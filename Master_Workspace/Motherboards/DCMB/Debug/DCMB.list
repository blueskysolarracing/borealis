
DCMB.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000298  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0002231c  080002a0  080002a0  000102a0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000b7880  080225bc  080225bc  000325bc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  080d9e3c  080d9e3c  000f0248  2**0
                  CONTENTS
  4 .ARM          00000008  080d9e3c  080d9e3c  000e9e3c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  080d9e44  080d9e44  000f0248  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  080d9e44  080d9e44  000e9e44  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  080d9e48  080d9e48  000e9e48  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000248  24000000  080d9e4c  000f0000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00063458  24000248  080da094  000f0248  2**2
                  ALLOC
 10 ._user_heap_stack 00000c00  240636a0  080da094  000f36a0  2**0
                  ALLOC
 11 .ARM.attributes 0000002e  00000000  00000000  000f0248  2**0
                  CONTENTS, READONLY
 12 .debug_info   0008b586  00000000  00000000  000f0276  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 0000ea9c  00000000  00000000  0017b7fc  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 000032f0  00000000  00000000  0018a298  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_ranges 00002ee0  00000000  00000000  0018d588  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  00050f90  00000000  00000000  00190468  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   000630a6  00000000  00000000  001e13f8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    001a17f8  00000000  00000000  0024449e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000053  00000000  00000000  003e5c96  2**0
                  CONTENTS, READONLY
 20 .debug_frame  0000ce08  00000000  00000000  003e5cec  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080002a0 <__do_global_dtors_aux>:
 80002a0:	b510      	push	{r4, lr}
 80002a2:	4c05      	ldr	r4, [pc, #20]	; (80002b8 <__do_global_dtors_aux+0x18>)
 80002a4:	7823      	ldrb	r3, [r4, #0]
 80002a6:	b933      	cbnz	r3, 80002b6 <__do_global_dtors_aux+0x16>
 80002a8:	4b04      	ldr	r3, [pc, #16]	; (80002bc <__do_global_dtors_aux+0x1c>)
 80002aa:	b113      	cbz	r3, 80002b2 <__do_global_dtors_aux+0x12>
 80002ac:	4804      	ldr	r0, [pc, #16]	; (80002c0 <__do_global_dtors_aux+0x20>)
 80002ae:	f3af 8000 	nop.w
 80002b2:	2301      	movs	r3, #1
 80002b4:	7023      	strb	r3, [r4, #0]
 80002b6:	bd10      	pop	{r4, pc}
 80002b8:	24000248 	.word	0x24000248
 80002bc:	00000000 	.word	0x00000000
 80002c0:	080225a4 	.word	0x080225a4

080002c4 <frame_dummy>:
 80002c4:	b508      	push	{r3, lr}
 80002c6:	4b03      	ldr	r3, [pc, #12]	; (80002d4 <frame_dummy+0x10>)
 80002c8:	b11b      	cbz	r3, 80002d2 <frame_dummy+0xe>
 80002ca:	4903      	ldr	r1, [pc, #12]	; (80002d8 <frame_dummy+0x14>)
 80002cc:	4803      	ldr	r0, [pc, #12]	; (80002dc <frame_dummy+0x18>)
 80002ce:	f3af 8000 	nop.w
 80002d2:	bd08      	pop	{r3, pc}
 80002d4:	00000000 	.word	0x00000000
 80002d8:	2400024c 	.word	0x2400024c
 80002dc:	080225a4 	.word	0x080225a4

080002e0 <strcmp>:
 80002e0:	f810 2b01 	ldrb.w	r2, [r0], #1
 80002e4:	f811 3b01 	ldrb.w	r3, [r1], #1
 80002e8:	2a01      	cmp	r2, #1
 80002ea:	bf28      	it	cs
 80002ec:	429a      	cmpcs	r2, r3
 80002ee:	d0f7      	beq.n	80002e0 <strcmp>
 80002f0:	1ad0      	subs	r0, r2, r3
 80002f2:	4770      	bx	lr

080002f4 <strlen>:
 80002f4:	4603      	mov	r3, r0
 80002f6:	f813 2b01 	ldrb.w	r2, [r3], #1
 80002fa:	2a00      	cmp	r2, #0
 80002fc:	d1fb      	bne.n	80002f6 <strlen+0x2>
 80002fe:	1a18      	subs	r0, r3, r0
 8000300:	3801      	subs	r0, #1
 8000302:	4770      	bx	lr
	...

08000310 <memchr>:
 8000310:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000314:	2a10      	cmp	r2, #16
 8000316:	db2b      	blt.n	8000370 <memchr+0x60>
 8000318:	f010 0f07 	tst.w	r0, #7
 800031c:	d008      	beq.n	8000330 <memchr+0x20>
 800031e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000322:	3a01      	subs	r2, #1
 8000324:	428b      	cmp	r3, r1
 8000326:	d02d      	beq.n	8000384 <memchr+0x74>
 8000328:	f010 0f07 	tst.w	r0, #7
 800032c:	b342      	cbz	r2, 8000380 <memchr+0x70>
 800032e:	d1f6      	bne.n	800031e <memchr+0xe>
 8000330:	b4f0      	push	{r4, r5, r6, r7}
 8000332:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000336:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800033a:	f022 0407 	bic.w	r4, r2, #7
 800033e:	f07f 0700 	mvns.w	r7, #0
 8000342:	2300      	movs	r3, #0
 8000344:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000348:	3c08      	subs	r4, #8
 800034a:	ea85 0501 	eor.w	r5, r5, r1
 800034e:	ea86 0601 	eor.w	r6, r6, r1
 8000352:	fa85 f547 	uadd8	r5, r5, r7
 8000356:	faa3 f587 	sel	r5, r3, r7
 800035a:	fa86 f647 	uadd8	r6, r6, r7
 800035e:	faa5 f687 	sel	r6, r5, r7
 8000362:	b98e      	cbnz	r6, 8000388 <memchr+0x78>
 8000364:	d1ee      	bne.n	8000344 <memchr+0x34>
 8000366:	bcf0      	pop	{r4, r5, r6, r7}
 8000368:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800036c:	f002 0207 	and.w	r2, r2, #7
 8000370:	b132      	cbz	r2, 8000380 <memchr+0x70>
 8000372:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000376:	3a01      	subs	r2, #1
 8000378:	ea83 0301 	eor.w	r3, r3, r1
 800037c:	b113      	cbz	r3, 8000384 <memchr+0x74>
 800037e:	d1f8      	bne.n	8000372 <memchr+0x62>
 8000380:	2000      	movs	r0, #0
 8000382:	4770      	bx	lr
 8000384:	3801      	subs	r0, #1
 8000386:	4770      	bx	lr
 8000388:	2d00      	cmp	r5, #0
 800038a:	bf06      	itte	eq
 800038c:	4635      	moveq	r5, r6
 800038e:	3803      	subeq	r0, #3
 8000390:	3807      	subne	r0, #7
 8000392:	f015 0f01 	tst.w	r5, #1
 8000396:	d107      	bne.n	80003a8 <memchr+0x98>
 8000398:	3001      	adds	r0, #1
 800039a:	f415 7f80 	tst.w	r5, #256	; 0x100
 800039e:	bf02      	ittt	eq
 80003a0:	3001      	addeq	r0, #1
 80003a2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 80003a6:	3001      	addeq	r0, #1
 80003a8:	bcf0      	pop	{r4, r5, r6, r7}
 80003aa:	3801      	subs	r0, #1
 80003ac:	4770      	bx	lr
 80003ae:	bf00      	nop

080003b0 <__aeabi_uldivmod>:
 80003b0:	b953      	cbnz	r3, 80003c8 <__aeabi_uldivmod+0x18>
 80003b2:	b94a      	cbnz	r2, 80003c8 <__aeabi_uldivmod+0x18>
 80003b4:	2900      	cmp	r1, #0
 80003b6:	bf08      	it	eq
 80003b8:	2800      	cmpeq	r0, #0
 80003ba:	bf1c      	itt	ne
 80003bc:	f04f 31ff 	movne.w	r1, #4294967295
 80003c0:	f04f 30ff 	movne.w	r0, #4294967295
 80003c4:	f000 b96e 	b.w	80006a4 <__aeabi_idiv0>
 80003c8:	f1ad 0c08 	sub.w	ip, sp, #8
 80003cc:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80003d0:	f000 f806 	bl	80003e0 <__udivmoddi4>
 80003d4:	f8dd e004 	ldr.w	lr, [sp, #4]
 80003d8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80003dc:	b004      	add	sp, #16
 80003de:	4770      	bx	lr

080003e0 <__udivmoddi4>:
 80003e0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80003e4:	9d08      	ldr	r5, [sp, #32]
 80003e6:	4604      	mov	r4, r0
 80003e8:	468c      	mov	ip, r1
 80003ea:	2b00      	cmp	r3, #0
 80003ec:	f040 8083 	bne.w	80004f6 <__udivmoddi4+0x116>
 80003f0:	428a      	cmp	r2, r1
 80003f2:	4617      	mov	r7, r2
 80003f4:	d947      	bls.n	8000486 <__udivmoddi4+0xa6>
 80003f6:	fab2 f282 	clz	r2, r2
 80003fa:	b142      	cbz	r2, 800040e <__udivmoddi4+0x2e>
 80003fc:	f1c2 0020 	rsb	r0, r2, #32
 8000400:	fa24 f000 	lsr.w	r0, r4, r0
 8000404:	4091      	lsls	r1, r2
 8000406:	4097      	lsls	r7, r2
 8000408:	ea40 0c01 	orr.w	ip, r0, r1
 800040c:	4094      	lsls	r4, r2
 800040e:	ea4f 4817 	mov.w	r8, r7, lsr #16
 8000412:	0c23      	lsrs	r3, r4, #16
 8000414:	fbbc f6f8 	udiv	r6, ip, r8
 8000418:	fa1f fe87 	uxth.w	lr, r7
 800041c:	fb08 c116 	mls	r1, r8, r6, ip
 8000420:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000424:	fb06 f10e 	mul.w	r1, r6, lr
 8000428:	4299      	cmp	r1, r3
 800042a:	d909      	bls.n	8000440 <__udivmoddi4+0x60>
 800042c:	18fb      	adds	r3, r7, r3
 800042e:	f106 30ff 	add.w	r0, r6, #4294967295
 8000432:	f080 8119 	bcs.w	8000668 <__udivmoddi4+0x288>
 8000436:	4299      	cmp	r1, r3
 8000438:	f240 8116 	bls.w	8000668 <__udivmoddi4+0x288>
 800043c:	3e02      	subs	r6, #2
 800043e:	443b      	add	r3, r7
 8000440:	1a5b      	subs	r3, r3, r1
 8000442:	b2a4      	uxth	r4, r4
 8000444:	fbb3 f0f8 	udiv	r0, r3, r8
 8000448:	fb08 3310 	mls	r3, r8, r0, r3
 800044c:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8000450:	fb00 fe0e 	mul.w	lr, r0, lr
 8000454:	45a6      	cmp	lr, r4
 8000456:	d909      	bls.n	800046c <__udivmoddi4+0x8c>
 8000458:	193c      	adds	r4, r7, r4
 800045a:	f100 33ff 	add.w	r3, r0, #4294967295
 800045e:	f080 8105 	bcs.w	800066c <__udivmoddi4+0x28c>
 8000462:	45a6      	cmp	lr, r4
 8000464:	f240 8102 	bls.w	800066c <__udivmoddi4+0x28c>
 8000468:	3802      	subs	r0, #2
 800046a:	443c      	add	r4, r7
 800046c:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 8000470:	eba4 040e 	sub.w	r4, r4, lr
 8000474:	2600      	movs	r6, #0
 8000476:	b11d      	cbz	r5, 8000480 <__udivmoddi4+0xa0>
 8000478:	40d4      	lsrs	r4, r2
 800047a:	2300      	movs	r3, #0
 800047c:	e9c5 4300 	strd	r4, r3, [r5]
 8000480:	4631      	mov	r1, r6
 8000482:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000486:	b902      	cbnz	r2, 800048a <__udivmoddi4+0xaa>
 8000488:	deff      	udf	#255	; 0xff
 800048a:	fab2 f282 	clz	r2, r2
 800048e:	2a00      	cmp	r2, #0
 8000490:	d150      	bne.n	8000534 <__udivmoddi4+0x154>
 8000492:	1bcb      	subs	r3, r1, r7
 8000494:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8000498:	fa1f f887 	uxth.w	r8, r7
 800049c:	2601      	movs	r6, #1
 800049e:	fbb3 fcfe 	udiv	ip, r3, lr
 80004a2:	0c21      	lsrs	r1, r4, #16
 80004a4:	fb0e 331c 	mls	r3, lr, ip, r3
 80004a8:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 80004ac:	fb08 f30c 	mul.w	r3, r8, ip
 80004b0:	428b      	cmp	r3, r1
 80004b2:	d907      	bls.n	80004c4 <__udivmoddi4+0xe4>
 80004b4:	1879      	adds	r1, r7, r1
 80004b6:	f10c 30ff 	add.w	r0, ip, #4294967295
 80004ba:	d202      	bcs.n	80004c2 <__udivmoddi4+0xe2>
 80004bc:	428b      	cmp	r3, r1
 80004be:	f200 80e9 	bhi.w	8000694 <__udivmoddi4+0x2b4>
 80004c2:	4684      	mov	ip, r0
 80004c4:	1ac9      	subs	r1, r1, r3
 80004c6:	b2a3      	uxth	r3, r4
 80004c8:	fbb1 f0fe 	udiv	r0, r1, lr
 80004cc:	fb0e 1110 	mls	r1, lr, r0, r1
 80004d0:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
 80004d4:	fb08 f800 	mul.w	r8, r8, r0
 80004d8:	45a0      	cmp	r8, r4
 80004da:	d907      	bls.n	80004ec <__udivmoddi4+0x10c>
 80004dc:	193c      	adds	r4, r7, r4
 80004de:	f100 33ff 	add.w	r3, r0, #4294967295
 80004e2:	d202      	bcs.n	80004ea <__udivmoddi4+0x10a>
 80004e4:	45a0      	cmp	r8, r4
 80004e6:	f200 80d9 	bhi.w	800069c <__udivmoddi4+0x2bc>
 80004ea:	4618      	mov	r0, r3
 80004ec:	eba4 0408 	sub.w	r4, r4, r8
 80004f0:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 80004f4:	e7bf      	b.n	8000476 <__udivmoddi4+0x96>
 80004f6:	428b      	cmp	r3, r1
 80004f8:	d909      	bls.n	800050e <__udivmoddi4+0x12e>
 80004fa:	2d00      	cmp	r5, #0
 80004fc:	f000 80b1 	beq.w	8000662 <__udivmoddi4+0x282>
 8000500:	2600      	movs	r6, #0
 8000502:	e9c5 0100 	strd	r0, r1, [r5]
 8000506:	4630      	mov	r0, r6
 8000508:	4631      	mov	r1, r6
 800050a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800050e:	fab3 f683 	clz	r6, r3
 8000512:	2e00      	cmp	r6, #0
 8000514:	d14a      	bne.n	80005ac <__udivmoddi4+0x1cc>
 8000516:	428b      	cmp	r3, r1
 8000518:	d302      	bcc.n	8000520 <__udivmoddi4+0x140>
 800051a:	4282      	cmp	r2, r0
 800051c:	f200 80b8 	bhi.w	8000690 <__udivmoddi4+0x2b0>
 8000520:	1a84      	subs	r4, r0, r2
 8000522:	eb61 0103 	sbc.w	r1, r1, r3
 8000526:	2001      	movs	r0, #1
 8000528:	468c      	mov	ip, r1
 800052a:	2d00      	cmp	r5, #0
 800052c:	d0a8      	beq.n	8000480 <__udivmoddi4+0xa0>
 800052e:	e9c5 4c00 	strd	r4, ip, [r5]
 8000532:	e7a5      	b.n	8000480 <__udivmoddi4+0xa0>
 8000534:	f1c2 0320 	rsb	r3, r2, #32
 8000538:	fa20 f603 	lsr.w	r6, r0, r3
 800053c:	4097      	lsls	r7, r2
 800053e:	fa01 f002 	lsl.w	r0, r1, r2
 8000542:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 8000546:	40d9      	lsrs	r1, r3
 8000548:	4330      	orrs	r0, r6
 800054a:	0c03      	lsrs	r3, r0, #16
 800054c:	fbb1 f6fe 	udiv	r6, r1, lr
 8000550:	fa1f f887 	uxth.w	r8, r7
 8000554:	fb0e 1116 	mls	r1, lr, r6, r1
 8000558:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 800055c:	fb06 f108 	mul.w	r1, r6, r8
 8000560:	4299      	cmp	r1, r3
 8000562:	fa04 f402 	lsl.w	r4, r4, r2
 8000566:	d909      	bls.n	800057c <__udivmoddi4+0x19c>
 8000568:	18fb      	adds	r3, r7, r3
 800056a:	f106 3cff 	add.w	ip, r6, #4294967295
 800056e:	f080 808d 	bcs.w	800068c <__udivmoddi4+0x2ac>
 8000572:	4299      	cmp	r1, r3
 8000574:	f240 808a 	bls.w	800068c <__udivmoddi4+0x2ac>
 8000578:	3e02      	subs	r6, #2
 800057a:	443b      	add	r3, r7
 800057c:	1a5b      	subs	r3, r3, r1
 800057e:	b281      	uxth	r1, r0
 8000580:	fbb3 f0fe 	udiv	r0, r3, lr
 8000584:	fb0e 3310 	mls	r3, lr, r0, r3
 8000588:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 800058c:	fb00 f308 	mul.w	r3, r0, r8
 8000590:	428b      	cmp	r3, r1
 8000592:	d907      	bls.n	80005a4 <__udivmoddi4+0x1c4>
 8000594:	1879      	adds	r1, r7, r1
 8000596:	f100 3cff 	add.w	ip, r0, #4294967295
 800059a:	d273      	bcs.n	8000684 <__udivmoddi4+0x2a4>
 800059c:	428b      	cmp	r3, r1
 800059e:	d971      	bls.n	8000684 <__udivmoddi4+0x2a4>
 80005a0:	3802      	subs	r0, #2
 80005a2:	4439      	add	r1, r7
 80005a4:	1acb      	subs	r3, r1, r3
 80005a6:	ea40 4606 	orr.w	r6, r0, r6, lsl #16
 80005aa:	e778      	b.n	800049e <__udivmoddi4+0xbe>
 80005ac:	f1c6 0c20 	rsb	ip, r6, #32
 80005b0:	fa03 f406 	lsl.w	r4, r3, r6
 80005b4:	fa22 f30c 	lsr.w	r3, r2, ip
 80005b8:	431c      	orrs	r4, r3
 80005ba:	fa20 f70c 	lsr.w	r7, r0, ip
 80005be:	fa01 f306 	lsl.w	r3, r1, r6
 80005c2:	ea4f 4e14 	mov.w	lr, r4, lsr #16
 80005c6:	fa21 f10c 	lsr.w	r1, r1, ip
 80005ca:	431f      	orrs	r7, r3
 80005cc:	0c3b      	lsrs	r3, r7, #16
 80005ce:	fbb1 f9fe 	udiv	r9, r1, lr
 80005d2:	fa1f f884 	uxth.w	r8, r4
 80005d6:	fb0e 1119 	mls	r1, lr, r9, r1
 80005da:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 80005de:	fb09 fa08 	mul.w	sl, r9, r8
 80005e2:	458a      	cmp	sl, r1
 80005e4:	fa02 f206 	lsl.w	r2, r2, r6
 80005e8:	fa00 f306 	lsl.w	r3, r0, r6
 80005ec:	d908      	bls.n	8000600 <__udivmoddi4+0x220>
 80005ee:	1861      	adds	r1, r4, r1
 80005f0:	f109 30ff 	add.w	r0, r9, #4294967295
 80005f4:	d248      	bcs.n	8000688 <__udivmoddi4+0x2a8>
 80005f6:	458a      	cmp	sl, r1
 80005f8:	d946      	bls.n	8000688 <__udivmoddi4+0x2a8>
 80005fa:	f1a9 0902 	sub.w	r9, r9, #2
 80005fe:	4421      	add	r1, r4
 8000600:	eba1 010a 	sub.w	r1, r1, sl
 8000604:	b2bf      	uxth	r7, r7
 8000606:	fbb1 f0fe 	udiv	r0, r1, lr
 800060a:	fb0e 1110 	mls	r1, lr, r0, r1
 800060e:	ea47 4701 	orr.w	r7, r7, r1, lsl #16
 8000612:	fb00 f808 	mul.w	r8, r0, r8
 8000616:	45b8      	cmp	r8, r7
 8000618:	d907      	bls.n	800062a <__udivmoddi4+0x24a>
 800061a:	19e7      	adds	r7, r4, r7
 800061c:	f100 31ff 	add.w	r1, r0, #4294967295
 8000620:	d22e      	bcs.n	8000680 <__udivmoddi4+0x2a0>
 8000622:	45b8      	cmp	r8, r7
 8000624:	d92c      	bls.n	8000680 <__udivmoddi4+0x2a0>
 8000626:	3802      	subs	r0, #2
 8000628:	4427      	add	r7, r4
 800062a:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 800062e:	eba7 0708 	sub.w	r7, r7, r8
 8000632:	fba0 8902 	umull	r8, r9, r0, r2
 8000636:	454f      	cmp	r7, r9
 8000638:	46c6      	mov	lr, r8
 800063a:	4649      	mov	r1, r9
 800063c:	d31a      	bcc.n	8000674 <__udivmoddi4+0x294>
 800063e:	d017      	beq.n	8000670 <__udivmoddi4+0x290>
 8000640:	b15d      	cbz	r5, 800065a <__udivmoddi4+0x27a>
 8000642:	ebb3 020e 	subs.w	r2, r3, lr
 8000646:	eb67 0701 	sbc.w	r7, r7, r1
 800064a:	fa07 fc0c 	lsl.w	ip, r7, ip
 800064e:	40f2      	lsrs	r2, r6
 8000650:	ea4c 0202 	orr.w	r2, ip, r2
 8000654:	40f7      	lsrs	r7, r6
 8000656:	e9c5 2700 	strd	r2, r7, [r5]
 800065a:	2600      	movs	r6, #0
 800065c:	4631      	mov	r1, r6
 800065e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000662:	462e      	mov	r6, r5
 8000664:	4628      	mov	r0, r5
 8000666:	e70b      	b.n	8000480 <__udivmoddi4+0xa0>
 8000668:	4606      	mov	r6, r0
 800066a:	e6e9      	b.n	8000440 <__udivmoddi4+0x60>
 800066c:	4618      	mov	r0, r3
 800066e:	e6fd      	b.n	800046c <__udivmoddi4+0x8c>
 8000670:	4543      	cmp	r3, r8
 8000672:	d2e5      	bcs.n	8000640 <__udivmoddi4+0x260>
 8000674:	ebb8 0e02 	subs.w	lr, r8, r2
 8000678:	eb69 0104 	sbc.w	r1, r9, r4
 800067c:	3801      	subs	r0, #1
 800067e:	e7df      	b.n	8000640 <__udivmoddi4+0x260>
 8000680:	4608      	mov	r0, r1
 8000682:	e7d2      	b.n	800062a <__udivmoddi4+0x24a>
 8000684:	4660      	mov	r0, ip
 8000686:	e78d      	b.n	80005a4 <__udivmoddi4+0x1c4>
 8000688:	4681      	mov	r9, r0
 800068a:	e7b9      	b.n	8000600 <__udivmoddi4+0x220>
 800068c:	4666      	mov	r6, ip
 800068e:	e775      	b.n	800057c <__udivmoddi4+0x19c>
 8000690:	4630      	mov	r0, r6
 8000692:	e74a      	b.n	800052a <__udivmoddi4+0x14a>
 8000694:	f1ac 0c02 	sub.w	ip, ip, #2
 8000698:	4439      	add	r1, r7
 800069a:	e713      	b.n	80004c4 <__udivmoddi4+0xe4>
 800069c:	3802      	subs	r0, #2
 800069e:	443c      	add	r4, r7
 80006a0:	e724      	b.n	80004ec <__udivmoddi4+0x10c>
 80006a2:	bf00      	nop

080006a4 <__aeabi_idiv0>:
 80006a4:	4770      	bx	lr
 80006a6:	bf00      	nop

080006a8 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 80006a8:	b580      	push	{r7, lr}
 80006aa:	b082      	sub	sp, #8
 80006ac:	af00      	add	r7, sp, #0
   __HAL_ART_CONFIG_BASE_ADDRESS(0x08100000UL);  /* Configure the Cortex-M4 ART Base address to the Flash Bank 2 : */
   __HAL_ART_ENABLE();                           /* Enable the Cortex-M4 ART */
#endif /* DUAL_CORE &&  CORE_CM4 */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80006ae:	2003      	movs	r0, #3
 80006b0:	f000 f90f 	bl	80008d2 <HAL_NVIC_SetPriorityGrouping>

  /* Update the SystemCoreClock global variable */
#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 80006b4:	f004 fa04 	bl	8004ac0 <HAL_RCC_GetSysClockFreq>
 80006b8:	4602      	mov	r2, r0
 80006ba:	4b15      	ldr	r3, [pc, #84]	; (8000710 <HAL_Init+0x68>)
 80006bc:	699b      	ldr	r3, [r3, #24]
 80006be:	0a1b      	lsrs	r3, r3, #8
 80006c0:	f003 030f 	and.w	r3, r3, #15
 80006c4:	4913      	ldr	r1, [pc, #76]	; (8000714 <HAL_Init+0x6c>)
 80006c6:	5ccb      	ldrb	r3, [r1, r3]
 80006c8:	f003 031f 	and.w	r3, r3, #31
 80006cc:	fa22 f303 	lsr.w	r3, r2, r3
 80006d0:	607b      	str	r3, [r7, #4]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos]) & 0x1FU);
#endif

  /* Update the SystemD2Clock global variable */
#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 80006d2:	4b0f      	ldr	r3, [pc, #60]	; (8000710 <HAL_Init+0x68>)
 80006d4:	699b      	ldr	r3, [r3, #24]
 80006d6:	f003 030f 	and.w	r3, r3, #15
 80006da:	4a0e      	ldr	r2, [pc, #56]	; (8000714 <HAL_Init+0x6c>)
 80006dc:	5cd3      	ldrb	r3, [r2, r3]
 80006de:	f003 031f 	and.w	r3, r3, #31
 80006e2:	687a      	ldr	r2, [r7, #4]
 80006e4:	fa22 f303 	lsr.w	r3, r2, r3
 80006e8:	4a0b      	ldr	r2, [pc, #44]	; (8000718 <HAL_Init+0x70>)
 80006ea:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
 80006ec:	4a0b      	ldr	r2, [pc, #44]	; (800071c <HAL_Init+0x74>)
 80006ee:	687b      	ldr	r3, [r7, #4]
 80006f0:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 80006f2:	2000      	movs	r0, #0
 80006f4:	f011 fb94 	bl	8011e20 <HAL_InitTick>
 80006f8:	4603      	mov	r3, r0
 80006fa:	2b00      	cmp	r3, #0
 80006fc:	d001      	beq.n	8000702 <HAL_Init+0x5a>
  {
    return HAL_ERROR;
 80006fe:	2301      	movs	r3, #1
 8000700:	e002      	b.n	8000708 <HAL_Init+0x60>
  }

  /* Init the low level hardware */
  HAL_MspInit();
 8000702:	f010 fc6f 	bl	8010fe4 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 8000706:	2300      	movs	r3, #0
}
 8000708:	4618      	mov	r0, r3
 800070a:	3708      	adds	r7, #8
 800070c:	46bd      	mov	sp, r7
 800070e:	bd80      	pop	{r7, pc}
 8000710:	58024400 	.word	0x58024400
 8000714:	080d9c9c 	.word	0x080d9c9c
 8000718:	240001a8 	.word	0x240001a8
 800071c:	240001a4 	.word	0x240001a4

08000720 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 8000720:	b480      	push	{r7}
 8000722:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
 8000724:	4b06      	ldr	r3, [pc, #24]	; (8000740 <HAL_IncTick+0x20>)
 8000726:	781b      	ldrb	r3, [r3, #0]
 8000728:	461a      	mov	r2, r3
 800072a:	4b06      	ldr	r3, [pc, #24]	; (8000744 <HAL_IncTick+0x24>)
 800072c:	681b      	ldr	r3, [r3, #0]
 800072e:	4413      	add	r3, r2
 8000730:	4a04      	ldr	r2, [pc, #16]	; (8000744 <HAL_IncTick+0x24>)
 8000732:	6013      	str	r3, [r2, #0]
}
 8000734:	bf00      	nop
 8000736:	46bd      	mov	sp, r7
 8000738:	f85d 7b04 	ldr.w	r7, [sp], #4
 800073c:	4770      	bx	lr
 800073e:	bf00      	nop
 8000740:	24000004 	.word	0x24000004
 8000744:	2406243c 	.word	0x2406243c

08000748 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 8000748:	b480      	push	{r7}
 800074a:	af00      	add	r7, sp, #0
  return uwTick;
 800074c:	4b03      	ldr	r3, [pc, #12]	; (800075c <HAL_GetTick+0x14>)
 800074e:	681b      	ldr	r3, [r3, #0]
}
 8000750:	4618      	mov	r0, r3
 8000752:	46bd      	mov	sp, r7
 8000754:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000758:	4770      	bx	lr
 800075a:	bf00      	nop
 800075c:	2406243c 	.word	0x2406243c

08000760 <HAL_GetREVID>:
/**
  * @brief  Returns the device revision identifier.
  * @retval Device revision identifier
  */
uint32_t HAL_GetREVID(void)
{
 8000760:	b480      	push	{r7}
 8000762:	af00      	add	r7, sp, #0
   return((DBGMCU->IDCODE) >> 16);
 8000764:	4b03      	ldr	r3, [pc, #12]	; (8000774 <HAL_GetREVID+0x14>)
 8000766:	681b      	ldr	r3, [r3, #0]
 8000768:	0c1b      	lsrs	r3, r3, #16
}
 800076a:	4618      	mov	r0, r3
 800076c:	46bd      	mov	sp, r7
 800076e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000772:	4770      	bx	lr
 8000774:	5c001000 	.word	0x5c001000

08000778 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8000778:	b480      	push	{r7}
 800077a:	b085      	sub	sp, #20
 800077c:	af00      	add	r7, sp, #0
 800077e:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8000780:	687b      	ldr	r3, [r7, #4]
 8000782:	f003 0307 	and.w	r3, r3, #7
 8000786:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000788:	4b0b      	ldr	r3, [pc, #44]	; (80007b8 <__NVIC_SetPriorityGrouping+0x40>)
 800078a:	68db      	ldr	r3, [r3, #12]
 800078c:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800078e:	68ba      	ldr	r2, [r7, #8]
 8000790:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8000794:	4013      	ands	r3, r2
 8000796:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8000798:	68fb      	ldr	r3, [r7, #12]
 800079a:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800079c:	68bb      	ldr	r3, [r7, #8]
 800079e:	431a      	orrs	r2, r3
  reg_value  =  (reg_value                                   |
 80007a0:	4b06      	ldr	r3, [pc, #24]	; (80007bc <__NVIC_SetPriorityGrouping+0x44>)
 80007a2:	4313      	orrs	r3, r2
 80007a4:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 80007a6:	4a04      	ldr	r2, [pc, #16]	; (80007b8 <__NVIC_SetPriorityGrouping+0x40>)
 80007a8:	68bb      	ldr	r3, [r7, #8]
 80007aa:	60d3      	str	r3, [r2, #12]
}
 80007ac:	bf00      	nop
 80007ae:	3714      	adds	r7, #20
 80007b0:	46bd      	mov	sp, r7
 80007b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80007b6:	4770      	bx	lr
 80007b8:	e000ed00 	.word	0xe000ed00
 80007bc:	05fa0000 	.word	0x05fa0000

080007c0 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 80007c0:	b480      	push	{r7}
 80007c2:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80007c4:	4b04      	ldr	r3, [pc, #16]	; (80007d8 <__NVIC_GetPriorityGrouping+0x18>)
 80007c6:	68db      	ldr	r3, [r3, #12]
 80007c8:	0a1b      	lsrs	r3, r3, #8
 80007ca:	f003 0307 	and.w	r3, r3, #7
}
 80007ce:	4618      	mov	r0, r3
 80007d0:	46bd      	mov	sp, r7
 80007d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80007d6:	4770      	bx	lr
 80007d8:	e000ed00 	.word	0xe000ed00

080007dc <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 80007dc:	b480      	push	{r7}
 80007de:	b083      	sub	sp, #12
 80007e0:	af00      	add	r7, sp, #0
 80007e2:	4603      	mov	r3, r0
 80007e4:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
 80007e6:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 80007ea:	2b00      	cmp	r3, #0
 80007ec:	db0b      	blt.n	8000806 <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80007ee:	88fb      	ldrh	r3, [r7, #6]
 80007f0:	f003 021f 	and.w	r2, r3, #31
 80007f4:	4907      	ldr	r1, [pc, #28]	; (8000814 <__NVIC_EnableIRQ+0x38>)
 80007f6:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 80007fa:	095b      	lsrs	r3, r3, #5
 80007fc:	2001      	movs	r0, #1
 80007fe:	fa00 f202 	lsl.w	r2, r0, r2
 8000802:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
 8000806:	bf00      	nop
 8000808:	370c      	adds	r7, #12
 800080a:	46bd      	mov	sp, r7
 800080c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000810:	4770      	bx	lr
 8000812:	bf00      	nop
 8000814:	e000e100 	.word	0xe000e100

08000818 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8000818:	b480      	push	{r7}
 800081a:	b083      	sub	sp, #12
 800081c:	af00      	add	r7, sp, #0
 800081e:	4603      	mov	r3, r0
 8000820:	6039      	str	r1, [r7, #0]
 8000822:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
 8000824:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8000828:	2b00      	cmp	r3, #0
 800082a:	db0a      	blt.n	8000842 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800082c:	683b      	ldr	r3, [r7, #0]
 800082e:	b2da      	uxtb	r2, r3
 8000830:	490c      	ldr	r1, [pc, #48]	; (8000864 <__NVIC_SetPriority+0x4c>)
 8000832:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8000836:	0112      	lsls	r2, r2, #4
 8000838:	b2d2      	uxtb	r2, r2
 800083a:	440b      	add	r3, r1
 800083c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 8000840:	e00a      	b.n	8000858 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000842:	683b      	ldr	r3, [r7, #0]
 8000844:	b2da      	uxtb	r2, r3
 8000846:	4908      	ldr	r1, [pc, #32]	; (8000868 <__NVIC_SetPriority+0x50>)
 8000848:	88fb      	ldrh	r3, [r7, #6]
 800084a:	f003 030f 	and.w	r3, r3, #15
 800084e:	3b04      	subs	r3, #4
 8000850:	0112      	lsls	r2, r2, #4
 8000852:	b2d2      	uxtb	r2, r2
 8000854:	440b      	add	r3, r1
 8000856:	761a      	strb	r2, [r3, #24]
}
 8000858:	bf00      	nop
 800085a:	370c      	adds	r7, #12
 800085c:	46bd      	mov	sp, r7
 800085e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000862:	4770      	bx	lr
 8000864:	e000e100 	.word	0xe000e100
 8000868:	e000ed00 	.word	0xe000ed00

0800086c <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800086c:	b480      	push	{r7}
 800086e:	b089      	sub	sp, #36	; 0x24
 8000870:	af00      	add	r7, sp, #0
 8000872:	60f8      	str	r0, [r7, #12]
 8000874:	60b9      	str	r1, [r7, #8]
 8000876:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8000878:	68fb      	ldr	r3, [r7, #12]
 800087a:	f003 0307 	and.w	r3, r3, #7
 800087e:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000880:	69fb      	ldr	r3, [r7, #28]
 8000882:	f1c3 0307 	rsb	r3, r3, #7
 8000886:	2b04      	cmp	r3, #4
 8000888:	bf28      	it	cs
 800088a:	2304      	movcs	r3, #4
 800088c:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800088e:	69fb      	ldr	r3, [r7, #28]
 8000890:	3304      	adds	r3, #4
 8000892:	2b06      	cmp	r3, #6
 8000894:	d902      	bls.n	800089c <NVIC_EncodePriority+0x30>
 8000896:	69fb      	ldr	r3, [r7, #28]
 8000898:	3b03      	subs	r3, #3
 800089a:	e000      	b.n	800089e <NVIC_EncodePriority+0x32>
 800089c:	2300      	movs	r3, #0
 800089e:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80008a0:	f04f 32ff 	mov.w	r2, #4294967295
 80008a4:	69bb      	ldr	r3, [r7, #24]
 80008a6:	fa02 f303 	lsl.w	r3, r2, r3
 80008aa:	43da      	mvns	r2, r3
 80008ac:	68bb      	ldr	r3, [r7, #8]
 80008ae:	401a      	ands	r2, r3
 80008b0:	697b      	ldr	r3, [r7, #20]
 80008b2:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 80008b4:	f04f 31ff 	mov.w	r1, #4294967295
 80008b8:	697b      	ldr	r3, [r7, #20]
 80008ba:	fa01 f303 	lsl.w	r3, r1, r3
 80008be:	43d9      	mvns	r1, r3
 80008c0:	687b      	ldr	r3, [r7, #4]
 80008c2:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80008c4:	4313      	orrs	r3, r2
         );
}
 80008c6:	4618      	mov	r0, r3
 80008c8:	3724      	adds	r7, #36	; 0x24
 80008ca:	46bd      	mov	sp, r7
 80008cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80008d0:	4770      	bx	lr

080008d2 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 80008d2:	b580      	push	{r7, lr}
 80008d4:	b082      	sub	sp, #8
 80008d6:	af00      	add	r7, sp, #0
 80008d8:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 80008da:	6878      	ldr	r0, [r7, #4]
 80008dc:	f7ff ff4c 	bl	8000778 <__NVIC_SetPriorityGrouping>
}
 80008e0:	bf00      	nop
 80008e2:	3708      	adds	r7, #8
 80008e4:	46bd      	mov	sp, r7
 80008e6:	bd80      	pop	{r7, pc}

080008e8 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 80008e8:	b580      	push	{r7, lr}
 80008ea:	b086      	sub	sp, #24
 80008ec:	af00      	add	r7, sp, #0
 80008ee:	4603      	mov	r3, r0
 80008f0:	60b9      	str	r1, [r7, #8]
 80008f2:	607a      	str	r2, [r7, #4]
 80008f4:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();
 80008f6:	f7ff ff63 	bl	80007c0 <__NVIC_GetPriorityGrouping>
 80008fa:	6178      	str	r0, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 80008fc:	687a      	ldr	r2, [r7, #4]
 80008fe:	68b9      	ldr	r1, [r7, #8]
 8000900:	6978      	ldr	r0, [r7, #20]
 8000902:	f7ff ffb3 	bl	800086c <NVIC_EncodePriority>
 8000906:	4602      	mov	r2, r0
 8000908:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 800090c:	4611      	mov	r1, r2
 800090e:	4618      	mov	r0, r3
 8000910:	f7ff ff82 	bl	8000818 <__NVIC_SetPriority>
}
 8000914:	bf00      	nop
 8000916:	3718      	adds	r7, #24
 8000918:	46bd      	mov	sp, r7
 800091a:	bd80      	pop	{r7, pc}

0800091c <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 800091c:	b580      	push	{r7, lr}
 800091e:	b082      	sub	sp, #8
 8000920:	af00      	add	r7, sp, #0
 8000922:	4603      	mov	r3, r0
 8000924:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 8000926:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 800092a:	4618      	mov	r0, r3
 800092c:	f7ff ff56 	bl	80007dc <__NVIC_EnableIRQ>
}
 8000930:	bf00      	nop
 8000932:	3708      	adds	r7, #8
 8000934:	46bd      	mov	sp, r7
 8000936:	bd80      	pop	{r7, pc}

08000938 <HAL_CRC_Init>:
  *         parameters in the CRC_InitTypeDef and create the associated handle.
  * @param  hcrc CRC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CRC_Init(CRC_HandleTypeDef *hcrc)
{
 8000938:	b580      	push	{r7, lr}
 800093a:	b082      	sub	sp, #8
 800093c:	af00      	add	r7, sp, #0
 800093e:	6078      	str	r0, [r7, #4]
  /* Check the CRC handle allocation */
  if (hcrc == NULL)
 8000940:	687b      	ldr	r3, [r7, #4]
 8000942:	2b00      	cmp	r3, #0
 8000944:	d101      	bne.n	800094a <HAL_CRC_Init+0x12>
  {
    return HAL_ERROR;
 8000946:	2301      	movs	r3, #1
 8000948:	e054      	b.n	80009f4 <HAL_CRC_Init+0xbc>
  }

  /* Check the parameters */
  assert_param(IS_CRC_ALL_INSTANCE(hcrc->Instance));

  if (hcrc->State == HAL_CRC_STATE_RESET)
 800094a:	687b      	ldr	r3, [r7, #4]
 800094c:	7f5b      	ldrb	r3, [r3, #29]
 800094e:	b2db      	uxtb	r3, r3
 8000950:	2b00      	cmp	r3, #0
 8000952:	d105      	bne.n	8000960 <HAL_CRC_Init+0x28>
  {
    /* Allocate lock resource and initialize it */
    hcrc->Lock = HAL_UNLOCKED;
 8000954:	687b      	ldr	r3, [r7, #4]
 8000956:	2200      	movs	r2, #0
 8000958:	771a      	strb	r2, [r3, #28]
    /* Init the low level hardware */
    HAL_CRC_MspInit(hcrc);
 800095a:	6878      	ldr	r0, [r7, #4]
 800095c:	f010 fb60 	bl	8011020 <HAL_CRC_MspInit>
  }

  hcrc->State = HAL_CRC_STATE_BUSY;
 8000960:	687b      	ldr	r3, [r7, #4]
 8000962:	2202      	movs	r2, #2
 8000964:	775a      	strb	r2, [r3, #29]

  /* check whether or not non-default generating polynomial has been
   * picked up by user */
  assert_param(IS_DEFAULT_POLYNOMIAL(hcrc->Init.DefaultPolynomialUse));
  if (hcrc->Init.DefaultPolynomialUse == DEFAULT_POLYNOMIAL_ENABLE)
 8000966:	687b      	ldr	r3, [r7, #4]
 8000968:	791b      	ldrb	r3, [r3, #4]
 800096a:	2b00      	cmp	r3, #0
 800096c:	d10c      	bne.n	8000988 <HAL_CRC_Init+0x50>
  {
    /* initialize peripheral with default generating polynomial */
    WRITE_REG(hcrc->Instance->POL, DEFAULT_CRC32_POLY);
 800096e:	687b      	ldr	r3, [r7, #4]
 8000970:	681b      	ldr	r3, [r3, #0]
 8000972:	4a22      	ldr	r2, [pc, #136]	; (80009fc <HAL_CRC_Init+0xc4>)
 8000974:	615a      	str	r2, [r3, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, CRC_POLYLENGTH_32B);
 8000976:	687b      	ldr	r3, [r7, #4]
 8000978:	681b      	ldr	r3, [r3, #0]
 800097a:	689a      	ldr	r2, [r3, #8]
 800097c:	687b      	ldr	r3, [r7, #4]
 800097e:	681b      	ldr	r3, [r3, #0]
 8000980:	f022 0218 	bic.w	r2, r2, #24
 8000984:	609a      	str	r2, [r3, #8]
 8000986:	e00c      	b.n	80009a2 <HAL_CRC_Init+0x6a>
  }
  else
  {
    /* initialize CRC peripheral with generating polynomial defined by user */
    if (HAL_CRCEx_Polynomial_Set(hcrc, hcrc->Init.GeneratingPolynomial, hcrc->Init.CRCLength) != HAL_OK)
 8000988:	687b      	ldr	r3, [r7, #4]
 800098a:	6899      	ldr	r1, [r3, #8]
 800098c:	687b      	ldr	r3, [r7, #4]
 800098e:	68db      	ldr	r3, [r3, #12]
 8000990:	461a      	mov	r2, r3
 8000992:	6878      	ldr	r0, [r7, #4]
 8000994:	f000 f948 	bl	8000c28 <HAL_CRCEx_Polynomial_Set>
 8000998:	4603      	mov	r3, r0
 800099a:	2b00      	cmp	r3, #0
 800099c:	d001      	beq.n	80009a2 <HAL_CRC_Init+0x6a>
    {
      return HAL_ERROR;
 800099e:	2301      	movs	r3, #1
 80009a0:	e028      	b.n	80009f4 <HAL_CRC_Init+0xbc>
  }

  /* check whether or not non-default CRC initial value has been
   * picked up by user */
  assert_param(IS_DEFAULT_INIT_VALUE(hcrc->Init.DefaultInitValueUse));
  if (hcrc->Init.DefaultInitValueUse == DEFAULT_INIT_VALUE_ENABLE)
 80009a2:	687b      	ldr	r3, [r7, #4]
 80009a4:	795b      	ldrb	r3, [r3, #5]
 80009a6:	2b00      	cmp	r3, #0
 80009a8:	d105      	bne.n	80009b6 <HAL_CRC_Init+0x7e>
  {
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);
 80009aa:	687b      	ldr	r3, [r7, #4]
 80009ac:	681b      	ldr	r3, [r3, #0]
 80009ae:	f04f 32ff 	mov.w	r2, #4294967295
 80009b2:	611a      	str	r2, [r3, #16]
 80009b4:	e004      	b.n	80009c0 <HAL_CRC_Init+0x88>
  }
  else
  {
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 80009b6:	687b      	ldr	r3, [r7, #4]
 80009b8:	681b      	ldr	r3, [r3, #0]
 80009ba:	687a      	ldr	r2, [r7, #4]
 80009bc:	6912      	ldr	r2, [r2, #16]
 80009be:	611a      	str	r2, [r3, #16]
  }


  /* set input data inversion mode */
  assert_param(IS_CRC_INPUTDATA_INVERSION_MODE(hcrc->Init.InputDataInversionMode));
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode);
 80009c0:	687b      	ldr	r3, [r7, #4]
 80009c2:	681b      	ldr	r3, [r3, #0]
 80009c4:	689b      	ldr	r3, [r3, #8]
 80009c6:	f023 0160 	bic.w	r1, r3, #96	; 0x60
 80009ca:	687b      	ldr	r3, [r7, #4]
 80009cc:	695a      	ldr	r2, [r3, #20]
 80009ce:	687b      	ldr	r3, [r7, #4]
 80009d0:	681b      	ldr	r3, [r3, #0]
 80009d2:	430a      	orrs	r2, r1
 80009d4:	609a      	str	r2, [r3, #8]

  /* set output data inversion mode */
  assert_param(IS_CRC_OUTPUTDATA_INVERSION_MODE(hcrc->Init.OutputDataInversionMode));
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);
 80009d6:	687b      	ldr	r3, [r7, #4]
 80009d8:	681b      	ldr	r3, [r3, #0]
 80009da:	689b      	ldr	r3, [r3, #8]
 80009dc:	f023 0180 	bic.w	r1, r3, #128	; 0x80
 80009e0:	687b      	ldr	r3, [r7, #4]
 80009e2:	699a      	ldr	r2, [r3, #24]
 80009e4:	687b      	ldr	r3, [r7, #4]
 80009e6:	681b      	ldr	r3, [r3, #0]
 80009e8:	430a      	orrs	r2, r1
 80009ea:	609a      	str	r2, [r3, #8]
  /* makes sure the input data format (bytes, halfwords or words stream)
   * is properly specified by user */
  assert_param(IS_CRC_INPUTDATA_FORMAT(hcrc->InputDataFormat));

  /* Change CRC peripheral state */
  hcrc->State = HAL_CRC_STATE_READY;
 80009ec:	687b      	ldr	r3, [r7, #4]
 80009ee:	2201      	movs	r2, #1
 80009f0:	775a      	strb	r2, [r3, #29]

  /* Return function status */
  return HAL_OK;
 80009f2:	2300      	movs	r3, #0
}
 80009f4:	4618      	mov	r0, r3
 80009f6:	3708      	adds	r7, #8
 80009f8:	46bd      	mov	sp, r7
 80009fa:	bd80      	pop	{r7, pc}
 80009fc:	04c11db7 	.word	0x04c11db7

08000a00 <HAL_CRC_Calculate>:
  *        and the API will internally adjust its input data processing based on the
  *        handle field hcrc->InputDataFormat.
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */
uint32_t HAL_CRC_Calculate(CRC_HandleTypeDef *hcrc, uint32_t pBuffer[], uint32_t BufferLength)
{
 8000a00:	b580      	push	{r7, lr}
 8000a02:	b086      	sub	sp, #24
 8000a04:	af00      	add	r7, sp, #0
 8000a06:	60f8      	str	r0, [r7, #12]
 8000a08:	60b9      	str	r1, [r7, #8]
 8000a0a:	607a      	str	r2, [r7, #4]
  uint32_t index;      /* CRC input data buffer index */
  uint32_t temp = 0U;  /* CRC output (read from hcrc->Instance->DR register) */
 8000a0c:	2300      	movs	r3, #0
 8000a0e:	613b      	str	r3, [r7, #16]

  /* Change CRC peripheral state */
  hcrc->State = HAL_CRC_STATE_BUSY;
 8000a10:	68fb      	ldr	r3, [r7, #12]
 8000a12:	2202      	movs	r2, #2
 8000a14:	775a      	strb	r2, [r3, #29]

  /* Reset CRC Calculation Unit (hcrc->Instance->INIT is
  *  written in hcrc->Instance->DR) */
  __HAL_CRC_DR_RESET(hcrc);
 8000a16:	68fb      	ldr	r3, [r7, #12]
 8000a18:	681b      	ldr	r3, [r3, #0]
 8000a1a:	689a      	ldr	r2, [r3, #8]
 8000a1c:	68fb      	ldr	r3, [r7, #12]
 8000a1e:	681b      	ldr	r3, [r3, #0]
 8000a20:	f042 0201 	orr.w	r2, r2, #1
 8000a24:	609a      	str	r2, [r3, #8]

  switch (hcrc->InputDataFormat)
 8000a26:	68fb      	ldr	r3, [r7, #12]
 8000a28:	6a1b      	ldr	r3, [r3, #32]
 8000a2a:	2b03      	cmp	r3, #3
 8000a2c:	d006      	beq.n	8000a3c <HAL_CRC_Calculate+0x3c>
 8000a2e:	2b03      	cmp	r3, #3
 8000a30:	d829      	bhi.n	8000a86 <HAL_CRC_Calculate+0x86>
 8000a32:	2b01      	cmp	r3, #1
 8000a34:	d019      	beq.n	8000a6a <HAL_CRC_Calculate+0x6a>
 8000a36:	2b02      	cmp	r3, #2
 8000a38:	d01e      	beq.n	8000a78 <HAL_CRC_Calculate+0x78>
      /* Specific 16-bit input data handling  */
      temp = CRC_Handle_16(hcrc, (uint16_t *)(void *)pBuffer, BufferLength);    /* Derogation MisraC2012 R.11.5 */
      break;

    default:
      break;
 8000a3a:	e024      	b.n	8000a86 <HAL_CRC_Calculate+0x86>
      for (index = 0U; index < BufferLength; index++)
 8000a3c:	2300      	movs	r3, #0
 8000a3e:	617b      	str	r3, [r7, #20]
 8000a40:	e00a      	b.n	8000a58 <HAL_CRC_Calculate+0x58>
        hcrc->Instance->DR = pBuffer[index];
 8000a42:	697b      	ldr	r3, [r7, #20]
 8000a44:	009b      	lsls	r3, r3, #2
 8000a46:	68ba      	ldr	r2, [r7, #8]
 8000a48:	441a      	add	r2, r3
 8000a4a:	68fb      	ldr	r3, [r7, #12]
 8000a4c:	681b      	ldr	r3, [r3, #0]
 8000a4e:	6812      	ldr	r2, [r2, #0]
 8000a50:	601a      	str	r2, [r3, #0]
      for (index = 0U; index < BufferLength; index++)
 8000a52:	697b      	ldr	r3, [r7, #20]
 8000a54:	3301      	adds	r3, #1
 8000a56:	617b      	str	r3, [r7, #20]
 8000a58:	697a      	ldr	r2, [r7, #20]
 8000a5a:	687b      	ldr	r3, [r7, #4]
 8000a5c:	429a      	cmp	r2, r3
 8000a5e:	d3f0      	bcc.n	8000a42 <HAL_CRC_Calculate+0x42>
      temp = hcrc->Instance->DR;
 8000a60:	68fb      	ldr	r3, [r7, #12]
 8000a62:	681b      	ldr	r3, [r3, #0]
 8000a64:	681b      	ldr	r3, [r3, #0]
 8000a66:	613b      	str	r3, [r7, #16]
      break;
 8000a68:	e00e      	b.n	8000a88 <HAL_CRC_Calculate+0x88>
      temp = CRC_Handle_8(hcrc, (uint8_t *)pBuffer, BufferLength);
 8000a6a:	687a      	ldr	r2, [r7, #4]
 8000a6c:	68b9      	ldr	r1, [r7, #8]
 8000a6e:	68f8      	ldr	r0, [r7, #12]
 8000a70:	f000 f812 	bl	8000a98 <CRC_Handle_8>
 8000a74:	6138      	str	r0, [r7, #16]
      break;
 8000a76:	e007      	b.n	8000a88 <HAL_CRC_Calculate+0x88>
      temp = CRC_Handle_16(hcrc, (uint16_t *)(void *)pBuffer, BufferLength);    /* Derogation MisraC2012 R.11.5 */
 8000a78:	687a      	ldr	r2, [r7, #4]
 8000a7a:	68b9      	ldr	r1, [r7, #8]
 8000a7c:	68f8      	ldr	r0, [r7, #12]
 8000a7e:	f000 f899 	bl	8000bb4 <CRC_Handle_16>
 8000a82:	6138      	str	r0, [r7, #16]
      break;
 8000a84:	e000      	b.n	8000a88 <HAL_CRC_Calculate+0x88>
      break;
 8000a86:	bf00      	nop
  }

  /* Change CRC peripheral state */
  hcrc->State = HAL_CRC_STATE_READY;
 8000a88:	68fb      	ldr	r3, [r7, #12]
 8000a8a:	2201      	movs	r2, #1
 8000a8c:	775a      	strb	r2, [r3, #29]

  /* Return the CRC computed value */
  return temp;
 8000a8e:	693b      	ldr	r3, [r7, #16]
}
 8000a90:	4618      	mov	r0, r3
 8000a92:	3718      	adds	r7, #24
 8000a94:	46bd      	mov	sp, r7
 8000a96:	bd80      	pop	{r7, pc}

08000a98 <CRC_Handle_8>:
  * @param  pBuffer pointer to the input data buffer
  * @param  BufferLength input data buffer length
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */
static uint32_t CRC_Handle_8(CRC_HandleTypeDef *hcrc, uint8_t pBuffer[], uint32_t BufferLength)
{
 8000a98:	b480      	push	{r7}
 8000a9a:	b089      	sub	sp, #36	; 0x24
 8000a9c:	af00      	add	r7, sp, #0
 8000a9e:	60f8      	str	r0, [r7, #12]
 8000aa0:	60b9      	str	r1, [r7, #8]
 8000aa2:	607a      	str	r2, [r7, #4]
  __IO uint16_t *pReg;

  /* Processing time optimization: 4 bytes are entered in a row with a single word write,
   * last bytes must be carefully fed to the CRC calculator to ensure a correct type
   * handling by the peripheral */
  for (i = 0U; i < (BufferLength / 4U); i++)
 8000aa4:	2300      	movs	r3, #0
 8000aa6:	61fb      	str	r3, [r7, #28]
 8000aa8:	e023      	b.n	8000af2 <CRC_Handle_8+0x5a>
  {
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 8000aaa:	69fb      	ldr	r3, [r7, #28]
 8000aac:	009b      	lsls	r3, r3, #2
 8000aae:	68ba      	ldr	r2, [r7, #8]
 8000ab0:	4413      	add	r3, r2
 8000ab2:	781b      	ldrb	r3, [r3, #0]
 8000ab4:	061a      	lsls	r2, r3, #24
                         ((uint32_t)pBuffer[(4U * i) + 1U] << 16U) | \
 8000ab6:	69fb      	ldr	r3, [r7, #28]
 8000ab8:	009b      	lsls	r3, r3, #2
 8000aba:	3301      	adds	r3, #1
 8000abc:	68b9      	ldr	r1, [r7, #8]
 8000abe:	440b      	add	r3, r1
 8000ac0:	781b      	ldrb	r3, [r3, #0]
 8000ac2:	041b      	lsls	r3, r3, #16
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 8000ac4:	431a      	orrs	r2, r3
                         ((uint32_t)pBuffer[(4U * i) + 2U] << 8U)  | \
 8000ac6:	69fb      	ldr	r3, [r7, #28]
 8000ac8:	009b      	lsls	r3, r3, #2
 8000aca:	3302      	adds	r3, #2
 8000acc:	68b9      	ldr	r1, [r7, #8]
 8000ace:	440b      	add	r3, r1
 8000ad0:	781b      	ldrb	r3, [r3, #0]
 8000ad2:	021b      	lsls	r3, r3, #8
                         ((uint32_t)pBuffer[(4U * i) + 1U] << 16U) | \
 8000ad4:	431a      	orrs	r2, r3
                         (uint32_t)pBuffer[(4U * i) + 3U];
 8000ad6:	69fb      	ldr	r3, [r7, #28]
 8000ad8:	009b      	lsls	r3, r3, #2
 8000ada:	3303      	adds	r3, #3
 8000adc:	68b9      	ldr	r1, [r7, #8]
 8000ade:	440b      	add	r3, r1
 8000ae0:	781b      	ldrb	r3, [r3, #0]
 8000ae2:	4619      	mov	r1, r3
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 8000ae4:	68fb      	ldr	r3, [r7, #12]
 8000ae6:	681b      	ldr	r3, [r3, #0]
                         ((uint32_t)pBuffer[(4U * i) + 2U] << 8U)  | \
 8000ae8:	430a      	orrs	r2, r1
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 8000aea:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < (BufferLength / 4U); i++)
 8000aec:	69fb      	ldr	r3, [r7, #28]
 8000aee:	3301      	adds	r3, #1
 8000af0:	61fb      	str	r3, [r7, #28]
 8000af2:	687b      	ldr	r3, [r7, #4]
 8000af4:	089b      	lsrs	r3, r3, #2
 8000af6:	69fa      	ldr	r2, [r7, #28]
 8000af8:	429a      	cmp	r2, r3
 8000afa:	d3d6      	bcc.n	8000aaa <CRC_Handle_8+0x12>
  }
  /* last bytes specific handling */
  if ((BufferLength % 4U) != 0U)
 8000afc:	687b      	ldr	r3, [r7, #4]
 8000afe:	f003 0303 	and.w	r3, r3, #3
 8000b02:	2b00      	cmp	r3, #0
 8000b04:	d04d      	beq.n	8000ba2 <CRC_Handle_8+0x10a>
  {
    if ((BufferLength % 4U) == 1U)
 8000b06:	687b      	ldr	r3, [r7, #4]
 8000b08:	f003 0303 	and.w	r3, r3, #3
 8000b0c:	2b01      	cmp	r3, #1
 8000b0e:	d107      	bne.n	8000b20 <CRC_Handle_8+0x88>
    {
      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[4U * i];         /* Derogation MisraC2012 R.11.5 */
 8000b10:	69fb      	ldr	r3, [r7, #28]
 8000b12:	009b      	lsls	r3, r3, #2
 8000b14:	68ba      	ldr	r2, [r7, #8]
 8000b16:	4413      	add	r3, r2
 8000b18:	68fa      	ldr	r2, [r7, #12]
 8000b1a:	6812      	ldr	r2, [r2, #0]
 8000b1c:	781b      	ldrb	r3, [r3, #0]
 8000b1e:	7013      	strb	r3, [r2, #0]
    }
    if ((BufferLength % 4U) == 2U)
 8000b20:	687b      	ldr	r3, [r7, #4]
 8000b22:	f003 0303 	and.w	r3, r3, #3
 8000b26:	2b02      	cmp	r3, #2
 8000b28:	d116      	bne.n	8000b58 <CRC_Handle_8+0xc0>
    {
      data = ((uint16_t)(pBuffer[4U * i]) << 8U) | (uint16_t)pBuffer[(4U * i) + 1U];
 8000b2a:	69fb      	ldr	r3, [r7, #28]
 8000b2c:	009b      	lsls	r3, r3, #2
 8000b2e:	68ba      	ldr	r2, [r7, #8]
 8000b30:	4413      	add	r3, r2
 8000b32:	781b      	ldrb	r3, [r3, #0]
 8000b34:	021b      	lsls	r3, r3, #8
 8000b36:	b21a      	sxth	r2, r3
 8000b38:	69fb      	ldr	r3, [r7, #28]
 8000b3a:	009b      	lsls	r3, r3, #2
 8000b3c:	3301      	adds	r3, #1
 8000b3e:	68b9      	ldr	r1, [r7, #8]
 8000b40:	440b      	add	r3, r1
 8000b42:	781b      	ldrb	r3, [r3, #0]
 8000b44:	b21b      	sxth	r3, r3
 8000b46:	4313      	orrs	r3, r2
 8000b48:	b21b      	sxth	r3, r3
 8000b4a:	837b      	strh	r3, [r7, #26]
      pReg = (__IO uint16_t *)(__IO void *)(&hcrc->Instance->DR);                    /* Derogation MisraC2012 R.11.5 */
 8000b4c:	68fb      	ldr	r3, [r7, #12]
 8000b4e:	681b      	ldr	r3, [r3, #0]
 8000b50:	617b      	str	r3, [r7, #20]
      *pReg = data;
 8000b52:	697b      	ldr	r3, [r7, #20]
 8000b54:	8b7a      	ldrh	r2, [r7, #26]
 8000b56:	801a      	strh	r2, [r3, #0]
    }
    if ((BufferLength % 4U) == 3U)
 8000b58:	687b      	ldr	r3, [r7, #4]
 8000b5a:	f003 0303 	and.w	r3, r3, #3
 8000b5e:	2b03      	cmp	r3, #3
 8000b60:	d11f      	bne.n	8000ba2 <CRC_Handle_8+0x10a>
    {
      data = ((uint16_t)(pBuffer[4U * i]) << 8U) | (uint16_t)pBuffer[(4U * i) + 1U];
 8000b62:	69fb      	ldr	r3, [r7, #28]
 8000b64:	009b      	lsls	r3, r3, #2
 8000b66:	68ba      	ldr	r2, [r7, #8]
 8000b68:	4413      	add	r3, r2
 8000b6a:	781b      	ldrb	r3, [r3, #0]
 8000b6c:	021b      	lsls	r3, r3, #8
 8000b6e:	b21a      	sxth	r2, r3
 8000b70:	69fb      	ldr	r3, [r7, #28]
 8000b72:	009b      	lsls	r3, r3, #2
 8000b74:	3301      	adds	r3, #1
 8000b76:	68b9      	ldr	r1, [r7, #8]
 8000b78:	440b      	add	r3, r1
 8000b7a:	781b      	ldrb	r3, [r3, #0]
 8000b7c:	b21b      	sxth	r3, r3
 8000b7e:	4313      	orrs	r3, r2
 8000b80:	b21b      	sxth	r3, r3
 8000b82:	837b      	strh	r3, [r7, #26]
      pReg = (__IO uint16_t *)(__IO void *)(&hcrc->Instance->DR);                    /* Derogation MisraC2012 R.11.5 */
 8000b84:	68fb      	ldr	r3, [r7, #12]
 8000b86:	681b      	ldr	r3, [r3, #0]
 8000b88:	617b      	str	r3, [r7, #20]
      *pReg = data;
 8000b8a:	697b      	ldr	r3, [r7, #20]
 8000b8c:	8b7a      	ldrh	r2, [r7, #26]
 8000b8e:	801a      	strh	r2, [r3, #0]

      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[(4U * i) + 2U];  /* Derogation MisraC2012 R.11.5 */
 8000b90:	69fb      	ldr	r3, [r7, #28]
 8000b92:	009b      	lsls	r3, r3, #2
 8000b94:	3302      	adds	r3, #2
 8000b96:	68ba      	ldr	r2, [r7, #8]
 8000b98:	4413      	add	r3, r2
 8000b9a:	68fa      	ldr	r2, [r7, #12]
 8000b9c:	6812      	ldr	r2, [r2, #0]
 8000b9e:	781b      	ldrb	r3, [r3, #0]
 8000ba0:	7013      	strb	r3, [r2, #0]
    }
  }

  /* Return the CRC computed value */
  return hcrc->Instance->DR;
 8000ba2:	68fb      	ldr	r3, [r7, #12]
 8000ba4:	681b      	ldr	r3, [r3, #0]
 8000ba6:	681b      	ldr	r3, [r3, #0]
}
 8000ba8:	4618      	mov	r0, r3
 8000baa:	3724      	adds	r7, #36	; 0x24
 8000bac:	46bd      	mov	sp, r7
 8000bae:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000bb2:	4770      	bx	lr

08000bb4 <CRC_Handle_16>:
  * @param  pBuffer pointer to the input data buffer
  * @param  BufferLength input data buffer length
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */
static uint32_t CRC_Handle_16(CRC_HandleTypeDef *hcrc, uint16_t pBuffer[], uint32_t BufferLength)
{
 8000bb4:	b480      	push	{r7}
 8000bb6:	b087      	sub	sp, #28
 8000bb8:	af00      	add	r7, sp, #0
 8000bba:	60f8      	str	r0, [r7, #12]
 8000bbc:	60b9      	str	r1, [r7, #8]
 8000bbe:	607a      	str	r2, [r7, #4]
  __IO uint16_t *pReg;

  /* Processing time optimization: 2 HalfWords are entered in a row with a single word write,
   * in case of odd length, last HalfWord must be carefully fed to the CRC calculator to ensure
   * a correct type handling by the peripheral */
  for (i = 0U; i < (BufferLength / 2U); i++)
 8000bc0:	2300      	movs	r3, #0
 8000bc2:	617b      	str	r3, [r7, #20]
 8000bc4:	e013      	b.n	8000bee <CRC_Handle_16+0x3a>
  {
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 8000bc6:	697b      	ldr	r3, [r7, #20]
 8000bc8:	009b      	lsls	r3, r3, #2
 8000bca:	68ba      	ldr	r2, [r7, #8]
 8000bcc:	4413      	add	r3, r2
 8000bce:	881b      	ldrh	r3, [r3, #0]
 8000bd0:	041a      	lsls	r2, r3, #16
 8000bd2:	697b      	ldr	r3, [r7, #20]
 8000bd4:	009b      	lsls	r3, r3, #2
 8000bd6:	3302      	adds	r3, #2
 8000bd8:	68b9      	ldr	r1, [r7, #8]
 8000bda:	440b      	add	r3, r1
 8000bdc:	881b      	ldrh	r3, [r3, #0]
 8000bde:	4619      	mov	r1, r3
 8000be0:	68fb      	ldr	r3, [r7, #12]
 8000be2:	681b      	ldr	r3, [r3, #0]
 8000be4:	430a      	orrs	r2, r1
 8000be6:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < (BufferLength / 2U); i++)
 8000be8:	697b      	ldr	r3, [r7, #20]
 8000bea:	3301      	adds	r3, #1
 8000bec:	617b      	str	r3, [r7, #20]
 8000bee:	687b      	ldr	r3, [r7, #4]
 8000bf0:	085b      	lsrs	r3, r3, #1
 8000bf2:	697a      	ldr	r2, [r7, #20]
 8000bf4:	429a      	cmp	r2, r3
 8000bf6:	d3e6      	bcc.n	8000bc6 <CRC_Handle_16+0x12>
  }
  if ((BufferLength % 2U) != 0U)
 8000bf8:	687b      	ldr	r3, [r7, #4]
 8000bfa:	f003 0301 	and.w	r3, r3, #1
 8000bfe:	2b00      	cmp	r3, #0
 8000c00:	d009      	beq.n	8000c16 <CRC_Handle_16+0x62>
  {
    pReg = (__IO uint16_t *)(__IO void *)(&hcrc->Instance->DR);                 /* Derogation MisraC2012 R.11.5 */
 8000c02:	68fb      	ldr	r3, [r7, #12]
 8000c04:	681b      	ldr	r3, [r3, #0]
 8000c06:	613b      	str	r3, [r7, #16]
    *pReg = pBuffer[2U * i];
 8000c08:	697b      	ldr	r3, [r7, #20]
 8000c0a:	009b      	lsls	r3, r3, #2
 8000c0c:	68ba      	ldr	r2, [r7, #8]
 8000c0e:	4413      	add	r3, r2
 8000c10:	881a      	ldrh	r2, [r3, #0]
 8000c12:	693b      	ldr	r3, [r7, #16]
 8000c14:	801a      	strh	r2, [r3, #0]
  }

  /* Return the CRC computed value */
  return hcrc->Instance->DR;
 8000c16:	68fb      	ldr	r3, [r7, #12]
 8000c18:	681b      	ldr	r3, [r3, #0]
 8000c1a:	681b      	ldr	r3, [r3, #0]
}
 8000c1c:	4618      	mov	r0, r3
 8000c1e:	371c      	adds	r7, #28
 8000c20:	46bd      	mov	sp, r7
 8000c22:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000c26:	4770      	bx	lr

08000c28 <HAL_CRCEx_Polynomial_Set>:
  *          @arg @ref CRC_POLYLENGTH_16B 16-bit long CRC (generating polynomial of degree 16)
  *          @arg @ref CRC_POLYLENGTH_32B 32-bit long CRC (generating polynomial of degree 32)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CRCEx_Polynomial_Set(CRC_HandleTypeDef *hcrc, uint32_t Pol, uint32_t PolyLength)
{
 8000c28:	b480      	push	{r7}
 8000c2a:	b087      	sub	sp, #28
 8000c2c:	af00      	add	r7, sp, #0
 8000c2e:	60f8      	str	r0, [r7, #12]
 8000c30:	60b9      	str	r1, [r7, #8]
 8000c32:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 8000c34:	2300      	movs	r3, #0
 8000c36:	75fb      	strb	r3, [r7, #23]
  uint32_t msb = 31U; /* polynomial degree is 32 at most, so msb is initialized to max value */
 8000c38:	231f      	movs	r3, #31
 8000c3a:	613b      	str	r3, [r7, #16]
   * definition. HAL_ERROR is reported if Pol degree is
   * larger than that indicated by PolyLength.
   * Look for MSB position: msb will contain the degree of
   *  the second to the largest polynomial member. E.g., for
   *  X^7 + X^6 + X^5 + X^2 + 1, msb = 6. */
  while ((msb-- > 0U) && ((Pol & ((uint32_t)(0x1U) << (msb & 0x1FU))) == 0U))
 8000c3c:	bf00      	nop
 8000c3e:	693b      	ldr	r3, [r7, #16]
 8000c40:	1e5a      	subs	r2, r3, #1
 8000c42:	613a      	str	r2, [r7, #16]
 8000c44:	2b00      	cmp	r3, #0
 8000c46:	d009      	beq.n	8000c5c <HAL_CRCEx_Polynomial_Set+0x34>
 8000c48:	693b      	ldr	r3, [r7, #16]
 8000c4a:	f003 031f 	and.w	r3, r3, #31
 8000c4e:	68ba      	ldr	r2, [r7, #8]
 8000c50:	fa22 f303 	lsr.w	r3, r2, r3
 8000c54:	f003 0301 	and.w	r3, r3, #1
 8000c58:	2b00      	cmp	r3, #0
 8000c5a:	d0f0      	beq.n	8000c3e <HAL_CRCEx_Polynomial_Set+0x16>
 8000c5c:	687b      	ldr	r3, [r7, #4]
 8000c5e:	2b18      	cmp	r3, #24
 8000c60:	d846      	bhi.n	8000cf0 <HAL_CRCEx_Polynomial_Set+0xc8>
 8000c62:	a201      	add	r2, pc, #4	; (adr r2, 8000c68 <HAL_CRCEx_Polynomial_Set+0x40>)
 8000c64:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000c68:	08000cf7 	.word	0x08000cf7
 8000c6c:	08000cf1 	.word	0x08000cf1
 8000c70:	08000cf1 	.word	0x08000cf1
 8000c74:	08000cf1 	.word	0x08000cf1
 8000c78:	08000cf1 	.word	0x08000cf1
 8000c7c:	08000cf1 	.word	0x08000cf1
 8000c80:	08000cf1 	.word	0x08000cf1
 8000c84:	08000cf1 	.word	0x08000cf1
 8000c88:	08000ce5 	.word	0x08000ce5
 8000c8c:	08000cf1 	.word	0x08000cf1
 8000c90:	08000cf1 	.word	0x08000cf1
 8000c94:	08000cf1 	.word	0x08000cf1
 8000c98:	08000cf1 	.word	0x08000cf1
 8000c9c:	08000cf1 	.word	0x08000cf1
 8000ca0:	08000cf1 	.word	0x08000cf1
 8000ca4:	08000cf1 	.word	0x08000cf1
 8000ca8:	08000cd9 	.word	0x08000cd9
 8000cac:	08000cf1 	.word	0x08000cf1
 8000cb0:	08000cf1 	.word	0x08000cf1
 8000cb4:	08000cf1 	.word	0x08000cf1
 8000cb8:	08000cf1 	.word	0x08000cf1
 8000cbc:	08000cf1 	.word	0x08000cf1
 8000cc0:	08000cf1 	.word	0x08000cf1
 8000cc4:	08000cf1 	.word	0x08000cf1
 8000cc8:	08000ccd 	.word	0x08000ccd
  }

  switch (PolyLength)
  {
    case CRC_POLYLENGTH_7B:
      if (msb >= HAL_CRC_LENGTH_7B)
 8000ccc:	693b      	ldr	r3, [r7, #16]
 8000cce:	2b06      	cmp	r3, #6
 8000cd0:	d913      	bls.n	8000cfa <HAL_CRCEx_Polynomial_Set+0xd2>
      {
        status =   HAL_ERROR;
 8000cd2:	2301      	movs	r3, #1
 8000cd4:	75fb      	strb	r3, [r7, #23]
      }
      break;
 8000cd6:	e010      	b.n	8000cfa <HAL_CRCEx_Polynomial_Set+0xd2>
    case CRC_POLYLENGTH_8B:
      if (msb >= HAL_CRC_LENGTH_8B)
 8000cd8:	693b      	ldr	r3, [r7, #16]
 8000cda:	2b07      	cmp	r3, #7
 8000cdc:	d90f      	bls.n	8000cfe <HAL_CRCEx_Polynomial_Set+0xd6>
      {
        status =   HAL_ERROR;
 8000cde:	2301      	movs	r3, #1
 8000ce0:	75fb      	strb	r3, [r7, #23]
      }
      break;
 8000ce2:	e00c      	b.n	8000cfe <HAL_CRCEx_Polynomial_Set+0xd6>
    case CRC_POLYLENGTH_16B:
      if (msb >= HAL_CRC_LENGTH_16B)
 8000ce4:	693b      	ldr	r3, [r7, #16]
 8000ce6:	2b0f      	cmp	r3, #15
 8000ce8:	d90b      	bls.n	8000d02 <HAL_CRCEx_Polynomial_Set+0xda>
      {
        status =   HAL_ERROR;
 8000cea:	2301      	movs	r3, #1
 8000cec:	75fb      	strb	r3, [r7, #23]
      }
      break;
 8000cee:	e008      	b.n	8000d02 <HAL_CRCEx_Polynomial_Set+0xda>

    case CRC_POLYLENGTH_32B:
      /* no polynomial definition vs. polynomial length issue possible */
      break;
    default:
      status =  HAL_ERROR;
 8000cf0:	2301      	movs	r3, #1
 8000cf2:	75fb      	strb	r3, [r7, #23]
      break;
 8000cf4:	e006      	b.n	8000d04 <HAL_CRCEx_Polynomial_Set+0xdc>
      break;
 8000cf6:	bf00      	nop
 8000cf8:	e004      	b.n	8000d04 <HAL_CRCEx_Polynomial_Set+0xdc>
      break;
 8000cfa:	bf00      	nop
 8000cfc:	e002      	b.n	8000d04 <HAL_CRCEx_Polynomial_Set+0xdc>
      break;
 8000cfe:	bf00      	nop
 8000d00:	e000      	b.n	8000d04 <HAL_CRCEx_Polynomial_Set+0xdc>
      break;
 8000d02:	bf00      	nop
  }
  if (status == HAL_OK)
 8000d04:	7dfb      	ldrb	r3, [r7, #23]
 8000d06:	2b00      	cmp	r3, #0
 8000d08:	d10d      	bne.n	8000d26 <HAL_CRCEx_Polynomial_Set+0xfe>
  {
    /* set generating polynomial */
    WRITE_REG(hcrc->Instance->POL, Pol);
 8000d0a:	68fb      	ldr	r3, [r7, #12]
 8000d0c:	681b      	ldr	r3, [r3, #0]
 8000d0e:	68ba      	ldr	r2, [r7, #8]
 8000d10:	615a      	str	r2, [r3, #20]

    /* set generating polynomial size */
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);
 8000d12:	68fb      	ldr	r3, [r7, #12]
 8000d14:	681b      	ldr	r3, [r3, #0]
 8000d16:	689b      	ldr	r3, [r3, #8]
 8000d18:	f023 0118 	bic.w	r1, r3, #24
 8000d1c:	68fb      	ldr	r3, [r7, #12]
 8000d1e:	681b      	ldr	r3, [r3, #0]
 8000d20:	687a      	ldr	r2, [r7, #4]
 8000d22:	430a      	orrs	r2, r1
 8000d24:	609a      	str	r2, [r3, #8]
  }
  /* Return function status */
  return status;
 8000d26:	7dfb      	ldrb	r3, [r7, #23]
}
 8000d28:	4618      	mov	r0, r3
 8000d2a:	371c      	adds	r7, #28
 8000d2c:	46bd      	mov	sp, r7
 8000d2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000d32:	4770      	bx	lr

08000d34 <HAL_DMA_Init>:
  * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
 8000d34:	b580      	push	{r7, lr}
 8000d36:	b086      	sub	sp, #24
 8000d38:	af00      	add	r7, sp, #0
 8000d3a:	6078      	str	r0, [r7, #4]
  uint32_t registerValue;
  uint32_t tickstart = HAL_GetTick();
 8000d3c:	f7ff fd04 	bl	8000748 <HAL_GetTick>
 8000d40:	6138      	str	r0, [r7, #16]
  DMA_Base_Registers *regs_dma;
  BDMA_Base_Registers *regs_bdma;

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
 8000d42:	687b      	ldr	r3, [r7, #4]
 8000d44:	2b00      	cmp	r3, #0
 8000d46:	d101      	bne.n	8000d4c <HAL_DMA_Init+0x18>
  {
    return HAL_ERROR;
 8000d48:	2301      	movs	r3, #1
 8000d4a:	e316      	b.n	800137a <HAL_DMA_Init+0x646>
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8000d4c:	687b      	ldr	r3, [r7, #4]
 8000d4e:	681b      	ldr	r3, [r3, #0]
 8000d50:	4a66      	ldr	r2, [pc, #408]	; (8000eec <HAL_DMA_Init+0x1b8>)
 8000d52:	4293      	cmp	r3, r2
 8000d54:	d04a      	beq.n	8000dec <HAL_DMA_Init+0xb8>
 8000d56:	687b      	ldr	r3, [r7, #4]
 8000d58:	681b      	ldr	r3, [r3, #0]
 8000d5a:	4a65      	ldr	r2, [pc, #404]	; (8000ef0 <HAL_DMA_Init+0x1bc>)
 8000d5c:	4293      	cmp	r3, r2
 8000d5e:	d045      	beq.n	8000dec <HAL_DMA_Init+0xb8>
 8000d60:	687b      	ldr	r3, [r7, #4]
 8000d62:	681b      	ldr	r3, [r3, #0]
 8000d64:	4a63      	ldr	r2, [pc, #396]	; (8000ef4 <HAL_DMA_Init+0x1c0>)
 8000d66:	4293      	cmp	r3, r2
 8000d68:	d040      	beq.n	8000dec <HAL_DMA_Init+0xb8>
 8000d6a:	687b      	ldr	r3, [r7, #4]
 8000d6c:	681b      	ldr	r3, [r3, #0]
 8000d6e:	4a62      	ldr	r2, [pc, #392]	; (8000ef8 <HAL_DMA_Init+0x1c4>)
 8000d70:	4293      	cmp	r3, r2
 8000d72:	d03b      	beq.n	8000dec <HAL_DMA_Init+0xb8>
 8000d74:	687b      	ldr	r3, [r7, #4]
 8000d76:	681b      	ldr	r3, [r3, #0]
 8000d78:	4a60      	ldr	r2, [pc, #384]	; (8000efc <HAL_DMA_Init+0x1c8>)
 8000d7a:	4293      	cmp	r3, r2
 8000d7c:	d036      	beq.n	8000dec <HAL_DMA_Init+0xb8>
 8000d7e:	687b      	ldr	r3, [r7, #4]
 8000d80:	681b      	ldr	r3, [r3, #0]
 8000d82:	4a5f      	ldr	r2, [pc, #380]	; (8000f00 <HAL_DMA_Init+0x1cc>)
 8000d84:	4293      	cmp	r3, r2
 8000d86:	d031      	beq.n	8000dec <HAL_DMA_Init+0xb8>
 8000d88:	687b      	ldr	r3, [r7, #4]
 8000d8a:	681b      	ldr	r3, [r3, #0]
 8000d8c:	4a5d      	ldr	r2, [pc, #372]	; (8000f04 <HAL_DMA_Init+0x1d0>)
 8000d8e:	4293      	cmp	r3, r2
 8000d90:	d02c      	beq.n	8000dec <HAL_DMA_Init+0xb8>
 8000d92:	687b      	ldr	r3, [r7, #4]
 8000d94:	681b      	ldr	r3, [r3, #0]
 8000d96:	4a5c      	ldr	r2, [pc, #368]	; (8000f08 <HAL_DMA_Init+0x1d4>)
 8000d98:	4293      	cmp	r3, r2
 8000d9a:	d027      	beq.n	8000dec <HAL_DMA_Init+0xb8>
 8000d9c:	687b      	ldr	r3, [r7, #4]
 8000d9e:	681b      	ldr	r3, [r3, #0]
 8000da0:	4a5a      	ldr	r2, [pc, #360]	; (8000f0c <HAL_DMA_Init+0x1d8>)
 8000da2:	4293      	cmp	r3, r2
 8000da4:	d022      	beq.n	8000dec <HAL_DMA_Init+0xb8>
 8000da6:	687b      	ldr	r3, [r7, #4]
 8000da8:	681b      	ldr	r3, [r3, #0]
 8000daa:	4a59      	ldr	r2, [pc, #356]	; (8000f10 <HAL_DMA_Init+0x1dc>)
 8000dac:	4293      	cmp	r3, r2
 8000dae:	d01d      	beq.n	8000dec <HAL_DMA_Init+0xb8>
 8000db0:	687b      	ldr	r3, [r7, #4]
 8000db2:	681b      	ldr	r3, [r3, #0]
 8000db4:	4a57      	ldr	r2, [pc, #348]	; (8000f14 <HAL_DMA_Init+0x1e0>)
 8000db6:	4293      	cmp	r3, r2
 8000db8:	d018      	beq.n	8000dec <HAL_DMA_Init+0xb8>
 8000dba:	687b      	ldr	r3, [r7, #4]
 8000dbc:	681b      	ldr	r3, [r3, #0]
 8000dbe:	4a56      	ldr	r2, [pc, #344]	; (8000f18 <HAL_DMA_Init+0x1e4>)
 8000dc0:	4293      	cmp	r3, r2
 8000dc2:	d013      	beq.n	8000dec <HAL_DMA_Init+0xb8>
 8000dc4:	687b      	ldr	r3, [r7, #4]
 8000dc6:	681b      	ldr	r3, [r3, #0]
 8000dc8:	4a54      	ldr	r2, [pc, #336]	; (8000f1c <HAL_DMA_Init+0x1e8>)
 8000dca:	4293      	cmp	r3, r2
 8000dcc:	d00e      	beq.n	8000dec <HAL_DMA_Init+0xb8>
 8000dce:	687b      	ldr	r3, [r7, #4]
 8000dd0:	681b      	ldr	r3, [r3, #0]
 8000dd2:	4a53      	ldr	r2, [pc, #332]	; (8000f20 <HAL_DMA_Init+0x1ec>)
 8000dd4:	4293      	cmp	r3, r2
 8000dd6:	d009      	beq.n	8000dec <HAL_DMA_Init+0xb8>
 8000dd8:	687b      	ldr	r3, [r7, #4]
 8000dda:	681b      	ldr	r3, [r3, #0]
 8000ddc:	4a51      	ldr	r2, [pc, #324]	; (8000f24 <HAL_DMA_Init+0x1f0>)
 8000dde:	4293      	cmp	r3, r2
 8000de0:	d004      	beq.n	8000dec <HAL_DMA_Init+0xb8>
 8000de2:	687b      	ldr	r3, [r7, #4]
 8000de4:	681b      	ldr	r3, [r3, #0]
 8000de6:	4a50      	ldr	r2, [pc, #320]	; (8000f28 <HAL_DMA_Init+0x1f4>)
 8000de8:	4293      	cmp	r3, r2
 8000dea:	d101      	bne.n	8000df0 <HAL_DMA_Init+0xbc>
 8000dec:	2301      	movs	r3, #1
 8000dee:	e000      	b.n	8000df2 <HAL_DMA_Init+0xbe>
 8000df0:	2300      	movs	r3, #0
 8000df2:	2b00      	cmp	r3, #0
 8000df4:	f000 813b 	beq.w	800106e <HAL_DMA_Init+0x33a>
      assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
      assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
    }

    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
 8000df8:	687b      	ldr	r3, [r7, #4]
 8000dfa:	2202      	movs	r2, #2
 8000dfc:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Allocate lock resource */
    __HAL_UNLOCK(hdma);
 8000e00:	687b      	ldr	r3, [r7, #4]
 8000e02:	2200      	movs	r2, #0
 8000e04:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Disable the peripheral */
    __HAL_DMA_DISABLE(hdma);
 8000e08:	687b      	ldr	r3, [r7, #4]
 8000e0a:	681b      	ldr	r3, [r3, #0]
 8000e0c:	4a37      	ldr	r2, [pc, #220]	; (8000eec <HAL_DMA_Init+0x1b8>)
 8000e0e:	4293      	cmp	r3, r2
 8000e10:	d04a      	beq.n	8000ea8 <HAL_DMA_Init+0x174>
 8000e12:	687b      	ldr	r3, [r7, #4]
 8000e14:	681b      	ldr	r3, [r3, #0]
 8000e16:	4a36      	ldr	r2, [pc, #216]	; (8000ef0 <HAL_DMA_Init+0x1bc>)
 8000e18:	4293      	cmp	r3, r2
 8000e1a:	d045      	beq.n	8000ea8 <HAL_DMA_Init+0x174>
 8000e1c:	687b      	ldr	r3, [r7, #4]
 8000e1e:	681b      	ldr	r3, [r3, #0]
 8000e20:	4a34      	ldr	r2, [pc, #208]	; (8000ef4 <HAL_DMA_Init+0x1c0>)
 8000e22:	4293      	cmp	r3, r2
 8000e24:	d040      	beq.n	8000ea8 <HAL_DMA_Init+0x174>
 8000e26:	687b      	ldr	r3, [r7, #4]
 8000e28:	681b      	ldr	r3, [r3, #0]
 8000e2a:	4a33      	ldr	r2, [pc, #204]	; (8000ef8 <HAL_DMA_Init+0x1c4>)
 8000e2c:	4293      	cmp	r3, r2
 8000e2e:	d03b      	beq.n	8000ea8 <HAL_DMA_Init+0x174>
 8000e30:	687b      	ldr	r3, [r7, #4]
 8000e32:	681b      	ldr	r3, [r3, #0]
 8000e34:	4a31      	ldr	r2, [pc, #196]	; (8000efc <HAL_DMA_Init+0x1c8>)
 8000e36:	4293      	cmp	r3, r2
 8000e38:	d036      	beq.n	8000ea8 <HAL_DMA_Init+0x174>
 8000e3a:	687b      	ldr	r3, [r7, #4]
 8000e3c:	681b      	ldr	r3, [r3, #0]
 8000e3e:	4a30      	ldr	r2, [pc, #192]	; (8000f00 <HAL_DMA_Init+0x1cc>)
 8000e40:	4293      	cmp	r3, r2
 8000e42:	d031      	beq.n	8000ea8 <HAL_DMA_Init+0x174>
 8000e44:	687b      	ldr	r3, [r7, #4]
 8000e46:	681b      	ldr	r3, [r3, #0]
 8000e48:	4a2e      	ldr	r2, [pc, #184]	; (8000f04 <HAL_DMA_Init+0x1d0>)
 8000e4a:	4293      	cmp	r3, r2
 8000e4c:	d02c      	beq.n	8000ea8 <HAL_DMA_Init+0x174>
 8000e4e:	687b      	ldr	r3, [r7, #4]
 8000e50:	681b      	ldr	r3, [r3, #0]
 8000e52:	4a2d      	ldr	r2, [pc, #180]	; (8000f08 <HAL_DMA_Init+0x1d4>)
 8000e54:	4293      	cmp	r3, r2
 8000e56:	d027      	beq.n	8000ea8 <HAL_DMA_Init+0x174>
 8000e58:	687b      	ldr	r3, [r7, #4]
 8000e5a:	681b      	ldr	r3, [r3, #0]
 8000e5c:	4a2b      	ldr	r2, [pc, #172]	; (8000f0c <HAL_DMA_Init+0x1d8>)
 8000e5e:	4293      	cmp	r3, r2
 8000e60:	d022      	beq.n	8000ea8 <HAL_DMA_Init+0x174>
 8000e62:	687b      	ldr	r3, [r7, #4]
 8000e64:	681b      	ldr	r3, [r3, #0]
 8000e66:	4a2a      	ldr	r2, [pc, #168]	; (8000f10 <HAL_DMA_Init+0x1dc>)
 8000e68:	4293      	cmp	r3, r2
 8000e6a:	d01d      	beq.n	8000ea8 <HAL_DMA_Init+0x174>
 8000e6c:	687b      	ldr	r3, [r7, #4]
 8000e6e:	681b      	ldr	r3, [r3, #0]
 8000e70:	4a28      	ldr	r2, [pc, #160]	; (8000f14 <HAL_DMA_Init+0x1e0>)
 8000e72:	4293      	cmp	r3, r2
 8000e74:	d018      	beq.n	8000ea8 <HAL_DMA_Init+0x174>
 8000e76:	687b      	ldr	r3, [r7, #4]
 8000e78:	681b      	ldr	r3, [r3, #0]
 8000e7a:	4a27      	ldr	r2, [pc, #156]	; (8000f18 <HAL_DMA_Init+0x1e4>)
 8000e7c:	4293      	cmp	r3, r2
 8000e7e:	d013      	beq.n	8000ea8 <HAL_DMA_Init+0x174>
 8000e80:	687b      	ldr	r3, [r7, #4]
 8000e82:	681b      	ldr	r3, [r3, #0]
 8000e84:	4a25      	ldr	r2, [pc, #148]	; (8000f1c <HAL_DMA_Init+0x1e8>)
 8000e86:	4293      	cmp	r3, r2
 8000e88:	d00e      	beq.n	8000ea8 <HAL_DMA_Init+0x174>
 8000e8a:	687b      	ldr	r3, [r7, #4]
 8000e8c:	681b      	ldr	r3, [r3, #0]
 8000e8e:	4a24      	ldr	r2, [pc, #144]	; (8000f20 <HAL_DMA_Init+0x1ec>)
 8000e90:	4293      	cmp	r3, r2
 8000e92:	d009      	beq.n	8000ea8 <HAL_DMA_Init+0x174>
 8000e94:	687b      	ldr	r3, [r7, #4]
 8000e96:	681b      	ldr	r3, [r3, #0]
 8000e98:	4a22      	ldr	r2, [pc, #136]	; (8000f24 <HAL_DMA_Init+0x1f0>)
 8000e9a:	4293      	cmp	r3, r2
 8000e9c:	d004      	beq.n	8000ea8 <HAL_DMA_Init+0x174>
 8000e9e:	687b      	ldr	r3, [r7, #4]
 8000ea0:	681b      	ldr	r3, [r3, #0]
 8000ea2:	4a21      	ldr	r2, [pc, #132]	; (8000f28 <HAL_DMA_Init+0x1f4>)
 8000ea4:	4293      	cmp	r3, r2
 8000ea6:	d108      	bne.n	8000eba <HAL_DMA_Init+0x186>
 8000ea8:	687b      	ldr	r3, [r7, #4]
 8000eaa:	681b      	ldr	r3, [r3, #0]
 8000eac:	681a      	ldr	r2, [r3, #0]
 8000eae:	687b      	ldr	r3, [r7, #4]
 8000eb0:	681b      	ldr	r3, [r3, #0]
 8000eb2:	f022 0201 	bic.w	r2, r2, #1
 8000eb6:	601a      	str	r2, [r3, #0]
 8000eb8:	e007      	b.n	8000eca <HAL_DMA_Init+0x196>
 8000eba:	687b      	ldr	r3, [r7, #4]
 8000ebc:	681b      	ldr	r3, [r3, #0]
 8000ebe:	681a      	ldr	r2, [r3, #0]
 8000ec0:	687b      	ldr	r3, [r7, #4]
 8000ec2:	681b      	ldr	r3, [r3, #0]
 8000ec4:	f022 0201 	bic.w	r2, r2, #1
 8000ec8:	601a      	str	r2, [r3, #0]

    /* Check if the DMA Stream is effectively disabled */
    while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
 8000eca:	e02f      	b.n	8000f2c <HAL_DMA_Init+0x1f8>
    {
      /* Check for the Timeout */
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 8000ecc:	f7ff fc3c 	bl	8000748 <HAL_GetTick>
 8000ed0:	4602      	mov	r2, r0
 8000ed2:	693b      	ldr	r3, [r7, #16]
 8000ed4:	1ad3      	subs	r3, r2, r3
 8000ed6:	2b05      	cmp	r3, #5
 8000ed8:	d928      	bls.n	8000f2c <HAL_DMA_Init+0x1f8>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 8000eda:	687b      	ldr	r3, [r7, #4]
 8000edc:	2220      	movs	r2, #32
 8000ede:	655a      	str	r2, [r3, #84]	; 0x54

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_ERROR;
 8000ee0:	687b      	ldr	r3, [r7, #4]
 8000ee2:	2203      	movs	r2, #3
 8000ee4:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        return HAL_ERROR;
 8000ee8:	2301      	movs	r3, #1
 8000eea:	e246      	b.n	800137a <HAL_DMA_Init+0x646>
 8000eec:	40020010 	.word	0x40020010
 8000ef0:	40020028 	.word	0x40020028
 8000ef4:	40020040 	.word	0x40020040
 8000ef8:	40020058 	.word	0x40020058
 8000efc:	40020070 	.word	0x40020070
 8000f00:	40020088 	.word	0x40020088
 8000f04:	400200a0 	.word	0x400200a0
 8000f08:	400200b8 	.word	0x400200b8
 8000f0c:	40020410 	.word	0x40020410
 8000f10:	40020428 	.word	0x40020428
 8000f14:	40020440 	.word	0x40020440
 8000f18:	40020458 	.word	0x40020458
 8000f1c:	40020470 	.word	0x40020470
 8000f20:	40020488 	.word	0x40020488
 8000f24:	400204a0 	.word	0x400204a0
 8000f28:	400204b8 	.word	0x400204b8
    while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
 8000f2c:	687b      	ldr	r3, [r7, #4]
 8000f2e:	681b      	ldr	r3, [r3, #0]
 8000f30:	681b      	ldr	r3, [r3, #0]
 8000f32:	f003 0301 	and.w	r3, r3, #1
 8000f36:	2b00      	cmp	r3, #0
 8000f38:	d1c8      	bne.n	8000ecc <HAL_DMA_Init+0x198>
      }
    }

    /* Get the CR register value */
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->CR;
 8000f3a:	687b      	ldr	r3, [r7, #4]
 8000f3c:	681b      	ldr	r3, [r3, #0]
 8000f3e:	681b      	ldr	r3, [r3, #0]
 8000f40:	617b      	str	r3, [r7, #20]

    /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
    registerValue &= ((uint32_t)~(DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8000f42:	697a      	ldr	r2, [r7, #20]
 8000f44:	4b83      	ldr	r3, [pc, #524]	; (8001154 <HAL_DMA_Init+0x420>)
 8000f46:	4013      	ands	r3, r2
 8000f48:	617b      	str	r3, [r7, #20]
                        DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                        DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                        DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

    /* Prepare the DMA Stream configuration */
    registerValue |=  hdma->Init.Direction           |
 8000f4a:	687b      	ldr	r3, [r7, #4]
 8000f4c:	689a      	ldr	r2, [r3, #8]
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8000f4e:	687b      	ldr	r3, [r7, #4]
 8000f50:	68db      	ldr	r3, [r3, #12]
    registerValue |=  hdma->Init.Direction           |
 8000f52:	431a      	orrs	r2, r3
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8000f54:	687b      	ldr	r3, [r7, #4]
 8000f56:	691b      	ldr	r3, [r3, #16]
 8000f58:	431a      	orrs	r2, r3
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8000f5a:	687b      	ldr	r3, [r7, #4]
 8000f5c:	695b      	ldr	r3, [r3, #20]
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8000f5e:	431a      	orrs	r2, r3
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8000f60:	687b      	ldr	r3, [r7, #4]
 8000f62:	699b      	ldr	r3, [r3, #24]
 8000f64:	431a      	orrs	r2, r3
            hdma->Init.Mode                | hdma->Init.Priority;
 8000f66:	687b      	ldr	r3, [r7, #4]
 8000f68:	69db      	ldr	r3, [r3, #28]
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8000f6a:	431a      	orrs	r2, r3
            hdma->Init.Mode                | hdma->Init.Priority;
 8000f6c:	687b      	ldr	r3, [r7, #4]
 8000f6e:	6a1b      	ldr	r3, [r3, #32]
 8000f70:	4313      	orrs	r3, r2
    registerValue |=  hdma->Init.Direction           |
 8000f72:	697a      	ldr	r2, [r7, #20]
 8000f74:	4313      	orrs	r3, r2
 8000f76:	617b      	str	r3, [r7, #20]

    /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8000f78:	687b      	ldr	r3, [r7, #4]
 8000f7a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000f7c:	2b04      	cmp	r3, #4
 8000f7e:	d107      	bne.n	8000f90 <HAL_DMA_Init+0x25c>
    {
      /* Get memory burst and peripheral burst */
      registerValue |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 8000f80:	687b      	ldr	r3, [r7, #4]
 8000f82:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000f84:	687b      	ldr	r3, [r7, #4]
 8000f86:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000f88:	4313      	orrs	r3, r2
 8000f8a:	697a      	ldr	r2, [r7, #20]
 8000f8c:	4313      	orrs	r3, r2
 8000f8e:	617b      	str	r3, [r7, #20]
    }

    /* Work around for Errata 2.22: UART/USART- DMA transfer lock: DMA stream could be
                                    lock when transferring data to/from USART/UART */
#if (STM32H7_DEV_ID == 0x450UL)
    if((DBGMCU->IDCODE & 0xFFFF0000U) >= 0x20000000U)
 8000f90:	4b71      	ldr	r3, [pc, #452]	; (8001158 <HAL_DMA_Init+0x424>)
 8000f92:	681a      	ldr	r2, [r3, #0]
 8000f94:	4b71      	ldr	r3, [pc, #452]	; (800115c <HAL_DMA_Init+0x428>)
 8000f96:	4013      	ands	r3, r2
 8000f98:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8000f9c:	d328      	bcc.n	8000ff0 <HAL_DMA_Init+0x2bc>
    {
#endif /* STM32H7_DEV_ID == 0x450UL */
      if(IS_DMA_UART_USART_REQUEST(hdma->Init.Request) != 0U)
 8000f9e:	687b      	ldr	r3, [r7, #4]
 8000fa0:	685b      	ldr	r3, [r3, #4]
 8000fa2:	2b28      	cmp	r3, #40	; 0x28
 8000fa4:	d903      	bls.n	8000fae <HAL_DMA_Init+0x27a>
 8000fa6:	687b      	ldr	r3, [r7, #4]
 8000fa8:	685b      	ldr	r3, [r3, #4]
 8000faa:	2b2e      	cmp	r3, #46	; 0x2e
 8000fac:	d917      	bls.n	8000fde <HAL_DMA_Init+0x2aa>
 8000fae:	687b      	ldr	r3, [r7, #4]
 8000fb0:	685b      	ldr	r3, [r3, #4]
 8000fb2:	2b3e      	cmp	r3, #62	; 0x3e
 8000fb4:	d903      	bls.n	8000fbe <HAL_DMA_Init+0x28a>
 8000fb6:	687b      	ldr	r3, [r7, #4]
 8000fb8:	685b      	ldr	r3, [r3, #4]
 8000fba:	2b42      	cmp	r3, #66	; 0x42
 8000fbc:	d90f      	bls.n	8000fde <HAL_DMA_Init+0x2aa>
 8000fbe:	687b      	ldr	r3, [r7, #4]
 8000fc0:	685b      	ldr	r3, [r3, #4]
 8000fc2:	2b46      	cmp	r3, #70	; 0x46
 8000fc4:	d903      	bls.n	8000fce <HAL_DMA_Init+0x29a>
 8000fc6:	687b      	ldr	r3, [r7, #4]
 8000fc8:	685b      	ldr	r3, [r3, #4]
 8000fca:	2b48      	cmp	r3, #72	; 0x48
 8000fcc:	d907      	bls.n	8000fde <HAL_DMA_Init+0x2aa>
 8000fce:	687b      	ldr	r3, [r7, #4]
 8000fd0:	685b      	ldr	r3, [r3, #4]
 8000fd2:	2b4e      	cmp	r3, #78	; 0x4e
 8000fd4:	d905      	bls.n	8000fe2 <HAL_DMA_Init+0x2ae>
 8000fd6:	687b      	ldr	r3, [r7, #4]
 8000fd8:	685b      	ldr	r3, [r3, #4]
 8000fda:	2b52      	cmp	r3, #82	; 0x52
 8000fdc:	d801      	bhi.n	8000fe2 <HAL_DMA_Init+0x2ae>
 8000fde:	2301      	movs	r3, #1
 8000fe0:	e000      	b.n	8000fe4 <HAL_DMA_Init+0x2b0>
 8000fe2:	2300      	movs	r3, #0
 8000fe4:	2b00      	cmp	r3, #0
 8000fe6:	d003      	beq.n	8000ff0 <HAL_DMA_Init+0x2bc>
      {
        registerValue |= DMA_SxCR_TRBUFF;
 8000fe8:	697b      	ldr	r3, [r7, #20]
 8000fea:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000fee:	617b      	str	r3, [r7, #20]
#if (STM32H7_DEV_ID == 0x450UL)
    }
#endif /* STM32H7_DEV_ID == 0x450UL */

    /* Write to DMA Stream CR register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR = registerValue;
 8000ff0:	687b      	ldr	r3, [r7, #4]
 8000ff2:	681b      	ldr	r3, [r3, #0]
 8000ff4:	697a      	ldr	r2, [r7, #20]
 8000ff6:	601a      	str	r2, [r3, #0]

    /* Get the FCR register value */
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR;
 8000ff8:	687b      	ldr	r3, [r7, #4]
 8000ffa:	681b      	ldr	r3, [r3, #0]
 8000ffc:	695b      	ldr	r3, [r3, #20]
 8000ffe:	617b      	str	r3, [r7, #20]

    /* Clear Direct mode and FIFO threshold bits */
    registerValue &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 8001000:	697b      	ldr	r3, [r7, #20]
 8001002:	f023 0307 	bic.w	r3, r3, #7
 8001006:	617b      	str	r3, [r7, #20]

    /* Prepare the DMA Stream FIFO configuration */
    registerValue |= hdma->Init.FIFOMode;
 8001008:	687b      	ldr	r3, [r7, #4]
 800100a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800100c:	697a      	ldr	r2, [r7, #20]
 800100e:	4313      	orrs	r3, r2
 8001010:	617b      	str	r3, [r7, #20]

    /* the FIFO threshold is not used when the FIFO mode is disabled */
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8001012:	687b      	ldr	r3, [r7, #4]
 8001014:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001016:	2b04      	cmp	r3, #4
 8001018:	d117      	bne.n	800104a <HAL_DMA_Init+0x316>
    {
      /* Get the FIFO threshold */
      registerValue |= hdma->Init.FIFOThreshold;
 800101a:	687b      	ldr	r3, [r7, #4]
 800101c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800101e:	697a      	ldr	r2, [r7, #20]
 8001020:	4313      	orrs	r3, r2
 8001022:	617b      	str	r3, [r7, #20]

      /* Check compatibility between FIFO threshold level and size of the memory burst */
      /* for INCR4, INCR8, INCR16 */
      if(hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 8001024:	687b      	ldr	r3, [r7, #4]
 8001026:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001028:	2b00      	cmp	r3, #0
 800102a:	d00e      	beq.n	800104a <HAL_DMA_Init+0x316>
      {
        if (DMA_CheckFifoParam(hdma) != HAL_OK)
 800102c:	6878      	ldr	r0, [r7, #4]
 800102e:	f002 fb31 	bl	8003694 <DMA_CheckFifoParam>
 8001032:	4603      	mov	r3, r0
 8001034:	2b00      	cmp	r3, #0
 8001036:	d008      	beq.n	800104a <HAL_DMA_Init+0x316>
        {
          /* Update error code */
          hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 8001038:	687b      	ldr	r3, [r7, #4]
 800103a:	2240      	movs	r2, #64	; 0x40
 800103c:	655a      	str	r2, [r3, #84]	; 0x54

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
 800103e:	687b      	ldr	r3, [r7, #4]
 8001040:	2201      	movs	r2, #1
 8001042:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

          return HAL_ERROR;
 8001046:	2301      	movs	r3, #1
 8001048:	e197      	b.n	800137a <HAL_DMA_Init+0x646>
        }
      }
    }

    /* Write to DMA Stream FCR */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR = registerValue;
 800104a:	687b      	ldr	r3, [r7, #4]
 800104c:	681b      	ldr	r3, [r3, #0]
 800104e:	697a      	ldr	r2, [r7, #20]
 8001050:	615a      	str	r2, [r3, #20]

    /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
       DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
    regs_dma = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 8001052:	6878      	ldr	r0, [r7, #4]
 8001054:	f002 fa6c 	bl	8003530 <DMA_CalcBaseAndBitshift>
 8001058:	4603      	mov	r3, r0
 800105a:	60bb      	str	r3, [r7, #8]

    /* Clear all interrupt flags */
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
 800105c:	687b      	ldr	r3, [r7, #4]
 800105e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8001060:	f003 031f 	and.w	r3, r3, #31
 8001064:	223f      	movs	r2, #63	; 0x3f
 8001066:	409a      	lsls	r2, r3
 8001068:	68bb      	ldr	r3, [r7, #8]
 800106a:	609a      	str	r2, [r3, #8]
 800106c:	e0cd      	b.n	800120a <HAL_DMA_Init+0x4d6>
  }
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
 800106e:	687b      	ldr	r3, [r7, #4]
 8001070:	681b      	ldr	r3, [r3, #0]
 8001072:	4a3b      	ldr	r2, [pc, #236]	; (8001160 <HAL_DMA_Init+0x42c>)
 8001074:	4293      	cmp	r3, r2
 8001076:	d022      	beq.n	80010be <HAL_DMA_Init+0x38a>
 8001078:	687b      	ldr	r3, [r7, #4]
 800107a:	681b      	ldr	r3, [r3, #0]
 800107c:	4a39      	ldr	r2, [pc, #228]	; (8001164 <HAL_DMA_Init+0x430>)
 800107e:	4293      	cmp	r3, r2
 8001080:	d01d      	beq.n	80010be <HAL_DMA_Init+0x38a>
 8001082:	687b      	ldr	r3, [r7, #4]
 8001084:	681b      	ldr	r3, [r3, #0]
 8001086:	4a38      	ldr	r2, [pc, #224]	; (8001168 <HAL_DMA_Init+0x434>)
 8001088:	4293      	cmp	r3, r2
 800108a:	d018      	beq.n	80010be <HAL_DMA_Init+0x38a>
 800108c:	687b      	ldr	r3, [r7, #4]
 800108e:	681b      	ldr	r3, [r3, #0]
 8001090:	4a36      	ldr	r2, [pc, #216]	; (800116c <HAL_DMA_Init+0x438>)
 8001092:	4293      	cmp	r3, r2
 8001094:	d013      	beq.n	80010be <HAL_DMA_Init+0x38a>
 8001096:	687b      	ldr	r3, [r7, #4]
 8001098:	681b      	ldr	r3, [r3, #0]
 800109a:	4a35      	ldr	r2, [pc, #212]	; (8001170 <HAL_DMA_Init+0x43c>)
 800109c:	4293      	cmp	r3, r2
 800109e:	d00e      	beq.n	80010be <HAL_DMA_Init+0x38a>
 80010a0:	687b      	ldr	r3, [r7, #4]
 80010a2:	681b      	ldr	r3, [r3, #0]
 80010a4:	4a33      	ldr	r2, [pc, #204]	; (8001174 <HAL_DMA_Init+0x440>)
 80010a6:	4293      	cmp	r3, r2
 80010a8:	d009      	beq.n	80010be <HAL_DMA_Init+0x38a>
 80010aa:	687b      	ldr	r3, [r7, #4]
 80010ac:	681b      	ldr	r3, [r3, #0]
 80010ae:	4a32      	ldr	r2, [pc, #200]	; (8001178 <HAL_DMA_Init+0x444>)
 80010b0:	4293      	cmp	r3, r2
 80010b2:	d004      	beq.n	80010be <HAL_DMA_Init+0x38a>
 80010b4:	687b      	ldr	r3, [r7, #4]
 80010b6:	681b      	ldr	r3, [r3, #0]
 80010b8:	4a30      	ldr	r2, [pc, #192]	; (800117c <HAL_DMA_Init+0x448>)
 80010ba:	4293      	cmp	r3, r2
 80010bc:	d101      	bne.n	80010c2 <HAL_DMA_Init+0x38e>
 80010be:	2301      	movs	r3, #1
 80010c0:	e000      	b.n	80010c4 <HAL_DMA_Init+0x390>
 80010c2:	2300      	movs	r3, #0
 80010c4:	2b00      	cmp	r3, #0
 80010c6:	f000 8097 	beq.w	80011f8 <HAL_DMA_Init+0x4c4>
  {
    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
 80010ca:	687b      	ldr	r3, [r7, #4]
 80010cc:	681b      	ldr	r3, [r3, #0]
 80010ce:	4a24      	ldr	r2, [pc, #144]	; (8001160 <HAL_DMA_Init+0x42c>)
 80010d0:	4293      	cmp	r3, r2
 80010d2:	d021      	beq.n	8001118 <HAL_DMA_Init+0x3e4>
 80010d4:	687b      	ldr	r3, [r7, #4]
 80010d6:	681b      	ldr	r3, [r3, #0]
 80010d8:	4a22      	ldr	r2, [pc, #136]	; (8001164 <HAL_DMA_Init+0x430>)
 80010da:	4293      	cmp	r3, r2
 80010dc:	d01c      	beq.n	8001118 <HAL_DMA_Init+0x3e4>
 80010de:	687b      	ldr	r3, [r7, #4]
 80010e0:	681b      	ldr	r3, [r3, #0]
 80010e2:	4a21      	ldr	r2, [pc, #132]	; (8001168 <HAL_DMA_Init+0x434>)
 80010e4:	4293      	cmp	r3, r2
 80010e6:	d017      	beq.n	8001118 <HAL_DMA_Init+0x3e4>
 80010e8:	687b      	ldr	r3, [r7, #4]
 80010ea:	681b      	ldr	r3, [r3, #0]
 80010ec:	4a1f      	ldr	r2, [pc, #124]	; (800116c <HAL_DMA_Init+0x438>)
 80010ee:	4293      	cmp	r3, r2
 80010f0:	d012      	beq.n	8001118 <HAL_DMA_Init+0x3e4>
 80010f2:	687b      	ldr	r3, [r7, #4]
 80010f4:	681b      	ldr	r3, [r3, #0]
 80010f6:	4a1e      	ldr	r2, [pc, #120]	; (8001170 <HAL_DMA_Init+0x43c>)
 80010f8:	4293      	cmp	r3, r2
 80010fa:	d00d      	beq.n	8001118 <HAL_DMA_Init+0x3e4>
 80010fc:	687b      	ldr	r3, [r7, #4]
 80010fe:	681b      	ldr	r3, [r3, #0]
 8001100:	4a1c      	ldr	r2, [pc, #112]	; (8001174 <HAL_DMA_Init+0x440>)
 8001102:	4293      	cmp	r3, r2
 8001104:	d008      	beq.n	8001118 <HAL_DMA_Init+0x3e4>
 8001106:	687b      	ldr	r3, [r7, #4]
 8001108:	681b      	ldr	r3, [r3, #0]
 800110a:	4a1b      	ldr	r2, [pc, #108]	; (8001178 <HAL_DMA_Init+0x444>)
 800110c:	4293      	cmp	r3, r2
 800110e:	d003      	beq.n	8001118 <HAL_DMA_Init+0x3e4>
 8001110:	687b      	ldr	r3, [r7, #4]
 8001112:	681b      	ldr	r3, [r3, #0]
 8001114:	4a19      	ldr	r2, [pc, #100]	; (800117c <HAL_DMA_Init+0x448>)
 8001116:	4293      	cmp	r3, r2
 8001118:	bf00      	nop
      /* Check the request parameter */
      assert_param(IS_BDMA_REQUEST(hdma->Init.Request));
    }

    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
 800111a:	687b      	ldr	r3, [r7, #4]
 800111c:	2202      	movs	r2, #2
 800111e:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Allocate lock resource */
    __HAL_UNLOCK(hdma);
 8001122:	687b      	ldr	r3, [r7, #4]
 8001124:	2200      	movs	r2, #0
 8001126:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Get the CR register value */
    registerValue = ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR;
 800112a:	687b      	ldr	r3, [r7, #4]
 800112c:	681b      	ldr	r3, [r3, #0]
 800112e:	681b      	ldr	r3, [r3, #0]
 8001130:	617b      	str	r3, [r7, #20]

    /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, MEM2MEM, DBM and CT bits */
    registerValue &= ((uint32_t)~(BDMA_CCR_PL    | BDMA_CCR_MSIZE   | BDMA_CCR_PSIZE  | \
 8001132:	697a      	ldr	r2, [r7, #20]
 8001134:	4b12      	ldr	r3, [pc, #72]	; (8001180 <HAL_DMA_Init+0x44c>)
 8001136:	4013      	ands	r3, r2
 8001138:	617b      	str	r3, [r7, #20]
                                  BDMA_CCR_MINC  | BDMA_CCR_PINC    | BDMA_CCR_CIRC   | \
                                  BDMA_CCR_DIR   | BDMA_CCR_MEM2MEM | BDMA_CCR_DBM    | \
                                  BDMA_CCR_CT));

    /* Prepare the DMA Channel configuration */
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
 800113a:	687b      	ldr	r3, [r7, #4]
 800113c:	689b      	ldr	r3, [r3, #8]
 800113e:	2b40      	cmp	r3, #64	; 0x40
 8001140:	d020      	beq.n	8001184 <HAL_DMA_Init+0x450>
 8001142:	687b      	ldr	r3, [r7, #4]
 8001144:	689b      	ldr	r3, [r3, #8]
 8001146:	2b80      	cmp	r3, #128	; 0x80
 8001148:	d102      	bne.n	8001150 <HAL_DMA_Init+0x41c>
 800114a:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800114e:	e01a      	b.n	8001186 <HAL_DMA_Init+0x452>
 8001150:	2300      	movs	r3, #0
 8001152:	e018      	b.n	8001186 <HAL_DMA_Init+0x452>
 8001154:	fe10803f 	.word	0xfe10803f
 8001158:	5c001000 	.word	0x5c001000
 800115c:	ffff0000 	.word	0xffff0000
 8001160:	58025408 	.word	0x58025408
 8001164:	5802541c 	.word	0x5802541c
 8001168:	58025430 	.word	0x58025430
 800116c:	58025444 	.word	0x58025444
 8001170:	58025458 	.word	0x58025458
 8001174:	5802546c 	.word	0x5802546c
 8001178:	58025480 	.word	0x58025480
 800117c:	58025494 	.word	0x58025494
 8001180:	fffe000f 	.word	0xfffe000f
 8001184:	2310      	movs	r3, #16
                      DMA_TO_BDMA_PERIPHERAL_INC(hdma->Init.PeriphInc)       |
 8001186:	687a      	ldr	r2, [r7, #4]
 8001188:	68d2      	ldr	r2, [r2, #12]
 800118a:	08d2      	lsrs	r2, r2, #3
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
 800118c:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_MEMORY_INC(hdma->Init.MemInc)              |
 800118e:	687b      	ldr	r3, [r7, #4]
 8001190:	691b      	ldr	r3, [r3, #16]
 8001192:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_PERIPHERAL_INC(hdma->Init.PeriphInc)       |
 8001194:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_PDATA_SIZE(hdma->Init.PeriphDataAlignment) |
 8001196:	687b      	ldr	r3, [r7, #4]
 8001198:	695b      	ldr	r3, [r3, #20]
 800119a:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_MEMORY_INC(hdma->Init.MemInc)              |
 800119c:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_MDATA_SIZE(hdma->Init.MemDataAlignment)    |
 800119e:	687b      	ldr	r3, [r7, #4]
 80011a0:	699b      	ldr	r3, [r3, #24]
 80011a2:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_PDATA_SIZE(hdma->Init.PeriphDataAlignment) |
 80011a4:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_MODE(hdma->Init.Mode)                      |
 80011a6:	687b      	ldr	r3, [r7, #4]
 80011a8:	69db      	ldr	r3, [r3, #28]
 80011aa:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_MDATA_SIZE(hdma->Init.MemDataAlignment)    |
 80011ac:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_PRIORITY(hdma->Init.Priority);
 80011ae:	687b      	ldr	r3, [r7, #4]
 80011b0:	6a1b      	ldr	r3, [r3, #32]
 80011b2:	091b      	lsrs	r3, r3, #4
                      DMA_TO_BDMA_MODE(hdma->Init.Mode)                      |
 80011b4:	4313      	orrs	r3, r2
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
 80011b6:	697a      	ldr	r2, [r7, #20]
 80011b8:	4313      	orrs	r3, r2
 80011ba:	617b      	str	r3, [r7, #20]

    /* Write to DMA Channel CR register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR = registerValue;
 80011bc:	687b      	ldr	r3, [r7, #4]
 80011be:	681b      	ldr	r3, [r3, #0]
 80011c0:	697a      	ldr	r2, [r7, #20]
 80011c2:	601a      	str	r2, [r3, #0]

    /* calculation of the channel index */
    hdma->StreamIndex = (((uint32_t)((uint32_t*)hdma->Instance) - (uint32_t)BDMA_Channel0) / ((uint32_t)BDMA_Channel1 - (uint32_t)BDMA_Channel0)) << 2U;
 80011c4:	687b      	ldr	r3, [r7, #4]
 80011c6:	681b      	ldr	r3, [r3, #0]
 80011c8:	461a      	mov	r2, r3
 80011ca:	4b6e      	ldr	r3, [pc, #440]	; (8001384 <HAL_DMA_Init+0x650>)
 80011cc:	4413      	add	r3, r2
 80011ce:	4a6e      	ldr	r2, [pc, #440]	; (8001388 <HAL_DMA_Init+0x654>)
 80011d0:	fba2 2303 	umull	r2, r3, r2, r3
 80011d4:	091b      	lsrs	r3, r3, #4
 80011d6:	009a      	lsls	r2, r3, #2
 80011d8:	687b      	ldr	r3, [r7, #4]
 80011da:	65da      	str	r2, [r3, #92]	; 0x5c

    /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
    DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 80011dc:	6878      	ldr	r0, [r7, #4]
 80011de:	f002 f9a7 	bl	8003530 <DMA_CalcBaseAndBitshift>
 80011e2:	4603      	mov	r3, r0
 80011e4:	60fb      	str	r3, [r7, #12]

    /* Clear all interrupt flags */
    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
 80011e6:	687b      	ldr	r3, [r7, #4]
 80011e8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80011ea:	f003 031f 	and.w	r3, r3, #31
 80011ee:	2201      	movs	r2, #1
 80011f0:	409a      	lsls	r2, r3
 80011f2:	68fb      	ldr	r3, [r7, #12]
 80011f4:	605a      	str	r2, [r3, #4]
 80011f6:	e008      	b.n	800120a <HAL_DMA_Init+0x4d6>
  }
  else
  {
    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 80011f8:	687b      	ldr	r3, [r7, #4]
 80011fa:	2240      	movs	r2, #64	; 0x40
 80011fc:	655a      	str	r2, [r3, #84]	; 0x54
    hdma->State     = HAL_DMA_STATE_ERROR;
 80011fe:	687b      	ldr	r3, [r7, #4]
 8001200:	2203      	movs	r2, #3
 8001202:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    return HAL_ERROR;
 8001206:	2301      	movs	r3, #1
 8001208:	e0b7      	b.n	800137a <HAL_DMA_Init+0x646>
  }

  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 800120a:	687b      	ldr	r3, [r7, #4]
 800120c:	681b      	ldr	r3, [r3, #0]
 800120e:	4a5f      	ldr	r2, [pc, #380]	; (800138c <HAL_DMA_Init+0x658>)
 8001210:	4293      	cmp	r3, r2
 8001212:	d072      	beq.n	80012fa <HAL_DMA_Init+0x5c6>
 8001214:	687b      	ldr	r3, [r7, #4]
 8001216:	681b      	ldr	r3, [r3, #0]
 8001218:	4a5d      	ldr	r2, [pc, #372]	; (8001390 <HAL_DMA_Init+0x65c>)
 800121a:	4293      	cmp	r3, r2
 800121c:	d06d      	beq.n	80012fa <HAL_DMA_Init+0x5c6>
 800121e:	687b      	ldr	r3, [r7, #4]
 8001220:	681b      	ldr	r3, [r3, #0]
 8001222:	4a5c      	ldr	r2, [pc, #368]	; (8001394 <HAL_DMA_Init+0x660>)
 8001224:	4293      	cmp	r3, r2
 8001226:	d068      	beq.n	80012fa <HAL_DMA_Init+0x5c6>
 8001228:	687b      	ldr	r3, [r7, #4]
 800122a:	681b      	ldr	r3, [r3, #0]
 800122c:	4a5a      	ldr	r2, [pc, #360]	; (8001398 <HAL_DMA_Init+0x664>)
 800122e:	4293      	cmp	r3, r2
 8001230:	d063      	beq.n	80012fa <HAL_DMA_Init+0x5c6>
 8001232:	687b      	ldr	r3, [r7, #4]
 8001234:	681b      	ldr	r3, [r3, #0]
 8001236:	4a59      	ldr	r2, [pc, #356]	; (800139c <HAL_DMA_Init+0x668>)
 8001238:	4293      	cmp	r3, r2
 800123a:	d05e      	beq.n	80012fa <HAL_DMA_Init+0x5c6>
 800123c:	687b      	ldr	r3, [r7, #4]
 800123e:	681b      	ldr	r3, [r3, #0]
 8001240:	4a57      	ldr	r2, [pc, #348]	; (80013a0 <HAL_DMA_Init+0x66c>)
 8001242:	4293      	cmp	r3, r2
 8001244:	d059      	beq.n	80012fa <HAL_DMA_Init+0x5c6>
 8001246:	687b      	ldr	r3, [r7, #4]
 8001248:	681b      	ldr	r3, [r3, #0]
 800124a:	4a56      	ldr	r2, [pc, #344]	; (80013a4 <HAL_DMA_Init+0x670>)
 800124c:	4293      	cmp	r3, r2
 800124e:	d054      	beq.n	80012fa <HAL_DMA_Init+0x5c6>
 8001250:	687b      	ldr	r3, [r7, #4]
 8001252:	681b      	ldr	r3, [r3, #0]
 8001254:	4a54      	ldr	r2, [pc, #336]	; (80013a8 <HAL_DMA_Init+0x674>)
 8001256:	4293      	cmp	r3, r2
 8001258:	d04f      	beq.n	80012fa <HAL_DMA_Init+0x5c6>
 800125a:	687b      	ldr	r3, [r7, #4]
 800125c:	681b      	ldr	r3, [r3, #0]
 800125e:	4a53      	ldr	r2, [pc, #332]	; (80013ac <HAL_DMA_Init+0x678>)
 8001260:	4293      	cmp	r3, r2
 8001262:	d04a      	beq.n	80012fa <HAL_DMA_Init+0x5c6>
 8001264:	687b      	ldr	r3, [r7, #4]
 8001266:	681b      	ldr	r3, [r3, #0]
 8001268:	4a51      	ldr	r2, [pc, #324]	; (80013b0 <HAL_DMA_Init+0x67c>)
 800126a:	4293      	cmp	r3, r2
 800126c:	d045      	beq.n	80012fa <HAL_DMA_Init+0x5c6>
 800126e:	687b      	ldr	r3, [r7, #4]
 8001270:	681b      	ldr	r3, [r3, #0]
 8001272:	4a50      	ldr	r2, [pc, #320]	; (80013b4 <HAL_DMA_Init+0x680>)
 8001274:	4293      	cmp	r3, r2
 8001276:	d040      	beq.n	80012fa <HAL_DMA_Init+0x5c6>
 8001278:	687b      	ldr	r3, [r7, #4]
 800127a:	681b      	ldr	r3, [r3, #0]
 800127c:	4a4e      	ldr	r2, [pc, #312]	; (80013b8 <HAL_DMA_Init+0x684>)
 800127e:	4293      	cmp	r3, r2
 8001280:	d03b      	beq.n	80012fa <HAL_DMA_Init+0x5c6>
 8001282:	687b      	ldr	r3, [r7, #4]
 8001284:	681b      	ldr	r3, [r3, #0]
 8001286:	4a4d      	ldr	r2, [pc, #308]	; (80013bc <HAL_DMA_Init+0x688>)
 8001288:	4293      	cmp	r3, r2
 800128a:	d036      	beq.n	80012fa <HAL_DMA_Init+0x5c6>
 800128c:	687b      	ldr	r3, [r7, #4]
 800128e:	681b      	ldr	r3, [r3, #0]
 8001290:	4a4b      	ldr	r2, [pc, #300]	; (80013c0 <HAL_DMA_Init+0x68c>)
 8001292:	4293      	cmp	r3, r2
 8001294:	d031      	beq.n	80012fa <HAL_DMA_Init+0x5c6>
 8001296:	687b      	ldr	r3, [r7, #4]
 8001298:	681b      	ldr	r3, [r3, #0]
 800129a:	4a4a      	ldr	r2, [pc, #296]	; (80013c4 <HAL_DMA_Init+0x690>)
 800129c:	4293      	cmp	r3, r2
 800129e:	d02c      	beq.n	80012fa <HAL_DMA_Init+0x5c6>
 80012a0:	687b      	ldr	r3, [r7, #4]
 80012a2:	681b      	ldr	r3, [r3, #0]
 80012a4:	4a48      	ldr	r2, [pc, #288]	; (80013c8 <HAL_DMA_Init+0x694>)
 80012a6:	4293      	cmp	r3, r2
 80012a8:	d027      	beq.n	80012fa <HAL_DMA_Init+0x5c6>
 80012aa:	687b      	ldr	r3, [r7, #4]
 80012ac:	681b      	ldr	r3, [r3, #0]
 80012ae:	4a47      	ldr	r2, [pc, #284]	; (80013cc <HAL_DMA_Init+0x698>)
 80012b0:	4293      	cmp	r3, r2
 80012b2:	d022      	beq.n	80012fa <HAL_DMA_Init+0x5c6>
 80012b4:	687b      	ldr	r3, [r7, #4]
 80012b6:	681b      	ldr	r3, [r3, #0]
 80012b8:	4a45      	ldr	r2, [pc, #276]	; (80013d0 <HAL_DMA_Init+0x69c>)
 80012ba:	4293      	cmp	r3, r2
 80012bc:	d01d      	beq.n	80012fa <HAL_DMA_Init+0x5c6>
 80012be:	687b      	ldr	r3, [r7, #4]
 80012c0:	681b      	ldr	r3, [r3, #0]
 80012c2:	4a44      	ldr	r2, [pc, #272]	; (80013d4 <HAL_DMA_Init+0x6a0>)
 80012c4:	4293      	cmp	r3, r2
 80012c6:	d018      	beq.n	80012fa <HAL_DMA_Init+0x5c6>
 80012c8:	687b      	ldr	r3, [r7, #4]
 80012ca:	681b      	ldr	r3, [r3, #0]
 80012cc:	4a42      	ldr	r2, [pc, #264]	; (80013d8 <HAL_DMA_Init+0x6a4>)
 80012ce:	4293      	cmp	r3, r2
 80012d0:	d013      	beq.n	80012fa <HAL_DMA_Init+0x5c6>
 80012d2:	687b      	ldr	r3, [r7, #4]
 80012d4:	681b      	ldr	r3, [r3, #0]
 80012d6:	4a41      	ldr	r2, [pc, #260]	; (80013dc <HAL_DMA_Init+0x6a8>)
 80012d8:	4293      	cmp	r3, r2
 80012da:	d00e      	beq.n	80012fa <HAL_DMA_Init+0x5c6>
 80012dc:	687b      	ldr	r3, [r7, #4]
 80012de:	681b      	ldr	r3, [r3, #0]
 80012e0:	4a3f      	ldr	r2, [pc, #252]	; (80013e0 <HAL_DMA_Init+0x6ac>)
 80012e2:	4293      	cmp	r3, r2
 80012e4:	d009      	beq.n	80012fa <HAL_DMA_Init+0x5c6>
 80012e6:	687b      	ldr	r3, [r7, #4]
 80012e8:	681b      	ldr	r3, [r3, #0]
 80012ea:	4a3e      	ldr	r2, [pc, #248]	; (80013e4 <HAL_DMA_Init+0x6b0>)
 80012ec:	4293      	cmp	r3, r2
 80012ee:	d004      	beq.n	80012fa <HAL_DMA_Init+0x5c6>
 80012f0:	687b      	ldr	r3, [r7, #4]
 80012f2:	681b      	ldr	r3, [r3, #0]
 80012f4:	4a3c      	ldr	r2, [pc, #240]	; (80013e8 <HAL_DMA_Init+0x6b4>)
 80012f6:	4293      	cmp	r3, r2
 80012f8:	d101      	bne.n	80012fe <HAL_DMA_Init+0x5ca>
 80012fa:	2301      	movs	r3, #1
 80012fc:	e000      	b.n	8001300 <HAL_DMA_Init+0x5cc>
 80012fe:	2300      	movs	r3, #0
 8001300:	2b00      	cmp	r3, #0
 8001302:	d032      	beq.n	800136a <HAL_DMA_Init+0x636>
  {
    /* Initialize parameters for DMAMUX channel :
    DMAmuxChannel, DMAmuxChannelStatus and DMAmuxChannelStatusMask
    */
    DMA_CalcDMAMUXChannelBaseAndMask(hdma);
 8001304:	6878      	ldr	r0, [r7, #4]
 8001306:	f002 fa41 	bl	800378c <DMA_CalcDMAMUXChannelBaseAndMask>

    if(hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 800130a:	687b      	ldr	r3, [r7, #4]
 800130c:	689b      	ldr	r3, [r3, #8]
 800130e:	2b80      	cmp	r3, #128	; 0x80
 8001310:	d102      	bne.n	8001318 <HAL_DMA_Init+0x5e4>
    {
      /* if memory to memory force the request to 0*/
      hdma->Init.Request = DMA_REQUEST_MEM2MEM;
 8001312:	687b      	ldr	r3, [r7, #4]
 8001314:	2200      	movs	r2, #0
 8001316:	605a      	str	r2, [r3, #4]
    }

    /* Set peripheral request  to DMAMUX channel */
    hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 8001318:	687b      	ldr	r3, [r7, #4]
 800131a:	685a      	ldr	r2, [r3, #4]
 800131c:	687b      	ldr	r3, [r7, #4]
 800131e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8001320:	b2d2      	uxtb	r2, r2
 8001322:	601a      	str	r2, [r3, #0]

    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8001324:	687b      	ldr	r3, [r7, #4]
 8001326:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8001328:	687a      	ldr	r2, [r7, #4]
 800132a:	6e92      	ldr	r2, [r2, #104]	; 0x68
 800132c:	605a      	str	r2, [r3, #4]

    /* Initialize parameters for DMAMUX request generator :
    if the DMA request is DMA_REQUEST_GENERATOR0 to DMA_REQUEST_GENERATOR7
    */
    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
 800132e:	687b      	ldr	r3, [r7, #4]
 8001330:	685b      	ldr	r3, [r3, #4]
 8001332:	2b00      	cmp	r3, #0
 8001334:	d010      	beq.n	8001358 <HAL_DMA_Init+0x624>
 8001336:	687b      	ldr	r3, [r7, #4]
 8001338:	685b      	ldr	r3, [r3, #4]
 800133a:	2b08      	cmp	r3, #8
 800133c:	d80c      	bhi.n	8001358 <HAL_DMA_Init+0x624>
    {
      /* Initialize parameters for DMAMUX request generator :
      DMAmuxRequestGen, DMAmuxRequestGenStatus and DMAmuxRequestGenStatusMask */
      DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);
 800133e:	6878      	ldr	r0, [r7, #4]
 8001340:	f002 fabe 	bl	80038c0 <DMA_CalcDMAMUXRequestGenBaseAndMask>

      /* Reset the DMAMUX request generator register */
      hdma->DMAmuxRequestGen->RGCR = 0U;
 8001344:	687b      	ldr	r3, [r7, #4]
 8001346:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8001348:	2200      	movs	r2, #0
 800134a:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 800134c:	687b      	ldr	r3, [r7, #4]
 800134e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8001350:	687a      	ldr	r2, [r7, #4]
 8001352:	6f52      	ldr	r2, [r2, #116]	; 0x74
 8001354:	605a      	str	r2, [r3, #4]
 8001356:	e008      	b.n	800136a <HAL_DMA_Init+0x636>
    }
    else
    {
      hdma->DMAmuxRequestGen = 0U;
 8001358:	687b      	ldr	r3, [r7, #4]
 800135a:	2200      	movs	r2, #0
 800135c:	66da      	str	r2, [r3, #108]	; 0x6c
      hdma->DMAmuxRequestGenStatus = 0U;
 800135e:	687b      	ldr	r3, [r7, #4]
 8001360:	2200      	movs	r2, #0
 8001362:	671a      	str	r2, [r3, #112]	; 0x70
      hdma->DMAmuxRequestGenStatusMask = 0U;
 8001364:	687b      	ldr	r3, [r7, #4]
 8001366:	2200      	movs	r2, #0
 8001368:	675a      	str	r2, [r3, #116]	; 0x74
    }
  }

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 800136a:	687b      	ldr	r3, [r7, #4]
 800136c:	2200      	movs	r2, #0
 800136e:	655a      	str	r2, [r3, #84]	; 0x54

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
 8001370:	687b      	ldr	r3, [r7, #4]
 8001372:	2201      	movs	r2, #1
 8001374:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  return HAL_OK;
 8001378:	2300      	movs	r3, #0
}
 800137a:	4618      	mov	r0, r3
 800137c:	3718      	adds	r7, #24
 800137e:	46bd      	mov	sp, r7
 8001380:	bd80      	pop	{r7, pc}
 8001382:	bf00      	nop
 8001384:	a7fdabf8 	.word	0xa7fdabf8
 8001388:	cccccccd 	.word	0xcccccccd
 800138c:	40020010 	.word	0x40020010
 8001390:	40020028 	.word	0x40020028
 8001394:	40020040 	.word	0x40020040
 8001398:	40020058 	.word	0x40020058
 800139c:	40020070 	.word	0x40020070
 80013a0:	40020088 	.word	0x40020088
 80013a4:	400200a0 	.word	0x400200a0
 80013a8:	400200b8 	.word	0x400200b8
 80013ac:	40020410 	.word	0x40020410
 80013b0:	40020428 	.word	0x40020428
 80013b4:	40020440 	.word	0x40020440
 80013b8:	40020458 	.word	0x40020458
 80013bc:	40020470 	.word	0x40020470
 80013c0:	40020488 	.word	0x40020488
 80013c4:	400204a0 	.word	0x400204a0
 80013c8:	400204b8 	.word	0x400204b8
 80013cc:	58025408 	.word	0x58025408
 80013d0:	5802541c 	.word	0x5802541c
 80013d4:	58025430 	.word	0x58025430
 80013d8:	58025444 	.word	0x58025444
 80013dc:	58025458 	.word	0x58025458
 80013e0:	5802546c 	.word	0x5802546c
 80013e4:	58025480 	.word	0x58025480
 80013e8:	58025494 	.word	0x58025494

080013ec <HAL_DMA_Start_IT>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 80013ec:	b580      	push	{r7, lr}
 80013ee:	b086      	sub	sp, #24
 80013f0:	af00      	add	r7, sp, #0
 80013f2:	60f8      	str	r0, [r7, #12]
 80013f4:	60b9      	str	r1, [r7, #8]
 80013f6:	607a      	str	r2, [r7, #4]
 80013f8:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 80013fa:	2300      	movs	r3, #0
 80013fc:	75fb      	strb	r3, [r7, #23]

  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
 80013fe:	68fb      	ldr	r3, [r7, #12]
 8001400:	2b00      	cmp	r3, #0
 8001402:	d101      	bne.n	8001408 <HAL_DMA_Start_IT+0x1c>
  {
    return HAL_ERROR;
 8001404:	2301      	movs	r3, #1
 8001406:	e226      	b.n	8001856 <HAL_DMA_Start_IT+0x46a>
  }

  /* Process locked */
  __HAL_LOCK(hdma);
 8001408:	68fb      	ldr	r3, [r7, #12]
 800140a:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 800140e:	2b01      	cmp	r3, #1
 8001410:	d101      	bne.n	8001416 <HAL_DMA_Start_IT+0x2a>
 8001412:	2302      	movs	r3, #2
 8001414:	e21f      	b.n	8001856 <HAL_DMA_Start_IT+0x46a>
 8001416:	68fb      	ldr	r3, [r7, #12]
 8001418:	2201      	movs	r2, #1
 800141a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  if(HAL_DMA_STATE_READY == hdma->State)
 800141e:	68fb      	ldr	r3, [r7, #12]
 8001420:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8001424:	b2db      	uxtb	r3, r3
 8001426:	2b01      	cmp	r3, #1
 8001428:	f040 820a 	bne.w	8001840 <HAL_DMA_Start_IT+0x454>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
 800142c:	68fb      	ldr	r3, [r7, #12]
 800142e:	2202      	movs	r2, #2
 8001430:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8001434:	68fb      	ldr	r3, [r7, #12]
 8001436:	2200      	movs	r2, #0
 8001438:	655a      	str	r2, [r3, #84]	; 0x54

    /* Disable the peripheral */
    __HAL_DMA_DISABLE(hdma);
 800143a:	68fb      	ldr	r3, [r7, #12]
 800143c:	681b      	ldr	r3, [r3, #0]
 800143e:	4a68      	ldr	r2, [pc, #416]	; (80015e0 <HAL_DMA_Start_IT+0x1f4>)
 8001440:	4293      	cmp	r3, r2
 8001442:	d04a      	beq.n	80014da <HAL_DMA_Start_IT+0xee>
 8001444:	68fb      	ldr	r3, [r7, #12]
 8001446:	681b      	ldr	r3, [r3, #0]
 8001448:	4a66      	ldr	r2, [pc, #408]	; (80015e4 <HAL_DMA_Start_IT+0x1f8>)
 800144a:	4293      	cmp	r3, r2
 800144c:	d045      	beq.n	80014da <HAL_DMA_Start_IT+0xee>
 800144e:	68fb      	ldr	r3, [r7, #12]
 8001450:	681b      	ldr	r3, [r3, #0]
 8001452:	4a65      	ldr	r2, [pc, #404]	; (80015e8 <HAL_DMA_Start_IT+0x1fc>)
 8001454:	4293      	cmp	r3, r2
 8001456:	d040      	beq.n	80014da <HAL_DMA_Start_IT+0xee>
 8001458:	68fb      	ldr	r3, [r7, #12]
 800145a:	681b      	ldr	r3, [r3, #0]
 800145c:	4a63      	ldr	r2, [pc, #396]	; (80015ec <HAL_DMA_Start_IT+0x200>)
 800145e:	4293      	cmp	r3, r2
 8001460:	d03b      	beq.n	80014da <HAL_DMA_Start_IT+0xee>
 8001462:	68fb      	ldr	r3, [r7, #12]
 8001464:	681b      	ldr	r3, [r3, #0]
 8001466:	4a62      	ldr	r2, [pc, #392]	; (80015f0 <HAL_DMA_Start_IT+0x204>)
 8001468:	4293      	cmp	r3, r2
 800146a:	d036      	beq.n	80014da <HAL_DMA_Start_IT+0xee>
 800146c:	68fb      	ldr	r3, [r7, #12]
 800146e:	681b      	ldr	r3, [r3, #0]
 8001470:	4a60      	ldr	r2, [pc, #384]	; (80015f4 <HAL_DMA_Start_IT+0x208>)
 8001472:	4293      	cmp	r3, r2
 8001474:	d031      	beq.n	80014da <HAL_DMA_Start_IT+0xee>
 8001476:	68fb      	ldr	r3, [r7, #12]
 8001478:	681b      	ldr	r3, [r3, #0]
 800147a:	4a5f      	ldr	r2, [pc, #380]	; (80015f8 <HAL_DMA_Start_IT+0x20c>)
 800147c:	4293      	cmp	r3, r2
 800147e:	d02c      	beq.n	80014da <HAL_DMA_Start_IT+0xee>
 8001480:	68fb      	ldr	r3, [r7, #12]
 8001482:	681b      	ldr	r3, [r3, #0]
 8001484:	4a5d      	ldr	r2, [pc, #372]	; (80015fc <HAL_DMA_Start_IT+0x210>)
 8001486:	4293      	cmp	r3, r2
 8001488:	d027      	beq.n	80014da <HAL_DMA_Start_IT+0xee>
 800148a:	68fb      	ldr	r3, [r7, #12]
 800148c:	681b      	ldr	r3, [r3, #0]
 800148e:	4a5c      	ldr	r2, [pc, #368]	; (8001600 <HAL_DMA_Start_IT+0x214>)
 8001490:	4293      	cmp	r3, r2
 8001492:	d022      	beq.n	80014da <HAL_DMA_Start_IT+0xee>
 8001494:	68fb      	ldr	r3, [r7, #12]
 8001496:	681b      	ldr	r3, [r3, #0]
 8001498:	4a5a      	ldr	r2, [pc, #360]	; (8001604 <HAL_DMA_Start_IT+0x218>)
 800149a:	4293      	cmp	r3, r2
 800149c:	d01d      	beq.n	80014da <HAL_DMA_Start_IT+0xee>
 800149e:	68fb      	ldr	r3, [r7, #12]
 80014a0:	681b      	ldr	r3, [r3, #0]
 80014a2:	4a59      	ldr	r2, [pc, #356]	; (8001608 <HAL_DMA_Start_IT+0x21c>)
 80014a4:	4293      	cmp	r3, r2
 80014a6:	d018      	beq.n	80014da <HAL_DMA_Start_IT+0xee>
 80014a8:	68fb      	ldr	r3, [r7, #12]
 80014aa:	681b      	ldr	r3, [r3, #0]
 80014ac:	4a57      	ldr	r2, [pc, #348]	; (800160c <HAL_DMA_Start_IT+0x220>)
 80014ae:	4293      	cmp	r3, r2
 80014b0:	d013      	beq.n	80014da <HAL_DMA_Start_IT+0xee>
 80014b2:	68fb      	ldr	r3, [r7, #12]
 80014b4:	681b      	ldr	r3, [r3, #0]
 80014b6:	4a56      	ldr	r2, [pc, #344]	; (8001610 <HAL_DMA_Start_IT+0x224>)
 80014b8:	4293      	cmp	r3, r2
 80014ba:	d00e      	beq.n	80014da <HAL_DMA_Start_IT+0xee>
 80014bc:	68fb      	ldr	r3, [r7, #12]
 80014be:	681b      	ldr	r3, [r3, #0]
 80014c0:	4a54      	ldr	r2, [pc, #336]	; (8001614 <HAL_DMA_Start_IT+0x228>)
 80014c2:	4293      	cmp	r3, r2
 80014c4:	d009      	beq.n	80014da <HAL_DMA_Start_IT+0xee>
 80014c6:	68fb      	ldr	r3, [r7, #12]
 80014c8:	681b      	ldr	r3, [r3, #0]
 80014ca:	4a53      	ldr	r2, [pc, #332]	; (8001618 <HAL_DMA_Start_IT+0x22c>)
 80014cc:	4293      	cmp	r3, r2
 80014ce:	d004      	beq.n	80014da <HAL_DMA_Start_IT+0xee>
 80014d0:	68fb      	ldr	r3, [r7, #12]
 80014d2:	681b      	ldr	r3, [r3, #0]
 80014d4:	4a51      	ldr	r2, [pc, #324]	; (800161c <HAL_DMA_Start_IT+0x230>)
 80014d6:	4293      	cmp	r3, r2
 80014d8:	d108      	bne.n	80014ec <HAL_DMA_Start_IT+0x100>
 80014da:	68fb      	ldr	r3, [r7, #12]
 80014dc:	681b      	ldr	r3, [r3, #0]
 80014de:	681a      	ldr	r2, [r3, #0]
 80014e0:	68fb      	ldr	r3, [r7, #12]
 80014e2:	681b      	ldr	r3, [r3, #0]
 80014e4:	f022 0201 	bic.w	r2, r2, #1
 80014e8:	601a      	str	r2, [r3, #0]
 80014ea:	e007      	b.n	80014fc <HAL_DMA_Start_IT+0x110>
 80014ec:	68fb      	ldr	r3, [r7, #12]
 80014ee:	681b      	ldr	r3, [r3, #0]
 80014f0:	681a      	ldr	r2, [r3, #0]
 80014f2:	68fb      	ldr	r3, [r7, #12]
 80014f4:	681b      	ldr	r3, [r3, #0]
 80014f6:	f022 0201 	bic.w	r2, r2, #1
 80014fa:	601a      	str	r2, [r3, #0]

    /* Configure the source, destination address and the data length */
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
 80014fc:	683b      	ldr	r3, [r7, #0]
 80014fe:	687a      	ldr	r2, [r7, #4]
 8001500:	68b9      	ldr	r1, [r7, #8]
 8001502:	68f8      	ldr	r0, [r7, #12]
 8001504:	f001 fe68 	bl	80031d8 <DMA_SetConfig>

    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8001508:	68fb      	ldr	r3, [r7, #12]
 800150a:	681b      	ldr	r3, [r3, #0]
 800150c:	4a34      	ldr	r2, [pc, #208]	; (80015e0 <HAL_DMA_Start_IT+0x1f4>)
 800150e:	4293      	cmp	r3, r2
 8001510:	d04a      	beq.n	80015a8 <HAL_DMA_Start_IT+0x1bc>
 8001512:	68fb      	ldr	r3, [r7, #12]
 8001514:	681b      	ldr	r3, [r3, #0]
 8001516:	4a33      	ldr	r2, [pc, #204]	; (80015e4 <HAL_DMA_Start_IT+0x1f8>)
 8001518:	4293      	cmp	r3, r2
 800151a:	d045      	beq.n	80015a8 <HAL_DMA_Start_IT+0x1bc>
 800151c:	68fb      	ldr	r3, [r7, #12]
 800151e:	681b      	ldr	r3, [r3, #0]
 8001520:	4a31      	ldr	r2, [pc, #196]	; (80015e8 <HAL_DMA_Start_IT+0x1fc>)
 8001522:	4293      	cmp	r3, r2
 8001524:	d040      	beq.n	80015a8 <HAL_DMA_Start_IT+0x1bc>
 8001526:	68fb      	ldr	r3, [r7, #12]
 8001528:	681b      	ldr	r3, [r3, #0]
 800152a:	4a30      	ldr	r2, [pc, #192]	; (80015ec <HAL_DMA_Start_IT+0x200>)
 800152c:	4293      	cmp	r3, r2
 800152e:	d03b      	beq.n	80015a8 <HAL_DMA_Start_IT+0x1bc>
 8001530:	68fb      	ldr	r3, [r7, #12]
 8001532:	681b      	ldr	r3, [r3, #0]
 8001534:	4a2e      	ldr	r2, [pc, #184]	; (80015f0 <HAL_DMA_Start_IT+0x204>)
 8001536:	4293      	cmp	r3, r2
 8001538:	d036      	beq.n	80015a8 <HAL_DMA_Start_IT+0x1bc>
 800153a:	68fb      	ldr	r3, [r7, #12]
 800153c:	681b      	ldr	r3, [r3, #0]
 800153e:	4a2d      	ldr	r2, [pc, #180]	; (80015f4 <HAL_DMA_Start_IT+0x208>)
 8001540:	4293      	cmp	r3, r2
 8001542:	d031      	beq.n	80015a8 <HAL_DMA_Start_IT+0x1bc>
 8001544:	68fb      	ldr	r3, [r7, #12]
 8001546:	681b      	ldr	r3, [r3, #0]
 8001548:	4a2b      	ldr	r2, [pc, #172]	; (80015f8 <HAL_DMA_Start_IT+0x20c>)
 800154a:	4293      	cmp	r3, r2
 800154c:	d02c      	beq.n	80015a8 <HAL_DMA_Start_IT+0x1bc>
 800154e:	68fb      	ldr	r3, [r7, #12]
 8001550:	681b      	ldr	r3, [r3, #0]
 8001552:	4a2a      	ldr	r2, [pc, #168]	; (80015fc <HAL_DMA_Start_IT+0x210>)
 8001554:	4293      	cmp	r3, r2
 8001556:	d027      	beq.n	80015a8 <HAL_DMA_Start_IT+0x1bc>
 8001558:	68fb      	ldr	r3, [r7, #12]
 800155a:	681b      	ldr	r3, [r3, #0]
 800155c:	4a28      	ldr	r2, [pc, #160]	; (8001600 <HAL_DMA_Start_IT+0x214>)
 800155e:	4293      	cmp	r3, r2
 8001560:	d022      	beq.n	80015a8 <HAL_DMA_Start_IT+0x1bc>
 8001562:	68fb      	ldr	r3, [r7, #12]
 8001564:	681b      	ldr	r3, [r3, #0]
 8001566:	4a27      	ldr	r2, [pc, #156]	; (8001604 <HAL_DMA_Start_IT+0x218>)
 8001568:	4293      	cmp	r3, r2
 800156a:	d01d      	beq.n	80015a8 <HAL_DMA_Start_IT+0x1bc>
 800156c:	68fb      	ldr	r3, [r7, #12]
 800156e:	681b      	ldr	r3, [r3, #0]
 8001570:	4a25      	ldr	r2, [pc, #148]	; (8001608 <HAL_DMA_Start_IT+0x21c>)
 8001572:	4293      	cmp	r3, r2
 8001574:	d018      	beq.n	80015a8 <HAL_DMA_Start_IT+0x1bc>
 8001576:	68fb      	ldr	r3, [r7, #12]
 8001578:	681b      	ldr	r3, [r3, #0]
 800157a:	4a24      	ldr	r2, [pc, #144]	; (800160c <HAL_DMA_Start_IT+0x220>)
 800157c:	4293      	cmp	r3, r2
 800157e:	d013      	beq.n	80015a8 <HAL_DMA_Start_IT+0x1bc>
 8001580:	68fb      	ldr	r3, [r7, #12]
 8001582:	681b      	ldr	r3, [r3, #0]
 8001584:	4a22      	ldr	r2, [pc, #136]	; (8001610 <HAL_DMA_Start_IT+0x224>)
 8001586:	4293      	cmp	r3, r2
 8001588:	d00e      	beq.n	80015a8 <HAL_DMA_Start_IT+0x1bc>
 800158a:	68fb      	ldr	r3, [r7, #12]
 800158c:	681b      	ldr	r3, [r3, #0]
 800158e:	4a21      	ldr	r2, [pc, #132]	; (8001614 <HAL_DMA_Start_IT+0x228>)
 8001590:	4293      	cmp	r3, r2
 8001592:	d009      	beq.n	80015a8 <HAL_DMA_Start_IT+0x1bc>
 8001594:	68fb      	ldr	r3, [r7, #12]
 8001596:	681b      	ldr	r3, [r3, #0]
 8001598:	4a1f      	ldr	r2, [pc, #124]	; (8001618 <HAL_DMA_Start_IT+0x22c>)
 800159a:	4293      	cmp	r3, r2
 800159c:	d004      	beq.n	80015a8 <HAL_DMA_Start_IT+0x1bc>
 800159e:	68fb      	ldr	r3, [r7, #12]
 80015a0:	681b      	ldr	r3, [r3, #0]
 80015a2:	4a1e      	ldr	r2, [pc, #120]	; (800161c <HAL_DMA_Start_IT+0x230>)
 80015a4:	4293      	cmp	r3, r2
 80015a6:	d101      	bne.n	80015ac <HAL_DMA_Start_IT+0x1c0>
 80015a8:	2301      	movs	r3, #1
 80015aa:	e000      	b.n	80015ae <HAL_DMA_Start_IT+0x1c2>
 80015ac:	2300      	movs	r3, #0
 80015ae:	2b00      	cmp	r3, #0
 80015b0:	d036      	beq.n	8001620 <HAL_DMA_Start_IT+0x234>
    {
      /* Enable Common interrupts*/
      MODIFY_REG(((DMA_Stream_TypeDef   *)hdma->Instance)->CR, (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT), (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME));
 80015b2:	68fb      	ldr	r3, [r7, #12]
 80015b4:	681b      	ldr	r3, [r3, #0]
 80015b6:	681b      	ldr	r3, [r3, #0]
 80015b8:	f023 021e 	bic.w	r2, r3, #30
 80015bc:	68fb      	ldr	r3, [r7, #12]
 80015be:	681b      	ldr	r3, [r3, #0]
 80015c0:	f042 0216 	orr.w	r2, r2, #22
 80015c4:	601a      	str	r2, [r3, #0]

      if(hdma->XferHalfCpltCallback != NULL)
 80015c6:	68fb      	ldr	r3, [r7, #12]
 80015c8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80015ca:	2b00      	cmp	r3, #0
 80015cc:	d03e      	beq.n	800164c <HAL_DMA_Start_IT+0x260>
      {
        /* Enable Half Transfer IT if corresponding Callback is set */
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  |= DMA_IT_HT;
 80015ce:	68fb      	ldr	r3, [r7, #12]
 80015d0:	681b      	ldr	r3, [r3, #0]
 80015d2:	681a      	ldr	r2, [r3, #0]
 80015d4:	68fb      	ldr	r3, [r7, #12]
 80015d6:	681b      	ldr	r3, [r3, #0]
 80015d8:	f042 0208 	orr.w	r2, r2, #8
 80015dc:	601a      	str	r2, [r3, #0]
 80015de:	e035      	b.n	800164c <HAL_DMA_Start_IT+0x260>
 80015e0:	40020010 	.word	0x40020010
 80015e4:	40020028 	.word	0x40020028
 80015e8:	40020040 	.word	0x40020040
 80015ec:	40020058 	.word	0x40020058
 80015f0:	40020070 	.word	0x40020070
 80015f4:	40020088 	.word	0x40020088
 80015f8:	400200a0 	.word	0x400200a0
 80015fc:	400200b8 	.word	0x400200b8
 8001600:	40020410 	.word	0x40020410
 8001604:	40020428 	.word	0x40020428
 8001608:	40020440 	.word	0x40020440
 800160c:	40020458 	.word	0x40020458
 8001610:	40020470 	.word	0x40020470
 8001614:	40020488 	.word	0x40020488
 8001618:	400204a0 	.word	0x400204a0
 800161c:	400204b8 	.word	0x400204b8
      }
    }
    else /* BDMA channel */
    {
      /* Enable Common interrupts */
      MODIFY_REG(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR, (BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE), (BDMA_CCR_TCIE | BDMA_CCR_TEIE));
 8001620:	68fb      	ldr	r3, [r7, #12]
 8001622:	681b      	ldr	r3, [r3, #0]
 8001624:	681b      	ldr	r3, [r3, #0]
 8001626:	f023 020e 	bic.w	r2, r3, #14
 800162a:	68fb      	ldr	r3, [r7, #12]
 800162c:	681b      	ldr	r3, [r3, #0]
 800162e:	f042 020a 	orr.w	r2, r2, #10
 8001632:	601a      	str	r2, [r3, #0]

      if(hdma->XferHalfCpltCallback != NULL)
 8001634:	68fb      	ldr	r3, [r7, #12]
 8001636:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001638:	2b00      	cmp	r3, #0
 800163a:	d007      	beq.n	800164c <HAL_DMA_Start_IT+0x260>
      {
        /*Enable Half Transfer IT if corresponding Callback is set */
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  |= BDMA_CCR_HTIE;
 800163c:	68fb      	ldr	r3, [r7, #12]
 800163e:	681b      	ldr	r3, [r3, #0]
 8001640:	681a      	ldr	r2, [r3, #0]
 8001642:	68fb      	ldr	r3, [r7, #12]
 8001644:	681b      	ldr	r3, [r3, #0]
 8001646:	f042 0204 	orr.w	r2, r2, #4
 800164a:	601a      	str	r2, [r3, #0]
      }
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 800164c:	68fb      	ldr	r3, [r7, #12]
 800164e:	681b      	ldr	r3, [r3, #0]
 8001650:	4a83      	ldr	r2, [pc, #524]	; (8001860 <HAL_DMA_Start_IT+0x474>)
 8001652:	4293      	cmp	r3, r2
 8001654:	d072      	beq.n	800173c <HAL_DMA_Start_IT+0x350>
 8001656:	68fb      	ldr	r3, [r7, #12]
 8001658:	681b      	ldr	r3, [r3, #0]
 800165a:	4a82      	ldr	r2, [pc, #520]	; (8001864 <HAL_DMA_Start_IT+0x478>)
 800165c:	4293      	cmp	r3, r2
 800165e:	d06d      	beq.n	800173c <HAL_DMA_Start_IT+0x350>
 8001660:	68fb      	ldr	r3, [r7, #12]
 8001662:	681b      	ldr	r3, [r3, #0]
 8001664:	4a80      	ldr	r2, [pc, #512]	; (8001868 <HAL_DMA_Start_IT+0x47c>)
 8001666:	4293      	cmp	r3, r2
 8001668:	d068      	beq.n	800173c <HAL_DMA_Start_IT+0x350>
 800166a:	68fb      	ldr	r3, [r7, #12]
 800166c:	681b      	ldr	r3, [r3, #0]
 800166e:	4a7f      	ldr	r2, [pc, #508]	; (800186c <HAL_DMA_Start_IT+0x480>)
 8001670:	4293      	cmp	r3, r2
 8001672:	d063      	beq.n	800173c <HAL_DMA_Start_IT+0x350>
 8001674:	68fb      	ldr	r3, [r7, #12]
 8001676:	681b      	ldr	r3, [r3, #0]
 8001678:	4a7d      	ldr	r2, [pc, #500]	; (8001870 <HAL_DMA_Start_IT+0x484>)
 800167a:	4293      	cmp	r3, r2
 800167c:	d05e      	beq.n	800173c <HAL_DMA_Start_IT+0x350>
 800167e:	68fb      	ldr	r3, [r7, #12]
 8001680:	681b      	ldr	r3, [r3, #0]
 8001682:	4a7c      	ldr	r2, [pc, #496]	; (8001874 <HAL_DMA_Start_IT+0x488>)
 8001684:	4293      	cmp	r3, r2
 8001686:	d059      	beq.n	800173c <HAL_DMA_Start_IT+0x350>
 8001688:	68fb      	ldr	r3, [r7, #12]
 800168a:	681b      	ldr	r3, [r3, #0]
 800168c:	4a7a      	ldr	r2, [pc, #488]	; (8001878 <HAL_DMA_Start_IT+0x48c>)
 800168e:	4293      	cmp	r3, r2
 8001690:	d054      	beq.n	800173c <HAL_DMA_Start_IT+0x350>
 8001692:	68fb      	ldr	r3, [r7, #12]
 8001694:	681b      	ldr	r3, [r3, #0]
 8001696:	4a79      	ldr	r2, [pc, #484]	; (800187c <HAL_DMA_Start_IT+0x490>)
 8001698:	4293      	cmp	r3, r2
 800169a:	d04f      	beq.n	800173c <HAL_DMA_Start_IT+0x350>
 800169c:	68fb      	ldr	r3, [r7, #12]
 800169e:	681b      	ldr	r3, [r3, #0]
 80016a0:	4a77      	ldr	r2, [pc, #476]	; (8001880 <HAL_DMA_Start_IT+0x494>)
 80016a2:	4293      	cmp	r3, r2
 80016a4:	d04a      	beq.n	800173c <HAL_DMA_Start_IT+0x350>
 80016a6:	68fb      	ldr	r3, [r7, #12]
 80016a8:	681b      	ldr	r3, [r3, #0]
 80016aa:	4a76      	ldr	r2, [pc, #472]	; (8001884 <HAL_DMA_Start_IT+0x498>)
 80016ac:	4293      	cmp	r3, r2
 80016ae:	d045      	beq.n	800173c <HAL_DMA_Start_IT+0x350>
 80016b0:	68fb      	ldr	r3, [r7, #12]
 80016b2:	681b      	ldr	r3, [r3, #0]
 80016b4:	4a74      	ldr	r2, [pc, #464]	; (8001888 <HAL_DMA_Start_IT+0x49c>)
 80016b6:	4293      	cmp	r3, r2
 80016b8:	d040      	beq.n	800173c <HAL_DMA_Start_IT+0x350>
 80016ba:	68fb      	ldr	r3, [r7, #12]
 80016bc:	681b      	ldr	r3, [r3, #0]
 80016be:	4a73      	ldr	r2, [pc, #460]	; (800188c <HAL_DMA_Start_IT+0x4a0>)
 80016c0:	4293      	cmp	r3, r2
 80016c2:	d03b      	beq.n	800173c <HAL_DMA_Start_IT+0x350>
 80016c4:	68fb      	ldr	r3, [r7, #12]
 80016c6:	681b      	ldr	r3, [r3, #0]
 80016c8:	4a71      	ldr	r2, [pc, #452]	; (8001890 <HAL_DMA_Start_IT+0x4a4>)
 80016ca:	4293      	cmp	r3, r2
 80016cc:	d036      	beq.n	800173c <HAL_DMA_Start_IT+0x350>
 80016ce:	68fb      	ldr	r3, [r7, #12]
 80016d0:	681b      	ldr	r3, [r3, #0]
 80016d2:	4a70      	ldr	r2, [pc, #448]	; (8001894 <HAL_DMA_Start_IT+0x4a8>)
 80016d4:	4293      	cmp	r3, r2
 80016d6:	d031      	beq.n	800173c <HAL_DMA_Start_IT+0x350>
 80016d8:	68fb      	ldr	r3, [r7, #12]
 80016da:	681b      	ldr	r3, [r3, #0]
 80016dc:	4a6e      	ldr	r2, [pc, #440]	; (8001898 <HAL_DMA_Start_IT+0x4ac>)
 80016de:	4293      	cmp	r3, r2
 80016e0:	d02c      	beq.n	800173c <HAL_DMA_Start_IT+0x350>
 80016e2:	68fb      	ldr	r3, [r7, #12]
 80016e4:	681b      	ldr	r3, [r3, #0]
 80016e6:	4a6d      	ldr	r2, [pc, #436]	; (800189c <HAL_DMA_Start_IT+0x4b0>)
 80016e8:	4293      	cmp	r3, r2
 80016ea:	d027      	beq.n	800173c <HAL_DMA_Start_IT+0x350>
 80016ec:	68fb      	ldr	r3, [r7, #12]
 80016ee:	681b      	ldr	r3, [r3, #0]
 80016f0:	4a6b      	ldr	r2, [pc, #428]	; (80018a0 <HAL_DMA_Start_IT+0x4b4>)
 80016f2:	4293      	cmp	r3, r2
 80016f4:	d022      	beq.n	800173c <HAL_DMA_Start_IT+0x350>
 80016f6:	68fb      	ldr	r3, [r7, #12]
 80016f8:	681b      	ldr	r3, [r3, #0]
 80016fa:	4a6a      	ldr	r2, [pc, #424]	; (80018a4 <HAL_DMA_Start_IT+0x4b8>)
 80016fc:	4293      	cmp	r3, r2
 80016fe:	d01d      	beq.n	800173c <HAL_DMA_Start_IT+0x350>
 8001700:	68fb      	ldr	r3, [r7, #12]
 8001702:	681b      	ldr	r3, [r3, #0]
 8001704:	4a68      	ldr	r2, [pc, #416]	; (80018a8 <HAL_DMA_Start_IT+0x4bc>)
 8001706:	4293      	cmp	r3, r2
 8001708:	d018      	beq.n	800173c <HAL_DMA_Start_IT+0x350>
 800170a:	68fb      	ldr	r3, [r7, #12]
 800170c:	681b      	ldr	r3, [r3, #0]
 800170e:	4a67      	ldr	r2, [pc, #412]	; (80018ac <HAL_DMA_Start_IT+0x4c0>)
 8001710:	4293      	cmp	r3, r2
 8001712:	d013      	beq.n	800173c <HAL_DMA_Start_IT+0x350>
 8001714:	68fb      	ldr	r3, [r7, #12]
 8001716:	681b      	ldr	r3, [r3, #0]
 8001718:	4a65      	ldr	r2, [pc, #404]	; (80018b0 <HAL_DMA_Start_IT+0x4c4>)
 800171a:	4293      	cmp	r3, r2
 800171c:	d00e      	beq.n	800173c <HAL_DMA_Start_IT+0x350>
 800171e:	68fb      	ldr	r3, [r7, #12]
 8001720:	681b      	ldr	r3, [r3, #0]
 8001722:	4a64      	ldr	r2, [pc, #400]	; (80018b4 <HAL_DMA_Start_IT+0x4c8>)
 8001724:	4293      	cmp	r3, r2
 8001726:	d009      	beq.n	800173c <HAL_DMA_Start_IT+0x350>
 8001728:	68fb      	ldr	r3, [r7, #12]
 800172a:	681b      	ldr	r3, [r3, #0]
 800172c:	4a62      	ldr	r2, [pc, #392]	; (80018b8 <HAL_DMA_Start_IT+0x4cc>)
 800172e:	4293      	cmp	r3, r2
 8001730:	d004      	beq.n	800173c <HAL_DMA_Start_IT+0x350>
 8001732:	68fb      	ldr	r3, [r7, #12]
 8001734:	681b      	ldr	r3, [r3, #0]
 8001736:	4a61      	ldr	r2, [pc, #388]	; (80018bc <HAL_DMA_Start_IT+0x4d0>)
 8001738:	4293      	cmp	r3, r2
 800173a:	d101      	bne.n	8001740 <HAL_DMA_Start_IT+0x354>
 800173c:	2301      	movs	r3, #1
 800173e:	e000      	b.n	8001742 <HAL_DMA_Start_IT+0x356>
 8001740:	2300      	movs	r3, #0
 8001742:	2b00      	cmp	r3, #0
 8001744:	d01a      	beq.n	800177c <HAL_DMA_Start_IT+0x390>
    {
      /* Check if DMAMUX Synchronization is enabled */
      if((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
 8001746:	68fb      	ldr	r3, [r7, #12]
 8001748:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800174a:	681b      	ldr	r3, [r3, #0]
 800174c:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8001750:	2b00      	cmp	r3, #0
 8001752:	d007      	beq.n	8001764 <HAL_DMA_Start_IT+0x378>
      {
        /* Enable DMAMUX sync overrun IT*/
        hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
 8001754:	68fb      	ldr	r3, [r7, #12]
 8001756:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8001758:	681a      	ldr	r2, [r3, #0]
 800175a:	68fb      	ldr	r3, [r7, #12]
 800175c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800175e:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8001762:	601a      	str	r2, [r3, #0]
      }

      if(hdma->DMAmuxRequestGen != 0U)
 8001764:	68fb      	ldr	r3, [r7, #12]
 8001766:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8001768:	2b00      	cmp	r3, #0
 800176a:	d007      	beq.n	800177c <HAL_DMA_Start_IT+0x390>
      {
        /* if using DMAMUX request generator, enable the DMAMUX request generator overrun IT*/
        /* enable the request gen overrun IT */
        hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
 800176c:	68fb      	ldr	r3, [r7, #12]
 800176e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8001770:	681a      	ldr	r2, [r3, #0]
 8001772:	68fb      	ldr	r3, [r7, #12]
 8001774:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8001776:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800177a:	601a      	str	r2, [r3, #0]
      }
    }

    /* Enable the Peripheral */
    __HAL_DMA_ENABLE(hdma);
 800177c:	68fb      	ldr	r3, [r7, #12]
 800177e:	681b      	ldr	r3, [r3, #0]
 8001780:	4a37      	ldr	r2, [pc, #220]	; (8001860 <HAL_DMA_Start_IT+0x474>)
 8001782:	4293      	cmp	r3, r2
 8001784:	d04a      	beq.n	800181c <HAL_DMA_Start_IT+0x430>
 8001786:	68fb      	ldr	r3, [r7, #12]
 8001788:	681b      	ldr	r3, [r3, #0]
 800178a:	4a36      	ldr	r2, [pc, #216]	; (8001864 <HAL_DMA_Start_IT+0x478>)
 800178c:	4293      	cmp	r3, r2
 800178e:	d045      	beq.n	800181c <HAL_DMA_Start_IT+0x430>
 8001790:	68fb      	ldr	r3, [r7, #12]
 8001792:	681b      	ldr	r3, [r3, #0]
 8001794:	4a34      	ldr	r2, [pc, #208]	; (8001868 <HAL_DMA_Start_IT+0x47c>)
 8001796:	4293      	cmp	r3, r2
 8001798:	d040      	beq.n	800181c <HAL_DMA_Start_IT+0x430>
 800179a:	68fb      	ldr	r3, [r7, #12]
 800179c:	681b      	ldr	r3, [r3, #0]
 800179e:	4a33      	ldr	r2, [pc, #204]	; (800186c <HAL_DMA_Start_IT+0x480>)
 80017a0:	4293      	cmp	r3, r2
 80017a2:	d03b      	beq.n	800181c <HAL_DMA_Start_IT+0x430>
 80017a4:	68fb      	ldr	r3, [r7, #12]
 80017a6:	681b      	ldr	r3, [r3, #0]
 80017a8:	4a31      	ldr	r2, [pc, #196]	; (8001870 <HAL_DMA_Start_IT+0x484>)
 80017aa:	4293      	cmp	r3, r2
 80017ac:	d036      	beq.n	800181c <HAL_DMA_Start_IT+0x430>
 80017ae:	68fb      	ldr	r3, [r7, #12]
 80017b0:	681b      	ldr	r3, [r3, #0]
 80017b2:	4a30      	ldr	r2, [pc, #192]	; (8001874 <HAL_DMA_Start_IT+0x488>)
 80017b4:	4293      	cmp	r3, r2
 80017b6:	d031      	beq.n	800181c <HAL_DMA_Start_IT+0x430>
 80017b8:	68fb      	ldr	r3, [r7, #12]
 80017ba:	681b      	ldr	r3, [r3, #0]
 80017bc:	4a2e      	ldr	r2, [pc, #184]	; (8001878 <HAL_DMA_Start_IT+0x48c>)
 80017be:	4293      	cmp	r3, r2
 80017c0:	d02c      	beq.n	800181c <HAL_DMA_Start_IT+0x430>
 80017c2:	68fb      	ldr	r3, [r7, #12]
 80017c4:	681b      	ldr	r3, [r3, #0]
 80017c6:	4a2d      	ldr	r2, [pc, #180]	; (800187c <HAL_DMA_Start_IT+0x490>)
 80017c8:	4293      	cmp	r3, r2
 80017ca:	d027      	beq.n	800181c <HAL_DMA_Start_IT+0x430>
 80017cc:	68fb      	ldr	r3, [r7, #12]
 80017ce:	681b      	ldr	r3, [r3, #0]
 80017d0:	4a2b      	ldr	r2, [pc, #172]	; (8001880 <HAL_DMA_Start_IT+0x494>)
 80017d2:	4293      	cmp	r3, r2
 80017d4:	d022      	beq.n	800181c <HAL_DMA_Start_IT+0x430>
 80017d6:	68fb      	ldr	r3, [r7, #12]
 80017d8:	681b      	ldr	r3, [r3, #0]
 80017da:	4a2a      	ldr	r2, [pc, #168]	; (8001884 <HAL_DMA_Start_IT+0x498>)
 80017dc:	4293      	cmp	r3, r2
 80017de:	d01d      	beq.n	800181c <HAL_DMA_Start_IT+0x430>
 80017e0:	68fb      	ldr	r3, [r7, #12]
 80017e2:	681b      	ldr	r3, [r3, #0]
 80017e4:	4a28      	ldr	r2, [pc, #160]	; (8001888 <HAL_DMA_Start_IT+0x49c>)
 80017e6:	4293      	cmp	r3, r2
 80017e8:	d018      	beq.n	800181c <HAL_DMA_Start_IT+0x430>
 80017ea:	68fb      	ldr	r3, [r7, #12]
 80017ec:	681b      	ldr	r3, [r3, #0]
 80017ee:	4a27      	ldr	r2, [pc, #156]	; (800188c <HAL_DMA_Start_IT+0x4a0>)
 80017f0:	4293      	cmp	r3, r2
 80017f2:	d013      	beq.n	800181c <HAL_DMA_Start_IT+0x430>
 80017f4:	68fb      	ldr	r3, [r7, #12]
 80017f6:	681b      	ldr	r3, [r3, #0]
 80017f8:	4a25      	ldr	r2, [pc, #148]	; (8001890 <HAL_DMA_Start_IT+0x4a4>)
 80017fa:	4293      	cmp	r3, r2
 80017fc:	d00e      	beq.n	800181c <HAL_DMA_Start_IT+0x430>
 80017fe:	68fb      	ldr	r3, [r7, #12]
 8001800:	681b      	ldr	r3, [r3, #0]
 8001802:	4a24      	ldr	r2, [pc, #144]	; (8001894 <HAL_DMA_Start_IT+0x4a8>)
 8001804:	4293      	cmp	r3, r2
 8001806:	d009      	beq.n	800181c <HAL_DMA_Start_IT+0x430>
 8001808:	68fb      	ldr	r3, [r7, #12]
 800180a:	681b      	ldr	r3, [r3, #0]
 800180c:	4a22      	ldr	r2, [pc, #136]	; (8001898 <HAL_DMA_Start_IT+0x4ac>)
 800180e:	4293      	cmp	r3, r2
 8001810:	d004      	beq.n	800181c <HAL_DMA_Start_IT+0x430>
 8001812:	68fb      	ldr	r3, [r7, #12]
 8001814:	681b      	ldr	r3, [r3, #0]
 8001816:	4a21      	ldr	r2, [pc, #132]	; (800189c <HAL_DMA_Start_IT+0x4b0>)
 8001818:	4293      	cmp	r3, r2
 800181a:	d108      	bne.n	800182e <HAL_DMA_Start_IT+0x442>
 800181c:	68fb      	ldr	r3, [r7, #12]
 800181e:	681b      	ldr	r3, [r3, #0]
 8001820:	681a      	ldr	r2, [r3, #0]
 8001822:	68fb      	ldr	r3, [r7, #12]
 8001824:	681b      	ldr	r3, [r3, #0]
 8001826:	f042 0201 	orr.w	r2, r2, #1
 800182a:	601a      	str	r2, [r3, #0]
 800182c:	e012      	b.n	8001854 <HAL_DMA_Start_IT+0x468>
 800182e:	68fb      	ldr	r3, [r7, #12]
 8001830:	681b      	ldr	r3, [r3, #0]
 8001832:	681a      	ldr	r2, [r3, #0]
 8001834:	68fb      	ldr	r3, [r7, #12]
 8001836:	681b      	ldr	r3, [r3, #0]
 8001838:	f042 0201 	orr.w	r2, r2, #1
 800183c:	601a      	str	r2, [r3, #0]
 800183e:	e009      	b.n	8001854 <HAL_DMA_Start_IT+0x468>
  }
  else
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
 8001840:	68fb      	ldr	r3, [r7, #12]
 8001842:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8001846:	655a      	str	r2, [r3, #84]	; 0x54

    /* Process unlocked */
    __HAL_UNLOCK(hdma);
 8001848:	68fb      	ldr	r3, [r7, #12]
 800184a:	2200      	movs	r2, #0
 800184c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Return error status */
    status = HAL_ERROR;
 8001850:	2301      	movs	r3, #1
 8001852:	75fb      	strb	r3, [r7, #23]
  }

  return status;
 8001854:	7dfb      	ldrb	r3, [r7, #23]
}
 8001856:	4618      	mov	r0, r3
 8001858:	3718      	adds	r7, #24
 800185a:	46bd      	mov	sp, r7
 800185c:	bd80      	pop	{r7, pc}
 800185e:	bf00      	nop
 8001860:	40020010 	.word	0x40020010
 8001864:	40020028 	.word	0x40020028
 8001868:	40020040 	.word	0x40020040
 800186c:	40020058 	.word	0x40020058
 8001870:	40020070 	.word	0x40020070
 8001874:	40020088 	.word	0x40020088
 8001878:	400200a0 	.word	0x400200a0
 800187c:	400200b8 	.word	0x400200b8
 8001880:	40020410 	.word	0x40020410
 8001884:	40020428 	.word	0x40020428
 8001888:	40020440 	.word	0x40020440
 800188c:	40020458 	.word	0x40020458
 8001890:	40020470 	.word	0x40020470
 8001894:	40020488 	.word	0x40020488
 8001898:	400204a0 	.word	0x400204a0
 800189c:	400204b8 	.word	0x400204b8
 80018a0:	58025408 	.word	0x58025408
 80018a4:	5802541c 	.word	0x5802541c
 80018a8:	58025430 	.word	0x58025430
 80018ac:	58025444 	.word	0x58025444
 80018b0:	58025458 	.word	0x58025458
 80018b4:	5802546c 	.word	0x5802546c
 80018b8:	58025480 	.word	0x58025480
 80018bc:	58025494 	.word	0x58025494

080018c0 <HAL_DMA_Abort>:
  *        and the Stream will be effectively disabled only after the transfer of
  *        this single data is finished.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
{
 80018c0:	b580      	push	{r7, lr}
 80018c2:	b086      	sub	sp, #24
 80018c4:	af00      	add	r7, sp, #0
 80018c6:	6078      	str	r0, [r7, #4]
  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs_dma;
  BDMA_Base_Registers *regs_bdma;
  const __IO uint32_t *enableRegister;

  uint32_t tickstart = HAL_GetTick();
 80018c8:	f7fe ff3e 	bl	8000748 <HAL_GetTick>
 80018cc:	6138      	str	r0, [r7, #16]

 /* Check the DMA peripheral handle */
  if(hdma == NULL)
 80018ce:	687b      	ldr	r3, [r7, #4]
 80018d0:	2b00      	cmp	r3, #0
 80018d2:	d101      	bne.n	80018d8 <HAL_DMA_Abort+0x18>
  {
    return HAL_ERROR;
 80018d4:	2301      	movs	r3, #1
 80018d6:	e2dc      	b.n	8001e92 <HAL_DMA_Abort+0x5d2>
  }

  /* Check the DMA peripheral state */
  if(hdma->State != HAL_DMA_STATE_BUSY)
 80018d8:	687b      	ldr	r3, [r7, #4]
 80018da:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 80018de:	b2db      	uxtb	r3, r3
 80018e0:	2b02      	cmp	r3, #2
 80018e2:	d008      	beq.n	80018f6 <HAL_DMA_Abort+0x36>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 80018e4:	687b      	ldr	r3, [r7, #4]
 80018e6:	2280      	movs	r2, #128	; 0x80
 80018e8:	655a      	str	r2, [r3, #84]	; 0x54

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 80018ea:	687b      	ldr	r3, [r7, #4]
 80018ec:	2200      	movs	r2, #0
 80018ee:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    return HAL_ERROR;
 80018f2:	2301      	movs	r3, #1
 80018f4:	e2cd      	b.n	8001e92 <HAL_DMA_Abort+0x5d2>
  }
  else
  {
    /* Disable all the transfer interrupts */
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 80018f6:	687b      	ldr	r3, [r7, #4]
 80018f8:	681b      	ldr	r3, [r3, #0]
 80018fa:	4a76      	ldr	r2, [pc, #472]	; (8001ad4 <HAL_DMA_Abort+0x214>)
 80018fc:	4293      	cmp	r3, r2
 80018fe:	d04a      	beq.n	8001996 <HAL_DMA_Abort+0xd6>
 8001900:	687b      	ldr	r3, [r7, #4]
 8001902:	681b      	ldr	r3, [r3, #0]
 8001904:	4a74      	ldr	r2, [pc, #464]	; (8001ad8 <HAL_DMA_Abort+0x218>)
 8001906:	4293      	cmp	r3, r2
 8001908:	d045      	beq.n	8001996 <HAL_DMA_Abort+0xd6>
 800190a:	687b      	ldr	r3, [r7, #4]
 800190c:	681b      	ldr	r3, [r3, #0]
 800190e:	4a73      	ldr	r2, [pc, #460]	; (8001adc <HAL_DMA_Abort+0x21c>)
 8001910:	4293      	cmp	r3, r2
 8001912:	d040      	beq.n	8001996 <HAL_DMA_Abort+0xd6>
 8001914:	687b      	ldr	r3, [r7, #4]
 8001916:	681b      	ldr	r3, [r3, #0]
 8001918:	4a71      	ldr	r2, [pc, #452]	; (8001ae0 <HAL_DMA_Abort+0x220>)
 800191a:	4293      	cmp	r3, r2
 800191c:	d03b      	beq.n	8001996 <HAL_DMA_Abort+0xd6>
 800191e:	687b      	ldr	r3, [r7, #4]
 8001920:	681b      	ldr	r3, [r3, #0]
 8001922:	4a70      	ldr	r2, [pc, #448]	; (8001ae4 <HAL_DMA_Abort+0x224>)
 8001924:	4293      	cmp	r3, r2
 8001926:	d036      	beq.n	8001996 <HAL_DMA_Abort+0xd6>
 8001928:	687b      	ldr	r3, [r7, #4]
 800192a:	681b      	ldr	r3, [r3, #0]
 800192c:	4a6e      	ldr	r2, [pc, #440]	; (8001ae8 <HAL_DMA_Abort+0x228>)
 800192e:	4293      	cmp	r3, r2
 8001930:	d031      	beq.n	8001996 <HAL_DMA_Abort+0xd6>
 8001932:	687b      	ldr	r3, [r7, #4]
 8001934:	681b      	ldr	r3, [r3, #0]
 8001936:	4a6d      	ldr	r2, [pc, #436]	; (8001aec <HAL_DMA_Abort+0x22c>)
 8001938:	4293      	cmp	r3, r2
 800193a:	d02c      	beq.n	8001996 <HAL_DMA_Abort+0xd6>
 800193c:	687b      	ldr	r3, [r7, #4]
 800193e:	681b      	ldr	r3, [r3, #0]
 8001940:	4a6b      	ldr	r2, [pc, #428]	; (8001af0 <HAL_DMA_Abort+0x230>)
 8001942:	4293      	cmp	r3, r2
 8001944:	d027      	beq.n	8001996 <HAL_DMA_Abort+0xd6>
 8001946:	687b      	ldr	r3, [r7, #4]
 8001948:	681b      	ldr	r3, [r3, #0]
 800194a:	4a6a      	ldr	r2, [pc, #424]	; (8001af4 <HAL_DMA_Abort+0x234>)
 800194c:	4293      	cmp	r3, r2
 800194e:	d022      	beq.n	8001996 <HAL_DMA_Abort+0xd6>
 8001950:	687b      	ldr	r3, [r7, #4]
 8001952:	681b      	ldr	r3, [r3, #0]
 8001954:	4a68      	ldr	r2, [pc, #416]	; (8001af8 <HAL_DMA_Abort+0x238>)
 8001956:	4293      	cmp	r3, r2
 8001958:	d01d      	beq.n	8001996 <HAL_DMA_Abort+0xd6>
 800195a:	687b      	ldr	r3, [r7, #4]
 800195c:	681b      	ldr	r3, [r3, #0]
 800195e:	4a67      	ldr	r2, [pc, #412]	; (8001afc <HAL_DMA_Abort+0x23c>)
 8001960:	4293      	cmp	r3, r2
 8001962:	d018      	beq.n	8001996 <HAL_DMA_Abort+0xd6>
 8001964:	687b      	ldr	r3, [r7, #4]
 8001966:	681b      	ldr	r3, [r3, #0]
 8001968:	4a65      	ldr	r2, [pc, #404]	; (8001b00 <HAL_DMA_Abort+0x240>)
 800196a:	4293      	cmp	r3, r2
 800196c:	d013      	beq.n	8001996 <HAL_DMA_Abort+0xd6>
 800196e:	687b      	ldr	r3, [r7, #4]
 8001970:	681b      	ldr	r3, [r3, #0]
 8001972:	4a64      	ldr	r2, [pc, #400]	; (8001b04 <HAL_DMA_Abort+0x244>)
 8001974:	4293      	cmp	r3, r2
 8001976:	d00e      	beq.n	8001996 <HAL_DMA_Abort+0xd6>
 8001978:	687b      	ldr	r3, [r7, #4]
 800197a:	681b      	ldr	r3, [r3, #0]
 800197c:	4a62      	ldr	r2, [pc, #392]	; (8001b08 <HAL_DMA_Abort+0x248>)
 800197e:	4293      	cmp	r3, r2
 8001980:	d009      	beq.n	8001996 <HAL_DMA_Abort+0xd6>
 8001982:	687b      	ldr	r3, [r7, #4]
 8001984:	681b      	ldr	r3, [r3, #0]
 8001986:	4a61      	ldr	r2, [pc, #388]	; (8001b0c <HAL_DMA_Abort+0x24c>)
 8001988:	4293      	cmp	r3, r2
 800198a:	d004      	beq.n	8001996 <HAL_DMA_Abort+0xd6>
 800198c:	687b      	ldr	r3, [r7, #4]
 800198e:	681b      	ldr	r3, [r3, #0]
 8001990:	4a5f      	ldr	r2, [pc, #380]	; (8001b10 <HAL_DMA_Abort+0x250>)
 8001992:	4293      	cmp	r3, r2
 8001994:	d101      	bne.n	800199a <HAL_DMA_Abort+0xda>
 8001996:	2301      	movs	r3, #1
 8001998:	e000      	b.n	800199c <HAL_DMA_Abort+0xdc>
 800199a:	2300      	movs	r3, #0
 800199c:	2b00      	cmp	r3, #0
 800199e:	d013      	beq.n	80019c8 <HAL_DMA_Abort+0x108>
    {
       /* Disable DMA All Interrupts  */
      ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT);
 80019a0:	687b      	ldr	r3, [r7, #4]
 80019a2:	681b      	ldr	r3, [r3, #0]
 80019a4:	681a      	ldr	r2, [r3, #0]
 80019a6:	687b      	ldr	r3, [r7, #4]
 80019a8:	681b      	ldr	r3, [r3, #0]
 80019aa:	f022 021e 	bic.w	r2, r2, #30
 80019ae:	601a      	str	r2, [r3, #0]
      ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR &= ~(DMA_IT_FE);
 80019b0:	687b      	ldr	r3, [r7, #4]
 80019b2:	681b      	ldr	r3, [r3, #0]
 80019b4:	695a      	ldr	r2, [r3, #20]
 80019b6:	687b      	ldr	r3, [r7, #4]
 80019b8:	681b      	ldr	r3, [r3, #0]
 80019ba:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 80019be:	615a      	str	r2, [r3, #20]

      enableRegister = (__IO uint32_t *)(&(((DMA_Stream_TypeDef   *)hdma->Instance)->CR));
 80019c0:	687b      	ldr	r3, [r7, #4]
 80019c2:	681b      	ldr	r3, [r3, #0]
 80019c4:	617b      	str	r3, [r7, #20]
 80019c6:	e00a      	b.n	80019de <HAL_DMA_Abort+0x11e>
    }
    else /* BDMA channel */
    {
      /* Disable DMA All Interrupts */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
 80019c8:	687b      	ldr	r3, [r7, #4]
 80019ca:	681b      	ldr	r3, [r3, #0]
 80019cc:	681a      	ldr	r2, [r3, #0]
 80019ce:	687b      	ldr	r3, [r7, #4]
 80019d0:	681b      	ldr	r3, [r3, #0]
 80019d2:	f022 020e 	bic.w	r2, r2, #14
 80019d6:	601a      	str	r2, [r3, #0]

      enableRegister = (__IO uint32_t *)(&(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR));
 80019d8:	687b      	ldr	r3, [r7, #4]
 80019da:	681b      	ldr	r3, [r3, #0]
 80019dc:	617b      	str	r3, [r7, #20]
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 80019de:	687b      	ldr	r3, [r7, #4]
 80019e0:	681b      	ldr	r3, [r3, #0]
 80019e2:	4a3c      	ldr	r2, [pc, #240]	; (8001ad4 <HAL_DMA_Abort+0x214>)
 80019e4:	4293      	cmp	r3, r2
 80019e6:	d072      	beq.n	8001ace <HAL_DMA_Abort+0x20e>
 80019e8:	687b      	ldr	r3, [r7, #4]
 80019ea:	681b      	ldr	r3, [r3, #0]
 80019ec:	4a3a      	ldr	r2, [pc, #232]	; (8001ad8 <HAL_DMA_Abort+0x218>)
 80019ee:	4293      	cmp	r3, r2
 80019f0:	d06d      	beq.n	8001ace <HAL_DMA_Abort+0x20e>
 80019f2:	687b      	ldr	r3, [r7, #4]
 80019f4:	681b      	ldr	r3, [r3, #0]
 80019f6:	4a39      	ldr	r2, [pc, #228]	; (8001adc <HAL_DMA_Abort+0x21c>)
 80019f8:	4293      	cmp	r3, r2
 80019fa:	d068      	beq.n	8001ace <HAL_DMA_Abort+0x20e>
 80019fc:	687b      	ldr	r3, [r7, #4]
 80019fe:	681b      	ldr	r3, [r3, #0]
 8001a00:	4a37      	ldr	r2, [pc, #220]	; (8001ae0 <HAL_DMA_Abort+0x220>)
 8001a02:	4293      	cmp	r3, r2
 8001a04:	d063      	beq.n	8001ace <HAL_DMA_Abort+0x20e>
 8001a06:	687b      	ldr	r3, [r7, #4]
 8001a08:	681b      	ldr	r3, [r3, #0]
 8001a0a:	4a36      	ldr	r2, [pc, #216]	; (8001ae4 <HAL_DMA_Abort+0x224>)
 8001a0c:	4293      	cmp	r3, r2
 8001a0e:	d05e      	beq.n	8001ace <HAL_DMA_Abort+0x20e>
 8001a10:	687b      	ldr	r3, [r7, #4]
 8001a12:	681b      	ldr	r3, [r3, #0]
 8001a14:	4a34      	ldr	r2, [pc, #208]	; (8001ae8 <HAL_DMA_Abort+0x228>)
 8001a16:	4293      	cmp	r3, r2
 8001a18:	d059      	beq.n	8001ace <HAL_DMA_Abort+0x20e>
 8001a1a:	687b      	ldr	r3, [r7, #4]
 8001a1c:	681b      	ldr	r3, [r3, #0]
 8001a1e:	4a33      	ldr	r2, [pc, #204]	; (8001aec <HAL_DMA_Abort+0x22c>)
 8001a20:	4293      	cmp	r3, r2
 8001a22:	d054      	beq.n	8001ace <HAL_DMA_Abort+0x20e>
 8001a24:	687b      	ldr	r3, [r7, #4]
 8001a26:	681b      	ldr	r3, [r3, #0]
 8001a28:	4a31      	ldr	r2, [pc, #196]	; (8001af0 <HAL_DMA_Abort+0x230>)
 8001a2a:	4293      	cmp	r3, r2
 8001a2c:	d04f      	beq.n	8001ace <HAL_DMA_Abort+0x20e>
 8001a2e:	687b      	ldr	r3, [r7, #4]
 8001a30:	681b      	ldr	r3, [r3, #0]
 8001a32:	4a30      	ldr	r2, [pc, #192]	; (8001af4 <HAL_DMA_Abort+0x234>)
 8001a34:	4293      	cmp	r3, r2
 8001a36:	d04a      	beq.n	8001ace <HAL_DMA_Abort+0x20e>
 8001a38:	687b      	ldr	r3, [r7, #4]
 8001a3a:	681b      	ldr	r3, [r3, #0]
 8001a3c:	4a2e      	ldr	r2, [pc, #184]	; (8001af8 <HAL_DMA_Abort+0x238>)
 8001a3e:	4293      	cmp	r3, r2
 8001a40:	d045      	beq.n	8001ace <HAL_DMA_Abort+0x20e>
 8001a42:	687b      	ldr	r3, [r7, #4]
 8001a44:	681b      	ldr	r3, [r3, #0]
 8001a46:	4a2d      	ldr	r2, [pc, #180]	; (8001afc <HAL_DMA_Abort+0x23c>)
 8001a48:	4293      	cmp	r3, r2
 8001a4a:	d040      	beq.n	8001ace <HAL_DMA_Abort+0x20e>
 8001a4c:	687b      	ldr	r3, [r7, #4]
 8001a4e:	681b      	ldr	r3, [r3, #0]
 8001a50:	4a2b      	ldr	r2, [pc, #172]	; (8001b00 <HAL_DMA_Abort+0x240>)
 8001a52:	4293      	cmp	r3, r2
 8001a54:	d03b      	beq.n	8001ace <HAL_DMA_Abort+0x20e>
 8001a56:	687b      	ldr	r3, [r7, #4]
 8001a58:	681b      	ldr	r3, [r3, #0]
 8001a5a:	4a2a      	ldr	r2, [pc, #168]	; (8001b04 <HAL_DMA_Abort+0x244>)
 8001a5c:	4293      	cmp	r3, r2
 8001a5e:	d036      	beq.n	8001ace <HAL_DMA_Abort+0x20e>
 8001a60:	687b      	ldr	r3, [r7, #4]
 8001a62:	681b      	ldr	r3, [r3, #0]
 8001a64:	4a28      	ldr	r2, [pc, #160]	; (8001b08 <HAL_DMA_Abort+0x248>)
 8001a66:	4293      	cmp	r3, r2
 8001a68:	d031      	beq.n	8001ace <HAL_DMA_Abort+0x20e>
 8001a6a:	687b      	ldr	r3, [r7, #4]
 8001a6c:	681b      	ldr	r3, [r3, #0]
 8001a6e:	4a27      	ldr	r2, [pc, #156]	; (8001b0c <HAL_DMA_Abort+0x24c>)
 8001a70:	4293      	cmp	r3, r2
 8001a72:	d02c      	beq.n	8001ace <HAL_DMA_Abort+0x20e>
 8001a74:	687b      	ldr	r3, [r7, #4]
 8001a76:	681b      	ldr	r3, [r3, #0]
 8001a78:	4a25      	ldr	r2, [pc, #148]	; (8001b10 <HAL_DMA_Abort+0x250>)
 8001a7a:	4293      	cmp	r3, r2
 8001a7c:	d027      	beq.n	8001ace <HAL_DMA_Abort+0x20e>
 8001a7e:	687b      	ldr	r3, [r7, #4]
 8001a80:	681b      	ldr	r3, [r3, #0]
 8001a82:	4a24      	ldr	r2, [pc, #144]	; (8001b14 <HAL_DMA_Abort+0x254>)
 8001a84:	4293      	cmp	r3, r2
 8001a86:	d022      	beq.n	8001ace <HAL_DMA_Abort+0x20e>
 8001a88:	687b      	ldr	r3, [r7, #4]
 8001a8a:	681b      	ldr	r3, [r3, #0]
 8001a8c:	4a22      	ldr	r2, [pc, #136]	; (8001b18 <HAL_DMA_Abort+0x258>)
 8001a8e:	4293      	cmp	r3, r2
 8001a90:	d01d      	beq.n	8001ace <HAL_DMA_Abort+0x20e>
 8001a92:	687b      	ldr	r3, [r7, #4]
 8001a94:	681b      	ldr	r3, [r3, #0]
 8001a96:	4a21      	ldr	r2, [pc, #132]	; (8001b1c <HAL_DMA_Abort+0x25c>)
 8001a98:	4293      	cmp	r3, r2
 8001a9a:	d018      	beq.n	8001ace <HAL_DMA_Abort+0x20e>
 8001a9c:	687b      	ldr	r3, [r7, #4]
 8001a9e:	681b      	ldr	r3, [r3, #0]
 8001aa0:	4a1f      	ldr	r2, [pc, #124]	; (8001b20 <HAL_DMA_Abort+0x260>)
 8001aa2:	4293      	cmp	r3, r2
 8001aa4:	d013      	beq.n	8001ace <HAL_DMA_Abort+0x20e>
 8001aa6:	687b      	ldr	r3, [r7, #4]
 8001aa8:	681b      	ldr	r3, [r3, #0]
 8001aaa:	4a1e      	ldr	r2, [pc, #120]	; (8001b24 <HAL_DMA_Abort+0x264>)
 8001aac:	4293      	cmp	r3, r2
 8001aae:	d00e      	beq.n	8001ace <HAL_DMA_Abort+0x20e>
 8001ab0:	687b      	ldr	r3, [r7, #4]
 8001ab2:	681b      	ldr	r3, [r3, #0]
 8001ab4:	4a1c      	ldr	r2, [pc, #112]	; (8001b28 <HAL_DMA_Abort+0x268>)
 8001ab6:	4293      	cmp	r3, r2
 8001ab8:	d009      	beq.n	8001ace <HAL_DMA_Abort+0x20e>
 8001aba:	687b      	ldr	r3, [r7, #4]
 8001abc:	681b      	ldr	r3, [r3, #0]
 8001abe:	4a1b      	ldr	r2, [pc, #108]	; (8001b2c <HAL_DMA_Abort+0x26c>)
 8001ac0:	4293      	cmp	r3, r2
 8001ac2:	d004      	beq.n	8001ace <HAL_DMA_Abort+0x20e>
 8001ac4:	687b      	ldr	r3, [r7, #4]
 8001ac6:	681b      	ldr	r3, [r3, #0]
 8001ac8:	4a19      	ldr	r2, [pc, #100]	; (8001b30 <HAL_DMA_Abort+0x270>)
 8001aca:	4293      	cmp	r3, r2
 8001acc:	d132      	bne.n	8001b34 <HAL_DMA_Abort+0x274>
 8001ace:	2301      	movs	r3, #1
 8001ad0:	e031      	b.n	8001b36 <HAL_DMA_Abort+0x276>
 8001ad2:	bf00      	nop
 8001ad4:	40020010 	.word	0x40020010
 8001ad8:	40020028 	.word	0x40020028
 8001adc:	40020040 	.word	0x40020040
 8001ae0:	40020058 	.word	0x40020058
 8001ae4:	40020070 	.word	0x40020070
 8001ae8:	40020088 	.word	0x40020088
 8001aec:	400200a0 	.word	0x400200a0
 8001af0:	400200b8 	.word	0x400200b8
 8001af4:	40020410 	.word	0x40020410
 8001af8:	40020428 	.word	0x40020428
 8001afc:	40020440 	.word	0x40020440
 8001b00:	40020458 	.word	0x40020458
 8001b04:	40020470 	.word	0x40020470
 8001b08:	40020488 	.word	0x40020488
 8001b0c:	400204a0 	.word	0x400204a0
 8001b10:	400204b8 	.word	0x400204b8
 8001b14:	58025408 	.word	0x58025408
 8001b18:	5802541c 	.word	0x5802541c
 8001b1c:	58025430 	.word	0x58025430
 8001b20:	58025444 	.word	0x58025444
 8001b24:	58025458 	.word	0x58025458
 8001b28:	5802546c 	.word	0x5802546c
 8001b2c:	58025480 	.word	0x58025480
 8001b30:	58025494 	.word	0x58025494
 8001b34:	2300      	movs	r3, #0
 8001b36:	2b00      	cmp	r3, #0
 8001b38:	d007      	beq.n	8001b4a <HAL_DMA_Abort+0x28a>
    {
      /* disable the DMAMUX sync overrun IT */
      hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 8001b3a:	687b      	ldr	r3, [r7, #4]
 8001b3c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8001b3e:	681a      	ldr	r2, [r3, #0]
 8001b40:	687b      	ldr	r3, [r7, #4]
 8001b42:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8001b44:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8001b48:	601a      	str	r2, [r3, #0]
    }

    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
 8001b4a:	687b      	ldr	r3, [r7, #4]
 8001b4c:	681b      	ldr	r3, [r3, #0]
 8001b4e:	4a6d      	ldr	r2, [pc, #436]	; (8001d04 <HAL_DMA_Abort+0x444>)
 8001b50:	4293      	cmp	r3, r2
 8001b52:	d04a      	beq.n	8001bea <HAL_DMA_Abort+0x32a>
 8001b54:	687b      	ldr	r3, [r7, #4]
 8001b56:	681b      	ldr	r3, [r3, #0]
 8001b58:	4a6b      	ldr	r2, [pc, #428]	; (8001d08 <HAL_DMA_Abort+0x448>)
 8001b5a:	4293      	cmp	r3, r2
 8001b5c:	d045      	beq.n	8001bea <HAL_DMA_Abort+0x32a>
 8001b5e:	687b      	ldr	r3, [r7, #4]
 8001b60:	681b      	ldr	r3, [r3, #0]
 8001b62:	4a6a      	ldr	r2, [pc, #424]	; (8001d0c <HAL_DMA_Abort+0x44c>)
 8001b64:	4293      	cmp	r3, r2
 8001b66:	d040      	beq.n	8001bea <HAL_DMA_Abort+0x32a>
 8001b68:	687b      	ldr	r3, [r7, #4]
 8001b6a:	681b      	ldr	r3, [r3, #0]
 8001b6c:	4a68      	ldr	r2, [pc, #416]	; (8001d10 <HAL_DMA_Abort+0x450>)
 8001b6e:	4293      	cmp	r3, r2
 8001b70:	d03b      	beq.n	8001bea <HAL_DMA_Abort+0x32a>
 8001b72:	687b      	ldr	r3, [r7, #4]
 8001b74:	681b      	ldr	r3, [r3, #0]
 8001b76:	4a67      	ldr	r2, [pc, #412]	; (8001d14 <HAL_DMA_Abort+0x454>)
 8001b78:	4293      	cmp	r3, r2
 8001b7a:	d036      	beq.n	8001bea <HAL_DMA_Abort+0x32a>
 8001b7c:	687b      	ldr	r3, [r7, #4]
 8001b7e:	681b      	ldr	r3, [r3, #0]
 8001b80:	4a65      	ldr	r2, [pc, #404]	; (8001d18 <HAL_DMA_Abort+0x458>)
 8001b82:	4293      	cmp	r3, r2
 8001b84:	d031      	beq.n	8001bea <HAL_DMA_Abort+0x32a>
 8001b86:	687b      	ldr	r3, [r7, #4]
 8001b88:	681b      	ldr	r3, [r3, #0]
 8001b8a:	4a64      	ldr	r2, [pc, #400]	; (8001d1c <HAL_DMA_Abort+0x45c>)
 8001b8c:	4293      	cmp	r3, r2
 8001b8e:	d02c      	beq.n	8001bea <HAL_DMA_Abort+0x32a>
 8001b90:	687b      	ldr	r3, [r7, #4]
 8001b92:	681b      	ldr	r3, [r3, #0]
 8001b94:	4a62      	ldr	r2, [pc, #392]	; (8001d20 <HAL_DMA_Abort+0x460>)
 8001b96:	4293      	cmp	r3, r2
 8001b98:	d027      	beq.n	8001bea <HAL_DMA_Abort+0x32a>
 8001b9a:	687b      	ldr	r3, [r7, #4]
 8001b9c:	681b      	ldr	r3, [r3, #0]
 8001b9e:	4a61      	ldr	r2, [pc, #388]	; (8001d24 <HAL_DMA_Abort+0x464>)
 8001ba0:	4293      	cmp	r3, r2
 8001ba2:	d022      	beq.n	8001bea <HAL_DMA_Abort+0x32a>
 8001ba4:	687b      	ldr	r3, [r7, #4]
 8001ba6:	681b      	ldr	r3, [r3, #0]
 8001ba8:	4a5f      	ldr	r2, [pc, #380]	; (8001d28 <HAL_DMA_Abort+0x468>)
 8001baa:	4293      	cmp	r3, r2
 8001bac:	d01d      	beq.n	8001bea <HAL_DMA_Abort+0x32a>
 8001bae:	687b      	ldr	r3, [r7, #4]
 8001bb0:	681b      	ldr	r3, [r3, #0]
 8001bb2:	4a5e      	ldr	r2, [pc, #376]	; (8001d2c <HAL_DMA_Abort+0x46c>)
 8001bb4:	4293      	cmp	r3, r2
 8001bb6:	d018      	beq.n	8001bea <HAL_DMA_Abort+0x32a>
 8001bb8:	687b      	ldr	r3, [r7, #4]
 8001bba:	681b      	ldr	r3, [r3, #0]
 8001bbc:	4a5c      	ldr	r2, [pc, #368]	; (8001d30 <HAL_DMA_Abort+0x470>)
 8001bbe:	4293      	cmp	r3, r2
 8001bc0:	d013      	beq.n	8001bea <HAL_DMA_Abort+0x32a>
 8001bc2:	687b      	ldr	r3, [r7, #4]
 8001bc4:	681b      	ldr	r3, [r3, #0]
 8001bc6:	4a5b      	ldr	r2, [pc, #364]	; (8001d34 <HAL_DMA_Abort+0x474>)
 8001bc8:	4293      	cmp	r3, r2
 8001bca:	d00e      	beq.n	8001bea <HAL_DMA_Abort+0x32a>
 8001bcc:	687b      	ldr	r3, [r7, #4]
 8001bce:	681b      	ldr	r3, [r3, #0]
 8001bd0:	4a59      	ldr	r2, [pc, #356]	; (8001d38 <HAL_DMA_Abort+0x478>)
 8001bd2:	4293      	cmp	r3, r2
 8001bd4:	d009      	beq.n	8001bea <HAL_DMA_Abort+0x32a>
 8001bd6:	687b      	ldr	r3, [r7, #4]
 8001bd8:	681b      	ldr	r3, [r3, #0]
 8001bda:	4a58      	ldr	r2, [pc, #352]	; (8001d3c <HAL_DMA_Abort+0x47c>)
 8001bdc:	4293      	cmp	r3, r2
 8001bde:	d004      	beq.n	8001bea <HAL_DMA_Abort+0x32a>
 8001be0:	687b      	ldr	r3, [r7, #4]
 8001be2:	681b      	ldr	r3, [r3, #0]
 8001be4:	4a56      	ldr	r2, [pc, #344]	; (8001d40 <HAL_DMA_Abort+0x480>)
 8001be6:	4293      	cmp	r3, r2
 8001be8:	d108      	bne.n	8001bfc <HAL_DMA_Abort+0x33c>
 8001bea:	687b      	ldr	r3, [r7, #4]
 8001bec:	681b      	ldr	r3, [r3, #0]
 8001bee:	681a      	ldr	r2, [r3, #0]
 8001bf0:	687b      	ldr	r3, [r7, #4]
 8001bf2:	681b      	ldr	r3, [r3, #0]
 8001bf4:	f022 0201 	bic.w	r2, r2, #1
 8001bf8:	601a      	str	r2, [r3, #0]
 8001bfa:	e007      	b.n	8001c0c <HAL_DMA_Abort+0x34c>
 8001bfc:	687b      	ldr	r3, [r7, #4]
 8001bfe:	681b      	ldr	r3, [r3, #0]
 8001c00:	681a      	ldr	r2, [r3, #0]
 8001c02:	687b      	ldr	r3, [r7, #4]
 8001c04:	681b      	ldr	r3, [r3, #0]
 8001c06:	f022 0201 	bic.w	r2, r2, #1
 8001c0a:	601a      	str	r2, [r3, #0]

    /* Check if the DMA Stream is effectively disabled */
    while(((*enableRegister) & DMA_SxCR_EN) != 0U)
 8001c0c:	e013      	b.n	8001c36 <HAL_DMA_Abort+0x376>
    {
      /* Check for the Timeout */
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 8001c0e:	f7fe fd9b 	bl	8000748 <HAL_GetTick>
 8001c12:	4602      	mov	r2, r0
 8001c14:	693b      	ldr	r3, [r7, #16]
 8001c16:	1ad3      	subs	r3, r2, r3
 8001c18:	2b05      	cmp	r3, #5
 8001c1a:	d90c      	bls.n	8001c36 <HAL_DMA_Abort+0x376>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 8001c1c:	687b      	ldr	r3, [r7, #4]
 8001c1e:	2220      	movs	r2, #32
 8001c20:	655a      	str	r2, [r3, #84]	; 0x54

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_ERROR;
 8001c22:	687b      	ldr	r3, [r7, #4]
 8001c24:	2203      	movs	r2, #3
 8001c26:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
 8001c2a:	687b      	ldr	r3, [r7, #4]
 8001c2c:	2200      	movs	r2, #0
 8001c2e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        return HAL_ERROR;
 8001c32:	2301      	movs	r3, #1
 8001c34:	e12d      	b.n	8001e92 <HAL_DMA_Abort+0x5d2>
    while(((*enableRegister) & DMA_SxCR_EN) != 0U)
 8001c36:	697b      	ldr	r3, [r7, #20]
 8001c38:	681b      	ldr	r3, [r3, #0]
 8001c3a:	f003 0301 	and.w	r3, r3, #1
 8001c3e:	2b00      	cmp	r3, #0
 8001c40:	d1e5      	bne.n	8001c0e <HAL_DMA_Abort+0x34e>
      }
    }

    /* Clear all interrupt flags at correct offset within the register */
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8001c42:	687b      	ldr	r3, [r7, #4]
 8001c44:	681b      	ldr	r3, [r3, #0]
 8001c46:	4a2f      	ldr	r2, [pc, #188]	; (8001d04 <HAL_DMA_Abort+0x444>)
 8001c48:	4293      	cmp	r3, r2
 8001c4a:	d04a      	beq.n	8001ce2 <HAL_DMA_Abort+0x422>
 8001c4c:	687b      	ldr	r3, [r7, #4]
 8001c4e:	681b      	ldr	r3, [r3, #0]
 8001c50:	4a2d      	ldr	r2, [pc, #180]	; (8001d08 <HAL_DMA_Abort+0x448>)
 8001c52:	4293      	cmp	r3, r2
 8001c54:	d045      	beq.n	8001ce2 <HAL_DMA_Abort+0x422>
 8001c56:	687b      	ldr	r3, [r7, #4]
 8001c58:	681b      	ldr	r3, [r3, #0]
 8001c5a:	4a2c      	ldr	r2, [pc, #176]	; (8001d0c <HAL_DMA_Abort+0x44c>)
 8001c5c:	4293      	cmp	r3, r2
 8001c5e:	d040      	beq.n	8001ce2 <HAL_DMA_Abort+0x422>
 8001c60:	687b      	ldr	r3, [r7, #4]
 8001c62:	681b      	ldr	r3, [r3, #0]
 8001c64:	4a2a      	ldr	r2, [pc, #168]	; (8001d10 <HAL_DMA_Abort+0x450>)
 8001c66:	4293      	cmp	r3, r2
 8001c68:	d03b      	beq.n	8001ce2 <HAL_DMA_Abort+0x422>
 8001c6a:	687b      	ldr	r3, [r7, #4]
 8001c6c:	681b      	ldr	r3, [r3, #0]
 8001c6e:	4a29      	ldr	r2, [pc, #164]	; (8001d14 <HAL_DMA_Abort+0x454>)
 8001c70:	4293      	cmp	r3, r2
 8001c72:	d036      	beq.n	8001ce2 <HAL_DMA_Abort+0x422>
 8001c74:	687b      	ldr	r3, [r7, #4]
 8001c76:	681b      	ldr	r3, [r3, #0]
 8001c78:	4a27      	ldr	r2, [pc, #156]	; (8001d18 <HAL_DMA_Abort+0x458>)
 8001c7a:	4293      	cmp	r3, r2
 8001c7c:	d031      	beq.n	8001ce2 <HAL_DMA_Abort+0x422>
 8001c7e:	687b      	ldr	r3, [r7, #4]
 8001c80:	681b      	ldr	r3, [r3, #0]
 8001c82:	4a26      	ldr	r2, [pc, #152]	; (8001d1c <HAL_DMA_Abort+0x45c>)
 8001c84:	4293      	cmp	r3, r2
 8001c86:	d02c      	beq.n	8001ce2 <HAL_DMA_Abort+0x422>
 8001c88:	687b      	ldr	r3, [r7, #4]
 8001c8a:	681b      	ldr	r3, [r3, #0]
 8001c8c:	4a24      	ldr	r2, [pc, #144]	; (8001d20 <HAL_DMA_Abort+0x460>)
 8001c8e:	4293      	cmp	r3, r2
 8001c90:	d027      	beq.n	8001ce2 <HAL_DMA_Abort+0x422>
 8001c92:	687b      	ldr	r3, [r7, #4]
 8001c94:	681b      	ldr	r3, [r3, #0]
 8001c96:	4a23      	ldr	r2, [pc, #140]	; (8001d24 <HAL_DMA_Abort+0x464>)
 8001c98:	4293      	cmp	r3, r2
 8001c9a:	d022      	beq.n	8001ce2 <HAL_DMA_Abort+0x422>
 8001c9c:	687b      	ldr	r3, [r7, #4]
 8001c9e:	681b      	ldr	r3, [r3, #0]
 8001ca0:	4a21      	ldr	r2, [pc, #132]	; (8001d28 <HAL_DMA_Abort+0x468>)
 8001ca2:	4293      	cmp	r3, r2
 8001ca4:	d01d      	beq.n	8001ce2 <HAL_DMA_Abort+0x422>
 8001ca6:	687b      	ldr	r3, [r7, #4]
 8001ca8:	681b      	ldr	r3, [r3, #0]
 8001caa:	4a20      	ldr	r2, [pc, #128]	; (8001d2c <HAL_DMA_Abort+0x46c>)
 8001cac:	4293      	cmp	r3, r2
 8001cae:	d018      	beq.n	8001ce2 <HAL_DMA_Abort+0x422>
 8001cb0:	687b      	ldr	r3, [r7, #4]
 8001cb2:	681b      	ldr	r3, [r3, #0]
 8001cb4:	4a1e      	ldr	r2, [pc, #120]	; (8001d30 <HAL_DMA_Abort+0x470>)
 8001cb6:	4293      	cmp	r3, r2
 8001cb8:	d013      	beq.n	8001ce2 <HAL_DMA_Abort+0x422>
 8001cba:	687b      	ldr	r3, [r7, #4]
 8001cbc:	681b      	ldr	r3, [r3, #0]
 8001cbe:	4a1d      	ldr	r2, [pc, #116]	; (8001d34 <HAL_DMA_Abort+0x474>)
 8001cc0:	4293      	cmp	r3, r2
 8001cc2:	d00e      	beq.n	8001ce2 <HAL_DMA_Abort+0x422>
 8001cc4:	687b      	ldr	r3, [r7, #4]
 8001cc6:	681b      	ldr	r3, [r3, #0]
 8001cc8:	4a1b      	ldr	r2, [pc, #108]	; (8001d38 <HAL_DMA_Abort+0x478>)
 8001cca:	4293      	cmp	r3, r2
 8001ccc:	d009      	beq.n	8001ce2 <HAL_DMA_Abort+0x422>
 8001cce:	687b      	ldr	r3, [r7, #4]
 8001cd0:	681b      	ldr	r3, [r3, #0]
 8001cd2:	4a1a      	ldr	r2, [pc, #104]	; (8001d3c <HAL_DMA_Abort+0x47c>)
 8001cd4:	4293      	cmp	r3, r2
 8001cd6:	d004      	beq.n	8001ce2 <HAL_DMA_Abort+0x422>
 8001cd8:	687b      	ldr	r3, [r7, #4]
 8001cda:	681b      	ldr	r3, [r3, #0]
 8001cdc:	4a18      	ldr	r2, [pc, #96]	; (8001d40 <HAL_DMA_Abort+0x480>)
 8001cde:	4293      	cmp	r3, r2
 8001ce0:	d101      	bne.n	8001ce6 <HAL_DMA_Abort+0x426>
 8001ce2:	2301      	movs	r3, #1
 8001ce4:	e000      	b.n	8001ce8 <HAL_DMA_Abort+0x428>
 8001ce6:	2300      	movs	r3, #0
 8001ce8:	2b00      	cmp	r3, #0
 8001cea:	d02b      	beq.n	8001d44 <HAL_DMA_Abort+0x484>
    {
      regs_dma = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8001cec:	687b      	ldr	r3, [r7, #4]
 8001cee:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8001cf0:	60bb      	str	r3, [r7, #8]
      regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
 8001cf2:	687b      	ldr	r3, [r7, #4]
 8001cf4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8001cf6:	f003 031f 	and.w	r3, r3, #31
 8001cfa:	223f      	movs	r2, #63	; 0x3f
 8001cfc:	409a      	lsls	r2, r3
 8001cfe:	68bb      	ldr	r3, [r7, #8]
 8001d00:	609a      	str	r2, [r3, #8]
 8001d02:	e02a      	b.n	8001d5a <HAL_DMA_Abort+0x49a>
 8001d04:	40020010 	.word	0x40020010
 8001d08:	40020028 	.word	0x40020028
 8001d0c:	40020040 	.word	0x40020040
 8001d10:	40020058 	.word	0x40020058
 8001d14:	40020070 	.word	0x40020070
 8001d18:	40020088 	.word	0x40020088
 8001d1c:	400200a0 	.word	0x400200a0
 8001d20:	400200b8 	.word	0x400200b8
 8001d24:	40020410 	.word	0x40020410
 8001d28:	40020428 	.word	0x40020428
 8001d2c:	40020440 	.word	0x40020440
 8001d30:	40020458 	.word	0x40020458
 8001d34:	40020470 	.word	0x40020470
 8001d38:	40020488 	.word	0x40020488
 8001d3c:	400204a0 	.word	0x400204a0
 8001d40:	400204b8 	.word	0x400204b8
    }
    else /* BDMA channel */
    {
      regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
 8001d44:	687b      	ldr	r3, [r7, #4]
 8001d46:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8001d48:	60fb      	str	r3, [r7, #12]
      regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
 8001d4a:	687b      	ldr	r3, [r7, #4]
 8001d4c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8001d4e:	f003 031f 	and.w	r3, r3, #31
 8001d52:	2201      	movs	r2, #1
 8001d54:	409a      	lsls	r2, r3
 8001d56:	68fb      	ldr	r3, [r7, #12]
 8001d58:	605a      	str	r2, [r3, #4]
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 8001d5a:	687b      	ldr	r3, [r7, #4]
 8001d5c:	681b      	ldr	r3, [r3, #0]
 8001d5e:	4a4f      	ldr	r2, [pc, #316]	; (8001e9c <HAL_DMA_Abort+0x5dc>)
 8001d60:	4293      	cmp	r3, r2
 8001d62:	d072      	beq.n	8001e4a <HAL_DMA_Abort+0x58a>
 8001d64:	687b      	ldr	r3, [r7, #4]
 8001d66:	681b      	ldr	r3, [r3, #0]
 8001d68:	4a4d      	ldr	r2, [pc, #308]	; (8001ea0 <HAL_DMA_Abort+0x5e0>)
 8001d6a:	4293      	cmp	r3, r2
 8001d6c:	d06d      	beq.n	8001e4a <HAL_DMA_Abort+0x58a>
 8001d6e:	687b      	ldr	r3, [r7, #4]
 8001d70:	681b      	ldr	r3, [r3, #0]
 8001d72:	4a4c      	ldr	r2, [pc, #304]	; (8001ea4 <HAL_DMA_Abort+0x5e4>)
 8001d74:	4293      	cmp	r3, r2
 8001d76:	d068      	beq.n	8001e4a <HAL_DMA_Abort+0x58a>
 8001d78:	687b      	ldr	r3, [r7, #4]
 8001d7a:	681b      	ldr	r3, [r3, #0]
 8001d7c:	4a4a      	ldr	r2, [pc, #296]	; (8001ea8 <HAL_DMA_Abort+0x5e8>)
 8001d7e:	4293      	cmp	r3, r2
 8001d80:	d063      	beq.n	8001e4a <HAL_DMA_Abort+0x58a>
 8001d82:	687b      	ldr	r3, [r7, #4]
 8001d84:	681b      	ldr	r3, [r3, #0]
 8001d86:	4a49      	ldr	r2, [pc, #292]	; (8001eac <HAL_DMA_Abort+0x5ec>)
 8001d88:	4293      	cmp	r3, r2
 8001d8a:	d05e      	beq.n	8001e4a <HAL_DMA_Abort+0x58a>
 8001d8c:	687b      	ldr	r3, [r7, #4]
 8001d8e:	681b      	ldr	r3, [r3, #0]
 8001d90:	4a47      	ldr	r2, [pc, #284]	; (8001eb0 <HAL_DMA_Abort+0x5f0>)
 8001d92:	4293      	cmp	r3, r2
 8001d94:	d059      	beq.n	8001e4a <HAL_DMA_Abort+0x58a>
 8001d96:	687b      	ldr	r3, [r7, #4]
 8001d98:	681b      	ldr	r3, [r3, #0]
 8001d9a:	4a46      	ldr	r2, [pc, #280]	; (8001eb4 <HAL_DMA_Abort+0x5f4>)
 8001d9c:	4293      	cmp	r3, r2
 8001d9e:	d054      	beq.n	8001e4a <HAL_DMA_Abort+0x58a>
 8001da0:	687b      	ldr	r3, [r7, #4]
 8001da2:	681b      	ldr	r3, [r3, #0]
 8001da4:	4a44      	ldr	r2, [pc, #272]	; (8001eb8 <HAL_DMA_Abort+0x5f8>)
 8001da6:	4293      	cmp	r3, r2
 8001da8:	d04f      	beq.n	8001e4a <HAL_DMA_Abort+0x58a>
 8001daa:	687b      	ldr	r3, [r7, #4]
 8001dac:	681b      	ldr	r3, [r3, #0]
 8001dae:	4a43      	ldr	r2, [pc, #268]	; (8001ebc <HAL_DMA_Abort+0x5fc>)
 8001db0:	4293      	cmp	r3, r2
 8001db2:	d04a      	beq.n	8001e4a <HAL_DMA_Abort+0x58a>
 8001db4:	687b      	ldr	r3, [r7, #4]
 8001db6:	681b      	ldr	r3, [r3, #0]
 8001db8:	4a41      	ldr	r2, [pc, #260]	; (8001ec0 <HAL_DMA_Abort+0x600>)
 8001dba:	4293      	cmp	r3, r2
 8001dbc:	d045      	beq.n	8001e4a <HAL_DMA_Abort+0x58a>
 8001dbe:	687b      	ldr	r3, [r7, #4]
 8001dc0:	681b      	ldr	r3, [r3, #0]
 8001dc2:	4a40      	ldr	r2, [pc, #256]	; (8001ec4 <HAL_DMA_Abort+0x604>)
 8001dc4:	4293      	cmp	r3, r2
 8001dc6:	d040      	beq.n	8001e4a <HAL_DMA_Abort+0x58a>
 8001dc8:	687b      	ldr	r3, [r7, #4]
 8001dca:	681b      	ldr	r3, [r3, #0]
 8001dcc:	4a3e      	ldr	r2, [pc, #248]	; (8001ec8 <HAL_DMA_Abort+0x608>)
 8001dce:	4293      	cmp	r3, r2
 8001dd0:	d03b      	beq.n	8001e4a <HAL_DMA_Abort+0x58a>
 8001dd2:	687b      	ldr	r3, [r7, #4]
 8001dd4:	681b      	ldr	r3, [r3, #0]
 8001dd6:	4a3d      	ldr	r2, [pc, #244]	; (8001ecc <HAL_DMA_Abort+0x60c>)
 8001dd8:	4293      	cmp	r3, r2
 8001dda:	d036      	beq.n	8001e4a <HAL_DMA_Abort+0x58a>
 8001ddc:	687b      	ldr	r3, [r7, #4]
 8001dde:	681b      	ldr	r3, [r3, #0]
 8001de0:	4a3b      	ldr	r2, [pc, #236]	; (8001ed0 <HAL_DMA_Abort+0x610>)
 8001de2:	4293      	cmp	r3, r2
 8001de4:	d031      	beq.n	8001e4a <HAL_DMA_Abort+0x58a>
 8001de6:	687b      	ldr	r3, [r7, #4]
 8001de8:	681b      	ldr	r3, [r3, #0]
 8001dea:	4a3a      	ldr	r2, [pc, #232]	; (8001ed4 <HAL_DMA_Abort+0x614>)
 8001dec:	4293      	cmp	r3, r2
 8001dee:	d02c      	beq.n	8001e4a <HAL_DMA_Abort+0x58a>
 8001df0:	687b      	ldr	r3, [r7, #4]
 8001df2:	681b      	ldr	r3, [r3, #0]
 8001df4:	4a38      	ldr	r2, [pc, #224]	; (8001ed8 <HAL_DMA_Abort+0x618>)
 8001df6:	4293      	cmp	r3, r2
 8001df8:	d027      	beq.n	8001e4a <HAL_DMA_Abort+0x58a>
 8001dfa:	687b      	ldr	r3, [r7, #4]
 8001dfc:	681b      	ldr	r3, [r3, #0]
 8001dfe:	4a37      	ldr	r2, [pc, #220]	; (8001edc <HAL_DMA_Abort+0x61c>)
 8001e00:	4293      	cmp	r3, r2
 8001e02:	d022      	beq.n	8001e4a <HAL_DMA_Abort+0x58a>
 8001e04:	687b      	ldr	r3, [r7, #4]
 8001e06:	681b      	ldr	r3, [r3, #0]
 8001e08:	4a35      	ldr	r2, [pc, #212]	; (8001ee0 <HAL_DMA_Abort+0x620>)
 8001e0a:	4293      	cmp	r3, r2
 8001e0c:	d01d      	beq.n	8001e4a <HAL_DMA_Abort+0x58a>
 8001e0e:	687b      	ldr	r3, [r7, #4]
 8001e10:	681b      	ldr	r3, [r3, #0]
 8001e12:	4a34      	ldr	r2, [pc, #208]	; (8001ee4 <HAL_DMA_Abort+0x624>)
 8001e14:	4293      	cmp	r3, r2
 8001e16:	d018      	beq.n	8001e4a <HAL_DMA_Abort+0x58a>
 8001e18:	687b      	ldr	r3, [r7, #4]
 8001e1a:	681b      	ldr	r3, [r3, #0]
 8001e1c:	4a32      	ldr	r2, [pc, #200]	; (8001ee8 <HAL_DMA_Abort+0x628>)
 8001e1e:	4293      	cmp	r3, r2
 8001e20:	d013      	beq.n	8001e4a <HAL_DMA_Abort+0x58a>
 8001e22:	687b      	ldr	r3, [r7, #4]
 8001e24:	681b      	ldr	r3, [r3, #0]
 8001e26:	4a31      	ldr	r2, [pc, #196]	; (8001eec <HAL_DMA_Abort+0x62c>)
 8001e28:	4293      	cmp	r3, r2
 8001e2a:	d00e      	beq.n	8001e4a <HAL_DMA_Abort+0x58a>
 8001e2c:	687b      	ldr	r3, [r7, #4]
 8001e2e:	681b      	ldr	r3, [r3, #0]
 8001e30:	4a2f      	ldr	r2, [pc, #188]	; (8001ef0 <HAL_DMA_Abort+0x630>)
 8001e32:	4293      	cmp	r3, r2
 8001e34:	d009      	beq.n	8001e4a <HAL_DMA_Abort+0x58a>
 8001e36:	687b      	ldr	r3, [r7, #4]
 8001e38:	681b      	ldr	r3, [r3, #0]
 8001e3a:	4a2e      	ldr	r2, [pc, #184]	; (8001ef4 <HAL_DMA_Abort+0x634>)
 8001e3c:	4293      	cmp	r3, r2
 8001e3e:	d004      	beq.n	8001e4a <HAL_DMA_Abort+0x58a>
 8001e40:	687b      	ldr	r3, [r7, #4]
 8001e42:	681b      	ldr	r3, [r3, #0]
 8001e44:	4a2c      	ldr	r2, [pc, #176]	; (8001ef8 <HAL_DMA_Abort+0x638>)
 8001e46:	4293      	cmp	r3, r2
 8001e48:	d101      	bne.n	8001e4e <HAL_DMA_Abort+0x58e>
 8001e4a:	2301      	movs	r3, #1
 8001e4c:	e000      	b.n	8001e50 <HAL_DMA_Abort+0x590>
 8001e4e:	2300      	movs	r3, #0
 8001e50:	2b00      	cmp	r3, #0
 8001e52:	d015      	beq.n	8001e80 <HAL_DMA_Abort+0x5c0>
    {
      /* Clear the DMAMUX synchro overrun flag */
      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8001e54:	687b      	ldr	r3, [r7, #4]
 8001e56:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8001e58:	687a      	ldr	r2, [r7, #4]
 8001e5a:	6e92      	ldr	r2, [r2, #104]	; 0x68
 8001e5c:	605a      	str	r2, [r3, #4]

      if(hdma->DMAmuxRequestGen != 0U)
 8001e5e:	687b      	ldr	r3, [r7, #4]
 8001e60:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8001e62:	2b00      	cmp	r3, #0
 8001e64:	d00c      	beq.n	8001e80 <HAL_DMA_Abort+0x5c0>
      {
        /* if using DMAMUX request generator, disable the DMAMUX request generator overrun IT */
        /* disable the request gen overrun IT */
        hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 8001e66:	687b      	ldr	r3, [r7, #4]
 8001e68:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8001e6a:	681a      	ldr	r2, [r3, #0]
 8001e6c:	687b      	ldr	r3, [r7, #4]
 8001e6e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8001e70:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8001e74:	601a      	str	r2, [r3, #0]

        /* Clear the DMAMUX request generator overrun flag */
        hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8001e76:	687b      	ldr	r3, [r7, #4]
 8001e78:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8001e7a:	687a      	ldr	r2, [r7, #4]
 8001e7c:	6f52      	ldr	r2, [r2, #116]	; 0x74
 8001e7e:	605a      	str	r2, [r3, #4]
      }
    }

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
 8001e80:	687b      	ldr	r3, [r7, #4]
 8001e82:	2201      	movs	r2, #1
 8001e84:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 8001e88:	687b      	ldr	r3, [r7, #4]
 8001e8a:	2200      	movs	r2, #0
 8001e8c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
  }

  return HAL_OK;
 8001e90:	2300      	movs	r3, #0
}
 8001e92:	4618      	mov	r0, r3
 8001e94:	3718      	adds	r7, #24
 8001e96:	46bd      	mov	sp, r7
 8001e98:	bd80      	pop	{r7, pc}
 8001e9a:	bf00      	nop
 8001e9c:	40020010 	.word	0x40020010
 8001ea0:	40020028 	.word	0x40020028
 8001ea4:	40020040 	.word	0x40020040
 8001ea8:	40020058 	.word	0x40020058
 8001eac:	40020070 	.word	0x40020070
 8001eb0:	40020088 	.word	0x40020088
 8001eb4:	400200a0 	.word	0x400200a0
 8001eb8:	400200b8 	.word	0x400200b8
 8001ebc:	40020410 	.word	0x40020410
 8001ec0:	40020428 	.word	0x40020428
 8001ec4:	40020440 	.word	0x40020440
 8001ec8:	40020458 	.word	0x40020458
 8001ecc:	40020470 	.word	0x40020470
 8001ed0:	40020488 	.word	0x40020488
 8001ed4:	400204a0 	.word	0x400204a0
 8001ed8:	400204b8 	.word	0x400204b8
 8001edc:	58025408 	.word	0x58025408
 8001ee0:	5802541c 	.word	0x5802541c
 8001ee4:	58025430 	.word	0x58025430
 8001ee8:	58025444 	.word	0x58025444
 8001eec:	58025458 	.word	0x58025458
 8001ef0:	5802546c 	.word	0x5802546c
 8001ef4:	58025480 	.word	0x58025480
 8001ef8:	58025494 	.word	0x58025494

08001efc <HAL_DMA_Abort_IT>:
  * @param  hdma  : pointer to a DMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
 8001efc:	b580      	push	{r7, lr}
 8001efe:	b084      	sub	sp, #16
 8001f00:	af00      	add	r7, sp, #0
 8001f02:	6078      	str	r0, [r7, #4]
  BDMA_Base_Registers *regs_bdma;

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
 8001f04:	687b      	ldr	r3, [r7, #4]
 8001f06:	2b00      	cmp	r3, #0
 8001f08:	d101      	bne.n	8001f0e <HAL_DMA_Abort_IT+0x12>
  {
    return HAL_ERROR;
 8001f0a:	2301      	movs	r3, #1
 8001f0c:	e205      	b.n	800231a <HAL_DMA_Abort_IT+0x41e>
  }

  if(hdma->State != HAL_DMA_STATE_BUSY)
 8001f0e:	687b      	ldr	r3, [r7, #4]
 8001f10:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8001f14:	b2db      	uxtb	r3, r3
 8001f16:	2b02      	cmp	r3, #2
 8001f18:	d004      	beq.n	8001f24 <HAL_DMA_Abort_IT+0x28>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8001f1a:	687b      	ldr	r3, [r7, #4]
 8001f1c:	2280      	movs	r2, #128	; 0x80
 8001f1e:	655a      	str	r2, [r3, #84]	; 0x54
    return HAL_ERROR;
 8001f20:	2301      	movs	r3, #1
 8001f22:	e1fa      	b.n	800231a <HAL_DMA_Abort_IT+0x41e>
  }
  else
  {
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8001f24:	687b      	ldr	r3, [r7, #4]
 8001f26:	681b      	ldr	r3, [r3, #0]
 8001f28:	4a8c      	ldr	r2, [pc, #560]	; (800215c <HAL_DMA_Abort_IT+0x260>)
 8001f2a:	4293      	cmp	r3, r2
 8001f2c:	d04a      	beq.n	8001fc4 <HAL_DMA_Abort_IT+0xc8>
 8001f2e:	687b      	ldr	r3, [r7, #4]
 8001f30:	681b      	ldr	r3, [r3, #0]
 8001f32:	4a8b      	ldr	r2, [pc, #556]	; (8002160 <HAL_DMA_Abort_IT+0x264>)
 8001f34:	4293      	cmp	r3, r2
 8001f36:	d045      	beq.n	8001fc4 <HAL_DMA_Abort_IT+0xc8>
 8001f38:	687b      	ldr	r3, [r7, #4]
 8001f3a:	681b      	ldr	r3, [r3, #0]
 8001f3c:	4a89      	ldr	r2, [pc, #548]	; (8002164 <HAL_DMA_Abort_IT+0x268>)
 8001f3e:	4293      	cmp	r3, r2
 8001f40:	d040      	beq.n	8001fc4 <HAL_DMA_Abort_IT+0xc8>
 8001f42:	687b      	ldr	r3, [r7, #4]
 8001f44:	681b      	ldr	r3, [r3, #0]
 8001f46:	4a88      	ldr	r2, [pc, #544]	; (8002168 <HAL_DMA_Abort_IT+0x26c>)
 8001f48:	4293      	cmp	r3, r2
 8001f4a:	d03b      	beq.n	8001fc4 <HAL_DMA_Abort_IT+0xc8>
 8001f4c:	687b      	ldr	r3, [r7, #4]
 8001f4e:	681b      	ldr	r3, [r3, #0]
 8001f50:	4a86      	ldr	r2, [pc, #536]	; (800216c <HAL_DMA_Abort_IT+0x270>)
 8001f52:	4293      	cmp	r3, r2
 8001f54:	d036      	beq.n	8001fc4 <HAL_DMA_Abort_IT+0xc8>
 8001f56:	687b      	ldr	r3, [r7, #4]
 8001f58:	681b      	ldr	r3, [r3, #0]
 8001f5a:	4a85      	ldr	r2, [pc, #532]	; (8002170 <HAL_DMA_Abort_IT+0x274>)
 8001f5c:	4293      	cmp	r3, r2
 8001f5e:	d031      	beq.n	8001fc4 <HAL_DMA_Abort_IT+0xc8>
 8001f60:	687b      	ldr	r3, [r7, #4]
 8001f62:	681b      	ldr	r3, [r3, #0]
 8001f64:	4a83      	ldr	r2, [pc, #524]	; (8002174 <HAL_DMA_Abort_IT+0x278>)
 8001f66:	4293      	cmp	r3, r2
 8001f68:	d02c      	beq.n	8001fc4 <HAL_DMA_Abort_IT+0xc8>
 8001f6a:	687b      	ldr	r3, [r7, #4]
 8001f6c:	681b      	ldr	r3, [r3, #0]
 8001f6e:	4a82      	ldr	r2, [pc, #520]	; (8002178 <HAL_DMA_Abort_IT+0x27c>)
 8001f70:	4293      	cmp	r3, r2
 8001f72:	d027      	beq.n	8001fc4 <HAL_DMA_Abort_IT+0xc8>
 8001f74:	687b      	ldr	r3, [r7, #4]
 8001f76:	681b      	ldr	r3, [r3, #0]
 8001f78:	4a80      	ldr	r2, [pc, #512]	; (800217c <HAL_DMA_Abort_IT+0x280>)
 8001f7a:	4293      	cmp	r3, r2
 8001f7c:	d022      	beq.n	8001fc4 <HAL_DMA_Abort_IT+0xc8>
 8001f7e:	687b      	ldr	r3, [r7, #4]
 8001f80:	681b      	ldr	r3, [r3, #0]
 8001f82:	4a7f      	ldr	r2, [pc, #508]	; (8002180 <HAL_DMA_Abort_IT+0x284>)
 8001f84:	4293      	cmp	r3, r2
 8001f86:	d01d      	beq.n	8001fc4 <HAL_DMA_Abort_IT+0xc8>
 8001f88:	687b      	ldr	r3, [r7, #4]
 8001f8a:	681b      	ldr	r3, [r3, #0]
 8001f8c:	4a7d      	ldr	r2, [pc, #500]	; (8002184 <HAL_DMA_Abort_IT+0x288>)
 8001f8e:	4293      	cmp	r3, r2
 8001f90:	d018      	beq.n	8001fc4 <HAL_DMA_Abort_IT+0xc8>
 8001f92:	687b      	ldr	r3, [r7, #4]
 8001f94:	681b      	ldr	r3, [r3, #0]
 8001f96:	4a7c      	ldr	r2, [pc, #496]	; (8002188 <HAL_DMA_Abort_IT+0x28c>)
 8001f98:	4293      	cmp	r3, r2
 8001f9a:	d013      	beq.n	8001fc4 <HAL_DMA_Abort_IT+0xc8>
 8001f9c:	687b      	ldr	r3, [r7, #4]
 8001f9e:	681b      	ldr	r3, [r3, #0]
 8001fa0:	4a7a      	ldr	r2, [pc, #488]	; (800218c <HAL_DMA_Abort_IT+0x290>)
 8001fa2:	4293      	cmp	r3, r2
 8001fa4:	d00e      	beq.n	8001fc4 <HAL_DMA_Abort_IT+0xc8>
 8001fa6:	687b      	ldr	r3, [r7, #4]
 8001fa8:	681b      	ldr	r3, [r3, #0]
 8001faa:	4a79      	ldr	r2, [pc, #484]	; (8002190 <HAL_DMA_Abort_IT+0x294>)
 8001fac:	4293      	cmp	r3, r2
 8001fae:	d009      	beq.n	8001fc4 <HAL_DMA_Abort_IT+0xc8>
 8001fb0:	687b      	ldr	r3, [r7, #4]
 8001fb2:	681b      	ldr	r3, [r3, #0]
 8001fb4:	4a77      	ldr	r2, [pc, #476]	; (8002194 <HAL_DMA_Abort_IT+0x298>)
 8001fb6:	4293      	cmp	r3, r2
 8001fb8:	d004      	beq.n	8001fc4 <HAL_DMA_Abort_IT+0xc8>
 8001fba:	687b      	ldr	r3, [r7, #4]
 8001fbc:	681b      	ldr	r3, [r3, #0]
 8001fbe:	4a76      	ldr	r2, [pc, #472]	; (8002198 <HAL_DMA_Abort_IT+0x29c>)
 8001fc0:	4293      	cmp	r3, r2
 8001fc2:	d101      	bne.n	8001fc8 <HAL_DMA_Abort_IT+0xcc>
 8001fc4:	2301      	movs	r3, #1
 8001fc6:	e000      	b.n	8001fca <HAL_DMA_Abort_IT+0xce>
 8001fc8:	2300      	movs	r3, #0
 8001fca:	2b00      	cmp	r3, #0
 8001fcc:	d065      	beq.n	800209a <HAL_DMA_Abort_IT+0x19e>
    {
      /* Set Abort State  */
      hdma->State = HAL_DMA_STATE_ABORT;
 8001fce:	687b      	ldr	r3, [r7, #4]
 8001fd0:	2204      	movs	r2, #4
 8001fd2:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Disable the stream */
      __HAL_DMA_DISABLE(hdma);
 8001fd6:	687b      	ldr	r3, [r7, #4]
 8001fd8:	681b      	ldr	r3, [r3, #0]
 8001fda:	4a60      	ldr	r2, [pc, #384]	; (800215c <HAL_DMA_Abort_IT+0x260>)
 8001fdc:	4293      	cmp	r3, r2
 8001fde:	d04a      	beq.n	8002076 <HAL_DMA_Abort_IT+0x17a>
 8001fe0:	687b      	ldr	r3, [r7, #4]
 8001fe2:	681b      	ldr	r3, [r3, #0]
 8001fe4:	4a5e      	ldr	r2, [pc, #376]	; (8002160 <HAL_DMA_Abort_IT+0x264>)
 8001fe6:	4293      	cmp	r3, r2
 8001fe8:	d045      	beq.n	8002076 <HAL_DMA_Abort_IT+0x17a>
 8001fea:	687b      	ldr	r3, [r7, #4]
 8001fec:	681b      	ldr	r3, [r3, #0]
 8001fee:	4a5d      	ldr	r2, [pc, #372]	; (8002164 <HAL_DMA_Abort_IT+0x268>)
 8001ff0:	4293      	cmp	r3, r2
 8001ff2:	d040      	beq.n	8002076 <HAL_DMA_Abort_IT+0x17a>
 8001ff4:	687b      	ldr	r3, [r7, #4]
 8001ff6:	681b      	ldr	r3, [r3, #0]
 8001ff8:	4a5b      	ldr	r2, [pc, #364]	; (8002168 <HAL_DMA_Abort_IT+0x26c>)
 8001ffa:	4293      	cmp	r3, r2
 8001ffc:	d03b      	beq.n	8002076 <HAL_DMA_Abort_IT+0x17a>
 8001ffe:	687b      	ldr	r3, [r7, #4]
 8002000:	681b      	ldr	r3, [r3, #0]
 8002002:	4a5a      	ldr	r2, [pc, #360]	; (800216c <HAL_DMA_Abort_IT+0x270>)
 8002004:	4293      	cmp	r3, r2
 8002006:	d036      	beq.n	8002076 <HAL_DMA_Abort_IT+0x17a>
 8002008:	687b      	ldr	r3, [r7, #4]
 800200a:	681b      	ldr	r3, [r3, #0]
 800200c:	4a58      	ldr	r2, [pc, #352]	; (8002170 <HAL_DMA_Abort_IT+0x274>)
 800200e:	4293      	cmp	r3, r2
 8002010:	d031      	beq.n	8002076 <HAL_DMA_Abort_IT+0x17a>
 8002012:	687b      	ldr	r3, [r7, #4]
 8002014:	681b      	ldr	r3, [r3, #0]
 8002016:	4a57      	ldr	r2, [pc, #348]	; (8002174 <HAL_DMA_Abort_IT+0x278>)
 8002018:	4293      	cmp	r3, r2
 800201a:	d02c      	beq.n	8002076 <HAL_DMA_Abort_IT+0x17a>
 800201c:	687b      	ldr	r3, [r7, #4]
 800201e:	681b      	ldr	r3, [r3, #0]
 8002020:	4a55      	ldr	r2, [pc, #340]	; (8002178 <HAL_DMA_Abort_IT+0x27c>)
 8002022:	4293      	cmp	r3, r2
 8002024:	d027      	beq.n	8002076 <HAL_DMA_Abort_IT+0x17a>
 8002026:	687b      	ldr	r3, [r7, #4]
 8002028:	681b      	ldr	r3, [r3, #0]
 800202a:	4a54      	ldr	r2, [pc, #336]	; (800217c <HAL_DMA_Abort_IT+0x280>)
 800202c:	4293      	cmp	r3, r2
 800202e:	d022      	beq.n	8002076 <HAL_DMA_Abort_IT+0x17a>
 8002030:	687b      	ldr	r3, [r7, #4]
 8002032:	681b      	ldr	r3, [r3, #0]
 8002034:	4a52      	ldr	r2, [pc, #328]	; (8002180 <HAL_DMA_Abort_IT+0x284>)
 8002036:	4293      	cmp	r3, r2
 8002038:	d01d      	beq.n	8002076 <HAL_DMA_Abort_IT+0x17a>
 800203a:	687b      	ldr	r3, [r7, #4]
 800203c:	681b      	ldr	r3, [r3, #0]
 800203e:	4a51      	ldr	r2, [pc, #324]	; (8002184 <HAL_DMA_Abort_IT+0x288>)
 8002040:	4293      	cmp	r3, r2
 8002042:	d018      	beq.n	8002076 <HAL_DMA_Abort_IT+0x17a>
 8002044:	687b      	ldr	r3, [r7, #4]
 8002046:	681b      	ldr	r3, [r3, #0]
 8002048:	4a4f      	ldr	r2, [pc, #316]	; (8002188 <HAL_DMA_Abort_IT+0x28c>)
 800204a:	4293      	cmp	r3, r2
 800204c:	d013      	beq.n	8002076 <HAL_DMA_Abort_IT+0x17a>
 800204e:	687b      	ldr	r3, [r7, #4]
 8002050:	681b      	ldr	r3, [r3, #0]
 8002052:	4a4e      	ldr	r2, [pc, #312]	; (800218c <HAL_DMA_Abort_IT+0x290>)
 8002054:	4293      	cmp	r3, r2
 8002056:	d00e      	beq.n	8002076 <HAL_DMA_Abort_IT+0x17a>
 8002058:	687b      	ldr	r3, [r7, #4]
 800205a:	681b      	ldr	r3, [r3, #0]
 800205c:	4a4c      	ldr	r2, [pc, #304]	; (8002190 <HAL_DMA_Abort_IT+0x294>)
 800205e:	4293      	cmp	r3, r2
 8002060:	d009      	beq.n	8002076 <HAL_DMA_Abort_IT+0x17a>
 8002062:	687b      	ldr	r3, [r7, #4]
 8002064:	681b      	ldr	r3, [r3, #0]
 8002066:	4a4b      	ldr	r2, [pc, #300]	; (8002194 <HAL_DMA_Abort_IT+0x298>)
 8002068:	4293      	cmp	r3, r2
 800206a:	d004      	beq.n	8002076 <HAL_DMA_Abort_IT+0x17a>
 800206c:	687b      	ldr	r3, [r7, #4]
 800206e:	681b      	ldr	r3, [r3, #0]
 8002070:	4a49      	ldr	r2, [pc, #292]	; (8002198 <HAL_DMA_Abort_IT+0x29c>)
 8002072:	4293      	cmp	r3, r2
 8002074:	d108      	bne.n	8002088 <HAL_DMA_Abort_IT+0x18c>
 8002076:	687b      	ldr	r3, [r7, #4]
 8002078:	681b      	ldr	r3, [r3, #0]
 800207a:	681a      	ldr	r2, [r3, #0]
 800207c:	687b      	ldr	r3, [r7, #4]
 800207e:	681b      	ldr	r3, [r3, #0]
 8002080:	f022 0201 	bic.w	r2, r2, #1
 8002084:	601a      	str	r2, [r3, #0]
 8002086:	e147      	b.n	8002318 <HAL_DMA_Abort_IT+0x41c>
 8002088:	687b      	ldr	r3, [r7, #4]
 800208a:	681b      	ldr	r3, [r3, #0]
 800208c:	681a      	ldr	r2, [r3, #0]
 800208e:	687b      	ldr	r3, [r7, #4]
 8002090:	681b      	ldr	r3, [r3, #0]
 8002092:	f022 0201 	bic.w	r2, r2, #1
 8002096:	601a      	str	r2, [r3, #0]
 8002098:	e13e      	b.n	8002318 <HAL_DMA_Abort_IT+0x41c>
    }
    else /* BDMA channel */
    {
      /* Disable DMA All Interrupts  */
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
 800209a:	687b      	ldr	r3, [r7, #4]
 800209c:	681b      	ldr	r3, [r3, #0]
 800209e:	681a      	ldr	r2, [r3, #0]
 80020a0:	687b      	ldr	r3, [r7, #4]
 80020a2:	681b      	ldr	r3, [r3, #0]
 80020a4:	f022 020e 	bic.w	r2, r2, #14
 80020a8:	601a      	str	r2, [r3, #0]

      /* Disable the channel */
      __HAL_DMA_DISABLE(hdma);
 80020aa:	687b      	ldr	r3, [r7, #4]
 80020ac:	681b      	ldr	r3, [r3, #0]
 80020ae:	4a2b      	ldr	r2, [pc, #172]	; (800215c <HAL_DMA_Abort_IT+0x260>)
 80020b0:	4293      	cmp	r3, r2
 80020b2:	d04a      	beq.n	800214a <HAL_DMA_Abort_IT+0x24e>
 80020b4:	687b      	ldr	r3, [r7, #4]
 80020b6:	681b      	ldr	r3, [r3, #0]
 80020b8:	4a29      	ldr	r2, [pc, #164]	; (8002160 <HAL_DMA_Abort_IT+0x264>)
 80020ba:	4293      	cmp	r3, r2
 80020bc:	d045      	beq.n	800214a <HAL_DMA_Abort_IT+0x24e>
 80020be:	687b      	ldr	r3, [r7, #4]
 80020c0:	681b      	ldr	r3, [r3, #0]
 80020c2:	4a28      	ldr	r2, [pc, #160]	; (8002164 <HAL_DMA_Abort_IT+0x268>)
 80020c4:	4293      	cmp	r3, r2
 80020c6:	d040      	beq.n	800214a <HAL_DMA_Abort_IT+0x24e>
 80020c8:	687b      	ldr	r3, [r7, #4]
 80020ca:	681b      	ldr	r3, [r3, #0]
 80020cc:	4a26      	ldr	r2, [pc, #152]	; (8002168 <HAL_DMA_Abort_IT+0x26c>)
 80020ce:	4293      	cmp	r3, r2
 80020d0:	d03b      	beq.n	800214a <HAL_DMA_Abort_IT+0x24e>
 80020d2:	687b      	ldr	r3, [r7, #4]
 80020d4:	681b      	ldr	r3, [r3, #0]
 80020d6:	4a25      	ldr	r2, [pc, #148]	; (800216c <HAL_DMA_Abort_IT+0x270>)
 80020d8:	4293      	cmp	r3, r2
 80020da:	d036      	beq.n	800214a <HAL_DMA_Abort_IT+0x24e>
 80020dc:	687b      	ldr	r3, [r7, #4]
 80020de:	681b      	ldr	r3, [r3, #0]
 80020e0:	4a23      	ldr	r2, [pc, #140]	; (8002170 <HAL_DMA_Abort_IT+0x274>)
 80020e2:	4293      	cmp	r3, r2
 80020e4:	d031      	beq.n	800214a <HAL_DMA_Abort_IT+0x24e>
 80020e6:	687b      	ldr	r3, [r7, #4]
 80020e8:	681b      	ldr	r3, [r3, #0]
 80020ea:	4a22      	ldr	r2, [pc, #136]	; (8002174 <HAL_DMA_Abort_IT+0x278>)
 80020ec:	4293      	cmp	r3, r2
 80020ee:	d02c      	beq.n	800214a <HAL_DMA_Abort_IT+0x24e>
 80020f0:	687b      	ldr	r3, [r7, #4]
 80020f2:	681b      	ldr	r3, [r3, #0]
 80020f4:	4a20      	ldr	r2, [pc, #128]	; (8002178 <HAL_DMA_Abort_IT+0x27c>)
 80020f6:	4293      	cmp	r3, r2
 80020f8:	d027      	beq.n	800214a <HAL_DMA_Abort_IT+0x24e>
 80020fa:	687b      	ldr	r3, [r7, #4]
 80020fc:	681b      	ldr	r3, [r3, #0]
 80020fe:	4a1f      	ldr	r2, [pc, #124]	; (800217c <HAL_DMA_Abort_IT+0x280>)
 8002100:	4293      	cmp	r3, r2
 8002102:	d022      	beq.n	800214a <HAL_DMA_Abort_IT+0x24e>
 8002104:	687b      	ldr	r3, [r7, #4]
 8002106:	681b      	ldr	r3, [r3, #0]
 8002108:	4a1d      	ldr	r2, [pc, #116]	; (8002180 <HAL_DMA_Abort_IT+0x284>)
 800210a:	4293      	cmp	r3, r2
 800210c:	d01d      	beq.n	800214a <HAL_DMA_Abort_IT+0x24e>
 800210e:	687b      	ldr	r3, [r7, #4]
 8002110:	681b      	ldr	r3, [r3, #0]
 8002112:	4a1c      	ldr	r2, [pc, #112]	; (8002184 <HAL_DMA_Abort_IT+0x288>)
 8002114:	4293      	cmp	r3, r2
 8002116:	d018      	beq.n	800214a <HAL_DMA_Abort_IT+0x24e>
 8002118:	687b      	ldr	r3, [r7, #4]
 800211a:	681b      	ldr	r3, [r3, #0]
 800211c:	4a1a      	ldr	r2, [pc, #104]	; (8002188 <HAL_DMA_Abort_IT+0x28c>)
 800211e:	4293      	cmp	r3, r2
 8002120:	d013      	beq.n	800214a <HAL_DMA_Abort_IT+0x24e>
 8002122:	687b      	ldr	r3, [r7, #4]
 8002124:	681b      	ldr	r3, [r3, #0]
 8002126:	4a19      	ldr	r2, [pc, #100]	; (800218c <HAL_DMA_Abort_IT+0x290>)
 8002128:	4293      	cmp	r3, r2
 800212a:	d00e      	beq.n	800214a <HAL_DMA_Abort_IT+0x24e>
 800212c:	687b      	ldr	r3, [r7, #4]
 800212e:	681b      	ldr	r3, [r3, #0]
 8002130:	4a17      	ldr	r2, [pc, #92]	; (8002190 <HAL_DMA_Abort_IT+0x294>)
 8002132:	4293      	cmp	r3, r2
 8002134:	d009      	beq.n	800214a <HAL_DMA_Abort_IT+0x24e>
 8002136:	687b      	ldr	r3, [r7, #4]
 8002138:	681b      	ldr	r3, [r3, #0]
 800213a:	4a16      	ldr	r2, [pc, #88]	; (8002194 <HAL_DMA_Abort_IT+0x298>)
 800213c:	4293      	cmp	r3, r2
 800213e:	d004      	beq.n	800214a <HAL_DMA_Abort_IT+0x24e>
 8002140:	687b      	ldr	r3, [r7, #4]
 8002142:	681b      	ldr	r3, [r3, #0]
 8002144:	4a14      	ldr	r2, [pc, #80]	; (8002198 <HAL_DMA_Abort_IT+0x29c>)
 8002146:	4293      	cmp	r3, r2
 8002148:	d128      	bne.n	800219c <HAL_DMA_Abort_IT+0x2a0>
 800214a:	687b      	ldr	r3, [r7, #4]
 800214c:	681b      	ldr	r3, [r3, #0]
 800214e:	681a      	ldr	r2, [r3, #0]
 8002150:	687b      	ldr	r3, [r7, #4]
 8002152:	681b      	ldr	r3, [r3, #0]
 8002154:	f022 0201 	bic.w	r2, r2, #1
 8002158:	601a      	str	r2, [r3, #0]
 800215a:	e027      	b.n	80021ac <HAL_DMA_Abort_IT+0x2b0>
 800215c:	40020010 	.word	0x40020010
 8002160:	40020028 	.word	0x40020028
 8002164:	40020040 	.word	0x40020040
 8002168:	40020058 	.word	0x40020058
 800216c:	40020070 	.word	0x40020070
 8002170:	40020088 	.word	0x40020088
 8002174:	400200a0 	.word	0x400200a0
 8002178:	400200b8 	.word	0x400200b8
 800217c:	40020410 	.word	0x40020410
 8002180:	40020428 	.word	0x40020428
 8002184:	40020440 	.word	0x40020440
 8002188:	40020458 	.word	0x40020458
 800218c:	40020470 	.word	0x40020470
 8002190:	40020488 	.word	0x40020488
 8002194:	400204a0 	.word	0x400204a0
 8002198:	400204b8 	.word	0x400204b8
 800219c:	687b      	ldr	r3, [r7, #4]
 800219e:	681b      	ldr	r3, [r3, #0]
 80021a0:	681a      	ldr	r2, [r3, #0]
 80021a2:	687b      	ldr	r3, [r7, #4]
 80021a4:	681b      	ldr	r3, [r3, #0]
 80021a6:	f022 0201 	bic.w	r2, r2, #1
 80021aa:	601a      	str	r2, [r3, #0]

      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 80021ac:	687b      	ldr	r3, [r7, #4]
 80021ae:	681b      	ldr	r3, [r3, #0]
 80021b0:	4a5c      	ldr	r2, [pc, #368]	; (8002324 <HAL_DMA_Abort_IT+0x428>)
 80021b2:	4293      	cmp	r3, r2
 80021b4:	d072      	beq.n	800229c <HAL_DMA_Abort_IT+0x3a0>
 80021b6:	687b      	ldr	r3, [r7, #4]
 80021b8:	681b      	ldr	r3, [r3, #0]
 80021ba:	4a5b      	ldr	r2, [pc, #364]	; (8002328 <HAL_DMA_Abort_IT+0x42c>)
 80021bc:	4293      	cmp	r3, r2
 80021be:	d06d      	beq.n	800229c <HAL_DMA_Abort_IT+0x3a0>
 80021c0:	687b      	ldr	r3, [r7, #4]
 80021c2:	681b      	ldr	r3, [r3, #0]
 80021c4:	4a59      	ldr	r2, [pc, #356]	; (800232c <HAL_DMA_Abort_IT+0x430>)
 80021c6:	4293      	cmp	r3, r2
 80021c8:	d068      	beq.n	800229c <HAL_DMA_Abort_IT+0x3a0>
 80021ca:	687b      	ldr	r3, [r7, #4]
 80021cc:	681b      	ldr	r3, [r3, #0]
 80021ce:	4a58      	ldr	r2, [pc, #352]	; (8002330 <HAL_DMA_Abort_IT+0x434>)
 80021d0:	4293      	cmp	r3, r2
 80021d2:	d063      	beq.n	800229c <HAL_DMA_Abort_IT+0x3a0>
 80021d4:	687b      	ldr	r3, [r7, #4]
 80021d6:	681b      	ldr	r3, [r3, #0]
 80021d8:	4a56      	ldr	r2, [pc, #344]	; (8002334 <HAL_DMA_Abort_IT+0x438>)
 80021da:	4293      	cmp	r3, r2
 80021dc:	d05e      	beq.n	800229c <HAL_DMA_Abort_IT+0x3a0>
 80021de:	687b      	ldr	r3, [r7, #4]
 80021e0:	681b      	ldr	r3, [r3, #0]
 80021e2:	4a55      	ldr	r2, [pc, #340]	; (8002338 <HAL_DMA_Abort_IT+0x43c>)
 80021e4:	4293      	cmp	r3, r2
 80021e6:	d059      	beq.n	800229c <HAL_DMA_Abort_IT+0x3a0>
 80021e8:	687b      	ldr	r3, [r7, #4]
 80021ea:	681b      	ldr	r3, [r3, #0]
 80021ec:	4a53      	ldr	r2, [pc, #332]	; (800233c <HAL_DMA_Abort_IT+0x440>)
 80021ee:	4293      	cmp	r3, r2
 80021f0:	d054      	beq.n	800229c <HAL_DMA_Abort_IT+0x3a0>
 80021f2:	687b      	ldr	r3, [r7, #4]
 80021f4:	681b      	ldr	r3, [r3, #0]
 80021f6:	4a52      	ldr	r2, [pc, #328]	; (8002340 <HAL_DMA_Abort_IT+0x444>)
 80021f8:	4293      	cmp	r3, r2
 80021fa:	d04f      	beq.n	800229c <HAL_DMA_Abort_IT+0x3a0>
 80021fc:	687b      	ldr	r3, [r7, #4]
 80021fe:	681b      	ldr	r3, [r3, #0]
 8002200:	4a50      	ldr	r2, [pc, #320]	; (8002344 <HAL_DMA_Abort_IT+0x448>)
 8002202:	4293      	cmp	r3, r2
 8002204:	d04a      	beq.n	800229c <HAL_DMA_Abort_IT+0x3a0>
 8002206:	687b      	ldr	r3, [r7, #4]
 8002208:	681b      	ldr	r3, [r3, #0]
 800220a:	4a4f      	ldr	r2, [pc, #316]	; (8002348 <HAL_DMA_Abort_IT+0x44c>)
 800220c:	4293      	cmp	r3, r2
 800220e:	d045      	beq.n	800229c <HAL_DMA_Abort_IT+0x3a0>
 8002210:	687b      	ldr	r3, [r7, #4]
 8002212:	681b      	ldr	r3, [r3, #0]
 8002214:	4a4d      	ldr	r2, [pc, #308]	; (800234c <HAL_DMA_Abort_IT+0x450>)
 8002216:	4293      	cmp	r3, r2
 8002218:	d040      	beq.n	800229c <HAL_DMA_Abort_IT+0x3a0>
 800221a:	687b      	ldr	r3, [r7, #4]
 800221c:	681b      	ldr	r3, [r3, #0]
 800221e:	4a4c      	ldr	r2, [pc, #304]	; (8002350 <HAL_DMA_Abort_IT+0x454>)
 8002220:	4293      	cmp	r3, r2
 8002222:	d03b      	beq.n	800229c <HAL_DMA_Abort_IT+0x3a0>
 8002224:	687b      	ldr	r3, [r7, #4]
 8002226:	681b      	ldr	r3, [r3, #0]
 8002228:	4a4a      	ldr	r2, [pc, #296]	; (8002354 <HAL_DMA_Abort_IT+0x458>)
 800222a:	4293      	cmp	r3, r2
 800222c:	d036      	beq.n	800229c <HAL_DMA_Abort_IT+0x3a0>
 800222e:	687b      	ldr	r3, [r7, #4]
 8002230:	681b      	ldr	r3, [r3, #0]
 8002232:	4a49      	ldr	r2, [pc, #292]	; (8002358 <HAL_DMA_Abort_IT+0x45c>)
 8002234:	4293      	cmp	r3, r2
 8002236:	d031      	beq.n	800229c <HAL_DMA_Abort_IT+0x3a0>
 8002238:	687b      	ldr	r3, [r7, #4]
 800223a:	681b      	ldr	r3, [r3, #0]
 800223c:	4a47      	ldr	r2, [pc, #284]	; (800235c <HAL_DMA_Abort_IT+0x460>)
 800223e:	4293      	cmp	r3, r2
 8002240:	d02c      	beq.n	800229c <HAL_DMA_Abort_IT+0x3a0>
 8002242:	687b      	ldr	r3, [r7, #4]
 8002244:	681b      	ldr	r3, [r3, #0]
 8002246:	4a46      	ldr	r2, [pc, #280]	; (8002360 <HAL_DMA_Abort_IT+0x464>)
 8002248:	4293      	cmp	r3, r2
 800224a:	d027      	beq.n	800229c <HAL_DMA_Abort_IT+0x3a0>
 800224c:	687b      	ldr	r3, [r7, #4]
 800224e:	681b      	ldr	r3, [r3, #0]
 8002250:	4a44      	ldr	r2, [pc, #272]	; (8002364 <HAL_DMA_Abort_IT+0x468>)
 8002252:	4293      	cmp	r3, r2
 8002254:	d022      	beq.n	800229c <HAL_DMA_Abort_IT+0x3a0>
 8002256:	687b      	ldr	r3, [r7, #4]
 8002258:	681b      	ldr	r3, [r3, #0]
 800225a:	4a43      	ldr	r2, [pc, #268]	; (8002368 <HAL_DMA_Abort_IT+0x46c>)
 800225c:	4293      	cmp	r3, r2
 800225e:	d01d      	beq.n	800229c <HAL_DMA_Abort_IT+0x3a0>
 8002260:	687b      	ldr	r3, [r7, #4]
 8002262:	681b      	ldr	r3, [r3, #0]
 8002264:	4a41      	ldr	r2, [pc, #260]	; (800236c <HAL_DMA_Abort_IT+0x470>)
 8002266:	4293      	cmp	r3, r2
 8002268:	d018      	beq.n	800229c <HAL_DMA_Abort_IT+0x3a0>
 800226a:	687b      	ldr	r3, [r7, #4]
 800226c:	681b      	ldr	r3, [r3, #0]
 800226e:	4a40      	ldr	r2, [pc, #256]	; (8002370 <HAL_DMA_Abort_IT+0x474>)
 8002270:	4293      	cmp	r3, r2
 8002272:	d013      	beq.n	800229c <HAL_DMA_Abort_IT+0x3a0>
 8002274:	687b      	ldr	r3, [r7, #4]
 8002276:	681b      	ldr	r3, [r3, #0]
 8002278:	4a3e      	ldr	r2, [pc, #248]	; (8002374 <HAL_DMA_Abort_IT+0x478>)
 800227a:	4293      	cmp	r3, r2
 800227c:	d00e      	beq.n	800229c <HAL_DMA_Abort_IT+0x3a0>
 800227e:	687b      	ldr	r3, [r7, #4]
 8002280:	681b      	ldr	r3, [r3, #0]
 8002282:	4a3d      	ldr	r2, [pc, #244]	; (8002378 <HAL_DMA_Abort_IT+0x47c>)
 8002284:	4293      	cmp	r3, r2
 8002286:	d009      	beq.n	800229c <HAL_DMA_Abort_IT+0x3a0>
 8002288:	687b      	ldr	r3, [r7, #4]
 800228a:	681b      	ldr	r3, [r3, #0]
 800228c:	4a3b      	ldr	r2, [pc, #236]	; (800237c <HAL_DMA_Abort_IT+0x480>)
 800228e:	4293      	cmp	r3, r2
 8002290:	d004      	beq.n	800229c <HAL_DMA_Abort_IT+0x3a0>
 8002292:	687b      	ldr	r3, [r7, #4]
 8002294:	681b      	ldr	r3, [r3, #0]
 8002296:	4a3a      	ldr	r2, [pc, #232]	; (8002380 <HAL_DMA_Abort_IT+0x484>)
 8002298:	4293      	cmp	r3, r2
 800229a:	d101      	bne.n	80022a0 <HAL_DMA_Abort_IT+0x3a4>
 800229c:	2301      	movs	r3, #1
 800229e:	e000      	b.n	80022a2 <HAL_DMA_Abort_IT+0x3a6>
 80022a0:	2300      	movs	r3, #0
 80022a2:	2b00      	cmp	r3, #0
 80022a4:	d028      	beq.n	80022f8 <HAL_DMA_Abort_IT+0x3fc>
      {
        /* disable the DMAMUX sync overrun IT */
        hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 80022a6:	687b      	ldr	r3, [r7, #4]
 80022a8:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80022aa:	681a      	ldr	r2, [r3, #0]
 80022ac:	687b      	ldr	r3, [r7, #4]
 80022ae:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80022b0:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 80022b4:	601a      	str	r2, [r3, #0]

        /* Clear all flags */
        regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
 80022b6:	687b      	ldr	r3, [r7, #4]
 80022b8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80022ba:	60fb      	str	r3, [r7, #12]
        regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
 80022bc:	687b      	ldr	r3, [r7, #4]
 80022be:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80022c0:	f003 031f 	and.w	r3, r3, #31
 80022c4:	2201      	movs	r2, #1
 80022c6:	409a      	lsls	r2, r3
 80022c8:	68fb      	ldr	r3, [r7, #12]
 80022ca:	605a      	str	r2, [r3, #4]

        /* Clear the DMAMUX synchro overrun flag */
        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 80022cc:	687b      	ldr	r3, [r7, #4]
 80022ce:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80022d0:	687a      	ldr	r2, [r7, #4]
 80022d2:	6e92      	ldr	r2, [r2, #104]	; 0x68
 80022d4:	605a      	str	r2, [r3, #4]

        if(hdma->DMAmuxRequestGen != 0U)
 80022d6:	687b      	ldr	r3, [r7, #4]
 80022d8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80022da:	2b00      	cmp	r3, #0
 80022dc:	d00c      	beq.n	80022f8 <HAL_DMA_Abort_IT+0x3fc>
        {
          /* if using DMAMUX request generator, disable the DMAMUX request generator overrun IT*/
          /* disable the request gen overrun IT */
          hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 80022de:	687b      	ldr	r3, [r7, #4]
 80022e0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80022e2:	681a      	ldr	r2, [r3, #0]
 80022e4:	687b      	ldr	r3, [r7, #4]
 80022e6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80022e8:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 80022ec:	601a      	str	r2, [r3, #0]

          /* Clear the DMAMUX request generator overrun flag */
          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 80022ee:	687b      	ldr	r3, [r7, #4]
 80022f0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80022f2:	687a      	ldr	r2, [r7, #4]
 80022f4:	6f52      	ldr	r2, [r2, #116]	; 0x74
 80022f6:	605a      	str	r2, [r3, #4]
        }
      }

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
 80022f8:	687b      	ldr	r3, [r7, #4]
 80022fa:	2201      	movs	r2, #1
 80022fc:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 8002300:	687b      	ldr	r3, [r7, #4]
 8002302:	2200      	movs	r2, #0
 8002304:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      /* Call User Abort callback */
      if(hdma->XferAbortCallback != NULL)
 8002308:	687b      	ldr	r3, [r7, #4]
 800230a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800230c:	2b00      	cmp	r3, #0
 800230e:	d003      	beq.n	8002318 <HAL_DMA_Abort_IT+0x41c>
      {
        hdma->XferAbortCallback(hdma);
 8002310:	687b      	ldr	r3, [r7, #4]
 8002312:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8002314:	6878      	ldr	r0, [r7, #4]
 8002316:	4798      	blx	r3
      }
    }
  }

  return HAL_OK;
 8002318:	2300      	movs	r3, #0
}
 800231a:	4618      	mov	r0, r3
 800231c:	3710      	adds	r7, #16
 800231e:	46bd      	mov	sp, r7
 8002320:	bd80      	pop	{r7, pc}
 8002322:	bf00      	nop
 8002324:	40020010 	.word	0x40020010
 8002328:	40020028 	.word	0x40020028
 800232c:	40020040 	.word	0x40020040
 8002330:	40020058 	.word	0x40020058
 8002334:	40020070 	.word	0x40020070
 8002338:	40020088 	.word	0x40020088
 800233c:	400200a0 	.word	0x400200a0
 8002340:	400200b8 	.word	0x400200b8
 8002344:	40020410 	.word	0x40020410
 8002348:	40020428 	.word	0x40020428
 800234c:	40020440 	.word	0x40020440
 8002350:	40020458 	.word	0x40020458
 8002354:	40020470 	.word	0x40020470
 8002358:	40020488 	.word	0x40020488
 800235c:	400204a0 	.word	0x400204a0
 8002360:	400204b8 	.word	0x400204b8
 8002364:	58025408 	.word	0x58025408
 8002368:	5802541c 	.word	0x5802541c
 800236c:	58025430 	.word	0x58025430
 8002370:	58025444 	.word	0x58025444
 8002374:	58025458 	.word	0x58025458
 8002378:	5802546c 	.word	0x5802546c
 800237c:	58025480 	.word	0x58025480
 8002380:	58025494 	.word	0x58025494

08002384 <HAL_DMA_IRQHandler>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
 8002384:	b580      	push	{r7, lr}
 8002386:	b08a      	sub	sp, #40	; 0x28
 8002388:	af00      	add	r7, sp, #0
 800238a:	6078      	str	r0, [r7, #4]
  uint32_t tmpisr_dma, tmpisr_bdma;
  uint32_t ccr_reg;
  __IO uint32_t count = 0U;
 800238c:	2300      	movs	r3, #0
 800238e:	60fb      	str	r3, [r7, #12]
  uint32_t timeout = SystemCoreClock / 9600U;
 8002390:	4b67      	ldr	r3, [pc, #412]	; (8002530 <HAL_DMA_IRQHandler+0x1ac>)
 8002392:	681b      	ldr	r3, [r3, #0]
 8002394:	4a67      	ldr	r2, [pc, #412]	; (8002534 <HAL_DMA_IRQHandler+0x1b0>)
 8002396:	fba2 2303 	umull	r2, r3, r2, r3
 800239a:	0a9b      	lsrs	r3, r3, #10
 800239c:	627b      	str	r3, [r7, #36]	; 0x24

  /* calculate DMA base and stream number */
  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 800239e:	687b      	ldr	r3, [r7, #4]
 80023a0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80023a2:	623b      	str	r3, [r7, #32]
  BDMA_Base_Registers *regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
 80023a4:	687b      	ldr	r3, [r7, #4]
 80023a6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80023a8:	61fb      	str	r3, [r7, #28]

  tmpisr_dma  = regs_dma->ISR;
 80023aa:	6a3b      	ldr	r3, [r7, #32]
 80023ac:	681b      	ldr	r3, [r3, #0]
 80023ae:	61bb      	str	r3, [r7, #24]
  tmpisr_bdma = regs_bdma->ISR;
 80023b0:	69fb      	ldr	r3, [r7, #28]
 80023b2:	681b      	ldr	r3, [r3, #0]
 80023b4:	617b      	str	r3, [r7, #20]

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U)  /* DMA1 or DMA2 instance */
 80023b6:	687b      	ldr	r3, [r7, #4]
 80023b8:	681b      	ldr	r3, [r3, #0]
 80023ba:	4a5f      	ldr	r2, [pc, #380]	; (8002538 <HAL_DMA_IRQHandler+0x1b4>)
 80023bc:	4293      	cmp	r3, r2
 80023be:	d04a      	beq.n	8002456 <HAL_DMA_IRQHandler+0xd2>
 80023c0:	687b      	ldr	r3, [r7, #4]
 80023c2:	681b      	ldr	r3, [r3, #0]
 80023c4:	4a5d      	ldr	r2, [pc, #372]	; (800253c <HAL_DMA_IRQHandler+0x1b8>)
 80023c6:	4293      	cmp	r3, r2
 80023c8:	d045      	beq.n	8002456 <HAL_DMA_IRQHandler+0xd2>
 80023ca:	687b      	ldr	r3, [r7, #4]
 80023cc:	681b      	ldr	r3, [r3, #0]
 80023ce:	4a5c      	ldr	r2, [pc, #368]	; (8002540 <HAL_DMA_IRQHandler+0x1bc>)
 80023d0:	4293      	cmp	r3, r2
 80023d2:	d040      	beq.n	8002456 <HAL_DMA_IRQHandler+0xd2>
 80023d4:	687b      	ldr	r3, [r7, #4]
 80023d6:	681b      	ldr	r3, [r3, #0]
 80023d8:	4a5a      	ldr	r2, [pc, #360]	; (8002544 <HAL_DMA_IRQHandler+0x1c0>)
 80023da:	4293      	cmp	r3, r2
 80023dc:	d03b      	beq.n	8002456 <HAL_DMA_IRQHandler+0xd2>
 80023de:	687b      	ldr	r3, [r7, #4]
 80023e0:	681b      	ldr	r3, [r3, #0]
 80023e2:	4a59      	ldr	r2, [pc, #356]	; (8002548 <HAL_DMA_IRQHandler+0x1c4>)
 80023e4:	4293      	cmp	r3, r2
 80023e6:	d036      	beq.n	8002456 <HAL_DMA_IRQHandler+0xd2>
 80023e8:	687b      	ldr	r3, [r7, #4]
 80023ea:	681b      	ldr	r3, [r3, #0]
 80023ec:	4a57      	ldr	r2, [pc, #348]	; (800254c <HAL_DMA_IRQHandler+0x1c8>)
 80023ee:	4293      	cmp	r3, r2
 80023f0:	d031      	beq.n	8002456 <HAL_DMA_IRQHandler+0xd2>
 80023f2:	687b      	ldr	r3, [r7, #4]
 80023f4:	681b      	ldr	r3, [r3, #0]
 80023f6:	4a56      	ldr	r2, [pc, #344]	; (8002550 <HAL_DMA_IRQHandler+0x1cc>)
 80023f8:	4293      	cmp	r3, r2
 80023fa:	d02c      	beq.n	8002456 <HAL_DMA_IRQHandler+0xd2>
 80023fc:	687b      	ldr	r3, [r7, #4]
 80023fe:	681b      	ldr	r3, [r3, #0]
 8002400:	4a54      	ldr	r2, [pc, #336]	; (8002554 <HAL_DMA_IRQHandler+0x1d0>)
 8002402:	4293      	cmp	r3, r2
 8002404:	d027      	beq.n	8002456 <HAL_DMA_IRQHandler+0xd2>
 8002406:	687b      	ldr	r3, [r7, #4]
 8002408:	681b      	ldr	r3, [r3, #0]
 800240a:	4a53      	ldr	r2, [pc, #332]	; (8002558 <HAL_DMA_IRQHandler+0x1d4>)
 800240c:	4293      	cmp	r3, r2
 800240e:	d022      	beq.n	8002456 <HAL_DMA_IRQHandler+0xd2>
 8002410:	687b      	ldr	r3, [r7, #4]
 8002412:	681b      	ldr	r3, [r3, #0]
 8002414:	4a51      	ldr	r2, [pc, #324]	; (800255c <HAL_DMA_IRQHandler+0x1d8>)
 8002416:	4293      	cmp	r3, r2
 8002418:	d01d      	beq.n	8002456 <HAL_DMA_IRQHandler+0xd2>
 800241a:	687b      	ldr	r3, [r7, #4]
 800241c:	681b      	ldr	r3, [r3, #0]
 800241e:	4a50      	ldr	r2, [pc, #320]	; (8002560 <HAL_DMA_IRQHandler+0x1dc>)
 8002420:	4293      	cmp	r3, r2
 8002422:	d018      	beq.n	8002456 <HAL_DMA_IRQHandler+0xd2>
 8002424:	687b      	ldr	r3, [r7, #4]
 8002426:	681b      	ldr	r3, [r3, #0]
 8002428:	4a4e      	ldr	r2, [pc, #312]	; (8002564 <HAL_DMA_IRQHandler+0x1e0>)
 800242a:	4293      	cmp	r3, r2
 800242c:	d013      	beq.n	8002456 <HAL_DMA_IRQHandler+0xd2>
 800242e:	687b      	ldr	r3, [r7, #4]
 8002430:	681b      	ldr	r3, [r3, #0]
 8002432:	4a4d      	ldr	r2, [pc, #308]	; (8002568 <HAL_DMA_IRQHandler+0x1e4>)
 8002434:	4293      	cmp	r3, r2
 8002436:	d00e      	beq.n	8002456 <HAL_DMA_IRQHandler+0xd2>
 8002438:	687b      	ldr	r3, [r7, #4]
 800243a:	681b      	ldr	r3, [r3, #0]
 800243c:	4a4b      	ldr	r2, [pc, #300]	; (800256c <HAL_DMA_IRQHandler+0x1e8>)
 800243e:	4293      	cmp	r3, r2
 8002440:	d009      	beq.n	8002456 <HAL_DMA_IRQHandler+0xd2>
 8002442:	687b      	ldr	r3, [r7, #4]
 8002444:	681b      	ldr	r3, [r3, #0]
 8002446:	4a4a      	ldr	r2, [pc, #296]	; (8002570 <HAL_DMA_IRQHandler+0x1ec>)
 8002448:	4293      	cmp	r3, r2
 800244a:	d004      	beq.n	8002456 <HAL_DMA_IRQHandler+0xd2>
 800244c:	687b      	ldr	r3, [r7, #4]
 800244e:	681b      	ldr	r3, [r3, #0]
 8002450:	4a48      	ldr	r2, [pc, #288]	; (8002574 <HAL_DMA_IRQHandler+0x1f0>)
 8002452:	4293      	cmp	r3, r2
 8002454:	d101      	bne.n	800245a <HAL_DMA_IRQHandler+0xd6>
 8002456:	2301      	movs	r3, #1
 8002458:	e000      	b.n	800245c <HAL_DMA_IRQHandler+0xd8>
 800245a:	2300      	movs	r3, #0
 800245c:	2b00      	cmp	r3, #0
 800245e:	f000 842b 	beq.w	8002cb8 <HAL_DMA_IRQHandler+0x934>
  {
    /* Transfer Error Interrupt management ***************************************/
    if ((tmpisr_dma & (DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 8002462:	687b      	ldr	r3, [r7, #4]
 8002464:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8002466:	f003 031f 	and.w	r3, r3, #31
 800246a:	2208      	movs	r2, #8
 800246c:	409a      	lsls	r2, r3
 800246e:	69bb      	ldr	r3, [r7, #24]
 8002470:	4013      	ands	r3, r2
 8002472:	2b00      	cmp	r3, #0
 8002474:	f000 80a2 	beq.w	80025bc <HAL_DMA_IRQHandler+0x238>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != 0U)
 8002478:	687b      	ldr	r3, [r7, #4]
 800247a:	681b      	ldr	r3, [r3, #0]
 800247c:	4a2e      	ldr	r2, [pc, #184]	; (8002538 <HAL_DMA_IRQHandler+0x1b4>)
 800247e:	4293      	cmp	r3, r2
 8002480:	d04a      	beq.n	8002518 <HAL_DMA_IRQHandler+0x194>
 8002482:	687b      	ldr	r3, [r7, #4]
 8002484:	681b      	ldr	r3, [r3, #0]
 8002486:	4a2d      	ldr	r2, [pc, #180]	; (800253c <HAL_DMA_IRQHandler+0x1b8>)
 8002488:	4293      	cmp	r3, r2
 800248a:	d045      	beq.n	8002518 <HAL_DMA_IRQHandler+0x194>
 800248c:	687b      	ldr	r3, [r7, #4]
 800248e:	681b      	ldr	r3, [r3, #0]
 8002490:	4a2b      	ldr	r2, [pc, #172]	; (8002540 <HAL_DMA_IRQHandler+0x1bc>)
 8002492:	4293      	cmp	r3, r2
 8002494:	d040      	beq.n	8002518 <HAL_DMA_IRQHandler+0x194>
 8002496:	687b      	ldr	r3, [r7, #4]
 8002498:	681b      	ldr	r3, [r3, #0]
 800249a:	4a2a      	ldr	r2, [pc, #168]	; (8002544 <HAL_DMA_IRQHandler+0x1c0>)
 800249c:	4293      	cmp	r3, r2
 800249e:	d03b      	beq.n	8002518 <HAL_DMA_IRQHandler+0x194>
 80024a0:	687b      	ldr	r3, [r7, #4]
 80024a2:	681b      	ldr	r3, [r3, #0]
 80024a4:	4a28      	ldr	r2, [pc, #160]	; (8002548 <HAL_DMA_IRQHandler+0x1c4>)
 80024a6:	4293      	cmp	r3, r2
 80024a8:	d036      	beq.n	8002518 <HAL_DMA_IRQHandler+0x194>
 80024aa:	687b      	ldr	r3, [r7, #4]
 80024ac:	681b      	ldr	r3, [r3, #0]
 80024ae:	4a27      	ldr	r2, [pc, #156]	; (800254c <HAL_DMA_IRQHandler+0x1c8>)
 80024b0:	4293      	cmp	r3, r2
 80024b2:	d031      	beq.n	8002518 <HAL_DMA_IRQHandler+0x194>
 80024b4:	687b      	ldr	r3, [r7, #4]
 80024b6:	681b      	ldr	r3, [r3, #0]
 80024b8:	4a25      	ldr	r2, [pc, #148]	; (8002550 <HAL_DMA_IRQHandler+0x1cc>)
 80024ba:	4293      	cmp	r3, r2
 80024bc:	d02c      	beq.n	8002518 <HAL_DMA_IRQHandler+0x194>
 80024be:	687b      	ldr	r3, [r7, #4]
 80024c0:	681b      	ldr	r3, [r3, #0]
 80024c2:	4a24      	ldr	r2, [pc, #144]	; (8002554 <HAL_DMA_IRQHandler+0x1d0>)
 80024c4:	4293      	cmp	r3, r2
 80024c6:	d027      	beq.n	8002518 <HAL_DMA_IRQHandler+0x194>
 80024c8:	687b      	ldr	r3, [r7, #4]
 80024ca:	681b      	ldr	r3, [r3, #0]
 80024cc:	4a22      	ldr	r2, [pc, #136]	; (8002558 <HAL_DMA_IRQHandler+0x1d4>)
 80024ce:	4293      	cmp	r3, r2
 80024d0:	d022      	beq.n	8002518 <HAL_DMA_IRQHandler+0x194>
 80024d2:	687b      	ldr	r3, [r7, #4]
 80024d4:	681b      	ldr	r3, [r3, #0]
 80024d6:	4a21      	ldr	r2, [pc, #132]	; (800255c <HAL_DMA_IRQHandler+0x1d8>)
 80024d8:	4293      	cmp	r3, r2
 80024da:	d01d      	beq.n	8002518 <HAL_DMA_IRQHandler+0x194>
 80024dc:	687b      	ldr	r3, [r7, #4]
 80024de:	681b      	ldr	r3, [r3, #0]
 80024e0:	4a1f      	ldr	r2, [pc, #124]	; (8002560 <HAL_DMA_IRQHandler+0x1dc>)
 80024e2:	4293      	cmp	r3, r2
 80024e4:	d018      	beq.n	8002518 <HAL_DMA_IRQHandler+0x194>
 80024e6:	687b      	ldr	r3, [r7, #4]
 80024e8:	681b      	ldr	r3, [r3, #0]
 80024ea:	4a1e      	ldr	r2, [pc, #120]	; (8002564 <HAL_DMA_IRQHandler+0x1e0>)
 80024ec:	4293      	cmp	r3, r2
 80024ee:	d013      	beq.n	8002518 <HAL_DMA_IRQHandler+0x194>
 80024f0:	687b      	ldr	r3, [r7, #4]
 80024f2:	681b      	ldr	r3, [r3, #0]
 80024f4:	4a1c      	ldr	r2, [pc, #112]	; (8002568 <HAL_DMA_IRQHandler+0x1e4>)
 80024f6:	4293      	cmp	r3, r2
 80024f8:	d00e      	beq.n	8002518 <HAL_DMA_IRQHandler+0x194>
 80024fa:	687b      	ldr	r3, [r7, #4]
 80024fc:	681b      	ldr	r3, [r3, #0]
 80024fe:	4a1b      	ldr	r2, [pc, #108]	; (800256c <HAL_DMA_IRQHandler+0x1e8>)
 8002500:	4293      	cmp	r3, r2
 8002502:	d009      	beq.n	8002518 <HAL_DMA_IRQHandler+0x194>
 8002504:	687b      	ldr	r3, [r7, #4]
 8002506:	681b      	ldr	r3, [r3, #0]
 8002508:	4a19      	ldr	r2, [pc, #100]	; (8002570 <HAL_DMA_IRQHandler+0x1ec>)
 800250a:	4293      	cmp	r3, r2
 800250c:	d004      	beq.n	8002518 <HAL_DMA_IRQHandler+0x194>
 800250e:	687b      	ldr	r3, [r7, #4]
 8002510:	681b      	ldr	r3, [r3, #0]
 8002512:	4a18      	ldr	r2, [pc, #96]	; (8002574 <HAL_DMA_IRQHandler+0x1f0>)
 8002514:	4293      	cmp	r3, r2
 8002516:	d12f      	bne.n	8002578 <HAL_DMA_IRQHandler+0x1f4>
 8002518:	687b      	ldr	r3, [r7, #4]
 800251a:	681b      	ldr	r3, [r3, #0]
 800251c:	681b      	ldr	r3, [r3, #0]
 800251e:	f003 0304 	and.w	r3, r3, #4
 8002522:	2b00      	cmp	r3, #0
 8002524:	bf14      	ite	ne
 8002526:	2301      	movne	r3, #1
 8002528:	2300      	moveq	r3, #0
 800252a:	b2db      	uxtb	r3, r3
 800252c:	e02e      	b.n	800258c <HAL_DMA_IRQHandler+0x208>
 800252e:	bf00      	nop
 8002530:	240001a4 	.word	0x240001a4
 8002534:	1b4e81b5 	.word	0x1b4e81b5
 8002538:	40020010 	.word	0x40020010
 800253c:	40020028 	.word	0x40020028
 8002540:	40020040 	.word	0x40020040
 8002544:	40020058 	.word	0x40020058
 8002548:	40020070 	.word	0x40020070
 800254c:	40020088 	.word	0x40020088
 8002550:	400200a0 	.word	0x400200a0
 8002554:	400200b8 	.word	0x400200b8
 8002558:	40020410 	.word	0x40020410
 800255c:	40020428 	.word	0x40020428
 8002560:	40020440 	.word	0x40020440
 8002564:	40020458 	.word	0x40020458
 8002568:	40020470 	.word	0x40020470
 800256c:	40020488 	.word	0x40020488
 8002570:	400204a0 	.word	0x400204a0
 8002574:	400204b8 	.word	0x400204b8
 8002578:	687b      	ldr	r3, [r7, #4]
 800257a:	681b      	ldr	r3, [r3, #0]
 800257c:	681b      	ldr	r3, [r3, #0]
 800257e:	f003 0308 	and.w	r3, r3, #8
 8002582:	2b00      	cmp	r3, #0
 8002584:	bf14      	ite	ne
 8002586:	2301      	movne	r3, #1
 8002588:	2300      	moveq	r3, #0
 800258a:	b2db      	uxtb	r3, r3
 800258c:	2b00      	cmp	r3, #0
 800258e:	d015      	beq.n	80025bc <HAL_DMA_IRQHandler+0x238>
      {
        /* Disable the transfer error interrupt */
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TE);
 8002590:	687b      	ldr	r3, [r7, #4]
 8002592:	681b      	ldr	r3, [r3, #0]
 8002594:	681a      	ldr	r2, [r3, #0]
 8002596:	687b      	ldr	r3, [r7, #4]
 8002598:	681b      	ldr	r3, [r3, #0]
 800259a:	f022 0204 	bic.w	r2, r2, #4
 800259e:	601a      	str	r2, [r3, #0]

        /* Clear the transfer error flag */
        regs_dma->IFCR = DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU);
 80025a0:	687b      	ldr	r3, [r7, #4]
 80025a2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80025a4:	f003 031f 	and.w	r3, r3, #31
 80025a8:	2208      	movs	r2, #8
 80025aa:	409a      	lsls	r2, r3
 80025ac:	6a3b      	ldr	r3, [r7, #32]
 80025ae:	609a      	str	r2, [r3, #8]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 80025b0:	687b      	ldr	r3, [r7, #4]
 80025b2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80025b4:	f043 0201 	orr.w	r2, r3, #1
 80025b8:	687b      	ldr	r3, [r7, #4]
 80025ba:	655a      	str	r2, [r3, #84]	; 0x54
      }
    }
    /* FIFO Error Interrupt management ******************************************/
    if ((tmpisr_dma & (DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 80025bc:	687b      	ldr	r3, [r7, #4]
 80025be:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80025c0:	f003 031f 	and.w	r3, r3, #31
 80025c4:	69ba      	ldr	r2, [r7, #24]
 80025c6:	fa22 f303 	lsr.w	r3, r2, r3
 80025ca:	f003 0301 	and.w	r3, r3, #1
 80025ce:	2b00      	cmp	r3, #0
 80025d0:	d06e      	beq.n	80026b0 <HAL_DMA_IRQHandler+0x32c>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != 0U)
 80025d2:	687b      	ldr	r3, [r7, #4]
 80025d4:	681b      	ldr	r3, [r3, #0]
 80025d6:	4a69      	ldr	r2, [pc, #420]	; (800277c <HAL_DMA_IRQHandler+0x3f8>)
 80025d8:	4293      	cmp	r3, r2
 80025da:	d04a      	beq.n	8002672 <HAL_DMA_IRQHandler+0x2ee>
 80025dc:	687b      	ldr	r3, [r7, #4]
 80025de:	681b      	ldr	r3, [r3, #0]
 80025e0:	4a67      	ldr	r2, [pc, #412]	; (8002780 <HAL_DMA_IRQHandler+0x3fc>)
 80025e2:	4293      	cmp	r3, r2
 80025e4:	d045      	beq.n	8002672 <HAL_DMA_IRQHandler+0x2ee>
 80025e6:	687b      	ldr	r3, [r7, #4]
 80025e8:	681b      	ldr	r3, [r3, #0]
 80025ea:	4a66      	ldr	r2, [pc, #408]	; (8002784 <HAL_DMA_IRQHandler+0x400>)
 80025ec:	4293      	cmp	r3, r2
 80025ee:	d040      	beq.n	8002672 <HAL_DMA_IRQHandler+0x2ee>
 80025f0:	687b      	ldr	r3, [r7, #4]
 80025f2:	681b      	ldr	r3, [r3, #0]
 80025f4:	4a64      	ldr	r2, [pc, #400]	; (8002788 <HAL_DMA_IRQHandler+0x404>)
 80025f6:	4293      	cmp	r3, r2
 80025f8:	d03b      	beq.n	8002672 <HAL_DMA_IRQHandler+0x2ee>
 80025fa:	687b      	ldr	r3, [r7, #4]
 80025fc:	681b      	ldr	r3, [r3, #0]
 80025fe:	4a63      	ldr	r2, [pc, #396]	; (800278c <HAL_DMA_IRQHandler+0x408>)
 8002600:	4293      	cmp	r3, r2
 8002602:	d036      	beq.n	8002672 <HAL_DMA_IRQHandler+0x2ee>
 8002604:	687b      	ldr	r3, [r7, #4]
 8002606:	681b      	ldr	r3, [r3, #0]
 8002608:	4a61      	ldr	r2, [pc, #388]	; (8002790 <HAL_DMA_IRQHandler+0x40c>)
 800260a:	4293      	cmp	r3, r2
 800260c:	d031      	beq.n	8002672 <HAL_DMA_IRQHandler+0x2ee>
 800260e:	687b      	ldr	r3, [r7, #4]
 8002610:	681b      	ldr	r3, [r3, #0]
 8002612:	4a60      	ldr	r2, [pc, #384]	; (8002794 <HAL_DMA_IRQHandler+0x410>)
 8002614:	4293      	cmp	r3, r2
 8002616:	d02c      	beq.n	8002672 <HAL_DMA_IRQHandler+0x2ee>
 8002618:	687b      	ldr	r3, [r7, #4]
 800261a:	681b      	ldr	r3, [r3, #0]
 800261c:	4a5e      	ldr	r2, [pc, #376]	; (8002798 <HAL_DMA_IRQHandler+0x414>)
 800261e:	4293      	cmp	r3, r2
 8002620:	d027      	beq.n	8002672 <HAL_DMA_IRQHandler+0x2ee>
 8002622:	687b      	ldr	r3, [r7, #4]
 8002624:	681b      	ldr	r3, [r3, #0]
 8002626:	4a5d      	ldr	r2, [pc, #372]	; (800279c <HAL_DMA_IRQHandler+0x418>)
 8002628:	4293      	cmp	r3, r2
 800262a:	d022      	beq.n	8002672 <HAL_DMA_IRQHandler+0x2ee>
 800262c:	687b      	ldr	r3, [r7, #4]
 800262e:	681b      	ldr	r3, [r3, #0]
 8002630:	4a5b      	ldr	r2, [pc, #364]	; (80027a0 <HAL_DMA_IRQHandler+0x41c>)
 8002632:	4293      	cmp	r3, r2
 8002634:	d01d      	beq.n	8002672 <HAL_DMA_IRQHandler+0x2ee>
 8002636:	687b      	ldr	r3, [r7, #4]
 8002638:	681b      	ldr	r3, [r3, #0]
 800263a:	4a5a      	ldr	r2, [pc, #360]	; (80027a4 <HAL_DMA_IRQHandler+0x420>)
 800263c:	4293      	cmp	r3, r2
 800263e:	d018      	beq.n	8002672 <HAL_DMA_IRQHandler+0x2ee>
 8002640:	687b      	ldr	r3, [r7, #4]
 8002642:	681b      	ldr	r3, [r3, #0]
 8002644:	4a58      	ldr	r2, [pc, #352]	; (80027a8 <HAL_DMA_IRQHandler+0x424>)
 8002646:	4293      	cmp	r3, r2
 8002648:	d013      	beq.n	8002672 <HAL_DMA_IRQHandler+0x2ee>
 800264a:	687b      	ldr	r3, [r7, #4]
 800264c:	681b      	ldr	r3, [r3, #0]
 800264e:	4a57      	ldr	r2, [pc, #348]	; (80027ac <HAL_DMA_IRQHandler+0x428>)
 8002650:	4293      	cmp	r3, r2
 8002652:	d00e      	beq.n	8002672 <HAL_DMA_IRQHandler+0x2ee>
 8002654:	687b      	ldr	r3, [r7, #4]
 8002656:	681b      	ldr	r3, [r3, #0]
 8002658:	4a55      	ldr	r2, [pc, #340]	; (80027b0 <HAL_DMA_IRQHandler+0x42c>)
 800265a:	4293      	cmp	r3, r2
 800265c:	d009      	beq.n	8002672 <HAL_DMA_IRQHandler+0x2ee>
 800265e:	687b      	ldr	r3, [r7, #4]
 8002660:	681b      	ldr	r3, [r3, #0]
 8002662:	4a54      	ldr	r2, [pc, #336]	; (80027b4 <HAL_DMA_IRQHandler+0x430>)
 8002664:	4293      	cmp	r3, r2
 8002666:	d004      	beq.n	8002672 <HAL_DMA_IRQHandler+0x2ee>
 8002668:	687b      	ldr	r3, [r7, #4]
 800266a:	681b      	ldr	r3, [r3, #0]
 800266c:	4a52      	ldr	r2, [pc, #328]	; (80027b8 <HAL_DMA_IRQHandler+0x434>)
 800266e:	4293      	cmp	r3, r2
 8002670:	d10a      	bne.n	8002688 <HAL_DMA_IRQHandler+0x304>
 8002672:	687b      	ldr	r3, [r7, #4]
 8002674:	681b      	ldr	r3, [r3, #0]
 8002676:	695b      	ldr	r3, [r3, #20]
 8002678:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800267c:	2b00      	cmp	r3, #0
 800267e:	bf14      	ite	ne
 8002680:	2301      	movne	r3, #1
 8002682:	2300      	moveq	r3, #0
 8002684:	b2db      	uxtb	r3, r3
 8002686:	e003      	b.n	8002690 <HAL_DMA_IRQHandler+0x30c>
 8002688:	687b      	ldr	r3, [r7, #4]
 800268a:	681b      	ldr	r3, [r3, #0]
 800268c:	681b      	ldr	r3, [r3, #0]
 800268e:	2300      	movs	r3, #0
 8002690:	2b00      	cmp	r3, #0
 8002692:	d00d      	beq.n	80026b0 <HAL_DMA_IRQHandler+0x32c>
      {
        /* Clear the FIFO error flag */
        regs_dma->IFCR = DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU);
 8002694:	687b      	ldr	r3, [r7, #4]
 8002696:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8002698:	f003 031f 	and.w	r3, r3, #31
 800269c:	2201      	movs	r2, #1
 800269e:	409a      	lsls	r2, r3
 80026a0:	6a3b      	ldr	r3, [r7, #32]
 80026a2:	609a      	str	r2, [r3, #8]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 80026a4:	687b      	ldr	r3, [r7, #4]
 80026a6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80026a8:	f043 0202 	orr.w	r2, r3, #2
 80026ac:	687b      	ldr	r3, [r7, #4]
 80026ae:	655a      	str	r2, [r3, #84]	; 0x54
      }
    }
    /* Direct Mode Error Interrupt management ***********************************/
    if ((tmpisr_dma & (DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 80026b0:	687b      	ldr	r3, [r7, #4]
 80026b2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80026b4:	f003 031f 	and.w	r3, r3, #31
 80026b8:	2204      	movs	r2, #4
 80026ba:	409a      	lsls	r2, r3
 80026bc:	69bb      	ldr	r3, [r7, #24]
 80026be:	4013      	ands	r3, r2
 80026c0:	2b00      	cmp	r3, #0
 80026c2:	f000 808f 	beq.w	80027e4 <HAL_DMA_IRQHandler+0x460>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != 0U)
 80026c6:	687b      	ldr	r3, [r7, #4]
 80026c8:	681b      	ldr	r3, [r3, #0]
 80026ca:	4a2c      	ldr	r2, [pc, #176]	; (800277c <HAL_DMA_IRQHandler+0x3f8>)
 80026cc:	4293      	cmp	r3, r2
 80026ce:	d04a      	beq.n	8002766 <HAL_DMA_IRQHandler+0x3e2>
 80026d0:	687b      	ldr	r3, [r7, #4]
 80026d2:	681b      	ldr	r3, [r3, #0]
 80026d4:	4a2a      	ldr	r2, [pc, #168]	; (8002780 <HAL_DMA_IRQHandler+0x3fc>)
 80026d6:	4293      	cmp	r3, r2
 80026d8:	d045      	beq.n	8002766 <HAL_DMA_IRQHandler+0x3e2>
 80026da:	687b      	ldr	r3, [r7, #4]
 80026dc:	681b      	ldr	r3, [r3, #0]
 80026de:	4a29      	ldr	r2, [pc, #164]	; (8002784 <HAL_DMA_IRQHandler+0x400>)
 80026e0:	4293      	cmp	r3, r2
 80026e2:	d040      	beq.n	8002766 <HAL_DMA_IRQHandler+0x3e2>
 80026e4:	687b      	ldr	r3, [r7, #4]
 80026e6:	681b      	ldr	r3, [r3, #0]
 80026e8:	4a27      	ldr	r2, [pc, #156]	; (8002788 <HAL_DMA_IRQHandler+0x404>)
 80026ea:	4293      	cmp	r3, r2
 80026ec:	d03b      	beq.n	8002766 <HAL_DMA_IRQHandler+0x3e2>
 80026ee:	687b      	ldr	r3, [r7, #4]
 80026f0:	681b      	ldr	r3, [r3, #0]
 80026f2:	4a26      	ldr	r2, [pc, #152]	; (800278c <HAL_DMA_IRQHandler+0x408>)
 80026f4:	4293      	cmp	r3, r2
 80026f6:	d036      	beq.n	8002766 <HAL_DMA_IRQHandler+0x3e2>
 80026f8:	687b      	ldr	r3, [r7, #4]
 80026fa:	681b      	ldr	r3, [r3, #0]
 80026fc:	4a24      	ldr	r2, [pc, #144]	; (8002790 <HAL_DMA_IRQHandler+0x40c>)
 80026fe:	4293      	cmp	r3, r2
 8002700:	d031      	beq.n	8002766 <HAL_DMA_IRQHandler+0x3e2>
 8002702:	687b      	ldr	r3, [r7, #4]
 8002704:	681b      	ldr	r3, [r3, #0]
 8002706:	4a23      	ldr	r2, [pc, #140]	; (8002794 <HAL_DMA_IRQHandler+0x410>)
 8002708:	4293      	cmp	r3, r2
 800270a:	d02c      	beq.n	8002766 <HAL_DMA_IRQHandler+0x3e2>
 800270c:	687b      	ldr	r3, [r7, #4]
 800270e:	681b      	ldr	r3, [r3, #0]
 8002710:	4a21      	ldr	r2, [pc, #132]	; (8002798 <HAL_DMA_IRQHandler+0x414>)
 8002712:	4293      	cmp	r3, r2
 8002714:	d027      	beq.n	8002766 <HAL_DMA_IRQHandler+0x3e2>
 8002716:	687b      	ldr	r3, [r7, #4]
 8002718:	681b      	ldr	r3, [r3, #0]
 800271a:	4a20      	ldr	r2, [pc, #128]	; (800279c <HAL_DMA_IRQHandler+0x418>)
 800271c:	4293      	cmp	r3, r2
 800271e:	d022      	beq.n	8002766 <HAL_DMA_IRQHandler+0x3e2>
 8002720:	687b      	ldr	r3, [r7, #4]
 8002722:	681b      	ldr	r3, [r3, #0]
 8002724:	4a1e      	ldr	r2, [pc, #120]	; (80027a0 <HAL_DMA_IRQHandler+0x41c>)
 8002726:	4293      	cmp	r3, r2
 8002728:	d01d      	beq.n	8002766 <HAL_DMA_IRQHandler+0x3e2>
 800272a:	687b      	ldr	r3, [r7, #4]
 800272c:	681b      	ldr	r3, [r3, #0]
 800272e:	4a1d      	ldr	r2, [pc, #116]	; (80027a4 <HAL_DMA_IRQHandler+0x420>)
 8002730:	4293      	cmp	r3, r2
 8002732:	d018      	beq.n	8002766 <HAL_DMA_IRQHandler+0x3e2>
 8002734:	687b      	ldr	r3, [r7, #4]
 8002736:	681b      	ldr	r3, [r3, #0]
 8002738:	4a1b      	ldr	r2, [pc, #108]	; (80027a8 <HAL_DMA_IRQHandler+0x424>)
 800273a:	4293      	cmp	r3, r2
 800273c:	d013      	beq.n	8002766 <HAL_DMA_IRQHandler+0x3e2>
 800273e:	687b      	ldr	r3, [r7, #4]
 8002740:	681b      	ldr	r3, [r3, #0]
 8002742:	4a1a      	ldr	r2, [pc, #104]	; (80027ac <HAL_DMA_IRQHandler+0x428>)
 8002744:	4293      	cmp	r3, r2
 8002746:	d00e      	beq.n	8002766 <HAL_DMA_IRQHandler+0x3e2>
 8002748:	687b      	ldr	r3, [r7, #4]
 800274a:	681b      	ldr	r3, [r3, #0]
 800274c:	4a18      	ldr	r2, [pc, #96]	; (80027b0 <HAL_DMA_IRQHandler+0x42c>)
 800274e:	4293      	cmp	r3, r2
 8002750:	d009      	beq.n	8002766 <HAL_DMA_IRQHandler+0x3e2>
 8002752:	687b      	ldr	r3, [r7, #4]
 8002754:	681b      	ldr	r3, [r3, #0]
 8002756:	4a17      	ldr	r2, [pc, #92]	; (80027b4 <HAL_DMA_IRQHandler+0x430>)
 8002758:	4293      	cmp	r3, r2
 800275a:	d004      	beq.n	8002766 <HAL_DMA_IRQHandler+0x3e2>
 800275c:	687b      	ldr	r3, [r7, #4]
 800275e:	681b      	ldr	r3, [r3, #0]
 8002760:	4a15      	ldr	r2, [pc, #84]	; (80027b8 <HAL_DMA_IRQHandler+0x434>)
 8002762:	4293      	cmp	r3, r2
 8002764:	d12a      	bne.n	80027bc <HAL_DMA_IRQHandler+0x438>
 8002766:	687b      	ldr	r3, [r7, #4]
 8002768:	681b      	ldr	r3, [r3, #0]
 800276a:	681b      	ldr	r3, [r3, #0]
 800276c:	f003 0302 	and.w	r3, r3, #2
 8002770:	2b00      	cmp	r3, #0
 8002772:	bf14      	ite	ne
 8002774:	2301      	movne	r3, #1
 8002776:	2300      	moveq	r3, #0
 8002778:	b2db      	uxtb	r3, r3
 800277a:	e023      	b.n	80027c4 <HAL_DMA_IRQHandler+0x440>
 800277c:	40020010 	.word	0x40020010
 8002780:	40020028 	.word	0x40020028
 8002784:	40020040 	.word	0x40020040
 8002788:	40020058 	.word	0x40020058
 800278c:	40020070 	.word	0x40020070
 8002790:	40020088 	.word	0x40020088
 8002794:	400200a0 	.word	0x400200a0
 8002798:	400200b8 	.word	0x400200b8
 800279c:	40020410 	.word	0x40020410
 80027a0:	40020428 	.word	0x40020428
 80027a4:	40020440 	.word	0x40020440
 80027a8:	40020458 	.word	0x40020458
 80027ac:	40020470 	.word	0x40020470
 80027b0:	40020488 	.word	0x40020488
 80027b4:	400204a0 	.word	0x400204a0
 80027b8:	400204b8 	.word	0x400204b8
 80027bc:	687b      	ldr	r3, [r7, #4]
 80027be:	681b      	ldr	r3, [r3, #0]
 80027c0:	681b      	ldr	r3, [r3, #0]
 80027c2:	2300      	movs	r3, #0
 80027c4:	2b00      	cmp	r3, #0
 80027c6:	d00d      	beq.n	80027e4 <HAL_DMA_IRQHandler+0x460>
      {
        /* Clear the direct mode error flag */
        regs_dma->IFCR = DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU);
 80027c8:	687b      	ldr	r3, [r7, #4]
 80027ca:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80027cc:	f003 031f 	and.w	r3, r3, #31
 80027d0:	2204      	movs	r2, #4
 80027d2:	409a      	lsls	r2, r3
 80027d4:	6a3b      	ldr	r3, [r7, #32]
 80027d6:	609a      	str	r2, [r3, #8]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 80027d8:	687b      	ldr	r3, [r7, #4]
 80027da:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80027dc:	f043 0204 	orr.w	r2, r3, #4
 80027e0:	687b      	ldr	r3, [r7, #4]
 80027e2:	655a      	str	r2, [r3, #84]	; 0x54
      }
    }
    /* Half Transfer Complete Interrupt management ******************************/
    if ((tmpisr_dma & (DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 80027e4:	687b      	ldr	r3, [r7, #4]
 80027e6:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80027e8:	f003 031f 	and.w	r3, r3, #31
 80027ec:	2210      	movs	r2, #16
 80027ee:	409a      	lsls	r2, r3
 80027f0:	69bb      	ldr	r3, [r7, #24]
 80027f2:	4013      	ands	r3, r2
 80027f4:	2b00      	cmp	r3, #0
 80027f6:	f000 80a6 	beq.w	8002946 <HAL_DMA_IRQHandler+0x5c2>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != 0U)
 80027fa:	687b      	ldr	r3, [r7, #4]
 80027fc:	681b      	ldr	r3, [r3, #0]
 80027fe:	4a85      	ldr	r2, [pc, #532]	; (8002a14 <HAL_DMA_IRQHandler+0x690>)
 8002800:	4293      	cmp	r3, r2
 8002802:	d04a      	beq.n	800289a <HAL_DMA_IRQHandler+0x516>
 8002804:	687b      	ldr	r3, [r7, #4]
 8002806:	681b      	ldr	r3, [r3, #0]
 8002808:	4a83      	ldr	r2, [pc, #524]	; (8002a18 <HAL_DMA_IRQHandler+0x694>)
 800280a:	4293      	cmp	r3, r2
 800280c:	d045      	beq.n	800289a <HAL_DMA_IRQHandler+0x516>
 800280e:	687b      	ldr	r3, [r7, #4]
 8002810:	681b      	ldr	r3, [r3, #0]
 8002812:	4a82      	ldr	r2, [pc, #520]	; (8002a1c <HAL_DMA_IRQHandler+0x698>)
 8002814:	4293      	cmp	r3, r2
 8002816:	d040      	beq.n	800289a <HAL_DMA_IRQHandler+0x516>
 8002818:	687b      	ldr	r3, [r7, #4]
 800281a:	681b      	ldr	r3, [r3, #0]
 800281c:	4a80      	ldr	r2, [pc, #512]	; (8002a20 <HAL_DMA_IRQHandler+0x69c>)
 800281e:	4293      	cmp	r3, r2
 8002820:	d03b      	beq.n	800289a <HAL_DMA_IRQHandler+0x516>
 8002822:	687b      	ldr	r3, [r7, #4]
 8002824:	681b      	ldr	r3, [r3, #0]
 8002826:	4a7f      	ldr	r2, [pc, #508]	; (8002a24 <HAL_DMA_IRQHandler+0x6a0>)
 8002828:	4293      	cmp	r3, r2
 800282a:	d036      	beq.n	800289a <HAL_DMA_IRQHandler+0x516>
 800282c:	687b      	ldr	r3, [r7, #4]
 800282e:	681b      	ldr	r3, [r3, #0]
 8002830:	4a7d      	ldr	r2, [pc, #500]	; (8002a28 <HAL_DMA_IRQHandler+0x6a4>)
 8002832:	4293      	cmp	r3, r2
 8002834:	d031      	beq.n	800289a <HAL_DMA_IRQHandler+0x516>
 8002836:	687b      	ldr	r3, [r7, #4]
 8002838:	681b      	ldr	r3, [r3, #0]
 800283a:	4a7c      	ldr	r2, [pc, #496]	; (8002a2c <HAL_DMA_IRQHandler+0x6a8>)
 800283c:	4293      	cmp	r3, r2
 800283e:	d02c      	beq.n	800289a <HAL_DMA_IRQHandler+0x516>
 8002840:	687b      	ldr	r3, [r7, #4]
 8002842:	681b      	ldr	r3, [r3, #0]
 8002844:	4a7a      	ldr	r2, [pc, #488]	; (8002a30 <HAL_DMA_IRQHandler+0x6ac>)
 8002846:	4293      	cmp	r3, r2
 8002848:	d027      	beq.n	800289a <HAL_DMA_IRQHandler+0x516>
 800284a:	687b      	ldr	r3, [r7, #4]
 800284c:	681b      	ldr	r3, [r3, #0]
 800284e:	4a79      	ldr	r2, [pc, #484]	; (8002a34 <HAL_DMA_IRQHandler+0x6b0>)
 8002850:	4293      	cmp	r3, r2
 8002852:	d022      	beq.n	800289a <HAL_DMA_IRQHandler+0x516>
 8002854:	687b      	ldr	r3, [r7, #4]
 8002856:	681b      	ldr	r3, [r3, #0]
 8002858:	4a77      	ldr	r2, [pc, #476]	; (8002a38 <HAL_DMA_IRQHandler+0x6b4>)
 800285a:	4293      	cmp	r3, r2
 800285c:	d01d      	beq.n	800289a <HAL_DMA_IRQHandler+0x516>
 800285e:	687b      	ldr	r3, [r7, #4]
 8002860:	681b      	ldr	r3, [r3, #0]
 8002862:	4a76      	ldr	r2, [pc, #472]	; (8002a3c <HAL_DMA_IRQHandler+0x6b8>)
 8002864:	4293      	cmp	r3, r2
 8002866:	d018      	beq.n	800289a <HAL_DMA_IRQHandler+0x516>
 8002868:	687b      	ldr	r3, [r7, #4]
 800286a:	681b      	ldr	r3, [r3, #0]
 800286c:	4a74      	ldr	r2, [pc, #464]	; (8002a40 <HAL_DMA_IRQHandler+0x6bc>)
 800286e:	4293      	cmp	r3, r2
 8002870:	d013      	beq.n	800289a <HAL_DMA_IRQHandler+0x516>
 8002872:	687b      	ldr	r3, [r7, #4]
 8002874:	681b      	ldr	r3, [r3, #0]
 8002876:	4a73      	ldr	r2, [pc, #460]	; (8002a44 <HAL_DMA_IRQHandler+0x6c0>)
 8002878:	4293      	cmp	r3, r2
 800287a:	d00e      	beq.n	800289a <HAL_DMA_IRQHandler+0x516>
 800287c:	687b      	ldr	r3, [r7, #4]
 800287e:	681b      	ldr	r3, [r3, #0]
 8002880:	4a71      	ldr	r2, [pc, #452]	; (8002a48 <HAL_DMA_IRQHandler+0x6c4>)
 8002882:	4293      	cmp	r3, r2
 8002884:	d009      	beq.n	800289a <HAL_DMA_IRQHandler+0x516>
 8002886:	687b      	ldr	r3, [r7, #4]
 8002888:	681b      	ldr	r3, [r3, #0]
 800288a:	4a70      	ldr	r2, [pc, #448]	; (8002a4c <HAL_DMA_IRQHandler+0x6c8>)
 800288c:	4293      	cmp	r3, r2
 800288e:	d004      	beq.n	800289a <HAL_DMA_IRQHandler+0x516>
 8002890:	687b      	ldr	r3, [r7, #4]
 8002892:	681b      	ldr	r3, [r3, #0]
 8002894:	4a6e      	ldr	r2, [pc, #440]	; (8002a50 <HAL_DMA_IRQHandler+0x6cc>)
 8002896:	4293      	cmp	r3, r2
 8002898:	d10a      	bne.n	80028b0 <HAL_DMA_IRQHandler+0x52c>
 800289a:	687b      	ldr	r3, [r7, #4]
 800289c:	681b      	ldr	r3, [r3, #0]
 800289e:	681b      	ldr	r3, [r3, #0]
 80028a0:	f003 0308 	and.w	r3, r3, #8
 80028a4:	2b00      	cmp	r3, #0
 80028a6:	bf14      	ite	ne
 80028a8:	2301      	movne	r3, #1
 80028aa:	2300      	moveq	r3, #0
 80028ac:	b2db      	uxtb	r3, r3
 80028ae:	e009      	b.n	80028c4 <HAL_DMA_IRQHandler+0x540>
 80028b0:	687b      	ldr	r3, [r7, #4]
 80028b2:	681b      	ldr	r3, [r3, #0]
 80028b4:	681b      	ldr	r3, [r3, #0]
 80028b6:	f003 0304 	and.w	r3, r3, #4
 80028ba:	2b00      	cmp	r3, #0
 80028bc:	bf14      	ite	ne
 80028be:	2301      	movne	r3, #1
 80028c0:	2300      	moveq	r3, #0
 80028c2:	b2db      	uxtb	r3, r3
 80028c4:	2b00      	cmp	r3, #0
 80028c6:	d03e      	beq.n	8002946 <HAL_DMA_IRQHandler+0x5c2>
      {
        /* Clear the half transfer complete flag */
        regs_dma->IFCR = DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU);
 80028c8:	687b      	ldr	r3, [r7, #4]
 80028ca:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80028cc:	f003 031f 	and.w	r3, r3, #31
 80028d0:	2210      	movs	r2, #16
 80028d2:	409a      	lsls	r2, r3
 80028d4:	6a3b      	ldr	r3, [r7, #32]
 80028d6:	609a      	str	r2, [r3, #8]

        /* Multi_Buffering mode enabled */
        if(((((DMA_Stream_TypeDef   *)hdma->Instance)->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)
 80028d8:	687b      	ldr	r3, [r7, #4]
 80028da:	681b      	ldr	r3, [r3, #0]
 80028dc:	681b      	ldr	r3, [r3, #0]
 80028de:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 80028e2:	2b00      	cmp	r3, #0
 80028e4:	d018      	beq.n	8002918 <HAL_DMA_IRQHandler+0x594>
        {
          /* Current memory buffer used is Memory 0 */
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CT) == 0U)
 80028e6:	687b      	ldr	r3, [r7, #4]
 80028e8:	681b      	ldr	r3, [r3, #0]
 80028ea:	681b      	ldr	r3, [r3, #0]
 80028ec:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 80028f0:	2b00      	cmp	r3, #0
 80028f2:	d108      	bne.n	8002906 <HAL_DMA_IRQHandler+0x582>
          {
            if(hdma->XferHalfCpltCallback != NULL)
 80028f4:	687b      	ldr	r3, [r7, #4]
 80028f6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80028f8:	2b00      	cmp	r3, #0
 80028fa:	d024      	beq.n	8002946 <HAL_DMA_IRQHandler+0x5c2>
            {
              /* Half transfer callback */
              hdma->XferHalfCpltCallback(hdma);
 80028fc:	687b      	ldr	r3, [r7, #4]
 80028fe:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002900:	6878      	ldr	r0, [r7, #4]
 8002902:	4798      	blx	r3
 8002904:	e01f      	b.n	8002946 <HAL_DMA_IRQHandler+0x5c2>
            }
          }
          /* Current memory buffer used is Memory 1 */
          else
          {
            if(hdma->XferM1HalfCpltCallback != NULL)
 8002906:	687b      	ldr	r3, [r7, #4]
 8002908:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800290a:	2b00      	cmp	r3, #0
 800290c:	d01b      	beq.n	8002946 <HAL_DMA_IRQHandler+0x5c2>
            {
              /* Half transfer callback */
              hdma->XferM1HalfCpltCallback(hdma);
 800290e:	687b      	ldr	r3, [r7, #4]
 8002910:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8002912:	6878      	ldr	r0, [r7, #4]
 8002914:	4798      	blx	r3
 8002916:	e016      	b.n	8002946 <HAL_DMA_IRQHandler+0x5c2>
          }
        }
        else
        {
          /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) == 0U)
 8002918:	687b      	ldr	r3, [r7, #4]
 800291a:	681b      	ldr	r3, [r3, #0]
 800291c:	681b      	ldr	r3, [r3, #0]
 800291e:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8002922:	2b00      	cmp	r3, #0
 8002924:	d107      	bne.n	8002936 <HAL_DMA_IRQHandler+0x5b2>
          {
            /* Disable the half transfer interrupt */
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_HT);
 8002926:	687b      	ldr	r3, [r7, #4]
 8002928:	681b      	ldr	r3, [r3, #0]
 800292a:	681a      	ldr	r2, [r3, #0]
 800292c:	687b      	ldr	r3, [r7, #4]
 800292e:	681b      	ldr	r3, [r3, #0]
 8002930:	f022 0208 	bic.w	r2, r2, #8
 8002934:	601a      	str	r2, [r3, #0]
          }

          if(hdma->XferHalfCpltCallback != NULL)
 8002936:	687b      	ldr	r3, [r7, #4]
 8002938:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800293a:	2b00      	cmp	r3, #0
 800293c:	d003      	beq.n	8002946 <HAL_DMA_IRQHandler+0x5c2>
          {
            /* Half transfer callback */
            hdma->XferHalfCpltCallback(hdma);
 800293e:	687b      	ldr	r3, [r7, #4]
 8002940:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002942:	6878      	ldr	r0, [r7, #4]
 8002944:	4798      	blx	r3
          }
        }
      }
    }
    /* Transfer Complete Interrupt management ***********************************/
    if ((tmpisr_dma & (DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 8002946:	687b      	ldr	r3, [r7, #4]
 8002948:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800294a:	f003 031f 	and.w	r3, r3, #31
 800294e:	2220      	movs	r2, #32
 8002950:	409a      	lsls	r2, r3
 8002952:	69bb      	ldr	r3, [r7, #24]
 8002954:	4013      	ands	r3, r2
 8002956:	2b00      	cmp	r3, #0
 8002958:	f000 8110 	beq.w	8002b7c <HAL_DMA_IRQHandler+0x7f8>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != 0U)
 800295c:	687b      	ldr	r3, [r7, #4]
 800295e:	681b      	ldr	r3, [r3, #0]
 8002960:	4a2c      	ldr	r2, [pc, #176]	; (8002a14 <HAL_DMA_IRQHandler+0x690>)
 8002962:	4293      	cmp	r3, r2
 8002964:	d04a      	beq.n	80029fc <HAL_DMA_IRQHandler+0x678>
 8002966:	687b      	ldr	r3, [r7, #4]
 8002968:	681b      	ldr	r3, [r3, #0]
 800296a:	4a2b      	ldr	r2, [pc, #172]	; (8002a18 <HAL_DMA_IRQHandler+0x694>)
 800296c:	4293      	cmp	r3, r2
 800296e:	d045      	beq.n	80029fc <HAL_DMA_IRQHandler+0x678>
 8002970:	687b      	ldr	r3, [r7, #4]
 8002972:	681b      	ldr	r3, [r3, #0]
 8002974:	4a29      	ldr	r2, [pc, #164]	; (8002a1c <HAL_DMA_IRQHandler+0x698>)
 8002976:	4293      	cmp	r3, r2
 8002978:	d040      	beq.n	80029fc <HAL_DMA_IRQHandler+0x678>
 800297a:	687b      	ldr	r3, [r7, #4]
 800297c:	681b      	ldr	r3, [r3, #0]
 800297e:	4a28      	ldr	r2, [pc, #160]	; (8002a20 <HAL_DMA_IRQHandler+0x69c>)
 8002980:	4293      	cmp	r3, r2
 8002982:	d03b      	beq.n	80029fc <HAL_DMA_IRQHandler+0x678>
 8002984:	687b      	ldr	r3, [r7, #4]
 8002986:	681b      	ldr	r3, [r3, #0]
 8002988:	4a26      	ldr	r2, [pc, #152]	; (8002a24 <HAL_DMA_IRQHandler+0x6a0>)
 800298a:	4293      	cmp	r3, r2
 800298c:	d036      	beq.n	80029fc <HAL_DMA_IRQHandler+0x678>
 800298e:	687b      	ldr	r3, [r7, #4]
 8002990:	681b      	ldr	r3, [r3, #0]
 8002992:	4a25      	ldr	r2, [pc, #148]	; (8002a28 <HAL_DMA_IRQHandler+0x6a4>)
 8002994:	4293      	cmp	r3, r2
 8002996:	d031      	beq.n	80029fc <HAL_DMA_IRQHandler+0x678>
 8002998:	687b      	ldr	r3, [r7, #4]
 800299a:	681b      	ldr	r3, [r3, #0]
 800299c:	4a23      	ldr	r2, [pc, #140]	; (8002a2c <HAL_DMA_IRQHandler+0x6a8>)
 800299e:	4293      	cmp	r3, r2
 80029a0:	d02c      	beq.n	80029fc <HAL_DMA_IRQHandler+0x678>
 80029a2:	687b      	ldr	r3, [r7, #4]
 80029a4:	681b      	ldr	r3, [r3, #0]
 80029a6:	4a22      	ldr	r2, [pc, #136]	; (8002a30 <HAL_DMA_IRQHandler+0x6ac>)
 80029a8:	4293      	cmp	r3, r2
 80029aa:	d027      	beq.n	80029fc <HAL_DMA_IRQHandler+0x678>
 80029ac:	687b      	ldr	r3, [r7, #4]
 80029ae:	681b      	ldr	r3, [r3, #0]
 80029b0:	4a20      	ldr	r2, [pc, #128]	; (8002a34 <HAL_DMA_IRQHandler+0x6b0>)
 80029b2:	4293      	cmp	r3, r2
 80029b4:	d022      	beq.n	80029fc <HAL_DMA_IRQHandler+0x678>
 80029b6:	687b      	ldr	r3, [r7, #4]
 80029b8:	681b      	ldr	r3, [r3, #0]
 80029ba:	4a1f      	ldr	r2, [pc, #124]	; (8002a38 <HAL_DMA_IRQHandler+0x6b4>)
 80029bc:	4293      	cmp	r3, r2
 80029be:	d01d      	beq.n	80029fc <HAL_DMA_IRQHandler+0x678>
 80029c0:	687b      	ldr	r3, [r7, #4]
 80029c2:	681b      	ldr	r3, [r3, #0]
 80029c4:	4a1d      	ldr	r2, [pc, #116]	; (8002a3c <HAL_DMA_IRQHandler+0x6b8>)
 80029c6:	4293      	cmp	r3, r2
 80029c8:	d018      	beq.n	80029fc <HAL_DMA_IRQHandler+0x678>
 80029ca:	687b      	ldr	r3, [r7, #4]
 80029cc:	681b      	ldr	r3, [r3, #0]
 80029ce:	4a1c      	ldr	r2, [pc, #112]	; (8002a40 <HAL_DMA_IRQHandler+0x6bc>)
 80029d0:	4293      	cmp	r3, r2
 80029d2:	d013      	beq.n	80029fc <HAL_DMA_IRQHandler+0x678>
 80029d4:	687b      	ldr	r3, [r7, #4]
 80029d6:	681b      	ldr	r3, [r3, #0]
 80029d8:	4a1a      	ldr	r2, [pc, #104]	; (8002a44 <HAL_DMA_IRQHandler+0x6c0>)
 80029da:	4293      	cmp	r3, r2
 80029dc:	d00e      	beq.n	80029fc <HAL_DMA_IRQHandler+0x678>
 80029de:	687b      	ldr	r3, [r7, #4]
 80029e0:	681b      	ldr	r3, [r3, #0]
 80029e2:	4a19      	ldr	r2, [pc, #100]	; (8002a48 <HAL_DMA_IRQHandler+0x6c4>)
 80029e4:	4293      	cmp	r3, r2
 80029e6:	d009      	beq.n	80029fc <HAL_DMA_IRQHandler+0x678>
 80029e8:	687b      	ldr	r3, [r7, #4]
 80029ea:	681b      	ldr	r3, [r3, #0]
 80029ec:	4a17      	ldr	r2, [pc, #92]	; (8002a4c <HAL_DMA_IRQHandler+0x6c8>)
 80029ee:	4293      	cmp	r3, r2
 80029f0:	d004      	beq.n	80029fc <HAL_DMA_IRQHandler+0x678>
 80029f2:	687b      	ldr	r3, [r7, #4]
 80029f4:	681b      	ldr	r3, [r3, #0]
 80029f6:	4a16      	ldr	r2, [pc, #88]	; (8002a50 <HAL_DMA_IRQHandler+0x6cc>)
 80029f8:	4293      	cmp	r3, r2
 80029fa:	d12b      	bne.n	8002a54 <HAL_DMA_IRQHandler+0x6d0>
 80029fc:	687b      	ldr	r3, [r7, #4]
 80029fe:	681b      	ldr	r3, [r3, #0]
 8002a00:	681b      	ldr	r3, [r3, #0]
 8002a02:	f003 0310 	and.w	r3, r3, #16
 8002a06:	2b00      	cmp	r3, #0
 8002a08:	bf14      	ite	ne
 8002a0a:	2301      	movne	r3, #1
 8002a0c:	2300      	moveq	r3, #0
 8002a0e:	b2db      	uxtb	r3, r3
 8002a10:	e02a      	b.n	8002a68 <HAL_DMA_IRQHandler+0x6e4>
 8002a12:	bf00      	nop
 8002a14:	40020010 	.word	0x40020010
 8002a18:	40020028 	.word	0x40020028
 8002a1c:	40020040 	.word	0x40020040
 8002a20:	40020058 	.word	0x40020058
 8002a24:	40020070 	.word	0x40020070
 8002a28:	40020088 	.word	0x40020088
 8002a2c:	400200a0 	.word	0x400200a0
 8002a30:	400200b8 	.word	0x400200b8
 8002a34:	40020410 	.word	0x40020410
 8002a38:	40020428 	.word	0x40020428
 8002a3c:	40020440 	.word	0x40020440
 8002a40:	40020458 	.word	0x40020458
 8002a44:	40020470 	.word	0x40020470
 8002a48:	40020488 	.word	0x40020488
 8002a4c:	400204a0 	.word	0x400204a0
 8002a50:	400204b8 	.word	0x400204b8
 8002a54:	687b      	ldr	r3, [r7, #4]
 8002a56:	681b      	ldr	r3, [r3, #0]
 8002a58:	681b      	ldr	r3, [r3, #0]
 8002a5a:	f003 0302 	and.w	r3, r3, #2
 8002a5e:	2b00      	cmp	r3, #0
 8002a60:	bf14      	ite	ne
 8002a62:	2301      	movne	r3, #1
 8002a64:	2300      	moveq	r3, #0
 8002a66:	b2db      	uxtb	r3, r3
 8002a68:	2b00      	cmp	r3, #0
 8002a6a:	f000 8087 	beq.w	8002b7c <HAL_DMA_IRQHandler+0x7f8>
      {
        /* Clear the transfer complete flag */
        regs_dma->IFCR = DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU);
 8002a6e:	687b      	ldr	r3, [r7, #4]
 8002a70:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8002a72:	f003 031f 	and.w	r3, r3, #31
 8002a76:	2220      	movs	r2, #32
 8002a78:	409a      	lsls	r2, r3
 8002a7a:	6a3b      	ldr	r3, [r7, #32]
 8002a7c:	609a      	str	r2, [r3, #8]

        if(HAL_DMA_STATE_ABORT == hdma->State)
 8002a7e:	687b      	ldr	r3, [r7, #4]
 8002a80:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8002a84:	b2db      	uxtb	r3, r3
 8002a86:	2b04      	cmp	r3, #4
 8002a88:	d139      	bne.n	8002afe <HAL_DMA_IRQHandler+0x77a>
        {
          /* Disable all the transfer interrupts */
          ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 8002a8a:	687b      	ldr	r3, [r7, #4]
 8002a8c:	681b      	ldr	r3, [r3, #0]
 8002a8e:	681a      	ldr	r2, [r3, #0]
 8002a90:	687b      	ldr	r3, [r7, #4]
 8002a92:	681b      	ldr	r3, [r3, #0]
 8002a94:	f022 0216 	bic.w	r2, r2, #22
 8002a98:	601a      	str	r2, [r3, #0]
          ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR &= ~(DMA_IT_FE);
 8002a9a:	687b      	ldr	r3, [r7, #4]
 8002a9c:	681b      	ldr	r3, [r3, #0]
 8002a9e:	695a      	ldr	r2, [r3, #20]
 8002aa0:	687b      	ldr	r3, [r7, #4]
 8002aa2:	681b      	ldr	r3, [r3, #0]
 8002aa4:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8002aa8:	615a      	str	r2, [r3, #20]

          if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8002aaa:	687b      	ldr	r3, [r7, #4]
 8002aac:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002aae:	2b00      	cmp	r3, #0
 8002ab0:	d103      	bne.n	8002aba <HAL_DMA_IRQHandler+0x736>
 8002ab2:	687b      	ldr	r3, [r7, #4]
 8002ab4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8002ab6:	2b00      	cmp	r3, #0
 8002ab8:	d007      	beq.n	8002aca <HAL_DMA_IRQHandler+0x746>
          {
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_HT);
 8002aba:	687b      	ldr	r3, [r7, #4]
 8002abc:	681b      	ldr	r3, [r3, #0]
 8002abe:	681a      	ldr	r2, [r3, #0]
 8002ac0:	687b      	ldr	r3, [r7, #4]
 8002ac2:	681b      	ldr	r3, [r3, #0]
 8002ac4:	f022 0208 	bic.w	r2, r2, #8
 8002ac8:	601a      	str	r2, [r3, #0]
          }

          /* Clear all interrupt flags at correct offset within the register */
          regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
 8002aca:	687b      	ldr	r3, [r7, #4]
 8002acc:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8002ace:	f003 031f 	and.w	r3, r3, #31
 8002ad2:	223f      	movs	r2, #63	; 0x3f
 8002ad4:	409a      	lsls	r2, r3
 8002ad6:	6a3b      	ldr	r3, [r7, #32]
 8002ad8:	609a      	str	r2, [r3, #8]

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
 8002ada:	687b      	ldr	r3, [r7, #4]
 8002adc:	2201      	movs	r2, #1
 8002ade:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

          /* Process Unlocked */
          __HAL_UNLOCK(hdma);
 8002ae2:	687b      	ldr	r3, [r7, #4]
 8002ae4:	2200      	movs	r2, #0
 8002ae6:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

          if(hdma->XferAbortCallback != NULL)
 8002aea:	687b      	ldr	r3, [r7, #4]
 8002aec:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8002aee:	2b00      	cmp	r3, #0
 8002af0:	f000 834a 	beq.w	8003188 <HAL_DMA_IRQHandler+0xe04>
          {
            hdma->XferAbortCallback(hdma);
 8002af4:	687b      	ldr	r3, [r7, #4]
 8002af6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8002af8:	6878      	ldr	r0, [r7, #4]
 8002afa:	4798      	blx	r3
          }
          return;
 8002afc:	e344      	b.n	8003188 <HAL_DMA_IRQHandler+0xe04>
        }

        if(((((DMA_Stream_TypeDef   *)hdma->Instance)->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)
 8002afe:	687b      	ldr	r3, [r7, #4]
 8002b00:	681b      	ldr	r3, [r3, #0]
 8002b02:	681b      	ldr	r3, [r3, #0]
 8002b04:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8002b08:	2b00      	cmp	r3, #0
 8002b0a:	d018      	beq.n	8002b3e <HAL_DMA_IRQHandler+0x7ba>
        {
          /* Current memory buffer used is Memory 0 */
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CT) == 0U)
 8002b0c:	687b      	ldr	r3, [r7, #4]
 8002b0e:	681b      	ldr	r3, [r3, #0]
 8002b10:	681b      	ldr	r3, [r3, #0]
 8002b12:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8002b16:	2b00      	cmp	r3, #0
 8002b18:	d108      	bne.n	8002b2c <HAL_DMA_IRQHandler+0x7a8>
          {
            if(hdma->XferM1CpltCallback != NULL)
 8002b1a:	687b      	ldr	r3, [r7, #4]
 8002b1c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002b1e:	2b00      	cmp	r3, #0
 8002b20:	d02c      	beq.n	8002b7c <HAL_DMA_IRQHandler+0x7f8>
            {
              /* Transfer complete Callback for memory1 */
              hdma->XferM1CpltCallback(hdma);
 8002b22:	687b      	ldr	r3, [r7, #4]
 8002b24:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002b26:	6878      	ldr	r0, [r7, #4]
 8002b28:	4798      	blx	r3
 8002b2a:	e027      	b.n	8002b7c <HAL_DMA_IRQHandler+0x7f8>
            }
          }
          /* Current memory buffer used is Memory 1 */
          else
          {
            if(hdma->XferCpltCallback != NULL)
 8002b2c:	687b      	ldr	r3, [r7, #4]
 8002b2e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002b30:	2b00      	cmp	r3, #0
 8002b32:	d023      	beq.n	8002b7c <HAL_DMA_IRQHandler+0x7f8>
            {
              /* Transfer complete Callback for memory0 */
              hdma->XferCpltCallback(hdma);
 8002b34:	687b      	ldr	r3, [r7, #4]
 8002b36:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002b38:	6878      	ldr	r0, [r7, #4]
 8002b3a:	4798      	blx	r3
 8002b3c:	e01e      	b.n	8002b7c <HAL_DMA_IRQHandler+0x7f8>
          }
        }
        /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
        else
        {
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) == 0U)
 8002b3e:	687b      	ldr	r3, [r7, #4]
 8002b40:	681b      	ldr	r3, [r3, #0]
 8002b42:	681b      	ldr	r3, [r3, #0]
 8002b44:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8002b48:	2b00      	cmp	r3, #0
 8002b4a:	d10f      	bne.n	8002b6c <HAL_DMA_IRQHandler+0x7e8>
          {
            /* Disable the transfer complete interrupt */
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC);
 8002b4c:	687b      	ldr	r3, [r7, #4]
 8002b4e:	681b      	ldr	r3, [r3, #0]
 8002b50:	681a      	ldr	r2, [r3, #0]
 8002b52:	687b      	ldr	r3, [r7, #4]
 8002b54:	681b      	ldr	r3, [r3, #0]
 8002b56:	f022 0210 	bic.w	r2, r2, #16
 8002b5a:	601a      	str	r2, [r3, #0]

            /* Change the DMA state */
            hdma->State = HAL_DMA_STATE_READY;
 8002b5c:	687b      	ldr	r3, [r7, #4]
 8002b5e:	2201      	movs	r2, #1
 8002b60:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

            /* Process Unlocked */
            __HAL_UNLOCK(hdma);
 8002b64:	687b      	ldr	r3, [r7, #4]
 8002b66:	2200      	movs	r2, #0
 8002b68:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
          }

          if(hdma->XferCpltCallback != NULL)
 8002b6c:	687b      	ldr	r3, [r7, #4]
 8002b6e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002b70:	2b00      	cmp	r3, #0
 8002b72:	d003      	beq.n	8002b7c <HAL_DMA_IRQHandler+0x7f8>
          {
            /* Transfer complete callback */
            hdma->XferCpltCallback(hdma);
 8002b74:	687b      	ldr	r3, [r7, #4]
 8002b76:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002b78:	6878      	ldr	r0, [r7, #4]
 8002b7a:	4798      	blx	r3
        }
      }
    }

    /* manage error case */
    if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
 8002b7c:	687b      	ldr	r3, [r7, #4]
 8002b7e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8002b80:	2b00      	cmp	r3, #0
 8002b82:	f000 8306 	beq.w	8003192 <HAL_DMA_IRQHandler+0xe0e>
    {
      if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != 0U)
 8002b86:	687b      	ldr	r3, [r7, #4]
 8002b88:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8002b8a:	f003 0301 	and.w	r3, r3, #1
 8002b8e:	2b00      	cmp	r3, #0
 8002b90:	f000 8088 	beq.w	8002ca4 <HAL_DMA_IRQHandler+0x920>
      {
        hdma->State = HAL_DMA_STATE_ABORT;
 8002b94:	687b      	ldr	r3, [r7, #4]
 8002b96:	2204      	movs	r2, #4
 8002b98:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        /* Disable the stream */
        __HAL_DMA_DISABLE(hdma);
 8002b9c:	687b      	ldr	r3, [r7, #4]
 8002b9e:	681b      	ldr	r3, [r3, #0]
 8002ba0:	4a7a      	ldr	r2, [pc, #488]	; (8002d8c <HAL_DMA_IRQHandler+0xa08>)
 8002ba2:	4293      	cmp	r3, r2
 8002ba4:	d04a      	beq.n	8002c3c <HAL_DMA_IRQHandler+0x8b8>
 8002ba6:	687b      	ldr	r3, [r7, #4]
 8002ba8:	681b      	ldr	r3, [r3, #0]
 8002baa:	4a79      	ldr	r2, [pc, #484]	; (8002d90 <HAL_DMA_IRQHandler+0xa0c>)
 8002bac:	4293      	cmp	r3, r2
 8002bae:	d045      	beq.n	8002c3c <HAL_DMA_IRQHandler+0x8b8>
 8002bb0:	687b      	ldr	r3, [r7, #4]
 8002bb2:	681b      	ldr	r3, [r3, #0]
 8002bb4:	4a77      	ldr	r2, [pc, #476]	; (8002d94 <HAL_DMA_IRQHandler+0xa10>)
 8002bb6:	4293      	cmp	r3, r2
 8002bb8:	d040      	beq.n	8002c3c <HAL_DMA_IRQHandler+0x8b8>
 8002bba:	687b      	ldr	r3, [r7, #4]
 8002bbc:	681b      	ldr	r3, [r3, #0]
 8002bbe:	4a76      	ldr	r2, [pc, #472]	; (8002d98 <HAL_DMA_IRQHandler+0xa14>)
 8002bc0:	4293      	cmp	r3, r2
 8002bc2:	d03b      	beq.n	8002c3c <HAL_DMA_IRQHandler+0x8b8>
 8002bc4:	687b      	ldr	r3, [r7, #4]
 8002bc6:	681b      	ldr	r3, [r3, #0]
 8002bc8:	4a74      	ldr	r2, [pc, #464]	; (8002d9c <HAL_DMA_IRQHandler+0xa18>)
 8002bca:	4293      	cmp	r3, r2
 8002bcc:	d036      	beq.n	8002c3c <HAL_DMA_IRQHandler+0x8b8>
 8002bce:	687b      	ldr	r3, [r7, #4]
 8002bd0:	681b      	ldr	r3, [r3, #0]
 8002bd2:	4a73      	ldr	r2, [pc, #460]	; (8002da0 <HAL_DMA_IRQHandler+0xa1c>)
 8002bd4:	4293      	cmp	r3, r2
 8002bd6:	d031      	beq.n	8002c3c <HAL_DMA_IRQHandler+0x8b8>
 8002bd8:	687b      	ldr	r3, [r7, #4]
 8002bda:	681b      	ldr	r3, [r3, #0]
 8002bdc:	4a71      	ldr	r2, [pc, #452]	; (8002da4 <HAL_DMA_IRQHandler+0xa20>)
 8002bde:	4293      	cmp	r3, r2
 8002be0:	d02c      	beq.n	8002c3c <HAL_DMA_IRQHandler+0x8b8>
 8002be2:	687b      	ldr	r3, [r7, #4]
 8002be4:	681b      	ldr	r3, [r3, #0]
 8002be6:	4a70      	ldr	r2, [pc, #448]	; (8002da8 <HAL_DMA_IRQHandler+0xa24>)
 8002be8:	4293      	cmp	r3, r2
 8002bea:	d027      	beq.n	8002c3c <HAL_DMA_IRQHandler+0x8b8>
 8002bec:	687b      	ldr	r3, [r7, #4]
 8002bee:	681b      	ldr	r3, [r3, #0]
 8002bf0:	4a6e      	ldr	r2, [pc, #440]	; (8002dac <HAL_DMA_IRQHandler+0xa28>)
 8002bf2:	4293      	cmp	r3, r2
 8002bf4:	d022      	beq.n	8002c3c <HAL_DMA_IRQHandler+0x8b8>
 8002bf6:	687b      	ldr	r3, [r7, #4]
 8002bf8:	681b      	ldr	r3, [r3, #0]
 8002bfa:	4a6d      	ldr	r2, [pc, #436]	; (8002db0 <HAL_DMA_IRQHandler+0xa2c>)
 8002bfc:	4293      	cmp	r3, r2
 8002bfe:	d01d      	beq.n	8002c3c <HAL_DMA_IRQHandler+0x8b8>
 8002c00:	687b      	ldr	r3, [r7, #4]
 8002c02:	681b      	ldr	r3, [r3, #0]
 8002c04:	4a6b      	ldr	r2, [pc, #428]	; (8002db4 <HAL_DMA_IRQHandler+0xa30>)
 8002c06:	4293      	cmp	r3, r2
 8002c08:	d018      	beq.n	8002c3c <HAL_DMA_IRQHandler+0x8b8>
 8002c0a:	687b      	ldr	r3, [r7, #4]
 8002c0c:	681b      	ldr	r3, [r3, #0]
 8002c0e:	4a6a      	ldr	r2, [pc, #424]	; (8002db8 <HAL_DMA_IRQHandler+0xa34>)
 8002c10:	4293      	cmp	r3, r2
 8002c12:	d013      	beq.n	8002c3c <HAL_DMA_IRQHandler+0x8b8>
 8002c14:	687b      	ldr	r3, [r7, #4]
 8002c16:	681b      	ldr	r3, [r3, #0]
 8002c18:	4a68      	ldr	r2, [pc, #416]	; (8002dbc <HAL_DMA_IRQHandler+0xa38>)
 8002c1a:	4293      	cmp	r3, r2
 8002c1c:	d00e      	beq.n	8002c3c <HAL_DMA_IRQHandler+0x8b8>
 8002c1e:	687b      	ldr	r3, [r7, #4]
 8002c20:	681b      	ldr	r3, [r3, #0]
 8002c22:	4a67      	ldr	r2, [pc, #412]	; (8002dc0 <HAL_DMA_IRQHandler+0xa3c>)
 8002c24:	4293      	cmp	r3, r2
 8002c26:	d009      	beq.n	8002c3c <HAL_DMA_IRQHandler+0x8b8>
 8002c28:	687b      	ldr	r3, [r7, #4]
 8002c2a:	681b      	ldr	r3, [r3, #0]
 8002c2c:	4a65      	ldr	r2, [pc, #404]	; (8002dc4 <HAL_DMA_IRQHandler+0xa40>)
 8002c2e:	4293      	cmp	r3, r2
 8002c30:	d004      	beq.n	8002c3c <HAL_DMA_IRQHandler+0x8b8>
 8002c32:	687b      	ldr	r3, [r7, #4]
 8002c34:	681b      	ldr	r3, [r3, #0]
 8002c36:	4a64      	ldr	r2, [pc, #400]	; (8002dc8 <HAL_DMA_IRQHandler+0xa44>)
 8002c38:	4293      	cmp	r3, r2
 8002c3a:	d108      	bne.n	8002c4e <HAL_DMA_IRQHandler+0x8ca>
 8002c3c:	687b      	ldr	r3, [r7, #4]
 8002c3e:	681b      	ldr	r3, [r3, #0]
 8002c40:	681a      	ldr	r2, [r3, #0]
 8002c42:	687b      	ldr	r3, [r7, #4]
 8002c44:	681b      	ldr	r3, [r3, #0]
 8002c46:	f022 0201 	bic.w	r2, r2, #1
 8002c4a:	601a      	str	r2, [r3, #0]
 8002c4c:	e007      	b.n	8002c5e <HAL_DMA_IRQHandler+0x8da>
 8002c4e:	687b      	ldr	r3, [r7, #4]
 8002c50:	681b      	ldr	r3, [r3, #0]
 8002c52:	681a      	ldr	r2, [r3, #0]
 8002c54:	687b      	ldr	r3, [r7, #4]
 8002c56:	681b      	ldr	r3, [r3, #0]
 8002c58:	f022 0201 	bic.w	r2, r2, #1
 8002c5c:	601a      	str	r2, [r3, #0]

        do
        {
          if (++count > timeout)
 8002c5e:	68fb      	ldr	r3, [r7, #12]
 8002c60:	3301      	adds	r3, #1
 8002c62:	60fb      	str	r3, [r7, #12]
 8002c64:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8002c66:	429a      	cmp	r2, r3
 8002c68:	d307      	bcc.n	8002c7a <HAL_DMA_IRQHandler+0x8f6>
          {
            break;
          }
        }
        while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U);
 8002c6a:	687b      	ldr	r3, [r7, #4]
 8002c6c:	681b      	ldr	r3, [r3, #0]
 8002c6e:	681b      	ldr	r3, [r3, #0]
 8002c70:	f003 0301 	and.w	r3, r3, #1
 8002c74:	2b00      	cmp	r3, #0
 8002c76:	d1f2      	bne.n	8002c5e <HAL_DMA_IRQHandler+0x8da>
 8002c78:	e000      	b.n	8002c7c <HAL_DMA_IRQHandler+0x8f8>
            break;
 8002c7a:	bf00      	nop

        if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
 8002c7c:	687b      	ldr	r3, [r7, #4]
 8002c7e:	681b      	ldr	r3, [r3, #0]
 8002c80:	681b      	ldr	r3, [r3, #0]
 8002c82:	f003 0301 	and.w	r3, r3, #1
 8002c86:	2b00      	cmp	r3, #0
 8002c88:	d004      	beq.n	8002c94 <HAL_DMA_IRQHandler+0x910>
        {
          /* Change the DMA state to error if DMA disable fails */
          hdma->State = HAL_DMA_STATE_ERROR;
 8002c8a:	687b      	ldr	r3, [r7, #4]
 8002c8c:	2203      	movs	r2, #3
 8002c8e:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
 8002c92:	e003      	b.n	8002c9c <HAL_DMA_IRQHandler+0x918>
        }
        else
        {
          /* Change the DMA state to Ready if DMA disable success */
          hdma->State = HAL_DMA_STATE_READY;
 8002c94:	687b      	ldr	r3, [r7, #4]
 8002c96:	2201      	movs	r2, #1
 8002c98:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
        }

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
 8002c9c:	687b      	ldr	r3, [r7, #4]
 8002c9e:	2200      	movs	r2, #0
 8002ca0:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
      }

      if(hdma->XferErrorCallback != NULL)
 8002ca4:	687b      	ldr	r3, [r7, #4]
 8002ca6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8002ca8:	2b00      	cmp	r3, #0
 8002caa:	f000 8272 	beq.w	8003192 <HAL_DMA_IRQHandler+0xe0e>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
 8002cae:	687b      	ldr	r3, [r7, #4]
 8002cb0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8002cb2:	6878      	ldr	r0, [r7, #4]
 8002cb4:	4798      	blx	r3
 8002cb6:	e26c      	b.n	8003192 <HAL_DMA_IRQHandler+0xe0e>
      }
    }
  }
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U)  /* BDMA instance(s) */
 8002cb8:	687b      	ldr	r3, [r7, #4]
 8002cba:	681b      	ldr	r3, [r3, #0]
 8002cbc:	4a43      	ldr	r2, [pc, #268]	; (8002dcc <HAL_DMA_IRQHandler+0xa48>)
 8002cbe:	4293      	cmp	r3, r2
 8002cc0:	d022      	beq.n	8002d08 <HAL_DMA_IRQHandler+0x984>
 8002cc2:	687b      	ldr	r3, [r7, #4]
 8002cc4:	681b      	ldr	r3, [r3, #0]
 8002cc6:	4a42      	ldr	r2, [pc, #264]	; (8002dd0 <HAL_DMA_IRQHandler+0xa4c>)
 8002cc8:	4293      	cmp	r3, r2
 8002cca:	d01d      	beq.n	8002d08 <HAL_DMA_IRQHandler+0x984>
 8002ccc:	687b      	ldr	r3, [r7, #4]
 8002cce:	681b      	ldr	r3, [r3, #0]
 8002cd0:	4a40      	ldr	r2, [pc, #256]	; (8002dd4 <HAL_DMA_IRQHandler+0xa50>)
 8002cd2:	4293      	cmp	r3, r2
 8002cd4:	d018      	beq.n	8002d08 <HAL_DMA_IRQHandler+0x984>
 8002cd6:	687b      	ldr	r3, [r7, #4]
 8002cd8:	681b      	ldr	r3, [r3, #0]
 8002cda:	4a3f      	ldr	r2, [pc, #252]	; (8002dd8 <HAL_DMA_IRQHandler+0xa54>)
 8002cdc:	4293      	cmp	r3, r2
 8002cde:	d013      	beq.n	8002d08 <HAL_DMA_IRQHandler+0x984>
 8002ce0:	687b      	ldr	r3, [r7, #4]
 8002ce2:	681b      	ldr	r3, [r3, #0]
 8002ce4:	4a3d      	ldr	r2, [pc, #244]	; (8002ddc <HAL_DMA_IRQHandler+0xa58>)
 8002ce6:	4293      	cmp	r3, r2
 8002ce8:	d00e      	beq.n	8002d08 <HAL_DMA_IRQHandler+0x984>
 8002cea:	687b      	ldr	r3, [r7, #4]
 8002cec:	681b      	ldr	r3, [r3, #0]
 8002cee:	4a3c      	ldr	r2, [pc, #240]	; (8002de0 <HAL_DMA_IRQHandler+0xa5c>)
 8002cf0:	4293      	cmp	r3, r2
 8002cf2:	d009      	beq.n	8002d08 <HAL_DMA_IRQHandler+0x984>
 8002cf4:	687b      	ldr	r3, [r7, #4]
 8002cf6:	681b      	ldr	r3, [r3, #0]
 8002cf8:	4a3a      	ldr	r2, [pc, #232]	; (8002de4 <HAL_DMA_IRQHandler+0xa60>)
 8002cfa:	4293      	cmp	r3, r2
 8002cfc:	d004      	beq.n	8002d08 <HAL_DMA_IRQHandler+0x984>
 8002cfe:	687b      	ldr	r3, [r7, #4]
 8002d00:	681b      	ldr	r3, [r3, #0]
 8002d02:	4a39      	ldr	r2, [pc, #228]	; (8002de8 <HAL_DMA_IRQHandler+0xa64>)
 8002d04:	4293      	cmp	r3, r2
 8002d06:	d101      	bne.n	8002d0c <HAL_DMA_IRQHandler+0x988>
 8002d08:	2301      	movs	r3, #1
 8002d0a:	e000      	b.n	8002d0e <HAL_DMA_IRQHandler+0x98a>
 8002d0c:	2300      	movs	r3, #0
 8002d0e:	2b00      	cmp	r3, #0
 8002d10:	f000 823f 	beq.w	8003192 <HAL_DMA_IRQHandler+0xe0e>
  {
    ccr_reg = (((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR);
 8002d14:	687b      	ldr	r3, [r7, #4]
 8002d16:	681b      	ldr	r3, [r3, #0]
 8002d18:	681b      	ldr	r3, [r3, #0]
 8002d1a:	613b      	str	r3, [r7, #16]

    /* Half Transfer Complete Interrupt management ******************************/
    if (((tmpisr_bdma & (BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_HTIE) != 0U))
 8002d1c:	687b      	ldr	r3, [r7, #4]
 8002d1e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8002d20:	f003 031f 	and.w	r3, r3, #31
 8002d24:	2204      	movs	r2, #4
 8002d26:	409a      	lsls	r2, r3
 8002d28:	697b      	ldr	r3, [r7, #20]
 8002d2a:	4013      	ands	r3, r2
 8002d2c:	2b00      	cmp	r3, #0
 8002d2e:	f000 80cd 	beq.w	8002ecc <HAL_DMA_IRQHandler+0xb48>
 8002d32:	693b      	ldr	r3, [r7, #16]
 8002d34:	f003 0304 	and.w	r3, r3, #4
 8002d38:	2b00      	cmp	r3, #0
 8002d3a:	f000 80c7 	beq.w	8002ecc <HAL_DMA_IRQHandler+0xb48>
    {
      /* Clear the half transfer complete flag */
      regs_bdma->IFCR = (BDMA_ISR_HTIF0 << (hdma->StreamIndex & 0x1FU));
 8002d3e:	687b      	ldr	r3, [r7, #4]
 8002d40:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8002d42:	f003 031f 	and.w	r3, r3, #31
 8002d46:	2204      	movs	r2, #4
 8002d48:	409a      	lsls	r2, r3
 8002d4a:	69fb      	ldr	r3, [r7, #28]
 8002d4c:	605a      	str	r2, [r3, #4]

      /* Disable the transfer complete interrupt if the DMA mode is Double Buffering */
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 8002d4e:	693b      	ldr	r3, [r7, #16]
 8002d50:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8002d54:	2b00      	cmp	r3, #0
 8002d56:	d049      	beq.n	8002dec <HAL_DMA_IRQHandler+0xa68>
      {
        /* Current memory buffer used is Memory 0 */
        if((ccr_reg & BDMA_CCR_CT) == 0U)
 8002d58:	693b      	ldr	r3, [r7, #16]
 8002d5a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8002d5e:	2b00      	cmp	r3, #0
 8002d60:	d109      	bne.n	8002d76 <HAL_DMA_IRQHandler+0x9f2>
        {
          if(hdma->XferM1HalfCpltCallback != NULL)
 8002d62:	687b      	ldr	r3, [r7, #4]
 8002d64:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8002d66:	2b00      	cmp	r3, #0
 8002d68:	f000 8210 	beq.w	800318c <HAL_DMA_IRQHandler+0xe08>
          {
            /* Half transfer Callback for Memory 1 */
            hdma->XferM1HalfCpltCallback(hdma);
 8002d6c:	687b      	ldr	r3, [r7, #4]
 8002d6e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8002d70:	6878      	ldr	r0, [r7, #4]
 8002d72:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 8002d74:	e20a      	b.n	800318c <HAL_DMA_IRQHandler+0xe08>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferHalfCpltCallback != NULL)
 8002d76:	687b      	ldr	r3, [r7, #4]
 8002d78:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002d7a:	2b00      	cmp	r3, #0
 8002d7c:	f000 8206 	beq.w	800318c <HAL_DMA_IRQHandler+0xe08>
          {
            /* Half transfer Callback for Memory 0 */
            hdma->XferHalfCpltCallback(hdma);
 8002d80:	687b      	ldr	r3, [r7, #4]
 8002d82:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002d84:	6878      	ldr	r0, [r7, #4]
 8002d86:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 8002d88:	e200      	b.n	800318c <HAL_DMA_IRQHandler+0xe08>
 8002d8a:	bf00      	nop
 8002d8c:	40020010 	.word	0x40020010
 8002d90:	40020028 	.word	0x40020028
 8002d94:	40020040 	.word	0x40020040
 8002d98:	40020058 	.word	0x40020058
 8002d9c:	40020070 	.word	0x40020070
 8002da0:	40020088 	.word	0x40020088
 8002da4:	400200a0 	.word	0x400200a0
 8002da8:	400200b8 	.word	0x400200b8
 8002dac:	40020410 	.word	0x40020410
 8002db0:	40020428 	.word	0x40020428
 8002db4:	40020440 	.word	0x40020440
 8002db8:	40020458 	.word	0x40020458
 8002dbc:	40020470 	.word	0x40020470
 8002dc0:	40020488 	.word	0x40020488
 8002dc4:	400204a0 	.word	0x400204a0
 8002dc8:	400204b8 	.word	0x400204b8
 8002dcc:	58025408 	.word	0x58025408
 8002dd0:	5802541c 	.word	0x5802541c
 8002dd4:	58025430 	.word	0x58025430
 8002dd8:	58025444 	.word	0x58025444
 8002ddc:	58025458 	.word	0x58025458
 8002de0:	5802546c 	.word	0x5802546c
 8002de4:	58025480 	.word	0x58025480
 8002de8:	58025494 	.word	0x58025494
          }
        }
      }
      else
      {
        if((ccr_reg & BDMA_CCR_CIRC) == 0U)
 8002dec:	693b      	ldr	r3, [r7, #16]
 8002dee:	f003 0320 	and.w	r3, r3, #32
 8002df2:	2b00      	cmp	r3, #0
 8002df4:	d160      	bne.n	8002eb8 <HAL_DMA_IRQHandler+0xb34>
        {
          /* Disable the half transfer interrupt */
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 8002df6:	687b      	ldr	r3, [r7, #4]
 8002df8:	681b      	ldr	r3, [r3, #0]
 8002dfa:	4a8c      	ldr	r2, [pc, #560]	; (800302c <HAL_DMA_IRQHandler+0xca8>)
 8002dfc:	4293      	cmp	r3, r2
 8002dfe:	d04a      	beq.n	8002e96 <HAL_DMA_IRQHandler+0xb12>
 8002e00:	687b      	ldr	r3, [r7, #4]
 8002e02:	681b      	ldr	r3, [r3, #0]
 8002e04:	4a8a      	ldr	r2, [pc, #552]	; (8003030 <HAL_DMA_IRQHandler+0xcac>)
 8002e06:	4293      	cmp	r3, r2
 8002e08:	d045      	beq.n	8002e96 <HAL_DMA_IRQHandler+0xb12>
 8002e0a:	687b      	ldr	r3, [r7, #4]
 8002e0c:	681b      	ldr	r3, [r3, #0]
 8002e0e:	4a89      	ldr	r2, [pc, #548]	; (8003034 <HAL_DMA_IRQHandler+0xcb0>)
 8002e10:	4293      	cmp	r3, r2
 8002e12:	d040      	beq.n	8002e96 <HAL_DMA_IRQHandler+0xb12>
 8002e14:	687b      	ldr	r3, [r7, #4]
 8002e16:	681b      	ldr	r3, [r3, #0]
 8002e18:	4a87      	ldr	r2, [pc, #540]	; (8003038 <HAL_DMA_IRQHandler+0xcb4>)
 8002e1a:	4293      	cmp	r3, r2
 8002e1c:	d03b      	beq.n	8002e96 <HAL_DMA_IRQHandler+0xb12>
 8002e1e:	687b      	ldr	r3, [r7, #4]
 8002e20:	681b      	ldr	r3, [r3, #0]
 8002e22:	4a86      	ldr	r2, [pc, #536]	; (800303c <HAL_DMA_IRQHandler+0xcb8>)
 8002e24:	4293      	cmp	r3, r2
 8002e26:	d036      	beq.n	8002e96 <HAL_DMA_IRQHandler+0xb12>
 8002e28:	687b      	ldr	r3, [r7, #4]
 8002e2a:	681b      	ldr	r3, [r3, #0]
 8002e2c:	4a84      	ldr	r2, [pc, #528]	; (8003040 <HAL_DMA_IRQHandler+0xcbc>)
 8002e2e:	4293      	cmp	r3, r2
 8002e30:	d031      	beq.n	8002e96 <HAL_DMA_IRQHandler+0xb12>
 8002e32:	687b      	ldr	r3, [r7, #4]
 8002e34:	681b      	ldr	r3, [r3, #0]
 8002e36:	4a83      	ldr	r2, [pc, #524]	; (8003044 <HAL_DMA_IRQHandler+0xcc0>)
 8002e38:	4293      	cmp	r3, r2
 8002e3a:	d02c      	beq.n	8002e96 <HAL_DMA_IRQHandler+0xb12>
 8002e3c:	687b      	ldr	r3, [r7, #4]
 8002e3e:	681b      	ldr	r3, [r3, #0]
 8002e40:	4a81      	ldr	r2, [pc, #516]	; (8003048 <HAL_DMA_IRQHandler+0xcc4>)
 8002e42:	4293      	cmp	r3, r2
 8002e44:	d027      	beq.n	8002e96 <HAL_DMA_IRQHandler+0xb12>
 8002e46:	687b      	ldr	r3, [r7, #4]
 8002e48:	681b      	ldr	r3, [r3, #0]
 8002e4a:	4a80      	ldr	r2, [pc, #512]	; (800304c <HAL_DMA_IRQHandler+0xcc8>)
 8002e4c:	4293      	cmp	r3, r2
 8002e4e:	d022      	beq.n	8002e96 <HAL_DMA_IRQHandler+0xb12>
 8002e50:	687b      	ldr	r3, [r7, #4]
 8002e52:	681b      	ldr	r3, [r3, #0]
 8002e54:	4a7e      	ldr	r2, [pc, #504]	; (8003050 <HAL_DMA_IRQHandler+0xccc>)
 8002e56:	4293      	cmp	r3, r2
 8002e58:	d01d      	beq.n	8002e96 <HAL_DMA_IRQHandler+0xb12>
 8002e5a:	687b      	ldr	r3, [r7, #4]
 8002e5c:	681b      	ldr	r3, [r3, #0]
 8002e5e:	4a7d      	ldr	r2, [pc, #500]	; (8003054 <HAL_DMA_IRQHandler+0xcd0>)
 8002e60:	4293      	cmp	r3, r2
 8002e62:	d018      	beq.n	8002e96 <HAL_DMA_IRQHandler+0xb12>
 8002e64:	687b      	ldr	r3, [r7, #4]
 8002e66:	681b      	ldr	r3, [r3, #0]
 8002e68:	4a7b      	ldr	r2, [pc, #492]	; (8003058 <HAL_DMA_IRQHandler+0xcd4>)
 8002e6a:	4293      	cmp	r3, r2
 8002e6c:	d013      	beq.n	8002e96 <HAL_DMA_IRQHandler+0xb12>
 8002e6e:	687b      	ldr	r3, [r7, #4]
 8002e70:	681b      	ldr	r3, [r3, #0]
 8002e72:	4a7a      	ldr	r2, [pc, #488]	; (800305c <HAL_DMA_IRQHandler+0xcd8>)
 8002e74:	4293      	cmp	r3, r2
 8002e76:	d00e      	beq.n	8002e96 <HAL_DMA_IRQHandler+0xb12>
 8002e78:	687b      	ldr	r3, [r7, #4]
 8002e7a:	681b      	ldr	r3, [r3, #0]
 8002e7c:	4a78      	ldr	r2, [pc, #480]	; (8003060 <HAL_DMA_IRQHandler+0xcdc>)
 8002e7e:	4293      	cmp	r3, r2
 8002e80:	d009      	beq.n	8002e96 <HAL_DMA_IRQHandler+0xb12>
 8002e82:	687b      	ldr	r3, [r7, #4]
 8002e84:	681b      	ldr	r3, [r3, #0]
 8002e86:	4a77      	ldr	r2, [pc, #476]	; (8003064 <HAL_DMA_IRQHandler+0xce0>)
 8002e88:	4293      	cmp	r3, r2
 8002e8a:	d004      	beq.n	8002e96 <HAL_DMA_IRQHandler+0xb12>
 8002e8c:	687b      	ldr	r3, [r7, #4]
 8002e8e:	681b      	ldr	r3, [r3, #0]
 8002e90:	4a75      	ldr	r2, [pc, #468]	; (8003068 <HAL_DMA_IRQHandler+0xce4>)
 8002e92:	4293      	cmp	r3, r2
 8002e94:	d108      	bne.n	8002ea8 <HAL_DMA_IRQHandler+0xb24>
 8002e96:	687b      	ldr	r3, [r7, #4]
 8002e98:	681b      	ldr	r3, [r3, #0]
 8002e9a:	681a      	ldr	r2, [r3, #0]
 8002e9c:	687b      	ldr	r3, [r7, #4]
 8002e9e:	681b      	ldr	r3, [r3, #0]
 8002ea0:	f022 0208 	bic.w	r2, r2, #8
 8002ea4:	601a      	str	r2, [r3, #0]
 8002ea6:	e007      	b.n	8002eb8 <HAL_DMA_IRQHandler+0xb34>
 8002ea8:	687b      	ldr	r3, [r7, #4]
 8002eaa:	681b      	ldr	r3, [r3, #0]
 8002eac:	681a      	ldr	r2, [r3, #0]
 8002eae:	687b      	ldr	r3, [r7, #4]
 8002eb0:	681b      	ldr	r3, [r3, #0]
 8002eb2:	f022 0204 	bic.w	r2, r2, #4
 8002eb6:	601a      	str	r2, [r3, #0]
        }

        /* DMA peripheral state is not updated in Half Transfer */
        /* but in Transfer Complete case */

       if(hdma->XferHalfCpltCallback != NULL)
 8002eb8:	687b      	ldr	r3, [r7, #4]
 8002eba:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002ebc:	2b00      	cmp	r3, #0
 8002ebe:	f000 8165 	beq.w	800318c <HAL_DMA_IRQHandler+0xe08>
        {
          /* Half transfer callback */
          hdma->XferHalfCpltCallback(hdma);
 8002ec2:	687b      	ldr	r3, [r7, #4]
 8002ec4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002ec6:	6878      	ldr	r0, [r7, #4]
 8002ec8:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 8002eca:	e15f      	b.n	800318c <HAL_DMA_IRQHandler+0xe08>
        }
      }
    }

    /* Transfer Complete Interrupt management ***********************************/
    else if (((tmpisr_bdma & (BDMA_FLAG_TC0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_TCIE) != 0U))
 8002ecc:	687b      	ldr	r3, [r7, #4]
 8002ece:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8002ed0:	f003 031f 	and.w	r3, r3, #31
 8002ed4:	2202      	movs	r2, #2
 8002ed6:	409a      	lsls	r2, r3
 8002ed8:	697b      	ldr	r3, [r7, #20]
 8002eda:	4013      	ands	r3, r2
 8002edc:	2b00      	cmp	r3, #0
 8002ede:	f000 80c5 	beq.w	800306c <HAL_DMA_IRQHandler+0xce8>
 8002ee2:	693b      	ldr	r3, [r7, #16]
 8002ee4:	f003 0302 	and.w	r3, r3, #2
 8002ee8:	2b00      	cmp	r3, #0
 8002eea:	f000 80bf 	beq.w	800306c <HAL_DMA_IRQHandler+0xce8>
    {
      /* Clear the transfer complete flag */
      regs_bdma->IFCR = (BDMA_ISR_TCIF0) << (hdma->StreamIndex & 0x1FU);
 8002eee:	687b      	ldr	r3, [r7, #4]
 8002ef0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8002ef2:	f003 031f 	and.w	r3, r3, #31
 8002ef6:	2202      	movs	r2, #2
 8002ef8:	409a      	lsls	r2, r3
 8002efa:	69fb      	ldr	r3, [r7, #28]
 8002efc:	605a      	str	r2, [r3, #4]

      /* Disable the transfer complete interrupt if the DMA mode is Double Buffering */
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 8002efe:	693b      	ldr	r3, [r7, #16]
 8002f00:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8002f04:	2b00      	cmp	r3, #0
 8002f06:	d018      	beq.n	8002f3a <HAL_DMA_IRQHandler+0xbb6>
      {
        /* Current memory buffer used is Memory 0 */
        if((ccr_reg & BDMA_CCR_CT) == 0U)
 8002f08:	693b      	ldr	r3, [r7, #16]
 8002f0a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8002f0e:	2b00      	cmp	r3, #0
 8002f10:	d109      	bne.n	8002f26 <HAL_DMA_IRQHandler+0xba2>
        {
          if(hdma->XferM1CpltCallback != NULL)
 8002f12:	687b      	ldr	r3, [r7, #4]
 8002f14:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002f16:	2b00      	cmp	r3, #0
 8002f18:	f000 813a 	beq.w	8003190 <HAL_DMA_IRQHandler+0xe0c>
          {
            /* Transfer complete Callback for Memory 1 */
            hdma->XferM1CpltCallback(hdma);
 8002f1c:	687b      	ldr	r3, [r7, #4]
 8002f1e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002f20:	6878      	ldr	r0, [r7, #4]
 8002f22:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 8002f24:	e134      	b.n	8003190 <HAL_DMA_IRQHandler+0xe0c>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferCpltCallback != NULL)
 8002f26:	687b      	ldr	r3, [r7, #4]
 8002f28:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002f2a:	2b00      	cmp	r3, #0
 8002f2c:	f000 8130 	beq.w	8003190 <HAL_DMA_IRQHandler+0xe0c>
          {
            /* Transfer complete Callback for Memory 0 */
            hdma->XferCpltCallback(hdma);
 8002f30:	687b      	ldr	r3, [r7, #4]
 8002f32:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002f34:	6878      	ldr	r0, [r7, #4]
 8002f36:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 8002f38:	e12a      	b.n	8003190 <HAL_DMA_IRQHandler+0xe0c>
          }
        }
      }
      else
      {
        if((ccr_reg & BDMA_CCR_CIRC) == 0U)
 8002f3a:	693b      	ldr	r3, [r7, #16]
 8002f3c:	f003 0320 	and.w	r3, r3, #32
 8002f40:	2b00      	cmp	r3, #0
 8002f42:	d168      	bne.n	8003016 <HAL_DMA_IRQHandler+0xc92>
        {
          /* Disable the transfer complete and error interrupt, if the DMA mode is not CIRCULAR */
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
 8002f44:	687b      	ldr	r3, [r7, #4]
 8002f46:	681b      	ldr	r3, [r3, #0]
 8002f48:	4a38      	ldr	r2, [pc, #224]	; (800302c <HAL_DMA_IRQHandler+0xca8>)
 8002f4a:	4293      	cmp	r3, r2
 8002f4c:	d04a      	beq.n	8002fe4 <HAL_DMA_IRQHandler+0xc60>
 8002f4e:	687b      	ldr	r3, [r7, #4]
 8002f50:	681b      	ldr	r3, [r3, #0]
 8002f52:	4a37      	ldr	r2, [pc, #220]	; (8003030 <HAL_DMA_IRQHandler+0xcac>)
 8002f54:	4293      	cmp	r3, r2
 8002f56:	d045      	beq.n	8002fe4 <HAL_DMA_IRQHandler+0xc60>
 8002f58:	687b      	ldr	r3, [r7, #4]
 8002f5a:	681b      	ldr	r3, [r3, #0]
 8002f5c:	4a35      	ldr	r2, [pc, #212]	; (8003034 <HAL_DMA_IRQHandler+0xcb0>)
 8002f5e:	4293      	cmp	r3, r2
 8002f60:	d040      	beq.n	8002fe4 <HAL_DMA_IRQHandler+0xc60>
 8002f62:	687b      	ldr	r3, [r7, #4]
 8002f64:	681b      	ldr	r3, [r3, #0]
 8002f66:	4a34      	ldr	r2, [pc, #208]	; (8003038 <HAL_DMA_IRQHandler+0xcb4>)
 8002f68:	4293      	cmp	r3, r2
 8002f6a:	d03b      	beq.n	8002fe4 <HAL_DMA_IRQHandler+0xc60>
 8002f6c:	687b      	ldr	r3, [r7, #4]
 8002f6e:	681b      	ldr	r3, [r3, #0]
 8002f70:	4a32      	ldr	r2, [pc, #200]	; (800303c <HAL_DMA_IRQHandler+0xcb8>)
 8002f72:	4293      	cmp	r3, r2
 8002f74:	d036      	beq.n	8002fe4 <HAL_DMA_IRQHandler+0xc60>
 8002f76:	687b      	ldr	r3, [r7, #4]
 8002f78:	681b      	ldr	r3, [r3, #0]
 8002f7a:	4a31      	ldr	r2, [pc, #196]	; (8003040 <HAL_DMA_IRQHandler+0xcbc>)
 8002f7c:	4293      	cmp	r3, r2
 8002f7e:	d031      	beq.n	8002fe4 <HAL_DMA_IRQHandler+0xc60>
 8002f80:	687b      	ldr	r3, [r7, #4]
 8002f82:	681b      	ldr	r3, [r3, #0]
 8002f84:	4a2f      	ldr	r2, [pc, #188]	; (8003044 <HAL_DMA_IRQHandler+0xcc0>)
 8002f86:	4293      	cmp	r3, r2
 8002f88:	d02c      	beq.n	8002fe4 <HAL_DMA_IRQHandler+0xc60>
 8002f8a:	687b      	ldr	r3, [r7, #4]
 8002f8c:	681b      	ldr	r3, [r3, #0]
 8002f8e:	4a2e      	ldr	r2, [pc, #184]	; (8003048 <HAL_DMA_IRQHandler+0xcc4>)
 8002f90:	4293      	cmp	r3, r2
 8002f92:	d027      	beq.n	8002fe4 <HAL_DMA_IRQHandler+0xc60>
 8002f94:	687b      	ldr	r3, [r7, #4]
 8002f96:	681b      	ldr	r3, [r3, #0]
 8002f98:	4a2c      	ldr	r2, [pc, #176]	; (800304c <HAL_DMA_IRQHandler+0xcc8>)
 8002f9a:	4293      	cmp	r3, r2
 8002f9c:	d022      	beq.n	8002fe4 <HAL_DMA_IRQHandler+0xc60>
 8002f9e:	687b      	ldr	r3, [r7, #4]
 8002fa0:	681b      	ldr	r3, [r3, #0]
 8002fa2:	4a2b      	ldr	r2, [pc, #172]	; (8003050 <HAL_DMA_IRQHandler+0xccc>)
 8002fa4:	4293      	cmp	r3, r2
 8002fa6:	d01d      	beq.n	8002fe4 <HAL_DMA_IRQHandler+0xc60>
 8002fa8:	687b      	ldr	r3, [r7, #4]
 8002faa:	681b      	ldr	r3, [r3, #0]
 8002fac:	4a29      	ldr	r2, [pc, #164]	; (8003054 <HAL_DMA_IRQHandler+0xcd0>)
 8002fae:	4293      	cmp	r3, r2
 8002fb0:	d018      	beq.n	8002fe4 <HAL_DMA_IRQHandler+0xc60>
 8002fb2:	687b      	ldr	r3, [r7, #4]
 8002fb4:	681b      	ldr	r3, [r3, #0]
 8002fb6:	4a28      	ldr	r2, [pc, #160]	; (8003058 <HAL_DMA_IRQHandler+0xcd4>)
 8002fb8:	4293      	cmp	r3, r2
 8002fba:	d013      	beq.n	8002fe4 <HAL_DMA_IRQHandler+0xc60>
 8002fbc:	687b      	ldr	r3, [r7, #4]
 8002fbe:	681b      	ldr	r3, [r3, #0]
 8002fc0:	4a26      	ldr	r2, [pc, #152]	; (800305c <HAL_DMA_IRQHandler+0xcd8>)
 8002fc2:	4293      	cmp	r3, r2
 8002fc4:	d00e      	beq.n	8002fe4 <HAL_DMA_IRQHandler+0xc60>
 8002fc6:	687b      	ldr	r3, [r7, #4]
 8002fc8:	681b      	ldr	r3, [r3, #0]
 8002fca:	4a25      	ldr	r2, [pc, #148]	; (8003060 <HAL_DMA_IRQHandler+0xcdc>)
 8002fcc:	4293      	cmp	r3, r2
 8002fce:	d009      	beq.n	8002fe4 <HAL_DMA_IRQHandler+0xc60>
 8002fd0:	687b      	ldr	r3, [r7, #4]
 8002fd2:	681b      	ldr	r3, [r3, #0]
 8002fd4:	4a23      	ldr	r2, [pc, #140]	; (8003064 <HAL_DMA_IRQHandler+0xce0>)
 8002fd6:	4293      	cmp	r3, r2
 8002fd8:	d004      	beq.n	8002fe4 <HAL_DMA_IRQHandler+0xc60>
 8002fda:	687b      	ldr	r3, [r7, #4]
 8002fdc:	681b      	ldr	r3, [r3, #0]
 8002fde:	4a22      	ldr	r2, [pc, #136]	; (8003068 <HAL_DMA_IRQHandler+0xce4>)
 8002fe0:	4293      	cmp	r3, r2
 8002fe2:	d108      	bne.n	8002ff6 <HAL_DMA_IRQHandler+0xc72>
 8002fe4:	687b      	ldr	r3, [r7, #4]
 8002fe6:	681b      	ldr	r3, [r3, #0]
 8002fe8:	681a      	ldr	r2, [r3, #0]
 8002fea:	687b      	ldr	r3, [r7, #4]
 8002fec:	681b      	ldr	r3, [r3, #0]
 8002fee:	f022 0214 	bic.w	r2, r2, #20
 8002ff2:	601a      	str	r2, [r3, #0]
 8002ff4:	e007      	b.n	8003006 <HAL_DMA_IRQHandler+0xc82>
 8002ff6:	687b      	ldr	r3, [r7, #4]
 8002ff8:	681b      	ldr	r3, [r3, #0]
 8002ffa:	681a      	ldr	r2, [r3, #0]
 8002ffc:	687b      	ldr	r3, [r7, #4]
 8002ffe:	681b      	ldr	r3, [r3, #0]
 8003000:	f022 020a 	bic.w	r2, r2, #10
 8003004:	601a      	str	r2, [r3, #0]

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
 8003006:	687b      	ldr	r3, [r7, #4]
 8003008:	2201      	movs	r2, #1
 800300a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

          /* Process Unlocked */
          __HAL_UNLOCK(hdma);
 800300e:	687b      	ldr	r3, [r7, #4]
 8003010:	2200      	movs	r2, #0
 8003012:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
        }

        if(hdma->XferCpltCallback != NULL)
 8003016:	687b      	ldr	r3, [r7, #4]
 8003018:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800301a:	2b00      	cmp	r3, #0
 800301c:	f000 80b8 	beq.w	8003190 <HAL_DMA_IRQHandler+0xe0c>
        {
          /* Transfer complete callback */
          hdma->XferCpltCallback(hdma);
 8003020:	687b      	ldr	r3, [r7, #4]
 8003022:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8003024:	6878      	ldr	r0, [r7, #4]
 8003026:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 8003028:	e0b2      	b.n	8003190 <HAL_DMA_IRQHandler+0xe0c>
 800302a:	bf00      	nop
 800302c:	40020010 	.word	0x40020010
 8003030:	40020028 	.word	0x40020028
 8003034:	40020040 	.word	0x40020040
 8003038:	40020058 	.word	0x40020058
 800303c:	40020070 	.word	0x40020070
 8003040:	40020088 	.word	0x40020088
 8003044:	400200a0 	.word	0x400200a0
 8003048:	400200b8 	.word	0x400200b8
 800304c:	40020410 	.word	0x40020410
 8003050:	40020428 	.word	0x40020428
 8003054:	40020440 	.word	0x40020440
 8003058:	40020458 	.word	0x40020458
 800305c:	40020470 	.word	0x40020470
 8003060:	40020488 	.word	0x40020488
 8003064:	400204a0 	.word	0x400204a0
 8003068:	400204b8 	.word	0x400204b8
        }
      }
    }
    /* Transfer Error Interrupt management **************************************/
    else if (((tmpisr_bdma & (BDMA_FLAG_TE0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_TEIE) != 0U))
 800306c:	687b      	ldr	r3, [r7, #4]
 800306e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8003070:	f003 031f 	and.w	r3, r3, #31
 8003074:	2208      	movs	r2, #8
 8003076:	409a      	lsls	r2, r3
 8003078:	697b      	ldr	r3, [r7, #20]
 800307a:	4013      	ands	r3, r2
 800307c:	2b00      	cmp	r3, #0
 800307e:	f000 8088 	beq.w	8003192 <HAL_DMA_IRQHandler+0xe0e>
 8003082:	693b      	ldr	r3, [r7, #16]
 8003084:	f003 0308 	and.w	r3, r3, #8
 8003088:	2b00      	cmp	r3, #0
 800308a:	f000 8082 	beq.w	8003192 <HAL_DMA_IRQHandler+0xe0e>
    {
      /* When a DMA transfer error occurs */
      /* A hardware clear of its EN bits is performed */
      /* Disable ALL DMA IT */
      __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 800308e:	687b      	ldr	r3, [r7, #4]
 8003090:	681b      	ldr	r3, [r3, #0]
 8003092:	4a41      	ldr	r2, [pc, #260]	; (8003198 <HAL_DMA_IRQHandler+0xe14>)
 8003094:	4293      	cmp	r3, r2
 8003096:	d04a      	beq.n	800312e <HAL_DMA_IRQHandler+0xdaa>
 8003098:	687b      	ldr	r3, [r7, #4]
 800309a:	681b      	ldr	r3, [r3, #0]
 800309c:	4a3f      	ldr	r2, [pc, #252]	; (800319c <HAL_DMA_IRQHandler+0xe18>)
 800309e:	4293      	cmp	r3, r2
 80030a0:	d045      	beq.n	800312e <HAL_DMA_IRQHandler+0xdaa>
 80030a2:	687b      	ldr	r3, [r7, #4]
 80030a4:	681b      	ldr	r3, [r3, #0]
 80030a6:	4a3e      	ldr	r2, [pc, #248]	; (80031a0 <HAL_DMA_IRQHandler+0xe1c>)
 80030a8:	4293      	cmp	r3, r2
 80030aa:	d040      	beq.n	800312e <HAL_DMA_IRQHandler+0xdaa>
 80030ac:	687b      	ldr	r3, [r7, #4]
 80030ae:	681b      	ldr	r3, [r3, #0]
 80030b0:	4a3c      	ldr	r2, [pc, #240]	; (80031a4 <HAL_DMA_IRQHandler+0xe20>)
 80030b2:	4293      	cmp	r3, r2
 80030b4:	d03b      	beq.n	800312e <HAL_DMA_IRQHandler+0xdaa>
 80030b6:	687b      	ldr	r3, [r7, #4]
 80030b8:	681b      	ldr	r3, [r3, #0]
 80030ba:	4a3b      	ldr	r2, [pc, #236]	; (80031a8 <HAL_DMA_IRQHandler+0xe24>)
 80030bc:	4293      	cmp	r3, r2
 80030be:	d036      	beq.n	800312e <HAL_DMA_IRQHandler+0xdaa>
 80030c0:	687b      	ldr	r3, [r7, #4]
 80030c2:	681b      	ldr	r3, [r3, #0]
 80030c4:	4a39      	ldr	r2, [pc, #228]	; (80031ac <HAL_DMA_IRQHandler+0xe28>)
 80030c6:	4293      	cmp	r3, r2
 80030c8:	d031      	beq.n	800312e <HAL_DMA_IRQHandler+0xdaa>
 80030ca:	687b      	ldr	r3, [r7, #4]
 80030cc:	681b      	ldr	r3, [r3, #0]
 80030ce:	4a38      	ldr	r2, [pc, #224]	; (80031b0 <HAL_DMA_IRQHandler+0xe2c>)
 80030d0:	4293      	cmp	r3, r2
 80030d2:	d02c      	beq.n	800312e <HAL_DMA_IRQHandler+0xdaa>
 80030d4:	687b      	ldr	r3, [r7, #4]
 80030d6:	681b      	ldr	r3, [r3, #0]
 80030d8:	4a36      	ldr	r2, [pc, #216]	; (80031b4 <HAL_DMA_IRQHandler+0xe30>)
 80030da:	4293      	cmp	r3, r2
 80030dc:	d027      	beq.n	800312e <HAL_DMA_IRQHandler+0xdaa>
 80030de:	687b      	ldr	r3, [r7, #4]
 80030e0:	681b      	ldr	r3, [r3, #0]
 80030e2:	4a35      	ldr	r2, [pc, #212]	; (80031b8 <HAL_DMA_IRQHandler+0xe34>)
 80030e4:	4293      	cmp	r3, r2
 80030e6:	d022      	beq.n	800312e <HAL_DMA_IRQHandler+0xdaa>
 80030e8:	687b      	ldr	r3, [r7, #4]
 80030ea:	681b      	ldr	r3, [r3, #0]
 80030ec:	4a33      	ldr	r2, [pc, #204]	; (80031bc <HAL_DMA_IRQHandler+0xe38>)
 80030ee:	4293      	cmp	r3, r2
 80030f0:	d01d      	beq.n	800312e <HAL_DMA_IRQHandler+0xdaa>
 80030f2:	687b      	ldr	r3, [r7, #4]
 80030f4:	681b      	ldr	r3, [r3, #0]
 80030f6:	4a32      	ldr	r2, [pc, #200]	; (80031c0 <HAL_DMA_IRQHandler+0xe3c>)
 80030f8:	4293      	cmp	r3, r2
 80030fa:	d018      	beq.n	800312e <HAL_DMA_IRQHandler+0xdaa>
 80030fc:	687b      	ldr	r3, [r7, #4]
 80030fe:	681b      	ldr	r3, [r3, #0]
 8003100:	4a30      	ldr	r2, [pc, #192]	; (80031c4 <HAL_DMA_IRQHandler+0xe40>)
 8003102:	4293      	cmp	r3, r2
 8003104:	d013      	beq.n	800312e <HAL_DMA_IRQHandler+0xdaa>
 8003106:	687b      	ldr	r3, [r7, #4]
 8003108:	681b      	ldr	r3, [r3, #0]
 800310a:	4a2f      	ldr	r2, [pc, #188]	; (80031c8 <HAL_DMA_IRQHandler+0xe44>)
 800310c:	4293      	cmp	r3, r2
 800310e:	d00e      	beq.n	800312e <HAL_DMA_IRQHandler+0xdaa>
 8003110:	687b      	ldr	r3, [r7, #4]
 8003112:	681b      	ldr	r3, [r3, #0]
 8003114:	4a2d      	ldr	r2, [pc, #180]	; (80031cc <HAL_DMA_IRQHandler+0xe48>)
 8003116:	4293      	cmp	r3, r2
 8003118:	d009      	beq.n	800312e <HAL_DMA_IRQHandler+0xdaa>
 800311a:	687b      	ldr	r3, [r7, #4]
 800311c:	681b      	ldr	r3, [r3, #0]
 800311e:	4a2c      	ldr	r2, [pc, #176]	; (80031d0 <HAL_DMA_IRQHandler+0xe4c>)
 8003120:	4293      	cmp	r3, r2
 8003122:	d004      	beq.n	800312e <HAL_DMA_IRQHandler+0xdaa>
 8003124:	687b      	ldr	r3, [r7, #4]
 8003126:	681b      	ldr	r3, [r3, #0]
 8003128:	4a2a      	ldr	r2, [pc, #168]	; (80031d4 <HAL_DMA_IRQHandler+0xe50>)
 800312a:	4293      	cmp	r3, r2
 800312c:	d108      	bne.n	8003140 <HAL_DMA_IRQHandler+0xdbc>
 800312e:	687b      	ldr	r3, [r7, #4]
 8003130:	681b      	ldr	r3, [r3, #0]
 8003132:	681a      	ldr	r2, [r3, #0]
 8003134:	687b      	ldr	r3, [r7, #4]
 8003136:	681b      	ldr	r3, [r3, #0]
 8003138:	f022 021c 	bic.w	r2, r2, #28
 800313c:	601a      	str	r2, [r3, #0]
 800313e:	e007      	b.n	8003150 <HAL_DMA_IRQHandler+0xdcc>
 8003140:	687b      	ldr	r3, [r7, #4]
 8003142:	681b      	ldr	r3, [r3, #0]
 8003144:	681a      	ldr	r2, [r3, #0]
 8003146:	687b      	ldr	r3, [r7, #4]
 8003148:	681b      	ldr	r3, [r3, #0]
 800314a:	f022 020e 	bic.w	r2, r2, #14
 800314e:	601a      	str	r2, [r3, #0]

      /* Clear all flags */
      regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
 8003150:	687b      	ldr	r3, [r7, #4]
 8003152:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8003154:	f003 031f 	and.w	r3, r3, #31
 8003158:	2201      	movs	r2, #1
 800315a:	409a      	lsls	r2, r3
 800315c:	69fb      	ldr	r3, [r7, #28]
 800315e:	605a      	str	r2, [r3, #4]

      /* Update error code */
      hdma->ErrorCode = HAL_DMA_ERROR_TE;
 8003160:	687b      	ldr	r3, [r7, #4]
 8003162:	2201      	movs	r2, #1
 8003164:	655a      	str	r2, [r3, #84]	; 0x54

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
 8003166:	687b      	ldr	r3, [r7, #4]
 8003168:	2201      	movs	r2, #1
 800316a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 800316e:	687b      	ldr	r3, [r7, #4]
 8003170:	2200      	movs	r2, #0
 8003172:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      if (hdma->XferErrorCallback != NULL)
 8003176:	687b      	ldr	r3, [r7, #4]
 8003178:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800317a:	2b00      	cmp	r3, #0
 800317c:	d009      	beq.n	8003192 <HAL_DMA_IRQHandler+0xe0e>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
 800317e:	687b      	ldr	r3, [r7, #4]
 8003180:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8003182:	6878      	ldr	r0, [r7, #4]
 8003184:	4798      	blx	r3
 8003186:	e004      	b.n	8003192 <HAL_DMA_IRQHandler+0xe0e>
          return;
 8003188:	bf00      	nop
 800318a:	e002      	b.n	8003192 <HAL_DMA_IRQHandler+0xe0e>
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 800318c:	bf00      	nop
 800318e:	e000      	b.n	8003192 <HAL_DMA_IRQHandler+0xe0e>
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 8003190:	bf00      	nop
  }
  else
  {
    /* Nothing To Do */
  }
}
 8003192:	3728      	adds	r7, #40	; 0x28
 8003194:	46bd      	mov	sp, r7
 8003196:	bd80      	pop	{r7, pc}
 8003198:	40020010 	.word	0x40020010
 800319c:	40020028 	.word	0x40020028
 80031a0:	40020040 	.word	0x40020040
 80031a4:	40020058 	.word	0x40020058
 80031a8:	40020070 	.word	0x40020070
 80031ac:	40020088 	.word	0x40020088
 80031b0:	400200a0 	.word	0x400200a0
 80031b4:	400200b8 	.word	0x400200b8
 80031b8:	40020410 	.word	0x40020410
 80031bc:	40020428 	.word	0x40020428
 80031c0:	40020440 	.word	0x40020440
 80031c4:	40020458 	.word	0x40020458
 80031c8:	40020470 	.word	0x40020470
 80031cc:	40020488 	.word	0x40020488
 80031d0:	400204a0 	.word	0x400204a0
 80031d4:	400204b8 	.word	0x400204b8

080031d8 <DMA_SetConfig>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval None
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 80031d8:	b480      	push	{r7}
 80031da:	b087      	sub	sp, #28
 80031dc:	af00      	add	r7, sp, #0
 80031de:	60f8      	str	r0, [r7, #12]
 80031e0:	60b9      	str	r1, [r7, #8]
 80031e2:	607a      	str	r2, [r7, #4]
 80031e4:	603b      	str	r3, [r7, #0]
  /* calculate DMA base and stream number */
  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 80031e6:	68fb      	ldr	r3, [r7, #12]
 80031e8:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80031ea:	617b      	str	r3, [r7, #20]
  BDMA_Base_Registers *regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
 80031ec:	68fb      	ldr	r3, [r7, #12]
 80031ee:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80031f0:	613b      	str	r3, [r7, #16]

  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 80031f2:	68fb      	ldr	r3, [r7, #12]
 80031f4:	681b      	ldr	r3, [r3, #0]
 80031f6:	4a84      	ldr	r2, [pc, #528]	; (8003408 <DMA_SetConfig+0x230>)
 80031f8:	4293      	cmp	r3, r2
 80031fa:	d072      	beq.n	80032e2 <DMA_SetConfig+0x10a>
 80031fc:	68fb      	ldr	r3, [r7, #12]
 80031fe:	681b      	ldr	r3, [r3, #0]
 8003200:	4a82      	ldr	r2, [pc, #520]	; (800340c <DMA_SetConfig+0x234>)
 8003202:	4293      	cmp	r3, r2
 8003204:	d06d      	beq.n	80032e2 <DMA_SetConfig+0x10a>
 8003206:	68fb      	ldr	r3, [r7, #12]
 8003208:	681b      	ldr	r3, [r3, #0]
 800320a:	4a81      	ldr	r2, [pc, #516]	; (8003410 <DMA_SetConfig+0x238>)
 800320c:	4293      	cmp	r3, r2
 800320e:	d068      	beq.n	80032e2 <DMA_SetConfig+0x10a>
 8003210:	68fb      	ldr	r3, [r7, #12]
 8003212:	681b      	ldr	r3, [r3, #0]
 8003214:	4a7f      	ldr	r2, [pc, #508]	; (8003414 <DMA_SetConfig+0x23c>)
 8003216:	4293      	cmp	r3, r2
 8003218:	d063      	beq.n	80032e2 <DMA_SetConfig+0x10a>
 800321a:	68fb      	ldr	r3, [r7, #12]
 800321c:	681b      	ldr	r3, [r3, #0]
 800321e:	4a7e      	ldr	r2, [pc, #504]	; (8003418 <DMA_SetConfig+0x240>)
 8003220:	4293      	cmp	r3, r2
 8003222:	d05e      	beq.n	80032e2 <DMA_SetConfig+0x10a>
 8003224:	68fb      	ldr	r3, [r7, #12]
 8003226:	681b      	ldr	r3, [r3, #0]
 8003228:	4a7c      	ldr	r2, [pc, #496]	; (800341c <DMA_SetConfig+0x244>)
 800322a:	4293      	cmp	r3, r2
 800322c:	d059      	beq.n	80032e2 <DMA_SetConfig+0x10a>
 800322e:	68fb      	ldr	r3, [r7, #12]
 8003230:	681b      	ldr	r3, [r3, #0]
 8003232:	4a7b      	ldr	r2, [pc, #492]	; (8003420 <DMA_SetConfig+0x248>)
 8003234:	4293      	cmp	r3, r2
 8003236:	d054      	beq.n	80032e2 <DMA_SetConfig+0x10a>
 8003238:	68fb      	ldr	r3, [r7, #12]
 800323a:	681b      	ldr	r3, [r3, #0]
 800323c:	4a79      	ldr	r2, [pc, #484]	; (8003424 <DMA_SetConfig+0x24c>)
 800323e:	4293      	cmp	r3, r2
 8003240:	d04f      	beq.n	80032e2 <DMA_SetConfig+0x10a>
 8003242:	68fb      	ldr	r3, [r7, #12]
 8003244:	681b      	ldr	r3, [r3, #0]
 8003246:	4a78      	ldr	r2, [pc, #480]	; (8003428 <DMA_SetConfig+0x250>)
 8003248:	4293      	cmp	r3, r2
 800324a:	d04a      	beq.n	80032e2 <DMA_SetConfig+0x10a>
 800324c:	68fb      	ldr	r3, [r7, #12]
 800324e:	681b      	ldr	r3, [r3, #0]
 8003250:	4a76      	ldr	r2, [pc, #472]	; (800342c <DMA_SetConfig+0x254>)
 8003252:	4293      	cmp	r3, r2
 8003254:	d045      	beq.n	80032e2 <DMA_SetConfig+0x10a>
 8003256:	68fb      	ldr	r3, [r7, #12]
 8003258:	681b      	ldr	r3, [r3, #0]
 800325a:	4a75      	ldr	r2, [pc, #468]	; (8003430 <DMA_SetConfig+0x258>)
 800325c:	4293      	cmp	r3, r2
 800325e:	d040      	beq.n	80032e2 <DMA_SetConfig+0x10a>
 8003260:	68fb      	ldr	r3, [r7, #12]
 8003262:	681b      	ldr	r3, [r3, #0]
 8003264:	4a73      	ldr	r2, [pc, #460]	; (8003434 <DMA_SetConfig+0x25c>)
 8003266:	4293      	cmp	r3, r2
 8003268:	d03b      	beq.n	80032e2 <DMA_SetConfig+0x10a>
 800326a:	68fb      	ldr	r3, [r7, #12]
 800326c:	681b      	ldr	r3, [r3, #0]
 800326e:	4a72      	ldr	r2, [pc, #456]	; (8003438 <DMA_SetConfig+0x260>)
 8003270:	4293      	cmp	r3, r2
 8003272:	d036      	beq.n	80032e2 <DMA_SetConfig+0x10a>
 8003274:	68fb      	ldr	r3, [r7, #12]
 8003276:	681b      	ldr	r3, [r3, #0]
 8003278:	4a70      	ldr	r2, [pc, #448]	; (800343c <DMA_SetConfig+0x264>)
 800327a:	4293      	cmp	r3, r2
 800327c:	d031      	beq.n	80032e2 <DMA_SetConfig+0x10a>
 800327e:	68fb      	ldr	r3, [r7, #12]
 8003280:	681b      	ldr	r3, [r3, #0]
 8003282:	4a6f      	ldr	r2, [pc, #444]	; (8003440 <DMA_SetConfig+0x268>)
 8003284:	4293      	cmp	r3, r2
 8003286:	d02c      	beq.n	80032e2 <DMA_SetConfig+0x10a>
 8003288:	68fb      	ldr	r3, [r7, #12]
 800328a:	681b      	ldr	r3, [r3, #0]
 800328c:	4a6d      	ldr	r2, [pc, #436]	; (8003444 <DMA_SetConfig+0x26c>)
 800328e:	4293      	cmp	r3, r2
 8003290:	d027      	beq.n	80032e2 <DMA_SetConfig+0x10a>
 8003292:	68fb      	ldr	r3, [r7, #12]
 8003294:	681b      	ldr	r3, [r3, #0]
 8003296:	4a6c      	ldr	r2, [pc, #432]	; (8003448 <DMA_SetConfig+0x270>)
 8003298:	4293      	cmp	r3, r2
 800329a:	d022      	beq.n	80032e2 <DMA_SetConfig+0x10a>
 800329c:	68fb      	ldr	r3, [r7, #12]
 800329e:	681b      	ldr	r3, [r3, #0]
 80032a0:	4a6a      	ldr	r2, [pc, #424]	; (800344c <DMA_SetConfig+0x274>)
 80032a2:	4293      	cmp	r3, r2
 80032a4:	d01d      	beq.n	80032e2 <DMA_SetConfig+0x10a>
 80032a6:	68fb      	ldr	r3, [r7, #12]
 80032a8:	681b      	ldr	r3, [r3, #0]
 80032aa:	4a69      	ldr	r2, [pc, #420]	; (8003450 <DMA_SetConfig+0x278>)
 80032ac:	4293      	cmp	r3, r2
 80032ae:	d018      	beq.n	80032e2 <DMA_SetConfig+0x10a>
 80032b0:	68fb      	ldr	r3, [r7, #12]
 80032b2:	681b      	ldr	r3, [r3, #0]
 80032b4:	4a67      	ldr	r2, [pc, #412]	; (8003454 <DMA_SetConfig+0x27c>)
 80032b6:	4293      	cmp	r3, r2
 80032b8:	d013      	beq.n	80032e2 <DMA_SetConfig+0x10a>
 80032ba:	68fb      	ldr	r3, [r7, #12]
 80032bc:	681b      	ldr	r3, [r3, #0]
 80032be:	4a66      	ldr	r2, [pc, #408]	; (8003458 <DMA_SetConfig+0x280>)
 80032c0:	4293      	cmp	r3, r2
 80032c2:	d00e      	beq.n	80032e2 <DMA_SetConfig+0x10a>
 80032c4:	68fb      	ldr	r3, [r7, #12]
 80032c6:	681b      	ldr	r3, [r3, #0]
 80032c8:	4a64      	ldr	r2, [pc, #400]	; (800345c <DMA_SetConfig+0x284>)
 80032ca:	4293      	cmp	r3, r2
 80032cc:	d009      	beq.n	80032e2 <DMA_SetConfig+0x10a>
 80032ce:	68fb      	ldr	r3, [r7, #12]
 80032d0:	681b      	ldr	r3, [r3, #0]
 80032d2:	4a63      	ldr	r2, [pc, #396]	; (8003460 <DMA_SetConfig+0x288>)
 80032d4:	4293      	cmp	r3, r2
 80032d6:	d004      	beq.n	80032e2 <DMA_SetConfig+0x10a>
 80032d8:	68fb      	ldr	r3, [r7, #12]
 80032da:	681b      	ldr	r3, [r3, #0]
 80032dc:	4a61      	ldr	r2, [pc, #388]	; (8003464 <DMA_SetConfig+0x28c>)
 80032de:	4293      	cmp	r3, r2
 80032e0:	d101      	bne.n	80032e6 <DMA_SetConfig+0x10e>
 80032e2:	2301      	movs	r3, #1
 80032e4:	e000      	b.n	80032e8 <DMA_SetConfig+0x110>
 80032e6:	2300      	movs	r3, #0
 80032e8:	2b00      	cmp	r3, #0
 80032ea:	d00d      	beq.n	8003308 <DMA_SetConfig+0x130>
  {
    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 80032ec:	68fb      	ldr	r3, [r7, #12]
 80032ee:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80032f0:	68fa      	ldr	r2, [r7, #12]
 80032f2:	6e92      	ldr	r2, [r2, #104]	; 0x68
 80032f4:	605a      	str	r2, [r3, #4]

    if(hdma->DMAmuxRequestGen != 0U)
 80032f6:	68fb      	ldr	r3, [r7, #12]
 80032f8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80032fa:	2b00      	cmp	r3, #0
 80032fc:	d004      	beq.n	8003308 <DMA_SetConfig+0x130>
    {
      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 80032fe:	68fb      	ldr	r3, [r7, #12]
 8003300:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8003302:	68fa      	ldr	r2, [r7, #12]
 8003304:	6f52      	ldr	r2, [r2, #116]	; 0x74
 8003306:	605a      	str	r2, [r3, #4]
    }
  }

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8003308:	68fb      	ldr	r3, [r7, #12]
 800330a:	681b      	ldr	r3, [r3, #0]
 800330c:	4a3e      	ldr	r2, [pc, #248]	; (8003408 <DMA_SetConfig+0x230>)
 800330e:	4293      	cmp	r3, r2
 8003310:	d04a      	beq.n	80033a8 <DMA_SetConfig+0x1d0>
 8003312:	68fb      	ldr	r3, [r7, #12]
 8003314:	681b      	ldr	r3, [r3, #0]
 8003316:	4a3d      	ldr	r2, [pc, #244]	; (800340c <DMA_SetConfig+0x234>)
 8003318:	4293      	cmp	r3, r2
 800331a:	d045      	beq.n	80033a8 <DMA_SetConfig+0x1d0>
 800331c:	68fb      	ldr	r3, [r7, #12]
 800331e:	681b      	ldr	r3, [r3, #0]
 8003320:	4a3b      	ldr	r2, [pc, #236]	; (8003410 <DMA_SetConfig+0x238>)
 8003322:	4293      	cmp	r3, r2
 8003324:	d040      	beq.n	80033a8 <DMA_SetConfig+0x1d0>
 8003326:	68fb      	ldr	r3, [r7, #12]
 8003328:	681b      	ldr	r3, [r3, #0]
 800332a:	4a3a      	ldr	r2, [pc, #232]	; (8003414 <DMA_SetConfig+0x23c>)
 800332c:	4293      	cmp	r3, r2
 800332e:	d03b      	beq.n	80033a8 <DMA_SetConfig+0x1d0>
 8003330:	68fb      	ldr	r3, [r7, #12]
 8003332:	681b      	ldr	r3, [r3, #0]
 8003334:	4a38      	ldr	r2, [pc, #224]	; (8003418 <DMA_SetConfig+0x240>)
 8003336:	4293      	cmp	r3, r2
 8003338:	d036      	beq.n	80033a8 <DMA_SetConfig+0x1d0>
 800333a:	68fb      	ldr	r3, [r7, #12]
 800333c:	681b      	ldr	r3, [r3, #0]
 800333e:	4a37      	ldr	r2, [pc, #220]	; (800341c <DMA_SetConfig+0x244>)
 8003340:	4293      	cmp	r3, r2
 8003342:	d031      	beq.n	80033a8 <DMA_SetConfig+0x1d0>
 8003344:	68fb      	ldr	r3, [r7, #12]
 8003346:	681b      	ldr	r3, [r3, #0]
 8003348:	4a35      	ldr	r2, [pc, #212]	; (8003420 <DMA_SetConfig+0x248>)
 800334a:	4293      	cmp	r3, r2
 800334c:	d02c      	beq.n	80033a8 <DMA_SetConfig+0x1d0>
 800334e:	68fb      	ldr	r3, [r7, #12]
 8003350:	681b      	ldr	r3, [r3, #0]
 8003352:	4a34      	ldr	r2, [pc, #208]	; (8003424 <DMA_SetConfig+0x24c>)
 8003354:	4293      	cmp	r3, r2
 8003356:	d027      	beq.n	80033a8 <DMA_SetConfig+0x1d0>
 8003358:	68fb      	ldr	r3, [r7, #12]
 800335a:	681b      	ldr	r3, [r3, #0]
 800335c:	4a32      	ldr	r2, [pc, #200]	; (8003428 <DMA_SetConfig+0x250>)
 800335e:	4293      	cmp	r3, r2
 8003360:	d022      	beq.n	80033a8 <DMA_SetConfig+0x1d0>
 8003362:	68fb      	ldr	r3, [r7, #12]
 8003364:	681b      	ldr	r3, [r3, #0]
 8003366:	4a31      	ldr	r2, [pc, #196]	; (800342c <DMA_SetConfig+0x254>)
 8003368:	4293      	cmp	r3, r2
 800336a:	d01d      	beq.n	80033a8 <DMA_SetConfig+0x1d0>
 800336c:	68fb      	ldr	r3, [r7, #12]
 800336e:	681b      	ldr	r3, [r3, #0]
 8003370:	4a2f      	ldr	r2, [pc, #188]	; (8003430 <DMA_SetConfig+0x258>)
 8003372:	4293      	cmp	r3, r2
 8003374:	d018      	beq.n	80033a8 <DMA_SetConfig+0x1d0>
 8003376:	68fb      	ldr	r3, [r7, #12]
 8003378:	681b      	ldr	r3, [r3, #0]
 800337a:	4a2e      	ldr	r2, [pc, #184]	; (8003434 <DMA_SetConfig+0x25c>)
 800337c:	4293      	cmp	r3, r2
 800337e:	d013      	beq.n	80033a8 <DMA_SetConfig+0x1d0>
 8003380:	68fb      	ldr	r3, [r7, #12]
 8003382:	681b      	ldr	r3, [r3, #0]
 8003384:	4a2c      	ldr	r2, [pc, #176]	; (8003438 <DMA_SetConfig+0x260>)
 8003386:	4293      	cmp	r3, r2
 8003388:	d00e      	beq.n	80033a8 <DMA_SetConfig+0x1d0>
 800338a:	68fb      	ldr	r3, [r7, #12]
 800338c:	681b      	ldr	r3, [r3, #0]
 800338e:	4a2b      	ldr	r2, [pc, #172]	; (800343c <DMA_SetConfig+0x264>)
 8003390:	4293      	cmp	r3, r2
 8003392:	d009      	beq.n	80033a8 <DMA_SetConfig+0x1d0>
 8003394:	68fb      	ldr	r3, [r7, #12]
 8003396:	681b      	ldr	r3, [r3, #0]
 8003398:	4a29      	ldr	r2, [pc, #164]	; (8003440 <DMA_SetConfig+0x268>)
 800339a:	4293      	cmp	r3, r2
 800339c:	d004      	beq.n	80033a8 <DMA_SetConfig+0x1d0>
 800339e:	68fb      	ldr	r3, [r7, #12]
 80033a0:	681b      	ldr	r3, [r3, #0]
 80033a2:	4a28      	ldr	r2, [pc, #160]	; (8003444 <DMA_SetConfig+0x26c>)
 80033a4:	4293      	cmp	r3, r2
 80033a6:	d101      	bne.n	80033ac <DMA_SetConfig+0x1d4>
 80033a8:	2301      	movs	r3, #1
 80033aa:	e000      	b.n	80033ae <DMA_SetConfig+0x1d6>
 80033ac:	2300      	movs	r3, #0
 80033ae:	2b00      	cmp	r3, #0
 80033b0:	d05a      	beq.n	8003468 <DMA_SetConfig+0x290>
  {
    /* Clear all interrupt flags at correct offset within the register */
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
 80033b2:	68fb      	ldr	r3, [r7, #12]
 80033b4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80033b6:	f003 031f 	and.w	r3, r3, #31
 80033ba:	223f      	movs	r2, #63	; 0x3f
 80033bc:	409a      	lsls	r2, r3
 80033be:	697b      	ldr	r3, [r7, #20]
 80033c0:	609a      	str	r2, [r3, #8]

    /* Clear DBM bit */
    ((DMA_Stream_TypeDef *)hdma->Instance)->CR &= (uint32_t)(~DMA_SxCR_DBM);
 80033c2:	68fb      	ldr	r3, [r7, #12]
 80033c4:	681b      	ldr	r3, [r3, #0]
 80033c6:	681a      	ldr	r2, [r3, #0]
 80033c8:	68fb      	ldr	r3, [r7, #12]
 80033ca:	681b      	ldr	r3, [r3, #0]
 80033cc:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80033d0:	601a      	str	r2, [r3, #0]

    /* Configure DMA Stream data length */
    ((DMA_Stream_TypeDef *)hdma->Instance)->NDTR = DataLength;
 80033d2:	68fb      	ldr	r3, [r7, #12]
 80033d4:	681b      	ldr	r3, [r3, #0]
 80033d6:	683a      	ldr	r2, [r7, #0]
 80033d8:	605a      	str	r2, [r3, #4]

    /* Peripheral to Memory */
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 80033da:	68fb      	ldr	r3, [r7, #12]
 80033dc:	689b      	ldr	r3, [r3, #8]
 80033de:	2b40      	cmp	r3, #64	; 0x40
 80033e0:	d108      	bne.n	80033f4 <DMA_SetConfig+0x21c>
    {
      /* Configure DMA Stream destination address */
      ((DMA_Stream_TypeDef *)hdma->Instance)->PAR = DstAddress;
 80033e2:	68fb      	ldr	r3, [r7, #12]
 80033e4:	681b      	ldr	r3, [r3, #0]
 80033e6:	687a      	ldr	r2, [r7, #4]
 80033e8:	609a      	str	r2, [r3, #8]

      /* Configure DMA Stream source address */
      ((DMA_Stream_TypeDef *)hdma->Instance)->M0AR = SrcAddress;
 80033ea:	68fb      	ldr	r3, [r7, #12]
 80033ec:	681b      	ldr	r3, [r3, #0]
 80033ee:	68ba      	ldr	r2, [r7, #8]
 80033f0:	60da      	str	r2, [r3, #12]
  }
  else
  {
    /* Nothing To Do */
  }
}
 80033f2:	e087      	b.n	8003504 <DMA_SetConfig+0x32c>
      ((DMA_Stream_TypeDef *)hdma->Instance)->PAR = SrcAddress;
 80033f4:	68fb      	ldr	r3, [r7, #12]
 80033f6:	681b      	ldr	r3, [r3, #0]
 80033f8:	68ba      	ldr	r2, [r7, #8]
 80033fa:	609a      	str	r2, [r3, #8]
      ((DMA_Stream_TypeDef *)hdma->Instance)->M0AR = DstAddress;
 80033fc:	68fb      	ldr	r3, [r7, #12]
 80033fe:	681b      	ldr	r3, [r3, #0]
 8003400:	687a      	ldr	r2, [r7, #4]
 8003402:	60da      	str	r2, [r3, #12]
}
 8003404:	e07e      	b.n	8003504 <DMA_SetConfig+0x32c>
 8003406:	bf00      	nop
 8003408:	40020010 	.word	0x40020010
 800340c:	40020028 	.word	0x40020028
 8003410:	40020040 	.word	0x40020040
 8003414:	40020058 	.word	0x40020058
 8003418:	40020070 	.word	0x40020070
 800341c:	40020088 	.word	0x40020088
 8003420:	400200a0 	.word	0x400200a0
 8003424:	400200b8 	.word	0x400200b8
 8003428:	40020410 	.word	0x40020410
 800342c:	40020428 	.word	0x40020428
 8003430:	40020440 	.word	0x40020440
 8003434:	40020458 	.word	0x40020458
 8003438:	40020470 	.word	0x40020470
 800343c:	40020488 	.word	0x40020488
 8003440:	400204a0 	.word	0x400204a0
 8003444:	400204b8 	.word	0x400204b8
 8003448:	58025408 	.word	0x58025408
 800344c:	5802541c 	.word	0x5802541c
 8003450:	58025430 	.word	0x58025430
 8003454:	58025444 	.word	0x58025444
 8003458:	58025458 	.word	0x58025458
 800345c:	5802546c 	.word	0x5802546c
 8003460:	58025480 	.word	0x58025480
 8003464:	58025494 	.word	0x58025494
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
 8003468:	68fb      	ldr	r3, [r7, #12]
 800346a:	681b      	ldr	r3, [r3, #0]
 800346c:	4a28      	ldr	r2, [pc, #160]	; (8003510 <DMA_SetConfig+0x338>)
 800346e:	4293      	cmp	r3, r2
 8003470:	d022      	beq.n	80034b8 <DMA_SetConfig+0x2e0>
 8003472:	68fb      	ldr	r3, [r7, #12]
 8003474:	681b      	ldr	r3, [r3, #0]
 8003476:	4a27      	ldr	r2, [pc, #156]	; (8003514 <DMA_SetConfig+0x33c>)
 8003478:	4293      	cmp	r3, r2
 800347a:	d01d      	beq.n	80034b8 <DMA_SetConfig+0x2e0>
 800347c:	68fb      	ldr	r3, [r7, #12]
 800347e:	681b      	ldr	r3, [r3, #0]
 8003480:	4a25      	ldr	r2, [pc, #148]	; (8003518 <DMA_SetConfig+0x340>)
 8003482:	4293      	cmp	r3, r2
 8003484:	d018      	beq.n	80034b8 <DMA_SetConfig+0x2e0>
 8003486:	68fb      	ldr	r3, [r7, #12]
 8003488:	681b      	ldr	r3, [r3, #0]
 800348a:	4a24      	ldr	r2, [pc, #144]	; (800351c <DMA_SetConfig+0x344>)
 800348c:	4293      	cmp	r3, r2
 800348e:	d013      	beq.n	80034b8 <DMA_SetConfig+0x2e0>
 8003490:	68fb      	ldr	r3, [r7, #12]
 8003492:	681b      	ldr	r3, [r3, #0]
 8003494:	4a22      	ldr	r2, [pc, #136]	; (8003520 <DMA_SetConfig+0x348>)
 8003496:	4293      	cmp	r3, r2
 8003498:	d00e      	beq.n	80034b8 <DMA_SetConfig+0x2e0>
 800349a:	68fb      	ldr	r3, [r7, #12]
 800349c:	681b      	ldr	r3, [r3, #0]
 800349e:	4a21      	ldr	r2, [pc, #132]	; (8003524 <DMA_SetConfig+0x34c>)
 80034a0:	4293      	cmp	r3, r2
 80034a2:	d009      	beq.n	80034b8 <DMA_SetConfig+0x2e0>
 80034a4:	68fb      	ldr	r3, [r7, #12]
 80034a6:	681b      	ldr	r3, [r3, #0]
 80034a8:	4a1f      	ldr	r2, [pc, #124]	; (8003528 <DMA_SetConfig+0x350>)
 80034aa:	4293      	cmp	r3, r2
 80034ac:	d004      	beq.n	80034b8 <DMA_SetConfig+0x2e0>
 80034ae:	68fb      	ldr	r3, [r7, #12]
 80034b0:	681b      	ldr	r3, [r3, #0]
 80034b2:	4a1e      	ldr	r2, [pc, #120]	; (800352c <DMA_SetConfig+0x354>)
 80034b4:	4293      	cmp	r3, r2
 80034b6:	d101      	bne.n	80034bc <DMA_SetConfig+0x2e4>
 80034b8:	2301      	movs	r3, #1
 80034ba:	e000      	b.n	80034be <DMA_SetConfig+0x2e6>
 80034bc:	2300      	movs	r3, #0
 80034be:	2b00      	cmp	r3, #0
 80034c0:	d020      	beq.n	8003504 <DMA_SetConfig+0x32c>
    regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
 80034c2:	68fb      	ldr	r3, [r7, #12]
 80034c4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80034c6:	f003 031f 	and.w	r3, r3, #31
 80034ca:	2201      	movs	r2, #1
 80034cc:	409a      	lsls	r2, r3
 80034ce:	693b      	ldr	r3, [r7, #16]
 80034d0:	605a      	str	r2, [r3, #4]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = DataLength;
 80034d2:	68fb      	ldr	r3, [r7, #12]
 80034d4:	681b      	ldr	r3, [r3, #0]
 80034d6:	683a      	ldr	r2, [r7, #0]
 80034d8:	605a      	str	r2, [r3, #4]
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 80034da:	68fb      	ldr	r3, [r7, #12]
 80034dc:	689b      	ldr	r3, [r3, #8]
 80034de:	2b40      	cmp	r3, #64	; 0x40
 80034e0:	d108      	bne.n	80034f4 <DMA_SetConfig+0x31c>
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = DstAddress;
 80034e2:	68fb      	ldr	r3, [r7, #12]
 80034e4:	681b      	ldr	r3, [r3, #0]
 80034e6:	687a      	ldr	r2, [r7, #4]
 80034e8:	609a      	str	r2, [r3, #8]
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = SrcAddress;
 80034ea:	68fb      	ldr	r3, [r7, #12]
 80034ec:	681b      	ldr	r3, [r3, #0]
 80034ee:	68ba      	ldr	r2, [r7, #8]
 80034f0:	60da      	str	r2, [r3, #12]
}
 80034f2:	e007      	b.n	8003504 <DMA_SetConfig+0x32c>
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = SrcAddress;
 80034f4:	68fb      	ldr	r3, [r7, #12]
 80034f6:	681b      	ldr	r3, [r3, #0]
 80034f8:	68ba      	ldr	r2, [r7, #8]
 80034fa:	609a      	str	r2, [r3, #8]
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = DstAddress;
 80034fc:	68fb      	ldr	r3, [r7, #12]
 80034fe:	681b      	ldr	r3, [r3, #0]
 8003500:	687a      	ldr	r2, [r7, #4]
 8003502:	60da      	str	r2, [r3, #12]
}
 8003504:	bf00      	nop
 8003506:	371c      	adds	r7, #28
 8003508:	46bd      	mov	sp, r7
 800350a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800350e:	4770      	bx	lr
 8003510:	58025408 	.word	0x58025408
 8003514:	5802541c 	.word	0x5802541c
 8003518:	58025430 	.word	0x58025430
 800351c:	58025444 	.word	0x58025444
 8003520:	58025458 	.word	0x58025458
 8003524:	5802546c 	.word	0x5802546c
 8003528:	58025480 	.word	0x58025480
 800352c:	58025494 	.word	0x58025494

08003530 <DMA_CalcBaseAndBitshift>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
 8003530:	b480      	push	{r7}
 8003532:	b085      	sub	sp, #20
 8003534:	af00      	add	r7, sp, #0
 8003536:	6078      	str	r0, [r7, #4]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8003538:	687b      	ldr	r3, [r7, #4]
 800353a:	681b      	ldr	r3, [r3, #0]
 800353c:	4a42      	ldr	r2, [pc, #264]	; (8003648 <DMA_CalcBaseAndBitshift+0x118>)
 800353e:	4293      	cmp	r3, r2
 8003540:	d04a      	beq.n	80035d8 <DMA_CalcBaseAndBitshift+0xa8>
 8003542:	687b      	ldr	r3, [r7, #4]
 8003544:	681b      	ldr	r3, [r3, #0]
 8003546:	4a41      	ldr	r2, [pc, #260]	; (800364c <DMA_CalcBaseAndBitshift+0x11c>)
 8003548:	4293      	cmp	r3, r2
 800354a:	d045      	beq.n	80035d8 <DMA_CalcBaseAndBitshift+0xa8>
 800354c:	687b      	ldr	r3, [r7, #4]
 800354e:	681b      	ldr	r3, [r3, #0]
 8003550:	4a3f      	ldr	r2, [pc, #252]	; (8003650 <DMA_CalcBaseAndBitshift+0x120>)
 8003552:	4293      	cmp	r3, r2
 8003554:	d040      	beq.n	80035d8 <DMA_CalcBaseAndBitshift+0xa8>
 8003556:	687b      	ldr	r3, [r7, #4]
 8003558:	681b      	ldr	r3, [r3, #0]
 800355a:	4a3e      	ldr	r2, [pc, #248]	; (8003654 <DMA_CalcBaseAndBitshift+0x124>)
 800355c:	4293      	cmp	r3, r2
 800355e:	d03b      	beq.n	80035d8 <DMA_CalcBaseAndBitshift+0xa8>
 8003560:	687b      	ldr	r3, [r7, #4]
 8003562:	681b      	ldr	r3, [r3, #0]
 8003564:	4a3c      	ldr	r2, [pc, #240]	; (8003658 <DMA_CalcBaseAndBitshift+0x128>)
 8003566:	4293      	cmp	r3, r2
 8003568:	d036      	beq.n	80035d8 <DMA_CalcBaseAndBitshift+0xa8>
 800356a:	687b      	ldr	r3, [r7, #4]
 800356c:	681b      	ldr	r3, [r3, #0]
 800356e:	4a3b      	ldr	r2, [pc, #236]	; (800365c <DMA_CalcBaseAndBitshift+0x12c>)
 8003570:	4293      	cmp	r3, r2
 8003572:	d031      	beq.n	80035d8 <DMA_CalcBaseAndBitshift+0xa8>
 8003574:	687b      	ldr	r3, [r7, #4]
 8003576:	681b      	ldr	r3, [r3, #0]
 8003578:	4a39      	ldr	r2, [pc, #228]	; (8003660 <DMA_CalcBaseAndBitshift+0x130>)
 800357a:	4293      	cmp	r3, r2
 800357c:	d02c      	beq.n	80035d8 <DMA_CalcBaseAndBitshift+0xa8>
 800357e:	687b      	ldr	r3, [r7, #4]
 8003580:	681b      	ldr	r3, [r3, #0]
 8003582:	4a38      	ldr	r2, [pc, #224]	; (8003664 <DMA_CalcBaseAndBitshift+0x134>)
 8003584:	4293      	cmp	r3, r2
 8003586:	d027      	beq.n	80035d8 <DMA_CalcBaseAndBitshift+0xa8>
 8003588:	687b      	ldr	r3, [r7, #4]
 800358a:	681b      	ldr	r3, [r3, #0]
 800358c:	4a36      	ldr	r2, [pc, #216]	; (8003668 <DMA_CalcBaseAndBitshift+0x138>)
 800358e:	4293      	cmp	r3, r2
 8003590:	d022      	beq.n	80035d8 <DMA_CalcBaseAndBitshift+0xa8>
 8003592:	687b      	ldr	r3, [r7, #4]
 8003594:	681b      	ldr	r3, [r3, #0]
 8003596:	4a35      	ldr	r2, [pc, #212]	; (800366c <DMA_CalcBaseAndBitshift+0x13c>)
 8003598:	4293      	cmp	r3, r2
 800359a:	d01d      	beq.n	80035d8 <DMA_CalcBaseAndBitshift+0xa8>
 800359c:	687b      	ldr	r3, [r7, #4]
 800359e:	681b      	ldr	r3, [r3, #0]
 80035a0:	4a33      	ldr	r2, [pc, #204]	; (8003670 <DMA_CalcBaseAndBitshift+0x140>)
 80035a2:	4293      	cmp	r3, r2
 80035a4:	d018      	beq.n	80035d8 <DMA_CalcBaseAndBitshift+0xa8>
 80035a6:	687b      	ldr	r3, [r7, #4]
 80035a8:	681b      	ldr	r3, [r3, #0]
 80035aa:	4a32      	ldr	r2, [pc, #200]	; (8003674 <DMA_CalcBaseAndBitshift+0x144>)
 80035ac:	4293      	cmp	r3, r2
 80035ae:	d013      	beq.n	80035d8 <DMA_CalcBaseAndBitshift+0xa8>
 80035b0:	687b      	ldr	r3, [r7, #4]
 80035b2:	681b      	ldr	r3, [r3, #0]
 80035b4:	4a30      	ldr	r2, [pc, #192]	; (8003678 <DMA_CalcBaseAndBitshift+0x148>)
 80035b6:	4293      	cmp	r3, r2
 80035b8:	d00e      	beq.n	80035d8 <DMA_CalcBaseAndBitshift+0xa8>
 80035ba:	687b      	ldr	r3, [r7, #4]
 80035bc:	681b      	ldr	r3, [r3, #0]
 80035be:	4a2f      	ldr	r2, [pc, #188]	; (800367c <DMA_CalcBaseAndBitshift+0x14c>)
 80035c0:	4293      	cmp	r3, r2
 80035c2:	d009      	beq.n	80035d8 <DMA_CalcBaseAndBitshift+0xa8>
 80035c4:	687b      	ldr	r3, [r7, #4]
 80035c6:	681b      	ldr	r3, [r3, #0]
 80035c8:	4a2d      	ldr	r2, [pc, #180]	; (8003680 <DMA_CalcBaseAndBitshift+0x150>)
 80035ca:	4293      	cmp	r3, r2
 80035cc:	d004      	beq.n	80035d8 <DMA_CalcBaseAndBitshift+0xa8>
 80035ce:	687b      	ldr	r3, [r7, #4]
 80035d0:	681b      	ldr	r3, [r3, #0]
 80035d2:	4a2c      	ldr	r2, [pc, #176]	; (8003684 <DMA_CalcBaseAndBitshift+0x154>)
 80035d4:	4293      	cmp	r3, r2
 80035d6:	d101      	bne.n	80035dc <DMA_CalcBaseAndBitshift+0xac>
 80035d8:	2301      	movs	r3, #1
 80035da:	e000      	b.n	80035de <DMA_CalcBaseAndBitshift+0xae>
 80035dc:	2300      	movs	r3, #0
 80035de:	2b00      	cmp	r3, #0
 80035e0:	d024      	beq.n	800362c <DMA_CalcBaseAndBitshift+0xfc>
  {
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 80035e2:	687b      	ldr	r3, [r7, #4]
 80035e4:	681b      	ldr	r3, [r3, #0]
 80035e6:	b2db      	uxtb	r3, r3
 80035e8:	3b10      	subs	r3, #16
 80035ea:	4a27      	ldr	r2, [pc, #156]	; (8003688 <DMA_CalcBaseAndBitshift+0x158>)
 80035ec:	fba2 2303 	umull	r2, r3, r2, r3
 80035f0:	091b      	lsrs	r3, r3, #4
 80035f2:	60fb      	str	r3, [r7, #12]

    /* lookup table for necessary bitshift of flags within status registers */
    static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
 80035f4:	68fb      	ldr	r3, [r7, #12]
 80035f6:	f003 0307 	and.w	r3, r3, #7
 80035fa:	4a24      	ldr	r2, [pc, #144]	; (800368c <DMA_CalcBaseAndBitshift+0x15c>)
 80035fc:	5cd3      	ldrb	r3, [r2, r3]
 80035fe:	461a      	mov	r2, r3
 8003600:	687b      	ldr	r3, [r7, #4]
 8003602:	65da      	str	r2, [r3, #92]	; 0x5c

    if (stream_number > 3U)
 8003604:	68fb      	ldr	r3, [r7, #12]
 8003606:	2b03      	cmp	r3, #3
 8003608:	d908      	bls.n	800361c <DMA_CalcBaseAndBitshift+0xec>
    {
      /* return pointer to HISR and HIFCR */
      hdma->StreamBaseAddress = (((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU)) + 4U);
 800360a:	687b      	ldr	r3, [r7, #4]
 800360c:	681b      	ldr	r3, [r3, #0]
 800360e:	461a      	mov	r2, r3
 8003610:	4b1f      	ldr	r3, [pc, #124]	; (8003690 <DMA_CalcBaseAndBitshift+0x160>)
 8003612:	4013      	ands	r3, r2
 8003614:	1d1a      	adds	r2, r3, #4
 8003616:	687b      	ldr	r3, [r7, #4]
 8003618:	659a      	str	r2, [r3, #88]	; 0x58
 800361a:	e00d      	b.n	8003638 <DMA_CalcBaseAndBitshift+0x108>
    }
    else
    {
      /* return pointer to LISR and LIFCR */
      hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU));
 800361c:	687b      	ldr	r3, [r7, #4]
 800361e:	681b      	ldr	r3, [r3, #0]
 8003620:	461a      	mov	r2, r3
 8003622:	4b1b      	ldr	r3, [pc, #108]	; (8003690 <DMA_CalcBaseAndBitshift+0x160>)
 8003624:	4013      	ands	r3, r2
 8003626:	687a      	ldr	r2, [r7, #4]
 8003628:	6593      	str	r3, [r2, #88]	; 0x58
 800362a:	e005      	b.n	8003638 <DMA_CalcBaseAndBitshift+0x108>
    }
  }
  else /* BDMA instance(s) */
  {
    /* return pointer to ISR and IFCR */
    hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0xFFU));
 800362c:	687b      	ldr	r3, [r7, #4]
 800362e:	681b      	ldr	r3, [r3, #0]
 8003630:	f023 02ff 	bic.w	r2, r3, #255	; 0xff
 8003634:	687b      	ldr	r3, [r7, #4]
 8003636:	659a      	str	r2, [r3, #88]	; 0x58
  }

  return hdma->StreamBaseAddress;
 8003638:	687b      	ldr	r3, [r7, #4]
 800363a:	6d9b      	ldr	r3, [r3, #88]	; 0x58
}
 800363c:	4618      	mov	r0, r3
 800363e:	3714      	adds	r7, #20
 8003640:	46bd      	mov	sp, r7
 8003642:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003646:	4770      	bx	lr
 8003648:	40020010 	.word	0x40020010
 800364c:	40020028 	.word	0x40020028
 8003650:	40020040 	.word	0x40020040
 8003654:	40020058 	.word	0x40020058
 8003658:	40020070 	.word	0x40020070
 800365c:	40020088 	.word	0x40020088
 8003660:	400200a0 	.word	0x400200a0
 8003664:	400200b8 	.word	0x400200b8
 8003668:	40020410 	.word	0x40020410
 800366c:	40020428 	.word	0x40020428
 8003670:	40020440 	.word	0x40020440
 8003674:	40020458 	.word	0x40020458
 8003678:	40020470 	.word	0x40020470
 800367c:	40020488 	.word	0x40020488
 8003680:	400204a0 	.word	0x400204a0
 8003684:	400204b8 	.word	0x400204b8
 8003688:	aaaaaaab 	.word	0xaaaaaaab
 800368c:	08022944 	.word	0x08022944
 8003690:	fffffc00 	.word	0xfffffc00

08003694 <DMA_CheckFifoParam>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
{
 8003694:	b480      	push	{r7}
 8003696:	b085      	sub	sp, #20
 8003698:	af00      	add	r7, sp, #0
 800369a:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 800369c:	2300      	movs	r3, #0
 800369e:	73fb      	strb	r3, [r7, #15]

  /* Memory Data size equal to Byte */
  if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
 80036a0:	687b      	ldr	r3, [r7, #4]
 80036a2:	699b      	ldr	r3, [r3, #24]
 80036a4:	2b00      	cmp	r3, #0
 80036a6:	d120      	bne.n	80036ea <DMA_CheckFifoParam+0x56>
  {
    switch (hdma->Init.FIFOThreshold)
 80036a8:	687b      	ldr	r3, [r7, #4]
 80036aa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80036ac:	2b03      	cmp	r3, #3
 80036ae:	d858      	bhi.n	8003762 <DMA_CheckFifoParam+0xce>
 80036b0:	a201      	add	r2, pc, #4	; (adr r2, 80036b8 <DMA_CheckFifoParam+0x24>)
 80036b2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80036b6:	bf00      	nop
 80036b8:	080036c9 	.word	0x080036c9
 80036bc:	080036db 	.word	0x080036db
 80036c0:	080036c9 	.word	0x080036c9
 80036c4:	08003763 	.word	0x08003763
    {
      case DMA_FIFO_THRESHOLD_1QUARTERFULL:
      case DMA_FIFO_THRESHOLD_3QUARTERSFULL:

        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 80036c8:	687b      	ldr	r3, [r7, #4]
 80036ca:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80036cc:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 80036d0:	2b00      	cmp	r3, #0
 80036d2:	d048      	beq.n	8003766 <DMA_CheckFifoParam+0xd2>
        {
          status = HAL_ERROR;
 80036d4:	2301      	movs	r3, #1
 80036d6:	73fb      	strb	r3, [r7, #15]
        }
        break;
 80036d8:	e045      	b.n	8003766 <DMA_CheckFifoParam+0xd2>

      case DMA_FIFO_THRESHOLD_HALFFULL:
        if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 80036da:	687b      	ldr	r3, [r7, #4]
 80036dc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80036de:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
 80036e2:	d142      	bne.n	800376a <DMA_CheckFifoParam+0xd6>
        {
          status = HAL_ERROR;
 80036e4:	2301      	movs	r3, #1
 80036e6:	73fb      	strb	r3, [r7, #15]
        }
        break;
 80036e8:	e03f      	b.n	800376a <DMA_CheckFifoParam+0xd6>
        break;
    }
  }

  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 80036ea:	687b      	ldr	r3, [r7, #4]
 80036ec:	699b      	ldr	r3, [r3, #24]
 80036ee:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 80036f2:	d123      	bne.n	800373c <DMA_CheckFifoParam+0xa8>
  {
    switch (hdma->Init.FIFOThreshold)
 80036f4:	687b      	ldr	r3, [r7, #4]
 80036f6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80036f8:	2b03      	cmp	r3, #3
 80036fa:	d838      	bhi.n	800376e <DMA_CheckFifoParam+0xda>
 80036fc:	a201      	add	r2, pc, #4	; (adr r2, 8003704 <DMA_CheckFifoParam+0x70>)
 80036fe:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8003702:	bf00      	nop
 8003704:	08003715 	.word	0x08003715
 8003708:	0800371b 	.word	0x0800371b
 800370c:	08003715 	.word	0x08003715
 8003710:	0800372d 	.word	0x0800372d
    {
      case DMA_FIFO_THRESHOLD_1QUARTERFULL:
      case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
        status = HAL_ERROR;
 8003714:	2301      	movs	r3, #1
 8003716:	73fb      	strb	r3, [r7, #15]
        break;
 8003718:	e030      	b.n	800377c <DMA_CheckFifoParam+0xe8>

      case DMA_FIFO_THRESHOLD_HALFFULL:
        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 800371a:	687b      	ldr	r3, [r7, #4]
 800371c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800371e:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 8003722:	2b00      	cmp	r3, #0
 8003724:	d025      	beq.n	8003772 <DMA_CheckFifoParam+0xde>
        {
          status = HAL_ERROR;
 8003726:	2301      	movs	r3, #1
 8003728:	73fb      	strb	r3, [r7, #15]
        }
        break;
 800372a:	e022      	b.n	8003772 <DMA_CheckFifoParam+0xde>

      case DMA_FIFO_THRESHOLD_FULL:
        if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 800372c:	687b      	ldr	r3, [r7, #4]
 800372e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003730:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
 8003734:	d11f      	bne.n	8003776 <DMA_CheckFifoParam+0xe2>
        {
          status = HAL_ERROR;
 8003736:	2301      	movs	r3, #1
 8003738:	73fb      	strb	r3, [r7, #15]
        }
        break;
 800373a:	e01c      	b.n	8003776 <DMA_CheckFifoParam+0xe2>
  }

  /* Memory Data size equal to Word */
  else
  {
    switch (hdma->Init.FIFOThreshold)
 800373c:	687b      	ldr	r3, [r7, #4]
 800373e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003740:	2b02      	cmp	r3, #2
 8003742:	d902      	bls.n	800374a <DMA_CheckFifoParam+0xb6>
 8003744:	2b03      	cmp	r3, #3
 8003746:	d003      	beq.n	8003750 <DMA_CheckFifoParam+0xbc>
          status = HAL_ERROR;
        }
    break;

      default:
        break;
 8003748:	e018      	b.n	800377c <DMA_CheckFifoParam+0xe8>
        status = HAL_ERROR;
 800374a:	2301      	movs	r3, #1
 800374c:	73fb      	strb	r3, [r7, #15]
        break;
 800374e:	e015      	b.n	800377c <DMA_CheckFifoParam+0xe8>
        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 8003750:	687b      	ldr	r3, [r7, #4]
 8003752:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003754:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 8003758:	2b00      	cmp	r3, #0
 800375a:	d00e      	beq.n	800377a <DMA_CheckFifoParam+0xe6>
          status = HAL_ERROR;
 800375c:	2301      	movs	r3, #1
 800375e:	73fb      	strb	r3, [r7, #15]
    break;
 8003760:	e00b      	b.n	800377a <DMA_CheckFifoParam+0xe6>
        break;
 8003762:	bf00      	nop
 8003764:	e00a      	b.n	800377c <DMA_CheckFifoParam+0xe8>
        break;
 8003766:	bf00      	nop
 8003768:	e008      	b.n	800377c <DMA_CheckFifoParam+0xe8>
        break;
 800376a:	bf00      	nop
 800376c:	e006      	b.n	800377c <DMA_CheckFifoParam+0xe8>
        break;
 800376e:	bf00      	nop
 8003770:	e004      	b.n	800377c <DMA_CheckFifoParam+0xe8>
        break;
 8003772:	bf00      	nop
 8003774:	e002      	b.n	800377c <DMA_CheckFifoParam+0xe8>
        break;
 8003776:	bf00      	nop
 8003778:	e000      	b.n	800377c <DMA_CheckFifoParam+0xe8>
    break;
 800377a:	bf00      	nop
    }
  }

  return status;
 800377c:	7bfb      	ldrb	r3, [r7, #15]
}
 800377e:	4618      	mov	r0, r3
 8003780:	3714      	adds	r7, #20
 8003782:	46bd      	mov	sp, r7
 8003784:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003788:	4770      	bx	lr
 800378a:	bf00      	nop

0800378c <DMA_CalcDMAMUXChannelBaseAndMask>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
static void DMA_CalcDMAMUXChannelBaseAndMask(DMA_HandleTypeDef *hdma)
{
 800378c:	b480      	push	{r7}
 800378e:	b085      	sub	sp, #20
 8003790:	af00      	add	r7, sp, #0
 8003792:	6078      	str	r0, [r7, #4]
  uint32_t stream_number;
  uint32_t stream_baseaddress = (uint32_t)((uint32_t*)hdma->Instance);
 8003794:	687b      	ldr	r3, [r7, #4]
 8003796:	681b      	ldr	r3, [r3, #0]
 8003798:	60bb      	str	r3, [r7, #8]

  if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
 800379a:	687b      	ldr	r3, [r7, #4]
 800379c:	681b      	ldr	r3, [r3, #0]
 800379e:	4a38      	ldr	r2, [pc, #224]	; (8003880 <DMA_CalcDMAMUXChannelBaseAndMask+0xf4>)
 80037a0:	4293      	cmp	r3, r2
 80037a2:	d022      	beq.n	80037ea <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
 80037a4:	687b      	ldr	r3, [r7, #4]
 80037a6:	681b      	ldr	r3, [r3, #0]
 80037a8:	4a36      	ldr	r2, [pc, #216]	; (8003884 <DMA_CalcDMAMUXChannelBaseAndMask+0xf8>)
 80037aa:	4293      	cmp	r3, r2
 80037ac:	d01d      	beq.n	80037ea <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
 80037ae:	687b      	ldr	r3, [r7, #4]
 80037b0:	681b      	ldr	r3, [r3, #0]
 80037b2:	4a35      	ldr	r2, [pc, #212]	; (8003888 <DMA_CalcDMAMUXChannelBaseAndMask+0xfc>)
 80037b4:	4293      	cmp	r3, r2
 80037b6:	d018      	beq.n	80037ea <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
 80037b8:	687b      	ldr	r3, [r7, #4]
 80037ba:	681b      	ldr	r3, [r3, #0]
 80037bc:	4a33      	ldr	r2, [pc, #204]	; (800388c <DMA_CalcDMAMUXChannelBaseAndMask+0x100>)
 80037be:	4293      	cmp	r3, r2
 80037c0:	d013      	beq.n	80037ea <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
 80037c2:	687b      	ldr	r3, [r7, #4]
 80037c4:	681b      	ldr	r3, [r3, #0]
 80037c6:	4a32      	ldr	r2, [pc, #200]	; (8003890 <DMA_CalcDMAMUXChannelBaseAndMask+0x104>)
 80037c8:	4293      	cmp	r3, r2
 80037ca:	d00e      	beq.n	80037ea <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
 80037cc:	687b      	ldr	r3, [r7, #4]
 80037ce:	681b      	ldr	r3, [r3, #0]
 80037d0:	4a30      	ldr	r2, [pc, #192]	; (8003894 <DMA_CalcDMAMUXChannelBaseAndMask+0x108>)
 80037d2:	4293      	cmp	r3, r2
 80037d4:	d009      	beq.n	80037ea <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
 80037d6:	687b      	ldr	r3, [r7, #4]
 80037d8:	681b      	ldr	r3, [r3, #0]
 80037da:	4a2f      	ldr	r2, [pc, #188]	; (8003898 <DMA_CalcDMAMUXChannelBaseAndMask+0x10c>)
 80037dc:	4293      	cmp	r3, r2
 80037de:	d004      	beq.n	80037ea <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
 80037e0:	687b      	ldr	r3, [r7, #4]
 80037e2:	681b      	ldr	r3, [r3, #0]
 80037e4:	4a2d      	ldr	r2, [pc, #180]	; (800389c <DMA_CalcDMAMUXChannelBaseAndMask+0x110>)
 80037e6:	4293      	cmp	r3, r2
 80037e8:	d101      	bne.n	80037ee <DMA_CalcDMAMUXChannelBaseAndMask+0x62>
 80037ea:	2301      	movs	r3, #1
 80037ec:	e000      	b.n	80037f0 <DMA_CalcDMAMUXChannelBaseAndMask+0x64>
 80037ee:	2300      	movs	r3, #0
 80037f0:	2b00      	cmp	r3, #0
 80037f2:	d01a      	beq.n	800382a <DMA_CalcDMAMUXChannelBaseAndMask+0x9e>
  {
    /* BDMA Channels are connected to DMAMUX2 channels */
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
 80037f4:	687b      	ldr	r3, [r7, #4]
 80037f6:	681b      	ldr	r3, [r3, #0]
 80037f8:	b2db      	uxtb	r3, r3
 80037fa:	3b08      	subs	r3, #8
 80037fc:	4a28      	ldr	r2, [pc, #160]	; (80038a0 <DMA_CalcDMAMUXChannelBaseAndMask+0x114>)
 80037fe:	fba2 2303 	umull	r2, r3, r2, r3
 8003802:	091b      	lsrs	r3, r3, #4
 8003804:	60fb      	str	r3, [r7, #12]
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
 8003806:	68fa      	ldr	r2, [r7, #12]
 8003808:	4b26      	ldr	r3, [pc, #152]	; (80038a4 <DMA_CalcDMAMUXChannelBaseAndMask+0x118>)
 800380a:	4413      	add	r3, r2
 800380c:	009b      	lsls	r3, r3, #2
 800380e:	461a      	mov	r2, r3
 8003810:	687b      	ldr	r3, [r7, #4]
 8003812:	661a      	str	r2, [r3, #96]	; 0x60
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
 8003814:	687b      	ldr	r3, [r7, #4]
 8003816:	4a24      	ldr	r2, [pc, #144]	; (80038a8 <DMA_CalcDMAMUXChannelBaseAndMask+0x11c>)
 8003818:	665a      	str	r2, [r3, #100]	; 0x64
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 800381a:	68fb      	ldr	r3, [r7, #12]
 800381c:	f003 031f 	and.w	r3, r3, #31
 8003820:	2201      	movs	r2, #1
 8003822:	409a      	lsls	r2, r3
 8003824:	687b      	ldr	r3, [r7, #4]
 8003826:	669a      	str	r2, [r3, #104]	; 0x68
    }
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
  }
}
 8003828:	e024      	b.n	8003874 <DMA_CalcDMAMUXChannelBaseAndMask+0xe8>
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 800382a:	687b      	ldr	r3, [r7, #4]
 800382c:	681b      	ldr	r3, [r3, #0]
 800382e:	b2db      	uxtb	r3, r3
 8003830:	3b10      	subs	r3, #16
 8003832:	4a1e      	ldr	r2, [pc, #120]	; (80038ac <DMA_CalcDMAMUXChannelBaseAndMask+0x120>)
 8003834:	fba2 2303 	umull	r2, r3, r2, r3
 8003838:	091b      	lsrs	r3, r3, #4
 800383a:	60fb      	str	r3, [r7, #12]
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
 800383c:	68bb      	ldr	r3, [r7, #8]
 800383e:	4a1c      	ldr	r2, [pc, #112]	; (80038b0 <DMA_CalcDMAMUXChannelBaseAndMask+0x124>)
 8003840:	4293      	cmp	r3, r2
 8003842:	d806      	bhi.n	8003852 <DMA_CalcDMAMUXChannelBaseAndMask+0xc6>
 8003844:	68bb      	ldr	r3, [r7, #8]
 8003846:	4a1b      	ldr	r2, [pc, #108]	; (80038b4 <DMA_CalcDMAMUXChannelBaseAndMask+0x128>)
 8003848:	4293      	cmp	r3, r2
 800384a:	d902      	bls.n	8003852 <DMA_CalcDMAMUXChannelBaseAndMask+0xc6>
      stream_number += 8U;
 800384c:	68fb      	ldr	r3, [r7, #12]
 800384e:	3308      	adds	r3, #8
 8003850:	60fb      	str	r3, [r7, #12]
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
 8003852:	68fa      	ldr	r2, [r7, #12]
 8003854:	4b18      	ldr	r3, [pc, #96]	; (80038b8 <DMA_CalcDMAMUXChannelBaseAndMask+0x12c>)
 8003856:	4413      	add	r3, r2
 8003858:	009b      	lsls	r3, r3, #2
 800385a:	461a      	mov	r2, r3
 800385c:	687b      	ldr	r3, [r7, #4]
 800385e:	661a      	str	r2, [r3, #96]	; 0x60
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 8003860:	687b      	ldr	r3, [r7, #4]
 8003862:	4a16      	ldr	r2, [pc, #88]	; (80038bc <DMA_CalcDMAMUXChannelBaseAndMask+0x130>)
 8003864:	665a      	str	r2, [r3, #100]	; 0x64
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 8003866:	68fb      	ldr	r3, [r7, #12]
 8003868:	f003 031f 	and.w	r3, r3, #31
 800386c:	2201      	movs	r2, #1
 800386e:	409a      	lsls	r2, r3
 8003870:	687b      	ldr	r3, [r7, #4]
 8003872:	669a      	str	r2, [r3, #104]	; 0x68
}
 8003874:	bf00      	nop
 8003876:	3714      	adds	r7, #20
 8003878:	46bd      	mov	sp, r7
 800387a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800387e:	4770      	bx	lr
 8003880:	58025408 	.word	0x58025408
 8003884:	5802541c 	.word	0x5802541c
 8003888:	58025430 	.word	0x58025430
 800388c:	58025444 	.word	0x58025444
 8003890:	58025458 	.word	0x58025458
 8003894:	5802546c 	.word	0x5802546c
 8003898:	58025480 	.word	0x58025480
 800389c:	58025494 	.word	0x58025494
 80038a0:	cccccccd 	.word	0xcccccccd
 80038a4:	16009600 	.word	0x16009600
 80038a8:	58025880 	.word	0x58025880
 80038ac:	aaaaaaab 	.word	0xaaaaaaab
 80038b0:	400204b8 	.word	0x400204b8
 80038b4:	4002040f 	.word	0x4002040f
 80038b8:	10008200 	.word	0x10008200
 80038bc:	40020880 	.word	0x40020880

080038c0 <DMA_CalcDMAMUXRequestGenBaseAndMask>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
static void DMA_CalcDMAMUXRequestGenBaseAndMask(DMA_HandleTypeDef *hdma)
{
 80038c0:	b480      	push	{r7}
 80038c2:	b085      	sub	sp, #20
 80038c4:	af00      	add	r7, sp, #0
 80038c6:	6078      	str	r0, [r7, #4]
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;
 80038c8:	687b      	ldr	r3, [r7, #4]
 80038ca:	685b      	ldr	r3, [r3, #4]
 80038cc:	b2db      	uxtb	r3, r3
 80038ce:	60fb      	str	r3, [r7, #12]

  if((request >= DMA_REQUEST_GENERATOR0) && (request <= DMA_REQUEST_GENERATOR7))
 80038d0:	68fb      	ldr	r3, [r7, #12]
 80038d2:	2b00      	cmp	r3, #0
 80038d4:	d04a      	beq.n	800396c <DMA_CalcDMAMUXRequestGenBaseAndMask+0xac>
 80038d6:	68fb      	ldr	r3, [r7, #12]
 80038d8:	2b08      	cmp	r3, #8
 80038da:	d847      	bhi.n	800396c <DMA_CalcDMAMUXRequestGenBaseAndMask+0xac>
  {
    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
 80038dc:	687b      	ldr	r3, [r7, #4]
 80038de:	681b      	ldr	r3, [r3, #0]
 80038e0:	4a25      	ldr	r2, [pc, #148]	; (8003978 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xb8>)
 80038e2:	4293      	cmp	r3, r2
 80038e4:	d022      	beq.n	800392c <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
 80038e6:	687b      	ldr	r3, [r7, #4]
 80038e8:	681b      	ldr	r3, [r3, #0]
 80038ea:	4a24      	ldr	r2, [pc, #144]	; (800397c <DMA_CalcDMAMUXRequestGenBaseAndMask+0xbc>)
 80038ec:	4293      	cmp	r3, r2
 80038ee:	d01d      	beq.n	800392c <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
 80038f0:	687b      	ldr	r3, [r7, #4]
 80038f2:	681b      	ldr	r3, [r3, #0]
 80038f4:	4a22      	ldr	r2, [pc, #136]	; (8003980 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xc0>)
 80038f6:	4293      	cmp	r3, r2
 80038f8:	d018      	beq.n	800392c <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
 80038fa:	687b      	ldr	r3, [r7, #4]
 80038fc:	681b      	ldr	r3, [r3, #0]
 80038fe:	4a21      	ldr	r2, [pc, #132]	; (8003984 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xc4>)
 8003900:	4293      	cmp	r3, r2
 8003902:	d013      	beq.n	800392c <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
 8003904:	687b      	ldr	r3, [r7, #4]
 8003906:	681b      	ldr	r3, [r3, #0]
 8003908:	4a1f      	ldr	r2, [pc, #124]	; (8003988 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xc8>)
 800390a:	4293      	cmp	r3, r2
 800390c:	d00e      	beq.n	800392c <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
 800390e:	687b      	ldr	r3, [r7, #4]
 8003910:	681b      	ldr	r3, [r3, #0]
 8003912:	4a1e      	ldr	r2, [pc, #120]	; (800398c <DMA_CalcDMAMUXRequestGenBaseAndMask+0xcc>)
 8003914:	4293      	cmp	r3, r2
 8003916:	d009      	beq.n	800392c <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
 8003918:	687b      	ldr	r3, [r7, #4]
 800391a:	681b      	ldr	r3, [r3, #0]
 800391c:	4a1c      	ldr	r2, [pc, #112]	; (8003990 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xd0>)
 800391e:	4293      	cmp	r3, r2
 8003920:	d004      	beq.n	800392c <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
 8003922:	687b      	ldr	r3, [r7, #4]
 8003924:	681b      	ldr	r3, [r3, #0]
 8003926:	4a1b      	ldr	r2, [pc, #108]	; (8003994 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xd4>)
 8003928:	4293      	cmp	r3, r2
 800392a:	d101      	bne.n	8003930 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x70>
 800392c:	2301      	movs	r3, #1
 800392e:	e000      	b.n	8003932 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x72>
 8003930:	2300      	movs	r3, #0
 8003932:	2b00      	cmp	r3, #0
 8003934:	d00a      	beq.n	800394c <DMA_CalcDMAMUXRequestGenBaseAndMask+0x8c>
    {
      /* BDMA Channels are connected to DMAMUX2 request generator blocks */
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
 8003936:	68fa      	ldr	r2, [r7, #12]
 8003938:	4b17      	ldr	r3, [pc, #92]	; (8003998 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xd8>)
 800393a:	4413      	add	r3, r2
 800393c:	009b      	lsls	r3, r3, #2
 800393e:	461a      	mov	r2, r3
 8003940:	687b      	ldr	r3, [r7, #4]
 8003942:	66da      	str	r2, [r3, #108]	; 0x6c

      hdma->DMAmuxRequestGenStatus = DMAMUX2_RequestGenStatus;
 8003944:	687b      	ldr	r3, [r7, #4]
 8003946:	4a15      	ldr	r2, [pc, #84]	; (800399c <DMA_CalcDMAMUXRequestGenBaseAndMask+0xdc>)
 8003948:	671a      	str	r2, [r3, #112]	; 0x70
 800394a:	e009      	b.n	8003960 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xa0>
    }
    else
    {
      /* DMA1 and DMA2 Streams use DMAMUX1 request generator blocks */
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 800394c:	68fa      	ldr	r2, [r7, #12]
 800394e:	4b14      	ldr	r3, [pc, #80]	; (80039a0 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xe0>)
 8003950:	4413      	add	r3, r2
 8003952:	009b      	lsls	r3, r3, #2
 8003954:	461a      	mov	r2, r3
 8003956:	687b      	ldr	r3, [r7, #4]
 8003958:	66da      	str	r2, [r3, #108]	; 0x6c

      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 800395a:	687b      	ldr	r3, [r7, #4]
 800395c:	4a11      	ldr	r2, [pc, #68]	; (80039a4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xe4>)
 800395e:	671a      	str	r2, [r3, #112]	; 0x70
    }

    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);
 8003960:	68fb      	ldr	r3, [r7, #12]
 8003962:	3b01      	subs	r3, #1
 8003964:	2201      	movs	r2, #1
 8003966:	409a      	lsls	r2, r3
 8003968:	687b      	ldr	r3, [r7, #4]
 800396a:	675a      	str	r2, [r3, #116]	; 0x74
  }
}
 800396c:	bf00      	nop
 800396e:	3714      	adds	r7, #20
 8003970:	46bd      	mov	sp, r7
 8003972:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003976:	4770      	bx	lr
 8003978:	58025408 	.word	0x58025408
 800397c:	5802541c 	.word	0x5802541c
 8003980:	58025430 	.word	0x58025430
 8003984:	58025444 	.word	0x58025444
 8003988:	58025458 	.word	0x58025458
 800398c:	5802546c 	.word	0x5802546c
 8003990:	58025480 	.word	0x58025480
 8003994:	58025494 	.word	0x58025494
 8003998:	1600963f 	.word	0x1600963f
 800399c:	58025940 	.word	0x58025940
 80039a0:	1000823f 	.word	0x1000823f
 80039a4:	40020940 	.word	0x40020940

080039a8 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 80039a8:	b480      	push	{r7}
 80039aa:	b089      	sub	sp, #36	; 0x24
 80039ac:	af00      	add	r7, sp, #0
 80039ae:	6078      	str	r0, [r7, #4]
 80039b0:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
 80039b2:	2300      	movs	r3, #0
 80039b4:	61fb      	str	r3, [r7, #28]
  EXTI_Core_TypeDef *EXTI_CurrentCPU;

#if defined(DUAL_CORE) && defined(CORE_CM4)
  EXTI_CurrentCPU = EXTI_D2; /* EXTI for CM4 CPU */
#else
  EXTI_CurrentCPU = EXTI_D1; /* EXTI for CM7 CPU */
 80039b6:	4b89      	ldr	r3, [pc, #548]	; (8003bdc <HAL_GPIO_Init+0x234>)
 80039b8:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 80039ba:	e194      	b.n	8003ce6 <HAL_GPIO_Init+0x33e>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 80039bc:	683b      	ldr	r3, [r7, #0]
 80039be:	681a      	ldr	r2, [r3, #0]
 80039c0:	2101      	movs	r1, #1
 80039c2:	69fb      	ldr	r3, [r7, #28]
 80039c4:	fa01 f303 	lsl.w	r3, r1, r3
 80039c8:	4013      	ands	r3, r2
 80039ca:	613b      	str	r3, [r7, #16]

    if (iocurrent != 0x00U)
 80039cc:	693b      	ldr	r3, [r7, #16]
 80039ce:	2b00      	cmp	r3, #0
 80039d0:	f000 8186 	beq.w	8003ce0 <HAL_GPIO_Init+0x338>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 80039d4:	683b      	ldr	r3, [r7, #0]
 80039d6:	685b      	ldr	r3, [r3, #4]
 80039d8:	f003 0303 	and.w	r3, r3, #3
 80039dc:	2b01      	cmp	r3, #1
 80039de:	d005      	beq.n	80039ec <HAL_GPIO_Init+0x44>
 80039e0:	683b      	ldr	r3, [r7, #0]
 80039e2:	685b      	ldr	r3, [r3, #4]
 80039e4:	f003 0303 	and.w	r3, r3, #3
 80039e8:	2b02      	cmp	r3, #2
 80039ea:	d130      	bne.n	8003a4e <HAL_GPIO_Init+0xa6>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));

        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 80039ec:	687b      	ldr	r3, [r7, #4]
 80039ee:	689b      	ldr	r3, [r3, #8]
 80039f0:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 80039f2:	69fb      	ldr	r3, [r7, #28]
 80039f4:	005b      	lsls	r3, r3, #1
 80039f6:	2203      	movs	r2, #3
 80039f8:	fa02 f303 	lsl.w	r3, r2, r3
 80039fc:	43db      	mvns	r3, r3
 80039fe:	69ba      	ldr	r2, [r7, #24]
 8003a00:	4013      	ands	r3, r2
 8003a02:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2U));
 8003a04:	683b      	ldr	r3, [r7, #0]
 8003a06:	68da      	ldr	r2, [r3, #12]
 8003a08:	69fb      	ldr	r3, [r7, #28]
 8003a0a:	005b      	lsls	r3, r3, #1
 8003a0c:	fa02 f303 	lsl.w	r3, r2, r3
 8003a10:	69ba      	ldr	r2, [r7, #24]
 8003a12:	4313      	orrs	r3, r2
 8003a14:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
 8003a16:	687b      	ldr	r3, [r7, #4]
 8003a18:	69ba      	ldr	r2, [r7, #24]
 8003a1a:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8003a1c:	687b      	ldr	r3, [r7, #4]
 8003a1e:	685b      	ldr	r3, [r3, #4]
 8003a20:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8003a22:	2201      	movs	r2, #1
 8003a24:	69fb      	ldr	r3, [r7, #28]
 8003a26:	fa02 f303 	lsl.w	r3, r2, r3
 8003a2a:	43db      	mvns	r3, r3
 8003a2c:	69ba      	ldr	r2, [r7, #24]
 8003a2e:	4013      	ands	r3, r2
 8003a30:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 8003a32:	683b      	ldr	r3, [r7, #0]
 8003a34:	685b      	ldr	r3, [r3, #4]
 8003a36:	091b      	lsrs	r3, r3, #4
 8003a38:	f003 0201 	and.w	r2, r3, #1
 8003a3c:	69fb      	ldr	r3, [r7, #28]
 8003a3e:	fa02 f303 	lsl.w	r3, r2, r3
 8003a42:	69ba      	ldr	r2, [r7, #24]
 8003a44:	4313      	orrs	r3, r2
 8003a46:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
 8003a48:	687b      	ldr	r3, [r7, #4]
 8003a4a:	69ba      	ldr	r2, [r7, #24]
 8003a4c:	605a      	str	r2, [r3, #4]
      }

      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 8003a4e:	683b      	ldr	r3, [r7, #0]
 8003a50:	685b      	ldr	r3, [r3, #4]
 8003a52:	f003 0303 	and.w	r3, r3, #3
 8003a56:	2b03      	cmp	r3, #3
 8003a58:	d017      	beq.n	8003a8a <HAL_GPIO_Init+0xe2>
      {
       /* Check the Pull parameter */
       assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 8003a5a:	687b      	ldr	r3, [r7, #4]
 8003a5c:	68db      	ldr	r3, [r3, #12]
 8003a5e:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8003a60:	69fb      	ldr	r3, [r7, #28]
 8003a62:	005b      	lsls	r3, r3, #1
 8003a64:	2203      	movs	r2, #3
 8003a66:	fa02 f303 	lsl.w	r3, r2, r3
 8003a6a:	43db      	mvns	r3, r3
 8003a6c:	69ba      	ldr	r2, [r7, #24]
 8003a6e:	4013      	ands	r3, r2
 8003a70:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8003a72:	683b      	ldr	r3, [r7, #0]
 8003a74:	689a      	ldr	r2, [r3, #8]
 8003a76:	69fb      	ldr	r3, [r7, #28]
 8003a78:	005b      	lsls	r3, r3, #1
 8003a7a:	fa02 f303 	lsl.w	r3, r2, r3
 8003a7e:	69ba      	ldr	r2, [r7, #24]
 8003a80:	4313      	orrs	r3, r2
 8003a82:	61bb      	str	r3, [r7, #24]
      GPIOx->PUPDR = temp;
 8003a84:	687b      	ldr	r3, [r7, #4]
 8003a86:	69ba      	ldr	r2, [r7, #24]
 8003a88:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8003a8a:	683b      	ldr	r3, [r7, #0]
 8003a8c:	685b      	ldr	r3, [r3, #4]
 8003a8e:	f003 0303 	and.w	r3, r3, #3
 8003a92:	2b02      	cmp	r3, #2
 8003a94:	d123      	bne.n	8003ade <HAL_GPIO_Init+0x136>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 8003a96:	69fb      	ldr	r3, [r7, #28]
 8003a98:	08da      	lsrs	r2, r3, #3
 8003a9a:	687b      	ldr	r3, [r7, #4]
 8003a9c:	3208      	adds	r2, #8
 8003a9e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8003aa2:	61bb      	str	r3, [r7, #24]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 8003aa4:	69fb      	ldr	r3, [r7, #28]
 8003aa6:	f003 0307 	and.w	r3, r3, #7
 8003aaa:	009b      	lsls	r3, r3, #2
 8003aac:	220f      	movs	r2, #15
 8003aae:	fa02 f303 	lsl.w	r3, r2, r3
 8003ab2:	43db      	mvns	r3, r3
 8003ab4:	69ba      	ldr	r2, [r7, #24]
 8003ab6:	4013      	ands	r3, r2
 8003ab8:	61bb      	str	r3, [r7, #24]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 8003aba:	683b      	ldr	r3, [r7, #0]
 8003abc:	691a      	ldr	r2, [r3, #16]
 8003abe:	69fb      	ldr	r3, [r7, #28]
 8003ac0:	f003 0307 	and.w	r3, r3, #7
 8003ac4:	009b      	lsls	r3, r3, #2
 8003ac6:	fa02 f303 	lsl.w	r3, r2, r3
 8003aca:	69ba      	ldr	r2, [r7, #24]
 8003acc:	4313      	orrs	r3, r2
 8003ace:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3U] = temp;
 8003ad0:	69fb      	ldr	r3, [r7, #28]
 8003ad2:	08da      	lsrs	r2, r3, #3
 8003ad4:	687b      	ldr	r3, [r7, #4]
 8003ad6:	3208      	adds	r2, #8
 8003ad8:	69b9      	ldr	r1, [r7, #24]
 8003ada:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8003ade:	687b      	ldr	r3, [r7, #4]
 8003ae0:	681b      	ldr	r3, [r3, #0]
 8003ae2:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 8003ae4:	69fb      	ldr	r3, [r7, #28]
 8003ae6:	005b      	lsls	r3, r3, #1
 8003ae8:	2203      	movs	r2, #3
 8003aea:	fa02 f303 	lsl.w	r3, r2, r3
 8003aee:	43db      	mvns	r3, r3
 8003af0:	69ba      	ldr	r2, [r7, #24]
 8003af2:	4013      	ands	r3, r2
 8003af4:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8003af6:	683b      	ldr	r3, [r7, #0]
 8003af8:	685b      	ldr	r3, [r3, #4]
 8003afa:	f003 0203 	and.w	r2, r3, #3
 8003afe:	69fb      	ldr	r3, [r7, #28]
 8003b00:	005b      	lsls	r3, r3, #1
 8003b02:	fa02 f303 	lsl.w	r3, r2, r3
 8003b06:	69ba      	ldr	r2, [r7, #24]
 8003b08:	4313      	orrs	r3, r2
 8003b0a:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
 8003b0c:	687b      	ldr	r3, [r7, #4]
 8003b0e:	69ba      	ldr	r2, [r7, #24]
 8003b10:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 8003b12:	683b      	ldr	r3, [r7, #0]
 8003b14:	685b      	ldr	r3, [r3, #4]
 8003b16:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
 8003b1a:	2b00      	cmp	r3, #0
 8003b1c:	f000 80e0 	beq.w	8003ce0 <HAL_GPIO_Init+0x338>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8003b20:	4b2f      	ldr	r3, [pc, #188]	; (8003be0 <HAL_GPIO_Init+0x238>)
 8003b22:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8003b26:	4a2e      	ldr	r2, [pc, #184]	; (8003be0 <HAL_GPIO_Init+0x238>)
 8003b28:	f043 0302 	orr.w	r3, r3, #2
 8003b2c:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
 8003b30:	4b2b      	ldr	r3, [pc, #172]	; (8003be0 <HAL_GPIO_Init+0x238>)
 8003b32:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8003b36:	f003 0302 	and.w	r3, r3, #2
 8003b3a:	60fb      	str	r3, [r7, #12]
 8003b3c:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
 8003b3e:	4a29      	ldr	r2, [pc, #164]	; (8003be4 <HAL_GPIO_Init+0x23c>)
 8003b40:	69fb      	ldr	r3, [r7, #28]
 8003b42:	089b      	lsrs	r3, r3, #2
 8003b44:	3302      	adds	r3, #2
 8003b46:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8003b4a:	61bb      	str	r3, [r7, #24]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 8003b4c:	69fb      	ldr	r3, [r7, #28]
 8003b4e:	f003 0303 	and.w	r3, r3, #3
 8003b52:	009b      	lsls	r3, r3, #2
 8003b54:	220f      	movs	r2, #15
 8003b56:	fa02 f303 	lsl.w	r3, r2, r3
 8003b5a:	43db      	mvns	r3, r3
 8003b5c:	69ba      	ldr	r2, [r7, #24]
 8003b5e:	4013      	ands	r3, r2
 8003b60:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 8003b62:	687b      	ldr	r3, [r7, #4]
 8003b64:	4a20      	ldr	r2, [pc, #128]	; (8003be8 <HAL_GPIO_Init+0x240>)
 8003b66:	4293      	cmp	r3, r2
 8003b68:	d052      	beq.n	8003c10 <HAL_GPIO_Init+0x268>
 8003b6a:	687b      	ldr	r3, [r7, #4]
 8003b6c:	4a1f      	ldr	r2, [pc, #124]	; (8003bec <HAL_GPIO_Init+0x244>)
 8003b6e:	4293      	cmp	r3, r2
 8003b70:	d031      	beq.n	8003bd6 <HAL_GPIO_Init+0x22e>
 8003b72:	687b      	ldr	r3, [r7, #4]
 8003b74:	4a1e      	ldr	r2, [pc, #120]	; (8003bf0 <HAL_GPIO_Init+0x248>)
 8003b76:	4293      	cmp	r3, r2
 8003b78:	d02b      	beq.n	8003bd2 <HAL_GPIO_Init+0x22a>
 8003b7a:	687b      	ldr	r3, [r7, #4]
 8003b7c:	4a1d      	ldr	r2, [pc, #116]	; (8003bf4 <HAL_GPIO_Init+0x24c>)
 8003b7e:	4293      	cmp	r3, r2
 8003b80:	d025      	beq.n	8003bce <HAL_GPIO_Init+0x226>
 8003b82:	687b      	ldr	r3, [r7, #4]
 8003b84:	4a1c      	ldr	r2, [pc, #112]	; (8003bf8 <HAL_GPIO_Init+0x250>)
 8003b86:	4293      	cmp	r3, r2
 8003b88:	d01f      	beq.n	8003bca <HAL_GPIO_Init+0x222>
 8003b8a:	687b      	ldr	r3, [r7, #4]
 8003b8c:	4a1b      	ldr	r2, [pc, #108]	; (8003bfc <HAL_GPIO_Init+0x254>)
 8003b8e:	4293      	cmp	r3, r2
 8003b90:	d019      	beq.n	8003bc6 <HAL_GPIO_Init+0x21e>
 8003b92:	687b      	ldr	r3, [r7, #4]
 8003b94:	4a1a      	ldr	r2, [pc, #104]	; (8003c00 <HAL_GPIO_Init+0x258>)
 8003b96:	4293      	cmp	r3, r2
 8003b98:	d013      	beq.n	8003bc2 <HAL_GPIO_Init+0x21a>
 8003b9a:	687b      	ldr	r3, [r7, #4]
 8003b9c:	4a19      	ldr	r2, [pc, #100]	; (8003c04 <HAL_GPIO_Init+0x25c>)
 8003b9e:	4293      	cmp	r3, r2
 8003ba0:	d00d      	beq.n	8003bbe <HAL_GPIO_Init+0x216>
 8003ba2:	687b      	ldr	r3, [r7, #4]
 8003ba4:	4a18      	ldr	r2, [pc, #96]	; (8003c08 <HAL_GPIO_Init+0x260>)
 8003ba6:	4293      	cmp	r3, r2
 8003ba8:	d007      	beq.n	8003bba <HAL_GPIO_Init+0x212>
 8003baa:	687b      	ldr	r3, [r7, #4]
 8003bac:	4a17      	ldr	r2, [pc, #92]	; (8003c0c <HAL_GPIO_Init+0x264>)
 8003bae:	4293      	cmp	r3, r2
 8003bb0:	d101      	bne.n	8003bb6 <HAL_GPIO_Init+0x20e>
 8003bb2:	2309      	movs	r3, #9
 8003bb4:	e02d      	b.n	8003c12 <HAL_GPIO_Init+0x26a>
 8003bb6:	230a      	movs	r3, #10
 8003bb8:	e02b      	b.n	8003c12 <HAL_GPIO_Init+0x26a>
 8003bba:	2308      	movs	r3, #8
 8003bbc:	e029      	b.n	8003c12 <HAL_GPIO_Init+0x26a>
 8003bbe:	2307      	movs	r3, #7
 8003bc0:	e027      	b.n	8003c12 <HAL_GPIO_Init+0x26a>
 8003bc2:	2306      	movs	r3, #6
 8003bc4:	e025      	b.n	8003c12 <HAL_GPIO_Init+0x26a>
 8003bc6:	2305      	movs	r3, #5
 8003bc8:	e023      	b.n	8003c12 <HAL_GPIO_Init+0x26a>
 8003bca:	2304      	movs	r3, #4
 8003bcc:	e021      	b.n	8003c12 <HAL_GPIO_Init+0x26a>
 8003bce:	2303      	movs	r3, #3
 8003bd0:	e01f      	b.n	8003c12 <HAL_GPIO_Init+0x26a>
 8003bd2:	2302      	movs	r3, #2
 8003bd4:	e01d      	b.n	8003c12 <HAL_GPIO_Init+0x26a>
 8003bd6:	2301      	movs	r3, #1
 8003bd8:	e01b      	b.n	8003c12 <HAL_GPIO_Init+0x26a>
 8003bda:	bf00      	nop
 8003bdc:	58000080 	.word	0x58000080
 8003be0:	58024400 	.word	0x58024400
 8003be4:	58000400 	.word	0x58000400
 8003be8:	58020000 	.word	0x58020000
 8003bec:	58020400 	.word	0x58020400
 8003bf0:	58020800 	.word	0x58020800
 8003bf4:	58020c00 	.word	0x58020c00
 8003bf8:	58021000 	.word	0x58021000
 8003bfc:	58021400 	.word	0x58021400
 8003c00:	58021800 	.word	0x58021800
 8003c04:	58021c00 	.word	0x58021c00
 8003c08:	58022000 	.word	0x58022000
 8003c0c:	58022400 	.word	0x58022400
 8003c10:	2300      	movs	r3, #0
 8003c12:	69fa      	ldr	r2, [r7, #28]
 8003c14:	f002 0203 	and.w	r2, r2, #3
 8003c18:	0092      	lsls	r2, r2, #2
 8003c1a:	4093      	lsls	r3, r2
 8003c1c:	69ba      	ldr	r2, [r7, #24]
 8003c1e:	4313      	orrs	r3, r2
 8003c20:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2U] = temp;
 8003c22:	4938      	ldr	r1, [pc, #224]	; (8003d04 <HAL_GPIO_Init+0x35c>)
 8003c24:	69fb      	ldr	r3, [r7, #28]
 8003c26:	089b      	lsrs	r3, r3, #2
 8003c28:	3302      	adds	r3, #2
 8003c2a:	69ba      	ldr	r2, [r7, #24]
 8003c2c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 8003c30:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003c34:	681b      	ldr	r3, [r3, #0]
 8003c36:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
 8003c38:	693b      	ldr	r3, [r7, #16]
 8003c3a:	43db      	mvns	r3, r3
 8003c3c:	69ba      	ldr	r2, [r7, #24]
 8003c3e:	4013      	ands	r3, r2
 8003c40:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 8003c42:	683b      	ldr	r3, [r7, #0]
 8003c44:	685b      	ldr	r3, [r3, #4]
 8003c46:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8003c4a:	2b00      	cmp	r3, #0
 8003c4c:	d003      	beq.n	8003c56 <HAL_GPIO_Init+0x2ae>
        {
          temp |= iocurrent;
 8003c4e:	69ba      	ldr	r2, [r7, #24]
 8003c50:	693b      	ldr	r3, [r7, #16]
 8003c52:	4313      	orrs	r3, r2
 8003c54:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR1 = temp;
 8003c56:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8003c5a:	69bb      	ldr	r3, [r7, #24]
 8003c5c:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
 8003c5e:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003c62:	685b      	ldr	r3, [r3, #4]
 8003c64:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
 8003c66:	693b      	ldr	r3, [r7, #16]
 8003c68:	43db      	mvns	r3, r3
 8003c6a:	69ba      	ldr	r2, [r7, #24]
 8003c6c:	4013      	ands	r3, r2
 8003c6e:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 8003c70:	683b      	ldr	r3, [r7, #0]
 8003c72:	685b      	ldr	r3, [r3, #4]
 8003c74:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8003c78:	2b00      	cmp	r3, #0
 8003c7a:	d003      	beq.n	8003c84 <HAL_GPIO_Init+0x2dc>
        {
          temp |= iocurrent;
 8003c7c:	69ba      	ldr	r2, [r7, #24]
 8003c7e:	693b      	ldr	r3, [r7, #16]
 8003c80:	4313      	orrs	r3, r2
 8003c82:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR1 = temp;
 8003c84:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8003c88:	69bb      	ldr	r3, [r7, #24]
 8003c8a:	6053      	str	r3, [r2, #4]

        temp = EXTI_CurrentCPU->EMR1;
 8003c8c:	697b      	ldr	r3, [r7, #20]
 8003c8e:	685b      	ldr	r3, [r3, #4]
 8003c90:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
 8003c92:	693b      	ldr	r3, [r7, #16]
 8003c94:	43db      	mvns	r3, r3
 8003c96:	69ba      	ldr	r2, [r7, #24]
 8003c98:	4013      	ands	r3, r2
 8003c9a:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 8003c9c:	683b      	ldr	r3, [r7, #0]
 8003c9e:	685b      	ldr	r3, [r3, #4]
 8003ca0:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8003ca4:	2b00      	cmp	r3, #0
 8003ca6:	d003      	beq.n	8003cb0 <HAL_GPIO_Init+0x308>
        {
          temp |= iocurrent;
 8003ca8:	69ba      	ldr	r2, [r7, #24]
 8003caa:	693b      	ldr	r3, [r7, #16]
 8003cac:	4313      	orrs	r3, r2
 8003cae:	61bb      	str	r3, [r7, #24]
        }
        EXTI_CurrentCPU->EMR1 = temp;
 8003cb0:	697b      	ldr	r3, [r7, #20]
 8003cb2:	69ba      	ldr	r2, [r7, #24]
 8003cb4:	605a      	str	r2, [r3, #4]

        /* Clear EXTI line configuration */
        temp = EXTI_CurrentCPU->IMR1;
 8003cb6:	697b      	ldr	r3, [r7, #20]
 8003cb8:	681b      	ldr	r3, [r3, #0]
 8003cba:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
 8003cbc:	693b      	ldr	r3, [r7, #16]
 8003cbe:	43db      	mvns	r3, r3
 8003cc0:	69ba      	ldr	r2, [r7, #24]
 8003cc2:	4013      	ands	r3, r2
 8003cc4:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 8003cc6:	683b      	ldr	r3, [r7, #0]
 8003cc8:	685b      	ldr	r3, [r3, #4]
 8003cca:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8003cce:	2b00      	cmp	r3, #0
 8003cd0:	d003      	beq.n	8003cda <HAL_GPIO_Init+0x332>
        {
          temp |= iocurrent;
 8003cd2:	69ba      	ldr	r2, [r7, #24]
 8003cd4:	693b      	ldr	r3, [r7, #16]
 8003cd6:	4313      	orrs	r3, r2
 8003cd8:	61bb      	str	r3, [r7, #24]
        }
        EXTI_CurrentCPU->IMR1 = temp;
 8003cda:	697b      	ldr	r3, [r7, #20]
 8003cdc:	69ba      	ldr	r2, [r7, #24]
 8003cde:	601a      	str	r2, [r3, #0]
      }
    }

    position++;
 8003ce0:	69fb      	ldr	r3, [r7, #28]
 8003ce2:	3301      	adds	r3, #1
 8003ce4:	61fb      	str	r3, [r7, #28]
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 8003ce6:	683b      	ldr	r3, [r7, #0]
 8003ce8:	681a      	ldr	r2, [r3, #0]
 8003cea:	69fb      	ldr	r3, [r7, #28]
 8003cec:	fa22 f303 	lsr.w	r3, r2, r3
 8003cf0:	2b00      	cmp	r3, #0
 8003cf2:	f47f ae63 	bne.w	80039bc <HAL_GPIO_Init+0x14>
  }
}
 8003cf6:	bf00      	nop
 8003cf8:	bf00      	nop
 8003cfa:	3724      	adds	r7, #36	; 0x24
 8003cfc:	46bd      	mov	sp, r7
 8003cfe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003d02:	4770      	bx	lr
 8003d04:	58000400 	.word	0x58000400

08003d08 <HAL_GPIO_ReadPin>:
  * @param  GPIO_Pin: specifies the port bit to read.
  *         This parameter can be GPIO_PIN_x where x can be (0..15).
  * @retval The input port pin value.
  */
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
 8003d08:	b480      	push	{r7}
 8003d0a:	b085      	sub	sp, #20
 8003d0c:	af00      	add	r7, sp, #0
 8003d0e:	6078      	str	r0, [r7, #4]
 8003d10:	460b      	mov	r3, r1
 8003d12:	807b      	strh	r3, [r7, #2]
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != 0x00U)
 8003d14:	687b      	ldr	r3, [r7, #4]
 8003d16:	691a      	ldr	r2, [r3, #16]
 8003d18:	887b      	ldrh	r3, [r7, #2]
 8003d1a:	4013      	ands	r3, r2
 8003d1c:	2b00      	cmp	r3, #0
 8003d1e:	d002      	beq.n	8003d26 <HAL_GPIO_ReadPin+0x1e>
  {
    bitstatus = GPIO_PIN_SET;
 8003d20:	2301      	movs	r3, #1
 8003d22:	73fb      	strb	r3, [r7, #15]
 8003d24:	e001      	b.n	8003d2a <HAL_GPIO_ReadPin+0x22>
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
 8003d26:	2300      	movs	r3, #0
 8003d28:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 8003d2a:	7bfb      	ldrb	r3, [r7, #15]
}
 8003d2c:	4618      	mov	r0, r3
 8003d2e:	3714      	adds	r7, #20
 8003d30:	46bd      	mov	sp, r7
 8003d32:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003d36:	4770      	bx	lr

08003d38 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 8003d38:	b480      	push	{r7}
 8003d3a:	b083      	sub	sp, #12
 8003d3c:	af00      	add	r7, sp, #0
 8003d3e:	6078      	str	r0, [r7, #4]
 8003d40:	460b      	mov	r3, r1
 8003d42:	807b      	strh	r3, [r7, #2]
 8003d44:	4613      	mov	r3, r2
 8003d46:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 8003d48:	787b      	ldrb	r3, [r7, #1]
 8003d4a:	2b00      	cmp	r3, #0
 8003d4c:	d003      	beq.n	8003d56 <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
 8003d4e:	887a      	ldrh	r2, [r7, #2]
 8003d50:	687b      	ldr	r3, [r7, #4]
 8003d52:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
  }
}
 8003d54:	e003      	b.n	8003d5e <HAL_GPIO_WritePin+0x26>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
 8003d56:	887b      	ldrh	r3, [r7, #2]
 8003d58:	041a      	lsls	r2, r3, #16
 8003d5a:	687b      	ldr	r3, [r7, #4]
 8003d5c:	619a      	str	r2, [r3, #24]
}
 8003d5e:	bf00      	nop
 8003d60:	370c      	adds	r7, #12
 8003d62:	46bd      	mov	sp, r7
 8003d64:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003d68:	4770      	bx	lr

08003d6a <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
 8003d6a:	b580      	push	{r7, lr}
 8003d6c:	b082      	sub	sp, #8
 8003d6e:	af00      	add	r7, sp, #0
 8003d70:	4603      	mov	r3, r0
 8003d72:	80fb      	strh	r3, [r7, #6]
    __HAL_GPIO_EXTID2_CLEAR_IT(GPIO_Pin);
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
  }
#else
  /* EXTI line interrupt detected */
  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00U)
 8003d74:	f04f 43b0 	mov.w	r3, #1476395008	; 0x58000000
 8003d78:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8003d7c:	88fb      	ldrh	r3, [r7, #6]
 8003d7e:	4013      	ands	r3, r2
 8003d80:	2b00      	cmp	r3, #0
 8003d82:	d008      	beq.n	8003d96 <HAL_GPIO_EXTI_IRQHandler+0x2c>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 8003d84:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
 8003d88:	88fb      	ldrh	r3, [r7, #6]
 8003d8a:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 8003d8e:	88fb      	ldrh	r3, [r7, #6]
 8003d90:	4618      	mov	r0, r3
 8003d92:	f000 f804 	bl	8003d9e <HAL_GPIO_EXTI_Callback>
  }
#endif
}
 8003d96:	bf00      	nop
 8003d98:	3708      	adds	r7, #8
 8003d9a:	46bd      	mov	sp, r7
 8003d9c:	bd80      	pop	{r7, pc}

08003d9e <HAL_GPIO_EXTI_Callback>:
  * @brief  EXTI line detection callback.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
 8003d9e:	b480      	push	{r7}
 8003da0:	b083      	sub	sp, #12
 8003da2:	af00      	add	r7, sp, #0
 8003da4:	4603      	mov	r3, r0
 8003da6:	80fb      	strh	r3, [r7, #6]
  UNUSED(GPIO_Pin);

  /* NOTE: This function Should not be modified, when the callback is needed,
           the HAL_GPIO_EXTI_Callback could be implemented in the user file
   */
}
 8003da8:	bf00      	nop
 8003daa:	370c      	adds	r7, #12
 8003dac:	46bd      	mov	sp, r7
 8003dae:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003db2:	4770      	bx	lr

08003db4 <HAL_PWREx_ConfigSupply>:
  *         PWR_SMPS_2V5_SUPPLIES_EXT are used only for lines that supports SMPS
  *         regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply (uint32_t SupplySource)
{
 8003db4:	b580      	push	{r7, lr}
 8003db6:	b084      	sub	sp, #16
 8003db8:	af00      	add	r7, sp, #0
 8003dba:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param (IS_PWR_SUPPLY (SupplySource));

  /* Check if supply source was configured */
#if defined (PWR_FLAG_SCUEN)
  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)
 8003dbc:	4b19      	ldr	r3, [pc, #100]	; (8003e24 <HAL_PWREx_ConfigSupply+0x70>)
 8003dbe:	68db      	ldr	r3, [r3, #12]
 8003dc0:	f003 0304 	and.w	r3, r3, #4
 8003dc4:	2b04      	cmp	r3, #4
 8003dc6:	d00a      	beq.n	8003dde <HAL_PWREx_ConfigSupply+0x2a>
#else
  if ((PWR->CR3 & (PWR_CR3_SMPSEN | PWR_CR3_LDOEN | PWR_CR3_BYPASS)) != (PWR_CR3_SMPSEN | PWR_CR3_LDOEN))
#endif /* defined (PWR_FLAG_SCUEN) */
  {
    /* Check supply configuration */
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
 8003dc8:	4b16      	ldr	r3, [pc, #88]	; (8003e24 <HAL_PWREx_ConfigSupply+0x70>)
 8003dca:	68db      	ldr	r3, [r3, #12]
 8003dcc:	f003 0307 	and.w	r3, r3, #7
 8003dd0:	687a      	ldr	r2, [r7, #4]
 8003dd2:	429a      	cmp	r2, r3
 8003dd4:	d001      	beq.n	8003dda <HAL_PWREx_ConfigSupply+0x26>
    {
      /* Supply configuration update locked, can't apply a new supply config */
      return HAL_ERROR;
 8003dd6:	2301      	movs	r3, #1
 8003dd8:	e01f      	b.n	8003e1a <HAL_PWREx_ConfigSupply+0x66>
    else
    {
      /* Supply configuration update locked, but new supply configuration
         matches with old supply configuration : nothing to do
      */
      return HAL_OK;
 8003dda:	2300      	movs	r3, #0
 8003ddc:	e01d      	b.n	8003e1a <HAL_PWREx_ConfigSupply+0x66>
    }
  }

  /* Set the power supply configuration */
  MODIFY_REG (PWR->CR3, PWR_SUPPLY_CONFIG_MASK, SupplySource);
 8003dde:	4b11      	ldr	r3, [pc, #68]	; (8003e24 <HAL_PWREx_ConfigSupply+0x70>)
 8003de0:	68db      	ldr	r3, [r3, #12]
 8003de2:	f023 0207 	bic.w	r2, r3, #7
 8003de6:	490f      	ldr	r1, [pc, #60]	; (8003e24 <HAL_PWREx_ConfigSupply+0x70>)
 8003de8:	687b      	ldr	r3, [r7, #4]
 8003dea:	4313      	orrs	r3, r2
 8003dec:	60cb      	str	r3, [r1, #12]

  /* Get tick */
  tickstart = HAL_GetTick ();
 8003dee:	f7fc fcab 	bl	8000748 <HAL_GetTick>
 8003df2:	60f8      	str	r0, [r7, #12]

  /* Wait till voltage level flag is set */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
 8003df4:	e009      	b.n	8003e0a <HAL_PWREx_ConfigSupply+0x56>
  {
    if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
 8003df6:	f7fc fca7 	bl	8000748 <HAL_GetTick>
 8003dfa:	4602      	mov	r2, r0
 8003dfc:	68fb      	ldr	r3, [r7, #12]
 8003dfe:	1ad3      	subs	r3, r2, r3
 8003e00:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8003e04:	d901      	bls.n	8003e0a <HAL_PWREx_ConfigSupply+0x56>
    {
      return HAL_ERROR;
 8003e06:	2301      	movs	r3, #1
 8003e08:	e007      	b.n	8003e1a <HAL_PWREx_ConfigSupply+0x66>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
 8003e0a:	4b06      	ldr	r3, [pc, #24]	; (8003e24 <HAL_PWREx_ConfigSupply+0x70>)
 8003e0c:	685b      	ldr	r3, [r3, #4]
 8003e0e:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8003e12:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8003e16:	d1ee      	bne.n	8003df6 <HAL_PWREx_ConfigSupply+0x42>
      }
    }
  }
#endif /* defined (SMPS) */

  return HAL_OK;
 8003e18:	2300      	movs	r3, #0
}
 8003e1a:	4618      	mov	r0, r3
 8003e1c:	3710      	adds	r7, #16
 8003e1e:	46bd      	mov	sp, r7
 8003e20:	bd80      	pop	{r7, pc}
 8003e22:	bf00      	nop
 8003e24:	58024800 	.word	0x58024800

08003e28 <HAL_RCC_OscConfig>:
  *         supported by this function. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8003e28:	b580      	push	{r7, lr}
 8003e2a:	b08c      	sub	sp, #48	; 0x30
 8003e2c:	af00      	add	r7, sp, #0
 8003e2e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  uint32_t temp1_pllckcfg, temp2_pllckcfg;

    /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 8003e30:	687b      	ldr	r3, [r7, #4]
 8003e32:	2b00      	cmp	r3, #0
 8003e34:	d102      	bne.n	8003e3c <HAL_RCC_OscConfig+0x14>
  {
    return HAL_ERROR;
 8003e36:	2301      	movs	r3, #1
 8003e38:	f000 bc1c 	b.w	8004674 <HAL_RCC_OscConfig+0x84c>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8003e3c:	687b      	ldr	r3, [r7, #4]
 8003e3e:	681b      	ldr	r3, [r3, #0]
 8003e40:	f003 0301 	and.w	r3, r3, #1
 8003e44:	2b00      	cmp	r3, #0
 8003e46:	f000 8087 	beq.w	8003f58 <HAL_RCC_OscConfig+0x130>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8003e4a:	4b9e      	ldr	r3, [pc, #632]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8003e4c:	691b      	ldr	r3, [r3, #16]
 8003e4e:	f003 0338 	and.w	r3, r3, #56	; 0x38
 8003e52:	62fb      	str	r3, [r7, #44]	; 0x2c
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 8003e54:	4b9b      	ldr	r3, [pc, #620]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8003e56:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003e58:	62bb      	str	r3, [r7, #40]	; 0x28
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((temp_sysclksrc == RCC_CFGR_SWS_HSE) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSE)))
 8003e5a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003e5c:	2b10      	cmp	r3, #16
 8003e5e:	d007      	beq.n	8003e70 <HAL_RCC_OscConfig+0x48>
 8003e60:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8003e62:	2b18      	cmp	r3, #24
 8003e64:	d110      	bne.n	8003e88 <HAL_RCC_OscConfig+0x60>
 8003e66:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003e68:	f003 0303 	and.w	r3, r3, #3
 8003e6c:	2b02      	cmp	r3, #2
 8003e6e:	d10b      	bne.n	8003e88 <HAL_RCC_OscConfig+0x60>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8003e70:	4b94      	ldr	r3, [pc, #592]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8003e72:	681b      	ldr	r3, [r3, #0]
 8003e74:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8003e78:	2b00      	cmp	r3, #0
 8003e7a:	d06c      	beq.n	8003f56 <HAL_RCC_OscConfig+0x12e>
 8003e7c:	687b      	ldr	r3, [r7, #4]
 8003e7e:	685b      	ldr	r3, [r3, #4]
 8003e80:	2b00      	cmp	r3, #0
 8003e82:	d168      	bne.n	8003f56 <HAL_RCC_OscConfig+0x12e>
      {
        return HAL_ERROR;
 8003e84:	2301      	movs	r3, #1
 8003e86:	e3f5      	b.n	8004674 <HAL_RCC_OscConfig+0x84c>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8003e88:	687b      	ldr	r3, [r7, #4]
 8003e8a:	685b      	ldr	r3, [r3, #4]
 8003e8c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8003e90:	d106      	bne.n	8003ea0 <HAL_RCC_OscConfig+0x78>
 8003e92:	4b8c      	ldr	r3, [pc, #560]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8003e94:	681b      	ldr	r3, [r3, #0]
 8003e96:	4a8b      	ldr	r2, [pc, #556]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8003e98:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003e9c:	6013      	str	r3, [r2, #0]
 8003e9e:	e02e      	b.n	8003efe <HAL_RCC_OscConfig+0xd6>
 8003ea0:	687b      	ldr	r3, [r7, #4]
 8003ea2:	685b      	ldr	r3, [r3, #4]
 8003ea4:	2b00      	cmp	r3, #0
 8003ea6:	d10c      	bne.n	8003ec2 <HAL_RCC_OscConfig+0x9a>
 8003ea8:	4b86      	ldr	r3, [pc, #536]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8003eaa:	681b      	ldr	r3, [r3, #0]
 8003eac:	4a85      	ldr	r2, [pc, #532]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8003eae:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8003eb2:	6013      	str	r3, [r2, #0]
 8003eb4:	4b83      	ldr	r3, [pc, #524]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8003eb6:	681b      	ldr	r3, [r3, #0]
 8003eb8:	4a82      	ldr	r2, [pc, #520]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8003eba:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8003ebe:	6013      	str	r3, [r2, #0]
 8003ec0:	e01d      	b.n	8003efe <HAL_RCC_OscConfig+0xd6>
 8003ec2:	687b      	ldr	r3, [r7, #4]
 8003ec4:	685b      	ldr	r3, [r3, #4]
 8003ec6:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8003eca:	d10c      	bne.n	8003ee6 <HAL_RCC_OscConfig+0xbe>
 8003ecc:	4b7d      	ldr	r3, [pc, #500]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8003ece:	681b      	ldr	r3, [r3, #0]
 8003ed0:	4a7c      	ldr	r2, [pc, #496]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8003ed2:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8003ed6:	6013      	str	r3, [r2, #0]
 8003ed8:	4b7a      	ldr	r3, [pc, #488]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8003eda:	681b      	ldr	r3, [r3, #0]
 8003edc:	4a79      	ldr	r2, [pc, #484]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8003ede:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003ee2:	6013      	str	r3, [r2, #0]
 8003ee4:	e00b      	b.n	8003efe <HAL_RCC_OscConfig+0xd6>
 8003ee6:	4b77      	ldr	r3, [pc, #476]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8003ee8:	681b      	ldr	r3, [r3, #0]
 8003eea:	4a76      	ldr	r2, [pc, #472]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8003eec:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8003ef0:	6013      	str	r3, [r2, #0]
 8003ef2:	4b74      	ldr	r3, [pc, #464]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8003ef4:	681b      	ldr	r3, [r3, #0]
 8003ef6:	4a73      	ldr	r2, [pc, #460]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8003ef8:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8003efc:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8003efe:	687b      	ldr	r3, [r7, #4]
 8003f00:	685b      	ldr	r3, [r3, #4]
 8003f02:	2b00      	cmp	r3, #0
 8003f04:	d013      	beq.n	8003f2e <HAL_RCC_OscConfig+0x106>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8003f06:	f7fc fc1f 	bl	8000748 <HAL_GetTick>
 8003f0a:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 8003f0c:	e008      	b.n	8003f20 <HAL_RCC_OscConfig+0xf8>
        {
          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8003f0e:	f7fc fc1b 	bl	8000748 <HAL_GetTick>
 8003f12:	4602      	mov	r2, r0
 8003f14:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003f16:	1ad3      	subs	r3, r2, r3
 8003f18:	2b64      	cmp	r3, #100	; 0x64
 8003f1a:	d901      	bls.n	8003f20 <HAL_RCC_OscConfig+0xf8>
          {
            return HAL_TIMEOUT;
 8003f1c:	2303      	movs	r3, #3
 8003f1e:	e3a9      	b.n	8004674 <HAL_RCC_OscConfig+0x84c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 8003f20:	4b68      	ldr	r3, [pc, #416]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8003f22:	681b      	ldr	r3, [r3, #0]
 8003f24:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8003f28:	2b00      	cmp	r3, #0
 8003f2a:	d0f0      	beq.n	8003f0e <HAL_RCC_OscConfig+0xe6>
 8003f2c:	e014      	b.n	8003f58 <HAL_RCC_OscConfig+0x130>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8003f2e:	f7fc fc0b 	bl	8000748 <HAL_GetTick>
 8003f32:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSE is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 8003f34:	e008      	b.n	8003f48 <HAL_RCC_OscConfig+0x120>
        {
          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8003f36:	f7fc fc07 	bl	8000748 <HAL_GetTick>
 8003f3a:	4602      	mov	r2, r0
 8003f3c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003f3e:	1ad3      	subs	r3, r2, r3
 8003f40:	2b64      	cmp	r3, #100	; 0x64
 8003f42:	d901      	bls.n	8003f48 <HAL_RCC_OscConfig+0x120>
          {
            return HAL_TIMEOUT;
 8003f44:	2303      	movs	r3, #3
 8003f46:	e395      	b.n	8004674 <HAL_RCC_OscConfig+0x84c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 8003f48:	4b5e      	ldr	r3, [pc, #376]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8003f4a:	681b      	ldr	r3, [r3, #0]
 8003f4c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8003f50:	2b00      	cmp	r3, #0
 8003f52:	d1f0      	bne.n	8003f36 <HAL_RCC_OscConfig+0x10e>
 8003f54:	e000      	b.n	8003f58 <HAL_RCC_OscConfig+0x130>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8003f56:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8003f58:	687b      	ldr	r3, [r7, #4]
 8003f5a:	681b      	ldr	r3, [r3, #0]
 8003f5c:	f003 0302 	and.w	r3, r3, #2
 8003f60:	2b00      	cmp	r3, #0
 8003f62:	f000 80ca 	beq.w	80040fa <HAL_RCC_OscConfig+0x2d2>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSICALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* When the HSI is used as system clock it will not be disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8003f66:	4b57      	ldr	r3, [pc, #348]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8003f68:	691b      	ldr	r3, [r3, #16]
 8003f6a:	f003 0338 	and.w	r3, r3, #56	; 0x38
 8003f6e:	623b      	str	r3, [r7, #32]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 8003f70:	4b54      	ldr	r3, [pc, #336]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8003f72:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003f74:	61fb      	str	r3, [r7, #28]
    if((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
 8003f76:	6a3b      	ldr	r3, [r7, #32]
 8003f78:	2b00      	cmp	r3, #0
 8003f7a:	d007      	beq.n	8003f8c <HAL_RCC_OscConfig+0x164>
 8003f7c:	6a3b      	ldr	r3, [r7, #32]
 8003f7e:	2b18      	cmp	r3, #24
 8003f80:	d156      	bne.n	8004030 <HAL_RCC_OscConfig+0x208>
 8003f82:	69fb      	ldr	r3, [r7, #28]
 8003f84:	f003 0303 	and.w	r3, r3, #3
 8003f88:	2b00      	cmp	r3, #0
 8003f8a:	d151      	bne.n	8004030 <HAL_RCC_OscConfig+0x208>
    {
      /* When HSI is used as system clock it will not be disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 8003f8c:	4b4d      	ldr	r3, [pc, #308]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8003f8e:	681b      	ldr	r3, [r3, #0]
 8003f90:	f003 0304 	and.w	r3, r3, #4
 8003f94:	2b00      	cmp	r3, #0
 8003f96:	d005      	beq.n	8003fa4 <HAL_RCC_OscConfig+0x17c>
 8003f98:	687b      	ldr	r3, [r7, #4]
 8003f9a:	68db      	ldr	r3, [r3, #12]
 8003f9c:	2b00      	cmp	r3, #0
 8003f9e:	d101      	bne.n	8003fa4 <HAL_RCC_OscConfig+0x17c>
      {
        return HAL_ERROR;
 8003fa0:	2301      	movs	r3, #1
 8003fa2:	e367      	b.n	8004674 <HAL_RCC_OscConfig+0x84c>
      }
      /* Otherwise, only HSI division and calibration are allowed */
      else
      {
          /* Enable the Internal High Speed oscillator (HSI, HSIDIV2, HSIDIV4, or HSIDIV8) */
          __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
 8003fa4:	4b47      	ldr	r3, [pc, #284]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8003fa6:	681b      	ldr	r3, [r3, #0]
 8003fa8:	f023 0219 	bic.w	r2, r3, #25
 8003fac:	687b      	ldr	r3, [r7, #4]
 8003fae:	68db      	ldr	r3, [r3, #12]
 8003fb0:	4944      	ldr	r1, [pc, #272]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8003fb2:	4313      	orrs	r3, r2
 8003fb4:	600b      	str	r3, [r1, #0]

          /* Get Start Tick*/
          tickstart = HAL_GetTick();
 8003fb6:	f7fc fbc7 	bl	8000748 <HAL_GetTick>
 8003fba:	6278      	str	r0, [r7, #36]	; 0x24

          /* Wait till HSI is ready */
          while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8003fbc:	e008      	b.n	8003fd0 <HAL_RCC_OscConfig+0x1a8>
          {
            if((uint32_t) (HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8003fbe:	f7fc fbc3 	bl	8000748 <HAL_GetTick>
 8003fc2:	4602      	mov	r2, r0
 8003fc4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003fc6:	1ad3      	subs	r3, r2, r3
 8003fc8:	2b02      	cmp	r3, #2
 8003fca:	d901      	bls.n	8003fd0 <HAL_RCC_OscConfig+0x1a8>
            {
              return HAL_TIMEOUT;
 8003fcc:	2303      	movs	r3, #3
 8003fce:	e351      	b.n	8004674 <HAL_RCC_OscConfig+0x84c>
          while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8003fd0:	4b3c      	ldr	r3, [pc, #240]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8003fd2:	681b      	ldr	r3, [r3, #0]
 8003fd4:	f003 0304 	and.w	r3, r3, #4
 8003fd8:	2b00      	cmp	r3, #0
 8003fda:	d0f0      	beq.n	8003fbe <HAL_RCC_OscConfig+0x196>
            }
          }
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8003fdc:	f7fc fbc0 	bl	8000760 <HAL_GetREVID>
 8003fe0:	4603      	mov	r3, r0
 8003fe2:	f241 0203 	movw	r2, #4099	; 0x1003
 8003fe6:	4293      	cmp	r3, r2
 8003fe8:	d817      	bhi.n	800401a <HAL_RCC_OscConfig+0x1f2>
 8003fea:	687b      	ldr	r3, [r7, #4]
 8003fec:	691b      	ldr	r3, [r3, #16]
 8003fee:	2b40      	cmp	r3, #64	; 0x40
 8003ff0:	d108      	bne.n	8004004 <HAL_RCC_OscConfig+0x1dc>
 8003ff2:	4b34      	ldr	r3, [pc, #208]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8003ff4:	685b      	ldr	r3, [r3, #4]
 8003ff6:	f423 337c 	bic.w	r3, r3, #258048	; 0x3f000
 8003ffa:	4a32      	ldr	r2, [pc, #200]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8003ffc:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8004000:	6053      	str	r3, [r2, #4]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 8004002:	e07a      	b.n	80040fa <HAL_RCC_OscConfig+0x2d2>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8004004:	4b2f      	ldr	r3, [pc, #188]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8004006:	685b      	ldr	r3, [r3, #4]
 8004008:	f423 327c 	bic.w	r2, r3, #258048	; 0x3f000
 800400c:	687b      	ldr	r3, [r7, #4]
 800400e:	691b      	ldr	r3, [r3, #16]
 8004010:	031b      	lsls	r3, r3, #12
 8004012:	492c      	ldr	r1, [pc, #176]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8004014:	4313      	orrs	r3, r2
 8004016:	604b      	str	r3, [r1, #4]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 8004018:	e06f      	b.n	80040fa <HAL_RCC_OscConfig+0x2d2>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800401a:	4b2a      	ldr	r3, [pc, #168]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 800401c:	685b      	ldr	r3, [r3, #4]
 800401e:	f023 42fe 	bic.w	r2, r3, #2130706432	; 0x7f000000
 8004022:	687b      	ldr	r3, [r7, #4]
 8004024:	691b      	ldr	r3, [r3, #16]
 8004026:	061b      	lsls	r3, r3, #24
 8004028:	4926      	ldr	r1, [pc, #152]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 800402a:	4313      	orrs	r3, r2
 800402c:	604b      	str	r3, [r1, #4]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 800402e:	e064      	b.n	80040fa <HAL_RCC_OscConfig+0x2d2>
    }

    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8004030:	687b      	ldr	r3, [r7, #4]
 8004032:	68db      	ldr	r3, [r3, #12]
 8004034:	2b00      	cmp	r3, #0
 8004036:	d047      	beq.n	80040c8 <HAL_RCC_OscConfig+0x2a0>
      {
     /* Enable the Internal High Speed oscillator (HSI, HSIDIV2,HSIDIV4, or HSIDIV8) */
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
 8004038:	4b22      	ldr	r3, [pc, #136]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 800403a:	681b      	ldr	r3, [r3, #0]
 800403c:	f023 0219 	bic.w	r2, r3, #25
 8004040:	687b      	ldr	r3, [r7, #4]
 8004042:	68db      	ldr	r3, [r3, #12]
 8004044:	491f      	ldr	r1, [pc, #124]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8004046:	4313      	orrs	r3, r2
 8004048:	600b      	str	r3, [r1, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800404a:	f7fc fb7d 	bl	8000748 <HAL_GetTick>
 800404e:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8004050:	e008      	b.n	8004064 <HAL_RCC_OscConfig+0x23c>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8004052:	f7fc fb79 	bl	8000748 <HAL_GetTick>
 8004056:	4602      	mov	r2, r0
 8004058:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800405a:	1ad3      	subs	r3, r2, r3
 800405c:	2b02      	cmp	r3, #2
 800405e:	d901      	bls.n	8004064 <HAL_RCC_OscConfig+0x23c>
          {
            return HAL_TIMEOUT;
 8004060:	2303      	movs	r3, #3
 8004062:	e307      	b.n	8004674 <HAL_RCC_OscConfig+0x84c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8004064:	4b17      	ldr	r3, [pc, #92]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8004066:	681b      	ldr	r3, [r3, #0]
 8004068:	f003 0304 	and.w	r3, r3, #4
 800406c:	2b00      	cmp	r3, #0
 800406e:	d0f0      	beq.n	8004052 <HAL_RCC_OscConfig+0x22a>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8004070:	f7fc fb76 	bl	8000760 <HAL_GetREVID>
 8004074:	4603      	mov	r3, r0
 8004076:	f241 0203 	movw	r2, #4099	; 0x1003
 800407a:	4293      	cmp	r3, r2
 800407c:	d817      	bhi.n	80040ae <HAL_RCC_OscConfig+0x286>
 800407e:	687b      	ldr	r3, [r7, #4]
 8004080:	691b      	ldr	r3, [r3, #16]
 8004082:	2b40      	cmp	r3, #64	; 0x40
 8004084:	d108      	bne.n	8004098 <HAL_RCC_OscConfig+0x270>
 8004086:	4b0f      	ldr	r3, [pc, #60]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8004088:	685b      	ldr	r3, [r3, #4]
 800408a:	f423 337c 	bic.w	r3, r3, #258048	; 0x3f000
 800408e:	4a0d      	ldr	r2, [pc, #52]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 8004090:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8004094:	6053      	str	r3, [r2, #4]
 8004096:	e030      	b.n	80040fa <HAL_RCC_OscConfig+0x2d2>
 8004098:	4b0a      	ldr	r3, [pc, #40]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 800409a:	685b      	ldr	r3, [r3, #4]
 800409c:	f423 327c 	bic.w	r2, r3, #258048	; 0x3f000
 80040a0:	687b      	ldr	r3, [r7, #4]
 80040a2:	691b      	ldr	r3, [r3, #16]
 80040a4:	031b      	lsls	r3, r3, #12
 80040a6:	4907      	ldr	r1, [pc, #28]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 80040a8:	4313      	orrs	r3, r2
 80040aa:	604b      	str	r3, [r1, #4]
 80040ac:	e025      	b.n	80040fa <HAL_RCC_OscConfig+0x2d2>
 80040ae:	4b05      	ldr	r3, [pc, #20]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 80040b0:	685b      	ldr	r3, [r3, #4]
 80040b2:	f023 42fe 	bic.w	r2, r3, #2130706432	; 0x7f000000
 80040b6:	687b      	ldr	r3, [r7, #4]
 80040b8:	691b      	ldr	r3, [r3, #16]
 80040ba:	061b      	lsls	r3, r3, #24
 80040bc:	4901      	ldr	r1, [pc, #4]	; (80040c4 <HAL_RCC_OscConfig+0x29c>)
 80040be:	4313      	orrs	r3, r2
 80040c0:	604b      	str	r3, [r1, #4]
 80040c2:	e01a      	b.n	80040fa <HAL_RCC_OscConfig+0x2d2>
 80040c4:	58024400 	.word	0x58024400
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 80040c8:	4b9e      	ldr	r3, [pc, #632]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 80040ca:	681b      	ldr	r3, [r3, #0]
 80040cc:	4a9d      	ldr	r2, [pc, #628]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 80040ce:	f023 0301 	bic.w	r3, r3, #1
 80040d2:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80040d4:	f7fc fb38 	bl	8000748 <HAL_GetTick>
 80040d8:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till HSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 80040da:	e008      	b.n	80040ee <HAL_RCC_OscConfig+0x2c6>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80040dc:	f7fc fb34 	bl	8000748 <HAL_GetTick>
 80040e0:	4602      	mov	r2, r0
 80040e2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80040e4:	1ad3      	subs	r3, r2, r3
 80040e6:	2b02      	cmp	r3, #2
 80040e8:	d901      	bls.n	80040ee <HAL_RCC_OscConfig+0x2c6>
          {
            return HAL_TIMEOUT;
 80040ea:	2303      	movs	r3, #3
 80040ec:	e2c2      	b.n	8004674 <HAL_RCC_OscConfig+0x84c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 80040ee:	4b95      	ldr	r3, [pc, #596]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 80040f0:	681b      	ldr	r3, [r3, #0]
 80040f2:	f003 0304 	and.w	r3, r3, #4
 80040f6:	2b00      	cmp	r3, #0
 80040f8:	d1f0      	bne.n	80040dc <HAL_RCC_OscConfig+0x2b4>
        }
      }
    }
  }
  /*----------------------------- CSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)
 80040fa:	687b      	ldr	r3, [r7, #4]
 80040fc:	681b      	ldr	r3, [r3, #0]
 80040fe:	f003 0310 	and.w	r3, r3, #16
 8004102:	2b00      	cmp	r3, #0
 8004104:	f000 80a9 	beq.w	800425a <HAL_RCC_OscConfig+0x432>
    /* Check the parameters */
    assert_param(IS_RCC_CSI(RCC_OscInitStruct->CSIState));
    assert_param(IS_RCC_CSICALIBRATION_VALUE(RCC_OscInitStruct->CSICalibrationValue));

    /* When the CSI is used as system clock it will not disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8004108:	4b8e      	ldr	r3, [pc, #568]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 800410a:	691b      	ldr	r3, [r3, #16]
 800410c:	f003 0338 	and.w	r3, r3, #56	; 0x38
 8004110:	61bb      	str	r3, [r7, #24]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 8004112:	4b8c      	ldr	r3, [pc, #560]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 8004114:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004116:	617b      	str	r3, [r7, #20]
    if((temp_sysclksrc == RCC_CFGR_SWS_CSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_CSI)))
 8004118:	69bb      	ldr	r3, [r7, #24]
 800411a:	2b08      	cmp	r3, #8
 800411c:	d007      	beq.n	800412e <HAL_RCC_OscConfig+0x306>
 800411e:	69bb      	ldr	r3, [r7, #24]
 8004120:	2b18      	cmp	r3, #24
 8004122:	d13a      	bne.n	800419a <HAL_RCC_OscConfig+0x372>
 8004124:	697b      	ldr	r3, [r7, #20]
 8004126:	f003 0303 	and.w	r3, r3, #3
 800412a:	2b01      	cmp	r3, #1
 800412c:	d135      	bne.n	800419a <HAL_RCC_OscConfig+0x372>
    {
      /* When CSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
 800412e:	4b85      	ldr	r3, [pc, #532]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 8004130:	681b      	ldr	r3, [r3, #0]
 8004132:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8004136:	2b00      	cmp	r3, #0
 8004138:	d005      	beq.n	8004146 <HAL_RCC_OscConfig+0x31e>
 800413a:	687b      	ldr	r3, [r7, #4]
 800413c:	69db      	ldr	r3, [r3, #28]
 800413e:	2b80      	cmp	r3, #128	; 0x80
 8004140:	d001      	beq.n	8004146 <HAL_RCC_OscConfig+0x31e>
      {
        return HAL_ERROR;
 8004142:	2301      	movs	r3, #1
 8004144:	e296      	b.n	8004674 <HAL_RCC_OscConfig+0x84c>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 8004146:	f7fc fb0b 	bl	8000760 <HAL_GetREVID>
 800414a:	4603      	mov	r3, r0
 800414c:	f241 0203 	movw	r2, #4099	; 0x1003
 8004150:	4293      	cmp	r3, r2
 8004152:	d817      	bhi.n	8004184 <HAL_RCC_OscConfig+0x35c>
 8004154:	687b      	ldr	r3, [r7, #4]
 8004156:	6a1b      	ldr	r3, [r3, #32]
 8004158:	2b20      	cmp	r3, #32
 800415a:	d108      	bne.n	800416e <HAL_RCC_OscConfig+0x346>
 800415c:	4b79      	ldr	r3, [pc, #484]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 800415e:	685b      	ldr	r3, [r3, #4]
 8004160:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
 8004164:	4a77      	ldr	r2, [pc, #476]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 8004166:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 800416a:	6053      	str	r3, [r2, #4]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
 800416c:	e075      	b.n	800425a <HAL_RCC_OscConfig+0x432>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 800416e:	4b75      	ldr	r3, [pc, #468]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 8004170:	685b      	ldr	r3, [r3, #4]
 8004172:	f023 42f8 	bic.w	r2, r3, #2080374784	; 0x7c000000
 8004176:	687b      	ldr	r3, [r7, #4]
 8004178:	6a1b      	ldr	r3, [r3, #32]
 800417a:	069b      	lsls	r3, r3, #26
 800417c:	4971      	ldr	r1, [pc, #452]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 800417e:	4313      	orrs	r3, r2
 8004180:	604b      	str	r3, [r1, #4]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
 8004182:	e06a      	b.n	800425a <HAL_RCC_OscConfig+0x432>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 8004184:	4b6f      	ldr	r3, [pc, #444]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 8004186:	68db      	ldr	r3, [r3, #12]
 8004188:	f023 527c 	bic.w	r2, r3, #1056964608	; 0x3f000000
 800418c:	687b      	ldr	r3, [r7, #4]
 800418e:	6a1b      	ldr	r3, [r3, #32]
 8004190:	061b      	lsls	r3, r3, #24
 8004192:	496c      	ldr	r1, [pc, #432]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 8004194:	4313      	orrs	r3, r2
 8004196:	60cb      	str	r3, [r1, #12]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
 8004198:	e05f      	b.n	800425a <HAL_RCC_OscConfig+0x432>
      }
    }
    else
    {
      /* Check the CSI State */
      if((RCC_OscInitStruct->CSIState)!= RCC_CSI_OFF)
 800419a:	687b      	ldr	r3, [r7, #4]
 800419c:	69db      	ldr	r3, [r3, #28]
 800419e:	2b00      	cmp	r3, #0
 80041a0:	d042      	beq.n	8004228 <HAL_RCC_OscConfig+0x400>
      {
        /* Enable the Internal High Speed oscillator (CSI). */
        __HAL_RCC_CSI_ENABLE();
 80041a2:	4b68      	ldr	r3, [pc, #416]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 80041a4:	681b      	ldr	r3, [r3, #0]
 80041a6:	4a67      	ldr	r2, [pc, #412]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 80041a8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80041ac:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80041ae:	f7fc facb 	bl	8000748 <HAL_GetTick>
 80041b2:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till CSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
 80041b4:	e008      	b.n	80041c8 <HAL_RCC_OscConfig+0x3a0>
        {
          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
 80041b6:	f7fc fac7 	bl	8000748 <HAL_GetTick>
 80041ba:	4602      	mov	r2, r0
 80041bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80041be:	1ad3      	subs	r3, r2, r3
 80041c0:	2b02      	cmp	r3, #2
 80041c2:	d901      	bls.n	80041c8 <HAL_RCC_OscConfig+0x3a0>
          {
            return HAL_TIMEOUT;
 80041c4:	2303      	movs	r3, #3
 80041c6:	e255      	b.n	8004674 <HAL_RCC_OscConfig+0x84c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
 80041c8:	4b5e      	ldr	r3, [pc, #376]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 80041ca:	681b      	ldr	r3, [r3, #0]
 80041cc:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80041d0:	2b00      	cmp	r3, #0
 80041d2:	d0f0      	beq.n	80041b6 <HAL_RCC_OscConfig+0x38e>
          }
        }

        /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 80041d4:	f7fc fac4 	bl	8000760 <HAL_GetREVID>
 80041d8:	4603      	mov	r3, r0
 80041da:	f241 0203 	movw	r2, #4099	; 0x1003
 80041de:	4293      	cmp	r3, r2
 80041e0:	d817      	bhi.n	8004212 <HAL_RCC_OscConfig+0x3ea>
 80041e2:	687b      	ldr	r3, [r7, #4]
 80041e4:	6a1b      	ldr	r3, [r3, #32]
 80041e6:	2b20      	cmp	r3, #32
 80041e8:	d108      	bne.n	80041fc <HAL_RCC_OscConfig+0x3d4>
 80041ea:	4b56      	ldr	r3, [pc, #344]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 80041ec:	685b      	ldr	r3, [r3, #4]
 80041ee:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
 80041f2:	4a54      	ldr	r2, [pc, #336]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 80041f4:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 80041f8:	6053      	str	r3, [r2, #4]
 80041fa:	e02e      	b.n	800425a <HAL_RCC_OscConfig+0x432>
 80041fc:	4b51      	ldr	r3, [pc, #324]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 80041fe:	685b      	ldr	r3, [r3, #4]
 8004200:	f023 42f8 	bic.w	r2, r3, #2080374784	; 0x7c000000
 8004204:	687b      	ldr	r3, [r7, #4]
 8004206:	6a1b      	ldr	r3, [r3, #32]
 8004208:	069b      	lsls	r3, r3, #26
 800420a:	494e      	ldr	r1, [pc, #312]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 800420c:	4313      	orrs	r3, r2
 800420e:	604b      	str	r3, [r1, #4]
 8004210:	e023      	b.n	800425a <HAL_RCC_OscConfig+0x432>
 8004212:	4b4c      	ldr	r3, [pc, #304]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 8004214:	68db      	ldr	r3, [r3, #12]
 8004216:	f023 527c 	bic.w	r2, r3, #1056964608	; 0x3f000000
 800421a:	687b      	ldr	r3, [r7, #4]
 800421c:	6a1b      	ldr	r3, [r3, #32]
 800421e:	061b      	lsls	r3, r3, #24
 8004220:	4948      	ldr	r1, [pc, #288]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 8004222:	4313      	orrs	r3, r2
 8004224:	60cb      	str	r3, [r1, #12]
 8004226:	e018      	b.n	800425a <HAL_RCC_OscConfig+0x432>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (CSI). */
        __HAL_RCC_CSI_DISABLE();
 8004228:	4b46      	ldr	r3, [pc, #280]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 800422a:	681b      	ldr	r3, [r3, #0]
 800422c:	4a45      	ldr	r2, [pc, #276]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 800422e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8004232:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8004234:	f7fc fa88 	bl	8000748 <HAL_GetTick>
 8004238:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till CSI is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
 800423a:	e008      	b.n	800424e <HAL_RCC_OscConfig+0x426>
        {
          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
 800423c:	f7fc fa84 	bl	8000748 <HAL_GetTick>
 8004240:	4602      	mov	r2, r0
 8004242:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004244:	1ad3      	subs	r3, r2, r3
 8004246:	2b02      	cmp	r3, #2
 8004248:	d901      	bls.n	800424e <HAL_RCC_OscConfig+0x426>
          {
            return HAL_TIMEOUT;
 800424a:	2303      	movs	r3, #3
 800424c:	e212      	b.n	8004674 <HAL_RCC_OscConfig+0x84c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
 800424e:	4b3d      	ldr	r3, [pc, #244]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 8004250:	681b      	ldr	r3, [r3, #0]
 8004252:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8004256:	2b00      	cmp	r3, #0
 8004258:	d1f0      	bne.n	800423c <HAL_RCC_OscConfig+0x414>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800425a:	687b      	ldr	r3, [r7, #4]
 800425c:	681b      	ldr	r3, [r3, #0]
 800425e:	f003 0308 	and.w	r3, r3, #8
 8004262:	2b00      	cmp	r3, #0
 8004264:	d036      	beq.n	80042d4 <HAL_RCC_OscConfig+0x4ac>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 8004266:	687b      	ldr	r3, [r7, #4]
 8004268:	695b      	ldr	r3, [r3, #20]
 800426a:	2b00      	cmp	r3, #0
 800426c:	d019      	beq.n	80042a2 <HAL_RCC_OscConfig+0x47a>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 800426e:	4b35      	ldr	r3, [pc, #212]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 8004270:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8004272:	4a34      	ldr	r2, [pc, #208]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 8004274:	f043 0301 	orr.w	r3, r3, #1
 8004278:	6753      	str	r3, [r2, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800427a:	f7fc fa65 	bl	8000748 <HAL_GetTick>
 800427e:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 8004280:	e008      	b.n	8004294 <HAL_RCC_OscConfig+0x46c>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8004282:	f7fc fa61 	bl	8000748 <HAL_GetTick>
 8004286:	4602      	mov	r2, r0
 8004288:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800428a:	1ad3      	subs	r3, r2, r3
 800428c:	2b02      	cmp	r3, #2
 800428e:	d901      	bls.n	8004294 <HAL_RCC_OscConfig+0x46c>
        {
          return HAL_TIMEOUT;
 8004290:	2303      	movs	r3, #3
 8004292:	e1ef      	b.n	8004674 <HAL_RCC_OscConfig+0x84c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 8004294:	4b2b      	ldr	r3, [pc, #172]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 8004296:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8004298:	f003 0302 	and.w	r3, r3, #2
 800429c:	2b00      	cmp	r3, #0
 800429e:	d0f0      	beq.n	8004282 <HAL_RCC_OscConfig+0x45a>
 80042a0:	e018      	b.n	80042d4 <HAL_RCC_OscConfig+0x4ac>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 80042a2:	4b28      	ldr	r3, [pc, #160]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 80042a4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80042a6:	4a27      	ldr	r2, [pc, #156]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 80042a8:	f023 0301 	bic.w	r3, r3, #1
 80042ac:	6753      	str	r3, [r2, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80042ae:	f7fc fa4b 	bl	8000748 <HAL_GetTick>
 80042b2:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 80042b4:	e008      	b.n	80042c8 <HAL_RCC_OscConfig+0x4a0>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80042b6:	f7fc fa47 	bl	8000748 <HAL_GetTick>
 80042ba:	4602      	mov	r2, r0
 80042bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80042be:	1ad3      	subs	r3, r2, r3
 80042c0:	2b02      	cmp	r3, #2
 80042c2:	d901      	bls.n	80042c8 <HAL_RCC_OscConfig+0x4a0>
        {
          return HAL_TIMEOUT;
 80042c4:	2303      	movs	r3, #3
 80042c6:	e1d5      	b.n	8004674 <HAL_RCC_OscConfig+0x84c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 80042c8:	4b1e      	ldr	r3, [pc, #120]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 80042ca:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80042cc:	f003 0302 	and.w	r3, r3, #2
 80042d0:	2b00      	cmp	r3, #0
 80042d2:	d1f0      	bne.n	80042b6 <HAL_RCC_OscConfig+0x48e>
      }
    }
  }

  /*------------------------------ HSI48 Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 80042d4:	687b      	ldr	r3, [r7, #4]
 80042d6:	681b      	ldr	r3, [r3, #0]
 80042d8:	f003 0320 	and.w	r3, r3, #32
 80042dc:	2b00      	cmp	r3, #0
 80042de:	d039      	beq.n	8004354 <HAL_RCC_OscConfig+0x52c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

    /* Check the HSI48 State */
    if((RCC_OscInitStruct->HSI48State)!= RCC_HSI48_OFF)
 80042e0:	687b      	ldr	r3, [r7, #4]
 80042e2:	699b      	ldr	r3, [r3, #24]
 80042e4:	2b00      	cmp	r3, #0
 80042e6:	d019      	beq.n	800431c <HAL_RCC_OscConfig+0x4f4>
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
 80042e8:	4b16      	ldr	r3, [pc, #88]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 80042ea:	681b      	ldr	r3, [r3, #0]
 80042ec:	4a15      	ldr	r2, [pc, #84]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 80042ee:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 80042f2:	6013      	str	r3, [r2, #0]

      /* Get time-out */
      tickstart = HAL_GetTick();
 80042f4:	f7fc fa28 	bl	8000748 <HAL_GetTick>
 80042f8:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till HSI48 is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
 80042fa:	e008      	b.n	800430e <HAL_RCC_OscConfig+0x4e6>
      {
        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
 80042fc:	f7fc fa24 	bl	8000748 <HAL_GetTick>
 8004300:	4602      	mov	r2, r0
 8004302:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004304:	1ad3      	subs	r3, r2, r3
 8004306:	2b02      	cmp	r3, #2
 8004308:	d901      	bls.n	800430e <HAL_RCC_OscConfig+0x4e6>
        {
          return HAL_TIMEOUT;
 800430a:	2303      	movs	r3, #3
 800430c:	e1b2      	b.n	8004674 <HAL_RCC_OscConfig+0x84c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
 800430e:	4b0d      	ldr	r3, [pc, #52]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 8004310:	681b      	ldr	r3, [r3, #0]
 8004312:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8004316:	2b00      	cmp	r3, #0
 8004318:	d0f0      	beq.n	80042fc <HAL_RCC_OscConfig+0x4d4>
 800431a:	e01b      	b.n	8004354 <HAL_RCC_OscConfig+0x52c>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_DISABLE();
 800431c:	4b09      	ldr	r3, [pc, #36]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 800431e:	681b      	ldr	r3, [r3, #0]
 8004320:	4a08      	ldr	r2, [pc, #32]	; (8004344 <HAL_RCC_OscConfig+0x51c>)
 8004322:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8004326:	6013      	str	r3, [r2, #0]

      /* Get time-out */
      tickstart = HAL_GetTick();
 8004328:	f7fc fa0e 	bl	8000748 <HAL_GetTick>
 800432c:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till HSI48 is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
 800432e:	e00b      	b.n	8004348 <HAL_RCC_OscConfig+0x520>
      {
        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
 8004330:	f7fc fa0a 	bl	8000748 <HAL_GetTick>
 8004334:	4602      	mov	r2, r0
 8004336:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004338:	1ad3      	subs	r3, r2, r3
 800433a:	2b02      	cmp	r3, #2
 800433c:	d904      	bls.n	8004348 <HAL_RCC_OscConfig+0x520>
        {
          return HAL_TIMEOUT;
 800433e:	2303      	movs	r3, #3
 8004340:	e198      	b.n	8004674 <HAL_RCC_OscConfig+0x84c>
 8004342:	bf00      	nop
 8004344:	58024400 	.word	0x58024400
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
 8004348:	4ba3      	ldr	r3, [pc, #652]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 800434a:	681b      	ldr	r3, [r3, #0]
 800434c:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8004350:	2b00      	cmp	r3, #0
 8004352:	d1ed      	bne.n	8004330 <HAL_RCC_OscConfig+0x508>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8004354:	687b      	ldr	r3, [r7, #4]
 8004356:	681b      	ldr	r3, [r3, #0]
 8004358:	f003 0304 	and.w	r3, r3, #4
 800435c:	2b00      	cmp	r3, #0
 800435e:	f000 8081 	beq.w	8004464 <HAL_RCC_OscConfig+0x63c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
 8004362:	4b9e      	ldr	r3, [pc, #632]	; (80045dc <HAL_RCC_OscConfig+0x7b4>)
 8004364:	681b      	ldr	r3, [r3, #0]
 8004366:	4a9d      	ldr	r2, [pc, #628]	; (80045dc <HAL_RCC_OscConfig+0x7b4>)
 8004368:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800436c:	6013      	str	r3, [r2, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 800436e:	f7fc f9eb 	bl	8000748 <HAL_GetTick>
 8004372:	6278      	str	r0, [r7, #36]	; 0x24

    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 8004374:	e008      	b.n	8004388 <HAL_RCC_OscConfig+0x560>
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 8004376:	f7fc f9e7 	bl	8000748 <HAL_GetTick>
 800437a:	4602      	mov	r2, r0
 800437c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800437e:	1ad3      	subs	r3, r2, r3
 8004380:	2b64      	cmp	r3, #100	; 0x64
 8004382:	d901      	bls.n	8004388 <HAL_RCC_OscConfig+0x560>
      {
        return HAL_TIMEOUT;
 8004384:	2303      	movs	r3, #3
 8004386:	e175      	b.n	8004674 <HAL_RCC_OscConfig+0x84c>
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 8004388:	4b94      	ldr	r3, [pc, #592]	; (80045dc <HAL_RCC_OscConfig+0x7b4>)
 800438a:	681b      	ldr	r3, [r3, #0]
 800438c:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8004390:	2b00      	cmp	r3, #0
 8004392:	d0f0      	beq.n	8004376 <HAL_RCC_OscConfig+0x54e>
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8004394:	687b      	ldr	r3, [r7, #4]
 8004396:	689b      	ldr	r3, [r3, #8]
 8004398:	2b01      	cmp	r3, #1
 800439a:	d106      	bne.n	80043aa <HAL_RCC_OscConfig+0x582>
 800439c:	4b8e      	ldr	r3, [pc, #568]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 800439e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80043a0:	4a8d      	ldr	r2, [pc, #564]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 80043a2:	f043 0301 	orr.w	r3, r3, #1
 80043a6:	6713      	str	r3, [r2, #112]	; 0x70
 80043a8:	e02d      	b.n	8004406 <HAL_RCC_OscConfig+0x5de>
 80043aa:	687b      	ldr	r3, [r7, #4]
 80043ac:	689b      	ldr	r3, [r3, #8]
 80043ae:	2b00      	cmp	r3, #0
 80043b0:	d10c      	bne.n	80043cc <HAL_RCC_OscConfig+0x5a4>
 80043b2:	4b89      	ldr	r3, [pc, #548]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 80043b4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80043b6:	4a88      	ldr	r2, [pc, #544]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 80043b8:	f023 0301 	bic.w	r3, r3, #1
 80043bc:	6713      	str	r3, [r2, #112]	; 0x70
 80043be:	4b86      	ldr	r3, [pc, #536]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 80043c0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80043c2:	4a85      	ldr	r2, [pc, #532]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 80043c4:	f023 0304 	bic.w	r3, r3, #4
 80043c8:	6713      	str	r3, [r2, #112]	; 0x70
 80043ca:	e01c      	b.n	8004406 <HAL_RCC_OscConfig+0x5de>
 80043cc:	687b      	ldr	r3, [r7, #4]
 80043ce:	689b      	ldr	r3, [r3, #8]
 80043d0:	2b05      	cmp	r3, #5
 80043d2:	d10c      	bne.n	80043ee <HAL_RCC_OscConfig+0x5c6>
 80043d4:	4b80      	ldr	r3, [pc, #512]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 80043d6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80043d8:	4a7f      	ldr	r2, [pc, #508]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 80043da:	f043 0304 	orr.w	r3, r3, #4
 80043de:	6713      	str	r3, [r2, #112]	; 0x70
 80043e0:	4b7d      	ldr	r3, [pc, #500]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 80043e2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80043e4:	4a7c      	ldr	r2, [pc, #496]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 80043e6:	f043 0301 	orr.w	r3, r3, #1
 80043ea:	6713      	str	r3, [r2, #112]	; 0x70
 80043ec:	e00b      	b.n	8004406 <HAL_RCC_OscConfig+0x5de>
 80043ee:	4b7a      	ldr	r3, [pc, #488]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 80043f0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80043f2:	4a79      	ldr	r2, [pc, #484]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 80043f4:	f023 0301 	bic.w	r3, r3, #1
 80043f8:	6713      	str	r3, [r2, #112]	; 0x70
 80043fa:	4b77      	ldr	r3, [pc, #476]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 80043fc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80043fe:	4a76      	ldr	r2, [pc, #472]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 8004400:	f023 0304 	bic.w	r3, r3, #4
 8004404:	6713      	str	r3, [r2, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 8004406:	687b      	ldr	r3, [r7, #4]
 8004408:	689b      	ldr	r3, [r3, #8]
 800440a:	2b00      	cmp	r3, #0
 800440c:	d015      	beq.n	800443a <HAL_RCC_OscConfig+0x612>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800440e:	f7fc f99b 	bl	8000748 <HAL_GetTick>
 8004412:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8004414:	e00a      	b.n	800442c <HAL_RCC_OscConfig+0x604>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8004416:	f7fc f997 	bl	8000748 <HAL_GetTick>
 800441a:	4602      	mov	r2, r0
 800441c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800441e:	1ad3      	subs	r3, r2, r3
 8004420:	f241 3288 	movw	r2, #5000	; 0x1388
 8004424:	4293      	cmp	r3, r2
 8004426:	d901      	bls.n	800442c <HAL_RCC_OscConfig+0x604>
        {
          return HAL_TIMEOUT;
 8004428:	2303      	movs	r3, #3
 800442a:	e123      	b.n	8004674 <HAL_RCC_OscConfig+0x84c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800442c:	4b6a      	ldr	r3, [pc, #424]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 800442e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8004430:	f003 0302 	and.w	r3, r3, #2
 8004434:	2b00      	cmp	r3, #0
 8004436:	d0ee      	beq.n	8004416 <HAL_RCC_OscConfig+0x5ee>
 8004438:	e014      	b.n	8004464 <HAL_RCC_OscConfig+0x63c>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800443a:	f7fc f985 	bl	8000748 <HAL_GetTick>
 800443e:	6278      	str	r0, [r7, #36]	; 0x24

      /* Wait till LSE is disabled */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 8004440:	e00a      	b.n	8004458 <HAL_RCC_OscConfig+0x630>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8004442:	f7fc f981 	bl	8000748 <HAL_GetTick>
 8004446:	4602      	mov	r2, r0
 8004448:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800444a:	1ad3      	subs	r3, r2, r3
 800444c:	f241 3288 	movw	r2, #5000	; 0x1388
 8004450:	4293      	cmp	r3, r2
 8004452:	d901      	bls.n	8004458 <HAL_RCC_OscConfig+0x630>
        {
          return HAL_TIMEOUT;
 8004454:	2303      	movs	r3, #3
 8004456:	e10d      	b.n	8004674 <HAL_RCC_OscConfig+0x84c>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 8004458:	4b5f      	ldr	r3, [pc, #380]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 800445a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800445c:	f003 0302 	and.w	r3, r3, #2
 8004460:	2b00      	cmp	r3, #0
 8004462:	d1ee      	bne.n	8004442 <HAL_RCC_OscConfig+0x61a>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8004464:	687b      	ldr	r3, [r7, #4]
 8004466:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004468:	2b00      	cmp	r3, #0
 800446a:	f000 8102 	beq.w	8004672 <HAL_RCC_OscConfig+0x84a>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL1)
 800446e:	4b5a      	ldr	r3, [pc, #360]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 8004470:	691b      	ldr	r3, [r3, #16]
 8004472:	f003 0338 	and.w	r3, r3, #56	; 0x38
 8004476:	2b18      	cmp	r3, #24
 8004478:	f000 80bd 	beq.w	80045f6 <HAL_RCC_OscConfig+0x7ce>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800447c:	687b      	ldr	r3, [r7, #4]
 800447e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004480:	2b02      	cmp	r3, #2
 8004482:	f040 8095 	bne.w	80045b0 <HAL_RCC_OscConfig+0x788>
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
        assert_param(IS_RCC_PLLFRACN_VALUE(RCC_OscInitStruct->PLL.PLLFRACN));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8004486:	4b54      	ldr	r3, [pc, #336]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 8004488:	681b      	ldr	r3, [r3, #0]
 800448a:	4a53      	ldr	r2, [pc, #332]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 800448c:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8004490:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8004492:	f7fc f959 	bl	8000748 <HAL_GetTick>
 8004496:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 8004498:	e008      	b.n	80044ac <HAL_RCC_OscConfig+0x684>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800449a:	f7fc f955 	bl	8000748 <HAL_GetTick>
 800449e:	4602      	mov	r2, r0
 80044a0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80044a2:	1ad3      	subs	r3, r2, r3
 80044a4:	2b02      	cmp	r3, #2
 80044a6:	d901      	bls.n	80044ac <HAL_RCC_OscConfig+0x684>
          {
            return HAL_TIMEOUT;
 80044a8:	2303      	movs	r3, #3
 80044aa:	e0e3      	b.n	8004674 <HAL_RCC_OscConfig+0x84c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 80044ac:	4b4a      	ldr	r3, [pc, #296]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 80044ae:	681b      	ldr	r3, [r3, #0]
 80044b0:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80044b4:	2b00      	cmp	r3, #0
 80044b6:	d1f0      	bne.n	800449a <HAL_RCC_OscConfig+0x672>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 80044b8:	4b47      	ldr	r3, [pc, #284]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 80044ba:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80044bc:	4b48      	ldr	r3, [pc, #288]	; (80045e0 <HAL_RCC_OscConfig+0x7b8>)
 80044be:	4013      	ands	r3, r2
 80044c0:	687a      	ldr	r2, [r7, #4]
 80044c2:	6a91      	ldr	r1, [r2, #40]	; 0x28
 80044c4:	687a      	ldr	r2, [r7, #4]
 80044c6:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 80044c8:	0112      	lsls	r2, r2, #4
 80044ca:	430a      	orrs	r2, r1
 80044cc:	4942      	ldr	r1, [pc, #264]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 80044ce:	4313      	orrs	r3, r2
 80044d0:	628b      	str	r3, [r1, #40]	; 0x28
 80044d2:	687b      	ldr	r3, [r7, #4]
 80044d4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80044d6:	3b01      	subs	r3, #1
 80044d8:	f3c3 0208 	ubfx	r2, r3, #0, #9
 80044dc:	687b      	ldr	r3, [r7, #4]
 80044de:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80044e0:	3b01      	subs	r3, #1
 80044e2:	025b      	lsls	r3, r3, #9
 80044e4:	b29b      	uxth	r3, r3
 80044e6:	431a      	orrs	r2, r3
 80044e8:	687b      	ldr	r3, [r7, #4]
 80044ea:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80044ec:	3b01      	subs	r3, #1
 80044ee:	041b      	lsls	r3, r3, #16
 80044f0:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
 80044f4:	431a      	orrs	r2, r3
 80044f6:	687b      	ldr	r3, [r7, #4]
 80044f8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80044fa:	3b01      	subs	r3, #1
 80044fc:	061b      	lsls	r3, r3, #24
 80044fe:	f003 43fe 	and.w	r3, r3, #2130706432	; 0x7f000000
 8004502:	4935      	ldr	r1, [pc, #212]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 8004504:	4313      	orrs	r3, r2
 8004506:	630b      	str	r3, [r1, #48]	; 0x30
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ,
                             RCC_OscInitStruct->PLL.PLLR);

         /* Disable PLLFRACN . */
         __HAL_RCC_PLLFRACN_DISABLE();
 8004508:	4b33      	ldr	r3, [pc, #204]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 800450a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800450c:	4a32      	ldr	r2, [pc, #200]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 800450e:	f023 0301 	bic.w	r3, r3, #1
 8004512:	62d3      	str	r3, [r2, #44]	; 0x2c

         /* Configure PLL PLL1FRACN */
         __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
 8004514:	4b30      	ldr	r3, [pc, #192]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 8004516:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8004518:	4b32      	ldr	r3, [pc, #200]	; (80045e4 <HAL_RCC_OscConfig+0x7bc>)
 800451a:	4013      	ands	r3, r2
 800451c:	687a      	ldr	r2, [r7, #4]
 800451e:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8004520:	00d2      	lsls	r2, r2, #3
 8004522:	492d      	ldr	r1, [pc, #180]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 8004524:	4313      	orrs	r3, r2
 8004526:	634b      	str	r3, [r1, #52]	; 0x34

        /* Select PLL1 input reference frequency range: VCI */
        __HAL_RCC_PLL_VCIRANGE(RCC_OscInitStruct->PLL.PLLRGE) ;
 8004528:	4b2b      	ldr	r3, [pc, #172]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 800452a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800452c:	f023 020c 	bic.w	r2, r3, #12
 8004530:	687b      	ldr	r3, [r7, #4]
 8004532:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004534:	4928      	ldr	r1, [pc, #160]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 8004536:	4313      	orrs	r3, r2
 8004538:	62cb      	str	r3, [r1, #44]	; 0x2c

        /* Select PLL1 output frequency range : VCO */
        __HAL_RCC_PLL_VCORANGE(RCC_OscInitStruct->PLL.PLLVCOSEL) ;
 800453a:	4b27      	ldr	r3, [pc, #156]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 800453c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800453e:	f023 0202 	bic.w	r2, r3, #2
 8004542:	687b      	ldr	r3, [r7, #4]
 8004544:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8004546:	4924      	ldr	r1, [pc, #144]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 8004548:	4313      	orrs	r3, r2
 800454a:	62cb      	str	r3, [r1, #44]	; 0x2c

        /* Enable PLL System Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
 800454c:	4b22      	ldr	r3, [pc, #136]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 800454e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004550:	4a21      	ldr	r2, [pc, #132]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 8004552:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8004556:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Enable PLL1Q Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8004558:	4b1f      	ldr	r3, [pc, #124]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 800455a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800455c:	4a1e      	ldr	r2, [pc, #120]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 800455e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8004562:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Enable PLL1R  Clock output. */
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVR);
 8004564:	4b1c      	ldr	r3, [pc, #112]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 8004566:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004568:	4a1b      	ldr	r2, [pc, #108]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 800456a:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800456e:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Enable PLL1FRACN . */
         __HAL_RCC_PLLFRACN_ENABLE();
 8004570:	4b19      	ldr	r3, [pc, #100]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 8004572:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004574:	4a18      	ldr	r2, [pc, #96]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 8004576:	f043 0301 	orr.w	r3, r3, #1
 800457a:	62d3      	str	r3, [r2, #44]	; 0x2c

        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 800457c:	4b16      	ldr	r3, [pc, #88]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 800457e:	681b      	ldr	r3, [r3, #0]
 8004580:	4a15      	ldr	r2, [pc, #84]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 8004582:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8004586:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8004588:	f7fc f8de 	bl	8000748 <HAL_GetTick>
 800458c:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 800458e:	e008      	b.n	80045a2 <HAL_RCC_OscConfig+0x77a>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8004590:	f7fc f8da 	bl	8000748 <HAL_GetTick>
 8004594:	4602      	mov	r2, r0
 8004596:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004598:	1ad3      	subs	r3, r2, r3
 800459a:	2b02      	cmp	r3, #2
 800459c:	d901      	bls.n	80045a2 <HAL_RCC_OscConfig+0x77a>
          {
            return HAL_TIMEOUT;
 800459e:	2303      	movs	r3, #3
 80045a0:	e068      	b.n	8004674 <HAL_RCC_OscConfig+0x84c>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 80045a2:	4b0d      	ldr	r3, [pc, #52]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 80045a4:	681b      	ldr	r3, [r3, #0]
 80045a6:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80045aa:	2b00      	cmp	r3, #0
 80045ac:	d0f0      	beq.n	8004590 <HAL_RCC_OscConfig+0x768>
 80045ae:	e060      	b.n	8004672 <HAL_RCC_OscConfig+0x84a>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 80045b0:	4b09      	ldr	r3, [pc, #36]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 80045b2:	681b      	ldr	r3, [r3, #0]
 80045b4:	4a08      	ldr	r2, [pc, #32]	; (80045d8 <HAL_RCC_OscConfig+0x7b0>)
 80045b6:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 80045ba:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80045bc:	f7fc f8c4 	bl	8000748 <HAL_GetTick>
 80045c0:	6278      	str	r0, [r7, #36]	; 0x24

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 80045c2:	e011      	b.n	80045e8 <HAL_RCC_OscConfig+0x7c0>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80045c4:	f7fc f8c0 	bl	8000748 <HAL_GetTick>
 80045c8:	4602      	mov	r2, r0
 80045ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80045cc:	1ad3      	subs	r3, r2, r3
 80045ce:	2b02      	cmp	r3, #2
 80045d0:	d90a      	bls.n	80045e8 <HAL_RCC_OscConfig+0x7c0>
          {
            return HAL_TIMEOUT;
 80045d2:	2303      	movs	r3, #3
 80045d4:	e04e      	b.n	8004674 <HAL_RCC_OscConfig+0x84c>
 80045d6:	bf00      	nop
 80045d8:	58024400 	.word	0x58024400
 80045dc:	58024800 	.word	0x58024800
 80045e0:	fffffc0c 	.word	0xfffffc0c
 80045e4:	ffff0007 	.word	0xffff0007
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 80045e8:	4b24      	ldr	r3, [pc, #144]	; (800467c <HAL_RCC_OscConfig+0x854>)
 80045ea:	681b      	ldr	r3, [r3, #0]
 80045ec:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80045f0:	2b00      	cmp	r3, #0
 80045f2:	d1e7      	bne.n	80045c4 <HAL_RCC_OscConfig+0x79c>
 80045f4:	e03d      	b.n	8004672 <HAL_RCC_OscConfig+0x84a>
      }
    }
    else
    {
      /* Do not return HAL_ERROR if request repeats the current configuration */
      temp1_pllckcfg = RCC->PLLCKSELR;
 80045f6:	4b21      	ldr	r3, [pc, #132]	; (800467c <HAL_RCC_OscConfig+0x854>)
 80045f8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80045fa:	613b      	str	r3, [r7, #16]
      temp2_pllckcfg = RCC->PLL1DIVR;
 80045fc:	4b1f      	ldr	r3, [pc, #124]	; (800467c <HAL_RCC_OscConfig+0x854>)
 80045fe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8004600:	60fb      	str	r3, [r7, #12]
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 8004602:	687b      	ldr	r3, [r7, #4]
 8004604:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004606:	2b01      	cmp	r3, #1
 8004608:	d031      	beq.n	800466e <HAL_RCC_OscConfig+0x846>
	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800460a:	693b      	ldr	r3, [r7, #16]
 800460c:	f003 0203 	and.w	r2, r3, #3
 8004610:	687b      	ldr	r3, [r7, #4]
 8004612:	6a9b      	ldr	r3, [r3, #40]	; 0x28
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 8004614:	429a      	cmp	r2, r3
 8004616:	d12a      	bne.n	800466e <HAL_RCC_OscConfig+0x846>
         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
 8004618:	693b      	ldr	r3, [r7, #16]
 800461a:	091b      	lsrs	r3, r3, #4
 800461c:	f003 023f 	and.w	r2, r3, #63	; 0x3f
 8004620:	687b      	ldr	r3, [r7, #4]
 8004622:	6adb      	ldr	r3, [r3, #44]	; 0x2c
	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8004624:	429a      	cmp	r2, r3
 8004626:	d122      	bne.n	800466e <HAL_RCC_OscConfig+0x846>
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
 8004628:	68fb      	ldr	r3, [r7, #12]
 800462a:	f3c3 0208 	ubfx	r2, r3, #0, #9
 800462e:	687b      	ldr	r3, [r7, #4]
 8004630:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8004632:	3b01      	subs	r3, #1
         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
 8004634:	429a      	cmp	r2, r3
 8004636:	d11a      	bne.n	800466e <HAL_RCC_OscConfig+0x846>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
 8004638:	68fb      	ldr	r3, [r7, #12]
 800463a:	0a5b      	lsrs	r3, r3, #9
 800463c:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 8004640:	687b      	ldr	r3, [r7, #4]
 8004642:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004644:	3b01      	subs	r3, #1
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
 8004646:	429a      	cmp	r2, r3
 8004648:	d111      	bne.n	800466e <HAL_RCC_OscConfig+0x846>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
 800464a:	68fb      	ldr	r3, [r7, #12]
 800464c:	0c1b      	lsrs	r3, r3, #16
 800464e:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 8004652:	687b      	ldr	r3, [r7, #4]
 8004654:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004656:	3b01      	subs	r3, #1
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
 8004658:	429a      	cmp	r2, r3
 800465a:	d108      	bne.n	800466e <HAL_RCC_OscConfig+0x846>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos) != (RCC_OscInitStruct->PLL.PLLR - 1U)))
 800465c:	68fb      	ldr	r3, [r7, #12]
 800465e:	0e1b      	lsrs	r3, r3, #24
 8004660:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 8004664:	687b      	ldr	r3, [r7, #4]
 8004666:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004668:	3b01      	subs	r3, #1
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
 800466a:	429a      	cmp	r2, r3
 800466c:	d001      	beq.n	8004672 <HAL_RCC_OscConfig+0x84a>
      {
        return HAL_ERROR;
 800466e:	2301      	movs	r3, #1
 8004670:	e000      	b.n	8004674 <HAL_RCC_OscConfig+0x84c>
      }
    }
  }
  return HAL_OK;
 8004672:	2300      	movs	r3, #0
}
 8004674:	4618      	mov	r0, r3
 8004676:	3730      	adds	r7, #48	; 0x30
 8004678:	46bd      	mov	sp, r7
 800467a:	bd80      	pop	{r7, pc}
 800467c:	58024400 	.word	0x58024400

08004680 <HAL_RCC_ClockConfig>:
  *         D1CPRE[3:0] bits to ensure that  Domain1 core clock not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8004680:	b580      	push	{r7, lr}
 8004682:	b086      	sub	sp, #24
 8004684:	af00      	add	r7, sp, #0
 8004686:	6078      	str	r0, [r7, #4]
 8004688:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halstatus;
  uint32_t tickstart;
  uint32_t common_system_clock;

   /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
 800468a:	687b      	ldr	r3, [r7, #4]
 800468c:	2b00      	cmp	r3, #0
 800468e:	d101      	bne.n	8004694 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 8004690:	2301      	movs	r3, #1
 8004692:	e19c      	b.n	80049ce <HAL_RCC_ClockConfig+0x34e>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8004694:	4b8a      	ldr	r3, [pc, #552]	; (80048c0 <HAL_RCC_ClockConfig+0x240>)
 8004696:	681b      	ldr	r3, [r3, #0]
 8004698:	f003 030f 	and.w	r3, r3, #15
 800469c:	683a      	ldr	r2, [r7, #0]
 800469e:	429a      	cmp	r2, r3
 80046a0:	d910      	bls.n	80046c4 <HAL_RCC_ClockConfig+0x44>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80046a2:	4b87      	ldr	r3, [pc, #540]	; (80048c0 <HAL_RCC_ClockConfig+0x240>)
 80046a4:	681b      	ldr	r3, [r3, #0]
 80046a6:	f023 020f 	bic.w	r2, r3, #15
 80046aa:	4985      	ldr	r1, [pc, #532]	; (80048c0 <HAL_RCC_ClockConfig+0x240>)
 80046ac:	683b      	ldr	r3, [r7, #0]
 80046ae:	4313      	orrs	r3, r2
 80046b0:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80046b2:	4b83      	ldr	r3, [pc, #524]	; (80048c0 <HAL_RCC_ClockConfig+0x240>)
 80046b4:	681b      	ldr	r3, [r3, #0]
 80046b6:	f003 030f 	and.w	r3, r3, #15
 80046ba:	683a      	ldr	r2, [r7, #0]
 80046bc:	429a      	cmp	r2, r3
 80046be:	d001      	beq.n	80046c4 <HAL_RCC_ClockConfig+0x44>
    {
      return HAL_ERROR;
 80046c0:	2301      	movs	r3, #1
 80046c2:	e184      	b.n	80049ce <HAL_RCC_ClockConfig+0x34e>

  }

  /* Increasing the BUS frequency divider */
  /*-------------------------- D1PCLK1/CDPCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
 80046c4:	687b      	ldr	r3, [r7, #4]
 80046c6:	681b      	ldr	r3, [r3, #0]
 80046c8:	f003 0304 	and.w	r3, r3, #4
 80046cc:	2b00      	cmp	r3, #0
 80046ce:	d010      	beq.n	80046f2 <HAL_RCC_ClockConfig+0x72>
  {
#if defined (RCC_D1CFGR_D1PPRE)
    if((RCC_ClkInitStruct->APB3CLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
 80046d0:	687b      	ldr	r3, [r7, #4]
 80046d2:	691a      	ldr	r2, [r3, #16]
 80046d4:	4b7b      	ldr	r3, [pc, #492]	; (80048c4 <HAL_RCC_ClockConfig+0x244>)
 80046d6:	699b      	ldr	r3, [r3, #24]
 80046d8:	f003 0370 	and.w	r3, r3, #112	; 0x70
 80046dc:	429a      	cmp	r2, r3
 80046de:	d908      	bls.n	80046f2 <HAL_RCC_ClockConfig+0x72>
    {
      assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
 80046e0:	4b78      	ldr	r3, [pc, #480]	; (80048c4 <HAL_RCC_ClockConfig+0x244>)
 80046e2:	699b      	ldr	r3, [r3, #24]
 80046e4:	f023 0270 	bic.w	r2, r3, #112	; 0x70
 80046e8:	687b      	ldr	r3, [r7, #4]
 80046ea:	691b      	ldr	r3, [r3, #16]
 80046ec:	4975      	ldr	r1, [pc, #468]	; (80048c4 <HAL_RCC_ClockConfig+0x244>)
 80046ee:	4313      	orrs	r3, r2
 80046f0:	618b      	str	r3, [r1, #24]
    }
#endif
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80046f2:	687b      	ldr	r3, [r7, #4]
 80046f4:	681b      	ldr	r3, [r3, #0]
 80046f6:	f003 0308 	and.w	r3, r3, #8
 80046fa:	2b00      	cmp	r3, #0
 80046fc:	d010      	beq.n	8004720 <HAL_RCC_ClockConfig+0xa0>
  {
#if defined (RCC_D2CFGR_D2PPRE1)
    if((RCC_ClkInitStruct->APB1CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
 80046fe:	687b      	ldr	r3, [r7, #4]
 8004700:	695a      	ldr	r2, [r3, #20]
 8004702:	4b70      	ldr	r3, [pc, #448]	; (80048c4 <HAL_RCC_ClockConfig+0x244>)
 8004704:	69db      	ldr	r3, [r3, #28]
 8004706:	f003 0370 	and.w	r3, r3, #112	; 0x70
 800470a:	429a      	cmp	r2, r3
 800470c:	d908      	bls.n	8004720 <HAL_RCC_ClockConfig+0xa0>
    {
      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
 800470e:	4b6d      	ldr	r3, [pc, #436]	; (80048c4 <HAL_RCC_ClockConfig+0x244>)
 8004710:	69db      	ldr	r3, [r3, #28]
 8004712:	f023 0270 	bic.w	r2, r3, #112	; 0x70
 8004716:	687b      	ldr	r3, [r7, #4]
 8004718:	695b      	ldr	r3, [r3, #20]
 800471a:	496a      	ldr	r1, [pc, #424]	; (80048c4 <HAL_RCC_ClockConfig+0x244>)
 800471c:	4313      	orrs	r3, r2
 800471e:	61cb      	str	r3, [r1, #28]
      MODIFY_REG(RCC->CDCFGR2, RCC_CDCFGR2_CDPPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
  }
#endif
    }
  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8004720:	687b      	ldr	r3, [r7, #4]
 8004722:	681b      	ldr	r3, [r3, #0]
 8004724:	f003 0310 	and.w	r3, r3, #16
 8004728:	2b00      	cmp	r3, #0
 800472a:	d010      	beq.n	800474e <HAL_RCC_ClockConfig+0xce>
  {
#if defined(RCC_D2CFGR_D2PPRE2)
    if((RCC_ClkInitStruct->APB2CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
 800472c:	687b      	ldr	r3, [r7, #4]
 800472e:	699a      	ldr	r2, [r3, #24]
 8004730:	4b64      	ldr	r3, [pc, #400]	; (80048c4 <HAL_RCC_ClockConfig+0x244>)
 8004732:	69db      	ldr	r3, [r3, #28]
 8004734:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8004738:	429a      	cmp	r2, r3
 800473a:	d908      	bls.n	800474e <HAL_RCC_ClockConfig+0xce>
    {
      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
 800473c:	4b61      	ldr	r3, [pc, #388]	; (80048c4 <HAL_RCC_ClockConfig+0x244>)
 800473e:	69db      	ldr	r3, [r3, #28]
 8004740:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
 8004744:	687b      	ldr	r3, [r7, #4]
 8004746:	699b      	ldr	r3, [r3, #24]
 8004748:	495e      	ldr	r1, [pc, #376]	; (80048c4 <HAL_RCC_ClockConfig+0x244>)
 800474a:	4313      	orrs	r3, r2
 800474c:	61cb      	str	r3, [r1, #28]
    }
#endif
  }

  /*-------------------------- D3PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
 800474e:	687b      	ldr	r3, [r7, #4]
 8004750:	681b      	ldr	r3, [r3, #0]
 8004752:	f003 0320 	and.w	r3, r3, #32
 8004756:	2b00      	cmp	r3, #0
 8004758:	d010      	beq.n	800477c <HAL_RCC_ClockConfig+0xfc>
  {
#if defined(RCC_D3CFGR_D3PPRE)
    if((RCC_ClkInitStruct->APB4CLKDivider) > (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
 800475a:	687b      	ldr	r3, [r7, #4]
 800475c:	69da      	ldr	r2, [r3, #28]
 800475e:	4b59      	ldr	r3, [pc, #356]	; (80048c4 <HAL_RCC_ClockConfig+0x244>)
 8004760:	6a1b      	ldr	r3, [r3, #32]
 8004762:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8004766:	429a      	cmp	r2, r3
 8004768:	d908      	bls.n	800477c <HAL_RCC_ClockConfig+0xfc>
    {
      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
      MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
 800476a:	4b56      	ldr	r3, [pc, #344]	; (80048c4 <HAL_RCC_ClockConfig+0x244>)
 800476c:	6a1b      	ldr	r3, [r3, #32]
 800476e:	f023 0270 	bic.w	r2, r3, #112	; 0x70
 8004772:	687b      	ldr	r3, [r7, #4]
 8004774:	69db      	ldr	r3, [r3, #28]
 8004776:	4953      	ldr	r1, [pc, #332]	; (80048c4 <HAL_RCC_ClockConfig+0x244>)
 8004778:	4313      	orrs	r3, r2
 800477a:	620b      	str	r3, [r1, #32]
    }
#endif
  }

   /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800477c:	687b      	ldr	r3, [r7, #4]
 800477e:	681b      	ldr	r3, [r3, #0]
 8004780:	f003 0302 	and.w	r3, r3, #2
 8004784:	2b00      	cmp	r3, #0
 8004786:	d010      	beq.n	80047aa <HAL_RCC_ClockConfig+0x12a>
  {
#if defined (RCC_D1CFGR_HPRE)
    if((RCC_ClkInitStruct->AHBCLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_HPRE))
 8004788:	687b      	ldr	r3, [r7, #4]
 800478a:	68da      	ldr	r2, [r3, #12]
 800478c:	4b4d      	ldr	r3, [pc, #308]	; (80048c4 <HAL_RCC_ClockConfig+0x244>)
 800478e:	699b      	ldr	r3, [r3, #24]
 8004790:	f003 030f 	and.w	r3, r3, #15
 8004794:	429a      	cmp	r2, r3
 8004796:	d908      	bls.n	80047aa <HAL_RCC_ClockConfig+0x12a>
    {
      /* Set the new HCLK clock divider */
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8004798:	4b4a      	ldr	r3, [pc, #296]	; (80048c4 <HAL_RCC_ClockConfig+0x244>)
 800479a:	699b      	ldr	r3, [r3, #24]
 800479c:	f023 020f 	bic.w	r2, r3, #15
 80047a0:	687b      	ldr	r3, [r7, #4]
 80047a2:	68db      	ldr	r3, [r3, #12]
 80047a4:	4947      	ldr	r1, [pc, #284]	; (80048c4 <HAL_RCC_ClockConfig+0x244>)
 80047a6:	4313      	orrs	r3, r2
 80047a8:	618b      	str	r3, [r1, #24]
    }
#endif
  }

    /*------------------------- SYSCLK Configuration -------------------------*/
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80047aa:	687b      	ldr	r3, [r7, #4]
 80047ac:	681b      	ldr	r3, [r3, #0]
 80047ae:	f003 0301 	and.w	r3, r3, #1
 80047b2:	2b00      	cmp	r3, #0
 80047b4:	d055      	beq.n	8004862 <HAL_RCC_ClockConfig+0x1e2>
    {
      assert_param(IS_RCC_SYSCLK(RCC_ClkInitStruct->SYSCLKDivider));
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
#if defined(RCC_D1CFGR_D1CPRE)
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1CPRE, RCC_ClkInitStruct->SYSCLKDivider);
 80047b6:	4b43      	ldr	r3, [pc, #268]	; (80048c4 <HAL_RCC_ClockConfig+0x244>)
 80047b8:	699b      	ldr	r3, [r3, #24]
 80047ba:	f423 6270 	bic.w	r2, r3, #3840	; 0xf00
 80047be:	687b      	ldr	r3, [r7, #4]
 80047c0:	689b      	ldr	r3, [r3, #8]
 80047c2:	4940      	ldr	r1, [pc, #256]	; (80048c4 <HAL_RCC_ClockConfig+0x244>)
 80047c4:	4313      	orrs	r3, r2
 80047c6:	618b      	str	r3, [r1, #24]
#else
      MODIFY_REG(RCC->CDCFGR1, RCC_CDCFGR1_CDCPRE, RCC_ClkInitStruct->SYSCLKDivider);
#endif
      /* HSE is selected as System Clock Source */
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80047c8:	687b      	ldr	r3, [r7, #4]
 80047ca:	685b      	ldr	r3, [r3, #4]
 80047cc:	2b02      	cmp	r3, #2
 80047ce:	d107      	bne.n	80047e0 <HAL_RCC_ClockConfig+0x160>
      {
        /* Check the HSE ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 80047d0:	4b3c      	ldr	r3, [pc, #240]	; (80048c4 <HAL_RCC_ClockConfig+0x244>)
 80047d2:	681b      	ldr	r3, [r3, #0]
 80047d4:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80047d8:	2b00      	cmp	r3, #0
 80047da:	d121      	bne.n	8004820 <HAL_RCC_ClockConfig+0x1a0>
        {
          return HAL_ERROR;
 80047dc:	2301      	movs	r3, #1
 80047de:	e0f6      	b.n	80049ce <HAL_RCC_ClockConfig+0x34e>
        }
      }
      /* PLL is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80047e0:	687b      	ldr	r3, [r7, #4]
 80047e2:	685b      	ldr	r3, [r3, #4]
 80047e4:	2b03      	cmp	r3, #3
 80047e6:	d107      	bne.n	80047f8 <HAL_RCC_ClockConfig+0x178>
      {
        /* Check the PLL ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 80047e8:	4b36      	ldr	r3, [pc, #216]	; (80048c4 <HAL_RCC_ClockConfig+0x244>)
 80047ea:	681b      	ldr	r3, [r3, #0]
 80047ec:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80047f0:	2b00      	cmp	r3, #0
 80047f2:	d115      	bne.n	8004820 <HAL_RCC_ClockConfig+0x1a0>
        {
          return HAL_ERROR;
 80047f4:	2301      	movs	r3, #1
 80047f6:	e0ea      	b.n	80049ce <HAL_RCC_ClockConfig+0x34e>
        }
      }
      /* CSI is selected as System Clock Source */
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_CSI)
 80047f8:	687b      	ldr	r3, [r7, #4]
 80047fa:	685b      	ldr	r3, [r3, #4]
 80047fc:	2b01      	cmp	r3, #1
 80047fe:	d107      	bne.n	8004810 <HAL_RCC_ClockConfig+0x190>
      {
        /* Check the PLL ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
 8004800:	4b30      	ldr	r3, [pc, #192]	; (80048c4 <HAL_RCC_ClockConfig+0x244>)
 8004802:	681b      	ldr	r3, [r3, #0]
 8004804:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8004808:	2b00      	cmp	r3, #0
 800480a:	d109      	bne.n	8004820 <HAL_RCC_ClockConfig+0x1a0>
        {
          return HAL_ERROR;
 800480c:	2301      	movs	r3, #1
 800480e:	e0de      	b.n	80049ce <HAL_RCC_ClockConfig+0x34e>
      }
      /* HSI is selected as System Clock Source */
      else
      {
        /* Check the HSI ready flag */
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8004810:	4b2c      	ldr	r3, [pc, #176]	; (80048c4 <HAL_RCC_ClockConfig+0x244>)
 8004812:	681b      	ldr	r3, [r3, #0]
 8004814:	f003 0304 	and.w	r3, r3, #4
 8004818:	2b00      	cmp	r3, #0
 800481a:	d101      	bne.n	8004820 <HAL_RCC_ClockConfig+0x1a0>
        {
          return HAL_ERROR;
 800481c:	2301      	movs	r3, #1
 800481e:	e0d6      	b.n	80049ce <HAL_RCC_ClockConfig+0x34e>
        }
      }
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8004820:	4b28      	ldr	r3, [pc, #160]	; (80048c4 <HAL_RCC_ClockConfig+0x244>)
 8004822:	691b      	ldr	r3, [r3, #16]
 8004824:	f023 0207 	bic.w	r2, r3, #7
 8004828:	687b      	ldr	r3, [r7, #4]
 800482a:	685b      	ldr	r3, [r3, #4]
 800482c:	4925      	ldr	r1, [pc, #148]	; (80048c4 <HAL_RCC_ClockConfig+0x244>)
 800482e:	4313      	orrs	r3, r2
 8004830:	610b      	str	r3, [r1, #16]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8004832:	f7fb ff89 	bl	8000748 <HAL_GetTick>
 8004836:	6178      	str	r0, [r7, #20]

        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8004838:	e00a      	b.n	8004850 <HAL_RCC_ClockConfig+0x1d0>
        {
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800483a:	f7fb ff85 	bl	8000748 <HAL_GetTick>
 800483e:	4602      	mov	r2, r0
 8004840:	697b      	ldr	r3, [r7, #20]
 8004842:	1ad3      	subs	r3, r2, r3
 8004844:	f241 3288 	movw	r2, #5000	; 0x1388
 8004848:	4293      	cmp	r3, r2
 800484a:	d901      	bls.n	8004850 <HAL_RCC_ClockConfig+0x1d0>
          {
            return HAL_TIMEOUT;
 800484c:	2303      	movs	r3, #3
 800484e:	e0be      	b.n	80049ce <HAL_RCC_ClockConfig+0x34e>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8004850:	4b1c      	ldr	r3, [pc, #112]	; (80048c4 <HAL_RCC_ClockConfig+0x244>)
 8004852:	691b      	ldr	r3, [r3, #16]
 8004854:	f003 0238 	and.w	r2, r3, #56	; 0x38
 8004858:	687b      	ldr	r3, [r7, #4]
 800485a:	685b      	ldr	r3, [r3, #4]
 800485c:	00db      	lsls	r3, r3, #3
 800485e:	429a      	cmp	r2, r3
 8004860:	d1eb      	bne.n	800483a <HAL_RCC_ClockConfig+0x1ba>

    }

    /* Decreasing the BUS frequency divider */
   /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8004862:	687b      	ldr	r3, [r7, #4]
 8004864:	681b      	ldr	r3, [r3, #0]
 8004866:	f003 0302 	and.w	r3, r3, #2
 800486a:	2b00      	cmp	r3, #0
 800486c:	d010      	beq.n	8004890 <HAL_RCC_ClockConfig+0x210>
  {
#if defined(RCC_D1CFGR_HPRE)
    if((RCC_ClkInitStruct->AHBCLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_HPRE))
 800486e:	687b      	ldr	r3, [r7, #4]
 8004870:	68da      	ldr	r2, [r3, #12]
 8004872:	4b14      	ldr	r3, [pc, #80]	; (80048c4 <HAL_RCC_ClockConfig+0x244>)
 8004874:	699b      	ldr	r3, [r3, #24]
 8004876:	f003 030f 	and.w	r3, r3, #15
 800487a:	429a      	cmp	r2, r3
 800487c:	d208      	bcs.n	8004890 <HAL_RCC_ClockConfig+0x210>
    {
      /* Set the new HCLK clock divider */
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800487e:	4b11      	ldr	r3, [pc, #68]	; (80048c4 <HAL_RCC_ClockConfig+0x244>)
 8004880:	699b      	ldr	r3, [r3, #24]
 8004882:	f023 020f 	bic.w	r2, r3, #15
 8004886:	687b      	ldr	r3, [r7, #4]
 8004888:	68db      	ldr	r3, [r3, #12]
 800488a:	490e      	ldr	r1, [pc, #56]	; (80048c4 <HAL_RCC_ClockConfig+0x244>)
 800488c:	4313      	orrs	r3, r2
 800488e:	618b      	str	r3, [r1, #24]
    }
#endif
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8004890:	4b0b      	ldr	r3, [pc, #44]	; (80048c0 <HAL_RCC_ClockConfig+0x240>)
 8004892:	681b      	ldr	r3, [r3, #0]
 8004894:	f003 030f 	and.w	r3, r3, #15
 8004898:	683a      	ldr	r2, [r7, #0]
 800489a:	429a      	cmp	r2, r3
 800489c:	d214      	bcs.n	80048c8 <HAL_RCC_ClockConfig+0x248>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800489e:	4b08      	ldr	r3, [pc, #32]	; (80048c0 <HAL_RCC_ClockConfig+0x240>)
 80048a0:	681b      	ldr	r3, [r3, #0]
 80048a2:	f023 020f 	bic.w	r2, r3, #15
 80048a6:	4906      	ldr	r1, [pc, #24]	; (80048c0 <HAL_RCC_ClockConfig+0x240>)
 80048a8:	683b      	ldr	r3, [r7, #0]
 80048aa:	4313      	orrs	r3, r2
 80048ac:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80048ae:	4b04      	ldr	r3, [pc, #16]	; (80048c0 <HAL_RCC_ClockConfig+0x240>)
 80048b0:	681b      	ldr	r3, [r3, #0]
 80048b2:	f003 030f 	and.w	r3, r3, #15
 80048b6:	683a      	ldr	r2, [r7, #0]
 80048b8:	429a      	cmp	r2, r3
 80048ba:	d005      	beq.n	80048c8 <HAL_RCC_ClockConfig+0x248>
    {
      return HAL_ERROR;
 80048bc:	2301      	movs	r3, #1
 80048be:	e086      	b.n	80049ce <HAL_RCC_ClockConfig+0x34e>
 80048c0:	52002000 	.word	0x52002000
 80048c4:	58024400 	.word	0x58024400
    }
 }

  /*-------------------------- D1PCLK1/CDPCLK Configuration ---------------------------*/
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
 80048c8:	687b      	ldr	r3, [r7, #4]
 80048ca:	681b      	ldr	r3, [r3, #0]
 80048cc:	f003 0304 	and.w	r3, r3, #4
 80048d0:	2b00      	cmp	r3, #0
 80048d2:	d010      	beq.n	80048f6 <HAL_RCC_ClockConfig+0x276>
 {
#if defined(RCC_D1CFGR_D1PPRE)
   if((RCC_ClkInitStruct->APB3CLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
 80048d4:	687b      	ldr	r3, [r7, #4]
 80048d6:	691a      	ldr	r2, [r3, #16]
 80048d8:	4b3f      	ldr	r3, [pc, #252]	; (80049d8 <HAL_RCC_ClockConfig+0x358>)
 80048da:	699b      	ldr	r3, [r3, #24]
 80048dc:	f003 0370 	and.w	r3, r3, #112	; 0x70
 80048e0:	429a      	cmp	r2, r3
 80048e2:	d208      	bcs.n	80048f6 <HAL_RCC_ClockConfig+0x276>
   {
     assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
     MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
 80048e4:	4b3c      	ldr	r3, [pc, #240]	; (80049d8 <HAL_RCC_ClockConfig+0x358>)
 80048e6:	699b      	ldr	r3, [r3, #24]
 80048e8:	f023 0270 	bic.w	r2, r3, #112	; 0x70
 80048ec:	687b      	ldr	r3, [r7, #4]
 80048ee:	691b      	ldr	r3, [r3, #16]
 80048f0:	4939      	ldr	r1, [pc, #228]	; (80049d8 <HAL_RCC_ClockConfig+0x358>)
 80048f2:	4313      	orrs	r3, r2
 80048f4:	618b      	str	r3, [r1, #24]
   }
#endif
 }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80048f6:	687b      	ldr	r3, [r7, #4]
 80048f8:	681b      	ldr	r3, [r3, #0]
 80048fa:	f003 0308 	and.w	r3, r3, #8
 80048fe:	2b00      	cmp	r3, #0
 8004900:	d010      	beq.n	8004924 <HAL_RCC_ClockConfig+0x2a4>
 {
#if defined(RCC_D2CFGR_D2PPRE1)
   if((RCC_ClkInitStruct->APB1CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
 8004902:	687b      	ldr	r3, [r7, #4]
 8004904:	695a      	ldr	r2, [r3, #20]
 8004906:	4b34      	ldr	r3, [pc, #208]	; (80049d8 <HAL_RCC_ClockConfig+0x358>)
 8004908:	69db      	ldr	r3, [r3, #28]
 800490a:	f003 0370 	and.w	r3, r3, #112	; 0x70
 800490e:	429a      	cmp	r2, r3
 8004910:	d208      	bcs.n	8004924 <HAL_RCC_ClockConfig+0x2a4>
   {
     assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
 8004912:	4b31      	ldr	r3, [pc, #196]	; (80049d8 <HAL_RCC_ClockConfig+0x358>)
 8004914:	69db      	ldr	r3, [r3, #28]
 8004916:	f023 0270 	bic.w	r2, r3, #112	; 0x70
 800491a:	687b      	ldr	r3, [r7, #4]
 800491c:	695b      	ldr	r3, [r3, #20]
 800491e:	492e      	ldr	r1, [pc, #184]	; (80049d8 <HAL_RCC_ClockConfig+0x358>)
 8004920:	4313      	orrs	r3, r2
 8004922:	61cb      	str	r3, [r1, #28]
   }
#endif
 }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8004924:	687b      	ldr	r3, [r7, #4]
 8004926:	681b      	ldr	r3, [r3, #0]
 8004928:	f003 0310 	and.w	r3, r3, #16
 800492c:	2b00      	cmp	r3, #0
 800492e:	d010      	beq.n	8004952 <HAL_RCC_ClockConfig+0x2d2>
 {
#if defined (RCC_D2CFGR_D2PPRE2)
   if((RCC_ClkInitStruct->APB2CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
 8004930:	687b      	ldr	r3, [r7, #4]
 8004932:	699a      	ldr	r2, [r3, #24]
 8004934:	4b28      	ldr	r3, [pc, #160]	; (80049d8 <HAL_RCC_ClockConfig+0x358>)
 8004936:	69db      	ldr	r3, [r3, #28]
 8004938:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800493c:	429a      	cmp	r2, r3
 800493e:	d208      	bcs.n	8004952 <HAL_RCC_ClockConfig+0x2d2>
   {
     assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
 8004940:	4b25      	ldr	r3, [pc, #148]	; (80049d8 <HAL_RCC_ClockConfig+0x358>)
 8004942:	69db      	ldr	r3, [r3, #28]
 8004944:	f423 62e0 	bic.w	r2, r3, #1792	; 0x700
 8004948:	687b      	ldr	r3, [r7, #4]
 800494a:	699b      	ldr	r3, [r3, #24]
 800494c:	4922      	ldr	r1, [pc, #136]	; (80049d8 <HAL_RCC_ClockConfig+0x358>)
 800494e:	4313      	orrs	r3, r2
 8004950:	61cb      	str	r3, [r1, #28]
   }
#endif
 }

  /*-------------------------- D3PCLK1/SRDPCLK1 Configuration ---------------------------*/
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
 8004952:	687b      	ldr	r3, [r7, #4]
 8004954:	681b      	ldr	r3, [r3, #0]
 8004956:	f003 0320 	and.w	r3, r3, #32
 800495a:	2b00      	cmp	r3, #0
 800495c:	d010      	beq.n	8004980 <HAL_RCC_ClockConfig+0x300>
 {
#if defined(RCC_D3CFGR_D3PPRE)
   if((RCC_ClkInitStruct->APB4CLKDivider) < (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
 800495e:	687b      	ldr	r3, [r7, #4]
 8004960:	69da      	ldr	r2, [r3, #28]
 8004962:	4b1d      	ldr	r3, [pc, #116]	; (80049d8 <HAL_RCC_ClockConfig+0x358>)
 8004964:	6a1b      	ldr	r3, [r3, #32]
 8004966:	f003 0370 	and.w	r3, r3, #112	; 0x70
 800496a:	429a      	cmp	r2, r3
 800496c:	d208      	bcs.n	8004980 <HAL_RCC_ClockConfig+0x300>
   {
     assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
     MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
 800496e:	4b1a      	ldr	r3, [pc, #104]	; (80049d8 <HAL_RCC_ClockConfig+0x358>)
 8004970:	6a1b      	ldr	r3, [r3, #32]
 8004972:	f023 0270 	bic.w	r2, r3, #112	; 0x70
 8004976:	687b      	ldr	r3, [r7, #4]
 8004978:	69db      	ldr	r3, [r3, #28]
 800497a:	4917      	ldr	r1, [pc, #92]	; (80049d8 <HAL_RCC_ClockConfig+0x358>)
 800497c:	4313      	orrs	r3, r2
 800497e:	620b      	str	r3, [r1, #32]
#endif
 }

  /* Update the SystemCoreClock global variable */
#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 8004980:	f000 f89e 	bl	8004ac0 <HAL_RCC_GetSysClockFreq>
 8004984:	4602      	mov	r2, r0
 8004986:	4b14      	ldr	r3, [pc, #80]	; (80049d8 <HAL_RCC_ClockConfig+0x358>)
 8004988:	699b      	ldr	r3, [r3, #24]
 800498a:	0a1b      	lsrs	r3, r3, #8
 800498c:	f003 030f 	and.w	r3, r3, #15
 8004990:	4912      	ldr	r1, [pc, #72]	; (80049dc <HAL_RCC_ClockConfig+0x35c>)
 8004992:	5ccb      	ldrb	r3, [r1, r3]
 8004994:	f003 031f 	and.w	r3, r3, #31
 8004998:	fa22 f303 	lsr.w	r3, r2, r3
 800499c:	613b      	str	r3, [r7, #16]
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos]) & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 800499e:	4b0e      	ldr	r3, [pc, #56]	; (80049d8 <HAL_RCC_ClockConfig+0x358>)
 80049a0:	699b      	ldr	r3, [r3, #24]
 80049a2:	f003 030f 	and.w	r3, r3, #15
 80049a6:	4a0d      	ldr	r2, [pc, #52]	; (80049dc <HAL_RCC_ClockConfig+0x35c>)
 80049a8:	5cd3      	ldrb	r3, [r2, r3]
 80049aa:	f003 031f 	and.w	r3, r3, #31
 80049ae:	693a      	ldr	r2, [r7, #16]
 80049b0:	fa22 f303 	lsr.w	r3, r2, r3
 80049b4:	4a0a      	ldr	r2, [pc, #40]	; (80049e0 <HAL_RCC_ClockConfig+0x360>)
 80049b6:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
 80049b8:	4a0a      	ldr	r2, [pc, #40]	; (80049e4 <HAL_RCC_ClockConfig+0x364>)
 80049ba:	693b      	ldr	r3, [r7, #16]
 80049bc:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  /* Configure the source of time base considering new system clocks settings*/
  halstatus = HAL_InitTick (uwTickPrio);
 80049be:	4b0a      	ldr	r3, [pc, #40]	; (80049e8 <HAL_RCC_ClockConfig+0x368>)
 80049c0:	681b      	ldr	r3, [r3, #0]
 80049c2:	4618      	mov	r0, r3
 80049c4:	f00d fa2c 	bl	8011e20 <HAL_InitTick>
 80049c8:	4603      	mov	r3, r0
 80049ca:	73fb      	strb	r3, [r7, #15]

  return halstatus;
 80049cc:	7bfb      	ldrb	r3, [r7, #15]
}
 80049ce:	4618      	mov	r0, r3
 80049d0:	3718      	adds	r7, #24
 80049d2:	46bd      	mov	sp, r7
 80049d4:	bd80      	pop	{r7, pc}
 80049d6:	bf00      	nop
 80049d8:	58024400 	.word	0x58024400
 80049dc:	080d9c9c 	.word	0x080d9c9c
 80049e0:	240001a8 	.word	0x240001a8
 80049e4:	240001a4 	.word	0x240001a4
 80049e8:	24000000 	.word	0x24000000

080049ec <HAL_RCC_MCOConfig>:
  *          This parameter can be one of the following values:
  *            @arg RCC_MCODIV_1 up to RCC_MCODIV_15  : divider applied to MCOx clock
  * @retval None
  */
void HAL_RCC_MCOConfig(uint32_t RCC_MCOx, uint32_t RCC_MCOSource, uint32_t RCC_MCODiv)
{
 80049ec:	b580      	push	{r7, lr}
 80049ee:	b08c      	sub	sp, #48	; 0x30
 80049f0:	af00      	add	r7, sp, #0
 80049f2:	60f8      	str	r0, [r7, #12]
 80049f4:	60b9      	str	r1, [r7, #8]
 80049f6:	607a      	str	r2, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct;
  /* Check the parameters */
  assert_param(IS_RCC_MCO(RCC_MCOx));
  assert_param(IS_RCC_MCODIV(RCC_MCODiv));
  /* RCC_MCO1 */
  if(RCC_MCOx == RCC_MCO1)
 80049f8:	68fb      	ldr	r3, [r7, #12]
 80049fa:	2b00      	cmp	r3, #0
 80049fc:	d12a      	bne.n	8004a54 <HAL_RCC_MCOConfig+0x68>
  {
    assert_param(IS_RCC_MCO1SOURCE(RCC_MCOSource));

    /* MCO1 Clock Enable */
    MCO1_CLK_ENABLE();
 80049fe:	4b2d      	ldr	r3, [pc, #180]	; (8004ab4 <HAL_RCC_MCOConfig+0xc8>)
 8004a00:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8004a04:	4a2b      	ldr	r2, [pc, #172]	; (8004ab4 <HAL_RCC_MCOConfig+0xc8>)
 8004a06:	f043 0301 	orr.w	r3, r3, #1
 8004a0a:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 8004a0e:	4b29      	ldr	r3, [pc, #164]	; (8004ab4 <HAL_RCC_MCOConfig+0xc8>)
 8004a10:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8004a14:	f003 0301 	and.w	r3, r3, #1
 8004a18:	61bb      	str	r3, [r7, #24]
 8004a1a:	69bb      	ldr	r3, [r7, #24]

    /* Configure the MCO1 pin in alternate function mode */
    GPIO_InitStruct.Pin = MCO1_PIN;
 8004a1c:	f44f 7380 	mov.w	r3, #256	; 0x100
 8004a20:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8004a22:	2302      	movs	r3, #2
 8004a24:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8004a26:	2303      	movs	r3, #3
 8004a28:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8004a2a:	2300      	movs	r3, #0
 8004a2c:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
 8004a2e:	2300      	movs	r3, #0
 8004a30:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(MCO1_GPIO_PORT, &GPIO_InitStruct);
 8004a32:	f107 031c 	add.w	r3, r7, #28
 8004a36:	4619      	mov	r1, r3
 8004a38:	481f      	ldr	r0, [pc, #124]	; (8004ab8 <HAL_RCC_MCOConfig+0xcc>)
 8004a3a:	f7fe ffb5 	bl	80039a8 <HAL_GPIO_Init>

    /* Mask MCO1 and MCO1PRE[3:0] bits then Select MCO1 clock source and pre-scaler */
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO1 | RCC_CFGR_MCO1PRE), (RCC_MCOSource | RCC_MCODiv));
 8004a3e:	4b1d      	ldr	r3, [pc, #116]	; (8004ab4 <HAL_RCC_MCOConfig+0xc8>)
 8004a40:	691b      	ldr	r3, [r3, #16]
 8004a42:	f023 72fe 	bic.w	r2, r3, #33292288	; 0x1fc0000
 8004a46:	68b9      	ldr	r1, [r7, #8]
 8004a48:	687b      	ldr	r3, [r7, #4]
 8004a4a:	430b      	orrs	r3, r1
 8004a4c:	4919      	ldr	r1, [pc, #100]	; (8004ab4 <HAL_RCC_MCOConfig+0xc8>)
 8004a4e:	4313      	orrs	r3, r2
 8004a50:	610b      	str	r3, [r1, #16]
    HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);

    /* Mask MCO2 and MCO2PRE[3:0] bits then Select MCO2 clock source and pre-scaler */
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 7U)));
  }
}
 8004a52:	e02a      	b.n	8004aaa <HAL_RCC_MCOConfig+0xbe>
    MCO2_CLK_ENABLE();
 8004a54:	4b17      	ldr	r3, [pc, #92]	; (8004ab4 <HAL_RCC_MCOConfig+0xc8>)
 8004a56:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8004a5a:	4a16      	ldr	r2, [pc, #88]	; (8004ab4 <HAL_RCC_MCOConfig+0xc8>)
 8004a5c:	f043 0304 	orr.w	r3, r3, #4
 8004a60:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 8004a64:	4b13      	ldr	r3, [pc, #76]	; (8004ab4 <HAL_RCC_MCOConfig+0xc8>)
 8004a66:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8004a6a:	f003 0304 	and.w	r3, r3, #4
 8004a6e:	617b      	str	r3, [r7, #20]
 8004a70:	697b      	ldr	r3, [r7, #20]
    GPIO_InitStruct.Pin = MCO2_PIN;
 8004a72:	f44f 7300 	mov.w	r3, #512	; 0x200
 8004a76:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8004a78:	2302      	movs	r3, #2
 8004a7a:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8004a7c:	2303      	movs	r3, #3
 8004a7e:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8004a80:	2300      	movs	r3, #0
 8004a82:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
 8004a84:	2300      	movs	r3, #0
 8004a86:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(MCO2_GPIO_PORT, &GPIO_InitStruct);
 8004a88:	f107 031c 	add.w	r3, r7, #28
 8004a8c:	4619      	mov	r1, r3
 8004a8e:	480b      	ldr	r0, [pc, #44]	; (8004abc <HAL_RCC_MCOConfig+0xd0>)
 8004a90:	f7fe ff8a 	bl	80039a8 <HAL_GPIO_Init>
    MODIFY_REG(RCC->CFGR, (RCC_CFGR_MCO2 | RCC_CFGR_MCO2PRE), (RCC_MCOSource | (RCC_MCODiv << 7U)));
 8004a94:	4b07      	ldr	r3, [pc, #28]	; (8004ab4 <HAL_RCC_MCOConfig+0xc8>)
 8004a96:	691b      	ldr	r3, [r3, #16]
 8004a98:	f023 427e 	bic.w	r2, r3, #4261412864	; 0xfe000000
 8004a9c:	687b      	ldr	r3, [r7, #4]
 8004a9e:	01d9      	lsls	r1, r3, #7
 8004aa0:	68bb      	ldr	r3, [r7, #8]
 8004aa2:	430b      	orrs	r3, r1
 8004aa4:	4903      	ldr	r1, [pc, #12]	; (8004ab4 <HAL_RCC_MCOConfig+0xc8>)
 8004aa6:	4313      	orrs	r3, r2
 8004aa8:	610b      	str	r3, [r1, #16]
}
 8004aaa:	bf00      	nop
 8004aac:	3730      	adds	r7, #48	; 0x30
 8004aae:	46bd      	mov	sp, r7
 8004ab0:	bd80      	pop	{r7, pc}
 8004ab2:	bf00      	nop
 8004ab4:	58024400 	.word	0x58024400
 8004ab8:	58020000 	.word	0x58020000
 8004abc:	58020800 	.word	0x58020800

08004ac0 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8004ac0:	b480      	push	{r7}
 8004ac2:	b089      	sub	sp, #36	; 0x24
 8004ac4:	af00      	add	r7, sp, #0
  float_t fracn1, pllvco;
  uint32_t sysclockfreq;

  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
 8004ac6:	4bb3      	ldr	r3, [pc, #716]	; (8004d94 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8004ac8:	691b      	ldr	r3, [r3, #16]
 8004aca:	f003 0338 	and.w	r3, r3, #56	; 0x38
 8004ace:	2b18      	cmp	r3, #24
 8004ad0:	f200 8155 	bhi.w	8004d7e <HAL_RCC_GetSysClockFreq+0x2be>
 8004ad4:	a201      	add	r2, pc, #4	; (adr r2, 8004adc <HAL_RCC_GetSysClockFreq+0x1c>)
 8004ad6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8004ada:	bf00      	nop
 8004adc:	08004b41 	.word	0x08004b41
 8004ae0:	08004d7f 	.word	0x08004d7f
 8004ae4:	08004d7f 	.word	0x08004d7f
 8004ae8:	08004d7f 	.word	0x08004d7f
 8004aec:	08004d7f 	.word	0x08004d7f
 8004af0:	08004d7f 	.word	0x08004d7f
 8004af4:	08004d7f 	.word	0x08004d7f
 8004af8:	08004d7f 	.word	0x08004d7f
 8004afc:	08004b67 	.word	0x08004b67
 8004b00:	08004d7f 	.word	0x08004d7f
 8004b04:	08004d7f 	.word	0x08004d7f
 8004b08:	08004d7f 	.word	0x08004d7f
 8004b0c:	08004d7f 	.word	0x08004d7f
 8004b10:	08004d7f 	.word	0x08004d7f
 8004b14:	08004d7f 	.word	0x08004d7f
 8004b18:	08004d7f 	.word	0x08004d7f
 8004b1c:	08004b6d 	.word	0x08004b6d
 8004b20:	08004d7f 	.word	0x08004d7f
 8004b24:	08004d7f 	.word	0x08004d7f
 8004b28:	08004d7f 	.word	0x08004d7f
 8004b2c:	08004d7f 	.word	0x08004d7f
 8004b30:	08004d7f 	.word	0x08004d7f
 8004b34:	08004d7f 	.word	0x08004d7f
 8004b38:	08004d7f 	.word	0x08004d7f
 8004b3c:	08004b73 	.word	0x08004b73
  {
  case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */

   if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8004b40:	4b94      	ldr	r3, [pc, #592]	; (8004d94 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8004b42:	681b      	ldr	r3, [r3, #0]
 8004b44:	f003 0320 	and.w	r3, r3, #32
 8004b48:	2b00      	cmp	r3, #0
 8004b4a:	d009      	beq.n	8004b60 <HAL_RCC_GetSysClockFreq+0xa0>
      {
        sysclockfreq = (uint32_t) (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 8004b4c:	4b91      	ldr	r3, [pc, #580]	; (8004d94 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8004b4e:	681b      	ldr	r3, [r3, #0]
 8004b50:	08db      	lsrs	r3, r3, #3
 8004b52:	f003 0303 	and.w	r3, r3, #3
 8004b56:	4a90      	ldr	r2, [pc, #576]	; (8004d98 <HAL_RCC_GetSysClockFreq+0x2d8>)
 8004b58:	fa22 f303 	lsr.w	r3, r2, r3
 8004b5c:	61bb      	str	r3, [r7, #24]
      else
      {
        sysclockfreq = (uint32_t) HSI_VALUE;
      }

    break;
 8004b5e:	e111      	b.n	8004d84 <HAL_RCC_GetSysClockFreq+0x2c4>
        sysclockfreq = (uint32_t) HSI_VALUE;
 8004b60:	4b8d      	ldr	r3, [pc, #564]	; (8004d98 <HAL_RCC_GetSysClockFreq+0x2d8>)
 8004b62:	61bb      	str	r3, [r7, #24]
    break;
 8004b64:	e10e      	b.n	8004d84 <HAL_RCC_GetSysClockFreq+0x2c4>

  case RCC_CFGR_SWS_CSI:  /* CSI used as system clock  source */
    sysclockfreq = CSI_VALUE;
 8004b66:	4b8d      	ldr	r3, [pc, #564]	; (8004d9c <HAL_RCC_GetSysClockFreq+0x2dc>)
 8004b68:	61bb      	str	r3, [r7, #24]
    break;
 8004b6a:	e10b      	b.n	8004d84 <HAL_RCC_GetSysClockFreq+0x2c4>

  case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    sysclockfreq = HSE_VALUE;
 8004b6c:	4b8c      	ldr	r3, [pc, #560]	; (8004da0 <HAL_RCC_GetSysClockFreq+0x2e0>)
 8004b6e:	61bb      	str	r3, [r7, #24]
    break;
 8004b70:	e108      	b.n	8004d84 <HAL_RCC_GetSysClockFreq+0x2c4>
  case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 8004b72:	4b88      	ldr	r3, [pc, #544]	; (8004d94 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8004b74:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004b76:	f003 0303 	and.w	r3, r3, #3
 8004b7a:	617b      	str	r3, [r7, #20]
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
 8004b7c:	4b85      	ldr	r3, [pc, #532]	; (8004d94 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8004b7e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004b80:	091b      	lsrs	r3, r3, #4
 8004b82:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8004b86:	613b      	str	r3, [r7, #16]
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
 8004b88:	4b82      	ldr	r3, [pc, #520]	; (8004d94 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8004b8a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004b8c:	f003 0301 	and.w	r3, r3, #1
 8004b90:	60fb      	str	r3, [r7, #12]
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 8004b92:	4b80      	ldr	r3, [pc, #512]	; (8004d94 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8004b94:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004b96:	08db      	lsrs	r3, r3, #3
 8004b98:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8004b9c:	68fa      	ldr	r2, [r7, #12]
 8004b9e:	fb02 f303 	mul.w	r3, r2, r3
 8004ba2:	ee07 3a90 	vmov	s15, r3
 8004ba6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8004baa:	edc7 7a02 	vstr	s15, [r7, #8]

    if (pllm != 0U)
 8004bae:	693b      	ldr	r3, [r7, #16]
 8004bb0:	2b00      	cmp	r3, #0
 8004bb2:	f000 80e1 	beq.w	8004d78 <HAL_RCC_GetSysClockFreq+0x2b8>
 8004bb6:	697b      	ldr	r3, [r7, #20]
 8004bb8:	2b02      	cmp	r3, #2
 8004bba:	f000 8083 	beq.w	8004cc4 <HAL_RCC_GetSysClockFreq+0x204>
 8004bbe:	697b      	ldr	r3, [r7, #20]
 8004bc0:	2b02      	cmp	r3, #2
 8004bc2:	f200 80a1 	bhi.w	8004d08 <HAL_RCC_GetSysClockFreq+0x248>
 8004bc6:	697b      	ldr	r3, [r7, #20]
 8004bc8:	2b00      	cmp	r3, #0
 8004bca:	d003      	beq.n	8004bd4 <HAL_RCC_GetSysClockFreq+0x114>
 8004bcc:	697b      	ldr	r3, [r7, #20]
 8004bce:	2b01      	cmp	r3, #1
 8004bd0:	d056      	beq.n	8004c80 <HAL_RCC_GetSysClockFreq+0x1c0>
 8004bd2:	e099      	b.n	8004d08 <HAL_RCC_GetSysClockFreq+0x248>
    {
      switch (pllsource)
      {
      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

       if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8004bd4:	4b6f      	ldr	r3, [pc, #444]	; (8004d94 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8004bd6:	681b      	ldr	r3, [r3, #0]
 8004bd8:	f003 0320 	and.w	r3, r3, #32
 8004bdc:	2b00      	cmp	r3, #0
 8004bde:	d02d      	beq.n	8004c3c <HAL_RCC_GetSysClockFreq+0x17c>
        {
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 8004be0:	4b6c      	ldr	r3, [pc, #432]	; (8004d94 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8004be2:	681b      	ldr	r3, [r3, #0]
 8004be4:	08db      	lsrs	r3, r3, #3
 8004be6:	f003 0303 	and.w	r3, r3, #3
 8004bea:	4a6b      	ldr	r2, [pc, #428]	; (8004d98 <HAL_RCC_GetSysClockFreq+0x2d8>)
 8004bec:	fa22 f303 	lsr.w	r3, r2, r3
 8004bf0:	607b      	str	r3, [r7, #4]
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8004bf2:	687b      	ldr	r3, [r7, #4]
 8004bf4:	ee07 3a90 	vmov	s15, r3
 8004bf8:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8004bfc:	693b      	ldr	r3, [r7, #16]
 8004bfe:	ee07 3a90 	vmov	s15, r3
 8004c02:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8004c06:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8004c0a:	4b62      	ldr	r3, [pc, #392]	; (8004d94 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8004c0c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8004c0e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8004c12:	ee07 3a90 	vmov	s15, r3
 8004c16:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8004c1a:	ed97 6a02 	vldr	s12, [r7, #8]
 8004c1e:	eddf 5a61 	vldr	s11, [pc, #388]	; 8004da4 <HAL_RCC_GetSysClockFreq+0x2e4>
 8004c22:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8004c26:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8004c2a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8004c2e:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8004c32:	ee67 7a27 	vmul.f32	s15, s14, s15
 8004c36:	edc7 7a07 	vstr	s15, [r7, #28]
        }
        else
        {
          pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
        }
        break;
 8004c3a:	e087      	b.n	8004d4c <HAL_RCC_GetSysClockFreq+0x28c>
          pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8004c3c:	693b      	ldr	r3, [r7, #16]
 8004c3e:	ee07 3a90 	vmov	s15, r3
 8004c42:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8004c46:	eddf 6a58 	vldr	s13, [pc, #352]	; 8004da8 <HAL_RCC_GetSysClockFreq+0x2e8>
 8004c4a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8004c4e:	4b51      	ldr	r3, [pc, #324]	; (8004d94 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8004c50:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8004c52:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8004c56:	ee07 3a90 	vmov	s15, r3
 8004c5a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8004c5e:	ed97 6a02 	vldr	s12, [r7, #8]
 8004c62:	eddf 5a50 	vldr	s11, [pc, #320]	; 8004da4 <HAL_RCC_GetSysClockFreq+0x2e4>
 8004c66:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8004c6a:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8004c6e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8004c72:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8004c76:	ee67 7a27 	vmul.f32	s15, s14, s15
 8004c7a:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 8004c7e:	e065      	b.n	8004d4c <HAL_RCC_GetSysClockFreq+0x28c>

      case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8004c80:	693b      	ldr	r3, [r7, #16]
 8004c82:	ee07 3a90 	vmov	s15, r3
 8004c86:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8004c8a:	eddf 6a48 	vldr	s13, [pc, #288]	; 8004dac <HAL_RCC_GetSysClockFreq+0x2ec>
 8004c8e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8004c92:	4b40      	ldr	r3, [pc, #256]	; (8004d94 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8004c94:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8004c96:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8004c9a:	ee07 3a90 	vmov	s15, r3
 8004c9e:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8004ca2:	ed97 6a02 	vldr	s12, [r7, #8]
 8004ca6:	eddf 5a3f 	vldr	s11, [pc, #252]	; 8004da4 <HAL_RCC_GetSysClockFreq+0x2e4>
 8004caa:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8004cae:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8004cb2:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8004cb6:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8004cba:	ee67 7a27 	vmul.f32	s15, s14, s15
 8004cbe:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 8004cc2:	e043      	b.n	8004d4c <HAL_RCC_GetSysClockFreq+0x28c>

      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8004cc4:	693b      	ldr	r3, [r7, #16]
 8004cc6:	ee07 3a90 	vmov	s15, r3
 8004cca:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8004cce:	eddf 6a38 	vldr	s13, [pc, #224]	; 8004db0 <HAL_RCC_GetSysClockFreq+0x2f0>
 8004cd2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8004cd6:	4b2f      	ldr	r3, [pc, #188]	; (8004d94 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8004cd8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8004cda:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8004cde:	ee07 3a90 	vmov	s15, r3
 8004ce2:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8004ce6:	ed97 6a02 	vldr	s12, [r7, #8]
 8004cea:	eddf 5a2e 	vldr	s11, [pc, #184]	; 8004da4 <HAL_RCC_GetSysClockFreq+0x2e4>
 8004cee:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8004cf2:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8004cf6:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8004cfa:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8004cfe:	ee67 7a27 	vmul.f32	s15, s14, s15
 8004d02:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 8004d06:	e021      	b.n	8004d4c <HAL_RCC_GetSysClockFreq+0x28c>

      default:
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8004d08:	693b      	ldr	r3, [r7, #16]
 8004d0a:	ee07 3a90 	vmov	s15, r3
 8004d0e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8004d12:	eddf 6a26 	vldr	s13, [pc, #152]	; 8004dac <HAL_RCC_GetSysClockFreq+0x2ec>
 8004d16:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8004d1a:	4b1e      	ldr	r3, [pc, #120]	; (8004d94 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8004d1c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8004d1e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8004d22:	ee07 3a90 	vmov	s15, r3
 8004d26:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8004d2a:	ed97 6a02 	vldr	s12, [r7, #8]
 8004d2e:	eddf 5a1d 	vldr	s11, [pc, #116]	; 8004da4 <HAL_RCC_GetSysClockFreq+0x2e4>
 8004d32:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8004d36:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8004d3a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8004d3e:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8004d42:	ee67 7a27 	vmul.f32	s15, s14, s15
 8004d46:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 8004d4a:	bf00      	nop
      }
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
 8004d4c:	4b11      	ldr	r3, [pc, #68]	; (8004d94 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8004d4e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8004d50:	0a5b      	lsrs	r3, r3, #9
 8004d52:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8004d56:	3301      	adds	r3, #1
 8004d58:	603b      	str	r3, [r7, #0]
      sysclockfreq =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
 8004d5a:	683b      	ldr	r3, [r7, #0]
 8004d5c:	ee07 3a90 	vmov	s15, r3
 8004d60:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 8004d64:	edd7 6a07 	vldr	s13, [r7, #28]
 8004d68:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8004d6c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8004d70:	ee17 3a90 	vmov	r3, s15
 8004d74:	61bb      	str	r3, [r7, #24]
    }
    else
    {
      sysclockfreq = 0U;
    }
    break;
 8004d76:	e005      	b.n	8004d84 <HAL_RCC_GetSysClockFreq+0x2c4>
      sysclockfreq = 0U;
 8004d78:	2300      	movs	r3, #0
 8004d7a:	61bb      	str	r3, [r7, #24]
    break;
 8004d7c:	e002      	b.n	8004d84 <HAL_RCC_GetSysClockFreq+0x2c4>

  default:
    sysclockfreq = CSI_VALUE;
 8004d7e:	4b07      	ldr	r3, [pc, #28]	; (8004d9c <HAL_RCC_GetSysClockFreq+0x2dc>)
 8004d80:	61bb      	str	r3, [r7, #24]
    break;
 8004d82:	bf00      	nop
  }

  return sysclockfreq;
 8004d84:	69bb      	ldr	r3, [r7, #24]
}
 8004d86:	4618      	mov	r0, r3
 8004d88:	3724      	adds	r7, #36	; 0x24
 8004d8a:	46bd      	mov	sp, r7
 8004d8c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004d90:	4770      	bx	lr
 8004d92:	bf00      	nop
 8004d94:	58024400 	.word	0x58024400
 8004d98:	03d09000 	.word	0x03d09000
 8004d9c:	003d0900 	.word	0x003d0900
 8004da0:	01e84800 	.word	0x01e84800
 8004da4:	46000000 	.word	0x46000000
 8004da8:	4c742400 	.word	0x4c742400
 8004dac:	4a742400 	.word	0x4a742400
 8004db0:	4bf42400 	.word	0x4bf42400

08004db4 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemD2Clock CMSIS variable is used to store System domain2 Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8004db4:	b580      	push	{r7, lr}
 8004db6:	b082      	sub	sp, #8
 8004db8:	af00      	add	r7, sp, #0
uint32_t common_system_clock;

#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 8004dba:	f7ff fe81 	bl	8004ac0 <HAL_RCC_GetSysClockFreq>
 8004dbe:	4602      	mov	r2, r0
 8004dc0:	4b10      	ldr	r3, [pc, #64]	; (8004e04 <HAL_RCC_GetHCLKFreq+0x50>)
 8004dc2:	699b      	ldr	r3, [r3, #24]
 8004dc4:	0a1b      	lsrs	r3, r3, #8
 8004dc6:	f003 030f 	and.w	r3, r3, #15
 8004dca:	490f      	ldr	r1, [pc, #60]	; (8004e08 <HAL_RCC_GetHCLKFreq+0x54>)
 8004dcc:	5ccb      	ldrb	r3, [r1, r3]
 8004dce:	f003 031f 	and.w	r3, r3, #31
 8004dd2:	fa22 f303 	lsr.w	r3, r2, r3
 8004dd6:	607b      	str	r3, [r7, #4]
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8004dd8:	4b0a      	ldr	r3, [pc, #40]	; (8004e04 <HAL_RCC_GetHCLKFreq+0x50>)
 8004dda:	699b      	ldr	r3, [r3, #24]
 8004ddc:	f003 030f 	and.w	r3, r3, #15
 8004de0:	4a09      	ldr	r2, [pc, #36]	; (8004e08 <HAL_RCC_GetHCLKFreq+0x54>)
 8004de2:	5cd3      	ldrb	r3, [r2, r3]
 8004de4:	f003 031f 	and.w	r3, r3, #31
 8004de8:	687a      	ldr	r2, [r7, #4]
 8004dea:	fa22 f303 	lsr.w	r3, r2, r3
 8004dee:	4a07      	ldr	r2, [pc, #28]	; (8004e0c <HAL_RCC_GetHCLKFreq+0x58>)
 8004df0:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
 8004df2:	4a07      	ldr	r2, [pc, #28]	; (8004e10 <HAL_RCC_GetHCLKFreq+0x5c>)
 8004df4:	687b      	ldr	r3, [r7, #4]
 8004df6:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  return SystemD2Clock;
 8004df8:	4b04      	ldr	r3, [pc, #16]	; (8004e0c <HAL_RCC_GetHCLKFreq+0x58>)
 8004dfa:	681b      	ldr	r3, [r3, #0]
}
 8004dfc:	4618      	mov	r0, r3
 8004dfe:	3708      	adds	r7, #8
 8004e00:	46bd      	mov	sp, r7
 8004e02:	bd80      	pop	{r7, pc}
 8004e04:	58024400 	.word	0x58024400
 8004e08:	080d9c9c 	.word	0x080d9c9c
 8004e0c:	240001a8 	.word	0x240001a8
 8004e10:	240001a4 	.word	0x240001a4

08004e14 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 8004e14:	b580      	push	{r7, lr}
 8004e16:	af00      	add	r7, sp, #0
#if defined (RCC_D2CFGR_D2PPRE1)
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1)>> RCC_D2CFGR_D2PPRE1_Pos]) & 0x1FU));
 8004e18:	f7ff ffcc 	bl	8004db4 <HAL_RCC_GetHCLKFreq>
 8004e1c:	4602      	mov	r2, r0
 8004e1e:	4b06      	ldr	r3, [pc, #24]	; (8004e38 <HAL_RCC_GetPCLK1Freq+0x24>)
 8004e20:	69db      	ldr	r3, [r3, #28]
 8004e22:	091b      	lsrs	r3, r3, #4
 8004e24:	f003 0307 	and.w	r3, r3, #7
 8004e28:	4904      	ldr	r1, [pc, #16]	; (8004e3c <HAL_RCC_GetPCLK1Freq+0x28>)
 8004e2a:	5ccb      	ldrb	r3, [r1, r3]
 8004e2c:	f003 031f 	and.w	r3, r3, #31
 8004e30:	fa22 f303 	lsr.w	r3, r2, r3
#else
 /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE1)>> RCC_CDCFGR2_CDPPRE1_Pos]) & 0x1FU));
#endif
}
 8004e34:	4618      	mov	r0, r3
 8004e36:	bd80      	pop	{r7, pc}
 8004e38:	58024400 	.word	0x58024400
 8004e3c:	080d9c9c 	.word	0x080d9c9c

08004e40 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 8004e40:	b580      	push	{r7, lr}
 8004e42:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
#if defined(RCC_D2CFGR_D2PPRE2)
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2)>> RCC_D2CFGR_D2PPRE2_Pos]) & 0x1FU));
 8004e44:	f7ff ffb6 	bl	8004db4 <HAL_RCC_GetHCLKFreq>
 8004e48:	4602      	mov	r2, r0
 8004e4a:	4b06      	ldr	r3, [pc, #24]	; (8004e64 <HAL_RCC_GetPCLK2Freq+0x24>)
 8004e4c:	69db      	ldr	r3, [r3, #28]
 8004e4e:	0a1b      	lsrs	r3, r3, #8
 8004e50:	f003 0307 	and.w	r3, r3, #7
 8004e54:	4904      	ldr	r1, [pc, #16]	; (8004e68 <HAL_RCC_GetPCLK2Freq+0x28>)
 8004e56:	5ccb      	ldrb	r3, [r1, r3]
 8004e58:	f003 031f 	and.w	r3, r3, #31
 8004e5c:	fa22 f303 	lsr.w	r3, r2, r3
#else
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE2)>> RCC_CDCFGR2_CDPPRE2_Pos]) & 0x1FU));
#endif
}
 8004e60:	4618      	mov	r0, r3
 8004e62:	bd80      	pop	{r7, pc}
 8004e64:	58024400 	.word	0x58024400
 8004e68:	080d9c9c 	.word	0x080d9c9c

08004e6c <HAL_RCC_GetClockConfig>:
  * will be configured.
  * @param  pFLatency: Pointer on the Flash Latency.
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
{
 8004e6c:	b480      	push	{r7}
 8004e6e:	b083      	sub	sp, #12
 8004e70:	af00      	add	r7, sp, #0
 8004e72:	6078      	str	r0, [r7, #4]
 8004e74:	6039      	str	r1, [r7, #0]
  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_D1PCLK1 | RCC_CLOCKTYPE_PCLK1 |
 8004e76:	687b      	ldr	r3, [r7, #4]
 8004e78:	223f      	movs	r2, #63	; 0x3f
 8004e7a:	601a      	str	r2, [r3, #0]
                                 RCC_CLOCKTYPE_PCLK2 |  RCC_CLOCKTYPE_D3PCLK1  ;

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8004e7c:	4b1a      	ldr	r3, [pc, #104]	; (8004ee8 <HAL_RCC_GetClockConfig+0x7c>)
 8004e7e:	691b      	ldr	r3, [r3, #16]
 8004e80:	f003 0207 	and.w	r2, r3, #7
 8004e84:	687b      	ldr	r3, [r7, #4]
 8004e86:	605a      	str	r2, [r3, #4]

#if defined(RCC_D1CFGR_D1CPRE)
  /* Get the SYSCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_D1CPRE);
 8004e88:	4b17      	ldr	r3, [pc, #92]	; (8004ee8 <HAL_RCC_GetClockConfig+0x7c>)
 8004e8a:	699b      	ldr	r3, [r3, #24]
 8004e8c:	f403 6270 	and.w	r2, r3, #3840	; 0xf00
 8004e90:	687b      	ldr	r3, [r7, #4]
 8004e92:	609a      	str	r2, [r3, #8]

  /* Get the D1HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_HPRE);
 8004e94:	4b14      	ldr	r3, [pc, #80]	; (8004ee8 <HAL_RCC_GetClockConfig+0x7c>)
 8004e96:	699b      	ldr	r3, [r3, #24]
 8004e98:	f003 020f 	and.w	r2, r3, #15
 8004e9c:	687b      	ldr	r3, [r7, #4]
 8004e9e:	60da      	str	r2, [r3, #12]

  /* Get the APB3 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB3CLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_D1PPRE);
 8004ea0:	4b11      	ldr	r3, [pc, #68]	; (8004ee8 <HAL_RCC_GetClockConfig+0x7c>)
 8004ea2:	699b      	ldr	r3, [r3, #24]
 8004ea4:	f003 0270 	and.w	r2, r3, #112	; 0x70
 8004ea8:	687b      	ldr	r3, [r7, #4]
 8004eaa:	611a      	str	r2, [r3, #16]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1);
 8004eac:	4b0e      	ldr	r3, [pc, #56]	; (8004ee8 <HAL_RCC_GetClockConfig+0x7c>)
 8004eae:	69db      	ldr	r3, [r3, #28]
 8004eb0:	f003 0270 	and.w	r2, r3, #112	; 0x70
 8004eb4:	687b      	ldr	r3, [r7, #4]
 8004eb6:	615a      	str	r2, [r3, #20]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2);
 8004eb8:	4b0b      	ldr	r3, [pc, #44]	; (8004ee8 <HAL_RCC_GetClockConfig+0x7c>)
 8004eba:	69db      	ldr	r3, [r3, #28]
 8004ebc:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
 8004ec0:	687b      	ldr	r3, [r7, #4]
 8004ec2:	619a      	str	r2, [r3, #24]

  /* Get the APB4 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->D3CFGR & RCC_D3CFGR_D3PPRE);
 8004ec4:	4b08      	ldr	r3, [pc, #32]	; (8004ee8 <HAL_RCC_GetClockConfig+0x7c>)
 8004ec6:	6a1b      	ldr	r3, [r3, #32]
 8004ec8:	f003 0270 	and.w	r2, r3, #112	; 0x70
 8004ecc:	687b      	ldr	r3, [r7, #4]
 8004ece:	61da      	str	r2, [r3, #28]
  /* Get the APB4 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE);
#endif

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 8004ed0:	4b06      	ldr	r3, [pc, #24]	; (8004eec <HAL_RCC_GetClockConfig+0x80>)
 8004ed2:	681b      	ldr	r3, [r3, #0]
 8004ed4:	f003 020f 	and.w	r2, r3, #15
 8004ed8:	683b      	ldr	r3, [r7, #0]
 8004eda:	601a      	str	r2, [r3, #0]
}
 8004edc:	bf00      	nop
 8004ede:	370c      	adds	r7, #12
 8004ee0:	46bd      	mov	sp, r7
 8004ee2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004ee6:	4770      	bx	lr
 8004ee8:	58024400 	.word	0x58024400
 8004eec:	52002000 	.word	0x52002000

08004ef0 <HAL_RCCEx_PeriphCLKConfig>:
  * (*) : Available on some STM32H7 lines only.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8004ef0:	b580      	push	{r7, lr}
 8004ef2:	b086      	sub	sp, #24
 8004ef4:	af00      	add	r7, sp, #0
 8004ef6:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
 8004ef8:	2300      	movs	r3, #0
 8004efa:	75fb      	strb	r3, [r7, #23]
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
 8004efc:	2300      	movs	r3, #0
 8004efe:	75bb      	strb	r3, [r7, #22]

  /*---------------------------- SPDIFRX configuration -------------------------------*/

  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 8004f00:	687b      	ldr	r3, [r7, #4]
 8004f02:	681b      	ldr	r3, [r3, #0]
 8004f04:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8004f08:	2b00      	cmp	r3, #0
 8004f0a:	d03f      	beq.n	8004f8c <HAL_RCCEx_PeriphCLKConfig+0x9c>
  {

    switch(PeriphClkInit->SpdifrxClockSelection)
 8004f0c:	687b      	ldr	r3, [r7, #4]
 8004f0e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8004f10:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
 8004f14:	d02a      	beq.n	8004f6c <HAL_RCCEx_PeriphCLKConfig+0x7c>
 8004f16:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
 8004f1a:	d824      	bhi.n	8004f66 <HAL_RCCEx_PeriphCLKConfig+0x76>
 8004f1c:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 8004f20:	d018      	beq.n	8004f54 <HAL_RCCEx_PeriphCLKConfig+0x64>
 8004f22:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 8004f26:	d81e      	bhi.n	8004f66 <HAL_RCCEx_PeriphCLKConfig+0x76>
 8004f28:	2b00      	cmp	r3, #0
 8004f2a:	d003      	beq.n	8004f34 <HAL_RCCEx_PeriphCLKConfig+0x44>
 8004f2c:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8004f30:	d007      	beq.n	8004f42 <HAL_RCCEx_PeriphCLKConfig+0x52>
 8004f32:	e018      	b.n	8004f66 <HAL_RCCEx_PeriphCLKConfig+0x76>
    {
    case RCC_SPDIFRXCLKSOURCE_PLL:      /* PLL is used as clock source for SPDIFRX*/
      /* Enable PLL1Q Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8004f34:	4bab      	ldr	r3, [pc, #684]	; (80051e4 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 8004f36:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004f38:	4aaa      	ldr	r2, [pc, #680]	; (80051e4 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 8004f3a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8004f3e:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SPDIFRX clock source configuration done later after clock selection check */
      break;
 8004f40:	e015      	b.n	8004f6e <HAL_RCCEx_PeriphCLKConfig+0x7e>

    case RCC_SPDIFRXCLKSOURCE_PLL2: /* PLL2 is used as clock source for SPDIFRX*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
 8004f42:	687b      	ldr	r3, [r7, #4]
 8004f44:	3304      	adds	r3, #4
 8004f46:	2102      	movs	r1, #2
 8004f48:	4618      	mov	r0, r3
 8004f4a:	f001 f9cf 	bl	80062ec <RCCEx_PLL2_Config>
 8004f4e:	4603      	mov	r3, r0
 8004f50:	75fb      	strb	r3, [r7, #23]

      /* SPDIFRX clock source configuration done later after clock selection check */
      break;
 8004f52:	e00c      	b.n	8004f6e <HAL_RCCEx_PeriphCLKConfig+0x7e>

    case RCC_SPDIFRXCLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPDIFRX*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
 8004f54:	687b      	ldr	r3, [r7, #4]
 8004f56:	3324      	adds	r3, #36	; 0x24
 8004f58:	2102      	movs	r1, #2
 8004f5a:	4618      	mov	r0, r3
 8004f5c:	f001 fa78 	bl	8006450 <RCCEx_PLL3_Config>
 8004f60:	4603      	mov	r3, r0
 8004f62:	75fb      	strb	r3, [r7, #23]

      /* SPDIFRX clock source configuration done later after clock selection check */
      break;
 8004f64:	e003      	b.n	8004f6e <HAL_RCCEx_PeriphCLKConfig+0x7e>
      /* Internal OSC clock is used as source of SPDIFRX clock*/
      /* SPDIFRX clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 8004f66:	2301      	movs	r3, #1
 8004f68:	75fb      	strb	r3, [r7, #23]
      break;
 8004f6a:	e000      	b.n	8004f6e <HAL_RCCEx_PeriphCLKConfig+0x7e>
      break;
 8004f6c:	bf00      	nop
    }

    if(ret == HAL_OK)
 8004f6e:	7dfb      	ldrb	r3, [r7, #23]
 8004f70:	2b00      	cmp	r3, #0
 8004f72:	d109      	bne.n	8004f88 <HAL_RCCEx_PeriphCLKConfig+0x98>
    {
      /* Set the source of SPDIFRX clock*/
      __HAL_RCC_SPDIFRX_CONFIG(PeriphClkInit->SpdifrxClockSelection);
 8004f74:	4b9b      	ldr	r3, [pc, #620]	; (80051e4 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 8004f76:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8004f78:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
 8004f7c:	687b      	ldr	r3, [r7, #4]
 8004f7e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8004f80:	4998      	ldr	r1, [pc, #608]	; (80051e4 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 8004f82:	4313      	orrs	r3, r2
 8004f84:	650b      	str	r3, [r1, #80]	; 0x50
 8004f86:	e001      	b.n	8004f8c <HAL_RCCEx_PeriphCLKConfig+0x9c>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8004f88:	7dfb      	ldrb	r3, [r7, #23]
 8004f8a:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SAI1 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
 8004f8c:	687b      	ldr	r3, [r7, #4]
 8004f8e:	681b      	ldr	r3, [r3, #0]
 8004f90:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8004f94:	2b00      	cmp	r3, #0
 8004f96:	d03d      	beq.n	8005014 <HAL_RCCEx_PeriphCLKConfig+0x124>
  {
    switch(PeriphClkInit->Sai1ClockSelection)
 8004f98:	687b      	ldr	r3, [r7, #4]
 8004f9a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004f9c:	2b04      	cmp	r3, #4
 8004f9e:	d826      	bhi.n	8004fee <HAL_RCCEx_PeriphCLKConfig+0xfe>
 8004fa0:	a201      	add	r2, pc, #4	; (adr r2, 8004fa8 <HAL_RCCEx_PeriphCLKConfig+0xb8>)
 8004fa2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8004fa6:	bf00      	nop
 8004fa8:	08004fbd 	.word	0x08004fbd
 8004fac:	08004fcb 	.word	0x08004fcb
 8004fb0:	08004fdd 	.word	0x08004fdd
 8004fb4:	08004ff5 	.word	0x08004ff5
 8004fb8:	08004ff5 	.word	0x08004ff5
    {
    case RCC_SAI1CLKSOURCE_PLL:      /* PLL is used as clock source for SAI1*/
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8004fbc:	4b89      	ldr	r3, [pc, #548]	; (80051e4 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 8004fbe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004fc0:	4a88      	ldr	r2, [pc, #544]	; (80051e4 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 8004fc2:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8004fc6:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SAI1 clock source configuration done later after clock selection check */
      break;
 8004fc8:	e015      	b.n	8004ff6 <HAL_RCCEx_PeriphCLKConfig+0x106>

    case RCC_SAI1CLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI1*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 8004fca:	687b      	ldr	r3, [r7, #4]
 8004fcc:	3304      	adds	r3, #4
 8004fce:	2100      	movs	r1, #0
 8004fd0:	4618      	mov	r0, r3
 8004fd2:	f001 f98b 	bl	80062ec <RCCEx_PLL2_Config>
 8004fd6:	4603      	mov	r3, r0
 8004fd8:	75fb      	strb	r3, [r7, #23]

      /* SAI1 clock source configuration done later after clock selection check */
      break;
 8004fda:	e00c      	b.n	8004ff6 <HAL_RCCEx_PeriphCLKConfig+0x106>

    case RCC_SAI1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI1*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
 8004fdc:	687b      	ldr	r3, [r7, #4]
 8004fde:	3324      	adds	r3, #36	; 0x24
 8004fe0:	2100      	movs	r1, #0
 8004fe2:	4618      	mov	r0, r3
 8004fe4:	f001 fa34 	bl	8006450 <RCCEx_PLL3_Config>
 8004fe8:	4603      	mov	r3, r0
 8004fea:	75fb      	strb	r3, [r7, #23]

      /* SAI1 clock source configuration done later after clock selection check */
      break;
 8004fec:	e003      	b.n	8004ff6 <HAL_RCCEx_PeriphCLKConfig+0x106>
      /* HSI, HSE, or CSI oscillator is used as source of SAI1 clock */
      /* SAI1 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 8004fee:	2301      	movs	r3, #1
 8004ff0:	75fb      	strb	r3, [r7, #23]
      break;
 8004ff2:	e000      	b.n	8004ff6 <HAL_RCCEx_PeriphCLKConfig+0x106>
      break;
 8004ff4:	bf00      	nop
    }

    if(ret == HAL_OK)
 8004ff6:	7dfb      	ldrb	r3, [r7, #23]
 8004ff8:	2b00      	cmp	r3, #0
 8004ffa:	d109      	bne.n	8005010 <HAL_RCCEx_PeriphCLKConfig+0x120>
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8004ffc:	4b79      	ldr	r3, [pc, #484]	; (80051e4 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 8004ffe:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8005000:	f023 0207 	bic.w	r2, r3, #7
 8005004:	687b      	ldr	r3, [r7, #4]
 8005006:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8005008:	4976      	ldr	r1, [pc, #472]	; (80051e4 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 800500a:	4313      	orrs	r3, r2
 800500c:	650b      	str	r3, [r1, #80]	; 0x50
 800500e:	e001      	b.n	8005014 <HAL_RCCEx_PeriphCLKConfig+0x124>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8005010:	7dfb      	ldrb	r3, [r7, #23]
 8005012:	75bb      	strb	r3, [r7, #22]
    }
  }

#if defined(SAI3)
  /*---------------------------- SAI2/3 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI23) == RCC_PERIPHCLK_SAI23)
 8005014:	687b      	ldr	r3, [r7, #4]
 8005016:	681b      	ldr	r3, [r3, #0]
 8005018:	f403 7300 	and.w	r3, r3, #512	; 0x200
 800501c:	2b00      	cmp	r3, #0
 800501e:	d042      	beq.n	80050a6 <HAL_RCCEx_PeriphCLKConfig+0x1b6>
  {
    switch(PeriphClkInit->Sai23ClockSelection)
 8005020:	687b      	ldr	r3, [r7, #4]
 8005022:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8005024:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8005028:	d02b      	beq.n	8005082 <HAL_RCCEx_PeriphCLKConfig+0x192>
 800502a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800502e:	d825      	bhi.n	800507c <HAL_RCCEx_PeriphCLKConfig+0x18c>
 8005030:	2bc0      	cmp	r3, #192	; 0xc0
 8005032:	d028      	beq.n	8005086 <HAL_RCCEx_PeriphCLKConfig+0x196>
 8005034:	2bc0      	cmp	r3, #192	; 0xc0
 8005036:	d821      	bhi.n	800507c <HAL_RCCEx_PeriphCLKConfig+0x18c>
 8005038:	2b80      	cmp	r3, #128	; 0x80
 800503a:	d016      	beq.n	800506a <HAL_RCCEx_PeriphCLKConfig+0x17a>
 800503c:	2b80      	cmp	r3, #128	; 0x80
 800503e:	d81d      	bhi.n	800507c <HAL_RCCEx_PeriphCLKConfig+0x18c>
 8005040:	2b00      	cmp	r3, #0
 8005042:	d002      	beq.n	800504a <HAL_RCCEx_PeriphCLKConfig+0x15a>
 8005044:	2b40      	cmp	r3, #64	; 0x40
 8005046:	d007      	beq.n	8005058 <HAL_RCCEx_PeriphCLKConfig+0x168>
 8005048:	e018      	b.n	800507c <HAL_RCCEx_PeriphCLKConfig+0x18c>
    {
    case RCC_SAI23CLKSOURCE_PLL:      /* PLL is used as clock source for SAI2/3 */
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800504a:	4b66      	ldr	r3, [pc, #408]	; (80051e4 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 800504c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800504e:	4a65      	ldr	r2, [pc, #404]	; (80051e4 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 8005050:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8005054:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SAI2/3 clock source configuration done later after clock selection check */
      break;
 8005056:	e017      	b.n	8005088 <HAL_RCCEx_PeriphCLKConfig+0x198>

    case RCC_SAI23CLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2/3 */

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 8005058:	687b      	ldr	r3, [r7, #4]
 800505a:	3304      	adds	r3, #4
 800505c:	2100      	movs	r1, #0
 800505e:	4618      	mov	r0, r3
 8005060:	f001 f944 	bl	80062ec <RCCEx_PLL2_Config>
 8005064:	4603      	mov	r3, r0
 8005066:	75fb      	strb	r3, [r7, #23]

      /* SAI2/3 clock source configuration done later after clock selection check */
      break;
 8005068:	e00e      	b.n	8005088 <HAL_RCCEx_PeriphCLKConfig+0x198>

    case RCC_SAI23CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2/3 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
 800506a:	687b      	ldr	r3, [r7, #4]
 800506c:	3324      	adds	r3, #36	; 0x24
 800506e:	2100      	movs	r1, #0
 8005070:	4618      	mov	r0, r3
 8005072:	f001 f9ed 	bl	8006450 <RCCEx_PLL3_Config>
 8005076:	4603      	mov	r3, r0
 8005078:	75fb      	strb	r3, [r7, #23]

      /* SAI2/3 clock source configuration done later after clock selection check */
      break;
 800507a:	e005      	b.n	8005088 <HAL_RCCEx_PeriphCLKConfig+0x198>
      /* HSI, HSE, or CSI oscillator is used as source of SAI2/3 clock */
      /* SAI2/3 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 800507c:	2301      	movs	r3, #1
 800507e:	75fb      	strb	r3, [r7, #23]
      break;
 8005080:	e002      	b.n	8005088 <HAL_RCCEx_PeriphCLKConfig+0x198>
      break;
 8005082:	bf00      	nop
 8005084:	e000      	b.n	8005088 <HAL_RCCEx_PeriphCLKConfig+0x198>
      break;
 8005086:	bf00      	nop
    }

    if(ret == HAL_OK)
 8005088:	7dfb      	ldrb	r3, [r7, #23]
 800508a:	2b00      	cmp	r3, #0
 800508c:	d109      	bne.n	80050a2 <HAL_RCCEx_PeriphCLKConfig+0x1b2>
    {
      /* Set the source of SAI2/3 clock*/
      __HAL_RCC_SAI23_CONFIG(PeriphClkInit->Sai23ClockSelection);
 800508e:	4b55      	ldr	r3, [pc, #340]	; (80051e4 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 8005090:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8005092:	f423 72e0 	bic.w	r2, r3, #448	; 0x1c0
 8005096:	687b      	ldr	r3, [r7, #4]
 8005098:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800509a:	4952      	ldr	r1, [pc, #328]	; (80051e4 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 800509c:	4313      	orrs	r3, r2
 800509e:	650b      	str	r3, [r1, #80]	; 0x50
 80050a0:	e001      	b.n	80050a6 <HAL_RCCEx_PeriphCLKConfig+0x1b6>
    }
    else
    {
      /* set overall return value */
      status = ret;
 80050a2:	7dfb      	ldrb	r3, [r7, #23]
 80050a4:	75bb      	strb	r3, [r7, #22]
  }
#endif  /*SAI2B*/

#if defined(SAI4)
  /*---------------------------- SAI4A configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4A) == RCC_PERIPHCLK_SAI4A)
 80050a6:	687b      	ldr	r3, [r7, #4]
 80050a8:	681b      	ldr	r3, [r3, #0]
 80050aa:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80050ae:	2b00      	cmp	r3, #0
 80050b0:	d049      	beq.n	8005146 <HAL_RCCEx_PeriphCLKConfig+0x256>
  {
    switch(PeriphClkInit->Sai4AClockSelection)
 80050b2:	687b      	ldr	r3, [r7, #4]
 80050b4:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 80050b8:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 80050bc:	d030      	beq.n	8005120 <HAL_RCCEx_PeriphCLKConfig+0x230>
 80050be:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 80050c2:	d82a      	bhi.n	800511a <HAL_RCCEx_PeriphCLKConfig+0x22a>
 80050c4:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
 80050c8:	d02c      	beq.n	8005124 <HAL_RCCEx_PeriphCLKConfig+0x234>
 80050ca:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
 80050ce:	d824      	bhi.n	800511a <HAL_RCCEx_PeriphCLKConfig+0x22a>
 80050d0:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 80050d4:	d018      	beq.n	8005108 <HAL_RCCEx_PeriphCLKConfig+0x218>
 80050d6:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 80050da:	d81e      	bhi.n	800511a <HAL_RCCEx_PeriphCLKConfig+0x22a>
 80050dc:	2b00      	cmp	r3, #0
 80050de:	d003      	beq.n	80050e8 <HAL_RCCEx_PeriphCLKConfig+0x1f8>
 80050e0:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 80050e4:	d007      	beq.n	80050f6 <HAL_RCCEx_PeriphCLKConfig+0x206>
 80050e6:	e018      	b.n	800511a <HAL_RCCEx_PeriphCLKConfig+0x22a>
    {
    case RCC_SAI4ACLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 80050e8:	4b3e      	ldr	r3, [pc, #248]	; (80051e4 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 80050ea:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80050ec:	4a3d      	ldr	r2, [pc, #244]	; (80051e4 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 80050ee:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80050f2:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SAI1 clock source configuration done later after clock selection check */
      break;
 80050f4:	e017      	b.n	8005126 <HAL_RCCEx_PeriphCLKConfig+0x236>

    case RCC_SAI4ACLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 80050f6:	687b      	ldr	r3, [r7, #4]
 80050f8:	3304      	adds	r3, #4
 80050fa:	2100      	movs	r1, #0
 80050fc:	4618      	mov	r0, r3
 80050fe:	f001 f8f5 	bl	80062ec <RCCEx_PLL2_Config>
 8005102:	4603      	mov	r3, r0
 8005104:	75fb      	strb	r3, [r7, #23]

      /* SAI2 clock source configuration done later after clock selection check */
      break;
 8005106:	e00e      	b.n	8005126 <HAL_RCCEx_PeriphCLKConfig+0x236>

    case RCC_SAI4ACLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
 8005108:	687b      	ldr	r3, [r7, #4]
 800510a:	3324      	adds	r3, #36	; 0x24
 800510c:	2100      	movs	r1, #0
 800510e:	4618      	mov	r0, r3
 8005110:	f001 f99e 	bl	8006450 <RCCEx_PLL3_Config>
 8005114:	4603      	mov	r3, r0
 8005116:	75fb      	strb	r3, [r7, #23]

      /* SAI1 clock source configuration done later after clock selection check */
      break;
 8005118:	e005      	b.n	8005126 <HAL_RCCEx_PeriphCLKConfig+0x236>
      /* SAI4A clock source configuration done later after clock selection check */
      break;
#endif /* RCC_VER_3_0 */

    default:
      ret = HAL_ERROR;
 800511a:	2301      	movs	r3, #1
 800511c:	75fb      	strb	r3, [r7, #23]
      break;
 800511e:	e002      	b.n	8005126 <HAL_RCCEx_PeriphCLKConfig+0x236>
      break;
 8005120:	bf00      	nop
 8005122:	e000      	b.n	8005126 <HAL_RCCEx_PeriphCLKConfig+0x236>
      break;
 8005124:	bf00      	nop
    }

    if(ret == HAL_OK)
 8005126:	7dfb      	ldrb	r3, [r7, #23]
 8005128:	2b00      	cmp	r3, #0
 800512a:	d10a      	bne.n	8005142 <HAL_RCCEx_PeriphCLKConfig+0x252>
    {
      /* Set the source of SAI4A clock*/
      __HAL_RCC_SAI4A_CONFIG(PeriphClkInit->Sai4AClockSelection);
 800512c:	4b2d      	ldr	r3, [pc, #180]	; (80051e4 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 800512e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8005130:	f423 0260 	bic.w	r2, r3, #14680064	; 0xe00000
 8005134:	687b      	ldr	r3, [r7, #4]
 8005136:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 800513a:	492a      	ldr	r1, [pc, #168]	; (80051e4 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 800513c:	4313      	orrs	r3, r2
 800513e:	658b      	str	r3, [r1, #88]	; 0x58
 8005140:	e001      	b.n	8005146 <HAL_RCCEx_PeriphCLKConfig+0x256>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8005142:	7dfb      	ldrb	r3, [r7, #23]
 8005144:	75bb      	strb	r3, [r7, #22]
    }
  }
  /*---------------------------- SAI4B configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4B) == RCC_PERIPHCLK_SAI4B)
 8005146:	687b      	ldr	r3, [r7, #4]
 8005148:	681b      	ldr	r3, [r3, #0]
 800514a:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800514e:	2b00      	cmp	r3, #0
 8005150:	d04c      	beq.n	80051ec <HAL_RCCEx_PeriphCLKConfig+0x2fc>
  {
    switch(PeriphClkInit->Sai4BClockSelection)
 8005152:	687b      	ldr	r3, [r7, #4]
 8005154:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 8005158:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 800515c:	d030      	beq.n	80051c0 <HAL_RCCEx_PeriphCLKConfig+0x2d0>
 800515e:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 8005162:	d82a      	bhi.n	80051ba <HAL_RCCEx_PeriphCLKConfig+0x2ca>
 8005164:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
 8005168:	d02c      	beq.n	80051c4 <HAL_RCCEx_PeriphCLKConfig+0x2d4>
 800516a:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
 800516e:	d824      	bhi.n	80051ba <HAL_RCCEx_PeriphCLKConfig+0x2ca>
 8005170:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 8005174:	d018      	beq.n	80051a8 <HAL_RCCEx_PeriphCLKConfig+0x2b8>
 8005176:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 800517a:	d81e      	bhi.n	80051ba <HAL_RCCEx_PeriphCLKConfig+0x2ca>
 800517c:	2b00      	cmp	r3, #0
 800517e:	d003      	beq.n	8005188 <HAL_RCCEx_PeriphCLKConfig+0x298>
 8005180:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 8005184:	d007      	beq.n	8005196 <HAL_RCCEx_PeriphCLKConfig+0x2a6>
 8005186:	e018      	b.n	80051ba <HAL_RCCEx_PeriphCLKConfig+0x2ca>
    {
    case RCC_SAI4BCLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
      /* Enable SAI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8005188:	4b16      	ldr	r3, [pc, #88]	; (80051e4 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 800518a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800518c:	4a15      	ldr	r2, [pc, #84]	; (80051e4 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 800518e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8005192:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SAI1 clock source configuration done later after clock selection check */
      break;
 8005194:	e017      	b.n	80051c6 <HAL_RCCEx_PeriphCLKConfig+0x2d6>

    case RCC_SAI4BCLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 8005196:	687b      	ldr	r3, [r7, #4]
 8005198:	3304      	adds	r3, #4
 800519a:	2100      	movs	r1, #0
 800519c:	4618      	mov	r0, r3
 800519e:	f001 f8a5 	bl	80062ec <RCCEx_PLL2_Config>
 80051a2:	4603      	mov	r3, r0
 80051a4:	75fb      	strb	r3, [r7, #23]

      /* SAI2 clock source configuration done later after clock selection check */
      break;
 80051a6:	e00e      	b.n	80051c6 <HAL_RCCEx_PeriphCLKConfig+0x2d6>

    case RCC_SAI4BCLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 80051a8:	687b      	ldr	r3, [r7, #4]
 80051aa:	3324      	adds	r3, #36	; 0x24
 80051ac:	2100      	movs	r1, #0
 80051ae:	4618      	mov	r0, r3
 80051b0:	f001 f94e 	bl	8006450 <RCCEx_PLL3_Config>
 80051b4:	4603      	mov	r3, r0
 80051b6:	75fb      	strb	r3, [r7, #23]

      /* SAI1 clock source configuration done later after clock selection check */
      break;
 80051b8:	e005      	b.n	80051c6 <HAL_RCCEx_PeriphCLKConfig+0x2d6>
      /* SAI4B clock source configuration done later after clock selection check */
      break;
#endif /* RCC_VER_3_0 */

    default:
      ret = HAL_ERROR;
 80051ba:	2301      	movs	r3, #1
 80051bc:	75fb      	strb	r3, [r7, #23]
      break;
 80051be:	e002      	b.n	80051c6 <HAL_RCCEx_PeriphCLKConfig+0x2d6>
      break;
 80051c0:	bf00      	nop
 80051c2:	e000      	b.n	80051c6 <HAL_RCCEx_PeriphCLKConfig+0x2d6>
      break;
 80051c4:	bf00      	nop
    }

    if(ret == HAL_OK)
 80051c6:	7dfb      	ldrb	r3, [r7, #23]
 80051c8:	2b00      	cmp	r3, #0
 80051ca:	d10d      	bne.n	80051e8 <HAL_RCCEx_PeriphCLKConfig+0x2f8>
    {
      /* Set the source of SAI4B clock*/
      __HAL_RCC_SAI4B_CONFIG(PeriphClkInit->Sai4BClockSelection);
 80051cc:	4b05      	ldr	r3, [pc, #20]	; (80051e4 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 80051ce:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80051d0:	f023 62e0 	bic.w	r2, r3, #117440512	; 0x7000000
 80051d4:	687b      	ldr	r3, [r7, #4]
 80051d6:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 80051da:	4902      	ldr	r1, [pc, #8]	; (80051e4 <HAL_RCCEx_PeriphCLKConfig+0x2f4>)
 80051dc:	4313      	orrs	r3, r2
 80051de:	658b      	str	r3, [r1, #88]	; 0x58
 80051e0:	e004      	b.n	80051ec <HAL_RCCEx_PeriphCLKConfig+0x2fc>
 80051e2:	bf00      	nop
 80051e4:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
 80051e8:	7dfb      	ldrb	r3, [r7, #23]
 80051ea:	75bb      	strb	r3, [r7, #22]
  }
#endif  /*SAI4*/

#if defined(QUADSPI)
  /*---------------------------- QSPI configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) == RCC_PERIPHCLK_QSPI)
 80051ec:	687b      	ldr	r3, [r7, #4]
 80051ee:	681b      	ldr	r3, [r3, #0]
 80051f0:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80051f4:	2b00      	cmp	r3, #0
 80051f6:	d032      	beq.n	800525e <HAL_RCCEx_PeriphCLKConfig+0x36e>
  {
    switch(PeriphClkInit->QspiClockSelection)
 80051f8:	687b      	ldr	r3, [r7, #4]
 80051fa:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80051fc:	2b30      	cmp	r3, #48	; 0x30
 80051fe:	d01c      	beq.n	800523a <HAL_RCCEx_PeriphCLKConfig+0x34a>
 8005200:	2b30      	cmp	r3, #48	; 0x30
 8005202:	d817      	bhi.n	8005234 <HAL_RCCEx_PeriphCLKConfig+0x344>
 8005204:	2b20      	cmp	r3, #32
 8005206:	d00c      	beq.n	8005222 <HAL_RCCEx_PeriphCLKConfig+0x332>
 8005208:	2b20      	cmp	r3, #32
 800520a:	d813      	bhi.n	8005234 <HAL_RCCEx_PeriphCLKConfig+0x344>
 800520c:	2b00      	cmp	r3, #0
 800520e:	d016      	beq.n	800523e <HAL_RCCEx_PeriphCLKConfig+0x34e>
 8005210:	2b10      	cmp	r3, #16
 8005212:	d10f      	bne.n	8005234 <HAL_RCCEx_PeriphCLKConfig+0x344>
    {
    case RCC_QSPICLKSOURCE_PLL:      /* PLL is used as clock source for QSPI*/
      /* Enable QSPI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8005214:	4baf      	ldr	r3, [pc, #700]	; (80054d4 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
 8005216:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005218:	4aae      	ldr	r2, [pc, #696]	; (80054d4 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
 800521a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800521e:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* QSPI clock source configuration done later after clock selection check */
      break;
 8005220:	e00e      	b.n	8005240 <HAL_RCCEx_PeriphCLKConfig+0x350>

    case RCC_QSPICLKSOURCE_PLL2: /* PLL2 is used as clock source for QSPI*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
 8005222:	687b      	ldr	r3, [r7, #4]
 8005224:	3304      	adds	r3, #4
 8005226:	2102      	movs	r1, #2
 8005228:	4618      	mov	r0, r3
 800522a:	f001 f85f 	bl	80062ec <RCCEx_PLL2_Config>
 800522e:	4603      	mov	r3, r0
 8005230:	75fb      	strb	r3, [r7, #23]

      /* QSPI clock source configuration done later after clock selection check */
      break;
 8005232:	e005      	b.n	8005240 <HAL_RCCEx_PeriphCLKConfig+0x350>
    case RCC_QSPICLKSOURCE_D1HCLK:
      /* Domain1 HCLK  clock selected as QSPI kernel peripheral clock */
      break;

    default:
      ret = HAL_ERROR;
 8005234:	2301      	movs	r3, #1
 8005236:	75fb      	strb	r3, [r7, #23]
      break;
 8005238:	e002      	b.n	8005240 <HAL_RCCEx_PeriphCLKConfig+0x350>
      break;
 800523a:	bf00      	nop
 800523c:	e000      	b.n	8005240 <HAL_RCCEx_PeriphCLKConfig+0x350>
      break;
 800523e:	bf00      	nop
    }

    if(ret == HAL_OK)
 8005240:	7dfb      	ldrb	r3, [r7, #23]
 8005242:	2b00      	cmp	r3, #0
 8005244:	d109      	bne.n	800525a <HAL_RCCEx_PeriphCLKConfig+0x36a>
    {
      /* Set the source of QSPI clock*/
      __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);
 8005246:	4ba3      	ldr	r3, [pc, #652]	; (80054d4 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
 8005248:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800524a:	f023 0230 	bic.w	r2, r3, #48	; 0x30
 800524e:	687b      	ldr	r3, [r7, #4]
 8005250:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8005252:	49a0      	ldr	r1, [pc, #640]	; (80054d4 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
 8005254:	4313      	orrs	r3, r2
 8005256:	64cb      	str	r3, [r1, #76]	; 0x4c
 8005258:	e001      	b.n	800525e <HAL_RCCEx_PeriphCLKConfig+0x36e>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800525a:	7dfb      	ldrb	r3, [r7, #23]
 800525c:	75bb      	strb	r3, [r7, #22]
    }
  }
#endif  /*OCTOSPI*/

  /*---------------------------- SPI1/2/3 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI123) == RCC_PERIPHCLK_SPI123)
 800525e:	687b      	ldr	r3, [r7, #4]
 8005260:	681b      	ldr	r3, [r3, #0]
 8005262:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8005266:	2b00      	cmp	r3, #0
 8005268:	d047      	beq.n	80052fa <HAL_RCCEx_PeriphCLKConfig+0x40a>
  {
    switch(PeriphClkInit->Spi123ClockSelection)
 800526a:	687b      	ldr	r3, [r7, #4]
 800526c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800526e:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8005272:	d030      	beq.n	80052d6 <HAL_RCCEx_PeriphCLKConfig+0x3e6>
 8005274:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8005278:	d82a      	bhi.n	80052d0 <HAL_RCCEx_PeriphCLKConfig+0x3e0>
 800527a:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 800527e:	d02c      	beq.n	80052da <HAL_RCCEx_PeriphCLKConfig+0x3ea>
 8005280:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 8005284:	d824      	bhi.n	80052d0 <HAL_RCCEx_PeriphCLKConfig+0x3e0>
 8005286:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800528a:	d018      	beq.n	80052be <HAL_RCCEx_PeriphCLKConfig+0x3ce>
 800528c:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8005290:	d81e      	bhi.n	80052d0 <HAL_RCCEx_PeriphCLKConfig+0x3e0>
 8005292:	2b00      	cmp	r3, #0
 8005294:	d003      	beq.n	800529e <HAL_RCCEx_PeriphCLKConfig+0x3ae>
 8005296:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800529a:	d007      	beq.n	80052ac <HAL_RCCEx_PeriphCLKConfig+0x3bc>
 800529c:	e018      	b.n	80052d0 <HAL_RCCEx_PeriphCLKConfig+0x3e0>
    {
    case RCC_SPI123CLKSOURCE_PLL:      /* PLL is used as clock source for SPI1/2/3 */
      /* Enable SPI Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800529e:	4b8d      	ldr	r3, [pc, #564]	; (80054d4 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
 80052a0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80052a2:	4a8c      	ldr	r2, [pc, #560]	; (80054d4 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
 80052a4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80052a8:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SPI1/2/3 clock source configuration done later after clock selection check */
      break;
 80052aa:	e017      	b.n	80052dc <HAL_RCCEx_PeriphCLKConfig+0x3ec>

    case RCC_SPI123CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI1/2/3 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 80052ac:	687b      	ldr	r3, [r7, #4]
 80052ae:	3304      	adds	r3, #4
 80052b0:	2100      	movs	r1, #0
 80052b2:	4618      	mov	r0, r3
 80052b4:	f001 f81a 	bl	80062ec <RCCEx_PLL2_Config>
 80052b8:	4603      	mov	r3, r0
 80052ba:	75fb      	strb	r3, [r7, #23]

      /* SPI1/2/3 clock source configuration done later after clock selection check */
      break;
 80052bc:	e00e      	b.n	80052dc <HAL_RCCEx_PeriphCLKConfig+0x3ec>

    case RCC_SPI123CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI1/2/3 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
 80052be:	687b      	ldr	r3, [r7, #4]
 80052c0:	3324      	adds	r3, #36	; 0x24
 80052c2:	2100      	movs	r1, #0
 80052c4:	4618      	mov	r0, r3
 80052c6:	f001 f8c3 	bl	8006450 <RCCEx_PLL3_Config>
 80052ca:	4603      	mov	r3, r0
 80052cc:	75fb      	strb	r3, [r7, #23]

      /* SPI1/2/3 clock source configuration done later after clock selection check */
      break;
 80052ce:	e005      	b.n	80052dc <HAL_RCCEx_PeriphCLKConfig+0x3ec>
      /* HSI, HSE, or CSI oscillator is used as source of SPI1/2/3 clock */
      /* SPI1/2/3 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 80052d0:	2301      	movs	r3, #1
 80052d2:	75fb      	strb	r3, [r7, #23]
      break;
 80052d4:	e002      	b.n	80052dc <HAL_RCCEx_PeriphCLKConfig+0x3ec>
      break;
 80052d6:	bf00      	nop
 80052d8:	e000      	b.n	80052dc <HAL_RCCEx_PeriphCLKConfig+0x3ec>
      break;
 80052da:	bf00      	nop
    }

    if(ret == HAL_OK)
 80052dc:	7dfb      	ldrb	r3, [r7, #23]
 80052de:	2b00      	cmp	r3, #0
 80052e0:	d109      	bne.n	80052f6 <HAL_RCCEx_PeriphCLKConfig+0x406>
    {
      /* Set the source of SPI1/2/3 clock*/
      __HAL_RCC_SPI123_CONFIG(PeriphClkInit->Spi123ClockSelection);
 80052e2:	4b7c      	ldr	r3, [pc, #496]	; (80054d4 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
 80052e4:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80052e6:	f423 42e0 	bic.w	r2, r3, #28672	; 0x7000
 80052ea:	687b      	ldr	r3, [r7, #4]
 80052ec:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80052ee:	4979      	ldr	r1, [pc, #484]	; (80054d4 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
 80052f0:	4313      	orrs	r3, r2
 80052f2:	650b      	str	r3, [r1, #80]	; 0x50
 80052f4:	e001      	b.n	80052fa <HAL_RCCEx_PeriphCLKConfig+0x40a>
    }
    else
    {
      /* set overall return value */
      status = ret;
 80052f6:	7dfb      	ldrb	r3, [r7, #23]
 80052f8:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SPI4/5 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI45) == RCC_PERIPHCLK_SPI45)
 80052fa:	687b      	ldr	r3, [r7, #4]
 80052fc:	681b      	ldr	r3, [r3, #0]
 80052fe:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8005302:	2b00      	cmp	r3, #0
 8005304:	d049      	beq.n	800539a <HAL_RCCEx_PeriphCLKConfig+0x4aa>
  {
    switch(PeriphClkInit->Spi45ClockSelection)
 8005306:	687b      	ldr	r3, [r7, #4]
 8005308:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800530a:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 800530e:	d02e      	beq.n	800536e <HAL_RCCEx_PeriphCLKConfig+0x47e>
 8005310:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8005314:	d828      	bhi.n	8005368 <HAL_RCCEx_PeriphCLKConfig+0x478>
 8005316:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 800531a:	d02a      	beq.n	8005372 <HAL_RCCEx_PeriphCLKConfig+0x482>
 800531c:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8005320:	d822      	bhi.n	8005368 <HAL_RCCEx_PeriphCLKConfig+0x478>
 8005322:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
 8005326:	d026      	beq.n	8005376 <HAL_RCCEx_PeriphCLKConfig+0x486>
 8005328:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
 800532c:	d81c      	bhi.n	8005368 <HAL_RCCEx_PeriphCLKConfig+0x478>
 800532e:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8005332:	d010      	beq.n	8005356 <HAL_RCCEx_PeriphCLKConfig+0x466>
 8005334:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8005338:	d816      	bhi.n	8005368 <HAL_RCCEx_PeriphCLKConfig+0x478>
 800533a:	2b00      	cmp	r3, #0
 800533c:	d01d      	beq.n	800537a <HAL_RCCEx_PeriphCLKConfig+0x48a>
 800533e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8005342:	d111      	bne.n	8005368 <HAL_RCCEx_PeriphCLKConfig+0x478>
      /* SPI4/5 clock source configuration done later after clock selection check */
      break;

    case RCC_SPI45CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI4/5 */

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 8005344:	687b      	ldr	r3, [r7, #4]
 8005346:	3304      	adds	r3, #4
 8005348:	2101      	movs	r1, #1
 800534a:	4618      	mov	r0, r3
 800534c:	f000 ffce 	bl	80062ec <RCCEx_PLL2_Config>
 8005350:	4603      	mov	r3, r0
 8005352:	75fb      	strb	r3, [r7, #23]

      /* SPI4/5 clock source configuration done later after clock selection check */
      break;
 8005354:	e012      	b.n	800537c <HAL_RCCEx_PeriphCLKConfig+0x48c>
    case RCC_SPI45CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI4/5 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 8005356:	687b      	ldr	r3, [r7, #4]
 8005358:	3324      	adds	r3, #36	; 0x24
 800535a:	2101      	movs	r1, #1
 800535c:	4618      	mov	r0, r3
 800535e:	f001 f877 	bl	8006450 <RCCEx_PLL3_Config>
 8005362:	4603      	mov	r3, r0
 8005364:	75fb      	strb	r3, [r7, #23]
      /* SPI4/5 clock source configuration done later after clock selection check */
      break;
 8005366:	e009      	b.n	800537c <HAL_RCCEx_PeriphCLKConfig+0x48c>
      /* HSE,  oscillator is used as source of SPI4/5 clock */
      /* SPI4/5 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 8005368:	2301      	movs	r3, #1
 800536a:	75fb      	strb	r3, [r7, #23]
      break;
 800536c:	e006      	b.n	800537c <HAL_RCCEx_PeriphCLKConfig+0x48c>
      break;
 800536e:	bf00      	nop
 8005370:	e004      	b.n	800537c <HAL_RCCEx_PeriphCLKConfig+0x48c>
      break;
 8005372:	bf00      	nop
 8005374:	e002      	b.n	800537c <HAL_RCCEx_PeriphCLKConfig+0x48c>
      break;
 8005376:	bf00      	nop
 8005378:	e000      	b.n	800537c <HAL_RCCEx_PeriphCLKConfig+0x48c>
      break;
 800537a:	bf00      	nop
    }

    if(ret == HAL_OK)
 800537c:	7dfb      	ldrb	r3, [r7, #23]
 800537e:	2b00      	cmp	r3, #0
 8005380:	d109      	bne.n	8005396 <HAL_RCCEx_PeriphCLKConfig+0x4a6>
    {
      /* Set the source of SPI4/5 clock*/
      __HAL_RCC_SPI45_CONFIG(PeriphClkInit->Spi45ClockSelection);
 8005382:	4b54      	ldr	r3, [pc, #336]	; (80054d4 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
 8005384:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8005386:	f423 22e0 	bic.w	r2, r3, #458752	; 0x70000
 800538a:	687b      	ldr	r3, [r7, #4]
 800538c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800538e:	4951      	ldr	r1, [pc, #324]	; (80054d4 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
 8005390:	4313      	orrs	r3, r2
 8005392:	650b      	str	r3, [r1, #80]	; 0x50
 8005394:	e001      	b.n	800539a <HAL_RCCEx_PeriphCLKConfig+0x4aa>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8005396:	7dfb      	ldrb	r3, [r7, #23]
 8005398:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SPI6 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
 800539a:	687b      	ldr	r3, [r7, #4]
 800539c:	681b      	ldr	r3, [r3, #0]
 800539e:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80053a2:	2b00      	cmp	r3, #0
 80053a4:	d04b      	beq.n	800543e <HAL_RCCEx_PeriphCLKConfig+0x54e>
  {
    switch(PeriphClkInit->Spi6ClockSelection)
 80053a6:	687b      	ldr	r3, [r7, #4]
 80053a8:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 80053ac:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 80053b0:	d02e      	beq.n	8005410 <HAL_RCCEx_PeriphCLKConfig+0x520>
 80053b2:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 80053b6:	d828      	bhi.n	800540a <HAL_RCCEx_PeriphCLKConfig+0x51a>
 80053b8:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80053bc:	d02a      	beq.n	8005414 <HAL_RCCEx_PeriphCLKConfig+0x524>
 80053be:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80053c2:	d822      	bhi.n	800540a <HAL_RCCEx_PeriphCLKConfig+0x51a>
 80053c4:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
 80053c8:	d026      	beq.n	8005418 <HAL_RCCEx_PeriphCLKConfig+0x528>
 80053ca:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
 80053ce:	d81c      	bhi.n	800540a <HAL_RCCEx_PeriphCLKConfig+0x51a>
 80053d0:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 80053d4:	d010      	beq.n	80053f8 <HAL_RCCEx_PeriphCLKConfig+0x508>
 80053d6:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 80053da:	d816      	bhi.n	800540a <HAL_RCCEx_PeriphCLKConfig+0x51a>
 80053dc:	2b00      	cmp	r3, #0
 80053de:	d01d      	beq.n	800541c <HAL_RCCEx_PeriphCLKConfig+0x52c>
 80053e0:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 80053e4:	d111      	bne.n	800540a <HAL_RCCEx_PeriphCLKConfig+0x51a>
      /* SPI6 clock source configuration done later after clock selection check */
      break;

    case RCC_SPI6CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI6*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 80053e6:	687b      	ldr	r3, [r7, #4]
 80053e8:	3304      	adds	r3, #4
 80053ea:	2101      	movs	r1, #1
 80053ec:	4618      	mov	r0, r3
 80053ee:	f000 ff7d 	bl	80062ec <RCCEx_PLL2_Config>
 80053f2:	4603      	mov	r3, r0
 80053f4:	75fb      	strb	r3, [r7, #23]

      /* SPI6 clock source configuration done later after clock selection check */
      break;
 80053f6:	e012      	b.n	800541e <HAL_RCCEx_PeriphCLKConfig+0x52e>
    case RCC_SPI6CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI6*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 80053f8:	687b      	ldr	r3, [r7, #4]
 80053fa:	3324      	adds	r3, #36	; 0x24
 80053fc:	2101      	movs	r1, #1
 80053fe:	4618      	mov	r0, r3
 8005400:	f001 f826 	bl	8006450 <RCCEx_PLL3_Config>
 8005404:	4603      	mov	r3, r0
 8005406:	75fb      	strb	r3, [r7, #23]
      /* SPI6 clock source configuration done later after clock selection check */
      break;
 8005408:	e009      	b.n	800541e <HAL_RCCEx_PeriphCLKConfig+0x52e>
      /* SPI6 clock source configuration done later after clock selection check */
      break;
#endif

    default:
      ret = HAL_ERROR;
 800540a:	2301      	movs	r3, #1
 800540c:	75fb      	strb	r3, [r7, #23]
      break;
 800540e:	e006      	b.n	800541e <HAL_RCCEx_PeriphCLKConfig+0x52e>
      break;
 8005410:	bf00      	nop
 8005412:	e004      	b.n	800541e <HAL_RCCEx_PeriphCLKConfig+0x52e>
      break;
 8005414:	bf00      	nop
 8005416:	e002      	b.n	800541e <HAL_RCCEx_PeriphCLKConfig+0x52e>
      break;
 8005418:	bf00      	nop
 800541a:	e000      	b.n	800541e <HAL_RCCEx_PeriphCLKConfig+0x52e>
      break;
 800541c:	bf00      	nop
    }

    if(ret == HAL_OK)
 800541e:	7dfb      	ldrb	r3, [r7, #23]
 8005420:	2b00      	cmp	r3, #0
 8005422:	d10a      	bne.n	800543a <HAL_RCCEx_PeriphCLKConfig+0x54a>
    {
      /* Set the source of SPI6 clock*/
      __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
 8005424:	4b2b      	ldr	r3, [pc, #172]	; (80054d4 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
 8005426:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8005428:	f023 42e0 	bic.w	r2, r3, #1879048192	; 0x70000000
 800542c:	687b      	ldr	r3, [r7, #4]
 800542e:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 8005432:	4928      	ldr	r1, [pc, #160]	; (80054d4 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
 8005434:	4313      	orrs	r3, r2
 8005436:	658b      	str	r3, [r1, #88]	; 0x58
 8005438:	e001      	b.n	800543e <HAL_RCCEx_PeriphCLKConfig+0x54e>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800543a:	7dfb      	ldrb	r3, [r7, #23]
 800543c:	75bb      	strb	r3, [r7, #22]
  }
#endif /*DSI*/

#if defined(FDCAN1) || defined(FDCAN2)
  /*---------------------------- FDCAN configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
 800543e:	687b      	ldr	r3, [r7, #4]
 8005440:	681b      	ldr	r3, [r3, #0]
 8005442:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8005446:	2b00      	cmp	r3, #0
 8005448:	d02f      	beq.n	80054aa <HAL_RCCEx_PeriphCLKConfig+0x5ba>
  {
    switch(PeriphClkInit->FdcanClockSelection)
 800544a:	687b      	ldr	r3, [r7, #4]
 800544c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800544e:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8005452:	d00e      	beq.n	8005472 <HAL_RCCEx_PeriphCLKConfig+0x582>
 8005454:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8005458:	d814      	bhi.n	8005484 <HAL_RCCEx_PeriphCLKConfig+0x594>
 800545a:	2b00      	cmp	r3, #0
 800545c:	d015      	beq.n	800548a <HAL_RCCEx_PeriphCLKConfig+0x59a>
 800545e:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8005462:	d10f      	bne.n	8005484 <HAL_RCCEx_PeriphCLKConfig+0x594>
    {
    case RCC_FDCANCLKSOURCE_PLL:      /* PLL is used as clock source for FDCAN*/
      /* Enable FDCAN Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8005464:	4b1b      	ldr	r3, [pc, #108]	; (80054d4 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
 8005466:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005468:	4a1a      	ldr	r2, [pc, #104]	; (80054d4 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
 800546a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800546e:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* FDCAN clock source configuration done later after clock selection check */
      break;
 8005470:	e00c      	b.n	800548c <HAL_RCCEx_PeriphCLKConfig+0x59c>

    case RCC_FDCANCLKSOURCE_PLL2: /* PLL2 is used as clock source for FDCAN*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 8005472:	687b      	ldr	r3, [r7, #4]
 8005474:	3304      	adds	r3, #4
 8005476:	2101      	movs	r1, #1
 8005478:	4618      	mov	r0, r3
 800547a:	f000 ff37 	bl	80062ec <RCCEx_PLL2_Config>
 800547e:	4603      	mov	r3, r0
 8005480:	75fb      	strb	r3, [r7, #23]

      /* FDCAN clock source configuration done later after clock selection check */
      break;
 8005482:	e003      	b.n	800548c <HAL_RCCEx_PeriphCLKConfig+0x59c>
      /* HSE is used as clock source for FDCAN*/
      /* FDCAN clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 8005484:	2301      	movs	r3, #1
 8005486:	75fb      	strb	r3, [r7, #23]
      break;
 8005488:	e000      	b.n	800548c <HAL_RCCEx_PeriphCLKConfig+0x59c>
      break;
 800548a:	bf00      	nop
    }

    if(ret == HAL_OK)
 800548c:	7dfb      	ldrb	r3, [r7, #23]
 800548e:	2b00      	cmp	r3, #0
 8005490:	d109      	bne.n	80054a6 <HAL_RCCEx_PeriphCLKConfig+0x5b6>
    {
      /* Set the source of FDCAN clock*/
      __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
 8005492:	4b10      	ldr	r3, [pc, #64]	; (80054d4 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
 8005494:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8005496:	f023 5240 	bic.w	r2, r3, #805306368	; 0x30000000
 800549a:	687b      	ldr	r3, [r7, #4]
 800549c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800549e:	490d      	ldr	r1, [pc, #52]	; (80054d4 <HAL_RCCEx_PeriphCLKConfig+0x5e4>)
 80054a0:	4313      	orrs	r3, r2
 80054a2:	650b      	str	r3, [r1, #80]	; 0x50
 80054a4:	e001      	b.n	80054aa <HAL_RCCEx_PeriphCLKConfig+0x5ba>
    }
    else
    {
      /* set overall return value */
      status = ret;
 80054a6:	7dfb      	ldrb	r3, [r7, #23]
 80054a8:	75bb      	strb	r3, [r7, #22]
    }
  }
#endif /*FDCAN1 || FDCAN2*/

  /*---------------------------- FMC configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
 80054aa:	687b      	ldr	r3, [r7, #4]
 80054ac:	681b      	ldr	r3, [r3, #0]
 80054ae:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 80054b2:	2b00      	cmp	r3, #0
 80054b4:	d033      	beq.n	800551e <HAL_RCCEx_PeriphCLKConfig+0x62e>
  {
    switch(PeriphClkInit->FmcClockSelection)
 80054b6:	687b      	ldr	r3, [r7, #4]
 80054b8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80054ba:	2b03      	cmp	r3, #3
 80054bc:	d81c      	bhi.n	80054f8 <HAL_RCCEx_PeriphCLKConfig+0x608>
 80054be:	a201      	add	r2, pc, #4	; (adr r2, 80054c4 <HAL_RCCEx_PeriphCLKConfig+0x5d4>)
 80054c0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80054c4:	080054ff 	.word	0x080054ff
 80054c8:	080054d9 	.word	0x080054d9
 80054cc:	080054e7 	.word	0x080054e7
 80054d0:	080054ff 	.word	0x080054ff
 80054d4:	58024400 	.word	0x58024400
    {
    case RCC_FMCCLKSOURCE_PLL:      /* PLL is used as clock source for FMC*/
      /* Enable FMC Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 80054d8:	4bb8      	ldr	r3, [pc, #736]	; (80057bc <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
 80054da:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80054dc:	4ab7      	ldr	r2, [pc, #732]	; (80057bc <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
 80054de:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80054e2:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* FMC clock source configuration done later after clock selection check */
      break;
 80054e4:	e00c      	b.n	8005500 <HAL_RCCEx_PeriphCLKConfig+0x610>

    case RCC_FMCCLKSOURCE_PLL2: /* PLL2 is used as clock source for FMC*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
 80054e6:	687b      	ldr	r3, [r7, #4]
 80054e8:	3304      	adds	r3, #4
 80054ea:	2102      	movs	r1, #2
 80054ec:	4618      	mov	r0, r3
 80054ee:	f000 fefd 	bl	80062ec <RCCEx_PLL2_Config>
 80054f2:	4603      	mov	r3, r0
 80054f4:	75fb      	strb	r3, [r7, #23]

      /* FMC clock source configuration done later after clock selection check */
      break;
 80054f6:	e003      	b.n	8005500 <HAL_RCCEx_PeriphCLKConfig+0x610>
    case RCC_FMCCLKSOURCE_HCLK:
      /* D1/CD HCLK  clock selected as FMC kernel peripheral clock */
      break;

    default:
      ret = HAL_ERROR;
 80054f8:	2301      	movs	r3, #1
 80054fa:	75fb      	strb	r3, [r7, #23]
      break;
 80054fc:	e000      	b.n	8005500 <HAL_RCCEx_PeriphCLKConfig+0x610>
      break;
 80054fe:	bf00      	nop
    }

    if(ret == HAL_OK)
 8005500:	7dfb      	ldrb	r3, [r7, #23]
 8005502:	2b00      	cmp	r3, #0
 8005504:	d109      	bne.n	800551a <HAL_RCCEx_PeriphCLKConfig+0x62a>
    {
      /* Set the source of FMC clock*/
      __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
 8005506:	4bad      	ldr	r3, [pc, #692]	; (80057bc <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
 8005508:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800550a:	f023 0203 	bic.w	r2, r3, #3
 800550e:	687b      	ldr	r3, [r7, #4]
 8005510:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8005512:	49aa      	ldr	r1, [pc, #680]	; (80057bc <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
 8005514:	4313      	orrs	r3, r2
 8005516:	64cb      	str	r3, [r1, #76]	; 0x4c
 8005518:	e001      	b.n	800551e <HAL_RCCEx_PeriphCLKConfig+0x62e>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800551a:	7dfb      	ldrb	r3, [r7, #23]
 800551c:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- RTC configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 800551e:	687b      	ldr	r3, [r7, #4]
 8005520:	681b      	ldr	r3, [r3, #0]
 8005522:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8005526:	2b00      	cmp	r3, #0
 8005528:	f000 8086 	beq.w	8005638 <HAL_RCCEx_PeriphCLKConfig+0x748>
  {
    /* check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 800552c:	4ba4      	ldr	r3, [pc, #656]	; (80057c0 <HAL_RCCEx_PeriphCLKConfig+0x8d0>)
 800552e:	681b      	ldr	r3, [r3, #0]
 8005530:	4aa3      	ldr	r2, [pc, #652]	; (80057c0 <HAL_RCCEx_PeriphCLKConfig+0x8d0>)
 8005532:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8005536:	6013      	str	r3, [r2, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 8005538:	f7fb f906 	bl	8000748 <HAL_GetTick>
 800553c:	6138      	str	r0, [r7, #16]

    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 800553e:	e009      	b.n	8005554 <HAL_RCCEx_PeriphCLKConfig+0x664>
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8005540:	f7fb f902 	bl	8000748 <HAL_GetTick>
 8005544:	4602      	mov	r2, r0
 8005546:	693b      	ldr	r3, [r7, #16]
 8005548:	1ad3      	subs	r3, r2, r3
 800554a:	2b64      	cmp	r3, #100	; 0x64
 800554c:	d902      	bls.n	8005554 <HAL_RCCEx_PeriphCLKConfig+0x664>
      {
        ret = HAL_TIMEOUT;
 800554e:	2303      	movs	r3, #3
 8005550:	75fb      	strb	r3, [r7, #23]
        break;
 8005552:	e005      	b.n	8005560 <HAL_RCCEx_PeriphCLKConfig+0x670>
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 8005554:	4b9a      	ldr	r3, [pc, #616]	; (80057c0 <HAL_RCCEx_PeriphCLKConfig+0x8d0>)
 8005556:	681b      	ldr	r3, [r3, #0]
 8005558:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800555c:	2b00      	cmp	r3, #0
 800555e:	d0ef      	beq.n	8005540 <HAL_RCCEx_PeriphCLKConfig+0x650>
      }
    }

    if(ret == HAL_OK)
 8005560:	7dfb      	ldrb	r3, [r7, #23]
 8005562:	2b00      	cmp	r3, #0
 8005564:	d166      	bne.n	8005634 <HAL_RCCEx_PeriphCLKConfig+0x744>
    {
      /* Reset the Backup domain only if the RTC Clock source selection is modified */
      if((RCC->BDCR & RCC_BDCR_RTCSEL) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))
 8005566:	4b95      	ldr	r3, [pc, #596]	; (80057bc <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
 8005568:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800556a:	687b      	ldr	r3, [r7, #4]
 800556c:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 8005570:	4053      	eors	r3, r2
 8005572:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8005576:	2b00      	cmp	r3, #0
 8005578:	d013      	beq.n	80055a2 <HAL_RCCEx_PeriphCLKConfig+0x6b2>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 800557a:	4b90      	ldr	r3, [pc, #576]	; (80057bc <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
 800557c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800557e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8005582:	60fb      	str	r3, [r7, #12]
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
 8005584:	4b8d      	ldr	r3, [pc, #564]	; (80057bc <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
 8005586:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8005588:	4a8c      	ldr	r2, [pc, #560]	; (80057bc <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
 800558a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800558e:	6713      	str	r3, [r2, #112]	; 0x70
        __HAL_RCC_BACKUPRESET_RELEASE();
 8005590:	4b8a      	ldr	r3, [pc, #552]	; (80057bc <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
 8005592:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8005594:	4a89      	ldr	r2, [pc, #548]	; (80057bc <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
 8005596:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800559a:	6713      	str	r3, [r2, #112]	; 0x70
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpreg;
 800559c:	4a87      	ldr	r2, [pc, #540]	; (80057bc <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
 800559e:	68fb      	ldr	r3, [r7, #12]
 80055a0:	6713      	str	r3, [r2, #112]	; 0x70
      }

      /* If LSE is selected as RTC clock source (and enabled prior to Backup Domain reset), wait for LSE reactivation */
      if(PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
 80055a2:	687b      	ldr	r3, [r7, #4]
 80055a4:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 80055a8:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 80055ac:	d115      	bne.n	80055da <HAL_RCCEx_PeriphCLKConfig+0x6ea>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80055ae:	f7fb f8cb 	bl	8000748 <HAL_GetTick>
 80055b2:	6138      	str	r0, [r7, #16]

        /* Wait till LSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 80055b4:	e00b      	b.n	80055ce <HAL_RCCEx_PeriphCLKConfig+0x6de>
        {
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80055b6:	f7fb f8c7 	bl	8000748 <HAL_GetTick>
 80055ba:	4602      	mov	r2, r0
 80055bc:	693b      	ldr	r3, [r7, #16]
 80055be:	1ad3      	subs	r3, r2, r3
 80055c0:	f241 3288 	movw	r2, #5000	; 0x1388
 80055c4:	4293      	cmp	r3, r2
 80055c6:	d902      	bls.n	80055ce <HAL_RCCEx_PeriphCLKConfig+0x6de>
          {
            ret = HAL_TIMEOUT;
 80055c8:	2303      	movs	r3, #3
 80055ca:	75fb      	strb	r3, [r7, #23]
            break;
 80055cc:	e005      	b.n	80055da <HAL_RCCEx_PeriphCLKConfig+0x6ea>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 80055ce:	4b7b      	ldr	r3, [pc, #492]	; (80057bc <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
 80055d0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80055d2:	f003 0302 	and.w	r3, r3, #2
 80055d6:	2b00      	cmp	r3, #0
 80055d8:	d0ed      	beq.n	80055b6 <HAL_RCCEx_PeriphCLKConfig+0x6c6>
          }
        }
      }

      if(ret == HAL_OK)
 80055da:	7dfb      	ldrb	r3, [r7, #23]
 80055dc:	2b00      	cmp	r3, #0
 80055de:	d126      	bne.n	800562e <HAL_RCCEx_PeriphCLKConfig+0x73e>
      {
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 80055e0:	687b      	ldr	r3, [r7, #4]
 80055e2:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 80055e6:	f403 7340 	and.w	r3, r3, #768	; 0x300
 80055ea:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 80055ee:	d10d      	bne.n	800560c <HAL_RCCEx_PeriphCLKConfig+0x71c>
 80055f0:	4b72      	ldr	r3, [pc, #456]	; (80057bc <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
 80055f2:	691b      	ldr	r3, [r3, #16]
 80055f4:	f423 527c 	bic.w	r2, r3, #16128	; 0x3f00
 80055f8:	687b      	ldr	r3, [r7, #4]
 80055fa:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 80055fe:	0919      	lsrs	r1, r3, #4
 8005600:	4b70      	ldr	r3, [pc, #448]	; (80057c4 <HAL_RCCEx_PeriphCLKConfig+0x8d4>)
 8005602:	400b      	ands	r3, r1
 8005604:	496d      	ldr	r1, [pc, #436]	; (80057bc <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
 8005606:	4313      	orrs	r3, r2
 8005608:	610b      	str	r3, [r1, #16]
 800560a:	e005      	b.n	8005618 <HAL_RCCEx_PeriphCLKConfig+0x728>
 800560c:	4b6b      	ldr	r3, [pc, #428]	; (80057bc <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
 800560e:	691b      	ldr	r3, [r3, #16]
 8005610:	4a6a      	ldr	r2, [pc, #424]	; (80057bc <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
 8005612:	f423 537c 	bic.w	r3, r3, #16128	; 0x3f00
 8005616:	6113      	str	r3, [r2, #16]
 8005618:	4b68      	ldr	r3, [pc, #416]	; (80057bc <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
 800561a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800561c:	687b      	ldr	r3, [r7, #4]
 800561e:	f8d3 30b0 	ldr.w	r3, [r3, #176]	; 0xb0
 8005622:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8005626:	4965      	ldr	r1, [pc, #404]	; (80057bc <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
 8005628:	4313      	orrs	r3, r2
 800562a:	670b      	str	r3, [r1, #112]	; 0x70
 800562c:	e004      	b.n	8005638 <HAL_RCCEx_PeriphCLKConfig+0x748>
      }
      else
      {
        /* set overall return value */
        status = ret;
 800562e:	7dfb      	ldrb	r3, [r7, #23]
 8005630:	75bb      	strb	r3, [r7, #22]
 8005632:	e001      	b.n	8005638 <HAL_RCCEx_PeriphCLKConfig+0x748>
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
 8005634:	7dfb      	ldrb	r3, [r7, #23]
 8005636:	75bb      	strb	r3, [r7, #22]
    }
  }


  /*-------------------------- USART1/6 configuration --------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART16) == RCC_PERIPHCLK_USART16)
 8005638:	687b      	ldr	r3, [r7, #4]
 800563a:	681b      	ldr	r3, [r3, #0]
 800563c:	f003 0301 	and.w	r3, r3, #1
 8005640:	2b00      	cmp	r3, #0
 8005642:	d07e      	beq.n	8005742 <HAL_RCCEx_PeriphCLKConfig+0x852>
  {
    switch(PeriphClkInit->Usart16ClockSelection)
 8005644:	687b      	ldr	r3, [r7, #4]
 8005646:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8005648:	2b28      	cmp	r3, #40	; 0x28
 800564a:	d867      	bhi.n	800571c <HAL_RCCEx_PeriphCLKConfig+0x82c>
 800564c:	a201      	add	r2, pc, #4	; (adr r2, 8005654 <HAL_RCCEx_PeriphCLKConfig+0x764>)
 800564e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005652:	bf00      	nop
 8005654:	08005723 	.word	0x08005723
 8005658:	0800571d 	.word	0x0800571d
 800565c:	0800571d 	.word	0x0800571d
 8005660:	0800571d 	.word	0x0800571d
 8005664:	0800571d 	.word	0x0800571d
 8005668:	0800571d 	.word	0x0800571d
 800566c:	0800571d 	.word	0x0800571d
 8005670:	0800571d 	.word	0x0800571d
 8005674:	080056f9 	.word	0x080056f9
 8005678:	0800571d 	.word	0x0800571d
 800567c:	0800571d 	.word	0x0800571d
 8005680:	0800571d 	.word	0x0800571d
 8005684:	0800571d 	.word	0x0800571d
 8005688:	0800571d 	.word	0x0800571d
 800568c:	0800571d 	.word	0x0800571d
 8005690:	0800571d 	.word	0x0800571d
 8005694:	0800570b 	.word	0x0800570b
 8005698:	0800571d 	.word	0x0800571d
 800569c:	0800571d 	.word	0x0800571d
 80056a0:	0800571d 	.word	0x0800571d
 80056a4:	0800571d 	.word	0x0800571d
 80056a8:	0800571d 	.word	0x0800571d
 80056ac:	0800571d 	.word	0x0800571d
 80056b0:	0800571d 	.word	0x0800571d
 80056b4:	08005723 	.word	0x08005723
 80056b8:	0800571d 	.word	0x0800571d
 80056bc:	0800571d 	.word	0x0800571d
 80056c0:	0800571d 	.word	0x0800571d
 80056c4:	0800571d 	.word	0x0800571d
 80056c8:	0800571d 	.word	0x0800571d
 80056cc:	0800571d 	.word	0x0800571d
 80056d0:	0800571d 	.word	0x0800571d
 80056d4:	08005723 	.word	0x08005723
 80056d8:	0800571d 	.word	0x0800571d
 80056dc:	0800571d 	.word	0x0800571d
 80056e0:	0800571d 	.word	0x0800571d
 80056e4:	0800571d 	.word	0x0800571d
 80056e8:	0800571d 	.word	0x0800571d
 80056ec:	0800571d 	.word	0x0800571d
 80056f0:	0800571d 	.word	0x0800571d
 80056f4:	08005723 	.word	0x08005723
    case RCC_USART16CLKSOURCE_PCLK2: /* CD/D2 PCLK2 as clock source for USART1/6 */
      /* USART1/6 clock source configuration done later after clock selection check */
      break;

    case RCC_USART16CLKSOURCE_PLL2: /* PLL2 is used as clock source for USART1/6 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 80056f8:	687b      	ldr	r3, [r7, #4]
 80056fa:	3304      	adds	r3, #4
 80056fc:	2101      	movs	r1, #1
 80056fe:	4618      	mov	r0, r3
 8005700:	f000 fdf4 	bl	80062ec <RCCEx_PLL2_Config>
 8005704:	4603      	mov	r3, r0
 8005706:	75fb      	strb	r3, [r7, #23]
      /* USART1/6 clock source configuration done later after clock selection check */
      break;
 8005708:	e00c      	b.n	8005724 <HAL_RCCEx_PeriphCLKConfig+0x834>

    case RCC_USART16CLKSOURCE_PLL3: /* PLL3 is used as clock source for USART1/6 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 800570a:	687b      	ldr	r3, [r7, #4]
 800570c:	3324      	adds	r3, #36	; 0x24
 800570e:	2101      	movs	r1, #1
 8005710:	4618      	mov	r0, r3
 8005712:	f000 fe9d 	bl	8006450 <RCCEx_PLL3_Config>
 8005716:	4603      	mov	r3, r0
 8005718:	75fb      	strb	r3, [r7, #23]
      /* USART1/6 clock source configuration done later after clock selection check */
      break;
 800571a:	e003      	b.n	8005724 <HAL_RCCEx_PeriphCLKConfig+0x834>
      /* LSE,  oscillator is used as source of USART1/6 clock */
      /* USART1/6 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 800571c:	2301      	movs	r3, #1
 800571e:	75fb      	strb	r3, [r7, #23]
      break;
 8005720:	e000      	b.n	8005724 <HAL_RCCEx_PeriphCLKConfig+0x834>
      break;
 8005722:	bf00      	nop
    }

    if(ret == HAL_OK)
 8005724:	7dfb      	ldrb	r3, [r7, #23]
 8005726:	2b00      	cmp	r3, #0
 8005728:	d109      	bne.n	800573e <HAL_RCCEx_PeriphCLKConfig+0x84e>
    {
      /* Set the source of USART1/6 clock */
      __HAL_RCC_USART16_CONFIG(PeriphClkInit->Usart16ClockSelection);
 800572a:	4b24      	ldr	r3, [pc, #144]	; (80057bc <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
 800572c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800572e:	f023 0238 	bic.w	r2, r3, #56	; 0x38
 8005732:	687b      	ldr	r3, [r7, #4]
 8005734:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8005736:	4921      	ldr	r1, [pc, #132]	; (80057bc <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
 8005738:	4313      	orrs	r3, r2
 800573a:	654b      	str	r3, [r1, #84]	; 0x54
 800573c:	e001      	b.n	8005742 <HAL_RCCEx_PeriphCLKConfig+0x852>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800573e:	7dfb      	ldrb	r3, [r7, #23]
 8005740:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*-------------------------- USART2/3/4/5/7/8 Configuration --------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART234578) == RCC_PERIPHCLK_USART234578)
 8005742:	687b      	ldr	r3, [r7, #4]
 8005744:	681b      	ldr	r3, [r3, #0]
 8005746:	f003 0302 	and.w	r3, r3, #2
 800574a:	2b00      	cmp	r3, #0
 800574c:	d03e      	beq.n	80057cc <HAL_RCCEx_PeriphCLKConfig+0x8dc>
  {
    switch(PeriphClkInit->Usart234578ClockSelection)
 800574e:	687b      	ldr	r3, [r7, #4]
 8005750:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8005752:	2b05      	cmp	r3, #5
 8005754:	d820      	bhi.n	8005798 <HAL_RCCEx_PeriphCLKConfig+0x8a8>
 8005756:	a201      	add	r2, pc, #4	; (adr r2, 800575c <HAL_RCCEx_PeriphCLKConfig+0x86c>)
 8005758:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800575c:	0800579f 	.word	0x0800579f
 8005760:	08005775 	.word	0x08005775
 8005764:	08005787 	.word	0x08005787
 8005768:	0800579f 	.word	0x0800579f
 800576c:	0800579f 	.word	0x0800579f
 8005770:	0800579f 	.word	0x0800579f
    case RCC_USART234578CLKSOURCE_PCLK1: /* CD/D2 PCLK1 as clock source for USART2/3/4/5/7/8 */
      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
      break;

    case RCC_USART234578CLKSOURCE_PLL2: /* PLL2 is used as clock source for USART2/3/4/5/7/8 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 8005774:	687b      	ldr	r3, [r7, #4]
 8005776:	3304      	adds	r3, #4
 8005778:	2101      	movs	r1, #1
 800577a:	4618      	mov	r0, r3
 800577c:	f000 fdb6 	bl	80062ec <RCCEx_PLL2_Config>
 8005780:	4603      	mov	r3, r0
 8005782:	75fb      	strb	r3, [r7, #23]
      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
      break;
 8005784:	e00c      	b.n	80057a0 <HAL_RCCEx_PeriphCLKConfig+0x8b0>

    case RCC_USART234578CLKSOURCE_PLL3: /* PLL3 is used as clock source for USART2/3/4/5/7/8 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 8005786:	687b      	ldr	r3, [r7, #4]
 8005788:	3324      	adds	r3, #36	; 0x24
 800578a:	2101      	movs	r1, #1
 800578c:	4618      	mov	r0, r3
 800578e:	f000 fe5f 	bl	8006450 <RCCEx_PLL3_Config>
 8005792:	4603      	mov	r3, r0
 8005794:	75fb      	strb	r3, [r7, #23]
      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
      break;
 8005796:	e003      	b.n	80057a0 <HAL_RCCEx_PeriphCLKConfig+0x8b0>
      /* LSE,  oscillator is used as source of USART2/3/4/5/7/8 clock */
      /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 8005798:	2301      	movs	r3, #1
 800579a:	75fb      	strb	r3, [r7, #23]
      break;
 800579c:	e000      	b.n	80057a0 <HAL_RCCEx_PeriphCLKConfig+0x8b0>
      break;
 800579e:	bf00      	nop
    }

    if(ret == HAL_OK)
 80057a0:	7dfb      	ldrb	r3, [r7, #23]
 80057a2:	2b00      	cmp	r3, #0
 80057a4:	d110      	bne.n	80057c8 <HAL_RCCEx_PeriphCLKConfig+0x8d8>
    {
      /* Set the source of USART2/3/4/5/7/8 clock */
      __HAL_RCC_USART234578_CONFIG(PeriphClkInit->Usart234578ClockSelection);
 80057a6:	4b05      	ldr	r3, [pc, #20]	; (80057bc <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
 80057a8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80057aa:	f023 0207 	bic.w	r2, r3, #7
 80057ae:	687b      	ldr	r3, [r7, #4]
 80057b0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80057b2:	4902      	ldr	r1, [pc, #8]	; (80057bc <HAL_RCCEx_PeriphCLKConfig+0x8cc>)
 80057b4:	4313      	orrs	r3, r2
 80057b6:	654b      	str	r3, [r1, #84]	; 0x54
 80057b8:	e008      	b.n	80057cc <HAL_RCCEx_PeriphCLKConfig+0x8dc>
 80057ba:	bf00      	nop
 80057bc:	58024400 	.word	0x58024400
 80057c0:	58024800 	.word	0x58024800
 80057c4:	00ffffcf 	.word	0x00ffffcf
    }
    else
    {
      /* set overall return value */
      status = ret;
 80057c8:	7dfb      	ldrb	r3, [r7, #23]
 80057ca:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*-------------------------- LPUART1 Configuration -------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 80057cc:	687b      	ldr	r3, [r7, #4]
 80057ce:	681b      	ldr	r3, [r3, #0]
 80057d0:	f003 0304 	and.w	r3, r3, #4
 80057d4:	2b00      	cmp	r3, #0
 80057d6:	d039      	beq.n	800584c <HAL_RCCEx_PeriphCLKConfig+0x95c>
  {
    switch(PeriphClkInit->Lpuart1ClockSelection)
 80057d8:	687b      	ldr	r3, [r7, #4]
 80057da:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80057de:	2b05      	cmp	r3, #5
 80057e0:	d820      	bhi.n	8005824 <HAL_RCCEx_PeriphCLKConfig+0x934>
 80057e2:	a201      	add	r2, pc, #4	; (adr r2, 80057e8 <HAL_RCCEx_PeriphCLKConfig+0x8f8>)
 80057e4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80057e8:	0800582b 	.word	0x0800582b
 80057ec:	08005801 	.word	0x08005801
 80057f0:	08005813 	.word	0x08005813
 80057f4:	0800582b 	.word	0x0800582b
 80057f8:	0800582b 	.word	0x0800582b
 80057fc:	0800582b 	.word	0x0800582b
    case RCC_LPUART1CLKSOURCE_PCLK4: /* SRD/D3 PCLK1 (PCLK4) as clock source for LPUART1 */
      /* LPUART1 clock source configuration done later after clock selection check */
      break;

    case RCC_LPUART1CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPUART1 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 8005800:	687b      	ldr	r3, [r7, #4]
 8005802:	3304      	adds	r3, #4
 8005804:	2101      	movs	r1, #1
 8005806:	4618      	mov	r0, r3
 8005808:	f000 fd70 	bl	80062ec <RCCEx_PLL2_Config>
 800580c:	4603      	mov	r3, r0
 800580e:	75fb      	strb	r3, [r7, #23]
      /* LPUART1 clock source configuration done later after clock selection check */
      break;
 8005810:	e00c      	b.n	800582c <HAL_RCCEx_PeriphCLKConfig+0x93c>

    case RCC_LPUART1CLKSOURCE_PLL3: /* PLL3 is used as clock source for LPUART1 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 8005812:	687b      	ldr	r3, [r7, #4]
 8005814:	3324      	adds	r3, #36	; 0x24
 8005816:	2101      	movs	r1, #1
 8005818:	4618      	mov	r0, r3
 800581a:	f000 fe19 	bl	8006450 <RCCEx_PLL3_Config>
 800581e:	4603      	mov	r3, r0
 8005820:	75fb      	strb	r3, [r7, #23]
      /* LPUART1 clock source configuration done later after clock selection check */
      break;
 8005822:	e003      	b.n	800582c <HAL_RCCEx_PeriphCLKConfig+0x93c>
      /* LSE,  oscillator is used as source of LPUART1 clock */
      /* LPUART1 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 8005824:	2301      	movs	r3, #1
 8005826:	75fb      	strb	r3, [r7, #23]
      break;
 8005828:	e000      	b.n	800582c <HAL_RCCEx_PeriphCLKConfig+0x93c>
      break;
 800582a:	bf00      	nop
    }

    if(ret == HAL_OK)
 800582c:	7dfb      	ldrb	r3, [r7, #23]
 800582e:	2b00      	cmp	r3, #0
 8005830:	d10a      	bne.n	8005848 <HAL_RCCEx_PeriphCLKConfig+0x958>
    {
      /* Set the source of LPUART1 clock */
      __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 8005832:	4bb7      	ldr	r3, [pc, #732]	; (8005b10 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
 8005834:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8005836:	f023 0207 	bic.w	r2, r3, #7
 800583a:	687b      	ldr	r3, [r7, #4]
 800583c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8005840:	49b3      	ldr	r1, [pc, #716]	; (8005b10 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
 8005842:	4313      	orrs	r3, r2
 8005844:	658b      	str	r3, [r1, #88]	; 0x58
 8005846:	e001      	b.n	800584c <HAL_RCCEx_PeriphCLKConfig+0x95c>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8005848:	7dfb      	ldrb	r3, [r7, #23]
 800584a:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- LPTIM1 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 800584c:	687b      	ldr	r3, [r7, #4]
 800584e:	681b      	ldr	r3, [r3, #0]
 8005850:	f003 0320 	and.w	r3, r3, #32
 8005854:	2b00      	cmp	r3, #0
 8005856:	d04b      	beq.n	80058f0 <HAL_RCCEx_PeriphCLKConfig+0xa00>
  {
    switch(PeriphClkInit->Lptim1ClockSelection)
 8005858:	687b      	ldr	r3, [r7, #4]
 800585a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800585e:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8005862:	d02e      	beq.n	80058c2 <HAL_RCCEx_PeriphCLKConfig+0x9d2>
 8005864:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8005868:	d828      	bhi.n	80058bc <HAL_RCCEx_PeriphCLKConfig+0x9cc>
 800586a:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800586e:	d02a      	beq.n	80058c6 <HAL_RCCEx_PeriphCLKConfig+0x9d6>
 8005870:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8005874:	d822      	bhi.n	80058bc <HAL_RCCEx_PeriphCLKConfig+0x9cc>
 8005876:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
 800587a:	d026      	beq.n	80058ca <HAL_RCCEx_PeriphCLKConfig+0x9da>
 800587c:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
 8005880:	d81c      	bhi.n	80058bc <HAL_RCCEx_PeriphCLKConfig+0x9cc>
 8005882:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8005886:	d010      	beq.n	80058aa <HAL_RCCEx_PeriphCLKConfig+0x9ba>
 8005888:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 800588c:	d816      	bhi.n	80058bc <HAL_RCCEx_PeriphCLKConfig+0x9cc>
 800588e:	2b00      	cmp	r3, #0
 8005890:	d01d      	beq.n	80058ce <HAL_RCCEx_PeriphCLKConfig+0x9de>
 8005892:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8005896:	d111      	bne.n	80058bc <HAL_RCCEx_PeriphCLKConfig+0x9cc>
      /* LPTIM1 clock source configuration done later after clock selection check */
      break;

    case RCC_LPTIM1CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM1*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 8005898:	687b      	ldr	r3, [r7, #4]
 800589a:	3304      	adds	r3, #4
 800589c:	2100      	movs	r1, #0
 800589e:	4618      	mov	r0, r3
 80058a0:	f000 fd24 	bl	80062ec <RCCEx_PLL2_Config>
 80058a4:	4603      	mov	r3, r0
 80058a6:	75fb      	strb	r3, [r7, #23]

      /* LPTIM1 clock source configuration done later after clock selection check */
      break;
 80058a8:	e012      	b.n	80058d0 <HAL_RCCEx_PeriphCLKConfig+0x9e0>

    case RCC_LPTIM1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM1*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
 80058aa:	687b      	ldr	r3, [r7, #4]
 80058ac:	3324      	adds	r3, #36	; 0x24
 80058ae:	2102      	movs	r1, #2
 80058b0:	4618      	mov	r0, r3
 80058b2:	f000 fdcd 	bl	8006450 <RCCEx_PLL3_Config>
 80058b6:	4603      	mov	r3, r0
 80058b8:	75fb      	strb	r3, [r7, #23]

      /* LPTIM1 clock source configuration done later after clock selection check */
      break;
 80058ba:	e009      	b.n	80058d0 <HAL_RCCEx_PeriphCLKConfig+0x9e0>
      /* HSI, HSE, or CSI oscillator is used as source of LPTIM1 clock */
      /* LPTIM1 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 80058bc:	2301      	movs	r3, #1
 80058be:	75fb      	strb	r3, [r7, #23]
      break;
 80058c0:	e006      	b.n	80058d0 <HAL_RCCEx_PeriphCLKConfig+0x9e0>
      break;
 80058c2:	bf00      	nop
 80058c4:	e004      	b.n	80058d0 <HAL_RCCEx_PeriphCLKConfig+0x9e0>
      break;
 80058c6:	bf00      	nop
 80058c8:	e002      	b.n	80058d0 <HAL_RCCEx_PeriphCLKConfig+0x9e0>
      break;
 80058ca:	bf00      	nop
 80058cc:	e000      	b.n	80058d0 <HAL_RCCEx_PeriphCLKConfig+0x9e0>
      break;
 80058ce:	bf00      	nop
    }

    if(ret == HAL_OK)
 80058d0:	7dfb      	ldrb	r3, [r7, #23]
 80058d2:	2b00      	cmp	r3, #0
 80058d4:	d10a      	bne.n	80058ec <HAL_RCCEx_PeriphCLKConfig+0x9fc>
    {
      /* Set the source of LPTIM1 clock*/
      __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 80058d6:	4b8e      	ldr	r3, [pc, #568]	; (8005b10 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
 80058d8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80058da:	f023 42e0 	bic.w	r2, r3, #1879048192	; 0x70000000
 80058de:	687b      	ldr	r3, [r7, #4]
 80058e0:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80058e4:	498a      	ldr	r1, [pc, #552]	; (8005b10 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
 80058e6:	4313      	orrs	r3, r2
 80058e8:	654b      	str	r3, [r1, #84]	; 0x54
 80058ea:	e001      	b.n	80058f0 <HAL_RCCEx_PeriphCLKConfig+0xa00>
    }
    else
    {
      /* set overall return value */
      status = ret;
 80058ec:	7dfb      	ldrb	r3, [r7, #23]
 80058ee:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- LPTIM2 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
 80058f0:	687b      	ldr	r3, [r7, #4]
 80058f2:	681b      	ldr	r3, [r3, #0]
 80058f4:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80058f8:	2b00      	cmp	r3, #0
 80058fa:	d04b      	beq.n	8005994 <HAL_RCCEx_PeriphCLKConfig+0xaa4>
  {
    switch(PeriphClkInit->Lptim2ClockSelection)
 80058fc:	687b      	ldr	r3, [r7, #4]
 80058fe:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8005902:	f5b3 5fa0 	cmp.w	r3, #5120	; 0x1400
 8005906:	d02e      	beq.n	8005966 <HAL_RCCEx_PeriphCLKConfig+0xa76>
 8005908:	f5b3 5fa0 	cmp.w	r3, #5120	; 0x1400
 800590c:	d828      	bhi.n	8005960 <HAL_RCCEx_PeriphCLKConfig+0xa70>
 800590e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8005912:	d02a      	beq.n	800596a <HAL_RCCEx_PeriphCLKConfig+0xa7a>
 8005914:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8005918:	d822      	bhi.n	8005960 <HAL_RCCEx_PeriphCLKConfig+0xa70>
 800591a:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 800591e:	d026      	beq.n	800596e <HAL_RCCEx_PeriphCLKConfig+0xa7e>
 8005920:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 8005924:	d81c      	bhi.n	8005960 <HAL_RCCEx_PeriphCLKConfig+0xa70>
 8005926:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 800592a:	d010      	beq.n	800594e <HAL_RCCEx_PeriphCLKConfig+0xa5e>
 800592c:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8005930:	d816      	bhi.n	8005960 <HAL_RCCEx_PeriphCLKConfig+0xa70>
 8005932:	2b00      	cmp	r3, #0
 8005934:	d01d      	beq.n	8005972 <HAL_RCCEx_PeriphCLKConfig+0xa82>
 8005936:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800593a:	d111      	bne.n	8005960 <HAL_RCCEx_PeriphCLKConfig+0xa70>
      /* LPTIM2 clock source configuration done later after clock selection check */
      break;

    case RCC_LPTIM2CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM2*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 800593c:	687b      	ldr	r3, [r7, #4]
 800593e:	3304      	adds	r3, #4
 8005940:	2100      	movs	r1, #0
 8005942:	4618      	mov	r0, r3
 8005944:	f000 fcd2 	bl	80062ec <RCCEx_PLL2_Config>
 8005948:	4603      	mov	r3, r0
 800594a:	75fb      	strb	r3, [r7, #23]

      /* LPTIM2 clock source configuration done later after clock selection check */
      break;
 800594c:	e012      	b.n	8005974 <HAL_RCCEx_PeriphCLKConfig+0xa84>

    case RCC_LPTIM2CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM2*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
 800594e:	687b      	ldr	r3, [r7, #4]
 8005950:	3324      	adds	r3, #36	; 0x24
 8005952:	2102      	movs	r1, #2
 8005954:	4618      	mov	r0, r3
 8005956:	f000 fd7b 	bl	8006450 <RCCEx_PLL3_Config>
 800595a:	4603      	mov	r3, r0
 800595c:	75fb      	strb	r3, [r7, #23]

      /* LPTIM2 clock source configuration done later after clock selection check */
      break;
 800595e:	e009      	b.n	8005974 <HAL_RCCEx_PeriphCLKConfig+0xa84>
      /* HSI, HSE, or CSI oscillator is used as source of LPTIM2 clock */
      /* LPTIM2 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 8005960:	2301      	movs	r3, #1
 8005962:	75fb      	strb	r3, [r7, #23]
      break;
 8005964:	e006      	b.n	8005974 <HAL_RCCEx_PeriphCLKConfig+0xa84>
      break;
 8005966:	bf00      	nop
 8005968:	e004      	b.n	8005974 <HAL_RCCEx_PeriphCLKConfig+0xa84>
      break;
 800596a:	bf00      	nop
 800596c:	e002      	b.n	8005974 <HAL_RCCEx_PeriphCLKConfig+0xa84>
      break;
 800596e:	bf00      	nop
 8005970:	e000      	b.n	8005974 <HAL_RCCEx_PeriphCLKConfig+0xa84>
      break;
 8005972:	bf00      	nop
    }

    if(ret == HAL_OK)
 8005974:	7dfb      	ldrb	r3, [r7, #23]
 8005976:	2b00      	cmp	r3, #0
 8005978:	d10a      	bne.n	8005990 <HAL_RCCEx_PeriphCLKConfig+0xaa0>
    {
      /* Set the source of LPTIM2 clock*/
      __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 800597a:	4b65      	ldr	r3, [pc, #404]	; (8005b10 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
 800597c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800597e:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
 8005982:	687b      	ldr	r3, [r7, #4]
 8005984:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
 8005988:	4961      	ldr	r1, [pc, #388]	; (8005b10 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
 800598a:	4313      	orrs	r3, r2
 800598c:	658b      	str	r3, [r1, #88]	; 0x58
 800598e:	e001      	b.n	8005994 <HAL_RCCEx_PeriphCLKConfig+0xaa4>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8005990:	7dfb      	ldrb	r3, [r7, #23]
 8005992:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- LPTIM345 configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM345) == RCC_PERIPHCLK_LPTIM345)
 8005994:	687b      	ldr	r3, [r7, #4]
 8005996:	681b      	ldr	r3, [r3, #0]
 8005998:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800599c:	2b00      	cmp	r3, #0
 800599e:	d04b      	beq.n	8005a38 <HAL_RCCEx_PeriphCLKConfig+0xb48>
  {
    switch(PeriphClkInit->Lptim345ClockSelection)
 80059a0:	687b      	ldr	r3, [r7, #4]
 80059a2:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 80059a6:	f5b3 4f20 	cmp.w	r3, #40960	; 0xa000
 80059aa:	d02e      	beq.n	8005a0a <HAL_RCCEx_PeriphCLKConfig+0xb1a>
 80059ac:	f5b3 4f20 	cmp.w	r3, #40960	; 0xa000
 80059b0:	d828      	bhi.n	8005a04 <HAL_RCCEx_PeriphCLKConfig+0xb14>
 80059b2:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 80059b6:	d02a      	beq.n	8005a0e <HAL_RCCEx_PeriphCLKConfig+0xb1e>
 80059b8:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 80059bc:	d822      	bhi.n	8005a04 <HAL_RCCEx_PeriphCLKConfig+0xb14>
 80059be:	f5b3 4fc0 	cmp.w	r3, #24576	; 0x6000
 80059c2:	d026      	beq.n	8005a12 <HAL_RCCEx_PeriphCLKConfig+0xb22>
 80059c4:	f5b3 4fc0 	cmp.w	r3, #24576	; 0x6000
 80059c8:	d81c      	bhi.n	8005a04 <HAL_RCCEx_PeriphCLKConfig+0xb14>
 80059ca:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 80059ce:	d010      	beq.n	80059f2 <HAL_RCCEx_PeriphCLKConfig+0xb02>
 80059d0:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 80059d4:	d816      	bhi.n	8005a04 <HAL_RCCEx_PeriphCLKConfig+0xb14>
 80059d6:	2b00      	cmp	r3, #0
 80059d8:	d01d      	beq.n	8005a16 <HAL_RCCEx_PeriphCLKConfig+0xb26>
 80059da:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 80059de:	d111      	bne.n	8005a04 <HAL_RCCEx_PeriphCLKConfig+0xb14>
    case RCC_LPTIM345CLKSOURCE_PCLK4:      /* SRD/D3 PCLK1 (PCLK4) as clock source for LPTIM3/4/5 */
      /* LPTIM3/4/5 clock source configuration done later after clock selection check */
      break;

    case RCC_LPTIM345CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM3/4/5 */
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 80059e0:	687b      	ldr	r3, [r7, #4]
 80059e2:	3304      	adds	r3, #4
 80059e4:	2100      	movs	r1, #0
 80059e6:	4618      	mov	r0, r3
 80059e8:	f000 fc80 	bl	80062ec <RCCEx_PLL2_Config>
 80059ec:	4603      	mov	r3, r0
 80059ee:	75fb      	strb	r3, [r7, #23]

      /* LPTIM3/4/5 clock source configuration done later after clock selection check */
      break;
 80059f0:	e012      	b.n	8005a18 <HAL_RCCEx_PeriphCLKConfig+0xb28>

    case RCC_LPTIM345CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM3/4/5 */
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
 80059f2:	687b      	ldr	r3, [r7, #4]
 80059f4:	3324      	adds	r3, #36	; 0x24
 80059f6:	2102      	movs	r1, #2
 80059f8:	4618      	mov	r0, r3
 80059fa:	f000 fd29 	bl	8006450 <RCCEx_PLL3_Config>
 80059fe:	4603      	mov	r3, r0
 8005a00:	75fb      	strb	r3, [r7, #23]

      /* LPTIM3/4/5 clock source configuration done later after clock selection check */
      break;
 8005a02:	e009      	b.n	8005a18 <HAL_RCCEx_PeriphCLKConfig+0xb28>
      /* HSI, HSE, or CSI oscillator is used as source of LPTIM3/4/5 clock */
      /* LPTIM3/4/5 clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 8005a04:	2301      	movs	r3, #1
 8005a06:	75fb      	strb	r3, [r7, #23]
      break;
 8005a08:	e006      	b.n	8005a18 <HAL_RCCEx_PeriphCLKConfig+0xb28>
      break;
 8005a0a:	bf00      	nop
 8005a0c:	e004      	b.n	8005a18 <HAL_RCCEx_PeriphCLKConfig+0xb28>
      break;
 8005a0e:	bf00      	nop
 8005a10:	e002      	b.n	8005a18 <HAL_RCCEx_PeriphCLKConfig+0xb28>
      break;
 8005a12:	bf00      	nop
 8005a14:	e000      	b.n	8005a18 <HAL_RCCEx_PeriphCLKConfig+0xb28>
      break;
 8005a16:	bf00      	nop
    }

    if(ret == HAL_OK)
 8005a18:	7dfb      	ldrb	r3, [r7, #23]
 8005a1a:	2b00      	cmp	r3, #0
 8005a1c:	d10a      	bne.n	8005a34 <HAL_RCCEx_PeriphCLKConfig+0xb44>
    {
      /* Set the source of LPTIM3/4/5 clock */
      __HAL_RCC_LPTIM345_CONFIG(PeriphClkInit->Lptim345ClockSelection);
 8005a1e:	4b3c      	ldr	r3, [pc, #240]	; (8005b10 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
 8005a20:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8005a22:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
 8005a26:	687b      	ldr	r3, [r7, #4]
 8005a28:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8005a2c:	4938      	ldr	r1, [pc, #224]	; (8005b10 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
 8005a2e:	4313      	orrs	r3, r2
 8005a30:	658b      	str	r3, [r1, #88]	; 0x58
 8005a32:	e001      	b.n	8005a38 <HAL_RCCEx_PeriphCLKConfig+0xb48>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8005a34:	7dfb      	ldrb	r3, [r7, #23]
 8005a36:	75bb      	strb	r3, [r7, #22]

      __HAL_RCC_I2C1235_CONFIG(PeriphClkInit->I2c1235ClockSelection);

  }
#else
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C123) == RCC_PERIPHCLK_I2C123)
 8005a38:	687b      	ldr	r3, [r7, #4]
 8005a3a:	681b      	ldr	r3, [r3, #0]
 8005a3c:	f003 0308 	and.w	r3, r3, #8
 8005a40:	2b00      	cmp	r3, #0
 8005a42:	d01a      	beq.n	8005a7a <HAL_RCCEx_PeriphCLKConfig+0xb8a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C123CLKSOURCE(PeriphClkInit->I2c123ClockSelection));

    if ((PeriphClkInit->I2c123ClockSelection )== RCC_I2C123CLKSOURCE_PLL3 )
 8005a44:	687b      	ldr	r3, [r7, #4]
 8005a46:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8005a4a:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8005a4e:	d10a      	bne.n	8005a66 <HAL_RCCEx_PeriphCLKConfig+0xb76>
    {
        if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)
 8005a50:	687b      	ldr	r3, [r7, #4]
 8005a52:	3324      	adds	r3, #36	; 0x24
 8005a54:	2102      	movs	r1, #2
 8005a56:	4618      	mov	r0, r3
 8005a58:	f000 fcfa 	bl	8006450 <RCCEx_PLL3_Config>
 8005a5c:	4603      	mov	r3, r0
 8005a5e:	2b00      	cmp	r3, #0
 8005a60:	d001      	beq.n	8005a66 <HAL_RCCEx_PeriphCLKConfig+0xb76>
        {
          status = HAL_ERROR;
 8005a62:	2301      	movs	r3, #1
 8005a64:	75bb      	strb	r3, [r7, #22]
        }
    }

      __HAL_RCC_I2C123_CONFIG(PeriphClkInit->I2c123ClockSelection);
 8005a66:	4b2a      	ldr	r3, [pc, #168]	; (8005b10 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
 8005a68:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8005a6a:	f423 5240 	bic.w	r2, r3, #12288	; 0x3000
 8005a6e:	687b      	ldr	r3, [r7, #4]
 8005a70:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8005a74:	4926      	ldr	r1, [pc, #152]	; (8005b10 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
 8005a76:	4313      	orrs	r3, r2
 8005a78:	654b      	str	r3, [r1, #84]	; 0x54

  }
#endif /* I2C5 */

  /*------------------------------ I2C4 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 8005a7a:	687b      	ldr	r3, [r7, #4]
 8005a7c:	681b      	ldr	r3, [r3, #0]
 8005a7e:	f003 0310 	and.w	r3, r3, #16
 8005a82:	2b00      	cmp	r3, #0
 8005a84:	d01a      	beq.n	8005abc <HAL_RCCEx_PeriphCLKConfig+0xbcc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    if ((PeriphClkInit->I2c4ClockSelection) == RCC_I2C4CLKSOURCE_PLL3 )
 8005a86:	687b      	ldr	r3, [r7, #4]
 8005a88:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8005a8c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8005a90:	d10a      	bne.n	8005aa8 <HAL_RCCEx_PeriphCLKConfig+0xbb8>
    {
      if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)
 8005a92:	687b      	ldr	r3, [r7, #4]
 8005a94:	3324      	adds	r3, #36	; 0x24
 8005a96:	2102      	movs	r1, #2
 8005a98:	4618      	mov	r0, r3
 8005a9a:	f000 fcd9 	bl	8006450 <RCCEx_PLL3_Config>
 8005a9e:	4603      	mov	r3, r0
 8005aa0:	2b00      	cmp	r3, #0
 8005aa2:	d001      	beq.n	8005aa8 <HAL_RCCEx_PeriphCLKConfig+0xbb8>
      {
        status = HAL_ERROR;
 8005aa4:	2301      	movs	r3, #1
 8005aa6:	75bb      	strb	r3, [r7, #22]
      }
    }

      __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 8005aa8:	4b19      	ldr	r3, [pc, #100]	; (8005b10 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
 8005aaa:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8005aac:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 8005ab0:	687b      	ldr	r3, [r7, #4]
 8005ab2:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8005ab6:	4916      	ldr	r1, [pc, #88]	; (8005b10 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
 8005ab8:	4313      	orrs	r3, r2
 8005aba:	658b      	str	r3, [r1, #88]	; 0x58

  }

  /*---------------------------- ADC configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 8005abc:	687b      	ldr	r3, [r7, #4]
 8005abe:	681b      	ldr	r3, [r3, #0]
 8005ac0:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8005ac4:	2b00      	cmp	r3, #0
 8005ac6:	d036      	beq.n	8005b36 <HAL_RCCEx_PeriphCLKConfig+0xc46>
  {
    switch(PeriphClkInit->AdcClockSelection)
 8005ac8:	687b      	ldr	r3, [r7, #4]
 8005aca:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 8005ace:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8005ad2:	d01f      	beq.n	8005b14 <HAL_RCCEx_PeriphCLKConfig+0xc24>
 8005ad4:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8005ad8:	d817      	bhi.n	8005b0a <HAL_RCCEx_PeriphCLKConfig+0xc1a>
 8005ada:	2b00      	cmp	r3, #0
 8005adc:	d003      	beq.n	8005ae6 <HAL_RCCEx_PeriphCLKConfig+0xbf6>
 8005ade:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8005ae2:	d009      	beq.n	8005af8 <HAL_RCCEx_PeriphCLKConfig+0xc08>
 8005ae4:	e011      	b.n	8005b0a <HAL_RCCEx_PeriphCLKConfig+0xc1a>
    {

    case RCC_ADCCLKSOURCE_PLL2: /* PLL2 is used as clock source for ADC*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 8005ae6:	687b      	ldr	r3, [r7, #4]
 8005ae8:	3304      	adds	r3, #4
 8005aea:	2100      	movs	r1, #0
 8005aec:	4618      	mov	r0, r3
 8005aee:	f000 fbfd 	bl	80062ec <RCCEx_PLL2_Config>
 8005af2:	4603      	mov	r3, r0
 8005af4:	75fb      	strb	r3, [r7, #23]

      /* ADC clock source configuration done later after clock selection check */
      break;
 8005af6:	e00e      	b.n	8005b16 <HAL_RCCEx_PeriphCLKConfig+0xc26>

    case RCC_ADCCLKSOURCE_PLL3:  /* PLL3 is used as clock source for ADC*/
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
 8005af8:	687b      	ldr	r3, [r7, #4]
 8005afa:	3324      	adds	r3, #36	; 0x24
 8005afc:	2102      	movs	r1, #2
 8005afe:	4618      	mov	r0, r3
 8005b00:	f000 fca6 	bl	8006450 <RCCEx_PLL3_Config>
 8005b04:	4603      	mov	r3, r0
 8005b06:	75fb      	strb	r3, [r7, #23]

      /* ADC clock source configuration done later after clock selection check */
      break;
 8005b08:	e005      	b.n	8005b16 <HAL_RCCEx_PeriphCLKConfig+0xc26>
      /* HSI, HSE, or CSI oscillator is used as source of ADC clock */
      /* ADC clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 8005b0a:	2301      	movs	r3, #1
 8005b0c:	75fb      	strb	r3, [r7, #23]
      break;
 8005b0e:	e002      	b.n	8005b16 <HAL_RCCEx_PeriphCLKConfig+0xc26>
 8005b10:	58024400 	.word	0x58024400
      break;
 8005b14:	bf00      	nop
    }

    if(ret == HAL_OK)
 8005b16:	7dfb      	ldrb	r3, [r7, #23]
 8005b18:	2b00      	cmp	r3, #0
 8005b1a:	d10a      	bne.n	8005b32 <HAL_RCCEx_PeriphCLKConfig+0xc42>
    {
      /* Set the source of ADC clock*/
      __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8005b1c:	4b93      	ldr	r3, [pc, #588]	; (8005d6c <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
 8005b1e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8005b20:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
 8005b24:	687b      	ldr	r3, [r7, #4]
 8005b26:	f8d3 30a0 	ldr.w	r3, [r3, #160]	; 0xa0
 8005b2a:	4990      	ldr	r1, [pc, #576]	; (8005d6c <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
 8005b2c:	4313      	orrs	r3, r2
 8005b2e:	658b      	str	r3, [r1, #88]	; 0x58
 8005b30:	e001      	b.n	8005b36 <HAL_RCCEx_PeriphCLKConfig+0xc46>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8005b32:	7dfb      	ldrb	r3, [r7, #23]
 8005b34:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*------------------------------ USB Configuration -------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
 8005b36:	687b      	ldr	r3, [r7, #4]
 8005b38:	681b      	ldr	r3, [r3, #0]
 8005b3a:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8005b3e:	2b00      	cmp	r3, #0
 8005b40:	d033      	beq.n	8005baa <HAL_RCCEx_PeriphCLKConfig+0xcba>
  {

    switch(PeriphClkInit->UsbClockSelection)
 8005b42:	687b      	ldr	r3, [r7, #4]
 8005b44:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8005b48:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
 8005b4c:	d01c      	beq.n	8005b88 <HAL_RCCEx_PeriphCLKConfig+0xc98>
 8005b4e:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
 8005b52:	d816      	bhi.n	8005b82 <HAL_RCCEx_PeriphCLKConfig+0xc92>
 8005b54:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8005b58:	d003      	beq.n	8005b62 <HAL_RCCEx_PeriphCLKConfig+0xc72>
 8005b5a:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 8005b5e:	d007      	beq.n	8005b70 <HAL_RCCEx_PeriphCLKConfig+0xc80>
 8005b60:	e00f      	b.n	8005b82 <HAL_RCCEx_PeriphCLKConfig+0xc92>
    {
    case RCC_USBCLKSOURCE_PLL:      /* PLL is used as clock source for USB*/
      /* Enable USB Clock output generated form System USB . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8005b62:	4b82      	ldr	r3, [pc, #520]	; (8005d6c <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
 8005b64:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005b66:	4a81      	ldr	r2, [pc, #516]	; (8005d6c <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
 8005b68:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8005b6c:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* USB clock source configuration done later after clock selection check */
      break;
 8005b6e:	e00c      	b.n	8005b8a <HAL_RCCEx_PeriphCLKConfig+0xc9a>

    case RCC_USBCLKSOURCE_PLL3: /* PLL3 is used as clock source for USB*/

      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 8005b70:	687b      	ldr	r3, [r7, #4]
 8005b72:	3324      	adds	r3, #36	; 0x24
 8005b74:	2101      	movs	r1, #1
 8005b76:	4618      	mov	r0, r3
 8005b78:	f000 fc6a 	bl	8006450 <RCCEx_PLL3_Config>
 8005b7c:	4603      	mov	r3, r0
 8005b7e:	75fb      	strb	r3, [r7, #23]

      /* USB clock source configuration done later after clock selection check */
      break;
 8005b80:	e003      	b.n	8005b8a <HAL_RCCEx_PeriphCLKConfig+0xc9a>
      /* HSI48 oscillator is used as source of USB clock */
      /* USB clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 8005b82:	2301      	movs	r3, #1
 8005b84:	75fb      	strb	r3, [r7, #23]
      break;
 8005b86:	e000      	b.n	8005b8a <HAL_RCCEx_PeriphCLKConfig+0xc9a>
      break;
 8005b88:	bf00      	nop
    }

    if(ret == HAL_OK)
 8005b8a:	7dfb      	ldrb	r3, [r7, #23]
 8005b8c:	2b00      	cmp	r3, #0
 8005b8e:	d10a      	bne.n	8005ba6 <HAL_RCCEx_PeriphCLKConfig+0xcb6>
    {
      /* Set the source of USB clock*/
      __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8005b90:	4b76      	ldr	r3, [pc, #472]	; (8005d6c <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
 8005b92:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8005b94:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
 8005b98:	687b      	ldr	r3, [r7, #4]
 8005b9a:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8005b9e:	4973      	ldr	r1, [pc, #460]	; (8005d6c <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
 8005ba0:	4313      	orrs	r3, r2
 8005ba2:	654b      	str	r3, [r1, #84]	; 0x54
 8005ba4:	e001      	b.n	8005baa <HAL_RCCEx_PeriphCLKConfig+0xcba>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8005ba6:	7dfb      	ldrb	r3, [r7, #23]
 8005ba8:	75bb      	strb	r3, [r7, #22]
    }

  }

  /*------------------------------------- SDMMC Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC) == RCC_PERIPHCLK_SDMMC)
 8005baa:	687b      	ldr	r3, [r7, #4]
 8005bac:	681b      	ldr	r3, [r3, #0]
 8005bae:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8005bb2:	2b00      	cmp	r3, #0
 8005bb4:	d029      	beq.n	8005c0a <HAL_RCCEx_PeriphCLKConfig+0xd1a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC(PeriphClkInit->SdmmcClockSelection));

    switch(PeriphClkInit->SdmmcClockSelection)
 8005bb6:	687b      	ldr	r3, [r7, #4]
 8005bb8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8005bba:	2b00      	cmp	r3, #0
 8005bbc:	d003      	beq.n	8005bc6 <HAL_RCCEx_PeriphCLKConfig+0xcd6>
 8005bbe:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8005bc2:	d007      	beq.n	8005bd4 <HAL_RCCEx_PeriphCLKConfig+0xce4>
 8005bc4:	e00f      	b.n	8005be6 <HAL_RCCEx_PeriphCLKConfig+0xcf6>
    {
    case RCC_SDMMCCLKSOURCE_PLL:      /* PLL is used as clock source for SDMMC*/
      /* Enable SDMMC Clock output generated form System PLL . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8005bc6:	4b69      	ldr	r3, [pc, #420]	; (8005d6c <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
 8005bc8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005bca:	4a68      	ldr	r2, [pc, #416]	; (8005d6c <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
 8005bcc:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8005bd0:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* SDMMC clock source configuration done later after clock selection check */
      break;
 8005bd2:	e00b      	b.n	8005bec <HAL_RCCEx_PeriphCLKConfig+0xcfc>

    case RCC_SDMMCCLKSOURCE_PLL2: /* PLL2 is used as clock source for SDMMC*/

      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
 8005bd4:	687b      	ldr	r3, [r7, #4]
 8005bd6:	3304      	adds	r3, #4
 8005bd8:	2102      	movs	r1, #2
 8005bda:	4618      	mov	r0, r3
 8005bdc:	f000 fb86 	bl	80062ec <RCCEx_PLL2_Config>
 8005be0:	4603      	mov	r3, r0
 8005be2:	75fb      	strb	r3, [r7, #23]

      /* SDMMC clock source configuration done later after clock selection check */
      break;
 8005be4:	e002      	b.n	8005bec <HAL_RCCEx_PeriphCLKConfig+0xcfc>

    default:
      ret = HAL_ERROR;
 8005be6:	2301      	movs	r3, #1
 8005be8:	75fb      	strb	r3, [r7, #23]
      break;
 8005bea:	bf00      	nop
    }

    if(ret == HAL_OK)
 8005bec:	7dfb      	ldrb	r3, [r7, #23]
 8005bee:	2b00      	cmp	r3, #0
 8005bf0:	d109      	bne.n	8005c06 <HAL_RCCEx_PeriphCLKConfig+0xd16>
    {
      /* Set the source of SDMMC clock*/
      __HAL_RCC_SDMMC_CONFIG(PeriphClkInit->SdmmcClockSelection);
 8005bf2:	4b5e      	ldr	r3, [pc, #376]	; (8005d6c <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
 8005bf4:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8005bf6:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 8005bfa:	687b      	ldr	r3, [r7, #4]
 8005bfc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8005bfe:	495b      	ldr	r1, [pc, #364]	; (8005d6c <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
 8005c00:	4313      	orrs	r3, r2
 8005c02:	64cb      	str	r3, [r1, #76]	; 0x4c
 8005c04:	e001      	b.n	8005c0a <HAL_RCCEx_PeriphCLKConfig+0xd1a>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8005c06:	7dfb      	ldrb	r3, [r7, #23]
 8005c08:	75bb      	strb	r3, [r7, #22]
    }
  }

#if defined(LTDC)
  /*-------------------------------------- LTDC Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
 8005c0a:	687b      	ldr	r3, [r7, #4]
 8005c0c:	681b      	ldr	r3, [r3, #0]
 8005c0e:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 8005c12:	2b00      	cmp	r3, #0
 8005c14:	d00a      	beq.n	8005c2c <HAL_RCCEx_PeriphCLKConfig+0xd3c>
  {
    if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!=HAL_OK)
 8005c16:	687b      	ldr	r3, [r7, #4]
 8005c18:	3324      	adds	r3, #36	; 0x24
 8005c1a:	2102      	movs	r1, #2
 8005c1c:	4618      	mov	r0, r3
 8005c1e:	f000 fc17 	bl	8006450 <RCCEx_PLL3_Config>
 8005c22:	4603      	mov	r3, r0
 8005c24:	2b00      	cmp	r3, #0
 8005c26:	d001      	beq.n	8005c2c <HAL_RCCEx_PeriphCLKConfig+0xd3c>
    {
      status=HAL_ERROR;
 8005c28:	2301      	movs	r3, #1
 8005c2a:	75bb      	strb	r3, [r7, #22]
    }
  }
#endif /* LTDC */

  /*------------------------------ RNG Configuration -------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == RCC_PERIPHCLK_RNG)
 8005c2c:	687b      	ldr	r3, [r7, #4]
 8005c2e:	681b      	ldr	r3, [r3, #0]
 8005c30:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8005c34:	2b00      	cmp	r3, #0
 8005c36:	d030      	beq.n	8005c9a <HAL_RCCEx_PeriphCLKConfig+0xdaa>
  {

    switch(PeriphClkInit->RngClockSelection)
 8005c38:	687b      	ldr	r3, [r7, #4]
 8005c3a:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8005c3c:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8005c40:	d017      	beq.n	8005c72 <HAL_RCCEx_PeriphCLKConfig+0xd82>
 8005c42:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8005c46:	d811      	bhi.n	8005c6c <HAL_RCCEx_PeriphCLKConfig+0xd7c>
 8005c48:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8005c4c:	d013      	beq.n	8005c76 <HAL_RCCEx_PeriphCLKConfig+0xd86>
 8005c4e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8005c52:	d80b      	bhi.n	8005c6c <HAL_RCCEx_PeriphCLKConfig+0xd7c>
 8005c54:	2b00      	cmp	r3, #0
 8005c56:	d010      	beq.n	8005c7a <HAL_RCCEx_PeriphCLKConfig+0xd8a>
 8005c58:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8005c5c:	d106      	bne.n	8005c6c <HAL_RCCEx_PeriphCLKConfig+0xd7c>
    {
    case RCC_RNGCLKSOURCE_PLL:     /* PLL is used as clock source for RNG*/
      /* Enable RNG Clock output generated form System RNG . */
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8005c5e:	4b43      	ldr	r3, [pc, #268]	; (8005d6c <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
 8005c60:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005c62:	4a42      	ldr	r2, [pc, #264]	; (8005d6c <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
 8005c64:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8005c68:	62d3      	str	r3, [r2, #44]	; 0x2c

      /* RNG clock source configuration done later after clock selection check */
      break;
 8005c6a:	e007      	b.n	8005c7c <HAL_RCCEx_PeriphCLKConfig+0xd8c>
      /* HSI48 oscillator is used as source of RNG clock */
      /* RNG clock source configuration done later after clock selection check */
      break;

    default:
      ret = HAL_ERROR;
 8005c6c:	2301      	movs	r3, #1
 8005c6e:	75fb      	strb	r3, [r7, #23]
      break;
 8005c70:	e004      	b.n	8005c7c <HAL_RCCEx_PeriphCLKConfig+0xd8c>
      break;
 8005c72:	bf00      	nop
 8005c74:	e002      	b.n	8005c7c <HAL_RCCEx_PeriphCLKConfig+0xd8c>
      break;
 8005c76:	bf00      	nop
 8005c78:	e000      	b.n	8005c7c <HAL_RCCEx_PeriphCLKConfig+0xd8c>
      break;
 8005c7a:	bf00      	nop
    }

    if(ret == HAL_OK)
 8005c7c:	7dfb      	ldrb	r3, [r7, #23]
 8005c7e:	2b00      	cmp	r3, #0
 8005c80:	d109      	bne.n	8005c96 <HAL_RCCEx_PeriphCLKConfig+0xda6>
    {
      /* Set the source of RNG clock*/
      __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8005c82:	4b3a      	ldr	r3, [pc, #232]	; (8005d6c <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
 8005c84:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8005c86:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 8005c8a:	687b      	ldr	r3, [r7, #4]
 8005c8c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8005c8e:	4937      	ldr	r1, [pc, #220]	; (8005d6c <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
 8005c90:	4313      	orrs	r3, r2
 8005c92:	654b      	str	r3, [r1, #84]	; 0x54
 8005c94:	e001      	b.n	8005c9a <HAL_RCCEx_PeriphCLKConfig+0xdaa>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8005c96:	7dfb      	ldrb	r3, [r7, #23]
 8005c98:	75bb      	strb	r3, [r7, #22]
    }

  }

  /*------------------------------ SWPMI1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
 8005c9a:	687b      	ldr	r3, [r7, #4]
 8005c9c:	681b      	ldr	r3, [r3, #0]
 8005c9e:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8005ca2:	2b00      	cmp	r3, #0
 8005ca4:	d008      	beq.n	8005cb8 <HAL_RCCEx_PeriphCLKConfig+0xdc8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));

    /* Configure the SWPMI1 interface clock source */
    __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);
 8005ca6:	4b31      	ldr	r3, [pc, #196]	; (8005d6c <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
 8005ca8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8005caa:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 8005cae:	687b      	ldr	r3, [r7, #4]
 8005cb0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8005cb2:	492e      	ldr	r1, [pc, #184]	; (8005d6c <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
 8005cb4:	4313      	orrs	r3, r2
 8005cb6:	650b      	str	r3, [r1, #80]	; 0x50
  }
#if defined(HRTIM1)
  /*------------------------------ HRTIM1 clock Configuration ----------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_HRTIM1) == RCC_PERIPHCLK_HRTIM1)
 8005cb8:	687b      	ldr	r3, [r7, #4]
 8005cba:	681b      	ldr	r3, [r3, #0]
 8005cbc:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8005cc0:	2b00      	cmp	r3, #0
 8005cc2:	d009      	beq.n	8005cd8 <HAL_RCCEx_PeriphCLKConfig+0xde8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HRTIM1CLKSOURCE(PeriphClkInit->Hrtim1ClockSelection));

    /* Configure the HRTIM1 clock source */
    __HAL_RCC_HRTIM1_CONFIG(PeriphClkInit->Hrtim1ClockSelection);
 8005cc4:	4b29      	ldr	r3, [pc, #164]	; (8005d6c <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
 8005cc6:	691b      	ldr	r3, [r3, #16]
 8005cc8:	f423 4280 	bic.w	r2, r3, #16384	; 0x4000
 8005ccc:	687b      	ldr	r3, [r7, #4]
 8005cce:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 8005cd2:	4926      	ldr	r1, [pc, #152]	; (8005d6c <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
 8005cd4:	4313      	orrs	r3, r2
 8005cd6:	610b      	str	r3, [r1, #16]
  }
#endif  /*HRTIM1*/
  /*------------------------------ DFSDM1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 8005cd8:	687b      	ldr	r3, [r7, #4]
 8005cda:	681b      	ldr	r3, [r3, #0]
 8005cdc:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8005ce0:	2b00      	cmp	r3, #0
 8005ce2:	d008      	beq.n	8005cf6 <HAL_RCCEx_PeriphCLKConfig+0xe06>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));

    /* Configure the DFSDM1 interface clock source */
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 8005ce4:	4b21      	ldr	r3, [pc, #132]	; (8005d6c <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
 8005ce6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8005ce8:	f023 7280 	bic.w	r2, r3, #16777216	; 0x1000000
 8005cec:	687b      	ldr	r3, [r7, #4]
 8005cee:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8005cf0:	491e      	ldr	r1, [pc, #120]	; (8005d6c <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
 8005cf2:	4313      	orrs	r3, r2
 8005cf4:	650b      	str	r3, [r1, #80]	; 0x50
    __HAL_RCC_DFSDM2_CONFIG(PeriphClkInit->Dfsdm2ClockSelection);
  }
#endif  /* DFSDM2 */

  /*------------------------------------ TIM configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
 8005cf6:	687b      	ldr	r3, [r7, #4]
 8005cf8:	681b      	ldr	r3, [r3, #0]
 8005cfa:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 8005cfe:	2b00      	cmp	r3, #0
 8005d00:	d00d      	beq.n	8005d1e <HAL_RCCEx_PeriphCLKConfig+0xe2e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 8005d02:	4b1a      	ldr	r3, [pc, #104]	; (8005d6c <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
 8005d04:	691b      	ldr	r3, [r3, #16]
 8005d06:	4a19      	ldr	r2, [pc, #100]	; (8005d6c <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
 8005d08:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8005d0c:	6113      	str	r3, [r2, #16]
 8005d0e:	4b17      	ldr	r3, [pc, #92]	; (8005d6c <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
 8005d10:	691a      	ldr	r2, [r3, #16]
 8005d12:	687b      	ldr	r3, [r7, #4]
 8005d14:	f8d3 30b8 	ldr.w	r3, [r3, #184]	; 0xb8
 8005d18:	4914      	ldr	r1, [pc, #80]	; (8005d6c <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
 8005d1a:	4313      	orrs	r3, r2
 8005d1c:	610b      	str	r3, [r1, #16]
  }

  /*------------------------------------ CKPER configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
 8005d1e:	687b      	ldr	r3, [r7, #4]
 8005d20:	681b      	ldr	r3, [r3, #0]
 8005d22:	2b00      	cmp	r3, #0
 8005d24:	da08      	bge.n	8005d38 <HAL_RCCEx_PeriphCLKConfig+0xe48>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLKPSOURCE(PeriphClkInit->CkperClockSelection));

    /* Configure the CKPER clock source */
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
 8005d26:	4b11      	ldr	r3, [pc, #68]	; (8005d6c <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
 8005d28:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8005d2a:	f023 5240 	bic.w	r2, r3, #805306368	; 0x30000000
 8005d2e:	687b      	ldr	r3, [r7, #4]
 8005d30:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8005d32:	490e      	ldr	r1, [pc, #56]	; (8005d6c <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
 8005d34:	4313      	orrs	r3, r2
 8005d36:	64cb      	str	r3, [r1, #76]	; 0x4c
  }

  /*------------------------------ CEC Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 8005d38:	687b      	ldr	r3, [r7, #4]
 8005d3a:	681b      	ldr	r3, [r3, #0]
 8005d3c:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8005d40:	2b00      	cmp	r3, #0
 8005d42:	d009      	beq.n	8005d58 <HAL_RCCEx_PeriphCLKConfig+0xe68>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));

    /* Configure the CEC interface clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
 8005d44:	4b09      	ldr	r3, [pc, #36]	; (8005d6c <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
 8005d46:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8005d48:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
 8005d4c:	687b      	ldr	r3, [r7, #4]
 8005d4e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8005d52:	4906      	ldr	r1, [pc, #24]	; (8005d6c <HAL_RCCEx_PeriphCLKConfig+0xe7c>)
 8005d54:	4313      	orrs	r3, r2
 8005d56:	654b      	str	r3, [r1, #84]	; 0x54
  }

  if (status == HAL_OK)
 8005d58:	7dbb      	ldrb	r3, [r7, #22]
 8005d5a:	2b00      	cmp	r3, #0
 8005d5c:	d101      	bne.n	8005d62 <HAL_RCCEx_PeriphCLKConfig+0xe72>
  {
    return HAL_OK;
 8005d5e:	2300      	movs	r3, #0
 8005d60:	e000      	b.n	8005d64 <HAL_RCCEx_PeriphCLKConfig+0xe74>
  }
  return HAL_ERROR;
 8005d62:	2301      	movs	r3, #1
}
 8005d64:	4618      	mov	r0, r3
 8005d66:	3718      	adds	r7, #24
 8005d68:	46bd      	mov	sp, r7
 8005d6a:	bd80      	pop	{r7, pc}
 8005d6c:	58024400 	.word	0x58024400

08005d70 <HAL_RCCEx_GetD3PCLK1Freq>:
  * @note   Each time D3PCLK1 changes, this function must be called to update the
  *         right D3PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval D3PCLK1 frequency
  */
uint32_t HAL_RCCEx_GetD3PCLK1Freq(void)
{
 8005d70:	b580      	push	{r7, lr}
 8005d72:	af00      	add	r7, sp, #0
#if defined(RCC_D3CFGR_D3PPRE)
  /* Get HCLK source and Compute D3PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->D3CFGR & RCC_D3CFGR_D3PPRE)>> RCC_D3CFGR_D3PPRE_Pos] & 0x1FU));
 8005d74:	f7ff f81e 	bl	8004db4 <HAL_RCC_GetHCLKFreq>
 8005d78:	4602      	mov	r2, r0
 8005d7a:	4b06      	ldr	r3, [pc, #24]	; (8005d94 <HAL_RCCEx_GetD3PCLK1Freq+0x24>)
 8005d7c:	6a1b      	ldr	r3, [r3, #32]
 8005d7e:	091b      	lsrs	r3, r3, #4
 8005d80:	f003 0307 	and.w	r3, r3, #7
 8005d84:	4904      	ldr	r1, [pc, #16]	; (8005d98 <HAL_RCCEx_GetD3PCLK1Freq+0x28>)
 8005d86:	5ccb      	ldrb	r3, [r1, r3]
 8005d88:	f003 031f 	and.w	r3, r3, #31
 8005d8c:	fa22 f303 	lsr.w	r3, r2, r3
#else
  /* Get HCLK source and Compute D3PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE)>> RCC_SRDCFGR_SRDPPRE_Pos] & 0x1FU));
#endif
}
 8005d90:	4618      	mov	r0, r3
 8005d92:	bd80      	pop	{r7, pc}
 8005d94:	58024400 	.word	0x58024400
 8005d98:	080d9c9c 	.word	0x080d9c9c

08005d9c <HAL_RCCEx_GetPLL2ClockFreq>:
  *         right PLL2CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL2_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL2ClockFreq(PLL2_ClocksTypeDef* PLL2_Clocks)
{
 8005d9c:	b480      	push	{r7}
 8005d9e:	b089      	sub	sp, #36	; 0x24
 8005da0:	af00      	add	r7, sp, #0
 8005da2:	6078      	str	r0, [r7, #4]
  float_t fracn2, pll2vco;

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL2M) * PLL2N
     PLL2xCLK = PLL2_VCO / PLL2x
  */
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 8005da4:	4ba1      	ldr	r3, [pc, #644]	; (800602c <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8005da6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005da8:	f003 0303 	and.w	r3, r3, #3
 8005dac:	61bb      	str	r3, [r7, #24]
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2)>> 12);
 8005dae:	4b9f      	ldr	r3, [pc, #636]	; (800602c <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8005db0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005db2:	0b1b      	lsrs	r3, r3, #12
 8005db4:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8005db8:	617b      	str	r3, [r7, #20]
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
 8005dba:	4b9c      	ldr	r3, [pc, #624]	; (800602c <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8005dbc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005dbe:	091b      	lsrs	r3, r3, #4
 8005dc0:	f003 0301 	and.w	r3, r3, #1
 8005dc4:	613b      	str	r3, [r7, #16]
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
 8005dc6:	4b99      	ldr	r3, [pc, #612]	; (800602c <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8005dc8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8005dca:	08db      	lsrs	r3, r3, #3
 8005dcc:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8005dd0:	693a      	ldr	r2, [r7, #16]
 8005dd2:	fb02 f303 	mul.w	r3, r2, r3
 8005dd6:	ee07 3a90 	vmov	s15, r3
 8005dda:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8005dde:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll2m != 0U)
 8005de2:	697b      	ldr	r3, [r7, #20]
 8005de4:	2b00      	cmp	r3, #0
 8005de6:	f000 8111 	beq.w	800600c <HAL_RCCEx_GetPLL2ClockFreq+0x270>
  {
    switch (pllsource)
 8005dea:	69bb      	ldr	r3, [r7, #24]
 8005dec:	2b02      	cmp	r3, #2
 8005dee:	f000 8083 	beq.w	8005ef8 <HAL_RCCEx_GetPLL2ClockFreq+0x15c>
 8005df2:	69bb      	ldr	r3, [r7, #24]
 8005df4:	2b02      	cmp	r3, #2
 8005df6:	f200 80a1 	bhi.w	8005f3c <HAL_RCCEx_GetPLL2ClockFreq+0x1a0>
 8005dfa:	69bb      	ldr	r3, [r7, #24]
 8005dfc:	2b00      	cmp	r3, #0
 8005dfe:	d003      	beq.n	8005e08 <HAL_RCCEx_GetPLL2ClockFreq+0x6c>
 8005e00:	69bb      	ldr	r3, [r7, #24]
 8005e02:	2b01      	cmp	r3, #1
 8005e04:	d056      	beq.n	8005eb4 <HAL_RCCEx_GetPLL2ClockFreq+0x118>
 8005e06:	e099      	b.n	8005f3c <HAL_RCCEx_GetPLL2ClockFreq+0x1a0>
    {

    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8005e08:	4b88      	ldr	r3, [pc, #544]	; (800602c <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8005e0a:	681b      	ldr	r3, [r3, #0]
 8005e0c:	f003 0320 	and.w	r3, r3, #32
 8005e10:	2b00      	cmp	r3, #0
 8005e12:	d02d      	beq.n	8005e70 <HAL_RCCEx_GetPLL2ClockFreq+0xd4>
      {
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 8005e14:	4b85      	ldr	r3, [pc, #532]	; (800602c <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8005e16:	681b      	ldr	r3, [r3, #0]
 8005e18:	08db      	lsrs	r3, r3, #3
 8005e1a:	f003 0303 	and.w	r3, r3, #3
 8005e1e:	4a84      	ldr	r2, [pc, #528]	; (8006030 <HAL_RCCEx_GetPLL2ClockFreq+0x294>)
 8005e20:	fa22 f303 	lsr.w	r3, r2, r3
 8005e24:	60bb      	str	r3, [r7, #8]
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
 8005e26:	68bb      	ldr	r3, [r7, #8]
 8005e28:	ee07 3a90 	vmov	s15, r3
 8005e2c:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8005e30:	697b      	ldr	r3, [r7, #20]
 8005e32:	ee07 3a90 	vmov	s15, r3
 8005e36:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8005e3a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8005e3e:	4b7b      	ldr	r3, [pc, #492]	; (800602c <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8005e40:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8005e42:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8005e46:	ee07 3a90 	vmov	s15, r3
 8005e4a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8005e4e:	ed97 6a03 	vldr	s12, [r7, #12]
 8005e52:	eddf 5a78 	vldr	s11, [pc, #480]	; 8006034 <HAL_RCCEx_GetPLL2ClockFreq+0x298>
 8005e56:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8005e5a:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8005e5e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8005e62:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8005e66:	ee67 7a27 	vmul.f32	s15, s14, s15
 8005e6a:	edc7 7a07 	vstr	s15, [r7, #28]
      }
      else
      {
        pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
      }
      break;
 8005e6e:	e087      	b.n	8005f80 <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>
        pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
 8005e70:	697b      	ldr	r3, [r7, #20]
 8005e72:	ee07 3a90 	vmov	s15, r3
 8005e76:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8005e7a:	eddf 6a6f 	vldr	s13, [pc, #444]	; 8006038 <HAL_RCCEx_GetPLL2ClockFreq+0x29c>
 8005e7e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8005e82:	4b6a      	ldr	r3, [pc, #424]	; (800602c <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8005e84:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8005e86:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8005e8a:	ee07 3a90 	vmov	s15, r3
 8005e8e:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8005e92:	ed97 6a03 	vldr	s12, [r7, #12]
 8005e96:	eddf 5a67 	vldr	s11, [pc, #412]	; 8006034 <HAL_RCCEx_GetPLL2ClockFreq+0x298>
 8005e9a:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8005e9e:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8005ea2:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8005ea6:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8005eaa:	ee67 7a27 	vmul.f32	s15, s14, s15
 8005eae:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 8005eb2:	e065      	b.n	8005f80 <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>

    case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
      pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
 8005eb4:	697b      	ldr	r3, [r7, #20]
 8005eb6:	ee07 3a90 	vmov	s15, r3
 8005eba:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8005ebe:	eddf 6a5f 	vldr	s13, [pc, #380]	; 800603c <HAL_RCCEx_GetPLL2ClockFreq+0x2a0>
 8005ec2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8005ec6:	4b59      	ldr	r3, [pc, #356]	; (800602c <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8005ec8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8005eca:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8005ece:	ee07 3a90 	vmov	s15, r3
 8005ed2:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8005ed6:	ed97 6a03 	vldr	s12, [r7, #12]
 8005eda:	eddf 5a56 	vldr	s11, [pc, #344]	; 8006034 <HAL_RCCEx_GetPLL2ClockFreq+0x298>
 8005ede:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8005ee2:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8005ee6:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8005eea:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8005eee:	ee67 7a27 	vmul.f32	s15, s14, s15
 8005ef2:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 8005ef6:	e043      	b.n	8005f80 <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
 8005ef8:	697b      	ldr	r3, [r7, #20]
 8005efa:	ee07 3a90 	vmov	s15, r3
 8005efe:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8005f02:	eddf 6a4f 	vldr	s13, [pc, #316]	; 8006040 <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>
 8005f06:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8005f0a:	4b48      	ldr	r3, [pc, #288]	; (800602c <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8005f0c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8005f0e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8005f12:	ee07 3a90 	vmov	s15, r3
 8005f16:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8005f1a:	ed97 6a03 	vldr	s12, [r7, #12]
 8005f1e:	eddf 5a45 	vldr	s11, [pc, #276]	; 8006034 <HAL_RCCEx_GetPLL2ClockFreq+0x298>
 8005f22:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8005f26:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8005f2a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8005f2e:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8005f32:	ee67 7a27 	vmul.f32	s15, s14, s15
 8005f36:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 8005f3a:	e021      	b.n	8005f80 <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>

    default:
      pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
 8005f3c:	697b      	ldr	r3, [r7, #20]
 8005f3e:	ee07 3a90 	vmov	s15, r3
 8005f42:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8005f46:	eddf 6a3d 	vldr	s13, [pc, #244]	; 800603c <HAL_RCCEx_GetPLL2ClockFreq+0x2a0>
 8005f4a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8005f4e:	4b37      	ldr	r3, [pc, #220]	; (800602c <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8005f50:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8005f52:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8005f56:	ee07 3a90 	vmov	s15, r3
 8005f5a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8005f5e:	ed97 6a03 	vldr	s12, [r7, #12]
 8005f62:	eddf 5a34 	vldr	s11, [pc, #208]	; 8006034 <HAL_RCCEx_GetPLL2ClockFreq+0x298>
 8005f66:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8005f6a:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8005f6e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8005f72:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8005f76:	ee67 7a27 	vmul.f32	s15, s14, s15
 8005f7a:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 8005f7e:	bf00      	nop
    }
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >>9)  + (float_t)1 )) ;
 8005f80:	4b2a      	ldr	r3, [pc, #168]	; (800602c <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8005f82:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8005f84:	0a5b      	lsrs	r3, r3, #9
 8005f86:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8005f8a:	ee07 3a90 	vmov	s15, r3
 8005f8e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8005f92:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8005f96:	ee37 7a87 	vadd.f32	s14, s15, s14
 8005f9a:	edd7 6a07 	vldr	s13, [r7, #28]
 8005f9e:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8005fa2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8005fa6:	ee17 2a90 	vmov	r2, s15
 8005faa:	687b      	ldr	r3, [r7, #4]
 8005fac:	601a      	str	r2, [r3, #0]
    PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_Q2) >>16) + (float_t)1 )) ;
 8005fae:	4b1f      	ldr	r3, [pc, #124]	; (800602c <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8005fb0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8005fb2:	0c1b      	lsrs	r3, r3, #16
 8005fb4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8005fb8:	ee07 3a90 	vmov	s15, r3
 8005fbc:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8005fc0:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8005fc4:	ee37 7a87 	vadd.f32	s14, s15, s14
 8005fc8:	edd7 6a07 	vldr	s13, [r7, #28]
 8005fcc:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8005fd0:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8005fd4:	ee17 2a90 	vmov	r2, s15
 8005fd8:	687b      	ldr	r3, [r7, #4]
 8005fda:	605a      	str	r2, [r3, #4]
    PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_R2) >>24) + (float_t)1 )) ;
 8005fdc:	4b13      	ldr	r3, [pc, #76]	; (800602c <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 8005fde:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8005fe0:	0e1b      	lsrs	r3, r3, #24
 8005fe2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8005fe6:	ee07 3a90 	vmov	s15, r3
 8005fea:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8005fee:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8005ff2:	ee37 7a87 	vadd.f32	s14, s15, s14
 8005ff6:	edd7 6a07 	vldr	s13, [r7, #28]
 8005ffa:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8005ffe:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8006002:	ee17 2a90 	vmov	r2, s15
 8006006:	687b      	ldr	r3, [r7, #4]
 8006008:	609a      	str	r2, [r3, #8]
  {
    PLL2_Clocks->PLL2_P_Frequency = 0U;
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
    PLL2_Clocks->PLL2_R_Frequency = 0U;
  }
}
 800600a:	e008      	b.n	800601e <HAL_RCCEx_GetPLL2ClockFreq+0x282>
    PLL2_Clocks->PLL2_P_Frequency = 0U;
 800600c:	687b      	ldr	r3, [r7, #4]
 800600e:	2200      	movs	r2, #0
 8006010:	601a      	str	r2, [r3, #0]
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
 8006012:	687b      	ldr	r3, [r7, #4]
 8006014:	2200      	movs	r2, #0
 8006016:	605a      	str	r2, [r3, #4]
    PLL2_Clocks->PLL2_R_Frequency = 0U;
 8006018:	687b      	ldr	r3, [r7, #4]
 800601a:	2200      	movs	r2, #0
 800601c:	609a      	str	r2, [r3, #8]
}
 800601e:	bf00      	nop
 8006020:	3724      	adds	r7, #36	; 0x24
 8006022:	46bd      	mov	sp, r7
 8006024:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006028:	4770      	bx	lr
 800602a:	bf00      	nop
 800602c:	58024400 	.word	0x58024400
 8006030:	03d09000 	.word	0x03d09000
 8006034:	46000000 	.word	0x46000000
 8006038:	4c742400 	.word	0x4c742400
 800603c:	4a742400 	.word	0x4a742400
 8006040:	4bf42400 	.word	0x4bf42400

08006044 <HAL_RCCEx_GetPLL3ClockFreq>:
  *         right PLL3CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL3_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL3ClockFreq(PLL3_ClocksTypeDef* PLL3_Clocks)
{
 8006044:	b480      	push	{r7}
 8006046:	b089      	sub	sp, #36	; 0x24
 8006048:	af00      	add	r7, sp, #0
 800604a:	6078      	str	r0, [r7, #4]
  float_t fracn3, pll3vco;

  /* PLL3_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL3M) * PLL3N
     PLL3xCLK = PLL3_VCO / PLLxR
  */
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800604c:	4ba1      	ldr	r3, [pc, #644]	; (80062d4 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800604e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006050:	f003 0303 	and.w	r3, r3, #3
 8006054:	61bb      	str	r3, [r7, #24]
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3)>> 20)  ;
 8006056:	4b9f      	ldr	r3, [pc, #636]	; (80062d4 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 8006058:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800605a:	0d1b      	lsrs	r3, r3, #20
 800605c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8006060:	617b      	str	r3, [r7, #20]
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
 8006062:	4b9c      	ldr	r3, [pc, #624]	; (80062d4 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 8006064:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006066:	0a1b      	lsrs	r3, r3, #8
 8006068:	f003 0301 	and.w	r3, r3, #1
 800606c:	613b      	str	r3, [r7, #16]
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
 800606e:	4b99      	ldr	r3, [pc, #612]	; (80062d4 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 8006070:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8006072:	08db      	lsrs	r3, r3, #3
 8006074:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8006078:	693a      	ldr	r2, [r7, #16]
 800607a:	fb02 f303 	mul.w	r3, r2, r3
 800607e:	ee07 3a90 	vmov	s15, r3
 8006082:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8006086:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll3m != 0U)
 800608a:	697b      	ldr	r3, [r7, #20]
 800608c:	2b00      	cmp	r3, #0
 800608e:	f000 8111 	beq.w	80062b4 <HAL_RCCEx_GetPLL3ClockFreq+0x270>
  {
    switch (pllsource)
 8006092:	69bb      	ldr	r3, [r7, #24]
 8006094:	2b02      	cmp	r3, #2
 8006096:	f000 8083 	beq.w	80061a0 <HAL_RCCEx_GetPLL3ClockFreq+0x15c>
 800609a:	69bb      	ldr	r3, [r7, #24]
 800609c:	2b02      	cmp	r3, #2
 800609e:	f200 80a1 	bhi.w	80061e4 <HAL_RCCEx_GetPLL3ClockFreq+0x1a0>
 80060a2:	69bb      	ldr	r3, [r7, #24]
 80060a4:	2b00      	cmp	r3, #0
 80060a6:	d003      	beq.n	80060b0 <HAL_RCCEx_GetPLL3ClockFreq+0x6c>
 80060a8:	69bb      	ldr	r3, [r7, #24]
 80060aa:	2b01      	cmp	r3, #1
 80060ac:	d056      	beq.n	800615c <HAL_RCCEx_GetPLL3ClockFreq+0x118>
 80060ae:	e099      	b.n	80061e4 <HAL_RCCEx_GetPLL3ClockFreq+0x1a0>
    {
    case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 80060b0:	4b88      	ldr	r3, [pc, #544]	; (80062d4 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 80060b2:	681b      	ldr	r3, [r3, #0]
 80060b4:	f003 0320 	and.w	r3, r3, #32
 80060b8:	2b00      	cmp	r3, #0
 80060ba:	d02d      	beq.n	8006118 <HAL_RCCEx_GetPLL3ClockFreq+0xd4>
      {
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 80060bc:	4b85      	ldr	r3, [pc, #532]	; (80062d4 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 80060be:	681b      	ldr	r3, [r3, #0]
 80060c0:	08db      	lsrs	r3, r3, #3
 80060c2:	f003 0303 	and.w	r3, r3, #3
 80060c6:	4a84      	ldr	r2, [pc, #528]	; (80062d8 <HAL_RCCEx_GetPLL3ClockFreq+0x294>)
 80060c8:	fa22 f303 	lsr.w	r3, r2, r3
 80060cc:	60bb      	str	r3, [r7, #8]
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
 80060ce:	68bb      	ldr	r3, [r7, #8]
 80060d0:	ee07 3a90 	vmov	s15, r3
 80060d4:	eef8 6a67 	vcvt.f32.u32	s13, s15
 80060d8:	697b      	ldr	r3, [r7, #20]
 80060da:	ee07 3a90 	vmov	s15, r3
 80060de:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80060e2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 80060e6:	4b7b      	ldr	r3, [pc, #492]	; (80062d4 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 80060e8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80060ea:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80060ee:	ee07 3a90 	vmov	s15, r3
 80060f2:	eef8 6a67 	vcvt.f32.u32	s13, s15
 80060f6:	ed97 6a03 	vldr	s12, [r7, #12]
 80060fa:	eddf 5a78 	vldr	s11, [pc, #480]	; 80062dc <HAL_RCCEx_GetPLL3ClockFreq+0x298>
 80060fe:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8006102:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8006106:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 800610a:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800610e:	ee67 7a27 	vmul.f32	s15, s14, s15
 8006112:	edc7 7a07 	vstr	s15, [r7, #28]
      }
      else
      {
        pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
      }
      break;
 8006116:	e087      	b.n	8006228 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>
        pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
 8006118:	697b      	ldr	r3, [r7, #20]
 800611a:	ee07 3a90 	vmov	s15, r3
 800611e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8006122:	eddf 6a6f 	vldr	s13, [pc, #444]	; 80062e0 <HAL_RCCEx_GetPLL3ClockFreq+0x29c>
 8006126:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800612a:	4b6a      	ldr	r3, [pc, #424]	; (80062d4 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800612c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800612e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8006132:	ee07 3a90 	vmov	s15, r3
 8006136:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800613a:	ed97 6a03 	vldr	s12, [r7, #12]
 800613e:	eddf 5a67 	vldr	s11, [pc, #412]	; 80062dc <HAL_RCCEx_GetPLL3ClockFreq+0x298>
 8006142:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8006146:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800614a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 800614e:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8006152:	ee67 7a27 	vmul.f32	s15, s14, s15
 8006156:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 800615a:	e065      	b.n	8006228 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>
    case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
      pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
 800615c:	697b      	ldr	r3, [r7, #20]
 800615e:	ee07 3a90 	vmov	s15, r3
 8006162:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8006166:	eddf 6a5f 	vldr	s13, [pc, #380]	; 80062e4 <HAL_RCCEx_GetPLL3ClockFreq+0x2a0>
 800616a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800616e:	4b59      	ldr	r3, [pc, #356]	; (80062d4 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 8006170:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8006172:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8006176:	ee07 3a90 	vmov	s15, r3
 800617a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800617e:	ed97 6a03 	vldr	s12, [r7, #12]
 8006182:	eddf 5a56 	vldr	s11, [pc, #344]	; 80062dc <HAL_RCCEx_GetPLL3ClockFreq+0x298>
 8006186:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800618a:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800618e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8006192:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8006196:	ee67 7a27 	vmul.f32	s15, s14, s15
 800619a:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 800619e:	e043      	b.n	8006228 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>

    case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
 80061a0:	697b      	ldr	r3, [r7, #20]
 80061a2:	ee07 3a90 	vmov	s15, r3
 80061a6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80061aa:	eddf 6a4f 	vldr	s13, [pc, #316]	; 80062e8 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>
 80061ae:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 80061b2:	4b48      	ldr	r3, [pc, #288]	; (80062d4 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 80061b4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80061b6:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80061ba:	ee07 3a90 	vmov	s15, r3
 80061be:	eef8 6a67 	vcvt.f32.u32	s13, s15
 80061c2:	ed97 6a03 	vldr	s12, [r7, #12]
 80061c6:	eddf 5a45 	vldr	s11, [pc, #276]	; 80062dc <HAL_RCCEx_GetPLL3ClockFreq+0x298>
 80061ca:	eec6 7a25 	vdiv.f32	s15, s12, s11
 80061ce:	ee76 7aa7 	vadd.f32	s15, s13, s15
 80061d2:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 80061d6:	ee77 7aa6 	vadd.f32	s15, s15, s13
 80061da:	ee67 7a27 	vmul.f32	s15, s14, s15
 80061de:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 80061e2:	e021      	b.n	8006228 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>

    default:
      pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
 80061e4:	697b      	ldr	r3, [r7, #20]
 80061e6:	ee07 3a90 	vmov	s15, r3
 80061ea:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80061ee:	eddf 6a3d 	vldr	s13, [pc, #244]	; 80062e4 <HAL_RCCEx_GetPLL3ClockFreq+0x2a0>
 80061f2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 80061f6:	4b37      	ldr	r3, [pc, #220]	; (80062d4 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 80061f8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80061fa:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80061fe:	ee07 3a90 	vmov	s15, r3
 8006202:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8006206:	ed97 6a03 	vldr	s12, [r7, #12]
 800620a:	eddf 5a34 	vldr	s11, [pc, #208]	; 80062dc <HAL_RCCEx_GetPLL3ClockFreq+0x298>
 800620e:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8006212:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8006216:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 800621a:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800621e:	ee67 7a27 	vmul.f32	s15, s14, s15
 8006222:	edc7 7a07 	vstr	s15, [r7, #28]
      break;
 8006226:	bf00      	nop
    }
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >>9)  + (float_t)1 )) ;
 8006228:	4b2a      	ldr	r3, [pc, #168]	; (80062d4 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800622a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800622c:	0a5b      	lsrs	r3, r3, #9
 800622e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8006232:	ee07 3a90 	vmov	s15, r3
 8006236:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800623a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 800623e:	ee37 7a87 	vadd.f32	s14, s15, s14
 8006242:	edd7 6a07 	vldr	s13, [r7, #28]
 8006246:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800624a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800624e:	ee17 2a90 	vmov	r2, s15
 8006252:	687b      	ldr	r3, [r7, #4]
 8006254:	601a      	str	r2, [r3, #0]
    PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_Q3) >>16) + (float_t)1 )) ;
 8006256:	4b1f      	ldr	r3, [pc, #124]	; (80062d4 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 8006258:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800625a:	0c1b      	lsrs	r3, r3, #16
 800625c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8006260:	ee07 3a90 	vmov	s15, r3
 8006264:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8006268:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 800626c:	ee37 7a87 	vadd.f32	s14, s15, s14
 8006270:	edd7 6a07 	vldr	s13, [r7, #28]
 8006274:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8006278:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800627c:	ee17 2a90 	vmov	r2, s15
 8006280:	687b      	ldr	r3, [r7, #4]
 8006282:	605a      	str	r2, [r3, #4]
    PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_R3) >>24) + (float_t)1 )) ;
 8006284:	4b13      	ldr	r3, [pc, #76]	; (80062d4 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 8006286:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8006288:	0e1b      	lsrs	r3, r3, #24
 800628a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800628e:	ee07 3a90 	vmov	s15, r3
 8006292:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8006296:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 800629a:	ee37 7a87 	vadd.f32	s14, s15, s14
 800629e:	edd7 6a07 	vldr	s13, [r7, #28]
 80062a2:	eec6 7a87 	vdiv.f32	s15, s13, s14
 80062a6:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80062aa:	ee17 2a90 	vmov	r2, s15
 80062ae:	687b      	ldr	r3, [r7, #4]
 80062b0:	609a      	str	r2, [r3, #8]
    PLL3_Clocks->PLL3_P_Frequency = 0U;
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
    PLL3_Clocks->PLL3_R_Frequency = 0U;
  }

}
 80062b2:	e008      	b.n	80062c6 <HAL_RCCEx_GetPLL3ClockFreq+0x282>
    PLL3_Clocks->PLL3_P_Frequency = 0U;
 80062b4:	687b      	ldr	r3, [r7, #4]
 80062b6:	2200      	movs	r2, #0
 80062b8:	601a      	str	r2, [r3, #0]
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
 80062ba:	687b      	ldr	r3, [r7, #4]
 80062bc:	2200      	movs	r2, #0
 80062be:	605a      	str	r2, [r3, #4]
    PLL3_Clocks->PLL3_R_Frequency = 0U;
 80062c0:	687b      	ldr	r3, [r7, #4]
 80062c2:	2200      	movs	r2, #0
 80062c4:	609a      	str	r2, [r3, #8]
}
 80062c6:	bf00      	nop
 80062c8:	3724      	adds	r7, #36	; 0x24
 80062ca:	46bd      	mov	sp, r7
 80062cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80062d0:	4770      	bx	lr
 80062d2:	bf00      	nop
 80062d4:	58024400 	.word	0x58024400
 80062d8:	03d09000 	.word	0x03d09000
 80062dc:	46000000 	.word	0x46000000
 80062e0:	4c742400 	.word	0x4c742400
 80062e4:	4a742400 	.word	0x4a742400
 80062e8:	4bf42400 	.word	0x4bf42400

080062ec <RCCEx_PLL2_Config>:
  * @note   PLL2 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL2_Config(RCC_PLL2InitTypeDef *pll2, uint32_t Divider)
{
 80062ec:	b580      	push	{r7, lr}
 80062ee:	b084      	sub	sp, #16
 80062f0:	af00      	add	r7, sp, #0
 80062f2:	6078      	str	r0, [r7, #4]
 80062f4:	6039      	str	r1, [r7, #0]

  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 80062f6:	2300      	movs	r3, #0
 80062f8:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLL2RGE_VALUE(pll2->PLL2RGE));
  assert_param(IS_RCC_PLL2VCO_VALUE(pll2->PLL2VCOSEL));
  assert_param(IS_RCC_PLLFRACN_VALUE(pll2->PLL2FRACN));

  /* Check that PLL2 OSC clock source is already set */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
 80062fa:	4b53      	ldr	r3, [pc, #332]	; (8006448 <RCCEx_PLL2_Config+0x15c>)
 80062fc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80062fe:	f003 0303 	and.w	r3, r3, #3
 8006302:	2b03      	cmp	r3, #3
 8006304:	d101      	bne.n	800630a <RCCEx_PLL2_Config+0x1e>
  {
    return HAL_ERROR;
 8006306:	2301      	movs	r3, #1
 8006308:	e099      	b.n	800643e <RCCEx_PLL2_Config+0x152>


  else
  {
    /* Disable  PLL2. */
    __HAL_RCC_PLL2_DISABLE();
 800630a:	4b4f      	ldr	r3, [pc, #316]	; (8006448 <RCCEx_PLL2_Config+0x15c>)
 800630c:	681b      	ldr	r3, [r3, #0]
 800630e:	4a4e      	ldr	r2, [pc, #312]	; (8006448 <RCCEx_PLL2_Config+0x15c>)
 8006310:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8006314:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8006316:	f7fa fa17 	bl	8000748 <HAL_GetTick>
 800631a:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 800631c:	e008      	b.n	8006330 <RCCEx_PLL2_Config+0x44>
    {
      if( (HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
 800631e:	f7fa fa13 	bl	8000748 <HAL_GetTick>
 8006322:	4602      	mov	r2, r0
 8006324:	68bb      	ldr	r3, [r7, #8]
 8006326:	1ad3      	subs	r3, r2, r3
 8006328:	2b02      	cmp	r3, #2
 800632a:	d901      	bls.n	8006330 <RCCEx_PLL2_Config+0x44>
      {
        return HAL_TIMEOUT;
 800632c:	2303      	movs	r3, #3
 800632e:	e086      	b.n	800643e <RCCEx_PLL2_Config+0x152>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 8006330:	4b45      	ldr	r3, [pc, #276]	; (8006448 <RCCEx_PLL2_Config+0x15c>)
 8006332:	681b      	ldr	r3, [r3, #0]
 8006334:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8006338:	2b00      	cmp	r3, #0
 800633a:	d1f0      	bne.n	800631e <RCCEx_PLL2_Config+0x32>
      }
    }

    /* Configure PLL2 multiplication and division factors. */
    __HAL_RCC_PLL2_CONFIG(pll2->PLL2M,
 800633c:	4b42      	ldr	r3, [pc, #264]	; (8006448 <RCCEx_PLL2_Config+0x15c>)
 800633e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006340:	f423 327c 	bic.w	r2, r3, #258048	; 0x3f000
 8006344:	687b      	ldr	r3, [r7, #4]
 8006346:	681b      	ldr	r3, [r3, #0]
 8006348:	031b      	lsls	r3, r3, #12
 800634a:	493f      	ldr	r1, [pc, #252]	; (8006448 <RCCEx_PLL2_Config+0x15c>)
 800634c:	4313      	orrs	r3, r2
 800634e:	628b      	str	r3, [r1, #40]	; 0x28
 8006350:	687b      	ldr	r3, [r7, #4]
 8006352:	685b      	ldr	r3, [r3, #4]
 8006354:	3b01      	subs	r3, #1
 8006356:	f3c3 0208 	ubfx	r2, r3, #0, #9
 800635a:	687b      	ldr	r3, [r7, #4]
 800635c:	689b      	ldr	r3, [r3, #8]
 800635e:	3b01      	subs	r3, #1
 8006360:	025b      	lsls	r3, r3, #9
 8006362:	b29b      	uxth	r3, r3
 8006364:	431a      	orrs	r2, r3
 8006366:	687b      	ldr	r3, [r7, #4]
 8006368:	68db      	ldr	r3, [r3, #12]
 800636a:	3b01      	subs	r3, #1
 800636c:	041b      	lsls	r3, r3, #16
 800636e:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
 8006372:	431a      	orrs	r2, r3
 8006374:	687b      	ldr	r3, [r7, #4]
 8006376:	691b      	ldr	r3, [r3, #16]
 8006378:	3b01      	subs	r3, #1
 800637a:	061b      	lsls	r3, r3, #24
 800637c:	f003 43fe 	and.w	r3, r3, #2130706432	; 0x7f000000
 8006380:	4931      	ldr	r1, [pc, #196]	; (8006448 <RCCEx_PLL2_Config+0x15c>)
 8006382:	4313      	orrs	r3, r2
 8006384:	638b      	str	r3, [r1, #56]	; 0x38
                          pll2->PLL2P,
                          pll2->PLL2Q,
                          pll2->PLL2R);

    /* Select PLL2 input reference frequency range: VCI */
    __HAL_RCC_PLL2_VCIRANGE(pll2->PLL2RGE) ;
 8006386:	4b30      	ldr	r3, [pc, #192]	; (8006448 <RCCEx_PLL2_Config+0x15c>)
 8006388:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800638a:	f023 02c0 	bic.w	r2, r3, #192	; 0xc0
 800638e:	687b      	ldr	r3, [r7, #4]
 8006390:	695b      	ldr	r3, [r3, #20]
 8006392:	492d      	ldr	r1, [pc, #180]	; (8006448 <RCCEx_PLL2_Config+0x15c>)
 8006394:	4313      	orrs	r3, r2
 8006396:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Select PLL2 output frequency range : VCO */
    __HAL_RCC_PLL2_VCORANGE(pll2->PLL2VCOSEL) ;
 8006398:	4b2b      	ldr	r3, [pc, #172]	; (8006448 <RCCEx_PLL2_Config+0x15c>)
 800639a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800639c:	f023 0220 	bic.w	r2, r3, #32
 80063a0:	687b      	ldr	r3, [r7, #4]
 80063a2:	699b      	ldr	r3, [r3, #24]
 80063a4:	4928      	ldr	r1, [pc, #160]	; (8006448 <RCCEx_PLL2_Config+0x15c>)
 80063a6:	4313      	orrs	r3, r2
 80063a8:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Disable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_DISABLE();
 80063aa:	4b27      	ldr	r3, [pc, #156]	; (8006448 <RCCEx_PLL2_Config+0x15c>)
 80063ac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80063ae:	4a26      	ldr	r2, [pc, #152]	; (8006448 <RCCEx_PLL2_Config+0x15c>)
 80063b0:	f023 0310 	bic.w	r3, r3, #16
 80063b4:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Configures PLL2 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
 80063b6:	4b24      	ldr	r3, [pc, #144]	; (8006448 <RCCEx_PLL2_Config+0x15c>)
 80063b8:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 80063ba:	4b24      	ldr	r3, [pc, #144]	; (800644c <RCCEx_PLL2_Config+0x160>)
 80063bc:	4013      	ands	r3, r2
 80063be:	687a      	ldr	r2, [r7, #4]
 80063c0:	69d2      	ldr	r2, [r2, #28]
 80063c2:	00d2      	lsls	r2, r2, #3
 80063c4:	4920      	ldr	r1, [pc, #128]	; (8006448 <RCCEx_PLL2_Config+0x15c>)
 80063c6:	4313      	orrs	r3, r2
 80063c8:	63cb      	str	r3, [r1, #60]	; 0x3c

    /* Enable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_ENABLE();
 80063ca:	4b1f      	ldr	r3, [pc, #124]	; (8006448 <RCCEx_PLL2_Config+0x15c>)
 80063cc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80063ce:	4a1e      	ldr	r2, [pc, #120]	; (8006448 <RCCEx_PLL2_Config+0x15c>)
 80063d0:	f043 0310 	orr.w	r3, r3, #16
 80063d4:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Enable the PLL2 clock output */
    if(Divider == DIVIDER_P_UPDATE)
 80063d6:	683b      	ldr	r3, [r7, #0]
 80063d8:	2b00      	cmp	r3, #0
 80063da:	d106      	bne.n	80063ea <RCCEx_PLL2_Config+0xfe>
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP);
 80063dc:	4b1a      	ldr	r3, [pc, #104]	; (8006448 <RCCEx_PLL2_Config+0x15c>)
 80063de:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80063e0:	4a19      	ldr	r2, [pc, #100]	; (8006448 <RCCEx_PLL2_Config+0x15c>)
 80063e2:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 80063e6:	62d3      	str	r3, [r2, #44]	; 0x2c
 80063e8:	e00f      	b.n	800640a <RCCEx_PLL2_Config+0x11e>
    }
    else if(Divider == DIVIDER_Q_UPDATE)
 80063ea:	683b      	ldr	r3, [r7, #0]
 80063ec:	2b01      	cmp	r3, #1
 80063ee:	d106      	bne.n	80063fe <RCCEx_PLL2_Config+0x112>
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVQ);
 80063f0:	4b15      	ldr	r3, [pc, #84]	; (8006448 <RCCEx_PLL2_Config+0x15c>)
 80063f2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80063f4:	4a14      	ldr	r2, [pc, #80]	; (8006448 <RCCEx_PLL2_Config+0x15c>)
 80063f6:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80063fa:	62d3      	str	r3, [r2, #44]	; 0x2c
 80063fc:	e005      	b.n	800640a <RCCEx_PLL2_Config+0x11e>
    }
    else
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVR);
 80063fe:	4b12      	ldr	r3, [pc, #72]	; (8006448 <RCCEx_PLL2_Config+0x15c>)
 8006400:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006402:	4a11      	ldr	r2, [pc, #68]	; (8006448 <RCCEx_PLL2_Config+0x15c>)
 8006404:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8006408:	62d3      	str	r3, [r2, #44]	; 0x2c
    }

    /* Enable  PLL2. */
    __HAL_RCC_PLL2_ENABLE();
 800640a:	4b0f      	ldr	r3, [pc, #60]	; (8006448 <RCCEx_PLL2_Config+0x15c>)
 800640c:	681b      	ldr	r3, [r3, #0]
 800640e:	4a0e      	ldr	r2, [pc, #56]	; (8006448 <RCCEx_PLL2_Config+0x15c>)
 8006410:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8006414:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8006416:	f7fa f997 	bl	8000748 <HAL_GetTick>
 800641a:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL2 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 800641c:	e008      	b.n	8006430 <RCCEx_PLL2_Config+0x144>
    {
      if( (HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
 800641e:	f7fa f993 	bl	8000748 <HAL_GetTick>
 8006422:	4602      	mov	r2, r0
 8006424:	68bb      	ldr	r3, [r7, #8]
 8006426:	1ad3      	subs	r3, r2, r3
 8006428:	2b02      	cmp	r3, #2
 800642a:	d901      	bls.n	8006430 <RCCEx_PLL2_Config+0x144>
      {
        return HAL_TIMEOUT;
 800642c:	2303      	movs	r3, #3
 800642e:	e006      	b.n	800643e <RCCEx_PLL2_Config+0x152>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 8006430:	4b05      	ldr	r3, [pc, #20]	; (8006448 <RCCEx_PLL2_Config+0x15c>)
 8006432:	681b      	ldr	r3, [r3, #0]
 8006434:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8006438:	2b00      	cmp	r3, #0
 800643a:	d0f0      	beq.n	800641e <RCCEx_PLL2_Config+0x132>
    }

  }


  return status;
 800643c:	7bfb      	ldrb	r3, [r7, #15]
}
 800643e:	4618      	mov	r0, r3
 8006440:	3710      	adds	r7, #16
 8006442:	46bd      	mov	sp, r7
 8006444:	bd80      	pop	{r7, pc}
 8006446:	bf00      	nop
 8006448:	58024400 	.word	0x58024400
 800644c:	ffff0007 	.word	0xffff0007

08006450 <RCCEx_PLL3_Config>:
  * @note   PLL3 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL3_Config(RCC_PLL3InitTypeDef *pll3, uint32_t Divider)
{
 8006450:	b580      	push	{r7, lr}
 8006452:	b084      	sub	sp, #16
 8006454:	af00      	add	r7, sp, #0
 8006456:	6078      	str	r0, [r7, #4]
 8006458:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 800645a:	2300      	movs	r3, #0
 800645c:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLL3RGE_VALUE(pll3->PLL3RGE));
  assert_param(IS_RCC_PLL3VCO_VALUE(pll3->PLL3VCOSEL));
  assert_param(IS_RCC_PLLFRACN_VALUE(pll3->PLL3FRACN));

  /* Check that PLL3 OSC clock source is already set */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
 800645e:	4b53      	ldr	r3, [pc, #332]	; (80065ac <RCCEx_PLL3_Config+0x15c>)
 8006460:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006462:	f003 0303 	and.w	r3, r3, #3
 8006466:	2b03      	cmp	r3, #3
 8006468:	d101      	bne.n	800646e <RCCEx_PLL3_Config+0x1e>
  {
    return HAL_ERROR;
 800646a:	2301      	movs	r3, #1
 800646c:	e099      	b.n	80065a2 <RCCEx_PLL3_Config+0x152>


  else
  {
    /* Disable  PLL3. */
    __HAL_RCC_PLL3_DISABLE();
 800646e:	4b4f      	ldr	r3, [pc, #316]	; (80065ac <RCCEx_PLL3_Config+0x15c>)
 8006470:	681b      	ldr	r3, [r3, #0]
 8006472:	4a4e      	ldr	r2, [pc, #312]	; (80065ac <RCCEx_PLL3_Config+0x15c>)
 8006474:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8006478:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800647a:	f7fa f965 	bl	8000748 <HAL_GetTick>
 800647e:	60b8      	str	r0, [r7, #8]
    /* Wait till PLL3 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 8006480:	e008      	b.n	8006494 <RCCEx_PLL3_Config+0x44>
    {
      if( (HAL_GetTick() - tickstart ) > PLL3_TIMEOUT_VALUE)
 8006482:	f7fa f961 	bl	8000748 <HAL_GetTick>
 8006486:	4602      	mov	r2, r0
 8006488:	68bb      	ldr	r3, [r7, #8]
 800648a:	1ad3      	subs	r3, r2, r3
 800648c:	2b02      	cmp	r3, #2
 800648e:	d901      	bls.n	8006494 <RCCEx_PLL3_Config+0x44>
      {
        return HAL_TIMEOUT;
 8006490:	2303      	movs	r3, #3
 8006492:	e086      	b.n	80065a2 <RCCEx_PLL3_Config+0x152>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 8006494:	4b45      	ldr	r3, [pc, #276]	; (80065ac <RCCEx_PLL3_Config+0x15c>)
 8006496:	681b      	ldr	r3, [r3, #0]
 8006498:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 800649c:	2b00      	cmp	r3, #0
 800649e:	d1f0      	bne.n	8006482 <RCCEx_PLL3_Config+0x32>
      }
    }

    /* Configure the PLL3  multiplication and division factors. */
    __HAL_RCC_PLL3_CONFIG(pll3->PLL3M,
 80064a0:	4b42      	ldr	r3, [pc, #264]	; (80065ac <RCCEx_PLL3_Config+0x15c>)
 80064a2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80064a4:	f023 727c 	bic.w	r2, r3, #66060288	; 0x3f00000
 80064a8:	687b      	ldr	r3, [r7, #4]
 80064aa:	681b      	ldr	r3, [r3, #0]
 80064ac:	051b      	lsls	r3, r3, #20
 80064ae:	493f      	ldr	r1, [pc, #252]	; (80065ac <RCCEx_PLL3_Config+0x15c>)
 80064b0:	4313      	orrs	r3, r2
 80064b2:	628b      	str	r3, [r1, #40]	; 0x28
 80064b4:	687b      	ldr	r3, [r7, #4]
 80064b6:	685b      	ldr	r3, [r3, #4]
 80064b8:	3b01      	subs	r3, #1
 80064ba:	f3c3 0208 	ubfx	r2, r3, #0, #9
 80064be:	687b      	ldr	r3, [r7, #4]
 80064c0:	689b      	ldr	r3, [r3, #8]
 80064c2:	3b01      	subs	r3, #1
 80064c4:	025b      	lsls	r3, r3, #9
 80064c6:	b29b      	uxth	r3, r3
 80064c8:	431a      	orrs	r2, r3
 80064ca:	687b      	ldr	r3, [r7, #4]
 80064cc:	68db      	ldr	r3, [r3, #12]
 80064ce:	3b01      	subs	r3, #1
 80064d0:	041b      	lsls	r3, r3, #16
 80064d2:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
 80064d6:	431a      	orrs	r2, r3
 80064d8:	687b      	ldr	r3, [r7, #4]
 80064da:	691b      	ldr	r3, [r3, #16]
 80064dc:	3b01      	subs	r3, #1
 80064de:	061b      	lsls	r3, r3, #24
 80064e0:	f003 43fe 	and.w	r3, r3, #2130706432	; 0x7f000000
 80064e4:	4931      	ldr	r1, [pc, #196]	; (80065ac <RCCEx_PLL3_Config+0x15c>)
 80064e6:	4313      	orrs	r3, r2
 80064e8:	640b      	str	r3, [r1, #64]	; 0x40
                          pll3->PLL3P,
                          pll3->PLL3Q,
                          pll3->PLL3R);

    /* Select PLL3 input reference frequency range: VCI */
    __HAL_RCC_PLL3_VCIRANGE(pll3->PLL3RGE) ;
 80064ea:	4b30      	ldr	r3, [pc, #192]	; (80065ac <RCCEx_PLL3_Config+0x15c>)
 80064ec:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80064ee:	f423 6240 	bic.w	r2, r3, #3072	; 0xc00
 80064f2:	687b      	ldr	r3, [r7, #4]
 80064f4:	695b      	ldr	r3, [r3, #20]
 80064f6:	492d      	ldr	r1, [pc, #180]	; (80065ac <RCCEx_PLL3_Config+0x15c>)
 80064f8:	4313      	orrs	r3, r2
 80064fa:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Select PLL3 output frequency range : VCO */
    __HAL_RCC_PLL3_VCORANGE(pll3->PLL3VCOSEL) ;
 80064fc:	4b2b      	ldr	r3, [pc, #172]	; (80065ac <RCCEx_PLL3_Config+0x15c>)
 80064fe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006500:	f423 7200 	bic.w	r2, r3, #512	; 0x200
 8006504:	687b      	ldr	r3, [r7, #4]
 8006506:	699b      	ldr	r3, [r3, #24]
 8006508:	4928      	ldr	r1, [pc, #160]	; (80065ac <RCCEx_PLL3_Config+0x15c>)
 800650a:	4313      	orrs	r3, r2
 800650c:	62cb      	str	r3, [r1, #44]	; 0x2c

    /* Disable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_DISABLE();
 800650e:	4b27      	ldr	r3, [pc, #156]	; (80065ac <RCCEx_PLL3_Config+0x15c>)
 8006510:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006512:	4a26      	ldr	r2, [pc, #152]	; (80065ac <RCCEx_PLL3_Config+0x15c>)
 8006514:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8006518:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Configures PLL3 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
 800651a:	4b24      	ldr	r3, [pc, #144]	; (80065ac <RCCEx_PLL3_Config+0x15c>)
 800651c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800651e:	4b24      	ldr	r3, [pc, #144]	; (80065b0 <RCCEx_PLL3_Config+0x160>)
 8006520:	4013      	ands	r3, r2
 8006522:	687a      	ldr	r2, [r7, #4]
 8006524:	69d2      	ldr	r2, [r2, #28]
 8006526:	00d2      	lsls	r2, r2, #3
 8006528:	4920      	ldr	r1, [pc, #128]	; (80065ac <RCCEx_PLL3_Config+0x15c>)
 800652a:	4313      	orrs	r3, r2
 800652c:	644b      	str	r3, [r1, #68]	; 0x44

    /* Enable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_ENABLE();
 800652e:	4b1f      	ldr	r3, [pc, #124]	; (80065ac <RCCEx_PLL3_Config+0x15c>)
 8006530:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006532:	4a1e      	ldr	r2, [pc, #120]	; (80065ac <RCCEx_PLL3_Config+0x15c>)
 8006534:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8006538:	62d3      	str	r3, [r2, #44]	; 0x2c

    /* Enable the PLL3 clock output */
    if(Divider == DIVIDER_P_UPDATE)
 800653a:	683b      	ldr	r3, [r7, #0]
 800653c:	2b00      	cmp	r3, #0
 800653e:	d106      	bne.n	800654e <RCCEx_PLL3_Config+0xfe>
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVP);
 8006540:	4b1a      	ldr	r3, [pc, #104]	; (80065ac <RCCEx_PLL3_Config+0x15c>)
 8006542:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006544:	4a19      	ldr	r2, [pc, #100]	; (80065ac <RCCEx_PLL3_Config+0x15c>)
 8006546:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 800654a:	62d3      	str	r3, [r2, #44]	; 0x2c
 800654c:	e00f      	b.n	800656e <RCCEx_PLL3_Config+0x11e>
    }
    else if(Divider == DIVIDER_Q_UPDATE)
 800654e:	683b      	ldr	r3, [r7, #0]
 8006550:	2b01      	cmp	r3, #1
 8006552:	d106      	bne.n	8006562 <RCCEx_PLL3_Config+0x112>
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
 8006554:	4b15      	ldr	r3, [pc, #84]	; (80065ac <RCCEx_PLL3_Config+0x15c>)
 8006556:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006558:	4a14      	ldr	r2, [pc, #80]	; (80065ac <RCCEx_PLL3_Config+0x15c>)
 800655a:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 800655e:	62d3      	str	r3, [r2, #44]	; 0x2c
 8006560:	e005      	b.n	800656e <RCCEx_PLL3_Config+0x11e>
    }
    else
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
 8006562:	4b12      	ldr	r3, [pc, #72]	; (80065ac <RCCEx_PLL3_Config+0x15c>)
 8006564:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006566:	4a11      	ldr	r2, [pc, #68]	; (80065ac <RCCEx_PLL3_Config+0x15c>)
 8006568:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800656c:	62d3      	str	r3, [r2, #44]	; 0x2c
    }

    /* Enable  PLL3. */
    __HAL_RCC_PLL3_ENABLE();
 800656e:	4b0f      	ldr	r3, [pc, #60]	; (80065ac <RCCEx_PLL3_Config+0x15c>)
 8006570:	681b      	ldr	r3, [r3, #0]
 8006572:	4a0e      	ldr	r2, [pc, #56]	; (80065ac <RCCEx_PLL3_Config+0x15c>)
 8006574:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8006578:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800657a:	f7fa f8e5 	bl	8000748 <HAL_GetTick>
 800657e:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL3 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 8006580:	e008      	b.n	8006594 <RCCEx_PLL3_Config+0x144>
    {
      if( (HAL_GetTick() - tickstart ) > PLL3_TIMEOUT_VALUE)
 8006582:	f7fa f8e1 	bl	8000748 <HAL_GetTick>
 8006586:	4602      	mov	r2, r0
 8006588:	68bb      	ldr	r3, [r7, #8]
 800658a:	1ad3      	subs	r3, r2, r3
 800658c:	2b02      	cmp	r3, #2
 800658e:	d901      	bls.n	8006594 <RCCEx_PLL3_Config+0x144>
      {
        return HAL_TIMEOUT;
 8006590:	2303      	movs	r3, #3
 8006592:	e006      	b.n	80065a2 <RCCEx_PLL3_Config+0x152>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 8006594:	4b05      	ldr	r3, [pc, #20]	; (80065ac <RCCEx_PLL3_Config+0x15c>)
 8006596:	681b      	ldr	r3, [r3, #0]
 8006598:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 800659c:	2b00      	cmp	r3, #0
 800659e:	d0f0      	beq.n	8006582 <RCCEx_PLL3_Config+0x132>
    }

  }


  return status;
 80065a0:	7bfb      	ldrb	r3, [r7, #15]
}
 80065a2:	4618      	mov	r0, r3
 80065a4:	3710      	adds	r7, #16
 80065a6:	46bd      	mov	sp, r7
 80065a8:	bd80      	pop	{r7, pc}
 80065aa:	bf00      	nop
 80065ac:	58024400 	.word	0x58024400
 80065b0:	ffff0007 	.word	0xffff0007

080065b4 <HAL_RTC_Init>:
  * @brief  Initialize the RTC peripheral
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc)
{
 80065b4:	b580      	push	{r7, lr}
 80065b6:	b084      	sub	sp, #16
 80065b8:	af00      	add	r7, sp, #0
 80065ba:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_ERROR;
 80065bc:	2301      	movs	r3, #1
 80065be:	73fb      	strb	r3, [r7, #15]

  /* Check RTC handler */
  if(hrtc != NULL)
 80065c0:	687b      	ldr	r3, [r7, #4]
 80065c2:	2b00      	cmp	r3, #0
 80065c4:	d067      	beq.n	8006696 <HAL_RTC_Init+0xe2>
      {
        hrtc->MspDeInitCallback = HAL_RTC_MspDeInit;
      }
    }
#else /*  (USE_HAL_RTC_REGISTER_CALLBACKS == 1) */
    if(hrtc->State == HAL_RTC_STATE_RESET)
 80065c6:	687b      	ldr	r3, [r7, #4]
 80065c8:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 80065cc:	b2db      	uxtb	r3, r3
 80065ce:	2b00      	cmp	r3, #0
 80065d0:	d106      	bne.n	80065e0 <HAL_RTC_Init+0x2c>
    {
      /* Allocate lock resource and initialize it */
      hrtc->Lock = HAL_UNLOCKED;
 80065d2:	687b      	ldr	r3, [r7, #4]
 80065d4:	2200      	movs	r2, #0
 80065d6:	f883 2020 	strb.w	r2, [r3, #32]

      /* Initialize RTC MSP */
      HAL_RTC_MspInit(hrtc);
 80065da:	6878      	ldr	r0, [r7, #4]
 80065dc:	f00a fd42 	bl	8011064 <HAL_RTC_MspInit>
    }
#endif /*  (USE_HAL_RTC_REGISTER_CALLBACKS == 1) */

    /* Set RTC state */
    hrtc->State = HAL_RTC_STATE_BUSY;
 80065e0:	687b      	ldr	r3, [r7, #4]
 80065e2:	2202      	movs	r2, #2
 80065e4:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21

    /* Disable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80065e8:	687b      	ldr	r3, [r7, #4]
 80065ea:	681b      	ldr	r3, [r3, #0]
 80065ec:	22ca      	movs	r2, #202	; 0xca
 80065ee:	625a      	str	r2, [r3, #36]	; 0x24
 80065f0:	687b      	ldr	r3, [r7, #4]
 80065f2:	681b      	ldr	r3, [r3, #0]
 80065f4:	2253      	movs	r2, #83	; 0x53
 80065f6:	625a      	str	r2, [r3, #36]	; 0x24

   /* Enter Initialization mode */
    status = RTC_EnterInitMode(hrtc);
 80065f8:	6878      	ldr	r0, [r7, #4]
 80065fa:	f000 f879 	bl	80066f0 <RTC_EnterInitMode>
 80065fe:	4603      	mov	r3, r0
 8006600:	73fb      	strb	r3, [r7, #15]
    if (status == HAL_OK)
 8006602:	7bfb      	ldrb	r3, [r7, #15]
 8006604:	2b00      	cmp	r3, #0
 8006606:	d13b      	bne.n	8006680 <HAL_RTC_Init+0xcc>
#if defined(RTC_CR_TAMPOE)
      /* Clear RTC_CR FMT, OSEL, POL and TAMPOE Bits */
      hrtc->Instance->CR &= ~(RTC_CR_FMT | RTC_CR_POL | RTC_CR_OSEL | RTC_CR_TAMPOE);
#else  /* RTC_CR_TAMPOE */
      /* Clear RTC_CR FMT, OSEL and POL Bits */
      hrtc->Instance->CR &= ~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL);
 8006608:	687b      	ldr	r3, [r7, #4]
 800660a:	681b      	ldr	r3, [r3, #0]
 800660c:	6899      	ldr	r1, [r3, #8]
 800660e:	687b      	ldr	r3, [r7, #4]
 8006610:	681a      	ldr	r2, [r3, #0]
 8006612:	4b23      	ldr	r3, [pc, #140]	; (80066a0 <HAL_RTC_Init+0xec>)
 8006614:	400b      	ands	r3, r1
 8006616:	6093      	str	r3, [r2, #8]
#endif /* RTC_CR_TAMPOE */

      /* Set RTC_CR register */
      hrtc->Instance->CR |= (hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 8006618:	687b      	ldr	r3, [r7, #4]
 800661a:	681b      	ldr	r3, [r3, #0]
 800661c:	6899      	ldr	r1, [r3, #8]
 800661e:	687b      	ldr	r3, [r7, #4]
 8006620:	685a      	ldr	r2, [r3, #4]
 8006622:	687b      	ldr	r3, [r7, #4]
 8006624:	691b      	ldr	r3, [r3, #16]
 8006626:	431a      	orrs	r2, r3
 8006628:	687b      	ldr	r3, [r7, #4]
 800662a:	699b      	ldr	r3, [r3, #24]
 800662c:	431a      	orrs	r2, r3
 800662e:	687b      	ldr	r3, [r7, #4]
 8006630:	681b      	ldr	r3, [r3, #0]
 8006632:	430a      	orrs	r2, r1
 8006634:	609a      	str	r2, [r3, #8]

      /* Configure the RTC PRER */
      hrtc->Instance->PRER = (hrtc->Init.AsynchPrediv << RTC_PRER_PREDIV_A_Pos) | (hrtc->Init.SynchPrediv << RTC_PRER_PREDIV_S_Pos);
 8006636:	687b      	ldr	r3, [r7, #4]
 8006638:	689b      	ldr	r3, [r3, #8]
 800663a:	0419      	lsls	r1, r3, #16
 800663c:	687b      	ldr	r3, [r7, #4]
 800663e:	68da      	ldr	r2, [r3, #12]
 8006640:	687b      	ldr	r3, [r7, #4]
 8006642:	681b      	ldr	r3, [r3, #0]
 8006644:	430a      	orrs	r2, r1
 8006646:	611a      	str	r2, [r3, #16]

      /* Exit Initialization mode */
      status = RTC_ExitInitMode(hrtc);
 8006648:	6878      	ldr	r0, [r7, #4]
 800664a:	f000 f885 	bl	8006758 <RTC_ExitInitMode>
 800664e:	4603      	mov	r3, r0
 8006650:	73fb      	strb	r3, [r7, #15]

      if(status == HAL_OK)
 8006652:	7bfb      	ldrb	r3, [r7, #15]
 8006654:	2b00      	cmp	r3, #0
 8006656:	d113      	bne.n	8006680 <HAL_RTC_Init+0xcc>
        hrtc->Instance->CR &= ~(RTC_CR_TAMPALRM_PU | RTC_CR_TAMPALRM_TYPE | RTC_CR_OUT2EN);
        hrtc->Instance->CR |= (hrtc->Init.OutPutPullUp | hrtc->Init.OutPutType | hrtc->Init.OutPutRemap);
#endif /* RTC_CR_TAMPALRM_TYPE && RTC_CR_OUT2EN && RTC_CR_TAMPALRM_PU */

#if defined(RTC_OR_ALARMOUTTYPE) && defined(RTC_OR_OUT_RMP)
        hrtc->Instance->OR &= ~(RTC_OR_ALARMOUTTYPE | RTC_OR_OUT_RMP);
 8006658:	687b      	ldr	r3, [r7, #4]
 800665a:	681b      	ldr	r3, [r3, #0]
 800665c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800665e:	687b      	ldr	r3, [r7, #4]
 8006660:	681b      	ldr	r3, [r3, #0]
 8006662:	f022 0203 	bic.w	r2, r2, #3
 8006666:	64da      	str	r2, [r3, #76]	; 0x4c
        hrtc->Instance->OR |= (hrtc->Init.OutPutType | hrtc->Init.OutPutRemap);
 8006668:	687b      	ldr	r3, [r7, #4]
 800666a:	681b      	ldr	r3, [r3, #0]
 800666c:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
 800666e:	687b      	ldr	r3, [r7, #4]
 8006670:	69da      	ldr	r2, [r3, #28]
 8006672:	687b      	ldr	r3, [r7, #4]
 8006674:	695b      	ldr	r3, [r3, #20]
 8006676:	431a      	orrs	r2, r3
 8006678:	687b      	ldr	r3, [r7, #4]
 800667a:	681b      	ldr	r3, [r3, #0]
 800667c:	430a      	orrs	r2, r1
 800667e:	64da      	str	r2, [r3, #76]	; 0x4c
#endif /* ALARMOUTTYPE && RTC_OR_OUT_RMP */
      }
    }
    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8006680:	687b      	ldr	r3, [r7, #4]
 8006682:	681b      	ldr	r3, [r3, #0]
 8006684:	22ff      	movs	r2, #255	; 0xff
 8006686:	625a      	str	r2, [r3, #36]	; 0x24
    if (status == HAL_OK)
 8006688:	7bfb      	ldrb	r3, [r7, #15]
 800668a:	2b00      	cmp	r3, #0
 800668c:	d103      	bne.n	8006696 <HAL_RTC_Init+0xe2>
    {
      /* Set RTC state */
      hrtc->State = HAL_RTC_STATE_READY;
 800668e:	687b      	ldr	r3, [r7, #4]
 8006690:	2201      	movs	r2, #1
 8006692:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
    }
  }

  /* return status */
  return status;
 8006696:	7bfb      	ldrb	r3, [r7, #15]
}
 8006698:	4618      	mov	r0, r3
 800669a:	3710      	adds	r7, #16
 800669c:	46bd      	mov	sp, r7
 800669e:	bd80      	pop	{r7, pc}
 80066a0:	ff8fffbf 	.word	0xff8fffbf

080066a4 <HAL_RTC_WaitForSynchro>:
  *         correctly copied into the RTC_TR and RTC_DR shadow registers.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef *hrtc)
{
 80066a4:	b580      	push	{r7, lr}
 80066a6:	b084      	sub	sp, #16
 80066a8:	af00      	add	r7, sp, #0
 80066aa:	6078      	str	r0, [r7, #4]
  /* Clear RSF flag */
#if defined(RTC_ICSR_RSF)
  hrtc->Instance->ICSR &= (uint32_t)RTC_RSF_MASK;
#endif /* RTC_ICSR_RSF */
#if defined(RTC_ISR_RSF)
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 80066ac:	687b      	ldr	r3, [r7, #4]
 80066ae:	681b      	ldr	r3, [r3, #0]
 80066b0:	68da      	ldr	r2, [r3, #12]
 80066b2:	687b      	ldr	r3, [r7, #4]
 80066b4:	681b      	ldr	r3, [r3, #0]
 80066b6:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
 80066ba:	60da      	str	r2, [r3, #12]
#endif /* RTC_ISR_RSF */

  tickstart = HAL_GetTick();
 80066bc:	f7fa f844 	bl	8000748 <HAL_GetTick>
 80066c0:	60f8      	str	r0, [r7, #12]
  /* Wait the registers to be synchronised */
#if defined(RTC_ICSR_RSF)
  while ((hrtc->Instance->ICSR & RTC_ICSR_RSF) == 0U)
#endif /* RTC_ICSR_RSF */
#if defined(RTC_ISR_RSF)
    while ((hrtc->Instance->ISR & RTC_ISR_RSF) == 0U)
 80066c2:	e009      	b.n	80066d8 <HAL_RTC_WaitForSynchro+0x34>
#endif /* RTC_ISR_RSF */
    {
      if((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 80066c4:	f7fa f840 	bl	8000748 <HAL_GetTick>
 80066c8:	4602      	mov	r2, r0
 80066ca:	68fb      	ldr	r3, [r7, #12]
 80066cc:	1ad3      	subs	r3, r2, r3
 80066ce:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 80066d2:	d901      	bls.n	80066d8 <HAL_RTC_WaitForSynchro+0x34>
      {
        return HAL_TIMEOUT;
 80066d4:	2303      	movs	r3, #3
 80066d6:	e007      	b.n	80066e8 <HAL_RTC_WaitForSynchro+0x44>
    while ((hrtc->Instance->ISR & RTC_ISR_RSF) == 0U)
 80066d8:	687b      	ldr	r3, [r7, #4]
 80066da:	681b      	ldr	r3, [r3, #0]
 80066dc:	68db      	ldr	r3, [r3, #12]
 80066de:	f003 0320 	and.w	r3, r3, #32
 80066e2:	2b00      	cmp	r3, #0
 80066e4:	d0ee      	beq.n	80066c4 <HAL_RTC_WaitForSynchro+0x20>
      }
    }

  return HAL_OK;
 80066e6:	2300      	movs	r3, #0
}
 80066e8:	4618      	mov	r0, r3
 80066ea:	3710      	adds	r7, #16
 80066ec:	46bd      	mov	sp, r7
 80066ee:	bd80      	pop	{r7, pc}

080066f0 <RTC_EnterInitMode>:
  *         __HAL_RTC_WRITEPROTECTION_DISABLE() before calling this function.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef *hrtc)
{
 80066f0:	b580      	push	{r7, lr}
 80066f2:	b084      	sub	sp, #16
 80066f4:	af00      	add	r7, sp, #0
 80066f6:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 80066f8:	2300      	movs	r3, #0
 80066fa:	73fb      	strb	r3, [r7, #15]
      }
    }
  }
#endif /* RTC_ICSR_INITF */
#if defined(RTC_ISR_INITF)
  if((hrtc->Instance->ISR & RTC_ISR_INITF) == 0U)
 80066fc:	687b      	ldr	r3, [r7, #4]
 80066fe:	681b      	ldr	r3, [r3, #0]
 8006700:	68db      	ldr	r3, [r3, #12]
 8006702:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8006706:	2b00      	cmp	r3, #0
 8006708:	d120      	bne.n	800674c <RTC_EnterInitMode+0x5c>
  {
    /* Set the Initialization mode */
    hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
 800670a:	687b      	ldr	r3, [r7, #4]
 800670c:	681b      	ldr	r3, [r3, #0]
 800670e:	f04f 32ff 	mov.w	r2, #4294967295
 8006712:	60da      	str	r2, [r3, #12]

    tickstart = HAL_GetTick();
 8006714:	f7fa f818 	bl	8000748 <HAL_GetTick>
 8006718:	60b8      	str	r0, [r7, #8]
    /* Wait till RTC is in INIT state and if Time out is reached exit */
    while (((hrtc->Instance->ISR & RTC_ISR_INITF) == 0U) && (status != HAL_TIMEOUT))
 800671a:	e00d      	b.n	8006738 <RTC_EnterInitMode+0x48>
    {
      if((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
 800671c:	f7fa f814 	bl	8000748 <HAL_GetTick>
 8006720:	4602      	mov	r2, r0
 8006722:	68bb      	ldr	r3, [r7, #8]
 8006724:	1ad3      	subs	r3, r2, r3
 8006726:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800672a:	d905      	bls.n	8006738 <RTC_EnterInitMode+0x48>
      {
        status = HAL_TIMEOUT;
 800672c:	2303      	movs	r3, #3
 800672e:	73fb      	strb	r3, [r7, #15]
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8006730:	687b      	ldr	r3, [r7, #4]
 8006732:	2203      	movs	r2, #3
 8006734:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
    while (((hrtc->Instance->ISR & RTC_ISR_INITF) == 0U) && (status != HAL_TIMEOUT))
 8006738:	687b      	ldr	r3, [r7, #4]
 800673a:	681b      	ldr	r3, [r3, #0]
 800673c:	68db      	ldr	r3, [r3, #12]
 800673e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8006742:	2b00      	cmp	r3, #0
 8006744:	d102      	bne.n	800674c <RTC_EnterInitMode+0x5c>
 8006746:	7bfb      	ldrb	r3, [r7, #15]
 8006748:	2b03      	cmp	r3, #3
 800674a:	d1e7      	bne.n	800671c <RTC_EnterInitMode+0x2c>
      }
    }
  }
#endif /* RTC_ISR_INITF */

  return status;
 800674c:	7bfb      	ldrb	r3, [r7, #15]
}
 800674e:	4618      	mov	r0, r3
 8006750:	3710      	adds	r7, #16
 8006752:	46bd      	mov	sp, r7
 8006754:	bd80      	pop	{r7, pc}
	...

08006758 <RTC_ExitInitMode>:
  * @brief  Exit the RTC Initialization mode.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_ExitInitMode(RTC_HandleTypeDef *hrtc)
{
 8006758:	b580      	push	{r7, lr}
 800675a:	b084      	sub	sp, #16
 800675c:	af00      	add	r7, sp, #0
 800675e:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 8006760:	2300      	movs	r3, #0
 8006762:	73fb      	strb	r3, [r7, #15]
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_INIT);

#elif defined(RTC_ISR_INITF)

  /* Exit Initialization mode */
  CLEAR_BIT(RTC->ISR, RTC_ISR_INITF);
 8006764:	4b1a      	ldr	r3, [pc, #104]	; (80067d0 <RTC_ExitInitMode+0x78>)
 8006766:	68db      	ldr	r3, [r3, #12]
 8006768:	4a19      	ldr	r2, [pc, #100]	; (80067d0 <RTC_ExitInitMode+0x78>)
 800676a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800676e:	60d3      	str	r3, [r2, #12]

#endif /* RTC_ISR_INITF */
  /* If CR_BYPSHAD bit = 0, wait for synchro */
  if (READ_BIT(RTC->CR, RTC_CR_BYPSHAD) == 0U)
 8006770:	4b17      	ldr	r3, [pc, #92]	; (80067d0 <RTC_ExitInitMode+0x78>)
 8006772:	689b      	ldr	r3, [r3, #8]
 8006774:	f003 0320 	and.w	r3, r3, #32
 8006778:	2b00      	cmp	r3, #0
 800677a:	d10c      	bne.n	8006796 <RTC_ExitInitMode+0x3e>
  {
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 800677c:	6878      	ldr	r0, [r7, #4]
 800677e:	f7ff ff91 	bl	80066a4 <HAL_RTC_WaitForSynchro>
 8006782:	4603      	mov	r3, r0
 8006784:	2b00      	cmp	r3, #0
 8006786:	d01e      	beq.n	80067c6 <RTC_ExitInitMode+0x6e>
    {
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8006788:	687b      	ldr	r3, [r7, #4]
 800678a:	2203      	movs	r2, #3
 800678c:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
      status = HAL_TIMEOUT;
 8006790:	2303      	movs	r3, #3
 8006792:	73fb      	strb	r3, [r7, #15]
 8006794:	e017      	b.n	80067c6 <RTC_ExitInitMode+0x6e>
    }
  }
  else
  {
    /* Clear BYPSHAD bit */
    CLEAR_BIT(RTC->CR, RTC_CR_BYPSHAD);
 8006796:	4b0e      	ldr	r3, [pc, #56]	; (80067d0 <RTC_ExitInitMode+0x78>)
 8006798:	689b      	ldr	r3, [r3, #8]
 800679a:	4a0d      	ldr	r2, [pc, #52]	; (80067d0 <RTC_ExitInitMode+0x78>)
 800679c:	f023 0320 	bic.w	r3, r3, #32
 80067a0:	6093      	str	r3, [r2, #8]
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 80067a2:	6878      	ldr	r0, [r7, #4]
 80067a4:	f7ff ff7e 	bl	80066a4 <HAL_RTC_WaitForSynchro>
 80067a8:	4603      	mov	r3, r0
 80067aa:	2b00      	cmp	r3, #0
 80067ac:	d005      	beq.n	80067ba <RTC_ExitInitMode+0x62>
    {
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 80067ae:	687b      	ldr	r3, [r7, #4]
 80067b0:	2203      	movs	r2, #3
 80067b2:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
      status = HAL_TIMEOUT;
 80067b6:	2303      	movs	r3, #3
 80067b8:	73fb      	strb	r3, [r7, #15]
    }
    /* Restore BYPSHAD bit */
    SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
 80067ba:	4b05      	ldr	r3, [pc, #20]	; (80067d0 <RTC_ExitInitMode+0x78>)
 80067bc:	689b      	ldr	r3, [r3, #8]
 80067be:	4a04      	ldr	r2, [pc, #16]	; (80067d0 <RTC_ExitInitMode+0x78>)
 80067c0:	f043 0320 	orr.w	r3, r3, #32
 80067c4:	6093      	str	r3, [r2, #8]
  }

  return status;
 80067c6:	7bfb      	ldrb	r3, [r7, #15]
}
 80067c8:	4618      	mov	r0, r3
 80067ca:	3710      	adds	r7, #16
 80067cc:	46bd      	mov	sp, r7
 80067ce:	bd80      	pop	{r7, pc}
 80067d0:	58004000 	.word	0x58004000

080067d4 <HAL_SPI_Init>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 80067d4:	b580      	push	{r7, lr}
 80067d6:	b084      	sub	sp, #16
 80067d8:	af00      	add	r7, sp, #0
 80067da:	6078      	str	r0, [r7, #4]
  uint32_t crc_length;
  uint32_t packet_length;

  /* Check the SPI handle allocation */
  if (hspi == NULL)
 80067dc:	687b      	ldr	r3, [r7, #4]
 80067de:	2b00      	cmp	r3, #0
 80067e0:	d101      	bne.n	80067e6 <HAL_SPI_Init+0x12>
  {
    return HAL_ERROR;
 80067e2:	2301      	movs	r3, #1
 80067e4:	e0f1      	b.n	80069ca <HAL_SPI_Init+0x1f6>
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
    assert_param(IS_SPI_CRC_INITIALIZATION_PATTERN(hspi->Init.TxCRCInitializationPattern));
    assert_param(IS_SPI_CRC_INITIALIZATION_PATTERN(hspi->Init.RxCRCInitializationPattern));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80067e6:	687b      	ldr	r3, [r7, #4]
 80067e8:	2200      	movs	r2, #0
 80067ea:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* USE_SPI_CRC */

  /* Verify that the SPI instance supports Data Size higher than 16bits */
  if ((!IS_SPI_HIGHEND_INSTANCE(hspi->Instance)) && (hspi->Init.DataSize > SPI_DATASIZE_16BIT))
 80067ec:	687b      	ldr	r3, [r7, #4]
 80067ee:	681b      	ldr	r3, [r3, #0]
 80067f0:	4a78      	ldr	r2, [pc, #480]	; (80069d4 <HAL_SPI_Init+0x200>)
 80067f2:	4293      	cmp	r3, r2
 80067f4:	d00f      	beq.n	8006816 <HAL_SPI_Init+0x42>
 80067f6:	687b      	ldr	r3, [r7, #4]
 80067f8:	681b      	ldr	r3, [r3, #0]
 80067fa:	4a77      	ldr	r2, [pc, #476]	; (80069d8 <HAL_SPI_Init+0x204>)
 80067fc:	4293      	cmp	r3, r2
 80067fe:	d00a      	beq.n	8006816 <HAL_SPI_Init+0x42>
 8006800:	687b      	ldr	r3, [r7, #4]
 8006802:	681b      	ldr	r3, [r3, #0]
 8006804:	4a75      	ldr	r2, [pc, #468]	; (80069dc <HAL_SPI_Init+0x208>)
 8006806:	4293      	cmp	r3, r2
 8006808:	d005      	beq.n	8006816 <HAL_SPI_Init+0x42>
 800680a:	687b      	ldr	r3, [r7, #4]
 800680c:	68db      	ldr	r3, [r3, #12]
 800680e:	2b0f      	cmp	r3, #15
 8006810:	d901      	bls.n	8006816 <HAL_SPI_Init+0x42>
  {
    return HAL_ERROR;
 8006812:	2301      	movs	r3, #1
 8006814:	e0d9      	b.n	80069ca <HAL_SPI_Init+0x1f6>
  }

  /* Verify that the SPI instance supports requested data packing */
  packet_length = SPI_GetPacketSize(hspi);
 8006816:	6878      	ldr	r0, [r7, #4]
 8006818:	f000 fb90 	bl	8006f3c <SPI_GetPacketSize>
 800681c:	60f8      	str	r0, [r7, #12]
  if (((!IS_SPI_HIGHEND_INSTANCE(hspi->Instance)) && (packet_length > SPI_LOWEND_FIFO_SIZE)) ||
 800681e:	687b      	ldr	r3, [r7, #4]
 8006820:	681b      	ldr	r3, [r3, #0]
 8006822:	4a6c      	ldr	r2, [pc, #432]	; (80069d4 <HAL_SPI_Init+0x200>)
 8006824:	4293      	cmp	r3, r2
 8006826:	d00c      	beq.n	8006842 <HAL_SPI_Init+0x6e>
 8006828:	687b      	ldr	r3, [r7, #4]
 800682a:	681b      	ldr	r3, [r3, #0]
 800682c:	4a6a      	ldr	r2, [pc, #424]	; (80069d8 <HAL_SPI_Init+0x204>)
 800682e:	4293      	cmp	r3, r2
 8006830:	d007      	beq.n	8006842 <HAL_SPI_Init+0x6e>
 8006832:	687b      	ldr	r3, [r7, #4]
 8006834:	681b      	ldr	r3, [r3, #0]
 8006836:	4a69      	ldr	r2, [pc, #420]	; (80069dc <HAL_SPI_Init+0x208>)
 8006838:	4293      	cmp	r3, r2
 800683a:	d002      	beq.n	8006842 <HAL_SPI_Init+0x6e>
 800683c:	68fb      	ldr	r3, [r7, #12]
 800683e:	2b08      	cmp	r3, #8
 8006840:	d811      	bhi.n	8006866 <HAL_SPI_Init+0x92>
      ((IS_SPI_HIGHEND_INSTANCE(hspi->Instance)) && (packet_length > SPI_HIGHEND_FIFO_SIZE)))
 8006842:	687b      	ldr	r3, [r7, #4]
 8006844:	681b      	ldr	r3, [r3, #0]
  if (((!IS_SPI_HIGHEND_INSTANCE(hspi->Instance)) && (packet_length > SPI_LOWEND_FIFO_SIZE)) ||
 8006846:	4a63      	ldr	r2, [pc, #396]	; (80069d4 <HAL_SPI_Init+0x200>)
 8006848:	4293      	cmp	r3, r2
 800684a:	d009      	beq.n	8006860 <HAL_SPI_Init+0x8c>
      ((IS_SPI_HIGHEND_INSTANCE(hspi->Instance)) && (packet_length > SPI_HIGHEND_FIFO_SIZE)))
 800684c:	687b      	ldr	r3, [r7, #4]
 800684e:	681b      	ldr	r3, [r3, #0]
 8006850:	4a61      	ldr	r2, [pc, #388]	; (80069d8 <HAL_SPI_Init+0x204>)
 8006852:	4293      	cmp	r3, r2
 8006854:	d004      	beq.n	8006860 <HAL_SPI_Init+0x8c>
 8006856:	687b      	ldr	r3, [r7, #4]
 8006858:	681b      	ldr	r3, [r3, #0]
 800685a:	4a60      	ldr	r2, [pc, #384]	; (80069dc <HAL_SPI_Init+0x208>)
 800685c:	4293      	cmp	r3, r2
 800685e:	d104      	bne.n	800686a <HAL_SPI_Init+0x96>
 8006860:	68fb      	ldr	r3, [r7, #12]
 8006862:	2b10      	cmp	r3, #16
 8006864:	d901      	bls.n	800686a <HAL_SPI_Init+0x96>
  {
    return HAL_ERROR;
 8006866:	2301      	movs	r3, #1
 8006868:	e0af      	b.n	80069ca <HAL_SPI_Init+0x1f6>
  {
    crc_length = hspi->Init.DataSize << SPI_CFG1_CRCSIZE_Pos;
  }
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 800686a:	687b      	ldr	r3, [r7, #4]
 800686c:	f893 3081 	ldrb.w	r3, [r3, #129]	; 0x81
 8006870:	b2db      	uxtb	r3, r3
 8006872:	2b00      	cmp	r3, #0
 8006874:	d106      	bne.n	8006884 <HAL_SPI_Init+0xb0>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 8006876:	687b      	ldr	r3, [r7, #4]
 8006878:	2200      	movs	r2, #0
 800687a:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    hspi->MspInitCallback(hspi);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 800687e:	6878      	ldr	r0, [r7, #4]
 8006880:	f00a fc20 	bl	80110c4 <HAL_SPI_MspInit>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 8006884:	687b      	ldr	r3, [r7, #4]
 8006886:	2202      	movs	r2, #2
 8006888:	f883 2081 	strb.w	r2, [r3, #129]	; 0x81

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 800688c:	687b      	ldr	r3, [r7, #4]
 800688e:	681b      	ldr	r3, [r3, #0]
 8006890:	681a      	ldr	r2, [r3, #0]
 8006892:	687b      	ldr	r3, [r7, #4]
 8006894:	681b      	ldr	r3, [r3, #0]
 8006896:	f022 0201 	bic.w	r2, r2, #1
 800689a:	601a      	str	r2, [r3, #0]

#if (USE_SPI_CRC == 0)
  /* Keep the default value of CRCSIZE in case of CRC is not used */
  crc_length = hspi->Instance->CFG1 & SPI_CFG1_CRCSIZE;
 800689c:	687b      	ldr	r3, [r7, #4]
 800689e:	681b      	ldr	r3, [r3, #0]
 80068a0:	689b      	ldr	r3, [r3, #8]
 80068a2:	f403 13f8 	and.w	r3, r3, #2031616	; 0x1f0000
 80068a6:	60bb      	str	r3, [r7, #8]
  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
  Communication speed, First bit, CRC calculation state, CRC Length */

  /* SPIx NSS Software Management Configuration */
  if ((hspi->Init.NSS == SPI_NSS_SOFT) && (((hspi->Init.Mode == SPI_MODE_MASTER) &&  \
 80068a8:	687b      	ldr	r3, [r7, #4]
 80068aa:	699b      	ldr	r3, [r3, #24]
 80068ac:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 80068b0:	d119      	bne.n	80068e6 <HAL_SPI_Init+0x112>
 80068b2:	687b      	ldr	r3, [r7, #4]
 80068b4:	685b      	ldr	r3, [r3, #4]
 80068b6:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 80068ba:	d103      	bne.n	80068c4 <HAL_SPI_Init+0xf0>
                                            (hspi->Init.NSSPolarity == SPI_NSS_POLARITY_LOW)) || \
 80068bc:	687b      	ldr	r3, [r7, #4]
 80068be:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  if ((hspi->Init.NSS == SPI_NSS_SOFT) && (((hspi->Init.Mode == SPI_MODE_MASTER) &&  \
 80068c0:	2b00      	cmp	r3, #0
 80068c2:	d008      	beq.n	80068d6 <HAL_SPI_Init+0x102>
                                           ((hspi->Init.Mode == SPI_MODE_SLAVE) && \
 80068c4:	687b      	ldr	r3, [r7, #4]
 80068c6:	685b      	ldr	r3, [r3, #4]
                                            (hspi->Init.NSSPolarity == SPI_NSS_POLARITY_LOW)) || \
 80068c8:	2b00      	cmp	r3, #0
 80068ca:	d10c      	bne.n	80068e6 <HAL_SPI_Init+0x112>
                                            (hspi->Init.NSSPolarity == SPI_NSS_POLARITY_HIGH))))
 80068cc:	687b      	ldr	r3, [r7, #4]
 80068ce:	6b9b      	ldr	r3, [r3, #56]	; 0x38
                                           ((hspi->Init.Mode == SPI_MODE_SLAVE) && \
 80068d0:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 80068d4:	d107      	bne.n	80068e6 <HAL_SPI_Init+0x112>
  {
    SET_BIT(hspi->Instance->CR1, SPI_CR1_SSI);
 80068d6:	687b      	ldr	r3, [r7, #4]
 80068d8:	681b      	ldr	r3, [r3, #0]
 80068da:	681a      	ldr	r2, [r3, #0]
 80068dc:	687b      	ldr	r3, [r7, #4]
 80068de:	681b      	ldr	r3, [r3, #0]
 80068e0:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 80068e4:	601a      	str	r2, [r3, #0]
  }

  /* SPIx CFG1 Configuration */
  WRITE_REG(hspi->Instance->CFG1, (hspi->Init.BaudRatePrescaler | hspi->Init.CRCCalculation | crc_length |
 80068e6:	687b      	ldr	r3, [r7, #4]
 80068e8:	69da      	ldr	r2, [r3, #28]
 80068ea:	687b      	ldr	r3, [r7, #4]
 80068ec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80068ee:	431a      	orrs	r2, r3
 80068f0:	68bb      	ldr	r3, [r7, #8]
 80068f2:	431a      	orrs	r2, r3
 80068f4:	687b      	ldr	r3, [r7, #4]
 80068f6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80068f8:	ea42 0103 	orr.w	r1, r2, r3
 80068fc:	687b      	ldr	r3, [r7, #4]
 80068fe:	68da      	ldr	r2, [r3, #12]
 8006900:	687b      	ldr	r3, [r7, #4]
 8006902:	681b      	ldr	r3, [r3, #0]
 8006904:	430a      	orrs	r2, r1
 8006906:	609a      	str	r2, [r3, #8]
                                   hspi->Init.FifoThreshold     | hspi->Init.DataSize));

  /* SPIx CFG2 Configuration */
  WRITE_REG(hspi->Instance->CFG2, (hspi->Init.NSSPMode                | hspi->Init.TIMode    |
 8006908:	687b      	ldr	r3, [r7, #4]
 800690a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800690c:	687b      	ldr	r3, [r7, #4]
 800690e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006910:	431a      	orrs	r2, r3
 8006912:	687b      	ldr	r3, [r7, #4]
 8006914:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8006916:	431a      	orrs	r2, r3
 8006918:	687b      	ldr	r3, [r7, #4]
 800691a:	699b      	ldr	r3, [r3, #24]
 800691c:	431a      	orrs	r2, r3
 800691e:	687b      	ldr	r3, [r7, #4]
 8006920:	691b      	ldr	r3, [r3, #16]
 8006922:	431a      	orrs	r2, r3
 8006924:	687b      	ldr	r3, [r7, #4]
 8006926:	695b      	ldr	r3, [r3, #20]
 8006928:	431a      	orrs	r2, r3
 800692a:	687b      	ldr	r3, [r7, #4]
 800692c:	6a1b      	ldr	r3, [r3, #32]
 800692e:	431a      	orrs	r2, r3
 8006930:	687b      	ldr	r3, [r7, #4]
 8006932:	685b      	ldr	r3, [r3, #4]
 8006934:	431a      	orrs	r2, r3
 8006936:	687b      	ldr	r3, [r7, #4]
 8006938:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800693a:	431a      	orrs	r2, r3
 800693c:	687b      	ldr	r3, [r7, #4]
 800693e:	689b      	ldr	r3, [r3, #8]
 8006940:	431a      	orrs	r2, r3
 8006942:	687b      	ldr	r3, [r7, #4]
 8006944:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8006946:	ea42 0103 	orr.w	r1, r2, r3
 800694a:	687b      	ldr	r3, [r7, #4]
 800694c:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800694e:	687b      	ldr	r3, [r7, #4]
 8006950:	681b      	ldr	r3, [r3, #0]
 8006952:	430a      	orrs	r2, r1
 8006954:	60da      	str	r2, [r3, #12]
    WRITE_REG(hspi->Instance->CRCPOLY, hspi->Init.CRCPolynomial);
  }
#endif /* USE_SPI_CRC */

  /* Insure that Underrun configuration is managed only by Salve */
  if (hspi->Init.Mode == SPI_MODE_SLAVE)
 8006956:	687b      	ldr	r3, [r7, #4]
 8006958:	685b      	ldr	r3, [r3, #4]
 800695a:	2b00      	cmp	r3, #0
 800695c:	d113      	bne.n	8006986 <HAL_SPI_Init+0x1b2>
    /* Set Default Underrun configuration */
#if (USE_SPI_CRC != 0UL)
    if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_DISABLE)
#endif /* USE_SPI_CRC */
    {
      MODIFY_REG(hspi->Instance->CFG1, SPI_CFG1_UDRDET, SPI_CFG1_UDRDET_0);
 800695e:	687b      	ldr	r3, [r7, #4]
 8006960:	681b      	ldr	r3, [r3, #0]
 8006962:	689b      	ldr	r3, [r3, #8]
 8006964:	f423 52c0 	bic.w	r2, r3, #6144	; 0x1800
 8006968:	687b      	ldr	r3, [r7, #4]
 800696a:	681b      	ldr	r3, [r3, #0]
 800696c:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8006970:	609a      	str	r2, [r3, #8]
    }
    MODIFY_REG(hspi->Instance->CFG1, SPI_CFG1_UDRCFG, SPI_CFG1_UDRCFG_1);
 8006972:	687b      	ldr	r3, [r7, #4]
 8006974:	681b      	ldr	r3, [r3, #0]
 8006976:	689b      	ldr	r3, [r3, #8]
 8006978:	f423 62c0 	bic.w	r2, r3, #1536	; 0x600
 800697c:	687b      	ldr	r3, [r7, #4]
 800697e:	681b      	ldr	r3, [r3, #0]
 8006980:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8006984:	609a      	str	r2, [r3, #8]
  }

#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 8006986:	687b      	ldr	r3, [r7, #4]
 8006988:	681b      	ldr	r3, [r3, #0]
 800698a:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800698c:	687b      	ldr	r3, [r7, #4]
 800698e:	681b      	ldr	r3, [r3, #0]
 8006990:	f022 0201 	bic.w	r2, r2, #1
 8006994:	651a      	str	r2, [r3, #80]	; 0x50
#endif /* SPI_I2SCFGR_I2SMOD */

  /* Insure that AFCNTR is managed only by Master */
  if ((hspi->Init.Mode & SPI_MODE_MASTER) == SPI_MODE_MASTER)
 8006996:	687b      	ldr	r3, [r7, #4]
 8006998:	685b      	ldr	r3, [r3, #4]
 800699a:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800699e:	2b00      	cmp	r3, #0
 80069a0:	d00a      	beq.n	80069b8 <HAL_SPI_Init+0x1e4>
  {
    /* Alternate function GPIOs control */
    MODIFY_REG(hspi->Instance->CFG2, SPI_CFG2_AFCNTR, (hspi->Init.MasterKeepIOState));
 80069a2:	687b      	ldr	r3, [r7, #4]
 80069a4:	681b      	ldr	r3, [r3, #0]
 80069a6:	68db      	ldr	r3, [r3, #12]
 80069a8:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 80069ac:	687b      	ldr	r3, [r7, #4]
 80069ae:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80069b0:	687b      	ldr	r3, [r7, #4]
 80069b2:	681b      	ldr	r3, [r3, #0]
 80069b4:	430a      	orrs	r2, r1
 80069b6:	60da      	str	r2, [r3, #12]
  }

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80069b8:	687b      	ldr	r3, [r7, #4]
 80069ba:	2200      	movs	r2, #0
 80069bc:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  hspi->State     = HAL_SPI_STATE_READY;
 80069c0:	687b      	ldr	r3, [r7, #4]
 80069c2:	2201      	movs	r2, #1
 80069c4:	f883 2081 	strb.w	r2, [r3, #129]	; 0x81

  return HAL_OK;
 80069c8:	2300      	movs	r3, #0
}
 80069ca:	4618      	mov	r0, r3
 80069cc:	3710      	adds	r7, #16
 80069ce:	46bd      	mov	sp, r7
 80069d0:	bd80      	pop	{r7, pc}
 80069d2:	bf00      	nop
 80069d4:	40013000 	.word	0x40013000
 80069d8:	40003800 	.word	0x40003800
 80069dc:	40003c00 	.word	0x40003c00

080069e0 <HAL_SPI_IRQHandler>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for the specified SPI module.
  * @retval None
  */
void HAL_SPI_IRQHandler(SPI_HandleTypeDef *hspi)
{
 80069e0:	b580      	push	{r7, lr}
 80069e2:	b08a      	sub	sp, #40	; 0x28
 80069e4:	af00      	add	r7, sp, #0
 80069e6:	6078      	str	r0, [r7, #4]
  uint32_t itsource = hspi->Instance->IER;
 80069e8:	687b      	ldr	r3, [r7, #4]
 80069ea:	681b      	ldr	r3, [r3, #0]
 80069ec:	691b      	ldr	r3, [r3, #16]
 80069ee:	623b      	str	r3, [r7, #32]
  uint32_t itflag   = hspi->Instance->SR;
 80069f0:	687b      	ldr	r3, [r7, #4]
 80069f2:	681b      	ldr	r3, [r3, #0]
 80069f4:	695b      	ldr	r3, [r3, #20]
 80069f6:	61fb      	str	r3, [r7, #28]
  uint32_t trigger  = itsource & itflag;
 80069f8:	6a3a      	ldr	r2, [r7, #32]
 80069fa:	69fb      	ldr	r3, [r7, #28]
 80069fc:	4013      	ands	r3, r2
 80069fe:	61bb      	str	r3, [r7, #24]
  uint32_t cfg1     = hspi->Instance->CFG1;
 8006a00:	687b      	ldr	r3, [r7, #4]
 8006a02:	681b      	ldr	r3, [r3, #0]
 8006a04:	689b      	ldr	r3, [r3, #8]
 8006a06:	617b      	str	r3, [r7, #20]
  uint32_t handled  = 0UL;
 8006a08:	2300      	movs	r3, #0
 8006a0a:	627b      	str	r3, [r7, #36]	; 0x24

  HAL_SPI_StateTypeDef State = hspi->State;
 8006a0c:	687b      	ldr	r3, [r7, #4]
 8006a0e:	f893 3081 	ldrb.w	r3, [r3, #129]	; 0x81
 8006a12:	74fb      	strb	r3, [r7, #19]
#if defined (__GNUC__)
  __IO uint16_t *prxdr_16bits = (__IO uint16_t *)(&(hspi->Instance->RXDR));
 8006a14:	687b      	ldr	r3, [r7, #4]
 8006a16:	681b      	ldr	r3, [r3, #0]
 8006a18:	3330      	adds	r3, #48	; 0x30
 8006a1a:	60fb      	str	r3, [r7, #12]
#endif /* __GNUC__ */


  /* SPI in mode Transmitter and Receiver ------------------------------------*/
  if (HAL_IS_BIT_CLR(trigger, SPI_FLAG_OVR) && HAL_IS_BIT_CLR(trigger, SPI_FLAG_UDR) && \
 8006a1c:	69bb      	ldr	r3, [r7, #24]
 8006a1e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8006a22:	2b00      	cmp	r3, #0
 8006a24:	d113      	bne.n	8006a4e <HAL_SPI_IRQHandler+0x6e>
 8006a26:	69bb      	ldr	r3, [r7, #24]
 8006a28:	f003 0320 	and.w	r3, r3, #32
 8006a2c:	2b00      	cmp	r3, #0
 8006a2e:	d10e      	bne.n	8006a4e <HAL_SPI_IRQHandler+0x6e>
      HAL_IS_BIT_SET(trigger, SPI_FLAG_DXP))
 8006a30:	69bb      	ldr	r3, [r7, #24]
 8006a32:	f003 0304 	and.w	r3, r3, #4
  if (HAL_IS_BIT_CLR(trigger, SPI_FLAG_OVR) && HAL_IS_BIT_CLR(trigger, SPI_FLAG_UDR) && \
 8006a36:	2b00      	cmp	r3, #0
 8006a38:	d009      	beq.n	8006a4e <HAL_SPI_IRQHandler+0x6e>
  {
    hspi->TxISR(hspi);
 8006a3a:	687b      	ldr	r3, [r7, #4]
 8006a3c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8006a3e:	6878      	ldr	r0, [r7, #4]
 8006a40:	4798      	blx	r3
    hspi->RxISR(hspi);
 8006a42:	687b      	ldr	r3, [r7, #4]
 8006a44:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8006a46:	6878      	ldr	r0, [r7, #4]
 8006a48:	4798      	blx	r3
    handled = 1UL;
 8006a4a:	2301      	movs	r3, #1
 8006a4c:	627b      	str	r3, [r7, #36]	; 0x24
  }

  /* SPI in mode Receiver ----------------------------------------------------*/
  if (HAL_IS_BIT_CLR(trigger, SPI_FLAG_OVR) && HAL_IS_BIT_SET(trigger, SPI_FLAG_RXP) && \
 8006a4e:	69bb      	ldr	r3, [r7, #24]
 8006a50:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8006a54:	2b00      	cmp	r3, #0
 8006a56:	d10f      	bne.n	8006a78 <HAL_SPI_IRQHandler+0x98>
 8006a58:	69bb      	ldr	r3, [r7, #24]
 8006a5a:	f003 0301 	and.w	r3, r3, #1
 8006a5e:	2b00      	cmp	r3, #0
 8006a60:	d00a      	beq.n	8006a78 <HAL_SPI_IRQHandler+0x98>
      HAL_IS_BIT_CLR(trigger, SPI_FLAG_DXP))
 8006a62:	69bb      	ldr	r3, [r7, #24]
 8006a64:	f003 0304 	and.w	r3, r3, #4
  if (HAL_IS_BIT_CLR(trigger, SPI_FLAG_OVR) && HAL_IS_BIT_SET(trigger, SPI_FLAG_RXP) && \
 8006a68:	2b00      	cmp	r3, #0
 8006a6a:	d105      	bne.n	8006a78 <HAL_SPI_IRQHandler+0x98>
  {
    hspi->RxISR(hspi);
 8006a6c:	687b      	ldr	r3, [r7, #4]
 8006a6e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8006a70:	6878      	ldr	r0, [r7, #4]
 8006a72:	4798      	blx	r3
    handled = 1UL;
 8006a74:	2301      	movs	r3, #1
 8006a76:	627b      	str	r3, [r7, #36]	; 0x24
  }

  /* SPI in mode Transmitter -------------------------------------------------*/
  if (HAL_IS_BIT_CLR(trigger, SPI_FLAG_UDR) && HAL_IS_BIT_SET(trigger, SPI_FLAG_TXP) && \
 8006a78:	69bb      	ldr	r3, [r7, #24]
 8006a7a:	f003 0320 	and.w	r3, r3, #32
 8006a7e:	2b00      	cmp	r3, #0
 8006a80:	d10f      	bne.n	8006aa2 <HAL_SPI_IRQHandler+0xc2>
 8006a82:	69bb      	ldr	r3, [r7, #24]
 8006a84:	f003 0302 	and.w	r3, r3, #2
 8006a88:	2b00      	cmp	r3, #0
 8006a8a:	d00a      	beq.n	8006aa2 <HAL_SPI_IRQHandler+0xc2>
      HAL_IS_BIT_CLR(trigger, SPI_FLAG_DXP))
 8006a8c:	69bb      	ldr	r3, [r7, #24]
 8006a8e:	f003 0304 	and.w	r3, r3, #4
  if (HAL_IS_BIT_CLR(trigger, SPI_FLAG_UDR) && HAL_IS_BIT_SET(trigger, SPI_FLAG_TXP) && \
 8006a92:	2b00      	cmp	r3, #0
 8006a94:	d105      	bne.n	8006aa2 <HAL_SPI_IRQHandler+0xc2>
  {
    hspi->TxISR(hspi);
 8006a96:	687b      	ldr	r3, [r7, #4]
 8006a98:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8006a9a:	6878      	ldr	r0, [r7, #4]
 8006a9c:	4798      	blx	r3
    handled = 1UL;
 8006a9e:	2301      	movs	r3, #1
 8006aa0:	627b      	str	r3, [r7, #36]	; 0x24
    hspi->Reload.Requested = 0UL;
    __HAL_SPI_CLEAR_TSERFFLAG(hspi);
  }
#endif /* USE_SPI_RELOAD_TRANSFER */

  if (handled != 0UL)
 8006aa2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006aa4:	2b00      	cmp	r3, #0
 8006aa6:	f040 816f 	bne.w	8006d88 <HAL_SPI_IRQHandler+0x3a8>
  {
    return;
  }

  /* SPI End Of Transfer: DMA or IT based transfer */
  if (HAL_IS_BIT_SET(trigger, SPI_FLAG_EOT))
 8006aaa:	69bb      	ldr	r3, [r7, #24]
 8006aac:	f003 0308 	and.w	r3, r3, #8
 8006ab0:	2b00      	cmp	r3, #0
 8006ab2:	f000 80a0 	beq.w	8006bf6 <HAL_SPI_IRQHandler+0x216>
  {
    /* Clear EOT/TXTF/SUSP flag */
    __HAL_SPI_CLEAR_EOTFLAG(hspi);
 8006ab6:	687b      	ldr	r3, [r7, #4]
 8006ab8:	681b      	ldr	r3, [r3, #0]
 8006aba:	699a      	ldr	r2, [r3, #24]
 8006abc:	687b      	ldr	r3, [r7, #4]
 8006abe:	681b      	ldr	r3, [r3, #0]
 8006ac0:	f042 0208 	orr.w	r2, r2, #8
 8006ac4:	619a      	str	r2, [r3, #24]
    __HAL_SPI_CLEAR_TXTFFLAG(hspi);
 8006ac6:	687b      	ldr	r3, [r7, #4]
 8006ac8:	681b      	ldr	r3, [r3, #0]
 8006aca:	699a      	ldr	r2, [r3, #24]
 8006acc:	687b      	ldr	r3, [r7, #4]
 8006ace:	681b      	ldr	r3, [r3, #0]
 8006ad0:	f042 0210 	orr.w	r2, r2, #16
 8006ad4:	619a      	str	r2, [r3, #24]
    __HAL_SPI_CLEAR_SUSPFLAG(hspi);
 8006ad6:	687b      	ldr	r3, [r7, #4]
 8006ad8:	681b      	ldr	r3, [r3, #0]
 8006ada:	699a      	ldr	r2, [r3, #24]
 8006adc:	687b      	ldr	r3, [r7, #4]
 8006ade:	681b      	ldr	r3, [r3, #0]
 8006ae0:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8006ae4:	619a      	str	r2, [r3, #24]

    /* Disable EOT interrupt */
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_EOT);
 8006ae6:	687b      	ldr	r3, [r7, #4]
 8006ae8:	681b      	ldr	r3, [r3, #0]
 8006aea:	691a      	ldr	r2, [r3, #16]
 8006aec:	687b      	ldr	r3, [r7, #4]
 8006aee:	681b      	ldr	r3, [r3, #0]
 8006af0:	f022 0208 	bic.w	r2, r2, #8
 8006af4:	611a      	str	r2, [r3, #16]

    /* DMA Normal Mode */
    if (HAL_IS_BIT_CLR(cfg1, SPI_CFG1_TXDMAEN | SPI_CFG1_RXDMAEN) ||
 8006af6:	697b      	ldr	r3, [r7, #20]
 8006af8:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 8006afc:	2b00      	cmp	r3, #0
 8006afe:	d00f      	beq.n	8006b20 <HAL_SPI_IRQHandler+0x140>
 8006b00:	7cfb      	ldrb	r3, [r7, #19]
 8006b02:	2b04      	cmp	r3, #4
 8006b04:	d004      	beq.n	8006b10 <HAL_SPI_IRQHandler+0x130>
        ((State != HAL_SPI_STATE_BUSY_RX) && (hspi->hdmatx->Init.Mode == DMA_NORMAL)) ||
 8006b06:	687b      	ldr	r3, [r7, #4]
 8006b08:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8006b0a:	69db      	ldr	r3, [r3, #28]
 8006b0c:	2b00      	cmp	r3, #0
 8006b0e:	d007      	beq.n	8006b20 <HAL_SPI_IRQHandler+0x140>
 8006b10:	7cfb      	ldrb	r3, [r7, #19]
 8006b12:	2b03      	cmp	r3, #3
 8006b14:	d059      	beq.n	8006bca <HAL_SPI_IRQHandler+0x1ea>
        ((State != HAL_SPI_STATE_BUSY_TX) && (hspi->hdmarx->Init.Mode == DMA_NORMAL)))
 8006b16:	687b      	ldr	r3, [r7, #4]
 8006b18:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8006b1a:	69db      	ldr	r3, [r3, #28]
 8006b1c:	2b00      	cmp	r3, #0
 8006b1e:	d154      	bne.n	8006bca <HAL_SPI_IRQHandler+0x1ea>
    {
      /* For the IT based receive extra polling maybe required for last packet */
      if (HAL_IS_BIT_CLR(hspi->Instance->CFG1, SPI_CFG1_TXDMAEN | SPI_CFG1_RXDMAEN))
 8006b20:	687b      	ldr	r3, [r7, #4]
 8006b22:	681b      	ldr	r3, [r3, #0]
 8006b24:	689b      	ldr	r3, [r3, #8]
 8006b26:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 8006b2a:	2b00      	cmp	r3, #0
 8006b2c:	d13d      	bne.n	8006baa <HAL_SPI_IRQHandler+0x1ca>
      {
        /* Pooling remaining data */
        while (hspi->RxXferCount != 0UL)
 8006b2e:	e036      	b.n	8006b9e <HAL_SPI_IRQHandler+0x1be>
        {
          /* Receive data in 32 Bit mode */
          if (hspi->Init.DataSize > SPI_DATASIZE_16BIT)
 8006b30:	687b      	ldr	r3, [r7, #4]
 8006b32:	68db      	ldr	r3, [r3, #12]
 8006b34:	2b0f      	cmp	r3, #15
 8006b36:	d90b      	bls.n	8006b50 <HAL_SPI_IRQHandler+0x170>
          {
            *((uint32_t *)hspi->pRxBuffPtr) = *((__IO uint32_t *)&hspi->Instance->RXDR);
 8006b38:	687b      	ldr	r3, [r7, #4]
 8006b3a:	681a      	ldr	r2, [r3, #0]
 8006b3c:	687b      	ldr	r3, [r7, #4]
 8006b3e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8006b40:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8006b42:	601a      	str	r2, [r3, #0]
            hspi->pRxBuffPtr += sizeof(uint32_t);
 8006b44:	687b      	ldr	r3, [r7, #4]
 8006b46:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8006b48:	1d1a      	adds	r2, r3, #4
 8006b4a:	687b      	ldr	r3, [r7, #4]
 8006b4c:	665a      	str	r2, [r3, #100]	; 0x64
 8006b4e:	e01d      	b.n	8006b8c <HAL_SPI_IRQHandler+0x1ac>
          }
          /* Receive data in 16 Bit mode */
          else if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8006b50:	687b      	ldr	r3, [r7, #4]
 8006b52:	68db      	ldr	r3, [r3, #12]
 8006b54:	2b07      	cmp	r3, #7
 8006b56:	d90b      	bls.n	8006b70 <HAL_SPI_IRQHandler+0x190>
          {
#if defined (__GNUC__)
            *((uint16_t *)hspi->pRxBuffPtr) = *prxdr_16bits;
 8006b58:	687b      	ldr	r3, [r7, #4]
 8006b5a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8006b5c:	68fa      	ldr	r2, [r7, #12]
 8006b5e:	8812      	ldrh	r2, [r2, #0]
 8006b60:	b292      	uxth	r2, r2
 8006b62:	801a      	strh	r2, [r3, #0]
#else
            *((uint16_t *)hspi->pRxBuffPtr) = *((__IO uint16_t *)&hspi->Instance->RXDR);
#endif /* __GNUC__ */
            hspi->pRxBuffPtr += sizeof(uint16_t);
 8006b64:	687b      	ldr	r3, [r7, #4]
 8006b66:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8006b68:	1c9a      	adds	r2, r3, #2
 8006b6a:	687b      	ldr	r3, [r7, #4]
 8006b6c:	665a      	str	r2, [r3, #100]	; 0x64
 8006b6e:	e00d      	b.n	8006b8c <HAL_SPI_IRQHandler+0x1ac>
          }
          /* Receive data in 8 Bit mode */
          else
          {
            *((uint8_t *)hspi->pRxBuffPtr) = *((__IO uint8_t *)&hspi->Instance->RXDR);
 8006b70:	687b      	ldr	r3, [r7, #4]
 8006b72:	681b      	ldr	r3, [r3, #0]
 8006b74:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8006b78:	687b      	ldr	r3, [r7, #4]
 8006b7a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8006b7c:	7812      	ldrb	r2, [r2, #0]
 8006b7e:	b2d2      	uxtb	r2, r2
 8006b80:	701a      	strb	r2, [r3, #0]
            hspi->pRxBuffPtr += sizeof(uint8_t);
 8006b82:	687b      	ldr	r3, [r7, #4]
 8006b84:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8006b86:	1c5a      	adds	r2, r3, #1
 8006b88:	687b      	ldr	r3, [r7, #4]
 8006b8a:	665a      	str	r2, [r3, #100]	; 0x64
          }

          hspi->RxXferCount--;
 8006b8c:	687b      	ldr	r3, [r7, #4]
 8006b8e:	f8b3 306a 	ldrh.w	r3, [r3, #106]	; 0x6a
 8006b92:	b29b      	uxth	r3, r3
 8006b94:	3b01      	subs	r3, #1
 8006b96:	b29a      	uxth	r2, r3
 8006b98:	687b      	ldr	r3, [r7, #4]
 8006b9a:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
        while (hspi->RxXferCount != 0UL)
 8006b9e:	687b      	ldr	r3, [r7, #4]
 8006ba0:	f8b3 306a 	ldrh.w	r3, [r3, #106]	; 0x6a
 8006ba4:	b29b      	uxth	r3, r3
 8006ba6:	2b00      	cmp	r3, #0
 8006ba8:	d1c2      	bne.n	8006b30 <HAL_SPI_IRQHandler+0x150>
        }
      }

      /* Call SPI Standard close procedure */
      SPI_CloseTransfer(hspi);
 8006baa:	6878      	ldr	r0, [r7, #4]
 8006bac:	f000 f926 	bl	8006dfc <SPI_CloseTransfer>

      hspi->State = HAL_SPI_STATE_READY;
 8006bb0:	687b      	ldr	r3, [r7, #4]
 8006bb2:	2201      	movs	r2, #1
 8006bb4:	f883 2081 	strb.w	r2, [r3, #129]	; 0x81
      if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8006bb8:	687b      	ldr	r3, [r7, #4]
 8006bba:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8006bbe:	2b00      	cmp	r3, #0
 8006bc0:	d003      	beq.n	8006bca <HAL_SPI_IRQHandler+0x1ea>
      {
#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1UL)
        hspi->ErrorCallback(hspi);
#else
        HAL_SPI_ErrorCallback(hspi);
 8006bc2:	6878      	ldr	r0, [r7, #4]
 8006bc4:	f000 f8f6 	bl	8006db4 <HAL_SPI_ErrorCallback>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
        return;
 8006bc8:	e0e3      	b.n	8006d92 <HAL_SPI_IRQHandler+0x3b2>
    {
      hspi->TxCpltCallback(hspi);
    }
#else
    /* Call appropriate user callback */
    if (State == HAL_SPI_STATE_BUSY_TX_RX)
 8006bca:	7cfb      	ldrb	r3, [r7, #19]
 8006bcc:	2b05      	cmp	r3, #5
 8006bce:	d103      	bne.n	8006bd8 <HAL_SPI_IRQHandler+0x1f8>
    {
      HAL_SPI_TxRxCpltCallback(hspi);
 8006bd0:	6878      	ldr	r0, [r7, #4]
 8006bd2:	f006 fd21 	bl	800d618 <HAL_SPI_TxRxCpltCallback>
    else
    {
      /* End of the appropriate call */
    }

    return;
 8006bd6:	e0d9      	b.n	8006d8c <HAL_SPI_IRQHandler+0x3ac>
    else if (State == HAL_SPI_STATE_BUSY_RX)
 8006bd8:	7cfb      	ldrb	r3, [r7, #19]
 8006bda:	2b04      	cmp	r3, #4
 8006bdc:	d103      	bne.n	8006be6 <HAL_SPI_IRQHandler+0x206>
      HAL_SPI_RxCpltCallback(hspi);
 8006bde:	6878      	ldr	r0, [r7, #4]
 8006be0:	f000 f8de 	bl	8006da0 <HAL_SPI_RxCpltCallback>
    return;
 8006be4:	e0d2      	b.n	8006d8c <HAL_SPI_IRQHandler+0x3ac>
    else if (State == HAL_SPI_STATE_BUSY_TX)
 8006be6:	7cfb      	ldrb	r3, [r7, #19]
 8006be8:	2b03      	cmp	r3, #3
 8006bea:	f040 80cf 	bne.w	8006d8c <HAL_SPI_IRQHandler+0x3ac>
      HAL_SPI_TxCpltCallback(hspi);
 8006bee:	6878      	ldr	r0, [r7, #4]
 8006bf0:	f006 fcfc 	bl	800d5ec <HAL_SPI_TxCpltCallback>
    return;
 8006bf4:	e0ca      	b.n	8006d8c <HAL_SPI_IRQHandler+0x3ac>
  }

  if (HAL_IS_BIT_SET(itflag, SPI_FLAG_SUSP) && HAL_IS_BIT_SET(itsource, SPI_FLAG_EOT))
 8006bf6:	69fb      	ldr	r3, [r7, #28]
 8006bf8:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8006bfc:	2b00      	cmp	r3, #0
 8006bfe:	d00d      	beq.n	8006c1c <HAL_SPI_IRQHandler+0x23c>
 8006c00:	6a3b      	ldr	r3, [r7, #32]
 8006c02:	f003 0308 	and.w	r3, r3, #8
 8006c06:	2b00      	cmp	r3, #0
 8006c08:	d008      	beq.n	8006c1c <HAL_SPI_IRQHandler+0x23c>
  {
    /* Abort on going, clear SUSP flag to avoid infinite looping */
    __HAL_SPI_CLEAR_SUSPFLAG(hspi);
 8006c0a:	687b      	ldr	r3, [r7, #4]
 8006c0c:	681b      	ldr	r3, [r3, #0]
 8006c0e:	699a      	ldr	r2, [r3, #24]
 8006c10:	687b      	ldr	r3, [r7, #4]
 8006c12:	681b      	ldr	r3, [r3, #0]
 8006c14:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8006c18:	619a      	str	r2, [r3, #24]

    return;
 8006c1a:	e0ba      	b.n	8006d92 <HAL_SPI_IRQHandler+0x3b2>
  }

  /* SPI in Error Treatment --------------------------------------------------*/
  if ((trigger & (SPI_FLAG_MODF | SPI_FLAG_OVR | SPI_FLAG_FRE | SPI_FLAG_UDR)) != 0UL)
 8006c1c:	69bb      	ldr	r3, [r7, #24]
 8006c1e:	f403 7358 	and.w	r3, r3, #864	; 0x360
 8006c22:	2b00      	cmp	r3, #0
 8006c24:	f000 80b5 	beq.w	8006d92 <HAL_SPI_IRQHandler+0x3b2>
  {
    /* SPI Overrun error interrupt occurred ----------------------------------*/
    if ((trigger & SPI_FLAG_OVR) != 0UL)
 8006c28:	69bb      	ldr	r3, [r7, #24]
 8006c2a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8006c2e:	2b00      	cmp	r3, #0
 8006c30:	d00f      	beq.n	8006c52 <HAL_SPI_IRQHandler+0x272>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
 8006c32:	687b      	ldr	r3, [r7, #4]
 8006c34:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8006c38:	f043 0204 	orr.w	r2, r3, #4
 8006c3c:	687b      	ldr	r3, [r7, #4]
 8006c3e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
      __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8006c42:	687b      	ldr	r3, [r7, #4]
 8006c44:	681b      	ldr	r3, [r3, #0]
 8006c46:	699a      	ldr	r2, [r3, #24]
 8006c48:	687b      	ldr	r3, [r7, #4]
 8006c4a:	681b      	ldr	r3, [r3, #0]
 8006c4c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8006c50:	619a      	str	r2, [r3, #24]
    }

    /* SPI Mode Fault error interrupt occurred -------------------------------*/
    if ((trigger & SPI_FLAG_MODF) != 0UL)
 8006c52:	69bb      	ldr	r3, [r7, #24]
 8006c54:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8006c58:	2b00      	cmp	r3, #0
 8006c5a:	d00f      	beq.n	8006c7c <HAL_SPI_IRQHandler+0x29c>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
 8006c5c:	687b      	ldr	r3, [r7, #4]
 8006c5e:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8006c62:	f043 0201 	orr.w	r2, r3, #1
 8006c66:	687b      	ldr	r3, [r7, #4]
 8006c68:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
      __HAL_SPI_CLEAR_MODFFLAG(hspi);
 8006c6c:	687b      	ldr	r3, [r7, #4]
 8006c6e:	681b      	ldr	r3, [r3, #0]
 8006c70:	699a      	ldr	r2, [r3, #24]
 8006c72:	687b      	ldr	r3, [r7, #4]
 8006c74:	681b      	ldr	r3, [r3, #0]
 8006c76:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8006c7a:	619a      	str	r2, [r3, #24]
    }

    /* SPI Frame error interrupt occurred ------------------------------------*/
    if ((trigger & SPI_FLAG_FRE) != 0UL)
 8006c7c:	69bb      	ldr	r3, [r7, #24]
 8006c7e:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8006c82:	2b00      	cmp	r3, #0
 8006c84:	d00f      	beq.n	8006ca6 <HAL_SPI_IRQHandler+0x2c6>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FRE);
 8006c86:	687b      	ldr	r3, [r7, #4]
 8006c88:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8006c8c:	f043 0208 	orr.w	r2, r3, #8
 8006c90:	687b      	ldr	r3, [r7, #4]
 8006c92:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
      __HAL_SPI_CLEAR_FREFLAG(hspi);
 8006c96:	687b      	ldr	r3, [r7, #4]
 8006c98:	681b      	ldr	r3, [r3, #0]
 8006c9a:	699a      	ldr	r2, [r3, #24]
 8006c9c:	687b      	ldr	r3, [r7, #4]
 8006c9e:	681b      	ldr	r3, [r3, #0]
 8006ca0:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8006ca4:	619a      	str	r2, [r3, #24]
    }

    /* SPI Underrun error interrupt occurred ------------------------------------*/
    if ((trigger & SPI_FLAG_UDR) != 0UL)
 8006ca6:	69bb      	ldr	r3, [r7, #24]
 8006ca8:	f003 0320 	and.w	r3, r3, #32
 8006cac:	2b00      	cmp	r3, #0
 8006cae:	d00f      	beq.n	8006cd0 <HAL_SPI_IRQHandler+0x2f0>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_UDR);
 8006cb0:	687b      	ldr	r3, [r7, #4]
 8006cb2:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8006cb6:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 8006cba:	687b      	ldr	r3, [r7, #4]
 8006cbc:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
      __HAL_SPI_CLEAR_UDRFLAG(hspi);
 8006cc0:	687b      	ldr	r3, [r7, #4]
 8006cc2:	681b      	ldr	r3, [r3, #0]
 8006cc4:	699a      	ldr	r2, [r3, #24]
 8006cc6:	687b      	ldr	r3, [r7, #4]
 8006cc8:	681b      	ldr	r3, [r3, #0]
 8006cca:	f042 0220 	orr.w	r2, r2, #32
 8006cce:	619a      	str	r2, [r3, #24]
    }

    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8006cd0:	687b      	ldr	r3, [r7, #4]
 8006cd2:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8006cd6:	2b00      	cmp	r3, #0
 8006cd8:	d05a      	beq.n	8006d90 <HAL_SPI_IRQHandler+0x3b0>
    {
      /* Disable SPI peripheral */
      __HAL_SPI_DISABLE(hspi);
 8006cda:	687b      	ldr	r3, [r7, #4]
 8006cdc:	681b      	ldr	r3, [r3, #0]
 8006cde:	681a      	ldr	r2, [r3, #0]
 8006ce0:	687b      	ldr	r3, [r7, #4]
 8006ce2:	681b      	ldr	r3, [r3, #0]
 8006ce4:	f022 0201 	bic.w	r2, r2, #1
 8006ce8:	601a      	str	r2, [r3, #0]

      /* Disable all interrupts */
      __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_EOT | SPI_IT_RXP | SPI_IT_TXP | SPI_IT_MODF |
 8006cea:	687b      	ldr	r3, [r7, #4]
 8006cec:	681b      	ldr	r3, [r3, #0]
 8006cee:	6919      	ldr	r1, [r3, #16]
 8006cf0:	687b      	ldr	r3, [r7, #4]
 8006cf2:	681a      	ldr	r2, [r3, #0]
 8006cf4:	4b28      	ldr	r3, [pc, #160]	; (8006d98 <HAL_SPI_IRQHandler+0x3b8>)
 8006cf6:	400b      	ands	r3, r1
 8006cf8:	6113      	str	r3, [r2, #16]
                                  SPI_IT_OVR | SPI_IT_FRE | SPI_IT_UDR));

      /* Disable the SPI DMA requests if enabled */
      if (HAL_IS_BIT_SET(cfg1, SPI_CFG1_TXDMAEN | SPI_CFG1_RXDMAEN))
 8006cfa:	697b      	ldr	r3, [r7, #20]
 8006cfc:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 8006d00:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
 8006d04:	d138      	bne.n	8006d78 <HAL_SPI_IRQHandler+0x398>
      {
        /* Disable the SPI DMA requests */
        CLEAR_BIT(hspi->Instance->CFG1, SPI_CFG1_TXDMAEN | SPI_CFG1_RXDMAEN);
 8006d06:	687b      	ldr	r3, [r7, #4]
 8006d08:	681b      	ldr	r3, [r3, #0]
 8006d0a:	689a      	ldr	r2, [r3, #8]
 8006d0c:	687b      	ldr	r3, [r7, #4]
 8006d0e:	681b      	ldr	r3, [r3, #0]
 8006d10:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 8006d14:	609a      	str	r2, [r3, #8]

        /* Abort the SPI DMA Rx channel */
        if (hspi->hdmarx != NULL)
 8006d16:	687b      	ldr	r3, [r7, #4]
 8006d18:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8006d1a:	2b00      	cmp	r3, #0
 8006d1c:	d013      	beq.n	8006d46 <HAL_SPI_IRQHandler+0x366>
        {
          /* Set the SPI DMA Abort callback :
          will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */
          hspi->hdmarx->XferAbortCallback = SPI_DMAAbortOnError;
 8006d1e:	687b      	ldr	r3, [r7, #4]
 8006d20:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8006d22:	4a1e      	ldr	r2, [pc, #120]	; (8006d9c <HAL_SPI_IRQHandler+0x3bc>)
 8006d24:	651a      	str	r2, [r3, #80]	; 0x50
          if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmarx))
 8006d26:	687b      	ldr	r3, [r7, #4]
 8006d28:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8006d2a:	4618      	mov	r0, r3
 8006d2c:	f7fb f8e6 	bl	8001efc <HAL_DMA_Abort_IT>
 8006d30:	4603      	mov	r3, r0
 8006d32:	2b00      	cmp	r3, #0
 8006d34:	d007      	beq.n	8006d46 <HAL_SPI_IRQHandler+0x366>
          {
            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
 8006d36:	687b      	ldr	r3, [r7, #4]
 8006d38:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8006d3c:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 8006d40:	687b      	ldr	r3, [r7, #4]
 8006d42:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
          }
        }
        /* Abort the SPI DMA Tx channel */
        if (hspi->hdmatx != NULL)
 8006d46:	687b      	ldr	r3, [r7, #4]
 8006d48:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8006d4a:	2b00      	cmp	r3, #0
 8006d4c:	d020      	beq.n	8006d90 <HAL_SPI_IRQHandler+0x3b0>
        {
          /* Set the SPI DMA Abort callback :
          will lead to call HAL_SPI_ErrorCallback() at end of DMA abort procedure */
          hspi->hdmatx->XferAbortCallback = SPI_DMAAbortOnError;
 8006d4e:	687b      	ldr	r3, [r7, #4]
 8006d50:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8006d52:	4a12      	ldr	r2, [pc, #72]	; (8006d9c <HAL_SPI_IRQHandler+0x3bc>)
 8006d54:	651a      	str	r2, [r3, #80]	; 0x50
          if (HAL_OK != HAL_DMA_Abort_IT(hspi->hdmatx))
 8006d56:	687b      	ldr	r3, [r7, #4]
 8006d58:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8006d5a:	4618      	mov	r0, r3
 8006d5c:	f7fb f8ce 	bl	8001efc <HAL_DMA_Abort_IT>
 8006d60:	4603      	mov	r3, r0
 8006d62:	2b00      	cmp	r3, #0
 8006d64:	d014      	beq.n	8006d90 <HAL_SPI_IRQHandler+0x3b0>
          {
            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_ABORT);
 8006d66:	687b      	ldr	r3, [r7, #4]
 8006d68:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8006d6c:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 8006d70:	687b      	ldr	r3, [r7, #4]
 8006d72:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
#else
        HAL_SPI_ErrorCallback(hspi);
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
      }
    }
    return;
 8006d76:	e00b      	b.n	8006d90 <HAL_SPI_IRQHandler+0x3b0>
        hspi->State = HAL_SPI_STATE_READY;
 8006d78:	687b      	ldr	r3, [r7, #4]
 8006d7a:	2201      	movs	r2, #1
 8006d7c:	f883 2081 	strb.w	r2, [r3, #129]	; 0x81
        HAL_SPI_ErrorCallback(hspi);
 8006d80:	6878      	ldr	r0, [r7, #4]
 8006d82:	f000 f817 	bl	8006db4 <HAL_SPI_ErrorCallback>
    return;
 8006d86:	e003      	b.n	8006d90 <HAL_SPI_IRQHandler+0x3b0>
    return;
 8006d88:	bf00      	nop
 8006d8a:	e002      	b.n	8006d92 <HAL_SPI_IRQHandler+0x3b2>
    return;
 8006d8c:	bf00      	nop
 8006d8e:	e000      	b.n	8006d92 <HAL_SPI_IRQHandler+0x3b2>
    return;
 8006d90:	bf00      	nop
  }
}
 8006d92:	3728      	adds	r7, #40	; 0x28
 8006d94:	46bd      	mov	sp, r7
 8006d96:	bd80      	pop	{r7, pc}
 8006d98:	fffffc94 	.word	0xfffffc94
 8006d9c:	08006dc9 	.word	0x08006dc9

08006da0 <HAL_SPI_RxCpltCallback>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_RxCpltCallback(SPI_HandleTypeDef *hspi)
{
 8006da0:	b480      	push	{r7}
 8006da2:	b083      	sub	sp, #12
 8006da4:	af00      	add	r7, sp, #0
 8006da6:	6078      	str	r0, [r7, #4]
  UNUSED(hspi);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SPI_RxCpltCallback should be implemented in the user file
   */
}
 8006da8:	bf00      	nop
 8006daa:	370c      	adds	r7, #12
 8006dac:	46bd      	mov	sp, r7
 8006dae:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006db2:	4770      	bx	lr

08006db4 <HAL_SPI_ErrorCallback>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval None
  */
__weak void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
{
 8006db4:	b480      	push	{r7}
 8006db6:	b083      	sub	sp, #12
 8006db8:	af00      	add	r7, sp, #0
 8006dba:	6078      	str	r0, [r7, #4]
            the HAL_SPI_ErrorCallback should be implemented in the user file
   */
  /* NOTE : The ErrorCode parameter in the hspi handle is updated by the SPI processes
            and user can use HAL_SPI_GetError() API to check the latest error occurred
   */
}
 8006dbc:	bf00      	nop
 8006dbe:	370c      	adds	r7, #12
 8006dc0:	46bd      	mov	sp, r7
 8006dc2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006dc6:	4770      	bx	lr

08006dc8 <SPI_DMAAbortOnError>:
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */
static void SPI_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 8006dc8:	b580      	push	{r7, lr}
 8006dca:	b084      	sub	sp, #16
 8006dcc:	af00      	add	r7, sp, #0
 8006dce:	6078      	str	r0, [r7, #4]
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8006dd0:	687b      	ldr	r3, [r7, #4]
 8006dd2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8006dd4:	60fb      	str	r3, [r7, #12]
  hspi->RxXferCount = (uint16_t) 0UL;
 8006dd6:	68fb      	ldr	r3, [r7, #12]
 8006dd8:	2200      	movs	r2, #0
 8006dda:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
  hspi->TxXferCount = (uint16_t) 0UL;
 8006dde:	68fb      	ldr	r3, [r7, #12]
 8006de0:	2200      	movs	r2, #0
 8006de2:	f8a3 2062 	strh.w	r2, [r3, #98]	; 0x62

  /* Restore hspi->State to Ready */
  hspi->State = HAL_SPI_STATE_READY;
 8006de6:	68fb      	ldr	r3, [r7, #12]
 8006de8:	2201      	movs	r2, #1
 8006dea:	f883 2081 	strb.w	r2, [r3, #129]	; 0x81

#if (USE_HAL_SPI_REGISTER_CALLBACKS == 1UL)
  hspi->ErrorCallback(hspi);
#else
  HAL_SPI_ErrorCallback(hspi);
 8006dee:	68f8      	ldr	r0, [r7, #12]
 8006df0:	f7ff ffe0 	bl	8006db4 <HAL_SPI_ErrorCallback>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
}
 8006df4:	bf00      	nop
 8006df6:	3710      	adds	r7, #16
 8006df8:	46bd      	mov	sp, r7
 8006dfa:	bd80      	pop	{r7, pc}

08006dfc <SPI_CloseTransfer>:
  *               the configuration information for SPI module.
  * @retval HAL_ERROR: if any error detected
  *         HAL_OK: if nothing detected
  */
static void SPI_CloseTransfer(SPI_HandleTypeDef *hspi)
{
 8006dfc:	b480      	push	{r7}
 8006dfe:	b085      	sub	sp, #20
 8006e00:	af00      	add	r7, sp, #0
 8006e02:	6078      	str	r0, [r7, #4]
  uint32_t itflag = hspi->Instance->SR;
 8006e04:	687b      	ldr	r3, [r7, #4]
 8006e06:	681b      	ldr	r3, [r3, #0]
 8006e08:	695b      	ldr	r3, [r3, #20]
 8006e0a:	60fb      	str	r3, [r7, #12]

  __HAL_SPI_CLEAR_EOTFLAG(hspi);
 8006e0c:	687b      	ldr	r3, [r7, #4]
 8006e0e:	681b      	ldr	r3, [r3, #0]
 8006e10:	699a      	ldr	r2, [r3, #24]
 8006e12:	687b      	ldr	r3, [r7, #4]
 8006e14:	681b      	ldr	r3, [r3, #0]
 8006e16:	f042 0208 	orr.w	r2, r2, #8
 8006e1a:	619a      	str	r2, [r3, #24]
  __HAL_SPI_CLEAR_TXTFFLAG(hspi);
 8006e1c:	687b      	ldr	r3, [r7, #4]
 8006e1e:	681b      	ldr	r3, [r3, #0]
 8006e20:	699a      	ldr	r2, [r3, #24]
 8006e22:	687b      	ldr	r3, [r7, #4]
 8006e24:	681b      	ldr	r3, [r3, #0]
 8006e26:	f042 0210 	orr.w	r2, r2, #16
 8006e2a:	619a      	str	r2, [r3, #24]

  /* Disable SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8006e2c:	687b      	ldr	r3, [r7, #4]
 8006e2e:	681b      	ldr	r3, [r3, #0]
 8006e30:	681a      	ldr	r2, [r3, #0]
 8006e32:	687b      	ldr	r3, [r7, #4]
 8006e34:	681b      	ldr	r3, [r3, #0]
 8006e36:	f022 0201 	bic.w	r2, r2, #1
 8006e3a:	601a      	str	r2, [r3, #0]

  /* Disable ITs */
  __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_EOT | SPI_IT_TXP | SPI_IT_RXP | SPI_IT_DXP | SPI_IT_UDR | SPI_IT_OVR | \
 8006e3c:	687b      	ldr	r3, [r7, #4]
 8006e3e:	681b      	ldr	r3, [r3, #0]
 8006e40:	6919      	ldr	r1, [r3, #16]
 8006e42:	687b      	ldr	r3, [r7, #4]
 8006e44:	681a      	ldr	r2, [r3, #0]
 8006e46:	4b3c      	ldr	r3, [pc, #240]	; (8006f38 <SPI_CloseTransfer+0x13c>)
 8006e48:	400b      	ands	r3, r1
 8006e4a:	6113      	str	r3, [r2, #16]
                              SPI_IT_FRE | SPI_IT_MODF));

  /* Disable Tx DMA Request */
  CLEAR_BIT(hspi->Instance->CFG1, SPI_CFG1_TXDMAEN | SPI_CFG1_RXDMAEN);
 8006e4c:	687b      	ldr	r3, [r7, #4]
 8006e4e:	681b      	ldr	r3, [r3, #0]
 8006e50:	689a      	ldr	r2, [r3, #8]
 8006e52:	687b      	ldr	r3, [r7, #4]
 8006e54:	681b      	ldr	r3, [r3, #0]
 8006e56:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 8006e5a:	609a      	str	r2, [r3, #8]

  /* Report UnderRun error for non RX Only communication */
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 8006e5c:	687b      	ldr	r3, [r7, #4]
 8006e5e:	f893 3081 	ldrb.w	r3, [r3, #129]	; 0x81
 8006e62:	b2db      	uxtb	r3, r3
 8006e64:	2b04      	cmp	r3, #4
 8006e66:	d014      	beq.n	8006e92 <SPI_CloseTransfer+0x96>
  {
    if ((itflag & SPI_FLAG_UDR) != 0UL)
 8006e68:	68fb      	ldr	r3, [r7, #12]
 8006e6a:	f003 0320 	and.w	r3, r3, #32
 8006e6e:	2b00      	cmp	r3, #0
 8006e70:	d00f      	beq.n	8006e92 <SPI_CloseTransfer+0x96>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_UDR);
 8006e72:	687b      	ldr	r3, [r7, #4]
 8006e74:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8006e78:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 8006e7c:	687b      	ldr	r3, [r7, #4]
 8006e7e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
      __HAL_SPI_CLEAR_UDRFLAG(hspi);
 8006e82:	687b      	ldr	r3, [r7, #4]
 8006e84:	681b      	ldr	r3, [r3, #0]
 8006e86:	699a      	ldr	r2, [r3, #24]
 8006e88:	687b      	ldr	r3, [r7, #4]
 8006e8a:	681b      	ldr	r3, [r3, #0]
 8006e8c:	f042 0220 	orr.w	r2, r2, #32
 8006e90:	619a      	str	r2, [r3, #24]
    }
  }

  /* Report OverRun error for non TX Only communication */
  if (hspi->State != HAL_SPI_STATE_BUSY_TX)
 8006e92:	687b      	ldr	r3, [r7, #4]
 8006e94:	f893 3081 	ldrb.w	r3, [r3, #129]	; 0x81
 8006e98:	b2db      	uxtb	r3, r3
 8006e9a:	2b03      	cmp	r3, #3
 8006e9c:	d014      	beq.n	8006ec8 <SPI_CloseTransfer+0xcc>
  {
    if ((itflag & SPI_FLAG_OVR) != 0UL)
 8006e9e:	68fb      	ldr	r3, [r7, #12]
 8006ea0:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8006ea4:	2b00      	cmp	r3, #0
 8006ea6:	d00f      	beq.n	8006ec8 <SPI_CloseTransfer+0xcc>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
 8006ea8:	687b      	ldr	r3, [r7, #4]
 8006eaa:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8006eae:	f043 0204 	orr.w	r2, r3, #4
 8006eb2:	687b      	ldr	r3, [r7, #4]
 8006eb4:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
      __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8006eb8:	687b      	ldr	r3, [r7, #4]
 8006eba:	681b      	ldr	r3, [r3, #0]
 8006ebc:	699a      	ldr	r2, [r3, #24]
 8006ebe:	687b      	ldr	r3, [r7, #4]
 8006ec0:	681b      	ldr	r3, [r3, #0]
 8006ec2:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8006ec6:	619a      	str	r2, [r3, #24]
    }
#endif /* USE_SPI_CRC */
  }

  /* SPI Mode Fault error interrupt occurred -------------------------------*/
  if ((itflag & SPI_FLAG_MODF) != 0UL)
 8006ec8:	68fb      	ldr	r3, [r7, #12]
 8006eca:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8006ece:	2b00      	cmp	r3, #0
 8006ed0:	d00f      	beq.n	8006ef2 <SPI_CloseTransfer+0xf6>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
 8006ed2:	687b      	ldr	r3, [r7, #4]
 8006ed4:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8006ed8:	f043 0201 	orr.w	r2, r3, #1
 8006edc:	687b      	ldr	r3, [r7, #4]
 8006ede:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    __HAL_SPI_CLEAR_MODFFLAG(hspi);
 8006ee2:	687b      	ldr	r3, [r7, #4]
 8006ee4:	681b      	ldr	r3, [r3, #0]
 8006ee6:	699a      	ldr	r2, [r3, #24]
 8006ee8:	687b      	ldr	r3, [r7, #4]
 8006eea:	681b      	ldr	r3, [r3, #0]
 8006eec:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8006ef0:	619a      	str	r2, [r3, #24]
  }

  /* SPI Frame error interrupt occurred ------------------------------------*/
  if ((itflag & SPI_FLAG_FRE) != 0UL)
 8006ef2:	68fb      	ldr	r3, [r7, #12]
 8006ef4:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8006ef8:	2b00      	cmp	r3, #0
 8006efa:	d00f      	beq.n	8006f1c <SPI_CloseTransfer+0x120>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FRE);
 8006efc:	687b      	ldr	r3, [r7, #4]
 8006efe:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8006f02:	f043 0208 	orr.w	r2, r3, #8
 8006f06:	687b      	ldr	r3, [r7, #4]
 8006f08:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    __HAL_SPI_CLEAR_FREFLAG(hspi);
 8006f0c:	687b      	ldr	r3, [r7, #4]
 8006f0e:	681b      	ldr	r3, [r3, #0]
 8006f10:	699a      	ldr	r2, [r3, #24]
 8006f12:	687b      	ldr	r3, [r7, #4]
 8006f14:	681b      	ldr	r3, [r3, #0]
 8006f16:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8006f1a:	619a      	str	r2, [r3, #24]
  }

  hspi->TxXferCount = (uint16_t)0UL;
 8006f1c:	687b      	ldr	r3, [r7, #4]
 8006f1e:	2200      	movs	r2, #0
 8006f20:	f8a3 2062 	strh.w	r2, [r3, #98]	; 0x62
  hspi->RxXferCount = (uint16_t)0UL;
 8006f24:	687b      	ldr	r3, [r7, #4]
 8006f26:	2200      	movs	r2, #0
 8006f28:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
}
 8006f2c:	bf00      	nop
 8006f2e:	3714      	adds	r7, #20
 8006f30:	46bd      	mov	sp, r7
 8006f32:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006f36:	4770      	bx	lr
 8006f38:	fffffc90 	.word	0xfffffc90

08006f3c <SPI_GetPacketSize>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval Packet size occupied in the fifo
  */
static uint32_t SPI_GetPacketSize(SPI_HandleTypeDef *hspi)
{
 8006f3c:	b480      	push	{r7}
 8006f3e:	b085      	sub	sp, #20
 8006f40:	af00      	add	r7, sp, #0
 8006f42:	6078      	str	r0, [r7, #4]
  uint32_t fifo_threashold = (hspi->Init.FifoThreshold >> SPI_CFG1_FTHLV_Pos) + 1UL;
 8006f44:	687b      	ldr	r3, [r7, #4]
 8006f46:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8006f48:	095b      	lsrs	r3, r3, #5
 8006f4a:	3301      	adds	r3, #1
 8006f4c:	60fb      	str	r3, [r7, #12]
  uint32_t data_size       = (hspi->Init.DataSize      >> SPI_CFG1_DSIZE_Pos) + 1UL;
 8006f4e:	687b      	ldr	r3, [r7, #4]
 8006f50:	68db      	ldr	r3, [r3, #12]
 8006f52:	3301      	adds	r3, #1
 8006f54:	60bb      	str	r3, [r7, #8]

  /* Convert data size to Byte */
  data_size = (data_size + 7UL) / 8UL;
 8006f56:	68bb      	ldr	r3, [r7, #8]
 8006f58:	3307      	adds	r3, #7
 8006f5a:	08db      	lsrs	r3, r3, #3
 8006f5c:	60bb      	str	r3, [r7, #8]

  return data_size * fifo_threashold;
 8006f5e:	68bb      	ldr	r3, [r7, #8]
 8006f60:	68fa      	ldr	r2, [r7, #12]
 8006f62:	fb02 f303 	mul.w	r3, r2, r3
}
 8006f66:	4618      	mov	r0, r3
 8006f68:	3714      	adds	r7, #20
 8006f6a:	46bd      	mov	sp, r7
 8006f6c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006f70:	4770      	bx	lr

08006f72 <HAL_TIM_Base_Init>:
  *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
 8006f72:	b580      	push	{r7, lr}
 8006f74:	b082      	sub	sp, #8
 8006f76:	af00      	add	r7, sp, #0
 8006f78:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 8006f7a:	687b      	ldr	r3, [r7, #4]
 8006f7c:	2b00      	cmp	r3, #0
 8006f7e:	d101      	bne.n	8006f84 <HAL_TIM_Base_Init+0x12>
  {
    return HAL_ERROR;
 8006f80:	2301      	movs	r3, #1
 8006f82:	e049      	b.n	8007018 <HAL_TIM_Base_Init+0xa6>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 8006f84:	687b      	ldr	r3, [r7, #4]
 8006f86:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8006f8a:	b2db      	uxtb	r3, r3
 8006f8c:	2b00      	cmp	r3, #0
 8006f8e:	d106      	bne.n	8006f9e <HAL_TIM_Base_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 8006f90:	687b      	ldr	r3, [r7, #4]
 8006f92:	2200      	movs	r2, #0
 8006f94:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->Base_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_TIM_Base_MspInit(htim);
 8006f98:	6878      	ldr	r0, [r7, #4]
 8006f9a:	f00a fb83 	bl	80116a4 <HAL_TIM_Base_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 8006f9e:	687b      	ldr	r3, [r7, #4]
 8006fa0:	2202      	movs	r2, #2
 8006fa2:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8006fa6:	687b      	ldr	r3, [r7, #4]
 8006fa8:	681a      	ldr	r2, [r3, #0]
 8006faa:	687b      	ldr	r3, [r7, #4]
 8006fac:	3304      	adds	r3, #4
 8006fae:	4619      	mov	r1, r3
 8006fb0:	4610      	mov	r0, r2
 8006fb2:	f000 fd67 	bl	8007a84 <TIM_Base_SetConfig>

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8006fb6:	687b      	ldr	r3, [r7, #4]
 8006fb8:	2201      	movs	r2, #1
 8006fba:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8006fbe:	687b      	ldr	r3, [r7, #4]
 8006fc0:	2201      	movs	r2, #1
 8006fc2:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
 8006fc6:	687b      	ldr	r3, [r7, #4]
 8006fc8:	2201      	movs	r2, #1
 8006fca:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
 8006fce:	687b      	ldr	r3, [r7, #4]
 8006fd0:	2201      	movs	r2, #1
 8006fd2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
 8006fd6:	687b      	ldr	r3, [r7, #4]
 8006fd8:	2201      	movs	r2, #1
 8006fda:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
 8006fde:	687b      	ldr	r3, [r7, #4]
 8006fe0:	2201      	movs	r2, #1
 8006fe2:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
 8006fe6:	687b      	ldr	r3, [r7, #4]
 8006fe8:	2201      	movs	r2, #1
 8006fea:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8006fee:	687b      	ldr	r3, [r7, #4]
 8006ff0:	2201      	movs	r2, #1
 8006ff2:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 8006ff6:	687b      	ldr	r3, [r7, #4]
 8006ff8:	2201      	movs	r2, #1
 8006ffa:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 8006ffe:	687b      	ldr	r3, [r7, #4]
 8007000:	2201      	movs	r2, #1
 8007002:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
 8007006:	687b      	ldr	r3, [r7, #4]
 8007008:	2201      	movs	r2, #1
 800700a:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 800700e:	687b      	ldr	r3, [r7, #4]
 8007010:	2201      	movs	r2, #1
 8007012:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
 8007016:	2300      	movs	r3, #0
}
 8007018:	4618      	mov	r0, r3
 800701a:	3708      	adds	r7, #8
 800701c:	46bd      	mov	sp, r7
 800701e:	bd80      	pop	{r7, pc}

08007020 <HAL_TIM_Base_Start_IT>:
  * @brief  Starts the TIM Base generation in interrupt mode.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
{
 8007020:	b480      	push	{r7}
 8007022:	b085      	sub	sp, #20
 8007024:	af00      	add	r7, sp, #0
 8007026:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Check the TIM state */
  if (htim->State != HAL_TIM_STATE_READY)
 8007028:	687b      	ldr	r3, [r7, #4]
 800702a:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 800702e:	b2db      	uxtb	r3, r3
 8007030:	2b01      	cmp	r3, #1
 8007032:	d001      	beq.n	8007038 <HAL_TIM_Base_Start_IT+0x18>
  {
    return HAL_ERROR;
 8007034:	2301      	movs	r3, #1
 8007036:	e054      	b.n	80070e2 <HAL_TIM_Base_Start_IT+0xc2>
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 8007038:	687b      	ldr	r3, [r7, #4]
 800703a:	2202      	movs	r2, #2
 800703c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8007040:	687b      	ldr	r3, [r7, #4]
 8007042:	681b      	ldr	r3, [r3, #0]
 8007044:	68da      	ldr	r2, [r3, #12]
 8007046:	687b      	ldr	r3, [r7, #4]
 8007048:	681b      	ldr	r3, [r3, #0]
 800704a:	f042 0201 	orr.w	r2, r2, #1
 800704e:	60da      	str	r2, [r3, #12]

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8007050:	687b      	ldr	r3, [r7, #4]
 8007052:	681b      	ldr	r3, [r3, #0]
 8007054:	4a26      	ldr	r2, [pc, #152]	; (80070f0 <HAL_TIM_Base_Start_IT+0xd0>)
 8007056:	4293      	cmp	r3, r2
 8007058:	d022      	beq.n	80070a0 <HAL_TIM_Base_Start_IT+0x80>
 800705a:	687b      	ldr	r3, [r7, #4]
 800705c:	681b      	ldr	r3, [r3, #0]
 800705e:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8007062:	d01d      	beq.n	80070a0 <HAL_TIM_Base_Start_IT+0x80>
 8007064:	687b      	ldr	r3, [r7, #4]
 8007066:	681b      	ldr	r3, [r3, #0]
 8007068:	4a22      	ldr	r2, [pc, #136]	; (80070f4 <HAL_TIM_Base_Start_IT+0xd4>)
 800706a:	4293      	cmp	r3, r2
 800706c:	d018      	beq.n	80070a0 <HAL_TIM_Base_Start_IT+0x80>
 800706e:	687b      	ldr	r3, [r7, #4]
 8007070:	681b      	ldr	r3, [r3, #0]
 8007072:	4a21      	ldr	r2, [pc, #132]	; (80070f8 <HAL_TIM_Base_Start_IT+0xd8>)
 8007074:	4293      	cmp	r3, r2
 8007076:	d013      	beq.n	80070a0 <HAL_TIM_Base_Start_IT+0x80>
 8007078:	687b      	ldr	r3, [r7, #4]
 800707a:	681b      	ldr	r3, [r3, #0]
 800707c:	4a1f      	ldr	r2, [pc, #124]	; (80070fc <HAL_TIM_Base_Start_IT+0xdc>)
 800707e:	4293      	cmp	r3, r2
 8007080:	d00e      	beq.n	80070a0 <HAL_TIM_Base_Start_IT+0x80>
 8007082:	687b      	ldr	r3, [r7, #4]
 8007084:	681b      	ldr	r3, [r3, #0]
 8007086:	4a1e      	ldr	r2, [pc, #120]	; (8007100 <HAL_TIM_Base_Start_IT+0xe0>)
 8007088:	4293      	cmp	r3, r2
 800708a:	d009      	beq.n	80070a0 <HAL_TIM_Base_Start_IT+0x80>
 800708c:	687b      	ldr	r3, [r7, #4]
 800708e:	681b      	ldr	r3, [r3, #0]
 8007090:	4a1c      	ldr	r2, [pc, #112]	; (8007104 <HAL_TIM_Base_Start_IT+0xe4>)
 8007092:	4293      	cmp	r3, r2
 8007094:	d004      	beq.n	80070a0 <HAL_TIM_Base_Start_IT+0x80>
 8007096:	687b      	ldr	r3, [r7, #4]
 8007098:	681b      	ldr	r3, [r3, #0]
 800709a:	4a1b      	ldr	r2, [pc, #108]	; (8007108 <HAL_TIM_Base_Start_IT+0xe8>)
 800709c:	4293      	cmp	r3, r2
 800709e:	d115      	bne.n	80070cc <HAL_TIM_Base_Start_IT+0xac>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 80070a0:	687b      	ldr	r3, [r7, #4]
 80070a2:	681b      	ldr	r3, [r3, #0]
 80070a4:	689a      	ldr	r2, [r3, #8]
 80070a6:	4b19      	ldr	r3, [pc, #100]	; (800710c <HAL_TIM_Base_Start_IT+0xec>)
 80070a8:	4013      	ands	r3, r2
 80070aa:	60fb      	str	r3, [r7, #12]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 80070ac:	68fb      	ldr	r3, [r7, #12]
 80070ae:	2b06      	cmp	r3, #6
 80070b0:	d015      	beq.n	80070de <HAL_TIM_Base_Start_IT+0xbe>
 80070b2:	68fb      	ldr	r3, [r7, #12]
 80070b4:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80070b8:	d011      	beq.n	80070de <HAL_TIM_Base_Start_IT+0xbe>
    {
      __HAL_TIM_ENABLE(htim);
 80070ba:	687b      	ldr	r3, [r7, #4]
 80070bc:	681b      	ldr	r3, [r3, #0]
 80070be:	681a      	ldr	r2, [r3, #0]
 80070c0:	687b      	ldr	r3, [r7, #4]
 80070c2:	681b      	ldr	r3, [r3, #0]
 80070c4:	f042 0201 	orr.w	r2, r2, #1
 80070c8:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 80070ca:	e008      	b.n	80070de <HAL_TIM_Base_Start_IT+0xbe>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
 80070cc:	687b      	ldr	r3, [r7, #4]
 80070ce:	681b      	ldr	r3, [r3, #0]
 80070d0:	681a      	ldr	r2, [r3, #0]
 80070d2:	687b      	ldr	r3, [r7, #4]
 80070d4:	681b      	ldr	r3, [r3, #0]
 80070d6:	f042 0201 	orr.w	r2, r2, #1
 80070da:	601a      	str	r2, [r3, #0]
 80070dc:	e000      	b.n	80070e0 <HAL_TIM_Base_Start_IT+0xc0>
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 80070de:	bf00      	nop
  }

  /* Return function status */
  return HAL_OK;
 80070e0:	2300      	movs	r3, #0
}
 80070e2:	4618      	mov	r0, r3
 80070e4:	3714      	adds	r7, #20
 80070e6:	46bd      	mov	sp, r7
 80070e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80070ec:	4770      	bx	lr
 80070ee:	bf00      	nop
 80070f0:	40010000 	.word	0x40010000
 80070f4:	40000400 	.word	0x40000400
 80070f8:	40000800 	.word	0x40000800
 80070fc:	40000c00 	.word	0x40000c00
 8007100:	40010400 	.word	0x40010400
 8007104:	40001800 	.word	0x40001800
 8007108:	40014000 	.word	0x40014000
 800710c:	00010007 	.word	0x00010007

08007110 <HAL_TIM_PWM_Init>:
  *         Ex: call @ref HAL_TIM_PWM_DeInit() before HAL_TIM_PWM_Init()
  * @param  htim TIM PWM handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
{
 8007110:	b580      	push	{r7, lr}
 8007112:	b082      	sub	sp, #8
 8007114:	af00      	add	r7, sp, #0
 8007116:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 8007118:	687b      	ldr	r3, [r7, #4]
 800711a:	2b00      	cmp	r3, #0
 800711c:	d101      	bne.n	8007122 <HAL_TIM_PWM_Init+0x12>
  {
    return HAL_ERROR;
 800711e:	2301      	movs	r3, #1
 8007120:	e049      	b.n	80071b6 <HAL_TIM_PWM_Init+0xa6>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 8007122:	687b      	ldr	r3, [r7, #4]
 8007124:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8007128:	b2db      	uxtb	r3, r3
 800712a:	2b00      	cmp	r3, #0
 800712c:	d106      	bne.n	800713c <HAL_TIM_PWM_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 800712e:	687b      	ldr	r3, [r7, #4]
 8007130:	2200      	movs	r2, #0
 8007132:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->PWM_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_PWM_MspInit(htim);
 8007136:	6878      	ldr	r0, [r7, #4]
 8007138:	f00a faee 	bl	8011718 <HAL_TIM_PWM_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 800713c:	687b      	ldr	r3, [r7, #4]
 800713e:	2202      	movs	r2, #2
 8007140:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Init the base time for the PWM */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8007144:	687b      	ldr	r3, [r7, #4]
 8007146:	681a      	ldr	r2, [r3, #0]
 8007148:	687b      	ldr	r3, [r7, #4]
 800714a:	3304      	adds	r3, #4
 800714c:	4619      	mov	r1, r3
 800714e:	4610      	mov	r0, r2
 8007150:	f000 fc98 	bl	8007a84 <TIM_Base_SetConfig>

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8007154:	687b      	ldr	r3, [r7, #4]
 8007156:	2201      	movs	r2, #1
 8007158:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800715c:	687b      	ldr	r3, [r7, #4]
 800715e:	2201      	movs	r2, #1
 8007160:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
 8007164:	687b      	ldr	r3, [r7, #4]
 8007166:	2201      	movs	r2, #1
 8007168:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
 800716c:	687b      	ldr	r3, [r7, #4]
 800716e:	2201      	movs	r2, #1
 8007170:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
 8007174:	687b      	ldr	r3, [r7, #4]
 8007176:	2201      	movs	r2, #1
 8007178:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
 800717c:	687b      	ldr	r3, [r7, #4]
 800717e:	2201      	movs	r2, #1
 8007180:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
 8007184:	687b      	ldr	r3, [r7, #4]
 8007186:	2201      	movs	r2, #1
 8007188:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800718c:	687b      	ldr	r3, [r7, #4]
 800718e:	2201      	movs	r2, #1
 8007190:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 8007194:	687b      	ldr	r3, [r7, #4]
 8007196:	2201      	movs	r2, #1
 8007198:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 800719c:	687b      	ldr	r3, [r7, #4]
 800719e:	2201      	movs	r2, #1
 80071a0:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
 80071a4:	687b      	ldr	r3, [r7, #4]
 80071a6:	2201      	movs	r2, #1
 80071a8:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 80071ac:	687b      	ldr	r3, [r7, #4]
 80071ae:	2201      	movs	r2, #1
 80071b0:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
 80071b4:	2300      	movs	r3, #0
}
 80071b6:	4618      	mov	r0, r3
 80071b8:	3708      	adds	r7, #8
 80071ba:	46bd      	mov	sp, r7
 80071bc:	bd80      	pop	{r7, pc}
	...

080071c0 <HAL_TIM_PWM_Start>:
  *            @arg TIM_CHANNEL_5: TIM Channel 5 selected
  *            @arg TIM_CHANNEL_6: TIM Channel 6 selected
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
{
 80071c0:	b580      	push	{r7, lr}
 80071c2:	b084      	sub	sp, #16
 80071c4:	af00      	add	r7, sp, #0
 80071c6:	6078      	str	r0, [r7, #4]
 80071c8:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));

  /* Check the TIM channel state */
  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
 80071ca:	683b      	ldr	r3, [r7, #0]
 80071cc:	2b00      	cmp	r3, #0
 80071ce:	d109      	bne.n	80071e4 <HAL_TIM_PWM_Start+0x24>
 80071d0:	687b      	ldr	r3, [r7, #4]
 80071d2:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 80071d6:	b2db      	uxtb	r3, r3
 80071d8:	2b01      	cmp	r3, #1
 80071da:	bf14      	ite	ne
 80071dc:	2301      	movne	r3, #1
 80071de:	2300      	moveq	r3, #0
 80071e0:	b2db      	uxtb	r3, r3
 80071e2:	e03c      	b.n	800725e <HAL_TIM_PWM_Start+0x9e>
 80071e4:	683b      	ldr	r3, [r7, #0]
 80071e6:	2b04      	cmp	r3, #4
 80071e8:	d109      	bne.n	80071fe <HAL_TIM_PWM_Start+0x3e>
 80071ea:	687b      	ldr	r3, [r7, #4]
 80071ec:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
 80071f0:	b2db      	uxtb	r3, r3
 80071f2:	2b01      	cmp	r3, #1
 80071f4:	bf14      	ite	ne
 80071f6:	2301      	movne	r3, #1
 80071f8:	2300      	moveq	r3, #0
 80071fa:	b2db      	uxtb	r3, r3
 80071fc:	e02f      	b.n	800725e <HAL_TIM_PWM_Start+0x9e>
 80071fe:	683b      	ldr	r3, [r7, #0]
 8007200:	2b08      	cmp	r3, #8
 8007202:	d109      	bne.n	8007218 <HAL_TIM_PWM_Start+0x58>
 8007204:	687b      	ldr	r3, [r7, #4]
 8007206:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 800720a:	b2db      	uxtb	r3, r3
 800720c:	2b01      	cmp	r3, #1
 800720e:	bf14      	ite	ne
 8007210:	2301      	movne	r3, #1
 8007212:	2300      	moveq	r3, #0
 8007214:	b2db      	uxtb	r3, r3
 8007216:	e022      	b.n	800725e <HAL_TIM_PWM_Start+0x9e>
 8007218:	683b      	ldr	r3, [r7, #0]
 800721a:	2b0c      	cmp	r3, #12
 800721c:	d109      	bne.n	8007232 <HAL_TIM_PWM_Start+0x72>
 800721e:	687b      	ldr	r3, [r7, #4]
 8007220:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8007224:	b2db      	uxtb	r3, r3
 8007226:	2b01      	cmp	r3, #1
 8007228:	bf14      	ite	ne
 800722a:	2301      	movne	r3, #1
 800722c:	2300      	moveq	r3, #0
 800722e:	b2db      	uxtb	r3, r3
 8007230:	e015      	b.n	800725e <HAL_TIM_PWM_Start+0x9e>
 8007232:	683b      	ldr	r3, [r7, #0]
 8007234:	2b10      	cmp	r3, #16
 8007236:	d109      	bne.n	800724c <HAL_TIM_PWM_Start+0x8c>
 8007238:	687b      	ldr	r3, [r7, #4]
 800723a:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
 800723e:	b2db      	uxtb	r3, r3
 8007240:	2b01      	cmp	r3, #1
 8007242:	bf14      	ite	ne
 8007244:	2301      	movne	r3, #1
 8007246:	2300      	moveq	r3, #0
 8007248:	b2db      	uxtb	r3, r3
 800724a:	e008      	b.n	800725e <HAL_TIM_PWM_Start+0x9e>
 800724c:	687b      	ldr	r3, [r7, #4]
 800724e:	f893 3043 	ldrb.w	r3, [r3, #67]	; 0x43
 8007252:	b2db      	uxtb	r3, r3
 8007254:	2b01      	cmp	r3, #1
 8007256:	bf14      	ite	ne
 8007258:	2301      	movne	r3, #1
 800725a:	2300      	moveq	r3, #0
 800725c:	b2db      	uxtb	r3, r3
 800725e:	2b00      	cmp	r3, #0
 8007260:	d001      	beq.n	8007266 <HAL_TIM_PWM_Start+0xa6>
  {
    return HAL_ERROR;
 8007262:	2301      	movs	r3, #1
 8007264:	e0a1      	b.n	80073aa <HAL_TIM_PWM_Start+0x1ea>
  }

  /* Set the TIM channel state */
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8007266:	683b      	ldr	r3, [r7, #0]
 8007268:	2b00      	cmp	r3, #0
 800726a:	d104      	bne.n	8007276 <HAL_TIM_PWM_Start+0xb6>
 800726c:	687b      	ldr	r3, [r7, #4]
 800726e:	2202      	movs	r2, #2
 8007270:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
 8007274:	e023      	b.n	80072be <HAL_TIM_PWM_Start+0xfe>
 8007276:	683b      	ldr	r3, [r7, #0]
 8007278:	2b04      	cmp	r3, #4
 800727a:	d104      	bne.n	8007286 <HAL_TIM_PWM_Start+0xc6>
 800727c:	687b      	ldr	r3, [r7, #4]
 800727e:	2202      	movs	r2, #2
 8007280:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
 8007284:	e01b      	b.n	80072be <HAL_TIM_PWM_Start+0xfe>
 8007286:	683b      	ldr	r3, [r7, #0]
 8007288:	2b08      	cmp	r3, #8
 800728a:	d104      	bne.n	8007296 <HAL_TIM_PWM_Start+0xd6>
 800728c:	687b      	ldr	r3, [r7, #4]
 800728e:	2202      	movs	r2, #2
 8007290:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
 8007294:	e013      	b.n	80072be <HAL_TIM_PWM_Start+0xfe>
 8007296:	683b      	ldr	r3, [r7, #0]
 8007298:	2b0c      	cmp	r3, #12
 800729a:	d104      	bne.n	80072a6 <HAL_TIM_PWM_Start+0xe6>
 800729c:	687b      	ldr	r3, [r7, #4]
 800729e:	2202      	movs	r2, #2
 80072a0:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
 80072a4:	e00b      	b.n	80072be <HAL_TIM_PWM_Start+0xfe>
 80072a6:	683b      	ldr	r3, [r7, #0]
 80072a8:	2b10      	cmp	r3, #16
 80072aa:	d104      	bne.n	80072b6 <HAL_TIM_PWM_Start+0xf6>
 80072ac:	687b      	ldr	r3, [r7, #4]
 80072ae:	2202      	movs	r2, #2
 80072b0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
 80072b4:	e003      	b.n	80072be <HAL_TIM_PWM_Start+0xfe>
 80072b6:	687b      	ldr	r3, [r7, #4]
 80072b8:	2202      	movs	r2, #2
 80072ba:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43

  /* Enable the Capture compare channel */
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 80072be:	687b      	ldr	r3, [r7, #4]
 80072c0:	681b      	ldr	r3, [r3, #0]
 80072c2:	2201      	movs	r2, #1
 80072c4:	6839      	ldr	r1, [r7, #0]
 80072c6:	4618      	mov	r0, r3
 80072c8:	f000 ffea 	bl	80082a0 <TIM_CCxChannelCmd>

  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 80072cc:	687b      	ldr	r3, [r7, #4]
 80072ce:	681b      	ldr	r3, [r3, #0]
 80072d0:	4a38      	ldr	r2, [pc, #224]	; (80073b4 <HAL_TIM_PWM_Start+0x1f4>)
 80072d2:	4293      	cmp	r3, r2
 80072d4:	d013      	beq.n	80072fe <HAL_TIM_PWM_Start+0x13e>
 80072d6:	687b      	ldr	r3, [r7, #4]
 80072d8:	681b      	ldr	r3, [r3, #0]
 80072da:	4a37      	ldr	r2, [pc, #220]	; (80073b8 <HAL_TIM_PWM_Start+0x1f8>)
 80072dc:	4293      	cmp	r3, r2
 80072de:	d00e      	beq.n	80072fe <HAL_TIM_PWM_Start+0x13e>
 80072e0:	687b      	ldr	r3, [r7, #4]
 80072e2:	681b      	ldr	r3, [r3, #0]
 80072e4:	4a35      	ldr	r2, [pc, #212]	; (80073bc <HAL_TIM_PWM_Start+0x1fc>)
 80072e6:	4293      	cmp	r3, r2
 80072e8:	d009      	beq.n	80072fe <HAL_TIM_PWM_Start+0x13e>
 80072ea:	687b      	ldr	r3, [r7, #4]
 80072ec:	681b      	ldr	r3, [r3, #0]
 80072ee:	4a34      	ldr	r2, [pc, #208]	; (80073c0 <HAL_TIM_PWM_Start+0x200>)
 80072f0:	4293      	cmp	r3, r2
 80072f2:	d004      	beq.n	80072fe <HAL_TIM_PWM_Start+0x13e>
 80072f4:	687b      	ldr	r3, [r7, #4]
 80072f6:	681b      	ldr	r3, [r3, #0]
 80072f8:	4a32      	ldr	r2, [pc, #200]	; (80073c4 <HAL_TIM_PWM_Start+0x204>)
 80072fa:	4293      	cmp	r3, r2
 80072fc:	d101      	bne.n	8007302 <HAL_TIM_PWM_Start+0x142>
 80072fe:	2301      	movs	r3, #1
 8007300:	e000      	b.n	8007304 <HAL_TIM_PWM_Start+0x144>
 8007302:	2300      	movs	r3, #0
 8007304:	2b00      	cmp	r3, #0
 8007306:	d007      	beq.n	8007318 <HAL_TIM_PWM_Start+0x158>
  {
    /* Enable the main output */
    __HAL_TIM_MOE_ENABLE(htim);
 8007308:	687b      	ldr	r3, [r7, #4]
 800730a:	681b      	ldr	r3, [r3, #0]
 800730c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800730e:	687b      	ldr	r3, [r7, #4]
 8007310:	681b      	ldr	r3, [r3, #0]
 8007312:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8007316:	645a      	str	r2, [r3, #68]	; 0x44
  }

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8007318:	687b      	ldr	r3, [r7, #4]
 800731a:	681b      	ldr	r3, [r3, #0]
 800731c:	4a25      	ldr	r2, [pc, #148]	; (80073b4 <HAL_TIM_PWM_Start+0x1f4>)
 800731e:	4293      	cmp	r3, r2
 8007320:	d022      	beq.n	8007368 <HAL_TIM_PWM_Start+0x1a8>
 8007322:	687b      	ldr	r3, [r7, #4]
 8007324:	681b      	ldr	r3, [r3, #0]
 8007326:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800732a:	d01d      	beq.n	8007368 <HAL_TIM_PWM_Start+0x1a8>
 800732c:	687b      	ldr	r3, [r7, #4]
 800732e:	681b      	ldr	r3, [r3, #0]
 8007330:	4a25      	ldr	r2, [pc, #148]	; (80073c8 <HAL_TIM_PWM_Start+0x208>)
 8007332:	4293      	cmp	r3, r2
 8007334:	d018      	beq.n	8007368 <HAL_TIM_PWM_Start+0x1a8>
 8007336:	687b      	ldr	r3, [r7, #4]
 8007338:	681b      	ldr	r3, [r3, #0]
 800733a:	4a24      	ldr	r2, [pc, #144]	; (80073cc <HAL_TIM_PWM_Start+0x20c>)
 800733c:	4293      	cmp	r3, r2
 800733e:	d013      	beq.n	8007368 <HAL_TIM_PWM_Start+0x1a8>
 8007340:	687b      	ldr	r3, [r7, #4]
 8007342:	681b      	ldr	r3, [r3, #0]
 8007344:	4a22      	ldr	r2, [pc, #136]	; (80073d0 <HAL_TIM_PWM_Start+0x210>)
 8007346:	4293      	cmp	r3, r2
 8007348:	d00e      	beq.n	8007368 <HAL_TIM_PWM_Start+0x1a8>
 800734a:	687b      	ldr	r3, [r7, #4]
 800734c:	681b      	ldr	r3, [r3, #0]
 800734e:	4a1a      	ldr	r2, [pc, #104]	; (80073b8 <HAL_TIM_PWM_Start+0x1f8>)
 8007350:	4293      	cmp	r3, r2
 8007352:	d009      	beq.n	8007368 <HAL_TIM_PWM_Start+0x1a8>
 8007354:	687b      	ldr	r3, [r7, #4]
 8007356:	681b      	ldr	r3, [r3, #0]
 8007358:	4a1e      	ldr	r2, [pc, #120]	; (80073d4 <HAL_TIM_PWM_Start+0x214>)
 800735a:	4293      	cmp	r3, r2
 800735c:	d004      	beq.n	8007368 <HAL_TIM_PWM_Start+0x1a8>
 800735e:	687b      	ldr	r3, [r7, #4]
 8007360:	681b      	ldr	r3, [r3, #0]
 8007362:	4a16      	ldr	r2, [pc, #88]	; (80073bc <HAL_TIM_PWM_Start+0x1fc>)
 8007364:	4293      	cmp	r3, r2
 8007366:	d115      	bne.n	8007394 <HAL_TIM_PWM_Start+0x1d4>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8007368:	687b      	ldr	r3, [r7, #4]
 800736a:	681b      	ldr	r3, [r3, #0]
 800736c:	689a      	ldr	r2, [r3, #8]
 800736e:	4b1a      	ldr	r3, [pc, #104]	; (80073d8 <HAL_TIM_PWM_Start+0x218>)
 8007370:	4013      	ands	r3, r2
 8007372:	60fb      	str	r3, [r7, #12]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8007374:	68fb      	ldr	r3, [r7, #12]
 8007376:	2b06      	cmp	r3, #6
 8007378:	d015      	beq.n	80073a6 <HAL_TIM_PWM_Start+0x1e6>
 800737a:	68fb      	ldr	r3, [r7, #12]
 800737c:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8007380:	d011      	beq.n	80073a6 <HAL_TIM_PWM_Start+0x1e6>
    {
      __HAL_TIM_ENABLE(htim);
 8007382:	687b      	ldr	r3, [r7, #4]
 8007384:	681b      	ldr	r3, [r3, #0]
 8007386:	681a      	ldr	r2, [r3, #0]
 8007388:	687b      	ldr	r3, [r7, #4]
 800738a:	681b      	ldr	r3, [r3, #0]
 800738c:	f042 0201 	orr.w	r2, r2, #1
 8007390:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8007392:	e008      	b.n	80073a6 <HAL_TIM_PWM_Start+0x1e6>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
 8007394:	687b      	ldr	r3, [r7, #4]
 8007396:	681b      	ldr	r3, [r3, #0]
 8007398:	681a      	ldr	r2, [r3, #0]
 800739a:	687b      	ldr	r3, [r7, #4]
 800739c:	681b      	ldr	r3, [r3, #0]
 800739e:	f042 0201 	orr.w	r2, r2, #1
 80073a2:	601a      	str	r2, [r3, #0]
 80073a4:	e000      	b.n	80073a8 <HAL_TIM_PWM_Start+0x1e8>
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 80073a6:	bf00      	nop
  }

  /* Return function status */
  return HAL_OK;
 80073a8:	2300      	movs	r3, #0
}
 80073aa:	4618      	mov	r0, r3
 80073ac:	3710      	adds	r7, #16
 80073ae:	46bd      	mov	sp, r7
 80073b0:	bd80      	pop	{r7, pc}
 80073b2:	bf00      	nop
 80073b4:	40010000 	.word	0x40010000
 80073b8:	40010400 	.word	0x40010400
 80073bc:	40014000 	.word	0x40014000
 80073c0:	40014400 	.word	0x40014400
 80073c4:	40014800 	.word	0x40014800
 80073c8:	40000400 	.word	0x40000400
 80073cc:	40000800 	.word	0x40000800
 80073d0:	40000c00 	.word	0x40000c00
 80073d4:	40001800 	.word	0x40001800
 80073d8:	00010007 	.word	0x00010007

080073dc <HAL_TIM_IRQHandler>:
  * @brief  This function handles TIM interrupts requests.
  * @param  htim TIM  handle
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
 80073dc:	b580      	push	{r7, lr}
 80073de:	b082      	sub	sp, #8
 80073e0:	af00      	add	r7, sp, #0
 80073e2:	6078      	str	r0, [r7, #4]
  /* Capture compare 1 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 80073e4:	687b      	ldr	r3, [r7, #4]
 80073e6:	681b      	ldr	r3, [r3, #0]
 80073e8:	691b      	ldr	r3, [r3, #16]
 80073ea:	f003 0302 	and.w	r3, r3, #2
 80073ee:	2b02      	cmp	r3, #2
 80073f0:	d122      	bne.n	8007438 <HAL_TIM_IRQHandler+0x5c>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 80073f2:	687b      	ldr	r3, [r7, #4]
 80073f4:	681b      	ldr	r3, [r3, #0]
 80073f6:	68db      	ldr	r3, [r3, #12]
 80073f8:	f003 0302 	and.w	r3, r3, #2
 80073fc:	2b02      	cmp	r3, #2
 80073fe:	d11b      	bne.n	8007438 <HAL_TIM_IRQHandler+0x5c>
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8007400:	687b      	ldr	r3, [r7, #4]
 8007402:	681b      	ldr	r3, [r3, #0]
 8007404:	f06f 0202 	mvn.w	r2, #2
 8007408:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 800740a:	687b      	ldr	r3, [r7, #4]
 800740c:	2201      	movs	r2, #1
 800740e:	771a      	strb	r2, [r3, #28]

        /* Input capture event */
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8007410:	687b      	ldr	r3, [r7, #4]
 8007412:	681b      	ldr	r3, [r3, #0]
 8007414:	699b      	ldr	r3, [r3, #24]
 8007416:	f003 0303 	and.w	r3, r3, #3
 800741a:	2b00      	cmp	r3, #0
 800741c:	d003      	beq.n	8007426 <HAL_TIM_IRQHandler+0x4a>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->IC_CaptureCallback(htim);
#else
          HAL_TIM_IC_CaptureCallback(htim);
 800741e:	6878      	ldr	r0, [r7, #4]
 8007420:	f000 fb12 	bl	8007a48 <HAL_TIM_IC_CaptureCallback>
 8007424:	e005      	b.n	8007432 <HAL_TIM_IRQHandler+0x56>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->OC_DelayElapsedCallback(htim);
          htim->PWM_PulseFinishedCallback(htim);
#else
          HAL_TIM_OC_DelayElapsedCallback(htim);
 8007426:	6878      	ldr	r0, [r7, #4]
 8007428:	f000 fb04 	bl	8007a34 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 800742c:	6878      	ldr	r0, [r7, #4]
 800742e:	f000 fb15 	bl	8007a5c <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8007432:	687b      	ldr	r3, [r7, #4]
 8007434:	2200      	movs	r2, #0
 8007436:	771a      	strb	r2, [r3, #28]
      }
    }
  }
  /* Capture compare 2 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8007438:	687b      	ldr	r3, [r7, #4]
 800743a:	681b      	ldr	r3, [r3, #0]
 800743c:	691b      	ldr	r3, [r3, #16]
 800743e:	f003 0304 	and.w	r3, r3, #4
 8007442:	2b04      	cmp	r3, #4
 8007444:	d122      	bne.n	800748c <HAL_TIM_IRQHandler+0xb0>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 8007446:	687b      	ldr	r3, [r7, #4]
 8007448:	681b      	ldr	r3, [r3, #0]
 800744a:	68db      	ldr	r3, [r3, #12]
 800744c:	f003 0304 	and.w	r3, r3, #4
 8007450:	2b04      	cmp	r3, #4
 8007452:	d11b      	bne.n	800748c <HAL_TIM_IRQHandler+0xb0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8007454:	687b      	ldr	r3, [r7, #4]
 8007456:	681b      	ldr	r3, [r3, #0]
 8007458:	f06f 0204 	mvn.w	r2, #4
 800745c:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 800745e:	687b      	ldr	r3, [r7, #4]
 8007460:	2202      	movs	r2, #2
 8007462:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8007464:	687b      	ldr	r3, [r7, #4]
 8007466:	681b      	ldr	r3, [r3, #0]
 8007468:	699b      	ldr	r3, [r3, #24]
 800746a:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800746e:	2b00      	cmp	r3, #0
 8007470:	d003      	beq.n	800747a <HAL_TIM_IRQHandler+0x9e>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 8007472:	6878      	ldr	r0, [r7, #4]
 8007474:	f000 fae8 	bl	8007a48 <HAL_TIM_IC_CaptureCallback>
 8007478:	e005      	b.n	8007486 <HAL_TIM_IRQHandler+0xaa>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800747a:	6878      	ldr	r0, [r7, #4]
 800747c:	f000 fada 	bl	8007a34 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8007480:	6878      	ldr	r0, [r7, #4]
 8007482:	f000 faeb 	bl	8007a5c <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8007486:	687b      	ldr	r3, [r7, #4]
 8007488:	2200      	movs	r2, #0
 800748a:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 3 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 800748c:	687b      	ldr	r3, [r7, #4]
 800748e:	681b      	ldr	r3, [r3, #0]
 8007490:	691b      	ldr	r3, [r3, #16]
 8007492:	f003 0308 	and.w	r3, r3, #8
 8007496:	2b08      	cmp	r3, #8
 8007498:	d122      	bne.n	80074e0 <HAL_TIM_IRQHandler+0x104>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 800749a:	687b      	ldr	r3, [r7, #4]
 800749c:	681b      	ldr	r3, [r3, #0]
 800749e:	68db      	ldr	r3, [r3, #12]
 80074a0:	f003 0308 	and.w	r3, r3, #8
 80074a4:	2b08      	cmp	r3, #8
 80074a6:	d11b      	bne.n	80074e0 <HAL_TIM_IRQHandler+0x104>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 80074a8:	687b      	ldr	r3, [r7, #4]
 80074aa:	681b      	ldr	r3, [r3, #0]
 80074ac:	f06f 0208 	mvn.w	r2, #8
 80074b0:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 80074b2:	687b      	ldr	r3, [r7, #4]
 80074b4:	2204      	movs	r2, #4
 80074b6:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 80074b8:	687b      	ldr	r3, [r7, #4]
 80074ba:	681b      	ldr	r3, [r3, #0]
 80074bc:	69db      	ldr	r3, [r3, #28]
 80074be:	f003 0303 	and.w	r3, r3, #3
 80074c2:	2b00      	cmp	r3, #0
 80074c4:	d003      	beq.n	80074ce <HAL_TIM_IRQHandler+0xf2>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 80074c6:	6878      	ldr	r0, [r7, #4]
 80074c8:	f000 fabe 	bl	8007a48 <HAL_TIM_IC_CaptureCallback>
 80074cc:	e005      	b.n	80074da <HAL_TIM_IRQHandler+0xfe>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 80074ce:	6878      	ldr	r0, [r7, #4]
 80074d0:	f000 fab0 	bl	8007a34 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 80074d4:	6878      	ldr	r0, [r7, #4]
 80074d6:	f000 fac1 	bl	8007a5c <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80074da:	687b      	ldr	r3, [r7, #4]
 80074dc:	2200      	movs	r2, #0
 80074de:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 4 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 80074e0:	687b      	ldr	r3, [r7, #4]
 80074e2:	681b      	ldr	r3, [r3, #0]
 80074e4:	691b      	ldr	r3, [r3, #16]
 80074e6:	f003 0310 	and.w	r3, r3, #16
 80074ea:	2b10      	cmp	r3, #16
 80074ec:	d122      	bne.n	8007534 <HAL_TIM_IRQHandler+0x158>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 80074ee:	687b      	ldr	r3, [r7, #4]
 80074f0:	681b      	ldr	r3, [r3, #0]
 80074f2:	68db      	ldr	r3, [r3, #12]
 80074f4:	f003 0310 	and.w	r3, r3, #16
 80074f8:	2b10      	cmp	r3, #16
 80074fa:	d11b      	bne.n	8007534 <HAL_TIM_IRQHandler+0x158>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 80074fc:	687b      	ldr	r3, [r7, #4]
 80074fe:	681b      	ldr	r3, [r3, #0]
 8007500:	f06f 0210 	mvn.w	r2, #16
 8007504:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8007506:	687b      	ldr	r3, [r7, #4]
 8007508:	2208      	movs	r2, #8
 800750a:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 800750c:	687b      	ldr	r3, [r7, #4]
 800750e:	681b      	ldr	r3, [r3, #0]
 8007510:	69db      	ldr	r3, [r3, #28]
 8007512:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8007516:	2b00      	cmp	r3, #0
 8007518:	d003      	beq.n	8007522 <HAL_TIM_IRQHandler+0x146>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 800751a:	6878      	ldr	r0, [r7, #4]
 800751c:	f000 fa94 	bl	8007a48 <HAL_TIM_IC_CaptureCallback>
 8007520:	e005      	b.n	800752e <HAL_TIM_IRQHandler+0x152>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8007522:	6878      	ldr	r0, [r7, #4]
 8007524:	f000 fa86 	bl	8007a34 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8007528:	6878      	ldr	r0, [r7, #4]
 800752a:	f000 fa97 	bl	8007a5c <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800752e:	687b      	ldr	r3, [r7, #4]
 8007530:	2200      	movs	r2, #0
 8007532:	771a      	strb	r2, [r3, #28]
    }
  }
  /* TIM Update event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8007534:	687b      	ldr	r3, [r7, #4]
 8007536:	681b      	ldr	r3, [r3, #0]
 8007538:	691b      	ldr	r3, [r3, #16]
 800753a:	f003 0301 	and.w	r3, r3, #1
 800753e:	2b01      	cmp	r3, #1
 8007540:	d10e      	bne.n	8007560 <HAL_TIM_IRQHandler+0x184>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 8007542:	687b      	ldr	r3, [r7, #4]
 8007544:	681b      	ldr	r3, [r3, #0]
 8007546:	68db      	ldr	r3, [r3, #12]
 8007548:	f003 0301 	and.w	r3, r3, #1
 800754c:	2b01      	cmp	r3, #1
 800754e:	d107      	bne.n	8007560 <HAL_TIM_IRQHandler+0x184>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8007550:	687b      	ldr	r3, [r7, #4]
 8007552:	681b      	ldr	r3, [r3, #0]
 8007554:	f06f 0201 	mvn.w	r2, #1
 8007558:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->PeriodElapsedCallback(htim);
#else
      HAL_TIM_PeriodElapsedCallback(htim);
 800755a:	6878      	ldr	r0, [r7, #4]
 800755c:	f009 fd28 	bl	8010fb0 <HAL_TIM_PeriodElapsedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8007560:	687b      	ldr	r3, [r7, #4]
 8007562:	681b      	ldr	r3, [r3, #0]
 8007564:	691b      	ldr	r3, [r3, #16]
 8007566:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800756a:	2b80      	cmp	r3, #128	; 0x80
 800756c:	d10e      	bne.n	800758c <HAL_TIM_IRQHandler+0x1b0>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 800756e:	687b      	ldr	r3, [r7, #4]
 8007570:	681b      	ldr	r3, [r3, #0]
 8007572:	68db      	ldr	r3, [r3, #12]
 8007574:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8007578:	2b80      	cmp	r3, #128	; 0x80
 800757a:	d107      	bne.n	800758c <HAL_TIM_IRQHandler+0x1b0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 800757c:	687b      	ldr	r3, [r7, #4]
 800757e:	681b      	ldr	r3, [r3, #0]
 8007580:	f06f 0280 	mvn.w	r2, #128	; 0x80
 8007584:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->BreakCallback(htim);
#else
      HAL_TIMEx_BreakCallback(htim);
 8007586:	6878      	ldr	r0, [r7, #4]
 8007588:	f000 ff48 	bl	800841c <HAL_TIMEx_BreakCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break2 input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 800758c:	687b      	ldr	r3, [r7, #4]
 800758e:	681b      	ldr	r3, [r3, #0]
 8007590:	691b      	ldr	r3, [r3, #16]
 8007592:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8007596:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800759a:	d10e      	bne.n	80075ba <HAL_TIM_IRQHandler+0x1de>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 800759c:	687b      	ldr	r3, [r7, #4]
 800759e:	681b      	ldr	r3, [r3, #0]
 80075a0:	68db      	ldr	r3, [r3, #12]
 80075a2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80075a6:	2b80      	cmp	r3, #128	; 0x80
 80075a8:	d107      	bne.n	80075ba <HAL_TIM_IRQHandler+0x1de>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 80075aa:	687b      	ldr	r3, [r7, #4]
 80075ac:	681b      	ldr	r3, [r3, #0]
 80075ae:	f46f 7280 	mvn.w	r2, #256	; 0x100
 80075b2:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->Break2Callback(htim);
#else
      HAL_TIMEx_Break2Callback(htim);
 80075b4:	6878      	ldr	r0, [r7, #4]
 80075b6:	f000 ff3b 	bl	8008430 <HAL_TIMEx_Break2Callback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Trigger detection event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 80075ba:	687b      	ldr	r3, [r7, #4]
 80075bc:	681b      	ldr	r3, [r3, #0]
 80075be:	691b      	ldr	r3, [r3, #16]
 80075c0:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80075c4:	2b40      	cmp	r3, #64	; 0x40
 80075c6:	d10e      	bne.n	80075e6 <HAL_TIM_IRQHandler+0x20a>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 80075c8:	687b      	ldr	r3, [r7, #4]
 80075ca:	681b      	ldr	r3, [r3, #0]
 80075cc:	68db      	ldr	r3, [r3, #12]
 80075ce:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80075d2:	2b40      	cmp	r3, #64	; 0x40
 80075d4:	d107      	bne.n	80075e6 <HAL_TIM_IRQHandler+0x20a>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 80075d6:	687b      	ldr	r3, [r7, #4]
 80075d8:	681b      	ldr	r3, [r3, #0]
 80075da:	f06f 0240 	mvn.w	r2, #64	; 0x40
 80075de:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TriggerCallback(htim);
#else
      HAL_TIM_TriggerCallback(htim);
 80075e0:	6878      	ldr	r0, [r7, #4]
 80075e2:	f000 fa45 	bl	8007a70 <HAL_TIM_TriggerCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM commutation event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 80075e6:	687b      	ldr	r3, [r7, #4]
 80075e8:	681b      	ldr	r3, [r3, #0]
 80075ea:	691b      	ldr	r3, [r3, #16]
 80075ec:	f003 0320 	and.w	r3, r3, #32
 80075f0:	2b20      	cmp	r3, #32
 80075f2:	d10e      	bne.n	8007612 <HAL_TIM_IRQHandler+0x236>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 80075f4:	687b      	ldr	r3, [r7, #4]
 80075f6:	681b      	ldr	r3, [r3, #0]
 80075f8:	68db      	ldr	r3, [r3, #12]
 80075fa:	f003 0320 	and.w	r3, r3, #32
 80075fe:	2b20      	cmp	r3, #32
 8007600:	d107      	bne.n	8007612 <HAL_TIM_IRQHandler+0x236>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8007602:	687b      	ldr	r3, [r7, #4]
 8007604:	681b      	ldr	r3, [r3, #0]
 8007606:	f06f 0220 	mvn.w	r2, #32
 800760a:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->CommutationCallback(htim);
#else
      HAL_TIMEx_CommutCallback(htim);
 800760c:	6878      	ldr	r0, [r7, #4]
 800760e:	f000 fefb 	bl	8008408 <HAL_TIMEx_CommutCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
}
 8007612:	bf00      	nop
 8007614:	3708      	adds	r7, #8
 8007616:	46bd      	mov	sp, r7
 8007618:	bd80      	pop	{r7, pc}
	...

0800761c <HAL_TIM_PWM_ConfigChannel>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim,
                                            TIM_OC_InitTypeDef *sConfig,
                                            uint32_t Channel)
{
 800761c:	b580      	push	{r7, lr}
 800761e:	b086      	sub	sp, #24
 8007620:	af00      	add	r7, sp, #0
 8007622:	60f8      	str	r0, [r7, #12]
 8007624:	60b9      	str	r1, [r7, #8]
 8007626:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 8007628:	2300      	movs	r3, #0
 800762a:	75fb      	strb	r3, [r7, #23]
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));

  /* Process Locked */
  __HAL_LOCK(htim);
 800762c:	68fb      	ldr	r3, [r7, #12]
 800762e:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8007632:	2b01      	cmp	r3, #1
 8007634:	d101      	bne.n	800763a <HAL_TIM_PWM_ConfigChannel+0x1e>
 8007636:	2302      	movs	r3, #2
 8007638:	e0ff      	b.n	800783a <HAL_TIM_PWM_ConfigChannel+0x21e>
 800763a:	68fb      	ldr	r3, [r7, #12]
 800763c:	2201      	movs	r2, #1
 800763e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
 8007642:	687b      	ldr	r3, [r7, #4]
 8007644:	2b14      	cmp	r3, #20
 8007646:	f200 80f0 	bhi.w	800782a <HAL_TIM_PWM_ConfigChannel+0x20e>
 800764a:	a201      	add	r2, pc, #4	; (adr r2, 8007650 <HAL_TIM_PWM_ConfigChannel+0x34>)
 800764c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8007650:	080076a5 	.word	0x080076a5
 8007654:	0800782b 	.word	0x0800782b
 8007658:	0800782b 	.word	0x0800782b
 800765c:	0800782b 	.word	0x0800782b
 8007660:	080076e5 	.word	0x080076e5
 8007664:	0800782b 	.word	0x0800782b
 8007668:	0800782b 	.word	0x0800782b
 800766c:	0800782b 	.word	0x0800782b
 8007670:	08007727 	.word	0x08007727
 8007674:	0800782b 	.word	0x0800782b
 8007678:	0800782b 	.word	0x0800782b
 800767c:	0800782b 	.word	0x0800782b
 8007680:	08007767 	.word	0x08007767
 8007684:	0800782b 	.word	0x0800782b
 8007688:	0800782b 	.word	0x0800782b
 800768c:	0800782b 	.word	0x0800782b
 8007690:	080077a9 	.word	0x080077a9
 8007694:	0800782b 	.word	0x0800782b
 8007698:	0800782b 	.word	0x0800782b
 800769c:	0800782b 	.word	0x0800782b
 80076a0:	080077e9 	.word	0x080077e9
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));

      /* Configure the Channel 1 in PWM mode */
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 80076a4:	68fb      	ldr	r3, [r7, #12]
 80076a6:	681b      	ldr	r3, [r3, #0]
 80076a8:	68b9      	ldr	r1, [r7, #8]
 80076aa:	4618      	mov	r0, r3
 80076ac:	f000 fa84 	bl	8007bb8 <TIM_OC1_SetConfig>

      /* Set the Preload enable bit for channel1 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 80076b0:	68fb      	ldr	r3, [r7, #12]
 80076b2:	681b      	ldr	r3, [r3, #0]
 80076b4:	699a      	ldr	r2, [r3, #24]
 80076b6:	68fb      	ldr	r3, [r7, #12]
 80076b8:	681b      	ldr	r3, [r3, #0]
 80076ba:	f042 0208 	orr.w	r2, r2, #8
 80076be:	619a      	str	r2, [r3, #24]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 80076c0:	68fb      	ldr	r3, [r7, #12]
 80076c2:	681b      	ldr	r3, [r3, #0]
 80076c4:	699a      	ldr	r2, [r3, #24]
 80076c6:	68fb      	ldr	r3, [r7, #12]
 80076c8:	681b      	ldr	r3, [r3, #0]
 80076ca:	f022 0204 	bic.w	r2, r2, #4
 80076ce:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 80076d0:	68fb      	ldr	r3, [r7, #12]
 80076d2:	681b      	ldr	r3, [r3, #0]
 80076d4:	6999      	ldr	r1, [r3, #24]
 80076d6:	68bb      	ldr	r3, [r7, #8]
 80076d8:	691a      	ldr	r2, [r3, #16]
 80076da:	68fb      	ldr	r3, [r7, #12]
 80076dc:	681b      	ldr	r3, [r3, #0]
 80076de:	430a      	orrs	r2, r1
 80076e0:	619a      	str	r2, [r3, #24]
      break;
 80076e2:	e0a5      	b.n	8007830 <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));

      /* Configure the Channel 2 in PWM mode */
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 80076e4:	68fb      	ldr	r3, [r7, #12]
 80076e6:	681b      	ldr	r3, [r3, #0]
 80076e8:	68b9      	ldr	r1, [r7, #8]
 80076ea:	4618      	mov	r0, r3
 80076ec:	f000 faf4 	bl	8007cd8 <TIM_OC2_SetConfig>

      /* Set the Preload enable bit for channel2 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 80076f0:	68fb      	ldr	r3, [r7, #12]
 80076f2:	681b      	ldr	r3, [r3, #0]
 80076f4:	699a      	ldr	r2, [r3, #24]
 80076f6:	68fb      	ldr	r3, [r7, #12]
 80076f8:	681b      	ldr	r3, [r3, #0]
 80076fa:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 80076fe:	619a      	str	r2, [r3, #24]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 8007700:	68fb      	ldr	r3, [r7, #12]
 8007702:	681b      	ldr	r3, [r3, #0]
 8007704:	699a      	ldr	r2, [r3, #24]
 8007706:	68fb      	ldr	r3, [r7, #12]
 8007708:	681b      	ldr	r3, [r3, #0]
 800770a:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800770e:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 8007710:	68fb      	ldr	r3, [r7, #12]
 8007712:	681b      	ldr	r3, [r3, #0]
 8007714:	6999      	ldr	r1, [r3, #24]
 8007716:	68bb      	ldr	r3, [r7, #8]
 8007718:	691b      	ldr	r3, [r3, #16]
 800771a:	021a      	lsls	r2, r3, #8
 800771c:	68fb      	ldr	r3, [r7, #12]
 800771e:	681b      	ldr	r3, [r3, #0]
 8007720:	430a      	orrs	r2, r1
 8007722:	619a      	str	r2, [r3, #24]
      break;
 8007724:	e084      	b.n	8007830 <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));

      /* Configure the Channel 3 in PWM mode */
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 8007726:	68fb      	ldr	r3, [r7, #12]
 8007728:	681b      	ldr	r3, [r3, #0]
 800772a:	68b9      	ldr	r1, [r7, #8]
 800772c:	4618      	mov	r0, r3
 800772e:	f000 fb5d 	bl	8007dec <TIM_OC3_SetConfig>

      /* Set the Preload enable bit for channel3 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 8007732:	68fb      	ldr	r3, [r7, #12]
 8007734:	681b      	ldr	r3, [r3, #0]
 8007736:	69da      	ldr	r2, [r3, #28]
 8007738:	68fb      	ldr	r3, [r7, #12]
 800773a:	681b      	ldr	r3, [r3, #0]
 800773c:	f042 0208 	orr.w	r2, r2, #8
 8007740:	61da      	str	r2, [r3, #28]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 8007742:	68fb      	ldr	r3, [r7, #12]
 8007744:	681b      	ldr	r3, [r3, #0]
 8007746:	69da      	ldr	r2, [r3, #28]
 8007748:	68fb      	ldr	r3, [r7, #12]
 800774a:	681b      	ldr	r3, [r3, #0]
 800774c:	f022 0204 	bic.w	r2, r2, #4
 8007750:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 8007752:	68fb      	ldr	r3, [r7, #12]
 8007754:	681b      	ldr	r3, [r3, #0]
 8007756:	69d9      	ldr	r1, [r3, #28]
 8007758:	68bb      	ldr	r3, [r7, #8]
 800775a:	691a      	ldr	r2, [r3, #16]
 800775c:	68fb      	ldr	r3, [r7, #12]
 800775e:	681b      	ldr	r3, [r3, #0]
 8007760:	430a      	orrs	r2, r1
 8007762:	61da      	str	r2, [r3, #28]
      break;
 8007764:	e064      	b.n	8007830 <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));

      /* Configure the Channel 4 in PWM mode */
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 8007766:	68fb      	ldr	r3, [r7, #12]
 8007768:	681b      	ldr	r3, [r3, #0]
 800776a:	68b9      	ldr	r1, [r7, #8]
 800776c:	4618      	mov	r0, r3
 800776e:	f000 fbc5 	bl	8007efc <TIM_OC4_SetConfig>

      /* Set the Preload enable bit for channel4 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 8007772:	68fb      	ldr	r3, [r7, #12]
 8007774:	681b      	ldr	r3, [r3, #0]
 8007776:	69da      	ldr	r2, [r3, #28]
 8007778:	68fb      	ldr	r3, [r7, #12]
 800777a:	681b      	ldr	r3, [r3, #0]
 800777c:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8007780:	61da      	str	r2, [r3, #28]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 8007782:	68fb      	ldr	r3, [r7, #12]
 8007784:	681b      	ldr	r3, [r3, #0]
 8007786:	69da      	ldr	r2, [r3, #28]
 8007788:	68fb      	ldr	r3, [r7, #12]
 800778a:	681b      	ldr	r3, [r3, #0]
 800778c:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8007790:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 8007792:	68fb      	ldr	r3, [r7, #12]
 8007794:	681b      	ldr	r3, [r3, #0]
 8007796:	69d9      	ldr	r1, [r3, #28]
 8007798:	68bb      	ldr	r3, [r7, #8]
 800779a:	691b      	ldr	r3, [r3, #16]
 800779c:	021a      	lsls	r2, r3, #8
 800779e:	68fb      	ldr	r3, [r7, #12]
 80077a0:	681b      	ldr	r3, [r3, #0]
 80077a2:	430a      	orrs	r2, r1
 80077a4:	61da      	str	r2, [r3, #28]
      break;
 80077a6:	e043      	b.n	8007830 <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));

      /* Configure the Channel 5 in PWM mode */
      TIM_OC5_SetConfig(htim->Instance, sConfig);
 80077a8:	68fb      	ldr	r3, [r7, #12]
 80077aa:	681b      	ldr	r3, [r3, #0]
 80077ac:	68b9      	ldr	r1, [r7, #8]
 80077ae:	4618      	mov	r0, r3
 80077b0:	f000 fc0e 	bl	8007fd0 <TIM_OC5_SetConfig>

      /* Set the Preload enable bit for channel5*/
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
 80077b4:	68fb      	ldr	r3, [r7, #12]
 80077b6:	681b      	ldr	r3, [r3, #0]
 80077b8:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80077ba:	68fb      	ldr	r3, [r7, #12]
 80077bc:	681b      	ldr	r3, [r3, #0]
 80077be:	f042 0208 	orr.w	r2, r2, #8
 80077c2:	655a      	str	r2, [r3, #84]	; 0x54

      /* Configure the Output Fast mode */
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
 80077c4:	68fb      	ldr	r3, [r7, #12]
 80077c6:	681b      	ldr	r3, [r3, #0]
 80077c8:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80077ca:	68fb      	ldr	r3, [r7, #12]
 80077cc:	681b      	ldr	r3, [r3, #0]
 80077ce:	f022 0204 	bic.w	r2, r2, #4
 80077d2:	655a      	str	r2, [r3, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
 80077d4:	68fb      	ldr	r3, [r7, #12]
 80077d6:	681b      	ldr	r3, [r3, #0]
 80077d8:	6d59      	ldr	r1, [r3, #84]	; 0x54
 80077da:	68bb      	ldr	r3, [r7, #8]
 80077dc:	691a      	ldr	r2, [r3, #16]
 80077de:	68fb      	ldr	r3, [r7, #12]
 80077e0:	681b      	ldr	r3, [r3, #0]
 80077e2:	430a      	orrs	r2, r1
 80077e4:	655a      	str	r2, [r3, #84]	; 0x54
      break;
 80077e6:	e023      	b.n	8007830 <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));

      /* Configure the Channel 6 in PWM mode */
      TIM_OC6_SetConfig(htim->Instance, sConfig);
 80077e8:	68fb      	ldr	r3, [r7, #12]
 80077ea:	681b      	ldr	r3, [r3, #0]
 80077ec:	68b9      	ldr	r1, [r7, #8]
 80077ee:	4618      	mov	r0, r3
 80077f0:	f000 fc52 	bl	8008098 <TIM_OC6_SetConfig>

      /* Set the Preload enable bit for channel6 */
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
 80077f4:	68fb      	ldr	r3, [r7, #12]
 80077f6:	681b      	ldr	r3, [r3, #0]
 80077f8:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80077fa:	68fb      	ldr	r3, [r7, #12]
 80077fc:	681b      	ldr	r3, [r3, #0]
 80077fe:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8007802:	655a      	str	r2, [r3, #84]	; 0x54

      /* Configure the Output Fast mode */
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
 8007804:	68fb      	ldr	r3, [r7, #12]
 8007806:	681b      	ldr	r3, [r3, #0]
 8007808:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800780a:	68fb      	ldr	r3, [r7, #12]
 800780c:	681b      	ldr	r3, [r3, #0]
 800780e:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8007812:	655a      	str	r2, [r3, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
 8007814:	68fb      	ldr	r3, [r7, #12]
 8007816:	681b      	ldr	r3, [r3, #0]
 8007818:	6d59      	ldr	r1, [r3, #84]	; 0x54
 800781a:	68bb      	ldr	r3, [r7, #8]
 800781c:	691b      	ldr	r3, [r3, #16]
 800781e:	021a      	lsls	r2, r3, #8
 8007820:	68fb      	ldr	r3, [r7, #12]
 8007822:	681b      	ldr	r3, [r3, #0]
 8007824:	430a      	orrs	r2, r1
 8007826:	655a      	str	r2, [r3, #84]	; 0x54
      break;
 8007828:	e002      	b.n	8007830 <HAL_TIM_PWM_ConfigChannel+0x214>
    }

    default:
      status = HAL_ERROR;
 800782a:	2301      	movs	r3, #1
 800782c:	75fb      	strb	r3, [r7, #23]
      break;
 800782e:	bf00      	nop
  }

  __HAL_UNLOCK(htim);
 8007830:	68fb      	ldr	r3, [r7, #12]
 8007832:	2200      	movs	r2, #0
 8007834:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return status;
 8007838:	7dfb      	ldrb	r3, [r7, #23]
}
 800783a:	4618      	mov	r0, r3
 800783c:	3718      	adds	r7, #24
 800783e:	46bd      	mov	sp, r7
 8007840:	bd80      	pop	{r7, pc}
 8007842:	bf00      	nop

08007844 <HAL_TIM_ConfigClockSource>:
  * @param  sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that
  *         contains the clock source information for the TIM peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef *sClockSourceConfig)
{
 8007844:	b580      	push	{r7, lr}
 8007846:	b084      	sub	sp, #16
 8007848:	af00      	add	r7, sp, #0
 800784a:	6078      	str	r0, [r7, #4]
 800784c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 800784e:	2300      	movs	r3, #0
 8007850:	73fb      	strb	r3, [r7, #15]
  uint32_t tmpsmcr;

  /* Process Locked */
  __HAL_LOCK(htim);
 8007852:	687b      	ldr	r3, [r7, #4]
 8007854:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 8007858:	2b01      	cmp	r3, #1
 800785a:	d101      	bne.n	8007860 <HAL_TIM_ConfigClockSource+0x1c>
 800785c:	2302      	movs	r3, #2
 800785e:	e0dc      	b.n	8007a1a <HAL_TIM_ConfigClockSource+0x1d6>
 8007860:	687b      	ldr	r3, [r7, #4]
 8007862:	2201      	movs	r2, #1
 8007864:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  htim->State = HAL_TIM_STATE_BUSY;
 8007868:	687b      	ldr	r3, [r7, #4]
 800786a:	2202      	movs	r2, #2
 800786c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Check the parameters */
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));

  /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
  tmpsmcr = htim->Instance->SMCR;
 8007870:	687b      	ldr	r3, [r7, #4]
 8007872:	681b      	ldr	r3, [r3, #0]
 8007874:	689b      	ldr	r3, [r3, #8]
 8007876:	60bb      	str	r3, [r7, #8]
  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
 8007878:	68ba      	ldr	r2, [r7, #8]
 800787a:	4b6a      	ldr	r3, [pc, #424]	; (8007a24 <HAL_TIM_ConfigClockSource+0x1e0>)
 800787c:	4013      	ands	r3, r2
 800787e:	60bb      	str	r3, [r7, #8]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8007880:	68bb      	ldr	r3, [r7, #8]
 8007882:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8007886:	60bb      	str	r3, [r7, #8]
  htim->Instance->SMCR = tmpsmcr;
 8007888:	687b      	ldr	r3, [r7, #4]
 800788a:	681b      	ldr	r3, [r3, #0]
 800788c:	68ba      	ldr	r2, [r7, #8]
 800788e:	609a      	str	r2, [r3, #8]

  switch (sClockSourceConfig->ClockSource)
 8007890:	683b      	ldr	r3, [r7, #0]
 8007892:	681b      	ldr	r3, [r3, #0]
 8007894:	4a64      	ldr	r2, [pc, #400]	; (8007a28 <HAL_TIM_ConfigClockSource+0x1e4>)
 8007896:	4293      	cmp	r3, r2
 8007898:	f000 80a9 	beq.w	80079ee <HAL_TIM_ConfigClockSource+0x1aa>
 800789c:	4a62      	ldr	r2, [pc, #392]	; (8007a28 <HAL_TIM_ConfigClockSource+0x1e4>)
 800789e:	4293      	cmp	r3, r2
 80078a0:	f200 80ae 	bhi.w	8007a00 <HAL_TIM_ConfigClockSource+0x1bc>
 80078a4:	4a61      	ldr	r2, [pc, #388]	; (8007a2c <HAL_TIM_ConfigClockSource+0x1e8>)
 80078a6:	4293      	cmp	r3, r2
 80078a8:	f000 80a1 	beq.w	80079ee <HAL_TIM_ConfigClockSource+0x1aa>
 80078ac:	4a5f      	ldr	r2, [pc, #380]	; (8007a2c <HAL_TIM_ConfigClockSource+0x1e8>)
 80078ae:	4293      	cmp	r3, r2
 80078b0:	f200 80a6 	bhi.w	8007a00 <HAL_TIM_ConfigClockSource+0x1bc>
 80078b4:	4a5e      	ldr	r2, [pc, #376]	; (8007a30 <HAL_TIM_ConfigClockSource+0x1ec>)
 80078b6:	4293      	cmp	r3, r2
 80078b8:	f000 8099 	beq.w	80079ee <HAL_TIM_ConfigClockSource+0x1aa>
 80078bc:	4a5c      	ldr	r2, [pc, #368]	; (8007a30 <HAL_TIM_ConfigClockSource+0x1ec>)
 80078be:	4293      	cmp	r3, r2
 80078c0:	f200 809e 	bhi.w	8007a00 <HAL_TIM_ConfigClockSource+0x1bc>
 80078c4:	f1b3 1f10 	cmp.w	r3, #1048592	; 0x100010
 80078c8:	f000 8091 	beq.w	80079ee <HAL_TIM_ConfigClockSource+0x1aa>
 80078cc:	f1b3 1f10 	cmp.w	r3, #1048592	; 0x100010
 80078d0:	f200 8096 	bhi.w	8007a00 <HAL_TIM_ConfigClockSource+0x1bc>
 80078d4:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 80078d8:	f000 8089 	beq.w	80079ee <HAL_TIM_ConfigClockSource+0x1aa>
 80078dc:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 80078e0:	f200 808e 	bhi.w	8007a00 <HAL_TIM_ConfigClockSource+0x1bc>
 80078e4:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 80078e8:	d03e      	beq.n	8007968 <HAL_TIM_ConfigClockSource+0x124>
 80078ea:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 80078ee:	f200 8087 	bhi.w	8007a00 <HAL_TIM_ConfigClockSource+0x1bc>
 80078f2:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80078f6:	f000 8086 	beq.w	8007a06 <HAL_TIM_ConfigClockSource+0x1c2>
 80078fa:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80078fe:	d87f      	bhi.n	8007a00 <HAL_TIM_ConfigClockSource+0x1bc>
 8007900:	2b70      	cmp	r3, #112	; 0x70
 8007902:	d01a      	beq.n	800793a <HAL_TIM_ConfigClockSource+0xf6>
 8007904:	2b70      	cmp	r3, #112	; 0x70
 8007906:	d87b      	bhi.n	8007a00 <HAL_TIM_ConfigClockSource+0x1bc>
 8007908:	2b60      	cmp	r3, #96	; 0x60
 800790a:	d050      	beq.n	80079ae <HAL_TIM_ConfigClockSource+0x16a>
 800790c:	2b60      	cmp	r3, #96	; 0x60
 800790e:	d877      	bhi.n	8007a00 <HAL_TIM_ConfigClockSource+0x1bc>
 8007910:	2b50      	cmp	r3, #80	; 0x50
 8007912:	d03c      	beq.n	800798e <HAL_TIM_ConfigClockSource+0x14a>
 8007914:	2b50      	cmp	r3, #80	; 0x50
 8007916:	d873      	bhi.n	8007a00 <HAL_TIM_ConfigClockSource+0x1bc>
 8007918:	2b40      	cmp	r3, #64	; 0x40
 800791a:	d058      	beq.n	80079ce <HAL_TIM_ConfigClockSource+0x18a>
 800791c:	2b40      	cmp	r3, #64	; 0x40
 800791e:	d86f      	bhi.n	8007a00 <HAL_TIM_ConfigClockSource+0x1bc>
 8007920:	2b30      	cmp	r3, #48	; 0x30
 8007922:	d064      	beq.n	80079ee <HAL_TIM_ConfigClockSource+0x1aa>
 8007924:	2b30      	cmp	r3, #48	; 0x30
 8007926:	d86b      	bhi.n	8007a00 <HAL_TIM_ConfigClockSource+0x1bc>
 8007928:	2b20      	cmp	r3, #32
 800792a:	d060      	beq.n	80079ee <HAL_TIM_ConfigClockSource+0x1aa>
 800792c:	2b20      	cmp	r3, #32
 800792e:	d867      	bhi.n	8007a00 <HAL_TIM_ConfigClockSource+0x1bc>
 8007930:	2b00      	cmp	r3, #0
 8007932:	d05c      	beq.n	80079ee <HAL_TIM_ConfigClockSource+0x1aa>
 8007934:	2b10      	cmp	r3, #16
 8007936:	d05a      	beq.n	80079ee <HAL_TIM_ConfigClockSource+0x1aa>
 8007938:	e062      	b.n	8007a00 <HAL_TIM_ConfigClockSource+0x1bc>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      /* Configure the ETR Clock source */
      TIM_ETR_SetConfig(htim->Instance,
 800793a:	687b      	ldr	r3, [r7, #4]
 800793c:	6818      	ldr	r0, [r3, #0]
 800793e:	683b      	ldr	r3, [r7, #0]
 8007940:	6899      	ldr	r1, [r3, #8]
 8007942:	683b      	ldr	r3, [r7, #0]
 8007944:	685a      	ldr	r2, [r3, #4]
 8007946:	683b      	ldr	r3, [r7, #0]
 8007948:	68db      	ldr	r3, [r3, #12]
 800794a:	f000 fc89 	bl	8008260 <TIM_ETR_SetConfig>
                        sClockSourceConfig->ClockPrescaler,
                        sClockSourceConfig->ClockPolarity,
                        sClockSourceConfig->ClockFilter);

      /* Select the External clock mode1 and the ETRF trigger */
      tmpsmcr = htim->Instance->SMCR;
 800794e:	687b      	ldr	r3, [r7, #4]
 8007950:	681b      	ldr	r3, [r3, #0]
 8007952:	689b      	ldr	r3, [r3, #8]
 8007954:	60bb      	str	r3, [r7, #8]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 8007956:	68bb      	ldr	r3, [r7, #8]
 8007958:	f043 0377 	orr.w	r3, r3, #119	; 0x77
 800795c:	60bb      	str	r3, [r7, #8]
      /* Write to TIMx SMCR */
      htim->Instance->SMCR = tmpsmcr;
 800795e:	687b      	ldr	r3, [r7, #4]
 8007960:	681b      	ldr	r3, [r3, #0]
 8007962:	68ba      	ldr	r2, [r7, #8]
 8007964:	609a      	str	r2, [r3, #8]
      break;
 8007966:	e04f      	b.n	8007a08 <HAL_TIM_ConfigClockSource+0x1c4>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      /* Configure the ETR Clock source */
      TIM_ETR_SetConfig(htim->Instance,
 8007968:	687b      	ldr	r3, [r7, #4]
 800796a:	6818      	ldr	r0, [r3, #0]
 800796c:	683b      	ldr	r3, [r7, #0]
 800796e:	6899      	ldr	r1, [r3, #8]
 8007970:	683b      	ldr	r3, [r7, #0]
 8007972:	685a      	ldr	r2, [r3, #4]
 8007974:	683b      	ldr	r3, [r7, #0]
 8007976:	68db      	ldr	r3, [r3, #12]
 8007978:	f000 fc72 	bl	8008260 <TIM_ETR_SetConfig>
                        sClockSourceConfig->ClockPrescaler,
                        sClockSourceConfig->ClockPolarity,
                        sClockSourceConfig->ClockFilter);
      /* Enable the External clock mode2 */
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 800797c:	687b      	ldr	r3, [r7, #4]
 800797e:	681b      	ldr	r3, [r3, #0]
 8007980:	689a      	ldr	r2, [r3, #8]
 8007982:	687b      	ldr	r3, [r7, #4]
 8007984:	681b      	ldr	r3, [r3, #0]
 8007986:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800798a:	609a      	str	r2, [r3, #8]
      break;
 800798c:	e03c      	b.n	8007a08 <HAL_TIM_ConfigClockSource+0x1c4>

      /* Check TI1 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI1_ConfigInputStage(htim->Instance,
 800798e:	687b      	ldr	r3, [r7, #4]
 8007990:	6818      	ldr	r0, [r3, #0]
 8007992:	683b      	ldr	r3, [r7, #0]
 8007994:	6859      	ldr	r1, [r3, #4]
 8007996:	683b      	ldr	r3, [r7, #0]
 8007998:	68db      	ldr	r3, [r3, #12]
 800799a:	461a      	mov	r2, r3
 800799c:	f000 fbe2 	bl	8008164 <TIM_TI1_ConfigInputStage>
                               sClockSourceConfig->ClockPolarity,
                               sClockSourceConfig->ClockFilter);
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
 80079a0:	687b      	ldr	r3, [r7, #4]
 80079a2:	681b      	ldr	r3, [r3, #0]
 80079a4:	2150      	movs	r1, #80	; 0x50
 80079a6:	4618      	mov	r0, r3
 80079a8:	f000 fc3c 	bl	8008224 <TIM_ITRx_SetConfig>
      break;
 80079ac:	e02c      	b.n	8007a08 <HAL_TIM_ConfigClockSource+0x1c4>

      /* Check TI2 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI2_ConfigInputStage(htim->Instance,
 80079ae:	687b      	ldr	r3, [r7, #4]
 80079b0:	6818      	ldr	r0, [r3, #0]
 80079b2:	683b      	ldr	r3, [r7, #0]
 80079b4:	6859      	ldr	r1, [r3, #4]
 80079b6:	683b      	ldr	r3, [r7, #0]
 80079b8:	68db      	ldr	r3, [r3, #12]
 80079ba:	461a      	mov	r2, r3
 80079bc:	f000 fc01 	bl	80081c2 <TIM_TI2_ConfigInputStage>
                               sClockSourceConfig->ClockPolarity,
                               sClockSourceConfig->ClockFilter);
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
 80079c0:	687b      	ldr	r3, [r7, #4]
 80079c2:	681b      	ldr	r3, [r3, #0]
 80079c4:	2160      	movs	r1, #96	; 0x60
 80079c6:	4618      	mov	r0, r3
 80079c8:	f000 fc2c 	bl	8008224 <TIM_ITRx_SetConfig>
      break;
 80079cc:	e01c      	b.n	8007a08 <HAL_TIM_ConfigClockSource+0x1c4>

      /* Check TI1 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI1_ConfigInputStage(htim->Instance,
 80079ce:	687b      	ldr	r3, [r7, #4]
 80079d0:	6818      	ldr	r0, [r3, #0]
 80079d2:	683b      	ldr	r3, [r7, #0]
 80079d4:	6859      	ldr	r1, [r3, #4]
 80079d6:	683b      	ldr	r3, [r7, #0]
 80079d8:	68db      	ldr	r3, [r3, #12]
 80079da:	461a      	mov	r2, r3
 80079dc:	f000 fbc2 	bl	8008164 <TIM_TI1_ConfigInputStage>
                               sClockSourceConfig->ClockPolarity,
                               sClockSourceConfig->ClockFilter);
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
 80079e0:	687b      	ldr	r3, [r7, #4]
 80079e2:	681b      	ldr	r3, [r3, #0]
 80079e4:	2140      	movs	r1, #64	; 0x40
 80079e6:	4618      	mov	r0, r3
 80079e8:	f000 fc1c 	bl	8008224 <TIM_ITRx_SetConfig>
      break;
 80079ec:	e00c      	b.n	8007a08 <HAL_TIM_ConfigClockSource+0x1c4>
    case TIM_CLOCKSOURCE_ITR8:
    {
      /* Check whether or not the timer instance supports internal trigger input */
      assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));

      TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
 80079ee:	687b      	ldr	r3, [r7, #4]
 80079f0:	681a      	ldr	r2, [r3, #0]
 80079f2:	683b      	ldr	r3, [r7, #0]
 80079f4:	681b      	ldr	r3, [r3, #0]
 80079f6:	4619      	mov	r1, r3
 80079f8:	4610      	mov	r0, r2
 80079fa:	f000 fc13 	bl	8008224 <TIM_ITRx_SetConfig>
      break;
 80079fe:	e003      	b.n	8007a08 <HAL_TIM_ConfigClockSource+0x1c4>
    }

    default:
      status = HAL_ERROR;
 8007a00:	2301      	movs	r3, #1
 8007a02:	73fb      	strb	r3, [r7, #15]
      break;
 8007a04:	e000      	b.n	8007a08 <HAL_TIM_ConfigClockSource+0x1c4>
      break;
 8007a06:	bf00      	nop
  }
  htim->State = HAL_TIM_STATE_READY;
 8007a08:	687b      	ldr	r3, [r7, #4]
 8007a0a:	2201      	movs	r2, #1
 8007a0c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  __HAL_UNLOCK(htim);
 8007a10:	687b      	ldr	r3, [r7, #4]
 8007a12:	2200      	movs	r2, #0
 8007a14:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return status;
 8007a18:	7bfb      	ldrb	r3, [r7, #15]
}
 8007a1a:	4618      	mov	r0, r3
 8007a1c:	3710      	adds	r7, #16
 8007a1e:	46bd      	mov	sp, r7
 8007a20:	bd80      	pop	{r7, pc}
 8007a22:	bf00      	nop
 8007a24:	ffceff88 	.word	0xffceff88
 8007a28:	00100040 	.word	0x00100040
 8007a2c:	00100030 	.word	0x00100030
 8007a30:	00100020 	.word	0x00100020

08007a34 <HAL_TIM_OC_DelayElapsedCallback>:
  * @brief  Output Compare callback in non-blocking mode
  * @param  htim TIM OC handle
  * @retval None
  */
__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
{
 8007a34:	b480      	push	{r7}
 8007a36:	b083      	sub	sp, #12
 8007a38:	af00      	add	r7, sp, #0
 8007a3a:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   */
}
 8007a3c:	bf00      	nop
 8007a3e:	370c      	adds	r7, #12
 8007a40:	46bd      	mov	sp, r7
 8007a42:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007a46:	4770      	bx	lr

08007a48 <HAL_TIM_IC_CaptureCallback>:
  * @brief  Input Capture callback in non-blocking mode
  * @param  htim TIM IC handle
  * @retval None
  */
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
 8007a48:	b480      	push	{r7}
 8007a4a:	b083      	sub	sp, #12
 8007a4c:	af00      	add	r7, sp, #0
 8007a4e:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */
}
 8007a50:	bf00      	nop
 8007a52:	370c      	adds	r7, #12
 8007a54:	46bd      	mov	sp, r7
 8007a56:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007a5a:	4770      	bx	lr

08007a5c <HAL_TIM_PWM_PulseFinishedCallback>:
  * @brief  PWM Pulse finished callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
{
 8007a5c:	b480      	push	{r7}
 8007a5e:	b083      	sub	sp, #12
 8007a60:	af00      	add	r7, sp, #0
 8007a62:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   */
}
 8007a64:	bf00      	nop
 8007a66:	370c      	adds	r7, #12
 8007a68:	46bd      	mov	sp, r7
 8007a6a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007a6e:	4770      	bx	lr

08007a70 <HAL_TIM_TriggerCallback>:
  * @brief  Hall Trigger detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
{
 8007a70:	b480      	push	{r7}
 8007a72:	b083      	sub	sp, #12
 8007a74:	af00      	add	r7, sp, #0
 8007a76:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */
}
 8007a78:	bf00      	nop
 8007a7a:	370c      	adds	r7, #12
 8007a7c:	46bd      	mov	sp, r7
 8007a7e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007a82:	4770      	bx	lr

08007a84 <TIM_Base_SetConfig>:
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
 8007a84:	b480      	push	{r7}
 8007a86:	b085      	sub	sp, #20
 8007a88:	af00      	add	r7, sp, #0
 8007a8a:	6078      	str	r0, [r7, #4]
 8007a8c:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
 8007a8e:	687b      	ldr	r3, [r7, #4]
 8007a90:	681b      	ldr	r3, [r3, #0]
 8007a92:	60fb      	str	r3, [r7, #12]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8007a94:	687b      	ldr	r3, [r7, #4]
 8007a96:	4a40      	ldr	r2, [pc, #256]	; (8007b98 <TIM_Base_SetConfig+0x114>)
 8007a98:	4293      	cmp	r3, r2
 8007a9a:	d013      	beq.n	8007ac4 <TIM_Base_SetConfig+0x40>
 8007a9c:	687b      	ldr	r3, [r7, #4]
 8007a9e:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8007aa2:	d00f      	beq.n	8007ac4 <TIM_Base_SetConfig+0x40>
 8007aa4:	687b      	ldr	r3, [r7, #4]
 8007aa6:	4a3d      	ldr	r2, [pc, #244]	; (8007b9c <TIM_Base_SetConfig+0x118>)
 8007aa8:	4293      	cmp	r3, r2
 8007aaa:	d00b      	beq.n	8007ac4 <TIM_Base_SetConfig+0x40>
 8007aac:	687b      	ldr	r3, [r7, #4]
 8007aae:	4a3c      	ldr	r2, [pc, #240]	; (8007ba0 <TIM_Base_SetConfig+0x11c>)
 8007ab0:	4293      	cmp	r3, r2
 8007ab2:	d007      	beq.n	8007ac4 <TIM_Base_SetConfig+0x40>
 8007ab4:	687b      	ldr	r3, [r7, #4]
 8007ab6:	4a3b      	ldr	r2, [pc, #236]	; (8007ba4 <TIM_Base_SetConfig+0x120>)
 8007ab8:	4293      	cmp	r3, r2
 8007aba:	d003      	beq.n	8007ac4 <TIM_Base_SetConfig+0x40>
 8007abc:	687b      	ldr	r3, [r7, #4]
 8007abe:	4a3a      	ldr	r2, [pc, #232]	; (8007ba8 <TIM_Base_SetConfig+0x124>)
 8007ac0:	4293      	cmp	r3, r2
 8007ac2:	d108      	bne.n	8007ad6 <TIM_Base_SetConfig+0x52>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8007ac4:	68fb      	ldr	r3, [r7, #12]
 8007ac6:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8007aca:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= Structure->CounterMode;
 8007acc:	683b      	ldr	r3, [r7, #0]
 8007ace:	685b      	ldr	r3, [r3, #4]
 8007ad0:	68fa      	ldr	r2, [r7, #12]
 8007ad2:	4313      	orrs	r3, r2
 8007ad4:	60fb      	str	r3, [r7, #12]
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8007ad6:	687b      	ldr	r3, [r7, #4]
 8007ad8:	4a2f      	ldr	r2, [pc, #188]	; (8007b98 <TIM_Base_SetConfig+0x114>)
 8007ada:	4293      	cmp	r3, r2
 8007adc:	d01f      	beq.n	8007b1e <TIM_Base_SetConfig+0x9a>
 8007ade:	687b      	ldr	r3, [r7, #4]
 8007ae0:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8007ae4:	d01b      	beq.n	8007b1e <TIM_Base_SetConfig+0x9a>
 8007ae6:	687b      	ldr	r3, [r7, #4]
 8007ae8:	4a2c      	ldr	r2, [pc, #176]	; (8007b9c <TIM_Base_SetConfig+0x118>)
 8007aea:	4293      	cmp	r3, r2
 8007aec:	d017      	beq.n	8007b1e <TIM_Base_SetConfig+0x9a>
 8007aee:	687b      	ldr	r3, [r7, #4]
 8007af0:	4a2b      	ldr	r2, [pc, #172]	; (8007ba0 <TIM_Base_SetConfig+0x11c>)
 8007af2:	4293      	cmp	r3, r2
 8007af4:	d013      	beq.n	8007b1e <TIM_Base_SetConfig+0x9a>
 8007af6:	687b      	ldr	r3, [r7, #4]
 8007af8:	4a2a      	ldr	r2, [pc, #168]	; (8007ba4 <TIM_Base_SetConfig+0x120>)
 8007afa:	4293      	cmp	r3, r2
 8007afc:	d00f      	beq.n	8007b1e <TIM_Base_SetConfig+0x9a>
 8007afe:	687b      	ldr	r3, [r7, #4]
 8007b00:	4a29      	ldr	r2, [pc, #164]	; (8007ba8 <TIM_Base_SetConfig+0x124>)
 8007b02:	4293      	cmp	r3, r2
 8007b04:	d00b      	beq.n	8007b1e <TIM_Base_SetConfig+0x9a>
 8007b06:	687b      	ldr	r3, [r7, #4]
 8007b08:	4a28      	ldr	r2, [pc, #160]	; (8007bac <TIM_Base_SetConfig+0x128>)
 8007b0a:	4293      	cmp	r3, r2
 8007b0c:	d007      	beq.n	8007b1e <TIM_Base_SetConfig+0x9a>
 8007b0e:	687b      	ldr	r3, [r7, #4]
 8007b10:	4a27      	ldr	r2, [pc, #156]	; (8007bb0 <TIM_Base_SetConfig+0x12c>)
 8007b12:	4293      	cmp	r3, r2
 8007b14:	d003      	beq.n	8007b1e <TIM_Base_SetConfig+0x9a>
 8007b16:	687b      	ldr	r3, [r7, #4]
 8007b18:	4a26      	ldr	r2, [pc, #152]	; (8007bb4 <TIM_Base_SetConfig+0x130>)
 8007b1a:	4293      	cmp	r3, r2
 8007b1c:	d108      	bne.n	8007b30 <TIM_Base_SetConfig+0xac>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 8007b1e:	68fb      	ldr	r3, [r7, #12]
 8007b20:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8007b24:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8007b26:	683b      	ldr	r3, [r7, #0]
 8007b28:	68db      	ldr	r3, [r3, #12]
 8007b2a:	68fa      	ldr	r2, [r7, #12]
 8007b2c:	4313      	orrs	r3, r2
 8007b2e:	60fb      	str	r3, [r7, #12]
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8007b30:	68fb      	ldr	r3, [r7, #12]
 8007b32:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 8007b36:	683b      	ldr	r3, [r7, #0]
 8007b38:	695b      	ldr	r3, [r3, #20]
 8007b3a:	4313      	orrs	r3, r2
 8007b3c:	60fb      	str	r3, [r7, #12]

  TIMx->CR1 = tmpcr1;
 8007b3e:	687b      	ldr	r3, [r7, #4]
 8007b40:	68fa      	ldr	r2, [r7, #12]
 8007b42:	601a      	str	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8007b44:	683b      	ldr	r3, [r7, #0]
 8007b46:	689a      	ldr	r2, [r3, #8]
 8007b48:	687b      	ldr	r3, [r7, #4]
 8007b4a:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 8007b4c:	683b      	ldr	r3, [r7, #0]
 8007b4e:	681a      	ldr	r2, [r3, #0]
 8007b50:	687b      	ldr	r3, [r7, #4]
 8007b52:	629a      	str	r2, [r3, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8007b54:	687b      	ldr	r3, [r7, #4]
 8007b56:	4a10      	ldr	r2, [pc, #64]	; (8007b98 <TIM_Base_SetConfig+0x114>)
 8007b58:	4293      	cmp	r3, r2
 8007b5a:	d00f      	beq.n	8007b7c <TIM_Base_SetConfig+0xf8>
 8007b5c:	687b      	ldr	r3, [r7, #4]
 8007b5e:	4a12      	ldr	r2, [pc, #72]	; (8007ba8 <TIM_Base_SetConfig+0x124>)
 8007b60:	4293      	cmp	r3, r2
 8007b62:	d00b      	beq.n	8007b7c <TIM_Base_SetConfig+0xf8>
 8007b64:	687b      	ldr	r3, [r7, #4]
 8007b66:	4a11      	ldr	r2, [pc, #68]	; (8007bac <TIM_Base_SetConfig+0x128>)
 8007b68:	4293      	cmp	r3, r2
 8007b6a:	d007      	beq.n	8007b7c <TIM_Base_SetConfig+0xf8>
 8007b6c:	687b      	ldr	r3, [r7, #4]
 8007b6e:	4a10      	ldr	r2, [pc, #64]	; (8007bb0 <TIM_Base_SetConfig+0x12c>)
 8007b70:	4293      	cmp	r3, r2
 8007b72:	d003      	beq.n	8007b7c <TIM_Base_SetConfig+0xf8>
 8007b74:	687b      	ldr	r3, [r7, #4]
 8007b76:	4a0f      	ldr	r2, [pc, #60]	; (8007bb4 <TIM_Base_SetConfig+0x130>)
 8007b78:	4293      	cmp	r3, r2
 8007b7a:	d103      	bne.n	8007b84 <TIM_Base_SetConfig+0x100>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 8007b7c:	683b      	ldr	r3, [r7, #0]
 8007b7e:	691a      	ldr	r2, [r3, #16]
 8007b80:	687b      	ldr	r3, [r7, #4]
 8007b82:	631a      	str	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 8007b84:	687b      	ldr	r3, [r7, #4]
 8007b86:	2201      	movs	r2, #1
 8007b88:	615a      	str	r2, [r3, #20]
}
 8007b8a:	bf00      	nop
 8007b8c:	3714      	adds	r7, #20
 8007b8e:	46bd      	mov	sp, r7
 8007b90:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007b94:	4770      	bx	lr
 8007b96:	bf00      	nop
 8007b98:	40010000 	.word	0x40010000
 8007b9c:	40000400 	.word	0x40000400
 8007ba0:	40000800 	.word	0x40000800
 8007ba4:	40000c00 	.word	0x40000c00
 8007ba8:	40010400 	.word	0x40010400
 8007bac:	40014000 	.word	0x40014000
 8007bb0:	40014400 	.word	0x40014400
 8007bb4:	40014800 	.word	0x40014800

08007bb8 <TIM_OC1_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8007bb8:	b480      	push	{r7}
 8007bba:	b087      	sub	sp, #28
 8007bbc:	af00      	add	r7, sp, #0
 8007bbe:	6078      	str	r0, [r7, #4]
 8007bc0:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8007bc2:	687b      	ldr	r3, [r7, #4]
 8007bc4:	6a1b      	ldr	r3, [r3, #32]
 8007bc6:	f023 0201 	bic.w	r2, r3, #1
 8007bca:	687b      	ldr	r3, [r7, #4]
 8007bcc:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8007bce:	687b      	ldr	r3, [r7, #4]
 8007bd0:	6a1b      	ldr	r3, [r3, #32]
 8007bd2:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8007bd4:	687b      	ldr	r3, [r7, #4]
 8007bd6:	685b      	ldr	r3, [r3, #4]
 8007bd8:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8007bda:	687b      	ldr	r3, [r7, #4]
 8007bdc:	699b      	ldr	r3, [r3, #24]
 8007bde:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
 8007be0:	68fa      	ldr	r2, [r7, #12]
 8007be2:	4b37      	ldr	r3, [pc, #220]	; (8007cc0 <TIM_OC1_SetConfig+0x108>)
 8007be4:	4013      	ands	r3, r2
 8007be6:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 8007be8:	68fb      	ldr	r3, [r7, #12]
 8007bea:	f023 0303 	bic.w	r3, r3, #3
 8007bee:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8007bf0:	683b      	ldr	r3, [r7, #0]
 8007bf2:	681b      	ldr	r3, [r3, #0]
 8007bf4:	68fa      	ldr	r2, [r7, #12]
 8007bf6:	4313      	orrs	r3, r2
 8007bf8:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
 8007bfa:	697b      	ldr	r3, [r7, #20]
 8007bfc:	f023 0302 	bic.w	r3, r3, #2
 8007c00:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 8007c02:	683b      	ldr	r3, [r7, #0]
 8007c04:	689b      	ldr	r3, [r3, #8]
 8007c06:	697a      	ldr	r2, [r7, #20]
 8007c08:	4313      	orrs	r3, r2
 8007c0a:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 8007c0c:	687b      	ldr	r3, [r7, #4]
 8007c0e:	4a2d      	ldr	r2, [pc, #180]	; (8007cc4 <TIM_OC1_SetConfig+0x10c>)
 8007c10:	4293      	cmp	r3, r2
 8007c12:	d00f      	beq.n	8007c34 <TIM_OC1_SetConfig+0x7c>
 8007c14:	687b      	ldr	r3, [r7, #4]
 8007c16:	4a2c      	ldr	r2, [pc, #176]	; (8007cc8 <TIM_OC1_SetConfig+0x110>)
 8007c18:	4293      	cmp	r3, r2
 8007c1a:	d00b      	beq.n	8007c34 <TIM_OC1_SetConfig+0x7c>
 8007c1c:	687b      	ldr	r3, [r7, #4]
 8007c1e:	4a2b      	ldr	r2, [pc, #172]	; (8007ccc <TIM_OC1_SetConfig+0x114>)
 8007c20:	4293      	cmp	r3, r2
 8007c22:	d007      	beq.n	8007c34 <TIM_OC1_SetConfig+0x7c>
 8007c24:	687b      	ldr	r3, [r7, #4]
 8007c26:	4a2a      	ldr	r2, [pc, #168]	; (8007cd0 <TIM_OC1_SetConfig+0x118>)
 8007c28:	4293      	cmp	r3, r2
 8007c2a:	d003      	beq.n	8007c34 <TIM_OC1_SetConfig+0x7c>
 8007c2c:	687b      	ldr	r3, [r7, #4]
 8007c2e:	4a29      	ldr	r2, [pc, #164]	; (8007cd4 <TIM_OC1_SetConfig+0x11c>)
 8007c30:	4293      	cmp	r3, r2
 8007c32:	d10c      	bne.n	8007c4e <TIM_OC1_SetConfig+0x96>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
 8007c34:	697b      	ldr	r3, [r7, #20]
 8007c36:	f023 0308 	bic.w	r3, r3, #8
 8007c3a:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 8007c3c:	683b      	ldr	r3, [r7, #0]
 8007c3e:	68db      	ldr	r3, [r3, #12]
 8007c40:	697a      	ldr	r2, [r7, #20]
 8007c42:	4313      	orrs	r3, r2
 8007c44:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
 8007c46:	697b      	ldr	r3, [r7, #20]
 8007c48:	f023 0304 	bic.w	r3, r3, #4
 8007c4c:	617b      	str	r3, [r7, #20]
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8007c4e:	687b      	ldr	r3, [r7, #4]
 8007c50:	4a1c      	ldr	r2, [pc, #112]	; (8007cc4 <TIM_OC1_SetConfig+0x10c>)
 8007c52:	4293      	cmp	r3, r2
 8007c54:	d00f      	beq.n	8007c76 <TIM_OC1_SetConfig+0xbe>
 8007c56:	687b      	ldr	r3, [r7, #4]
 8007c58:	4a1b      	ldr	r2, [pc, #108]	; (8007cc8 <TIM_OC1_SetConfig+0x110>)
 8007c5a:	4293      	cmp	r3, r2
 8007c5c:	d00b      	beq.n	8007c76 <TIM_OC1_SetConfig+0xbe>
 8007c5e:	687b      	ldr	r3, [r7, #4]
 8007c60:	4a1a      	ldr	r2, [pc, #104]	; (8007ccc <TIM_OC1_SetConfig+0x114>)
 8007c62:	4293      	cmp	r3, r2
 8007c64:	d007      	beq.n	8007c76 <TIM_OC1_SetConfig+0xbe>
 8007c66:	687b      	ldr	r3, [r7, #4]
 8007c68:	4a19      	ldr	r2, [pc, #100]	; (8007cd0 <TIM_OC1_SetConfig+0x118>)
 8007c6a:	4293      	cmp	r3, r2
 8007c6c:	d003      	beq.n	8007c76 <TIM_OC1_SetConfig+0xbe>
 8007c6e:	687b      	ldr	r3, [r7, #4]
 8007c70:	4a18      	ldr	r2, [pc, #96]	; (8007cd4 <TIM_OC1_SetConfig+0x11c>)
 8007c72:	4293      	cmp	r3, r2
 8007c74:	d111      	bne.n	8007c9a <TIM_OC1_SetConfig+0xe2>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
 8007c76:	693b      	ldr	r3, [r7, #16]
 8007c78:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8007c7c:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS1N;
 8007c7e:	693b      	ldr	r3, [r7, #16]
 8007c80:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8007c84:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
 8007c86:	683b      	ldr	r3, [r7, #0]
 8007c88:	695b      	ldr	r3, [r3, #20]
 8007c8a:	693a      	ldr	r2, [r7, #16]
 8007c8c:	4313      	orrs	r3, r2
 8007c8e:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 8007c90:	683b      	ldr	r3, [r7, #0]
 8007c92:	699b      	ldr	r3, [r3, #24]
 8007c94:	693a      	ldr	r2, [r7, #16]
 8007c96:	4313      	orrs	r3, r2
 8007c98:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8007c9a:	687b      	ldr	r3, [r7, #4]
 8007c9c:	693a      	ldr	r2, [r7, #16]
 8007c9e:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8007ca0:	687b      	ldr	r3, [r7, #4]
 8007ca2:	68fa      	ldr	r2, [r7, #12]
 8007ca4:	619a      	str	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 8007ca6:	683b      	ldr	r3, [r7, #0]
 8007ca8:	685a      	ldr	r2, [r3, #4]
 8007caa:	687b      	ldr	r3, [r7, #4]
 8007cac:	635a      	str	r2, [r3, #52]	; 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8007cae:	687b      	ldr	r3, [r7, #4]
 8007cb0:	697a      	ldr	r2, [r7, #20]
 8007cb2:	621a      	str	r2, [r3, #32]
}
 8007cb4:	bf00      	nop
 8007cb6:	371c      	adds	r7, #28
 8007cb8:	46bd      	mov	sp, r7
 8007cba:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007cbe:	4770      	bx	lr
 8007cc0:	fffeff8f 	.word	0xfffeff8f
 8007cc4:	40010000 	.word	0x40010000
 8007cc8:	40010400 	.word	0x40010400
 8007ccc:	40014000 	.word	0x40014000
 8007cd0:	40014400 	.word	0x40014400
 8007cd4:	40014800 	.word	0x40014800

08007cd8 <TIM_OC2_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8007cd8:	b480      	push	{r7}
 8007cda:	b087      	sub	sp, #28
 8007cdc:	af00      	add	r7, sp, #0
 8007cde:	6078      	str	r0, [r7, #4]
 8007ce0:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8007ce2:	687b      	ldr	r3, [r7, #4]
 8007ce4:	6a1b      	ldr	r3, [r3, #32]
 8007ce6:	f023 0210 	bic.w	r2, r3, #16
 8007cea:	687b      	ldr	r3, [r7, #4]
 8007cec:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8007cee:	687b      	ldr	r3, [r7, #4]
 8007cf0:	6a1b      	ldr	r3, [r3, #32]
 8007cf2:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8007cf4:	687b      	ldr	r3, [r7, #4]
 8007cf6:	685b      	ldr	r3, [r3, #4]
 8007cf8:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8007cfa:	687b      	ldr	r3, [r7, #4]
 8007cfc:	699b      	ldr	r3, [r3, #24]
 8007cfe:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR1_OC2M;
 8007d00:	68fa      	ldr	r2, [r7, #12]
 8007d02:	4b34      	ldr	r3, [pc, #208]	; (8007dd4 <TIM_OC2_SetConfig+0xfc>)
 8007d04:	4013      	ands	r3, r2
 8007d06:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 8007d08:	68fb      	ldr	r3, [r7, #12]
 8007d0a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8007d0e:	60fb      	str	r3, [r7, #12]

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8007d10:	683b      	ldr	r3, [r7, #0]
 8007d12:	681b      	ldr	r3, [r3, #0]
 8007d14:	021b      	lsls	r3, r3, #8
 8007d16:	68fa      	ldr	r2, [r7, #12]
 8007d18:	4313      	orrs	r3, r2
 8007d1a:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
 8007d1c:	697b      	ldr	r3, [r7, #20]
 8007d1e:	f023 0320 	bic.w	r3, r3, #32
 8007d22:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4U);
 8007d24:	683b      	ldr	r3, [r7, #0]
 8007d26:	689b      	ldr	r3, [r3, #8]
 8007d28:	011b      	lsls	r3, r3, #4
 8007d2a:	697a      	ldr	r2, [r7, #20]
 8007d2c:	4313      	orrs	r3, r2
 8007d2e:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 8007d30:	687b      	ldr	r3, [r7, #4]
 8007d32:	4a29      	ldr	r2, [pc, #164]	; (8007dd8 <TIM_OC2_SetConfig+0x100>)
 8007d34:	4293      	cmp	r3, r2
 8007d36:	d003      	beq.n	8007d40 <TIM_OC2_SetConfig+0x68>
 8007d38:	687b      	ldr	r3, [r7, #4]
 8007d3a:	4a28      	ldr	r2, [pc, #160]	; (8007ddc <TIM_OC2_SetConfig+0x104>)
 8007d3c:	4293      	cmp	r3, r2
 8007d3e:	d10d      	bne.n	8007d5c <TIM_OC2_SetConfig+0x84>
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC2NP;
 8007d40:	697b      	ldr	r3, [r7, #20]
 8007d42:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8007d46:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8007d48:	683b      	ldr	r3, [r7, #0]
 8007d4a:	68db      	ldr	r3, [r3, #12]
 8007d4c:	011b      	lsls	r3, r3, #4
 8007d4e:	697a      	ldr	r2, [r7, #20]
 8007d50:	4313      	orrs	r3, r2
 8007d52:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC2NE;
 8007d54:	697b      	ldr	r3, [r7, #20]
 8007d56:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8007d5a:	617b      	str	r3, [r7, #20]

  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8007d5c:	687b      	ldr	r3, [r7, #4]
 8007d5e:	4a1e      	ldr	r2, [pc, #120]	; (8007dd8 <TIM_OC2_SetConfig+0x100>)
 8007d60:	4293      	cmp	r3, r2
 8007d62:	d00f      	beq.n	8007d84 <TIM_OC2_SetConfig+0xac>
 8007d64:	687b      	ldr	r3, [r7, #4]
 8007d66:	4a1d      	ldr	r2, [pc, #116]	; (8007ddc <TIM_OC2_SetConfig+0x104>)
 8007d68:	4293      	cmp	r3, r2
 8007d6a:	d00b      	beq.n	8007d84 <TIM_OC2_SetConfig+0xac>
 8007d6c:	687b      	ldr	r3, [r7, #4]
 8007d6e:	4a1c      	ldr	r2, [pc, #112]	; (8007de0 <TIM_OC2_SetConfig+0x108>)
 8007d70:	4293      	cmp	r3, r2
 8007d72:	d007      	beq.n	8007d84 <TIM_OC2_SetConfig+0xac>
 8007d74:	687b      	ldr	r3, [r7, #4]
 8007d76:	4a1b      	ldr	r2, [pc, #108]	; (8007de4 <TIM_OC2_SetConfig+0x10c>)
 8007d78:	4293      	cmp	r3, r2
 8007d7a:	d003      	beq.n	8007d84 <TIM_OC2_SetConfig+0xac>
 8007d7c:	687b      	ldr	r3, [r7, #4]
 8007d7e:	4a1a      	ldr	r2, [pc, #104]	; (8007de8 <TIM_OC2_SetConfig+0x110>)
 8007d80:	4293      	cmp	r3, r2
 8007d82:	d113      	bne.n	8007dac <TIM_OC2_SetConfig+0xd4>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS2;
 8007d84:	693b      	ldr	r3, [r7, #16]
 8007d86:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8007d8a:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8007d8c:	693b      	ldr	r3, [r7, #16]
 8007d8e:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8007d92:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 2U);
 8007d94:	683b      	ldr	r3, [r7, #0]
 8007d96:	695b      	ldr	r3, [r3, #20]
 8007d98:	009b      	lsls	r3, r3, #2
 8007d9a:	693a      	ldr	r2, [r7, #16]
 8007d9c:	4313      	orrs	r3, r2
 8007d9e:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8007da0:	683b      	ldr	r3, [r7, #0]
 8007da2:	699b      	ldr	r3, [r3, #24]
 8007da4:	009b      	lsls	r3, r3, #2
 8007da6:	693a      	ldr	r2, [r7, #16]
 8007da8:	4313      	orrs	r3, r2
 8007daa:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8007dac:	687b      	ldr	r3, [r7, #4]
 8007dae:	693a      	ldr	r2, [r7, #16]
 8007db0:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8007db2:	687b      	ldr	r3, [r7, #4]
 8007db4:	68fa      	ldr	r2, [r7, #12]
 8007db6:	619a      	str	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR2 = OC_Config->Pulse;
 8007db8:	683b      	ldr	r3, [r7, #0]
 8007dba:	685a      	ldr	r2, [r3, #4]
 8007dbc:	687b      	ldr	r3, [r7, #4]
 8007dbe:	639a      	str	r2, [r3, #56]	; 0x38

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8007dc0:	687b      	ldr	r3, [r7, #4]
 8007dc2:	697a      	ldr	r2, [r7, #20]
 8007dc4:	621a      	str	r2, [r3, #32]
}
 8007dc6:	bf00      	nop
 8007dc8:	371c      	adds	r7, #28
 8007dca:	46bd      	mov	sp, r7
 8007dcc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007dd0:	4770      	bx	lr
 8007dd2:	bf00      	nop
 8007dd4:	feff8fff 	.word	0xfeff8fff
 8007dd8:	40010000 	.word	0x40010000
 8007ddc:	40010400 	.word	0x40010400
 8007de0:	40014000 	.word	0x40014000
 8007de4:	40014400 	.word	0x40014400
 8007de8:	40014800 	.word	0x40014800

08007dec <TIM_OC3_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8007dec:	b480      	push	{r7}
 8007dee:	b087      	sub	sp, #28
 8007df0:	af00      	add	r7, sp, #0
 8007df2:	6078      	str	r0, [r7, #4]
 8007df4:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8007df6:	687b      	ldr	r3, [r7, #4]
 8007df8:	6a1b      	ldr	r3, [r3, #32]
 8007dfa:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 8007dfe:	687b      	ldr	r3, [r7, #4]
 8007e00:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8007e02:	687b      	ldr	r3, [r7, #4]
 8007e04:	6a1b      	ldr	r3, [r3, #32]
 8007e06:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8007e08:	687b      	ldr	r3, [r7, #4]
 8007e0a:	685b      	ldr	r3, [r3, #4]
 8007e0c:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8007e0e:	687b      	ldr	r3, [r7, #4]
 8007e10:	69db      	ldr	r3, [r3, #28]
 8007e12:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
 8007e14:	68fa      	ldr	r2, [r7, #12]
 8007e16:	4b33      	ldr	r3, [pc, #204]	; (8007ee4 <TIM_OC3_SetConfig+0xf8>)
 8007e18:	4013      	ands	r3, r2
 8007e1a:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8007e1c:	68fb      	ldr	r3, [r7, #12]
 8007e1e:	f023 0303 	bic.w	r3, r3, #3
 8007e22:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8007e24:	683b      	ldr	r3, [r7, #0]
 8007e26:	681b      	ldr	r3, [r3, #0]
 8007e28:	68fa      	ldr	r2, [r7, #12]
 8007e2a:	4313      	orrs	r3, r2
 8007e2c:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
 8007e2e:	697b      	ldr	r3, [r7, #20]
 8007e30:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8007e34:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
 8007e36:	683b      	ldr	r3, [r7, #0]
 8007e38:	689b      	ldr	r3, [r3, #8]
 8007e3a:	021b      	lsls	r3, r3, #8
 8007e3c:	697a      	ldr	r2, [r7, #20]
 8007e3e:	4313      	orrs	r3, r2
 8007e40:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 8007e42:	687b      	ldr	r3, [r7, #4]
 8007e44:	4a28      	ldr	r2, [pc, #160]	; (8007ee8 <TIM_OC3_SetConfig+0xfc>)
 8007e46:	4293      	cmp	r3, r2
 8007e48:	d003      	beq.n	8007e52 <TIM_OC3_SetConfig+0x66>
 8007e4a:	687b      	ldr	r3, [r7, #4]
 8007e4c:	4a27      	ldr	r2, [pc, #156]	; (8007eec <TIM_OC3_SetConfig+0x100>)
 8007e4e:	4293      	cmp	r3, r2
 8007e50:	d10d      	bne.n	8007e6e <TIM_OC3_SetConfig+0x82>
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
 8007e52:	697b      	ldr	r3, [r7, #20]
 8007e54:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8007e58:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 8007e5a:	683b      	ldr	r3, [r7, #0]
 8007e5c:	68db      	ldr	r3, [r3, #12]
 8007e5e:	021b      	lsls	r3, r3, #8
 8007e60:	697a      	ldr	r2, [r7, #20]
 8007e62:	4313      	orrs	r3, r2
 8007e64:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
 8007e66:	697b      	ldr	r3, [r7, #20]
 8007e68:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8007e6c:	617b      	str	r3, [r7, #20]
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8007e6e:	687b      	ldr	r3, [r7, #4]
 8007e70:	4a1d      	ldr	r2, [pc, #116]	; (8007ee8 <TIM_OC3_SetConfig+0xfc>)
 8007e72:	4293      	cmp	r3, r2
 8007e74:	d00f      	beq.n	8007e96 <TIM_OC3_SetConfig+0xaa>
 8007e76:	687b      	ldr	r3, [r7, #4]
 8007e78:	4a1c      	ldr	r2, [pc, #112]	; (8007eec <TIM_OC3_SetConfig+0x100>)
 8007e7a:	4293      	cmp	r3, r2
 8007e7c:	d00b      	beq.n	8007e96 <TIM_OC3_SetConfig+0xaa>
 8007e7e:	687b      	ldr	r3, [r7, #4]
 8007e80:	4a1b      	ldr	r2, [pc, #108]	; (8007ef0 <TIM_OC3_SetConfig+0x104>)
 8007e82:	4293      	cmp	r3, r2
 8007e84:	d007      	beq.n	8007e96 <TIM_OC3_SetConfig+0xaa>
 8007e86:	687b      	ldr	r3, [r7, #4]
 8007e88:	4a1a      	ldr	r2, [pc, #104]	; (8007ef4 <TIM_OC3_SetConfig+0x108>)
 8007e8a:	4293      	cmp	r3, r2
 8007e8c:	d003      	beq.n	8007e96 <TIM_OC3_SetConfig+0xaa>
 8007e8e:	687b      	ldr	r3, [r7, #4]
 8007e90:	4a19      	ldr	r2, [pc, #100]	; (8007ef8 <TIM_OC3_SetConfig+0x10c>)
 8007e92:	4293      	cmp	r3, r2
 8007e94:	d113      	bne.n	8007ebe <TIM_OC3_SetConfig+0xd2>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
 8007e96:	693b      	ldr	r3, [r7, #16]
 8007e98:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8007e9c:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS3N;
 8007e9e:	693b      	ldr	r3, [r7, #16]
 8007ea0:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8007ea4:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
 8007ea6:	683b      	ldr	r3, [r7, #0]
 8007ea8:	695b      	ldr	r3, [r3, #20]
 8007eaa:	011b      	lsls	r3, r3, #4
 8007eac:	693a      	ldr	r2, [r7, #16]
 8007eae:	4313      	orrs	r3, r2
 8007eb0:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 8007eb2:	683b      	ldr	r3, [r7, #0]
 8007eb4:	699b      	ldr	r3, [r3, #24]
 8007eb6:	011b      	lsls	r3, r3, #4
 8007eb8:	693a      	ldr	r2, [r7, #16]
 8007eba:	4313      	orrs	r3, r2
 8007ebc:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8007ebe:	687b      	ldr	r3, [r7, #4]
 8007ec0:	693a      	ldr	r2, [r7, #16]
 8007ec2:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8007ec4:	687b      	ldr	r3, [r7, #4]
 8007ec6:	68fa      	ldr	r2, [r7, #12]
 8007ec8:	61da      	str	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 8007eca:	683b      	ldr	r3, [r7, #0]
 8007ecc:	685a      	ldr	r2, [r3, #4]
 8007ece:	687b      	ldr	r3, [r7, #4]
 8007ed0:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8007ed2:	687b      	ldr	r3, [r7, #4]
 8007ed4:	697a      	ldr	r2, [r7, #20]
 8007ed6:	621a      	str	r2, [r3, #32]
}
 8007ed8:	bf00      	nop
 8007eda:	371c      	adds	r7, #28
 8007edc:	46bd      	mov	sp, r7
 8007ede:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007ee2:	4770      	bx	lr
 8007ee4:	fffeff8f 	.word	0xfffeff8f
 8007ee8:	40010000 	.word	0x40010000
 8007eec:	40010400 	.word	0x40010400
 8007ef0:	40014000 	.word	0x40014000
 8007ef4:	40014400 	.word	0x40014400
 8007ef8:	40014800 	.word	0x40014800

08007efc <TIM_OC4_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8007efc:	b480      	push	{r7}
 8007efe:	b087      	sub	sp, #28
 8007f00:	af00      	add	r7, sp, #0
 8007f02:	6078      	str	r0, [r7, #4]
 8007f04:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8007f06:	687b      	ldr	r3, [r7, #4]
 8007f08:	6a1b      	ldr	r3, [r3, #32]
 8007f0a:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
 8007f0e:	687b      	ldr	r3, [r7, #4]
 8007f10:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8007f12:	687b      	ldr	r3, [r7, #4]
 8007f14:	6a1b      	ldr	r3, [r3, #32]
 8007f16:	613b      	str	r3, [r7, #16]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8007f18:	687b      	ldr	r3, [r7, #4]
 8007f1a:	685b      	ldr	r3, [r3, #4]
 8007f1c:	617b      	str	r3, [r7, #20]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8007f1e:	687b      	ldr	r3, [r7, #4]
 8007f20:	69db      	ldr	r3, [r3, #28]
 8007f22:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
 8007f24:	68fa      	ldr	r2, [r7, #12]
 8007f26:	4b24      	ldr	r3, [pc, #144]	; (8007fb8 <TIM_OC4_SetConfig+0xbc>)
 8007f28:	4013      	ands	r3, r2
 8007f2a:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 8007f2c:	68fb      	ldr	r3, [r7, #12]
 8007f2e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8007f32:	60fb      	str	r3, [r7, #12]

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8007f34:	683b      	ldr	r3, [r7, #0]
 8007f36:	681b      	ldr	r3, [r3, #0]
 8007f38:	021b      	lsls	r3, r3, #8
 8007f3a:	68fa      	ldr	r2, [r7, #12]
 8007f3c:	4313      	orrs	r3, r2
 8007f3e:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
 8007f40:	693b      	ldr	r3, [r7, #16]
 8007f42:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8007f46:	613b      	str	r3, [r7, #16]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 8007f48:	683b      	ldr	r3, [r7, #0]
 8007f4a:	689b      	ldr	r3, [r3, #8]
 8007f4c:	031b      	lsls	r3, r3, #12
 8007f4e:	693a      	ldr	r2, [r7, #16]
 8007f50:	4313      	orrs	r3, r2
 8007f52:	613b      	str	r3, [r7, #16]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8007f54:	687b      	ldr	r3, [r7, #4]
 8007f56:	4a19      	ldr	r2, [pc, #100]	; (8007fbc <TIM_OC4_SetConfig+0xc0>)
 8007f58:	4293      	cmp	r3, r2
 8007f5a:	d00f      	beq.n	8007f7c <TIM_OC4_SetConfig+0x80>
 8007f5c:	687b      	ldr	r3, [r7, #4]
 8007f5e:	4a18      	ldr	r2, [pc, #96]	; (8007fc0 <TIM_OC4_SetConfig+0xc4>)
 8007f60:	4293      	cmp	r3, r2
 8007f62:	d00b      	beq.n	8007f7c <TIM_OC4_SetConfig+0x80>
 8007f64:	687b      	ldr	r3, [r7, #4]
 8007f66:	4a17      	ldr	r2, [pc, #92]	; (8007fc4 <TIM_OC4_SetConfig+0xc8>)
 8007f68:	4293      	cmp	r3, r2
 8007f6a:	d007      	beq.n	8007f7c <TIM_OC4_SetConfig+0x80>
 8007f6c:	687b      	ldr	r3, [r7, #4]
 8007f6e:	4a16      	ldr	r2, [pc, #88]	; (8007fc8 <TIM_OC4_SetConfig+0xcc>)
 8007f70:	4293      	cmp	r3, r2
 8007f72:	d003      	beq.n	8007f7c <TIM_OC4_SetConfig+0x80>
 8007f74:	687b      	ldr	r3, [r7, #4]
 8007f76:	4a15      	ldr	r2, [pc, #84]	; (8007fcc <TIM_OC4_SetConfig+0xd0>)
 8007f78:	4293      	cmp	r3, r2
 8007f7a:	d109      	bne.n	8007f90 <TIM_OC4_SetConfig+0x94>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;
 8007f7c:	697b      	ldr	r3, [r7, #20]
 8007f7e:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8007f82:	617b      	str	r3, [r7, #20]

    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 8007f84:	683b      	ldr	r3, [r7, #0]
 8007f86:	695b      	ldr	r3, [r3, #20]
 8007f88:	019b      	lsls	r3, r3, #6
 8007f8a:	697a      	ldr	r2, [r7, #20]
 8007f8c:	4313      	orrs	r3, r2
 8007f8e:	617b      	str	r3, [r7, #20]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8007f90:	687b      	ldr	r3, [r7, #4]
 8007f92:	697a      	ldr	r2, [r7, #20]
 8007f94:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8007f96:	687b      	ldr	r3, [r7, #4]
 8007f98:	68fa      	ldr	r2, [r7, #12]
 8007f9a:	61da      	str	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 8007f9c:	683b      	ldr	r3, [r7, #0]
 8007f9e:	685a      	ldr	r2, [r3, #4]
 8007fa0:	687b      	ldr	r3, [r7, #4]
 8007fa2:	641a      	str	r2, [r3, #64]	; 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8007fa4:	687b      	ldr	r3, [r7, #4]
 8007fa6:	693a      	ldr	r2, [r7, #16]
 8007fa8:	621a      	str	r2, [r3, #32]
}
 8007faa:	bf00      	nop
 8007fac:	371c      	adds	r7, #28
 8007fae:	46bd      	mov	sp, r7
 8007fb0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007fb4:	4770      	bx	lr
 8007fb6:	bf00      	nop
 8007fb8:	feff8fff 	.word	0xfeff8fff
 8007fbc:	40010000 	.word	0x40010000
 8007fc0:	40010400 	.word	0x40010400
 8007fc4:	40014000 	.word	0x40014000
 8007fc8:	40014400 	.word	0x40014400
 8007fcc:	40014800 	.word	0x40014800

08007fd0 <TIM_OC5_SetConfig>:
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC5_SetConfig(TIM_TypeDef *TIMx,
                              TIM_OC_InitTypeDef *OC_Config)
{
 8007fd0:	b480      	push	{r7}
 8007fd2:	b087      	sub	sp, #28
 8007fd4:	af00      	add	r7, sp, #0
 8007fd6:	6078      	str	r0, [r7, #4]
 8007fd8:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC5E;
 8007fda:	687b      	ldr	r3, [r7, #4]
 8007fdc:	6a1b      	ldr	r3, [r3, #32]
 8007fde:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 8007fe2:	687b      	ldr	r3, [r7, #4]
 8007fe4:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8007fe6:	687b      	ldr	r3, [r7, #4]
 8007fe8:	6a1b      	ldr	r3, [r3, #32]
 8007fea:	613b      	str	r3, [r7, #16]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8007fec:	687b      	ldr	r3, [r7, #4]
 8007fee:	685b      	ldr	r3, [r3, #4]
 8007ff0:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 8007ff2:	687b      	ldr	r3, [r7, #4]
 8007ff4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8007ff6:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
 8007ff8:	68fa      	ldr	r2, [r7, #12]
 8007ffa:	4b21      	ldr	r3, [pc, #132]	; (8008080 <TIM_OC5_SetConfig+0xb0>)
 8007ffc:	4013      	ands	r3, r2
 8007ffe:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8008000:	683b      	ldr	r3, [r7, #0]
 8008002:	681b      	ldr	r3, [r3, #0]
 8008004:	68fa      	ldr	r2, [r7, #12]
 8008006:	4313      	orrs	r3, r2
 8008008:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC5P;
 800800a:	693b      	ldr	r3, [r7, #16]
 800800c:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8008010:	613b      	str	r3, [r7, #16]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 16U);
 8008012:	683b      	ldr	r3, [r7, #0]
 8008014:	689b      	ldr	r3, [r3, #8]
 8008016:	041b      	lsls	r3, r3, #16
 8008018:	693a      	ldr	r2, [r7, #16]
 800801a:	4313      	orrs	r3, r2
 800801c:	613b      	str	r3, [r7, #16]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800801e:	687b      	ldr	r3, [r7, #4]
 8008020:	4a18      	ldr	r2, [pc, #96]	; (8008084 <TIM_OC5_SetConfig+0xb4>)
 8008022:	4293      	cmp	r3, r2
 8008024:	d00f      	beq.n	8008046 <TIM_OC5_SetConfig+0x76>
 8008026:	687b      	ldr	r3, [r7, #4]
 8008028:	4a17      	ldr	r2, [pc, #92]	; (8008088 <TIM_OC5_SetConfig+0xb8>)
 800802a:	4293      	cmp	r3, r2
 800802c:	d00b      	beq.n	8008046 <TIM_OC5_SetConfig+0x76>
 800802e:	687b      	ldr	r3, [r7, #4]
 8008030:	4a16      	ldr	r2, [pc, #88]	; (800808c <TIM_OC5_SetConfig+0xbc>)
 8008032:	4293      	cmp	r3, r2
 8008034:	d007      	beq.n	8008046 <TIM_OC5_SetConfig+0x76>
 8008036:	687b      	ldr	r3, [r7, #4]
 8008038:	4a15      	ldr	r2, [pc, #84]	; (8008090 <TIM_OC5_SetConfig+0xc0>)
 800803a:	4293      	cmp	r3, r2
 800803c:	d003      	beq.n	8008046 <TIM_OC5_SetConfig+0x76>
 800803e:	687b      	ldr	r3, [r7, #4]
 8008040:	4a14      	ldr	r2, [pc, #80]	; (8008094 <TIM_OC5_SetConfig+0xc4>)
 8008042:	4293      	cmp	r3, r2
 8008044:	d109      	bne.n	800805a <TIM_OC5_SetConfig+0x8a>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS5;
 8008046:	697b      	ldr	r3, [r7, #20]
 8008048:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800804c:	617b      	str	r3, [r7, #20]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
 800804e:	683b      	ldr	r3, [r7, #0]
 8008050:	695b      	ldr	r3, [r3, #20]
 8008052:	021b      	lsls	r3, r3, #8
 8008054:	697a      	ldr	r2, [r7, #20]
 8008056:	4313      	orrs	r3, r2
 8008058:	617b      	str	r3, [r7, #20]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800805a:	687b      	ldr	r3, [r7, #4]
 800805c:	697a      	ldr	r2, [r7, #20]
 800805e:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 8008060:	687b      	ldr	r3, [r7, #4]
 8008062:	68fa      	ldr	r2, [r7, #12]
 8008064:	655a      	str	r2, [r3, #84]	; 0x54

  /* Set the Capture Compare Register value */
  TIMx->CCR5 = OC_Config->Pulse;
 8008066:	683b      	ldr	r3, [r7, #0]
 8008068:	685a      	ldr	r2, [r3, #4]
 800806a:	687b      	ldr	r3, [r7, #4]
 800806c:	659a      	str	r2, [r3, #88]	; 0x58

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800806e:	687b      	ldr	r3, [r7, #4]
 8008070:	693a      	ldr	r2, [r7, #16]
 8008072:	621a      	str	r2, [r3, #32]
}
 8008074:	bf00      	nop
 8008076:	371c      	adds	r7, #28
 8008078:	46bd      	mov	sp, r7
 800807a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800807e:	4770      	bx	lr
 8008080:	fffeff8f 	.word	0xfffeff8f
 8008084:	40010000 	.word	0x40010000
 8008088:	40010400 	.word	0x40010400
 800808c:	40014000 	.word	0x40014000
 8008090:	40014400 	.word	0x40014400
 8008094:	40014800 	.word	0x40014800

08008098 <TIM_OC6_SetConfig>:
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC6_SetConfig(TIM_TypeDef *TIMx,
                              TIM_OC_InitTypeDef *OC_Config)
{
 8008098:	b480      	push	{r7}
 800809a:	b087      	sub	sp, #28
 800809c:	af00      	add	r7, sp, #0
 800809e:	6078      	str	r0, [r7, #4]
 80080a0:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC6E;
 80080a2:	687b      	ldr	r3, [r7, #4]
 80080a4:	6a1b      	ldr	r3, [r3, #32]
 80080a6:	f423 1280 	bic.w	r2, r3, #1048576	; 0x100000
 80080aa:	687b      	ldr	r3, [r7, #4]
 80080ac:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80080ae:	687b      	ldr	r3, [r7, #4]
 80080b0:	6a1b      	ldr	r3, [r3, #32]
 80080b2:	613b      	str	r3, [r7, #16]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80080b4:	687b      	ldr	r3, [r7, #4]
 80080b6:	685b      	ldr	r3, [r3, #4]
 80080b8:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 80080ba:	687b      	ldr	r3, [r7, #4]
 80080bc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80080be:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
 80080c0:	68fa      	ldr	r2, [r7, #12]
 80080c2:	4b22      	ldr	r3, [pc, #136]	; (800814c <TIM_OC6_SetConfig+0xb4>)
 80080c4:	4013      	ands	r3, r2
 80080c6:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80080c8:	683b      	ldr	r3, [r7, #0]
 80080ca:	681b      	ldr	r3, [r3, #0]
 80080cc:	021b      	lsls	r3, r3, #8
 80080ce:	68fa      	ldr	r2, [r7, #12]
 80080d0:	4313      	orrs	r3, r2
 80080d2:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 80080d4:	693b      	ldr	r3, [r7, #16]
 80080d6:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 80080da:	613b      	str	r3, [r7, #16]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 20U);
 80080dc:	683b      	ldr	r3, [r7, #0]
 80080de:	689b      	ldr	r3, [r3, #8]
 80080e0:	051b      	lsls	r3, r3, #20
 80080e2:	693a      	ldr	r2, [r7, #16]
 80080e4:	4313      	orrs	r3, r2
 80080e6:	613b      	str	r3, [r7, #16]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 80080e8:	687b      	ldr	r3, [r7, #4]
 80080ea:	4a19      	ldr	r2, [pc, #100]	; (8008150 <TIM_OC6_SetConfig+0xb8>)
 80080ec:	4293      	cmp	r3, r2
 80080ee:	d00f      	beq.n	8008110 <TIM_OC6_SetConfig+0x78>
 80080f0:	687b      	ldr	r3, [r7, #4]
 80080f2:	4a18      	ldr	r2, [pc, #96]	; (8008154 <TIM_OC6_SetConfig+0xbc>)
 80080f4:	4293      	cmp	r3, r2
 80080f6:	d00b      	beq.n	8008110 <TIM_OC6_SetConfig+0x78>
 80080f8:	687b      	ldr	r3, [r7, #4]
 80080fa:	4a17      	ldr	r2, [pc, #92]	; (8008158 <TIM_OC6_SetConfig+0xc0>)
 80080fc:	4293      	cmp	r3, r2
 80080fe:	d007      	beq.n	8008110 <TIM_OC6_SetConfig+0x78>
 8008100:	687b      	ldr	r3, [r7, #4]
 8008102:	4a16      	ldr	r2, [pc, #88]	; (800815c <TIM_OC6_SetConfig+0xc4>)
 8008104:	4293      	cmp	r3, r2
 8008106:	d003      	beq.n	8008110 <TIM_OC6_SetConfig+0x78>
 8008108:	687b      	ldr	r3, [r7, #4]
 800810a:	4a15      	ldr	r2, [pc, #84]	; (8008160 <TIM_OC6_SetConfig+0xc8>)
 800810c:	4293      	cmp	r3, r2
 800810e:	d109      	bne.n	8008124 <TIM_OC6_SetConfig+0x8c>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS6;
 8008110:	697b      	ldr	r3, [r7, #20]
 8008112:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8008116:	617b      	str	r3, [r7, #20]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
 8008118:	683b      	ldr	r3, [r7, #0]
 800811a:	695b      	ldr	r3, [r3, #20]
 800811c:	029b      	lsls	r3, r3, #10
 800811e:	697a      	ldr	r2, [r7, #20]
 8008120:	4313      	orrs	r3, r2
 8008122:	617b      	str	r3, [r7, #20]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8008124:	687b      	ldr	r3, [r7, #4]
 8008126:	697a      	ldr	r2, [r7, #20]
 8008128:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 800812a:	687b      	ldr	r3, [r7, #4]
 800812c:	68fa      	ldr	r2, [r7, #12]
 800812e:	655a      	str	r2, [r3, #84]	; 0x54

  /* Set the Capture Compare Register value */
  TIMx->CCR6 = OC_Config->Pulse;
 8008130:	683b      	ldr	r3, [r7, #0]
 8008132:	685a      	ldr	r2, [r3, #4]
 8008134:	687b      	ldr	r3, [r7, #4]
 8008136:	65da      	str	r2, [r3, #92]	; 0x5c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8008138:	687b      	ldr	r3, [r7, #4]
 800813a:	693a      	ldr	r2, [r7, #16]
 800813c:	621a      	str	r2, [r3, #32]
}
 800813e:	bf00      	nop
 8008140:	371c      	adds	r7, #28
 8008142:	46bd      	mov	sp, r7
 8008144:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008148:	4770      	bx	lr
 800814a:	bf00      	nop
 800814c:	feff8fff 	.word	0xfeff8fff
 8008150:	40010000 	.word	0x40010000
 8008154:	40010400 	.word	0x40010400
 8008158:	40014000 	.word	0x40014000
 800815c:	40014400 	.word	0x40014400
 8008160:	40014800 	.word	0x40014800

08008164 <TIM_TI1_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
 8008164:	b480      	push	{r7}
 8008166:	b087      	sub	sp, #28
 8008168:	af00      	add	r7, sp, #0
 800816a:	60f8      	str	r0, [r7, #12]
 800816c:	60b9      	str	r1, [r7, #8]
 800816e:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
 8008170:	68fb      	ldr	r3, [r7, #12]
 8008172:	6a1b      	ldr	r3, [r3, #32]
 8008174:	617b      	str	r3, [r7, #20]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8008176:	68fb      	ldr	r3, [r7, #12]
 8008178:	6a1b      	ldr	r3, [r3, #32]
 800817a:	f023 0201 	bic.w	r2, r3, #1
 800817e:	68fb      	ldr	r3, [r7, #12]
 8008180:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 8008182:	68fb      	ldr	r3, [r7, #12]
 8008184:	699b      	ldr	r3, [r3, #24]
 8008186:	613b      	str	r3, [r7, #16]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8008188:	693b      	ldr	r3, [r7, #16]
 800818a:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800818e:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= (TIM_ICFilter << 4U);
 8008190:	687b      	ldr	r3, [r7, #4]
 8008192:	011b      	lsls	r3, r3, #4
 8008194:	693a      	ldr	r2, [r7, #16]
 8008196:	4313      	orrs	r3, r2
 8008198:	613b      	str	r3, [r7, #16]

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 800819a:	697b      	ldr	r3, [r7, #20]
 800819c:	f023 030a 	bic.w	r3, r3, #10
 80081a0:	617b      	str	r3, [r7, #20]
  tmpccer |= TIM_ICPolarity;
 80081a2:	697a      	ldr	r2, [r7, #20]
 80081a4:	68bb      	ldr	r3, [r7, #8]
 80081a6:	4313      	orrs	r3, r2
 80081a8:	617b      	str	r3, [r7, #20]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 80081aa:	68fb      	ldr	r3, [r7, #12]
 80081ac:	693a      	ldr	r2, [r7, #16]
 80081ae:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 80081b0:	68fb      	ldr	r3, [r7, #12]
 80081b2:	697a      	ldr	r2, [r7, #20]
 80081b4:	621a      	str	r2, [r3, #32]
}
 80081b6:	bf00      	nop
 80081b8:	371c      	adds	r7, #28
 80081ba:	46bd      	mov	sp, r7
 80081bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80081c0:	4770      	bx	lr

080081c2 <TIM_TI2_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
 80081c2:	b480      	push	{r7}
 80081c4:	b087      	sub	sp, #28
 80081c6:	af00      	add	r7, sp, #0
 80081c8:	60f8      	str	r0, [r7, #12]
 80081ca:	60b9      	str	r1, [r7, #8]
 80081cc:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 80081ce:	68fb      	ldr	r3, [r7, #12]
 80081d0:	6a1b      	ldr	r3, [r3, #32]
 80081d2:	f023 0210 	bic.w	r2, r3, #16
 80081d6:	68fb      	ldr	r3, [r7, #12]
 80081d8:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 80081da:	68fb      	ldr	r3, [r7, #12]
 80081dc:	699b      	ldr	r3, [r3, #24]
 80081de:	617b      	str	r3, [r7, #20]
  tmpccer = TIMx->CCER;
 80081e0:	68fb      	ldr	r3, [r7, #12]
 80081e2:	6a1b      	ldr	r3, [r3, #32]
 80081e4:	613b      	str	r3, [r7, #16]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 80081e6:	697b      	ldr	r3, [r7, #20]
 80081e8:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000
 80081ec:	617b      	str	r3, [r7, #20]
  tmpccmr1 |= (TIM_ICFilter << 12U);
 80081ee:	687b      	ldr	r3, [r7, #4]
 80081f0:	031b      	lsls	r3, r3, #12
 80081f2:	697a      	ldr	r2, [r7, #20]
 80081f4:	4313      	orrs	r3, r2
 80081f6:	617b      	str	r3, [r7, #20]

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 80081f8:	693b      	ldr	r3, [r7, #16]
 80081fa:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 80081fe:	613b      	str	r3, [r7, #16]
  tmpccer |= (TIM_ICPolarity << 4U);
 8008200:	68bb      	ldr	r3, [r7, #8]
 8008202:	011b      	lsls	r3, r3, #4
 8008204:	693a      	ldr	r2, [r7, #16]
 8008206:	4313      	orrs	r3, r2
 8008208:	613b      	str	r3, [r7, #16]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 800820a:	68fb      	ldr	r3, [r7, #12]
 800820c:	697a      	ldr	r2, [r7, #20]
 800820e:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 8008210:	68fb      	ldr	r3, [r7, #12]
 8008212:	693a      	ldr	r2, [r7, #16]
 8008214:	621a      	str	r2, [r3, #32]
}
 8008216:	bf00      	nop
 8008218:	371c      	adds	r7, #28
 800821a:	46bd      	mov	sp, r7
 800821c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008220:	4770      	bx	lr
	...

08008224 <TIM_ITRx_SetConfig>:
  *       (*)  Value not defined in all devices.
  *
  * @retval None
  */
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
{
 8008224:	b480      	push	{r7}
 8008226:	b085      	sub	sp, #20
 8008228:	af00      	add	r7, sp, #0
 800822a:	6078      	str	r0, [r7, #4]
 800822c:	6039      	str	r1, [r7, #0]
  uint32_t tmpsmcr;

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 800822e:	687b      	ldr	r3, [r7, #4]
 8008230:	689b      	ldr	r3, [r3, #8]
 8008232:	60fb      	str	r3, [r7, #12]
  /* Reset the TS Bits */
  tmpsmcr &= ~TIM_SMCR_TS;
 8008234:	68fa      	ldr	r2, [r7, #12]
 8008236:	4b09      	ldr	r3, [pc, #36]	; (800825c <TIM_ITRx_SetConfig+0x38>)
 8008238:	4013      	ands	r3, r2
 800823a:	60fb      	str	r3, [r7, #12]
  /* Set the Input Trigger source and the slave mode*/
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 800823c:	683a      	ldr	r2, [r7, #0]
 800823e:	68fb      	ldr	r3, [r7, #12]
 8008240:	4313      	orrs	r3, r2
 8008242:	f043 0307 	orr.w	r3, r3, #7
 8008246:	60fb      	str	r3, [r7, #12]
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8008248:	687b      	ldr	r3, [r7, #4]
 800824a:	68fa      	ldr	r2, [r7, #12]
 800824c:	609a      	str	r2, [r3, #8]
}
 800824e:	bf00      	nop
 8008250:	3714      	adds	r7, #20
 8008252:	46bd      	mov	sp, r7
 8008254:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008258:	4770      	bx	lr
 800825a:	bf00      	nop
 800825c:	ffcfff8f 	.word	0xffcfff8f

08008260 <TIM_ETR_SetConfig>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
{
 8008260:	b480      	push	{r7}
 8008262:	b087      	sub	sp, #28
 8008264:	af00      	add	r7, sp, #0
 8008266:	60f8      	str	r0, [r7, #12]
 8008268:	60b9      	str	r1, [r7, #8]
 800826a:	607a      	str	r2, [r7, #4]
 800826c:	603b      	str	r3, [r7, #0]
  uint32_t tmpsmcr;

  tmpsmcr = TIMx->SMCR;
 800826e:	68fb      	ldr	r3, [r7, #12]
 8008270:	689b      	ldr	r3, [r3, #8]
 8008272:	617b      	str	r3, [r7, #20]

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8008274:	697b      	ldr	r3, [r7, #20]
 8008276:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 800827a:	617b      	str	r3, [r7, #20]

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 800827c:	683b      	ldr	r3, [r7, #0]
 800827e:	021a      	lsls	r2, r3, #8
 8008280:	687b      	ldr	r3, [r7, #4]
 8008282:	431a      	orrs	r2, r3
 8008284:	68bb      	ldr	r3, [r7, #8]
 8008286:	4313      	orrs	r3, r2
 8008288:	697a      	ldr	r2, [r7, #20]
 800828a:	4313      	orrs	r3, r2
 800828c:	617b      	str	r3, [r7, #20]

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800828e:	68fb      	ldr	r3, [r7, #12]
 8008290:	697a      	ldr	r2, [r7, #20]
 8008292:	609a      	str	r2, [r3, #8]
}
 8008294:	bf00      	nop
 8008296:	371c      	adds	r7, #28
 8008298:	46bd      	mov	sp, r7
 800829a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800829e:	4770      	bx	lr

080082a0 <TIM_CCxChannelCmd>:
  * @param  ChannelState specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_DISABLE.
  * @retval None
  */
void TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState)
{
 80082a0:	b480      	push	{r7}
 80082a2:	b087      	sub	sp, #28
 80082a4:	af00      	add	r7, sp, #0
 80082a6:	60f8      	str	r0, [r7, #12]
 80082a8:	60b9      	str	r1, [r7, #8]
 80082aa:	607a      	str	r2, [r7, #4]

  /* Check the parameters */
  assert_param(IS_TIM_CC1_INSTANCE(TIMx));
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
 80082ac:	68bb      	ldr	r3, [r7, #8]
 80082ae:	f003 031f 	and.w	r3, r3, #31
 80082b2:	2201      	movs	r2, #1
 80082b4:	fa02 f303 	lsl.w	r3, r2, r3
 80082b8:	617b      	str	r3, [r7, #20]

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
 80082ba:	68fb      	ldr	r3, [r7, #12]
 80082bc:	6a1a      	ldr	r2, [r3, #32]
 80082be:	697b      	ldr	r3, [r7, #20]
 80082c0:	43db      	mvns	r3, r3
 80082c2:	401a      	ands	r2, r3
 80082c4:	68fb      	ldr	r3, [r7, #12]
 80082c6:	621a      	str	r2, [r3, #32]

  /* Set or reset the CCxE Bit */
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
 80082c8:	68fb      	ldr	r3, [r7, #12]
 80082ca:	6a1a      	ldr	r2, [r3, #32]
 80082cc:	68bb      	ldr	r3, [r7, #8]
 80082ce:	f003 031f 	and.w	r3, r3, #31
 80082d2:	6879      	ldr	r1, [r7, #4]
 80082d4:	fa01 f303 	lsl.w	r3, r1, r3
 80082d8:	431a      	orrs	r2, r3
 80082da:	68fb      	ldr	r3, [r7, #12]
 80082dc:	621a      	str	r2, [r3, #32]
}
 80082de:	bf00      	nop
 80082e0:	371c      	adds	r7, #28
 80082e2:	46bd      	mov	sp, r7
 80082e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80082e8:	4770      	bx	lr
	...

080082ec <HAL_TIMEx_MasterConfigSynchronization>:
  *         mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
                                                        TIM_MasterConfigTypeDef *sMasterConfig)
{
 80082ec:	b480      	push	{r7}
 80082ee:	b085      	sub	sp, #20
 80082f0:	af00      	add	r7, sp, #0
 80082f2:	6078      	str	r0, [r7, #4]
 80082f4:	6039      	str	r1, [r7, #0]
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 80082f6:	687b      	ldr	r3, [r7, #4]
 80082f8:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 80082fc:	2b01      	cmp	r3, #1
 80082fe:	d101      	bne.n	8008304 <HAL_TIMEx_MasterConfigSynchronization+0x18>
 8008300:	2302      	movs	r3, #2
 8008302:	e06d      	b.n	80083e0 <HAL_TIMEx_MasterConfigSynchronization+0xf4>
 8008304:	687b      	ldr	r3, [r7, #4]
 8008306:	2201      	movs	r2, #1
 8008308:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;
 800830c:	687b      	ldr	r3, [r7, #4]
 800830e:	2202      	movs	r2, #2
 8008310:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 8008314:	687b      	ldr	r3, [r7, #4]
 8008316:	681b      	ldr	r3, [r3, #0]
 8008318:	685b      	ldr	r3, [r3, #4]
 800831a:	60fb      	str	r3, [r7, #12]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
 800831c:	687b      	ldr	r3, [r7, #4]
 800831e:	681b      	ldr	r3, [r3, #0]
 8008320:	689b      	ldr	r3, [r3, #8]
 8008322:	60bb      	str	r3, [r7, #8]

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8008324:	687b      	ldr	r3, [r7, #4]
 8008326:	681b      	ldr	r3, [r3, #0]
 8008328:	4a30      	ldr	r2, [pc, #192]	; (80083ec <HAL_TIMEx_MasterConfigSynchronization+0x100>)
 800832a:	4293      	cmp	r3, r2
 800832c:	d004      	beq.n	8008338 <HAL_TIMEx_MasterConfigSynchronization+0x4c>
 800832e:	687b      	ldr	r3, [r7, #4]
 8008330:	681b      	ldr	r3, [r3, #0]
 8008332:	4a2f      	ldr	r2, [pc, #188]	; (80083f0 <HAL_TIMEx_MasterConfigSynchronization+0x104>)
 8008334:	4293      	cmp	r3, r2
 8008336:	d108      	bne.n	800834a <HAL_TIMEx_MasterConfigSynchronization+0x5e>
  {
    /* Check the parameters */
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));

    /* Clear the MMS2 bits */
    tmpcr2 &= ~TIM_CR2_MMS2;
 8008338:	68fb      	ldr	r3, [r7, #12]
 800833a:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 800833e:	60fb      	str	r3, [r7, #12]
    /* Select the TRGO2 source*/
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 8008340:	683b      	ldr	r3, [r7, #0]
 8008342:	685b      	ldr	r3, [r3, #4]
 8008344:	68fa      	ldr	r2, [r7, #12]
 8008346:	4313      	orrs	r3, r2
 8008348:	60fb      	str	r3, [r7, #12]
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
 800834a:	68fb      	ldr	r3, [r7, #12]
 800834c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8008350:	60fb      	str	r3, [r7, #12]
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8008352:	683b      	ldr	r3, [r7, #0]
 8008354:	681b      	ldr	r3, [r3, #0]
 8008356:	68fa      	ldr	r2, [r7, #12]
 8008358:	4313      	orrs	r3, r2
 800835a:	60fb      	str	r3, [r7, #12]

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 800835c:	687b      	ldr	r3, [r7, #4]
 800835e:	681b      	ldr	r3, [r3, #0]
 8008360:	68fa      	ldr	r2, [r7, #12]
 8008362:	605a      	str	r2, [r3, #4]

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8008364:	687b      	ldr	r3, [r7, #4]
 8008366:	681b      	ldr	r3, [r3, #0]
 8008368:	4a20      	ldr	r2, [pc, #128]	; (80083ec <HAL_TIMEx_MasterConfigSynchronization+0x100>)
 800836a:	4293      	cmp	r3, r2
 800836c:	d022      	beq.n	80083b4 <HAL_TIMEx_MasterConfigSynchronization+0xc8>
 800836e:	687b      	ldr	r3, [r7, #4]
 8008370:	681b      	ldr	r3, [r3, #0]
 8008372:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8008376:	d01d      	beq.n	80083b4 <HAL_TIMEx_MasterConfigSynchronization+0xc8>
 8008378:	687b      	ldr	r3, [r7, #4]
 800837a:	681b      	ldr	r3, [r3, #0]
 800837c:	4a1d      	ldr	r2, [pc, #116]	; (80083f4 <HAL_TIMEx_MasterConfigSynchronization+0x108>)
 800837e:	4293      	cmp	r3, r2
 8008380:	d018      	beq.n	80083b4 <HAL_TIMEx_MasterConfigSynchronization+0xc8>
 8008382:	687b      	ldr	r3, [r7, #4]
 8008384:	681b      	ldr	r3, [r3, #0]
 8008386:	4a1c      	ldr	r2, [pc, #112]	; (80083f8 <HAL_TIMEx_MasterConfigSynchronization+0x10c>)
 8008388:	4293      	cmp	r3, r2
 800838a:	d013      	beq.n	80083b4 <HAL_TIMEx_MasterConfigSynchronization+0xc8>
 800838c:	687b      	ldr	r3, [r7, #4]
 800838e:	681b      	ldr	r3, [r3, #0]
 8008390:	4a1a      	ldr	r2, [pc, #104]	; (80083fc <HAL_TIMEx_MasterConfigSynchronization+0x110>)
 8008392:	4293      	cmp	r3, r2
 8008394:	d00e      	beq.n	80083b4 <HAL_TIMEx_MasterConfigSynchronization+0xc8>
 8008396:	687b      	ldr	r3, [r7, #4]
 8008398:	681b      	ldr	r3, [r3, #0]
 800839a:	4a15      	ldr	r2, [pc, #84]	; (80083f0 <HAL_TIMEx_MasterConfigSynchronization+0x104>)
 800839c:	4293      	cmp	r3, r2
 800839e:	d009      	beq.n	80083b4 <HAL_TIMEx_MasterConfigSynchronization+0xc8>
 80083a0:	687b      	ldr	r3, [r7, #4]
 80083a2:	681b      	ldr	r3, [r3, #0]
 80083a4:	4a16      	ldr	r2, [pc, #88]	; (8008400 <HAL_TIMEx_MasterConfigSynchronization+0x114>)
 80083a6:	4293      	cmp	r3, r2
 80083a8:	d004      	beq.n	80083b4 <HAL_TIMEx_MasterConfigSynchronization+0xc8>
 80083aa:	687b      	ldr	r3, [r7, #4]
 80083ac:	681b      	ldr	r3, [r3, #0]
 80083ae:	4a15      	ldr	r2, [pc, #84]	; (8008404 <HAL_TIMEx_MasterConfigSynchronization+0x118>)
 80083b0:	4293      	cmp	r3, r2
 80083b2:	d10c      	bne.n	80083ce <HAL_TIMEx_MasterConfigSynchronization+0xe2>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
 80083b4:	68bb      	ldr	r3, [r7, #8]
 80083b6:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80083ba:	60bb      	str	r3, [r7, #8]
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 80083bc:	683b      	ldr	r3, [r7, #0]
 80083be:	689b      	ldr	r3, [r3, #8]
 80083c0:	68ba      	ldr	r2, [r7, #8]
 80083c2:	4313      	orrs	r3, r2
 80083c4:	60bb      	str	r3, [r7, #8]

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
 80083c6:	687b      	ldr	r3, [r7, #4]
 80083c8:	681b      	ldr	r3, [r3, #0]
 80083ca:	68ba      	ldr	r2, [r7, #8]
 80083cc:	609a      	str	r2, [r3, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 80083ce:	687b      	ldr	r3, [r7, #4]
 80083d0:	2201      	movs	r2, #1
 80083d2:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  __HAL_UNLOCK(htim);
 80083d6:	687b      	ldr	r3, [r7, #4]
 80083d8:	2200      	movs	r2, #0
 80083da:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
 80083de:	2300      	movs	r3, #0
}
 80083e0:	4618      	mov	r0, r3
 80083e2:	3714      	adds	r7, #20
 80083e4:	46bd      	mov	sp, r7
 80083e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80083ea:	4770      	bx	lr
 80083ec:	40010000 	.word	0x40010000
 80083f0:	40010400 	.word	0x40010400
 80083f4:	40000400 	.word	0x40000400
 80083f8:	40000800 	.word	0x40000800
 80083fc:	40000c00 	.word	0x40000c00
 8008400:	40001800 	.word	0x40001800
 8008404:	40014000 	.word	0x40014000

08008408 <HAL_TIMEx_CommutCallback>:
  * @brief  Hall commutation changed callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)
{
 8008408:	b480      	push	{r7}
 800840a:	b083      	sub	sp, #12
 800840c:	af00      	add	r7, sp, #0
 800840e:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutCallback could be implemented in the user file
   */
}
 8008410:	bf00      	nop
 8008412:	370c      	adds	r7, #12
 8008414:	46bd      	mov	sp, r7
 8008416:	f85d 7b04 	ldr.w	r7, [sp], #4
 800841a:	4770      	bx	lr

0800841c <HAL_TIMEx_BreakCallback>:
  * @brief  Hall Break detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
{
 800841c:	b480      	push	{r7}
 800841e:	b083      	sub	sp, #12
 8008420:	af00      	add	r7, sp, #0
 8008422:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_BreakCallback could be implemented in the user file
   */
}
 8008424:	bf00      	nop
 8008426:	370c      	adds	r7, #12
 8008428:	46bd      	mov	sp, r7
 800842a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800842e:	4770      	bx	lr

08008430 <HAL_TIMEx_Break2Callback>:
  * @brief  Hall Break2 detection callback in non blocking mode
  * @param  htim: TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_Break2Callback(TIM_HandleTypeDef *htim)
{
 8008430:	b480      	push	{r7}
 8008432:	b083      	sub	sp, #12
 8008434:	af00      	add	r7, sp, #0
 8008436:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIMEx_Break2Callback could be implemented in the user file
   */
}
 8008438:	bf00      	nop
 800843a:	370c      	adds	r7, #12
 800843c:	46bd      	mov	sp, r7
 800843e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008442:	4770      	bx	lr

08008444 <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 8008444:	b580      	push	{r7, lr}
 8008446:	b082      	sub	sp, #8
 8008448:	af00      	add	r7, sp, #0
 800844a:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
 800844c:	687b      	ldr	r3, [r7, #4]
 800844e:	2b00      	cmp	r3, #0
 8008450:	d101      	bne.n	8008456 <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 8008452:	2301      	movs	r3, #1
 8008454:	e042      	b.n	80084dc <HAL_UART_Init+0x98>
  {
    /* Check the parameters */
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
  }

  if (huart->gState == HAL_UART_STATE_RESET)
 8008456:	687b      	ldr	r3, [r7, #4]
 8008458:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800845c:	2b00      	cmp	r3, #0
 800845e:	d106      	bne.n	800846e <HAL_UART_Init+0x2a>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 8008460:	687b      	ldr	r3, [r7, #4]
 8008462:	2200      	movs	r2, #0
 8008464:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 8008468:	6878      	ldr	r0, [r7, #4]
 800846a:	f009 f9d7 	bl	801181c <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
 800846e:	687b      	ldr	r3, [r7, #4]
 8008470:	2224      	movs	r2, #36	; 0x24
 8008472:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  __HAL_UART_DISABLE(huart);
 8008476:	687b      	ldr	r3, [r7, #4]
 8008478:	681b      	ldr	r3, [r3, #0]
 800847a:	681a      	ldr	r2, [r3, #0]
 800847c:	687b      	ldr	r3, [r7, #4]
 800847e:	681b      	ldr	r3, [r3, #0]
 8008480:	f022 0201 	bic.w	r2, r2, #1
 8008484:	601a      	str	r2, [r3, #0]

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
 8008486:	6878      	ldr	r0, [r7, #4]
 8008488:	f000 fd72 	bl	8008f70 <UART_SetConfig>
 800848c:	4603      	mov	r3, r0
 800848e:	2b01      	cmp	r3, #1
 8008490:	d101      	bne.n	8008496 <HAL_UART_Init+0x52>
  {
    return HAL_ERROR;
 8008492:	2301      	movs	r3, #1
 8008494:	e022      	b.n	80084dc <HAL_UART_Init+0x98>
  }

  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 8008496:	687b      	ldr	r3, [r7, #4]
 8008498:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800849a:	2b00      	cmp	r3, #0
 800849c:	d002      	beq.n	80084a4 <HAL_UART_Init+0x60>
  {
    UART_AdvFeatureConfig(huart);
 800849e:	6878      	ldr	r0, [r7, #4]
 80084a0:	f001 fac6 	bl	8009a30 <UART_AdvFeatureConfig>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 80084a4:	687b      	ldr	r3, [r7, #4]
 80084a6:	681b      	ldr	r3, [r3, #0]
 80084a8:	685a      	ldr	r2, [r3, #4]
 80084aa:	687b      	ldr	r3, [r7, #4]
 80084ac:	681b      	ldr	r3, [r3, #0]
 80084ae:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 80084b2:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 80084b4:	687b      	ldr	r3, [r7, #4]
 80084b6:	681b      	ldr	r3, [r3, #0]
 80084b8:	689a      	ldr	r2, [r3, #8]
 80084ba:	687b      	ldr	r3, [r7, #4]
 80084bc:	681b      	ldr	r3, [r3, #0]
 80084be:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 80084c2:	609a      	str	r2, [r3, #8]

  __HAL_UART_ENABLE(huart);
 80084c4:	687b      	ldr	r3, [r7, #4]
 80084c6:	681b      	ldr	r3, [r3, #0]
 80084c8:	681a      	ldr	r2, [r3, #0]
 80084ca:	687b      	ldr	r3, [r7, #4]
 80084cc:	681b      	ldr	r3, [r3, #0]
 80084ce:	f042 0201 	orr.w	r2, r2, #1
 80084d2:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
 80084d4:	6878      	ldr	r0, [r7, #4]
 80084d6:	f001 fb4d 	bl	8009b74 <UART_CheckIdleState>
 80084da:	4603      	mov	r3, r0
}
 80084dc:	4618      	mov	r0, r3
 80084de:	3708      	adds	r7, #8
 80084e0:	46bd      	mov	sp, r7
 80084e2:	bd80      	pop	{r7, pc}

080084e4 <HAL_UART_Transmit>:
  * @param Size    Amount of data elements (u8 or u16) to be sent.
  * @param Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 80084e4:	b580      	push	{r7, lr}
 80084e6:	b08a      	sub	sp, #40	; 0x28
 80084e8:	af02      	add	r7, sp, #8
 80084ea:	60f8      	str	r0, [r7, #12]
 80084ec:	60b9      	str	r1, [r7, #8]
 80084ee:	603b      	str	r3, [r7, #0]
 80084f0:	4613      	mov	r3, r2
 80084f2:	80fb      	strh	r3, [r7, #6]
  const uint8_t  *pdata8bits;
  const uint16_t *pdata16bits;
  uint32_t tickstart;

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 80084f4:	68fb      	ldr	r3, [r7, #12]
 80084f6:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 80084fa:	2b20      	cmp	r3, #32
 80084fc:	f040 8083 	bne.w	8008606 <HAL_UART_Transmit+0x122>
  {
    if ((pData == NULL) || (Size == 0U))
 8008500:	68bb      	ldr	r3, [r7, #8]
 8008502:	2b00      	cmp	r3, #0
 8008504:	d002      	beq.n	800850c <HAL_UART_Transmit+0x28>
 8008506:	88fb      	ldrh	r3, [r7, #6]
 8008508:	2b00      	cmp	r3, #0
 800850a:	d101      	bne.n	8008510 <HAL_UART_Transmit+0x2c>
    {
      return  HAL_ERROR;
 800850c:	2301      	movs	r3, #1
 800850e:	e07b      	b.n	8008608 <HAL_UART_Transmit+0x124>
    }

    __HAL_LOCK(huart);
 8008510:	68fb      	ldr	r3, [r7, #12]
 8008512:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
 8008516:	2b01      	cmp	r3, #1
 8008518:	d101      	bne.n	800851e <HAL_UART_Transmit+0x3a>
 800851a:	2302      	movs	r3, #2
 800851c:	e074      	b.n	8008608 <HAL_UART_Transmit+0x124>
 800851e:	68fb      	ldr	r3, [r7, #12]
 8008520:	2201      	movs	r2, #1
 8008522:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8008526:	68fb      	ldr	r3, [r7, #12]
 8008528:	2200      	movs	r2, #0
 800852a:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 800852e:	68fb      	ldr	r3, [r7, #12]
 8008530:	2221      	movs	r2, #33	; 0x21
 8008532:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

    /* Init tickstart for timeout management */
    tickstart = HAL_GetTick();
 8008536:	f7f8 f907 	bl	8000748 <HAL_GetTick>
 800853a:	6178      	str	r0, [r7, #20]

    huart->TxXferSize  = Size;
 800853c:	68fb      	ldr	r3, [r7, #12]
 800853e:	88fa      	ldrh	r2, [r7, #6]
 8008540:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54
    huart->TxXferCount = Size;
 8008544:	68fb      	ldr	r3, [r7, #12]
 8008546:	88fa      	ldrh	r2, [r7, #6]
 8008548:	f8a3 2056 	strh.w	r2, [r3, #86]	; 0x56

    /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800854c:	68fb      	ldr	r3, [r7, #12]
 800854e:	689b      	ldr	r3, [r3, #8]
 8008550:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8008554:	d108      	bne.n	8008568 <HAL_UART_Transmit+0x84>
 8008556:	68fb      	ldr	r3, [r7, #12]
 8008558:	691b      	ldr	r3, [r3, #16]
 800855a:	2b00      	cmp	r3, #0
 800855c:	d104      	bne.n	8008568 <HAL_UART_Transmit+0x84>
    {
      pdata8bits  = NULL;
 800855e:	2300      	movs	r3, #0
 8008560:	61fb      	str	r3, [r7, #28]
      pdata16bits = (const uint16_t *) pData;
 8008562:	68bb      	ldr	r3, [r7, #8]
 8008564:	61bb      	str	r3, [r7, #24]
 8008566:	e003      	b.n	8008570 <HAL_UART_Transmit+0x8c>
    }
    else
    {
      pdata8bits  = pData;
 8008568:	68bb      	ldr	r3, [r7, #8]
 800856a:	61fb      	str	r3, [r7, #28]
      pdata16bits = NULL;
 800856c:	2300      	movs	r3, #0
 800856e:	61bb      	str	r3, [r7, #24]
    }

    __HAL_UNLOCK(huart);
 8008570:	68fb      	ldr	r3, [r7, #12]
 8008572:	2200      	movs	r2, #0
 8008574:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

    while (huart->TxXferCount > 0U)
 8008578:	e02c      	b.n	80085d4 <HAL_UART_Transmit+0xf0>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 800857a:	683b      	ldr	r3, [r7, #0]
 800857c:	9300      	str	r3, [sp, #0]
 800857e:	697b      	ldr	r3, [r7, #20]
 8008580:	2200      	movs	r2, #0
 8008582:	2180      	movs	r1, #128	; 0x80
 8008584:	68f8      	ldr	r0, [r7, #12]
 8008586:	f001 fb40 	bl	8009c0a <UART_WaitOnFlagUntilTimeout>
 800858a:	4603      	mov	r3, r0
 800858c:	2b00      	cmp	r3, #0
 800858e:	d001      	beq.n	8008594 <HAL_UART_Transmit+0xb0>
      {
        return HAL_TIMEOUT;
 8008590:	2303      	movs	r3, #3
 8008592:	e039      	b.n	8008608 <HAL_UART_Transmit+0x124>
      }
      if (pdata8bits == NULL)
 8008594:	69fb      	ldr	r3, [r7, #28]
 8008596:	2b00      	cmp	r3, #0
 8008598:	d10b      	bne.n	80085b2 <HAL_UART_Transmit+0xce>
      {
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 800859a:	69bb      	ldr	r3, [r7, #24]
 800859c:	881b      	ldrh	r3, [r3, #0]
 800859e:	461a      	mov	r2, r3
 80085a0:	68fb      	ldr	r3, [r7, #12]
 80085a2:	681b      	ldr	r3, [r3, #0]
 80085a4:	f3c2 0208 	ubfx	r2, r2, #0, #9
 80085a8:	629a      	str	r2, [r3, #40]	; 0x28
        pdata16bits++;
 80085aa:	69bb      	ldr	r3, [r7, #24]
 80085ac:	3302      	adds	r3, #2
 80085ae:	61bb      	str	r3, [r7, #24]
 80085b0:	e007      	b.n	80085c2 <HAL_UART_Transmit+0xde>
      }
      else
      {
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 80085b2:	69fb      	ldr	r3, [r7, #28]
 80085b4:	781a      	ldrb	r2, [r3, #0]
 80085b6:	68fb      	ldr	r3, [r7, #12]
 80085b8:	681b      	ldr	r3, [r3, #0]
 80085ba:	629a      	str	r2, [r3, #40]	; 0x28
        pdata8bits++;
 80085bc:	69fb      	ldr	r3, [r7, #28]
 80085be:	3301      	adds	r3, #1
 80085c0:	61fb      	str	r3, [r7, #28]
      }
      huart->TxXferCount--;
 80085c2:	68fb      	ldr	r3, [r7, #12]
 80085c4:	f8b3 3056 	ldrh.w	r3, [r3, #86]	; 0x56
 80085c8:	b29b      	uxth	r3, r3
 80085ca:	3b01      	subs	r3, #1
 80085cc:	b29a      	uxth	r2, r3
 80085ce:	68fb      	ldr	r3, [r7, #12]
 80085d0:	f8a3 2056 	strh.w	r2, [r3, #86]	; 0x56
    while (huart->TxXferCount > 0U)
 80085d4:	68fb      	ldr	r3, [r7, #12]
 80085d6:	f8b3 3056 	ldrh.w	r3, [r3, #86]	; 0x56
 80085da:	b29b      	uxth	r3, r3
 80085dc:	2b00      	cmp	r3, #0
 80085de:	d1cc      	bne.n	800857a <HAL_UART_Transmit+0x96>
    }

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 80085e0:	683b      	ldr	r3, [r7, #0]
 80085e2:	9300      	str	r3, [sp, #0]
 80085e4:	697b      	ldr	r3, [r7, #20]
 80085e6:	2200      	movs	r2, #0
 80085e8:	2140      	movs	r1, #64	; 0x40
 80085ea:	68f8      	ldr	r0, [r7, #12]
 80085ec:	f001 fb0d 	bl	8009c0a <UART_WaitOnFlagUntilTimeout>
 80085f0:	4603      	mov	r3, r0
 80085f2:	2b00      	cmp	r3, #0
 80085f4:	d001      	beq.n	80085fa <HAL_UART_Transmit+0x116>
    {
      return HAL_TIMEOUT;
 80085f6:	2303      	movs	r3, #3
 80085f8:	e006      	b.n	8008608 <HAL_UART_Transmit+0x124>
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
 80085fa:	68fb      	ldr	r3, [r7, #12]
 80085fc:	2220      	movs	r2, #32
 80085fe:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

    return HAL_OK;
 8008602:	2300      	movs	r3, #0
 8008604:	e000      	b.n	8008608 <HAL_UART_Transmit+0x124>
  }
  else
  {
    return HAL_BUSY;
 8008606:	2302      	movs	r3, #2
  }
}
 8008608:	4618      	mov	r0, r3
 800860a:	3720      	adds	r7, #32
 800860c:	46bd      	mov	sp, r7
 800860e:	bd80      	pop	{r7, pc}

08008610 <HAL_UART_Transmit_DMA>:
  * @param pData Pointer to data buffer (u8 or u16 data elements).
  * @param Size  Amount of data elements (u8 or u16) to be sent.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size)
{
 8008610:	b580      	push	{r7, lr}
 8008612:	b08a      	sub	sp, #40	; 0x28
 8008614:	af00      	add	r7, sp, #0
 8008616:	60f8      	str	r0, [r7, #12]
 8008618:	60b9      	str	r1, [r7, #8]
 800861a:	4613      	mov	r3, r2
 800861c:	80fb      	strh	r3, [r7, #6]
  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 800861e:	68fb      	ldr	r3, [r7, #12]
 8008620:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8008624:	2b20      	cmp	r3, #32
 8008626:	d17a      	bne.n	800871e <HAL_UART_Transmit_DMA+0x10e>
  {
    if ((pData == NULL) || (Size == 0U))
 8008628:	68bb      	ldr	r3, [r7, #8]
 800862a:	2b00      	cmp	r3, #0
 800862c:	d002      	beq.n	8008634 <HAL_UART_Transmit_DMA+0x24>
 800862e:	88fb      	ldrh	r3, [r7, #6]
 8008630:	2b00      	cmp	r3, #0
 8008632:	d101      	bne.n	8008638 <HAL_UART_Transmit_DMA+0x28>
    {
      return HAL_ERROR;
 8008634:	2301      	movs	r3, #1
 8008636:	e073      	b.n	8008720 <HAL_UART_Transmit_DMA+0x110>
    }

    __HAL_LOCK(huart);
 8008638:	68fb      	ldr	r3, [r7, #12]
 800863a:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
 800863e:	2b01      	cmp	r3, #1
 8008640:	d101      	bne.n	8008646 <HAL_UART_Transmit_DMA+0x36>
 8008642:	2302      	movs	r3, #2
 8008644:	e06c      	b.n	8008720 <HAL_UART_Transmit_DMA+0x110>
 8008646:	68fb      	ldr	r3, [r7, #12]
 8008648:	2201      	movs	r2, #1
 800864a:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

    huart->pTxBuffPtr  = pData;
 800864e:	68fb      	ldr	r3, [r7, #12]
 8008650:	68ba      	ldr	r2, [r7, #8]
 8008652:	651a      	str	r2, [r3, #80]	; 0x50
    huart->TxXferSize  = Size;
 8008654:	68fb      	ldr	r3, [r7, #12]
 8008656:	88fa      	ldrh	r2, [r7, #6]
 8008658:	f8a3 2054 	strh.w	r2, [r3, #84]	; 0x54
    huart->TxXferCount = Size;
 800865c:	68fb      	ldr	r3, [r7, #12]
 800865e:	88fa      	ldrh	r2, [r7, #6]
 8008660:	f8a3 2056 	strh.w	r2, [r3, #86]	; 0x56

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8008664:	68fb      	ldr	r3, [r7, #12]
 8008666:	2200      	movs	r2, #0
 8008668:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 800866c:	68fb      	ldr	r3, [r7, #12]
 800866e:	2221      	movs	r2, #33	; 0x21
 8008670:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

    if (huart->hdmatx != NULL)
 8008674:	68fb      	ldr	r3, [r7, #12]
 8008676:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8008678:	2b00      	cmp	r3, #0
 800867a:	d02c      	beq.n	80086d6 <HAL_UART_Transmit_DMA+0xc6>
    {
      /* Set the UART DMA transfer complete callback */
      huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
 800867c:	68fb      	ldr	r3, [r7, #12]
 800867e:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8008680:	4a29      	ldr	r2, [pc, #164]	; (8008728 <HAL_UART_Transmit_DMA+0x118>)
 8008682:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Set the UART DMA Half transfer complete callback */
      huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
 8008684:	68fb      	ldr	r3, [r7, #12]
 8008686:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8008688:	4a28      	ldr	r2, [pc, #160]	; (800872c <HAL_UART_Transmit_DMA+0x11c>)
 800868a:	641a      	str	r2, [r3, #64]	; 0x40

      /* Set the DMA error callback */
      huart->hdmatx->XferErrorCallback = UART_DMAError;
 800868c:	68fb      	ldr	r3, [r7, #12]
 800868e:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8008690:	4a27      	ldr	r2, [pc, #156]	; (8008730 <HAL_UART_Transmit_DMA+0x120>)
 8008692:	64da      	str	r2, [r3, #76]	; 0x4c

      /* Set the DMA abort callback */
      huart->hdmatx->XferAbortCallback = NULL;
 8008694:	68fb      	ldr	r3, [r7, #12]
 8008696:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8008698:	2200      	movs	r2, #0
 800869a:	651a      	str	r2, [r3, #80]	; 0x50

      /* Enable the UART transmit DMA channel */
      if (HAL_DMA_Start_IT(huart->hdmatx, (uint32_t)huart->pTxBuffPtr, (uint32_t)&huart->Instance->TDR, Size) != HAL_OK)
 800869c:	68fb      	ldr	r3, [r7, #12]
 800869e:	6f98      	ldr	r0, [r3, #120]	; 0x78
 80086a0:	68fb      	ldr	r3, [r7, #12]
 80086a2:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80086a4:	4619      	mov	r1, r3
 80086a6:	68fb      	ldr	r3, [r7, #12]
 80086a8:	681b      	ldr	r3, [r3, #0]
 80086aa:	3328      	adds	r3, #40	; 0x28
 80086ac:	461a      	mov	r2, r3
 80086ae:	88fb      	ldrh	r3, [r7, #6]
 80086b0:	f7f8 fe9c 	bl	80013ec <HAL_DMA_Start_IT>
 80086b4:	4603      	mov	r3, r0
 80086b6:	2b00      	cmp	r3, #0
 80086b8:	d00d      	beq.n	80086d6 <HAL_UART_Transmit_DMA+0xc6>
      {
        /* Set error code to DMA */
        huart->ErrorCode = HAL_UART_ERROR_DMA;
 80086ba:	68fb      	ldr	r3, [r7, #12]
 80086bc:	2210      	movs	r2, #16
 80086be:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

        __HAL_UNLOCK(huart);
 80086c2:	68fb      	ldr	r3, [r7, #12]
 80086c4:	2200      	movs	r2, #0
 80086c6:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

        /* Restore huart->gState to ready */
        huart->gState = HAL_UART_STATE_READY;
 80086ca:	68fb      	ldr	r3, [r7, #12]
 80086cc:	2220      	movs	r2, #32
 80086ce:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

        return HAL_ERROR;
 80086d2:	2301      	movs	r3, #1
 80086d4:	e024      	b.n	8008720 <HAL_UART_Transmit_DMA+0x110>
      }
    }
    /* Clear the TC flag in the ICR register */
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_TCF);
 80086d6:	68fb      	ldr	r3, [r7, #12]
 80086d8:	681b      	ldr	r3, [r3, #0]
 80086da:	2240      	movs	r2, #64	; 0x40
 80086dc:	621a      	str	r2, [r3, #32]

    __HAL_UNLOCK(huart);
 80086de:	68fb      	ldr	r3, [r7, #12]
 80086e0:	2200      	movs	r2, #0
 80086e2:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

    /* Enable the DMA transfer for transmit request by setting the DMAT bit
    in the UART CR3 register */
    ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 80086e6:	68fb      	ldr	r3, [r7, #12]
 80086e8:	681b      	ldr	r3, [r3, #0]
 80086ea:	3308      	adds	r3, #8
 80086ec:	617b      	str	r3, [r7, #20]
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80086ee:	697b      	ldr	r3, [r7, #20]
 80086f0:	e853 3f00 	ldrex	r3, [r3]
 80086f4:	613b      	str	r3, [r7, #16]
   return(result);
 80086f6:	693b      	ldr	r3, [r7, #16]
 80086f8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80086fc:	627b      	str	r3, [r7, #36]	; 0x24
 80086fe:	68fb      	ldr	r3, [r7, #12]
 8008700:	681b      	ldr	r3, [r3, #0]
 8008702:	3308      	adds	r3, #8
 8008704:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8008706:	623a      	str	r2, [r7, #32]
 8008708:	61fb      	str	r3, [r7, #28]
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800870a:	69f9      	ldr	r1, [r7, #28]
 800870c:	6a3a      	ldr	r2, [r7, #32]
 800870e:	e841 2300 	strex	r3, r2, [r1]
 8008712:	61bb      	str	r3, [r7, #24]
   return(result);
 8008714:	69bb      	ldr	r3, [r7, #24]
 8008716:	2b00      	cmp	r3, #0
 8008718:	d1e5      	bne.n	80086e6 <HAL_UART_Transmit_DMA+0xd6>

    return HAL_OK;
 800871a:	2300      	movs	r3, #0
 800871c:	e000      	b.n	8008720 <HAL_UART_Transmit_DMA+0x110>
  }
  else
  {
    return HAL_BUSY;
 800871e:	2302      	movs	r3, #2
  }
}
 8008720:	4618      	mov	r0, r3
 8008722:	3728      	adds	r7, #40	; 0x28
 8008724:	46bd      	mov	sp, r7
 8008726:	bd80      	pop	{r7, pc}
 8008728:	0800a03d 	.word	0x0800a03d
 800872c:	0800a0d3 	.word	0x0800a0d3
 8008730:	0800a249 	.word	0x0800a249

08008734 <HAL_UART_Receive_DMA>:
  * @param pData Pointer to data buffer (u8 or u16 data elements).
  * @param Size  Amount of data elements (u8 or u16) to be received.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 8008734:	b580      	push	{r7, lr}
 8008736:	b08a      	sub	sp, #40	; 0x28
 8008738:	af00      	add	r7, sp, #0
 800873a:	60f8      	str	r0, [r7, #12]
 800873c:	60b9      	str	r1, [r7, #8]
 800873e:	4613      	mov	r3, r2
 8008740:	80fb      	strh	r3, [r7, #6]
  /* Check that a Rx process is not already ongoing */
  if (huart->RxState == HAL_UART_STATE_READY)
 8008742:	68fb      	ldr	r3, [r7, #12]
 8008744:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8008748:	2b20      	cmp	r3, #32
 800874a:	d142      	bne.n	80087d2 <HAL_UART_Receive_DMA+0x9e>
  {
    if ((pData == NULL) || (Size == 0U))
 800874c:	68bb      	ldr	r3, [r7, #8]
 800874e:	2b00      	cmp	r3, #0
 8008750:	d002      	beq.n	8008758 <HAL_UART_Receive_DMA+0x24>
 8008752:	88fb      	ldrh	r3, [r7, #6]
 8008754:	2b00      	cmp	r3, #0
 8008756:	d101      	bne.n	800875c <HAL_UART_Receive_DMA+0x28>
    {
      return HAL_ERROR;
 8008758:	2301      	movs	r3, #1
 800875a:	e03b      	b.n	80087d4 <HAL_UART_Receive_DMA+0xa0>
    }

    __HAL_LOCK(huart);
 800875c:	68fb      	ldr	r3, [r7, #12]
 800875e:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
 8008762:	2b01      	cmp	r3, #1
 8008764:	d101      	bne.n	800876a <HAL_UART_Receive_DMA+0x36>
 8008766:	2302      	movs	r3, #2
 8008768:	e034      	b.n	80087d4 <HAL_UART_Receive_DMA+0xa0>
 800876a:	68fb      	ldr	r3, [r7, #12]
 800876c:	2201      	movs	r2, #1
 800876e:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

    /* Set Reception type to Standard reception */
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8008772:	68fb      	ldr	r3, [r7, #12]
 8008774:	2200      	movs	r2, #0
 8008776:	66da      	str	r2, [r3, #108]	; 0x6c

    if (!(IS_LPUART_INSTANCE(huart->Instance)))
 8008778:	68fb      	ldr	r3, [r7, #12]
 800877a:	681b      	ldr	r3, [r3, #0]
 800877c:	4a17      	ldr	r2, [pc, #92]	; (80087dc <HAL_UART_Receive_DMA+0xa8>)
 800877e:	4293      	cmp	r3, r2
 8008780:	d01f      	beq.n	80087c2 <HAL_UART_Receive_DMA+0x8e>
    {
      /* Check that USART RTOEN bit is set */
      if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 8008782:	68fb      	ldr	r3, [r7, #12]
 8008784:	681b      	ldr	r3, [r3, #0]
 8008786:	685b      	ldr	r3, [r3, #4]
 8008788:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 800878c:	2b00      	cmp	r3, #0
 800878e:	d018      	beq.n	80087c2 <HAL_UART_Receive_DMA+0x8e>
      {
        /* Enable the UART Receiver Timeout Interrupt */
        ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 8008790:	68fb      	ldr	r3, [r7, #12]
 8008792:	681b      	ldr	r3, [r3, #0]
 8008794:	617b      	str	r3, [r7, #20]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008796:	697b      	ldr	r3, [r7, #20]
 8008798:	e853 3f00 	ldrex	r3, [r3]
 800879c:	613b      	str	r3, [r7, #16]
   return(result);
 800879e:	693b      	ldr	r3, [r7, #16]
 80087a0:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 80087a4:	627b      	str	r3, [r7, #36]	; 0x24
 80087a6:	68fb      	ldr	r3, [r7, #12]
 80087a8:	681b      	ldr	r3, [r3, #0]
 80087aa:	461a      	mov	r2, r3
 80087ac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80087ae:	623b      	str	r3, [r7, #32]
 80087b0:	61fa      	str	r2, [r7, #28]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 80087b2:	69f9      	ldr	r1, [r7, #28]
 80087b4:	6a3a      	ldr	r2, [r7, #32]
 80087b6:	e841 2300 	strex	r3, r2, [r1]
 80087ba:	61bb      	str	r3, [r7, #24]
   return(result);
 80087bc:	69bb      	ldr	r3, [r7, #24]
 80087be:	2b00      	cmp	r3, #0
 80087c0:	d1e6      	bne.n	8008790 <HAL_UART_Receive_DMA+0x5c>
      }
    }

    return (UART_Start_Receive_DMA(huart, pData, Size));
 80087c2:	88fb      	ldrh	r3, [r7, #6]
 80087c4:	461a      	mov	r2, r3
 80087c6:	68b9      	ldr	r1, [r7, #8]
 80087c8:	68f8      	ldr	r0, [r7, #12]
 80087ca:	f001 fae7 	bl	8009d9c <UART_Start_Receive_DMA>
 80087ce:	4603      	mov	r3, r0
 80087d0:	e000      	b.n	80087d4 <HAL_UART_Receive_DMA+0xa0>
  }
  else
  {
    return HAL_BUSY;
 80087d2:	2302      	movs	r3, #2
  }
}
 80087d4:	4618      	mov	r0, r3
 80087d6:	3728      	adds	r7, #40	; 0x28
 80087d8:	46bd      	mov	sp, r7
 80087da:	bd80      	pop	{r7, pc}
 80087dc:	58000c00 	.word	0x58000c00

080087e0 <HAL_UART_IRQHandler>:
  * @brief Handle UART interrupt request.
  * @param huart UART handle.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
 80087e0:	b580      	push	{r7, lr}
 80087e2:	b0ba      	sub	sp, #232	; 0xe8
 80087e4:	af00      	add	r7, sp, #0
 80087e6:	6078      	str	r0, [r7, #4]
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 80087e8:	687b      	ldr	r3, [r7, #4]
 80087ea:	681b      	ldr	r3, [r3, #0]
 80087ec:	69db      	ldr	r3, [r3, #28]
 80087ee:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 80087f2:	687b      	ldr	r3, [r7, #4]
 80087f4:	681b      	ldr	r3, [r3, #0]
 80087f6:	681b      	ldr	r3, [r3, #0]
 80087f8:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 80087fc:	687b      	ldr	r3, [r7, #4]
 80087fe:	681b      	ldr	r3, [r3, #0]
 8008800:	689b      	ldr	r3, [r3, #8]
 8008802:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc

  uint32_t errorflags;
  uint32_t errorcode;

  /* If no error occurs */
  errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE | USART_ISR_RTOF));
 8008806:	f8d7 20e4 	ldr.w	r2, [r7, #228]	; 0xe4
 800880a:	f640 030f 	movw	r3, #2063	; 0x80f
 800880e:	4013      	ands	r3, r2
 8008810:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
  if (errorflags == 0U)
 8008814:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8008818:	2b00      	cmp	r3, #0
 800881a:	d11b      	bne.n	8008854 <HAL_UART_IRQHandler+0x74>
  {
    /* UART in mode Receiver ---------------------------------------------------*/
    if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
 800881c:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8008820:	f003 0320 	and.w	r3, r3, #32
 8008824:	2b00      	cmp	r3, #0
 8008826:	d015      	beq.n	8008854 <HAL_UART_IRQHandler+0x74>
        && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
 8008828:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 800882c:	f003 0320 	and.w	r3, r3, #32
 8008830:	2b00      	cmp	r3, #0
 8008832:	d105      	bne.n	8008840 <HAL_UART_IRQHandler+0x60>
            || ((cr3its & USART_CR3_RXFTIE) != 0U)))
 8008834:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8008838:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800883c:	2b00      	cmp	r3, #0
 800883e:	d009      	beq.n	8008854 <HAL_UART_IRQHandler+0x74>
    {
      if (huart->RxISR != NULL)
 8008840:	687b      	ldr	r3, [r7, #4]
 8008842:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008844:	2b00      	cmp	r3, #0
 8008846:	f000 835a 	beq.w	8008efe <HAL_UART_IRQHandler+0x71e>
      {
        huart->RxISR(huart);
 800884a:	687b      	ldr	r3, [r7, #4]
 800884c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800884e:	6878      	ldr	r0, [r7, #4]
 8008850:	4798      	blx	r3
      }
      return;
 8008852:	e354      	b.n	8008efe <HAL_UART_IRQHandler+0x71e>
    }
  }

  /* If some errors occur */
  if ((errorflags != 0U)
 8008854:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8008858:	2b00      	cmp	r3, #0
 800885a:	f000 811f 	beq.w	8008a9c <HAL_UART_IRQHandler+0x2bc>
      && ((((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)
 800885e:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 8008862:	4b8b      	ldr	r3, [pc, #556]	; (8008a90 <HAL_UART_IRQHandler+0x2b0>)
 8008864:	4013      	ands	r3, r2
 8008866:	2b00      	cmp	r3, #0
 8008868:	d106      	bne.n	8008878 <HAL_UART_IRQHandler+0x98>
           || ((cr1its & (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U))))
 800886a:	f8d7 20e0 	ldr.w	r2, [r7, #224]	; 0xe0
 800886e:	4b89      	ldr	r3, [pc, #548]	; (8008a94 <HAL_UART_IRQHandler+0x2b4>)
 8008870:	4013      	ands	r3, r2
 8008872:	2b00      	cmp	r3, #0
 8008874:	f000 8112 	beq.w	8008a9c <HAL_UART_IRQHandler+0x2bc>
  {
    /* UART parity error interrupt occurred -------------------------------------*/
    if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 8008878:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 800887c:	f003 0301 	and.w	r3, r3, #1
 8008880:	2b00      	cmp	r3, #0
 8008882:	d011      	beq.n	80088a8 <HAL_UART_IRQHandler+0xc8>
 8008884:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8008888:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800888c:	2b00      	cmp	r3, #0
 800888e:	d00b      	beq.n	80088a8 <HAL_UART_IRQHandler+0xc8>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 8008890:	687b      	ldr	r3, [r7, #4]
 8008892:	681b      	ldr	r3, [r3, #0]
 8008894:	2201      	movs	r2, #1
 8008896:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_PE;
 8008898:	687b      	ldr	r3, [r7, #4]
 800889a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800889e:	f043 0201 	orr.w	r2, r3, #1
 80088a2:	687b      	ldr	r3, [r7, #4]
 80088a4:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    }

    /* UART frame error interrupt occurred --------------------------------------*/
    if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80088a8:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 80088ac:	f003 0302 	and.w	r3, r3, #2
 80088b0:	2b00      	cmp	r3, #0
 80088b2:	d011      	beq.n	80088d8 <HAL_UART_IRQHandler+0xf8>
 80088b4:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80088b8:	f003 0301 	and.w	r3, r3, #1
 80088bc:	2b00      	cmp	r3, #0
 80088be:	d00b      	beq.n	80088d8 <HAL_UART_IRQHandler+0xf8>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 80088c0:	687b      	ldr	r3, [r7, #4]
 80088c2:	681b      	ldr	r3, [r3, #0]
 80088c4:	2202      	movs	r2, #2
 80088c6:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_FE;
 80088c8:	687b      	ldr	r3, [r7, #4]
 80088ca:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80088ce:	f043 0204 	orr.w	r2, r3, #4
 80088d2:	687b      	ldr	r3, [r7, #4]
 80088d4:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    }

    /* UART noise error interrupt occurred --------------------------------------*/
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80088d8:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 80088dc:	f003 0304 	and.w	r3, r3, #4
 80088e0:	2b00      	cmp	r3, #0
 80088e2:	d011      	beq.n	8008908 <HAL_UART_IRQHandler+0x128>
 80088e4:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 80088e8:	f003 0301 	and.w	r3, r3, #1
 80088ec:	2b00      	cmp	r3, #0
 80088ee:	d00b      	beq.n	8008908 <HAL_UART_IRQHandler+0x128>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 80088f0:	687b      	ldr	r3, [r7, #4]
 80088f2:	681b      	ldr	r3, [r3, #0]
 80088f4:	2204      	movs	r2, #4
 80088f6:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_NE;
 80088f8:	687b      	ldr	r3, [r7, #4]
 80088fa:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80088fe:	f043 0202 	orr.w	r2, r3, #2
 8008902:	687b      	ldr	r3, [r7, #4]
 8008904:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    }

    /* UART Over-Run interrupt occurred -----------------------------------------*/
    if (((isrflags & USART_ISR_ORE) != 0U)
 8008908:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 800890c:	f003 0308 	and.w	r3, r3, #8
 8008910:	2b00      	cmp	r3, #0
 8008912:	d017      	beq.n	8008944 <HAL_UART_IRQHandler+0x164>
        && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U) ||
 8008914:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8008918:	f003 0320 	and.w	r3, r3, #32
 800891c:	2b00      	cmp	r3, #0
 800891e:	d105      	bne.n	800892c <HAL_UART_IRQHandler+0x14c>
            ((cr3its & (USART_CR3_RXFTIE | USART_CR3_EIE)) != 0U)))
 8008920:	f8d7 20dc 	ldr.w	r2, [r7, #220]	; 0xdc
 8008924:	4b5a      	ldr	r3, [pc, #360]	; (8008a90 <HAL_UART_IRQHandler+0x2b0>)
 8008926:	4013      	ands	r3, r2
        && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U) ||
 8008928:	2b00      	cmp	r3, #0
 800892a:	d00b      	beq.n	8008944 <HAL_UART_IRQHandler+0x164>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 800892c:	687b      	ldr	r3, [r7, #4]
 800892e:	681b      	ldr	r3, [r3, #0]
 8008930:	2208      	movs	r2, #8
 8008932:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 8008934:	687b      	ldr	r3, [r7, #4]
 8008936:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800893a:	f043 0208 	orr.w	r2, r3, #8
 800893e:	687b      	ldr	r3, [r7, #4]
 8008940:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    }

    /* UART Receiver Timeout interrupt occurred ---------------------------------*/
    if (((isrflags & USART_ISR_RTOF) != 0U) && ((cr1its & USART_CR1_RTOIE) != 0U))
 8008944:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8008948:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800894c:	2b00      	cmp	r3, #0
 800894e:	d012      	beq.n	8008976 <HAL_UART_IRQHandler+0x196>
 8008950:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8008954:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 8008958:	2b00      	cmp	r3, #0
 800895a:	d00c      	beq.n	8008976 <HAL_UART_IRQHandler+0x196>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 800895c:	687b      	ldr	r3, [r7, #4]
 800895e:	681b      	ldr	r3, [r3, #0]
 8008960:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8008964:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_RTO;
 8008966:	687b      	ldr	r3, [r7, #4]
 8008968:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800896c:	f043 0220 	orr.w	r2, r3, #32
 8008970:	687b      	ldr	r3, [r7, #4]
 8008972:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    }

    /* Call UART Error Call back function if need be ----------------------------*/
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 8008976:	687b      	ldr	r3, [r7, #4]
 8008978:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800897c:	2b00      	cmp	r3, #0
 800897e:	f000 82c0 	beq.w	8008f02 <HAL_UART_IRQHandler+0x722>
    {
      /* UART in mode Receiver --------------------------------------------------*/
      if (((isrflags & USART_ISR_RXNE_RXFNE) != 0U)
 8008982:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8008986:	f003 0320 	and.w	r3, r3, #32
 800898a:	2b00      	cmp	r3, #0
 800898c:	d013      	beq.n	80089b6 <HAL_UART_IRQHandler+0x1d6>
          && (((cr1its & USART_CR1_RXNEIE_RXFNEIE) != 0U)
 800898e:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8008992:	f003 0320 	and.w	r3, r3, #32
 8008996:	2b00      	cmp	r3, #0
 8008998:	d105      	bne.n	80089a6 <HAL_UART_IRQHandler+0x1c6>
              || ((cr3its & USART_CR3_RXFTIE) != 0U)))
 800899a:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 800899e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80089a2:	2b00      	cmp	r3, #0
 80089a4:	d007      	beq.n	80089b6 <HAL_UART_IRQHandler+0x1d6>
      {
        if (huart->RxISR != NULL)
 80089a6:	687b      	ldr	r3, [r7, #4]
 80089a8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80089aa:	2b00      	cmp	r3, #0
 80089ac:	d003      	beq.n	80089b6 <HAL_UART_IRQHandler+0x1d6>
        {
          huart->RxISR(huart);
 80089ae:	687b      	ldr	r3, [r7, #4]
 80089b0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80089b2:	6878      	ldr	r0, [r7, #4]
 80089b4:	4798      	blx	r3
      /* If Error is to be considered as blocking :
          - Receiver Timeout error in Reception
          - Overrun error in Reception
          - any error occurs in DMA mode reception
      */
      errorcode = huart->ErrorCode;
 80089b6:	687b      	ldr	r3, [r7, #4]
 80089b8:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80089bc:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 80089c0:	687b      	ldr	r3, [r7, #4]
 80089c2:	681b      	ldr	r3, [r3, #0]
 80089c4:	689b      	ldr	r3, [r3, #8]
 80089c6:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80089ca:	2b40      	cmp	r3, #64	; 0x40
 80089cc:	d005      	beq.n	80089da <HAL_UART_IRQHandler+0x1fa>
          ((errorcode & (HAL_UART_ERROR_RTO | HAL_UART_ERROR_ORE)) != 0U))
 80089ce:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80089d2:	f003 0328 	and.w	r3, r3, #40	; 0x28
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 80089d6:	2b00      	cmp	r3, #0
 80089d8:	d04f      	beq.n	8008a7a <HAL_UART_IRQHandler+0x29a>
      {
        /* Blocking error : transfer is aborted
           Set the UART state ready to be able to start again the process,
           Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
        UART_EndRxTransfer(huart);
 80089da:	6878      	ldr	r0, [r7, #4]
 80089dc:	f001 fac8 	bl	8009f70 <UART_EndRxTransfer>

        /* Abort the UART DMA Rx channel if enabled */
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 80089e0:	687b      	ldr	r3, [r7, #4]
 80089e2:	681b      	ldr	r3, [r3, #0]
 80089e4:	689b      	ldr	r3, [r3, #8]
 80089e6:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80089ea:	2b40      	cmp	r3, #64	; 0x40
 80089ec:	d141      	bne.n	8008a72 <HAL_UART_IRQHandler+0x292>
        {
          /* Disable the UART DMA Rx request if enabled */
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 80089ee:	687b      	ldr	r3, [r7, #4]
 80089f0:	681b      	ldr	r3, [r3, #0]
 80089f2:	3308      	adds	r3, #8
 80089f4:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 80089f8:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 80089fc:	e853 3f00 	ldrex	r3, [r3]
 8008a00:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
   return(result);
 8008a04:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8008a08:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8008a0c:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
 8008a10:	687b      	ldr	r3, [r7, #4]
 8008a12:	681b      	ldr	r3, [r3, #0]
 8008a14:	3308      	adds	r3, #8
 8008a16:	f8d7 20d0 	ldr.w	r2, [r7, #208]	; 0xd0
 8008a1a:	f8c7 20a8 	str.w	r2, [r7, #168]	; 0xa8
 8008a1e:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008a22:	f8d7 10a4 	ldr.w	r1, [r7, #164]	; 0xa4
 8008a26:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
 8008a2a:	e841 2300 	strex	r3, r2, [r1]
 8008a2e:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
   return(result);
 8008a32:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8008a36:	2b00      	cmp	r3, #0
 8008a38:	d1d9      	bne.n	80089ee <HAL_UART_IRQHandler+0x20e>

          /* Abort the UART DMA Rx channel */
          if (huart->hdmarx != NULL)
 8008a3a:	687b      	ldr	r3, [r7, #4]
 8008a3c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8008a3e:	2b00      	cmp	r3, #0
 8008a40:	d013      	beq.n	8008a6a <HAL_UART_IRQHandler+0x28a>
          {
            /* Set the UART DMA Abort callback :
               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 8008a42:	687b      	ldr	r3, [r7, #4]
 8008a44:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8008a46:	4a14      	ldr	r2, [pc, #80]	; (8008a98 <HAL_UART_IRQHandler+0x2b8>)
 8008a48:	651a      	str	r2, [r3, #80]	; 0x50

            /* Abort DMA RX */
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 8008a4a:	687b      	ldr	r3, [r7, #4]
 8008a4c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8008a4e:	4618      	mov	r0, r3
 8008a50:	f7f9 fa54 	bl	8001efc <HAL_DMA_Abort_IT>
 8008a54:	4603      	mov	r3, r0
 8008a56:	2b00      	cmp	r3, #0
 8008a58:	d017      	beq.n	8008a8a <HAL_UART_IRQHandler+0x2aa>
            {
              /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8008a5a:	687b      	ldr	r3, [r7, #4]
 8008a5c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8008a5e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8008a60:	687a      	ldr	r2, [r7, #4]
 8008a62:	6fd2      	ldr	r2, [r2, #124]	; 0x7c
 8008a64:	4610      	mov	r0, r2
 8008a66:	4798      	blx	r3
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8008a68:	e00f      	b.n	8008a8a <HAL_UART_IRQHandler+0x2aa>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
            /*Call registered error callback*/
            huart->ErrorCallback(huart);
#else
            /*Call legacy weak error callback*/
            HAL_UART_ErrorCallback(huart);
 8008a6a:	6878      	ldr	r0, [r7, #4]
 8008a6c:	f000 fa6a 	bl	8008f44 <HAL_UART_ErrorCallback>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8008a70:	e00b      	b.n	8008a8a <HAL_UART_IRQHandler+0x2aa>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
          /*Call registered error callback*/
          huart->ErrorCallback(huart);
#else
          /*Call legacy weak error callback*/
          HAL_UART_ErrorCallback(huart);
 8008a72:	6878      	ldr	r0, [r7, #4]
 8008a74:	f000 fa66 	bl	8008f44 <HAL_UART_ErrorCallback>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8008a78:	e007      	b.n	8008a8a <HAL_UART_IRQHandler+0x2aa>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered error callback*/
        huart->ErrorCallback(huart);
#else
        /*Call legacy weak error callback*/
        HAL_UART_ErrorCallback(huart);
 8008a7a:	6878      	ldr	r0, [r7, #4]
 8008a7c:	f000 fa62 	bl	8008f44 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 8008a80:	687b      	ldr	r3, [r7, #4]
 8008a82:	2200      	movs	r2, #0
 8008a84:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
      }
    }
    return;
 8008a88:	e23b      	b.n	8008f02 <HAL_UART_IRQHandler+0x722>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8008a8a:	bf00      	nop
    return;
 8008a8c:	e239      	b.n	8008f02 <HAL_UART_IRQHandler+0x722>
 8008a8e:	bf00      	nop
 8008a90:	10000001 	.word	0x10000001
 8008a94:	04000120 	.word	0x04000120
 8008a98:	0800a2c9 	.word	0x0800a2c9

  } /* End if some error occurs */

  /* Check current reception Mode :
     If Reception till IDLE event has been selected : */
  if ((huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8008a9c:	687b      	ldr	r3, [r7, #4]
 8008a9e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008aa0:	2b01      	cmp	r3, #1
 8008aa2:	f040 81ce 	bne.w	8008e42 <HAL_UART_IRQHandler+0x662>
      && ((isrflags & USART_ISR_IDLE) != 0U)
 8008aa6:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8008aaa:	f003 0310 	and.w	r3, r3, #16
 8008aae:	2b00      	cmp	r3, #0
 8008ab0:	f000 81c7 	beq.w	8008e42 <HAL_UART_IRQHandler+0x662>
      && ((cr1its & USART_ISR_IDLE) != 0U))
 8008ab4:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8008ab8:	f003 0310 	and.w	r3, r3, #16
 8008abc:	2b00      	cmp	r3, #0
 8008abe:	f000 81c0 	beq.w	8008e42 <HAL_UART_IRQHandler+0x662>
  {
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
 8008ac2:	687b      	ldr	r3, [r7, #4]
 8008ac4:	681b      	ldr	r3, [r3, #0]
 8008ac6:	2210      	movs	r2, #16
 8008ac8:	621a      	str	r2, [r3, #32]

    /* Check if DMA mode is enabled in UART */
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8008aca:	687b      	ldr	r3, [r7, #4]
 8008acc:	681b      	ldr	r3, [r3, #0]
 8008ace:	689b      	ldr	r3, [r3, #8]
 8008ad0:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8008ad4:	2b40      	cmp	r3, #64	; 0x40
 8008ad6:	f040 813b 	bne.w	8008d50 <HAL_UART_IRQHandler+0x570>
    {
      /* DMA mode enabled */
      /* Check received length : If all expected data are received, do nothing,
         (DMA cplt callback will be called).
         Otherwise, if at least one data has already been received, IDLE event is to be notified to user */
      uint16_t nb_remaining_rx_data = (uint16_t) __HAL_DMA_GET_COUNTER(huart->hdmarx);
 8008ada:	687b      	ldr	r3, [r7, #4]
 8008adc:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8008ade:	681b      	ldr	r3, [r3, #0]
 8008ae0:	4a8b      	ldr	r2, [pc, #556]	; (8008d10 <HAL_UART_IRQHandler+0x530>)
 8008ae2:	4293      	cmp	r3, r2
 8008ae4:	d059      	beq.n	8008b9a <HAL_UART_IRQHandler+0x3ba>
 8008ae6:	687b      	ldr	r3, [r7, #4]
 8008ae8:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8008aea:	681b      	ldr	r3, [r3, #0]
 8008aec:	4a89      	ldr	r2, [pc, #548]	; (8008d14 <HAL_UART_IRQHandler+0x534>)
 8008aee:	4293      	cmp	r3, r2
 8008af0:	d053      	beq.n	8008b9a <HAL_UART_IRQHandler+0x3ba>
 8008af2:	687b      	ldr	r3, [r7, #4]
 8008af4:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8008af6:	681b      	ldr	r3, [r3, #0]
 8008af8:	4a87      	ldr	r2, [pc, #540]	; (8008d18 <HAL_UART_IRQHandler+0x538>)
 8008afa:	4293      	cmp	r3, r2
 8008afc:	d04d      	beq.n	8008b9a <HAL_UART_IRQHandler+0x3ba>
 8008afe:	687b      	ldr	r3, [r7, #4]
 8008b00:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8008b02:	681b      	ldr	r3, [r3, #0]
 8008b04:	4a85      	ldr	r2, [pc, #532]	; (8008d1c <HAL_UART_IRQHandler+0x53c>)
 8008b06:	4293      	cmp	r3, r2
 8008b08:	d047      	beq.n	8008b9a <HAL_UART_IRQHandler+0x3ba>
 8008b0a:	687b      	ldr	r3, [r7, #4]
 8008b0c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8008b0e:	681b      	ldr	r3, [r3, #0]
 8008b10:	4a83      	ldr	r2, [pc, #524]	; (8008d20 <HAL_UART_IRQHandler+0x540>)
 8008b12:	4293      	cmp	r3, r2
 8008b14:	d041      	beq.n	8008b9a <HAL_UART_IRQHandler+0x3ba>
 8008b16:	687b      	ldr	r3, [r7, #4]
 8008b18:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8008b1a:	681b      	ldr	r3, [r3, #0]
 8008b1c:	4a81      	ldr	r2, [pc, #516]	; (8008d24 <HAL_UART_IRQHandler+0x544>)
 8008b1e:	4293      	cmp	r3, r2
 8008b20:	d03b      	beq.n	8008b9a <HAL_UART_IRQHandler+0x3ba>
 8008b22:	687b      	ldr	r3, [r7, #4]
 8008b24:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8008b26:	681b      	ldr	r3, [r3, #0]
 8008b28:	4a7f      	ldr	r2, [pc, #508]	; (8008d28 <HAL_UART_IRQHandler+0x548>)
 8008b2a:	4293      	cmp	r3, r2
 8008b2c:	d035      	beq.n	8008b9a <HAL_UART_IRQHandler+0x3ba>
 8008b2e:	687b      	ldr	r3, [r7, #4]
 8008b30:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8008b32:	681b      	ldr	r3, [r3, #0]
 8008b34:	4a7d      	ldr	r2, [pc, #500]	; (8008d2c <HAL_UART_IRQHandler+0x54c>)
 8008b36:	4293      	cmp	r3, r2
 8008b38:	d02f      	beq.n	8008b9a <HAL_UART_IRQHandler+0x3ba>
 8008b3a:	687b      	ldr	r3, [r7, #4]
 8008b3c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8008b3e:	681b      	ldr	r3, [r3, #0]
 8008b40:	4a7b      	ldr	r2, [pc, #492]	; (8008d30 <HAL_UART_IRQHandler+0x550>)
 8008b42:	4293      	cmp	r3, r2
 8008b44:	d029      	beq.n	8008b9a <HAL_UART_IRQHandler+0x3ba>
 8008b46:	687b      	ldr	r3, [r7, #4]
 8008b48:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8008b4a:	681b      	ldr	r3, [r3, #0]
 8008b4c:	4a79      	ldr	r2, [pc, #484]	; (8008d34 <HAL_UART_IRQHandler+0x554>)
 8008b4e:	4293      	cmp	r3, r2
 8008b50:	d023      	beq.n	8008b9a <HAL_UART_IRQHandler+0x3ba>
 8008b52:	687b      	ldr	r3, [r7, #4]
 8008b54:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8008b56:	681b      	ldr	r3, [r3, #0]
 8008b58:	4a77      	ldr	r2, [pc, #476]	; (8008d38 <HAL_UART_IRQHandler+0x558>)
 8008b5a:	4293      	cmp	r3, r2
 8008b5c:	d01d      	beq.n	8008b9a <HAL_UART_IRQHandler+0x3ba>
 8008b5e:	687b      	ldr	r3, [r7, #4]
 8008b60:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8008b62:	681b      	ldr	r3, [r3, #0]
 8008b64:	4a75      	ldr	r2, [pc, #468]	; (8008d3c <HAL_UART_IRQHandler+0x55c>)
 8008b66:	4293      	cmp	r3, r2
 8008b68:	d017      	beq.n	8008b9a <HAL_UART_IRQHandler+0x3ba>
 8008b6a:	687b      	ldr	r3, [r7, #4]
 8008b6c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8008b6e:	681b      	ldr	r3, [r3, #0]
 8008b70:	4a73      	ldr	r2, [pc, #460]	; (8008d40 <HAL_UART_IRQHandler+0x560>)
 8008b72:	4293      	cmp	r3, r2
 8008b74:	d011      	beq.n	8008b9a <HAL_UART_IRQHandler+0x3ba>
 8008b76:	687b      	ldr	r3, [r7, #4]
 8008b78:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8008b7a:	681b      	ldr	r3, [r3, #0]
 8008b7c:	4a71      	ldr	r2, [pc, #452]	; (8008d44 <HAL_UART_IRQHandler+0x564>)
 8008b7e:	4293      	cmp	r3, r2
 8008b80:	d00b      	beq.n	8008b9a <HAL_UART_IRQHandler+0x3ba>
 8008b82:	687b      	ldr	r3, [r7, #4]
 8008b84:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8008b86:	681b      	ldr	r3, [r3, #0]
 8008b88:	4a6f      	ldr	r2, [pc, #444]	; (8008d48 <HAL_UART_IRQHandler+0x568>)
 8008b8a:	4293      	cmp	r3, r2
 8008b8c:	d005      	beq.n	8008b9a <HAL_UART_IRQHandler+0x3ba>
 8008b8e:	687b      	ldr	r3, [r7, #4]
 8008b90:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8008b92:	681b      	ldr	r3, [r3, #0]
 8008b94:	4a6d      	ldr	r2, [pc, #436]	; (8008d4c <HAL_UART_IRQHandler+0x56c>)
 8008b96:	4293      	cmp	r3, r2
 8008b98:	d105      	bne.n	8008ba6 <HAL_UART_IRQHandler+0x3c6>
 8008b9a:	687b      	ldr	r3, [r7, #4]
 8008b9c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8008b9e:	681b      	ldr	r3, [r3, #0]
 8008ba0:	685b      	ldr	r3, [r3, #4]
 8008ba2:	b29b      	uxth	r3, r3
 8008ba4:	e004      	b.n	8008bb0 <HAL_UART_IRQHandler+0x3d0>
 8008ba6:	687b      	ldr	r3, [r7, #4]
 8008ba8:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8008baa:	681b      	ldr	r3, [r3, #0]
 8008bac:	685b      	ldr	r3, [r3, #4]
 8008bae:	b29b      	uxth	r3, r3
 8008bb0:	f8a7 30be 	strh.w	r3, [r7, #190]	; 0xbe
      if ((nb_remaining_rx_data > 0U)
 8008bb4:	f8b7 30be 	ldrh.w	r3, [r7, #190]	; 0xbe
 8008bb8:	2b00      	cmp	r3, #0
 8008bba:	f000 81a4 	beq.w	8008f06 <HAL_UART_IRQHandler+0x726>
          && (nb_remaining_rx_data < huart->RxXferSize))
 8008bbe:	687b      	ldr	r3, [r7, #4]
 8008bc0:	f8b3 305c 	ldrh.w	r3, [r3, #92]	; 0x5c
 8008bc4:	f8b7 20be 	ldrh.w	r2, [r7, #190]	; 0xbe
 8008bc8:	429a      	cmp	r2, r3
 8008bca:	f080 819c 	bcs.w	8008f06 <HAL_UART_IRQHandler+0x726>
      {
        /* Reception is not complete */
        huart->RxXferCount = nb_remaining_rx_data;
 8008bce:	687b      	ldr	r3, [r7, #4]
 8008bd0:	f8b7 20be 	ldrh.w	r2, [r7, #190]	; 0xbe
 8008bd4:	f8a3 205e 	strh.w	r2, [r3, #94]	; 0x5e

        /* In Normal mode, end DMA xfer and HAL UART Rx process*/
        if (huart->hdmarx->Init.Mode != DMA_CIRCULAR)
 8008bd8:	687b      	ldr	r3, [r7, #4]
 8008bda:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8008bdc:	69db      	ldr	r3, [r3, #28]
 8008bde:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8008be2:	f000 8086 	beq.w	8008cf2 <HAL_UART_IRQHandler+0x512>
        {
          /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8008be6:	687b      	ldr	r3, [r7, #4]
 8008be8:	681b      	ldr	r3, [r3, #0]
 8008bea:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008bee:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8008bf2:	e853 3f00 	ldrex	r3, [r3]
 8008bf6:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
   return(result);
 8008bfa:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 8008bfe:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8008c02:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
 8008c06:	687b      	ldr	r3, [r7, #4]
 8008c08:	681b      	ldr	r3, [r3, #0]
 8008c0a:	461a      	mov	r2, r3
 8008c0c:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 8008c10:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
 8008c14:	f8c7 2090 	str.w	r2, [r7, #144]	; 0x90
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008c18:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
 8008c1c:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 8008c20:	e841 2300 	strex	r3, r2, [r1]
 8008c24:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
   return(result);
 8008c28:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8008c2c:	2b00      	cmp	r3, #0
 8008c2e:	d1da      	bne.n	8008be6 <HAL_UART_IRQHandler+0x406>
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8008c30:	687b      	ldr	r3, [r7, #4]
 8008c32:	681b      	ldr	r3, [r3, #0]
 8008c34:	3308      	adds	r3, #8
 8008c36:	677b      	str	r3, [r7, #116]	; 0x74
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008c38:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 8008c3a:	e853 3f00 	ldrex	r3, [r3]
 8008c3e:	673b      	str	r3, [r7, #112]	; 0x70
   return(result);
 8008c40:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 8008c42:	f023 0301 	bic.w	r3, r3, #1
 8008c46:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
 8008c4a:	687b      	ldr	r3, [r7, #4]
 8008c4c:	681b      	ldr	r3, [r3, #0]
 8008c4e:	3308      	adds	r3, #8
 8008c50:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
 8008c54:	f8c7 2080 	str.w	r2, [r7, #128]	; 0x80
 8008c58:	67fb      	str	r3, [r7, #124]	; 0x7c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008c5a:	6ff9      	ldr	r1, [r7, #124]	; 0x7c
 8008c5c:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
 8008c60:	e841 2300 	strex	r3, r2, [r1]
 8008c64:	67bb      	str	r3, [r7, #120]	; 0x78
   return(result);
 8008c66:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8008c68:	2b00      	cmp	r3, #0
 8008c6a:	d1e1      	bne.n	8008c30 <HAL_UART_IRQHandler+0x450>

          /* Disable the DMA transfer for the receiver request by resetting the DMAR bit
             in the UART CR3 register */
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8008c6c:	687b      	ldr	r3, [r7, #4]
 8008c6e:	681b      	ldr	r3, [r3, #0]
 8008c70:	3308      	adds	r3, #8
 8008c72:	663b      	str	r3, [r7, #96]	; 0x60
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008c74:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8008c76:	e853 3f00 	ldrex	r3, [r3]
 8008c7a:	65fb      	str	r3, [r7, #92]	; 0x5c
   return(result);
 8008c7c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8008c7e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8008c82:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
 8008c86:	687b      	ldr	r3, [r7, #4]
 8008c88:	681b      	ldr	r3, [r3, #0]
 8008c8a:	3308      	adds	r3, #8
 8008c8c:	f8d7 20b0 	ldr.w	r2, [r7, #176]	; 0xb0
 8008c90:	66fa      	str	r2, [r7, #108]	; 0x6c
 8008c92:	66bb      	str	r3, [r7, #104]	; 0x68
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008c94:	6eb9      	ldr	r1, [r7, #104]	; 0x68
 8008c96:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8008c98:	e841 2300 	strex	r3, r2, [r1]
 8008c9c:	667b      	str	r3, [r7, #100]	; 0x64
   return(result);
 8008c9e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8008ca0:	2b00      	cmp	r3, #0
 8008ca2:	d1e3      	bne.n	8008c6c <HAL_UART_IRQHandler+0x48c>

          /* At end of Rx process, restore huart->RxState to Ready */
          huart->RxState = HAL_UART_STATE_READY;
 8008ca4:	687b      	ldr	r3, [r7, #4]
 8008ca6:	2220      	movs	r2, #32
 8008ca8:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8008cac:	687b      	ldr	r3, [r7, #4]
 8008cae:	2200      	movs	r2, #0
 8008cb0:	66da      	str	r2, [r3, #108]	; 0x6c

          ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8008cb2:	687b      	ldr	r3, [r7, #4]
 8008cb4:	681b      	ldr	r3, [r3, #0]
 8008cb6:	64fb      	str	r3, [r7, #76]	; 0x4c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008cb8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8008cba:	e853 3f00 	ldrex	r3, [r3]
 8008cbe:	64bb      	str	r3, [r7, #72]	; 0x48
   return(result);
 8008cc0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8008cc2:	f023 0310 	bic.w	r3, r3, #16
 8008cc6:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
 8008cca:	687b      	ldr	r3, [r7, #4]
 8008ccc:	681b      	ldr	r3, [r3, #0]
 8008cce:	461a      	mov	r2, r3
 8008cd0:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8008cd4:	65bb      	str	r3, [r7, #88]	; 0x58
 8008cd6:	657a      	str	r2, [r7, #84]	; 0x54
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008cd8:	6d79      	ldr	r1, [r7, #84]	; 0x54
 8008cda:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8008cdc:	e841 2300 	strex	r3, r2, [r1]
 8008ce0:	653b      	str	r3, [r7, #80]	; 0x50
   return(result);
 8008ce2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8008ce4:	2b00      	cmp	r3, #0
 8008ce6:	d1e4      	bne.n	8008cb2 <HAL_UART_IRQHandler+0x4d2>

          /* Last bytes received, so no need as the abort is immediate */
          (void)HAL_DMA_Abort(huart->hdmarx);
 8008ce8:	687b      	ldr	r3, [r7, #4]
 8008cea:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8008cec:	4618      	mov	r0, r3
 8008cee:	f7f8 fde7 	bl	80018c0 <HAL_DMA_Abort>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
 8008cf2:	687b      	ldr	r3, [r7, #4]
 8008cf4:	f8b3 205c 	ldrh.w	r2, [r3, #92]	; 0x5c
 8008cf8:	687b      	ldr	r3, [r7, #4]
 8008cfa:	f8b3 305e 	ldrh.w	r3, [r3, #94]	; 0x5e
 8008cfe:	b29b      	uxth	r3, r3
 8008d00:	1ad3      	subs	r3, r2, r3
 8008d02:	b29b      	uxth	r3, r3
 8008d04:	4619      	mov	r1, r3
 8008d06:	6878      	ldr	r0, [r7, #4]
 8008d08:	f000 f926 	bl	8008f58 <HAL_UARTEx_RxEventCallback>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
      }
      return;
 8008d0c:	e0fb      	b.n	8008f06 <HAL_UART_IRQHandler+0x726>
 8008d0e:	bf00      	nop
 8008d10:	40020010 	.word	0x40020010
 8008d14:	40020028 	.word	0x40020028
 8008d18:	40020040 	.word	0x40020040
 8008d1c:	40020058 	.word	0x40020058
 8008d20:	40020070 	.word	0x40020070
 8008d24:	40020088 	.word	0x40020088
 8008d28:	400200a0 	.word	0x400200a0
 8008d2c:	400200b8 	.word	0x400200b8
 8008d30:	40020410 	.word	0x40020410
 8008d34:	40020428 	.word	0x40020428
 8008d38:	40020440 	.word	0x40020440
 8008d3c:	40020458 	.word	0x40020458
 8008d40:	40020470 	.word	0x40020470
 8008d44:	40020488 	.word	0x40020488
 8008d48:	400204a0 	.word	0x400204a0
 8008d4c:	400204b8 	.word	0x400204b8
    else
    {
      /* DMA mode not enabled */
      /* Check received length : If all expected data are received, do nothing.
         Otherwise, if at least one data has already been received, IDLE event is to be notified to user */
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
 8008d50:	687b      	ldr	r3, [r7, #4]
 8008d52:	f8b3 205c 	ldrh.w	r2, [r3, #92]	; 0x5c
 8008d56:	687b      	ldr	r3, [r7, #4]
 8008d58:	f8b3 305e 	ldrh.w	r3, [r3, #94]	; 0x5e
 8008d5c:	b29b      	uxth	r3, r3
 8008d5e:	1ad3      	subs	r3, r2, r3
 8008d60:	f8a7 30ce 	strh.w	r3, [r7, #206]	; 0xce
      if ((huart->RxXferCount > 0U)
 8008d64:	687b      	ldr	r3, [r7, #4]
 8008d66:	f8b3 305e 	ldrh.w	r3, [r3, #94]	; 0x5e
 8008d6a:	b29b      	uxth	r3, r3
 8008d6c:	2b00      	cmp	r3, #0
 8008d6e:	f000 80cc 	beq.w	8008f0a <HAL_UART_IRQHandler+0x72a>
          && (nb_rx_data > 0U))
 8008d72:	f8b7 30ce 	ldrh.w	r3, [r7, #206]	; 0xce
 8008d76:	2b00      	cmp	r3, #0
 8008d78:	f000 80c7 	beq.w	8008f0a <HAL_UART_IRQHandler+0x72a>
      {
        /* Disable the UART Parity Error Interrupt and RXNE interrupts */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 8008d7c:	687b      	ldr	r3, [r7, #4]
 8008d7e:	681b      	ldr	r3, [r3, #0]
 8008d80:	63bb      	str	r3, [r7, #56]	; 0x38
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008d82:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8008d84:	e853 3f00 	ldrex	r3, [r3]
 8008d88:	637b      	str	r3, [r7, #52]	; 0x34
   return(result);
 8008d8a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008d8c:	f423 7390 	bic.w	r3, r3, #288	; 0x120
 8008d90:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
 8008d94:	687b      	ldr	r3, [r7, #4]
 8008d96:	681b      	ldr	r3, [r3, #0]
 8008d98:	461a      	mov	r2, r3
 8008d9a:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8008d9e:	647b      	str	r3, [r7, #68]	; 0x44
 8008da0:	643a      	str	r2, [r7, #64]	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008da2:	6c39      	ldr	r1, [r7, #64]	; 0x40
 8008da4:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8008da6:	e841 2300 	strex	r3, r2, [r1]
 8008daa:	63fb      	str	r3, [r7, #60]	; 0x3c
   return(result);
 8008dac:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8008dae:	2b00      	cmp	r3, #0
 8008db0:	d1e4      	bne.n	8008d7c <HAL_UART_IRQHandler+0x59c>

        /* Disable the UART Error Interrupt:(Frame error, noise error, overrun error) and RX FIFO Threshold interrupt */
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 8008db2:	687b      	ldr	r3, [r7, #4]
 8008db4:	681b      	ldr	r3, [r3, #0]
 8008db6:	3308      	adds	r3, #8
 8008db8:	627b      	str	r3, [r7, #36]	; 0x24
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008dba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008dbc:	e853 3f00 	ldrex	r3, [r3]
 8008dc0:	623b      	str	r3, [r7, #32]
   return(result);
 8008dc2:	6a3a      	ldr	r2, [r7, #32]
 8008dc4:	4b54      	ldr	r3, [pc, #336]	; (8008f18 <HAL_UART_IRQHandler+0x738>)
 8008dc6:	4013      	ands	r3, r2
 8008dc8:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
 8008dcc:	687b      	ldr	r3, [r7, #4]
 8008dce:	681b      	ldr	r3, [r3, #0]
 8008dd0:	3308      	adds	r3, #8
 8008dd2:	f8d7 20c4 	ldr.w	r2, [r7, #196]	; 0xc4
 8008dd6:	633a      	str	r2, [r7, #48]	; 0x30
 8008dd8:	62fb      	str	r3, [r7, #44]	; 0x2c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008dda:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8008ddc:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8008dde:	e841 2300 	strex	r3, r2, [r1]
 8008de2:	62bb      	str	r3, [r7, #40]	; 0x28
   return(result);
 8008de4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008de6:	2b00      	cmp	r3, #0
 8008de8:	d1e3      	bne.n	8008db2 <HAL_UART_IRQHandler+0x5d2>

        /* Rx process is completed, restore huart->RxState to Ready */
        huart->RxState = HAL_UART_STATE_READY;
 8008dea:	687b      	ldr	r3, [r7, #4]
 8008dec:	2220      	movs	r2, #32
 8008dee:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8008df2:	687b      	ldr	r3, [r7, #4]
 8008df4:	2200      	movs	r2, #0
 8008df6:	66da      	str	r2, [r3, #108]	; 0x6c

        /* Clear RxISR function pointer */
        huart->RxISR = NULL;
 8008df8:	687b      	ldr	r3, [r7, #4]
 8008dfa:	2200      	movs	r2, #0
 8008dfc:	671a      	str	r2, [r3, #112]	; 0x70

        ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8008dfe:	687b      	ldr	r3, [r7, #4]
 8008e00:	681b      	ldr	r3, [r3, #0]
 8008e02:	613b      	str	r3, [r7, #16]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8008e04:	693b      	ldr	r3, [r7, #16]
 8008e06:	e853 3f00 	ldrex	r3, [r3]
 8008e0a:	60fb      	str	r3, [r7, #12]
   return(result);
 8008e0c:	68fb      	ldr	r3, [r7, #12]
 8008e0e:	f023 0310 	bic.w	r3, r3, #16
 8008e12:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
 8008e16:	687b      	ldr	r3, [r7, #4]
 8008e18:	681b      	ldr	r3, [r3, #0]
 8008e1a:	461a      	mov	r2, r3
 8008e1c:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 8008e20:	61fb      	str	r3, [r7, #28]
 8008e22:	61ba      	str	r2, [r7, #24]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8008e24:	69b9      	ldr	r1, [r7, #24]
 8008e26:	69fa      	ldr	r2, [r7, #28]
 8008e28:	e841 2300 	strex	r3, r2, [r1]
 8008e2c:	617b      	str	r3, [r7, #20]
   return(result);
 8008e2e:	697b      	ldr	r3, [r7, #20]
 8008e30:	2b00      	cmp	r3, #0
 8008e32:	d1e4      	bne.n	8008dfe <HAL_UART_IRQHandler+0x61e>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx complete callback*/
        huart->RxEventCallback(huart, nb_rx_data);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, nb_rx_data);
 8008e34:	f8b7 30ce 	ldrh.w	r3, [r7, #206]	; 0xce
 8008e38:	4619      	mov	r1, r3
 8008e3a:	6878      	ldr	r0, [r7, #4]
 8008e3c:	f000 f88c 	bl	8008f58 <HAL_UARTEx_RxEventCallback>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
      }
      return;
 8008e40:	e063      	b.n	8008f0a <HAL_UART_IRQHandler+0x72a>
    }
  }

  /* UART wakeup from Stop mode interrupt occurred ---------------------------*/
  if (((isrflags & USART_ISR_WUF) != 0U) && ((cr3its & USART_CR3_WUFIE) != 0U))
 8008e42:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8008e46:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8008e4a:	2b00      	cmp	r3, #0
 8008e4c:	d00e      	beq.n	8008e6c <HAL_UART_IRQHandler+0x68c>
 8008e4e:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8008e52:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8008e56:	2b00      	cmp	r3, #0
 8008e58:	d008      	beq.n	8008e6c <HAL_UART_IRQHandler+0x68c>
  {
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
 8008e5a:	687b      	ldr	r3, [r7, #4]
 8008e5c:	681b      	ldr	r3, [r3, #0]
 8008e5e:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 8008e62:	621a      	str	r2, [r3, #32]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    /* Call registered Wakeup Callback */
    huart->WakeupCallback(huart);
#else
    /* Call legacy weak Wakeup Callback */
    HAL_UARTEx_WakeupCallback(huart);
 8008e64:	6878      	ldr	r0, [r7, #4]
 8008e66:	f001 fa70 	bl	800a34a <HAL_UARTEx_WakeupCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
    return;
 8008e6a:	e051      	b.n	8008f10 <HAL_UART_IRQHandler+0x730>
  }

  /* UART in mode Transmitter ------------------------------------------------*/
  if (((isrflags & USART_ISR_TXE_TXFNF) != 0U)
 8008e6c:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8008e70:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8008e74:	2b00      	cmp	r3, #0
 8008e76:	d014      	beq.n	8008ea2 <HAL_UART_IRQHandler+0x6c2>
      && (((cr1its & USART_CR1_TXEIE_TXFNFIE) != 0U)
 8008e78:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8008e7c:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8008e80:	2b00      	cmp	r3, #0
 8008e82:	d105      	bne.n	8008e90 <HAL_UART_IRQHandler+0x6b0>
          || ((cr3its & USART_CR3_TXFTIE) != 0U)))
 8008e84:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8008e88:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8008e8c:	2b00      	cmp	r3, #0
 8008e8e:	d008      	beq.n	8008ea2 <HAL_UART_IRQHandler+0x6c2>
  {
    if (huart->TxISR != NULL)
 8008e90:	687b      	ldr	r3, [r7, #4]
 8008e92:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8008e94:	2b00      	cmp	r3, #0
 8008e96:	d03a      	beq.n	8008f0e <HAL_UART_IRQHandler+0x72e>
    {
      huart->TxISR(huart);
 8008e98:	687b      	ldr	r3, [r7, #4]
 8008e9a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8008e9c:	6878      	ldr	r0, [r7, #4]
 8008e9e:	4798      	blx	r3
    }
    return;
 8008ea0:	e035      	b.n	8008f0e <HAL_UART_IRQHandler+0x72e>
  }

  /* UART in mode Transmitter (transmission end) -----------------------------*/
  if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))
 8008ea2:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8008ea6:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8008eaa:	2b00      	cmp	r3, #0
 8008eac:	d009      	beq.n	8008ec2 <HAL_UART_IRQHandler+0x6e2>
 8008eae:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8008eb2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8008eb6:	2b00      	cmp	r3, #0
 8008eb8:	d003      	beq.n	8008ec2 <HAL_UART_IRQHandler+0x6e2>
  {
    UART_EndTransmit_IT(huart);
 8008eba:	6878      	ldr	r0, [r7, #4]
 8008ebc:	f001 fa1a 	bl	800a2f4 <UART_EndTransmit_IT>
    return;
 8008ec0:	e026      	b.n	8008f10 <HAL_UART_IRQHandler+0x730>
  }

  /* UART TX Fifo Empty occurred ----------------------------------------------*/
  if (((isrflags & USART_ISR_TXFE) != 0U) && ((cr1its & USART_CR1_TXFEIE) != 0U))
 8008ec2:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8008ec6:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8008eca:	2b00      	cmp	r3, #0
 8008ecc:	d009      	beq.n	8008ee2 <HAL_UART_IRQHandler+0x702>
 8008ece:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8008ed2:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 8008ed6:	2b00      	cmp	r3, #0
 8008ed8:	d003      	beq.n	8008ee2 <HAL_UART_IRQHandler+0x702>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    /* Call registered Tx Fifo Empty Callback */
    huart->TxFifoEmptyCallback(huart);
#else
    /* Call legacy weak Tx Fifo Empty Callback */
    HAL_UARTEx_TxFifoEmptyCallback(huart);
 8008eda:	6878      	ldr	r0, [r7, #4]
 8008edc:	f001 fa49 	bl	800a372 <HAL_UARTEx_TxFifoEmptyCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
    return;
 8008ee0:	e016      	b.n	8008f10 <HAL_UART_IRQHandler+0x730>
  }

  /* UART RX Fifo Full occurred ----------------------------------------------*/
  if (((isrflags & USART_ISR_RXFF) != 0U) && ((cr1its & USART_CR1_RXFFIE) != 0U))
 8008ee2:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8008ee6:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 8008eea:	2b00      	cmp	r3, #0
 8008eec:	d010      	beq.n	8008f10 <HAL_UART_IRQHandler+0x730>
 8008eee:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8008ef2:	2b00      	cmp	r3, #0
 8008ef4:	da0c      	bge.n	8008f10 <HAL_UART_IRQHandler+0x730>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    /* Call registered Rx Fifo Full Callback */
    huart->RxFifoFullCallback(huart);
#else
    /* Call legacy weak Rx Fifo Full Callback */
    HAL_UARTEx_RxFifoFullCallback(huart);
 8008ef6:	6878      	ldr	r0, [r7, #4]
 8008ef8:	f001 fa31 	bl	800a35e <HAL_UARTEx_RxFifoFullCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
    return;
 8008efc:	e008      	b.n	8008f10 <HAL_UART_IRQHandler+0x730>
      return;
 8008efe:	bf00      	nop
 8008f00:	e006      	b.n	8008f10 <HAL_UART_IRQHandler+0x730>
    return;
 8008f02:	bf00      	nop
 8008f04:	e004      	b.n	8008f10 <HAL_UART_IRQHandler+0x730>
      return;
 8008f06:	bf00      	nop
 8008f08:	e002      	b.n	8008f10 <HAL_UART_IRQHandler+0x730>
      return;
 8008f0a:	bf00      	nop
 8008f0c:	e000      	b.n	8008f10 <HAL_UART_IRQHandler+0x730>
    return;
 8008f0e:	bf00      	nop
  }
}
 8008f10:	37e8      	adds	r7, #232	; 0xe8
 8008f12:	46bd      	mov	sp, r7
 8008f14:	bd80      	pop	{r7, pc}
 8008f16:	bf00      	nop
 8008f18:	effffffe 	.word	0xeffffffe

08008f1c <HAL_UART_TxHalfCpltCallback>:
  * @brief  Tx Half Transfer completed callback.
  * @param  huart UART handle.
  * @retval None
  */
__weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
{
 8008f1c:	b480      	push	{r7}
 8008f1e:	b083      	sub	sp, #12
 8008f20:	af00      	add	r7, sp, #0
 8008f22:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_TxHalfCpltCallback can be implemented in the user file.
   */
}
 8008f24:	bf00      	nop
 8008f26:	370c      	adds	r7, #12
 8008f28:	46bd      	mov	sp, r7
 8008f2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008f2e:	4770      	bx	lr

08008f30 <HAL_UART_RxHalfCpltCallback>:
  * @brief  Rx Half Transfer completed callback.
  * @param  huart UART handle.
  * @retval None
  */
__weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
{
 8008f30:	b480      	push	{r7}
 8008f32:	b083      	sub	sp, #12
 8008f34:	af00      	add	r7, sp, #0
 8008f36:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_RxHalfCpltCallback can be implemented in the user file.
   */
}
 8008f38:	bf00      	nop
 8008f3a:	370c      	adds	r7, #12
 8008f3c:	46bd      	mov	sp, r7
 8008f3e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008f42:	4770      	bx	lr

08008f44 <HAL_UART_ErrorCallback>:
  * @brief  UART error callback.
  * @param  huart UART handle.
  * @retval None
  */
__weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
 8008f44:	b480      	push	{r7}
 8008f46:	b083      	sub	sp, #12
 8008f48:	af00      	add	r7, sp, #0
 8008f4a:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_ErrorCallback can be implemented in the user file.
   */
}
 8008f4c:	bf00      	nop
 8008f4e:	370c      	adds	r7, #12
 8008f50:	46bd      	mov	sp, r7
 8008f52:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008f56:	4770      	bx	lr

08008f58 <HAL_UARTEx_RxEventCallback>:
  * @param  Size  Number of data available in application reception buffer (indicates a position in
  *               reception buffer until which, data are available)
  * @retval None
  */
__weak void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
{
 8008f58:	b480      	push	{r7}
 8008f5a:	b083      	sub	sp, #12
 8008f5c:	af00      	add	r7, sp, #0
 8008f5e:	6078      	str	r0, [r7, #4]
 8008f60:	460b      	mov	r3, r1
 8008f62:	807b      	strh	r3, [r7, #2]
  UNUSED(Size);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_RxEventCallback can be implemented in the user file.
   */
}
 8008f64:	bf00      	nop
 8008f66:	370c      	adds	r7, #12
 8008f68:	46bd      	mov	sp, r7
 8008f6a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008f6e:	4770      	bx	lr

08008f70 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 8008f70:	b5b0      	push	{r4, r5, r7, lr}
 8008f72:	b08e      	sub	sp, #56	; 0x38
 8008f74:	af00      	add	r7, sp, #0
 8008f76:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;
  uint16_t brrtemp;
  UART_ClockSourceTypeDef clocksource;
  uint32_t usartdiv;
  HAL_StatusTypeDef ret               = HAL_OK;
 8008f78:	2300      	movs	r3, #0
 8008f7a:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8008f7e:	687b      	ldr	r3, [r7, #4]
 8008f80:	689a      	ldr	r2, [r3, #8]
 8008f82:	687b      	ldr	r3, [r7, #4]
 8008f84:	691b      	ldr	r3, [r3, #16]
 8008f86:	431a      	orrs	r2, r3
 8008f88:	687b      	ldr	r3, [r7, #4]
 8008f8a:	695b      	ldr	r3, [r3, #20]
 8008f8c:	431a      	orrs	r2, r3
 8008f8e:	687b      	ldr	r3, [r7, #4]
 8008f90:	69db      	ldr	r3, [r3, #28]
 8008f92:	4313      	orrs	r3, r2
 8008f94:	637b      	str	r3, [r7, #52]	; 0x34
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8008f96:	687b      	ldr	r3, [r7, #4]
 8008f98:	681b      	ldr	r3, [r3, #0]
 8008f9a:	681a      	ldr	r2, [r3, #0]
 8008f9c:	4bbf      	ldr	r3, [pc, #764]	; (800929c <UART_SetConfig+0x32c>)
 8008f9e:	4013      	ands	r3, r2
 8008fa0:	687a      	ldr	r2, [r7, #4]
 8008fa2:	6812      	ldr	r2, [r2, #0]
 8008fa4:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8008fa6:	430b      	orrs	r3, r1
 8008fa8:	6013      	str	r3, [r2, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8008faa:	687b      	ldr	r3, [r7, #4]
 8008fac:	681b      	ldr	r3, [r3, #0]
 8008fae:	685b      	ldr	r3, [r3, #4]
 8008fb0:	f423 5140 	bic.w	r1, r3, #12288	; 0x3000
 8008fb4:	687b      	ldr	r3, [r7, #4]
 8008fb6:	68da      	ldr	r2, [r3, #12]
 8008fb8:	687b      	ldr	r3, [r7, #4]
 8008fba:	681b      	ldr	r3, [r3, #0]
 8008fbc:	430a      	orrs	r2, r1
 8008fbe:	605a      	str	r2, [r3, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 8008fc0:	687b      	ldr	r3, [r7, #4]
 8008fc2:	699b      	ldr	r3, [r3, #24]
 8008fc4:	637b      	str	r3, [r7, #52]	; 0x34

  if (!(UART_INSTANCE_LOWPOWER(huart)))
 8008fc6:	687b      	ldr	r3, [r7, #4]
 8008fc8:	681b      	ldr	r3, [r3, #0]
 8008fca:	4ab5      	ldr	r2, [pc, #724]	; (80092a0 <UART_SetConfig+0x330>)
 8008fcc:	4293      	cmp	r3, r2
 8008fce:	d004      	beq.n	8008fda <UART_SetConfig+0x6a>
  {
    tmpreg |= huart->Init.OneBitSampling;
 8008fd0:	687b      	ldr	r3, [r7, #4]
 8008fd2:	6a1b      	ldr	r3, [r3, #32]
 8008fd4:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8008fd6:	4313      	orrs	r3, r2
 8008fd8:	637b      	str	r3, [r7, #52]	; 0x34
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8008fda:	687b      	ldr	r3, [r7, #4]
 8008fdc:	681b      	ldr	r3, [r3, #0]
 8008fde:	689a      	ldr	r2, [r3, #8]
 8008fe0:	4bb0      	ldr	r3, [pc, #704]	; (80092a4 <UART_SetConfig+0x334>)
 8008fe2:	4013      	ands	r3, r2
 8008fe4:	687a      	ldr	r2, [r7, #4]
 8008fe6:	6812      	ldr	r2, [r2, #0]
 8008fe8:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8008fea:	430b      	orrs	r3, r1
 8008fec:	6093      	str	r3, [r2, #8]

  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 8008fee:	687b      	ldr	r3, [r7, #4]
 8008ff0:	681b      	ldr	r3, [r3, #0]
 8008ff2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8008ff4:	f023 010f 	bic.w	r1, r3, #15
 8008ff8:	687b      	ldr	r3, [r7, #4]
 8008ffa:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8008ffc:	687b      	ldr	r3, [r7, #4]
 8008ffe:	681b      	ldr	r3, [r3, #0]
 8009000:	430a      	orrs	r2, r1
 8009002:	62da      	str	r2, [r3, #44]	; 0x2c

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 8009004:	687b      	ldr	r3, [r7, #4]
 8009006:	681b      	ldr	r3, [r3, #0]
 8009008:	4aa7      	ldr	r2, [pc, #668]	; (80092a8 <UART_SetConfig+0x338>)
 800900a:	4293      	cmp	r3, r2
 800900c:	d176      	bne.n	80090fc <UART_SetConfig+0x18c>
 800900e:	4ba7      	ldr	r3, [pc, #668]	; (80092ac <UART_SetConfig+0x33c>)
 8009010:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8009012:	f003 0338 	and.w	r3, r3, #56	; 0x38
 8009016:	2b28      	cmp	r3, #40	; 0x28
 8009018:	d86c      	bhi.n	80090f4 <UART_SetConfig+0x184>
 800901a:	a201      	add	r2, pc, #4	; (adr r2, 8009020 <UART_SetConfig+0xb0>)
 800901c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8009020:	080090c5 	.word	0x080090c5
 8009024:	080090f5 	.word	0x080090f5
 8009028:	080090f5 	.word	0x080090f5
 800902c:	080090f5 	.word	0x080090f5
 8009030:	080090f5 	.word	0x080090f5
 8009034:	080090f5 	.word	0x080090f5
 8009038:	080090f5 	.word	0x080090f5
 800903c:	080090f5 	.word	0x080090f5
 8009040:	080090cd 	.word	0x080090cd
 8009044:	080090f5 	.word	0x080090f5
 8009048:	080090f5 	.word	0x080090f5
 800904c:	080090f5 	.word	0x080090f5
 8009050:	080090f5 	.word	0x080090f5
 8009054:	080090f5 	.word	0x080090f5
 8009058:	080090f5 	.word	0x080090f5
 800905c:	080090f5 	.word	0x080090f5
 8009060:	080090d5 	.word	0x080090d5
 8009064:	080090f5 	.word	0x080090f5
 8009068:	080090f5 	.word	0x080090f5
 800906c:	080090f5 	.word	0x080090f5
 8009070:	080090f5 	.word	0x080090f5
 8009074:	080090f5 	.word	0x080090f5
 8009078:	080090f5 	.word	0x080090f5
 800907c:	080090f5 	.word	0x080090f5
 8009080:	080090dd 	.word	0x080090dd
 8009084:	080090f5 	.word	0x080090f5
 8009088:	080090f5 	.word	0x080090f5
 800908c:	080090f5 	.word	0x080090f5
 8009090:	080090f5 	.word	0x080090f5
 8009094:	080090f5 	.word	0x080090f5
 8009098:	080090f5 	.word	0x080090f5
 800909c:	080090f5 	.word	0x080090f5
 80090a0:	080090e5 	.word	0x080090e5
 80090a4:	080090f5 	.word	0x080090f5
 80090a8:	080090f5 	.word	0x080090f5
 80090ac:	080090f5 	.word	0x080090f5
 80090b0:	080090f5 	.word	0x080090f5
 80090b4:	080090f5 	.word	0x080090f5
 80090b8:	080090f5 	.word	0x080090f5
 80090bc:	080090f5 	.word	0x080090f5
 80090c0:	080090ed 	.word	0x080090ed
 80090c4:	2301      	movs	r3, #1
 80090c6:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 80090ca:	e222      	b.n	8009512 <UART_SetConfig+0x5a2>
 80090cc:	2304      	movs	r3, #4
 80090ce:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 80090d2:	e21e      	b.n	8009512 <UART_SetConfig+0x5a2>
 80090d4:	2308      	movs	r3, #8
 80090d6:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 80090da:	e21a      	b.n	8009512 <UART_SetConfig+0x5a2>
 80090dc:	2310      	movs	r3, #16
 80090de:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 80090e2:	e216      	b.n	8009512 <UART_SetConfig+0x5a2>
 80090e4:	2320      	movs	r3, #32
 80090e6:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 80090ea:	e212      	b.n	8009512 <UART_SetConfig+0x5a2>
 80090ec:	2340      	movs	r3, #64	; 0x40
 80090ee:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 80090f2:	e20e      	b.n	8009512 <UART_SetConfig+0x5a2>
 80090f4:	2380      	movs	r3, #128	; 0x80
 80090f6:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 80090fa:	e20a      	b.n	8009512 <UART_SetConfig+0x5a2>
 80090fc:	687b      	ldr	r3, [r7, #4]
 80090fe:	681b      	ldr	r3, [r3, #0]
 8009100:	4a6b      	ldr	r2, [pc, #428]	; (80092b0 <UART_SetConfig+0x340>)
 8009102:	4293      	cmp	r3, r2
 8009104:	d130      	bne.n	8009168 <UART_SetConfig+0x1f8>
 8009106:	4b69      	ldr	r3, [pc, #420]	; (80092ac <UART_SetConfig+0x33c>)
 8009108:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800910a:	f003 0307 	and.w	r3, r3, #7
 800910e:	2b05      	cmp	r3, #5
 8009110:	d826      	bhi.n	8009160 <UART_SetConfig+0x1f0>
 8009112:	a201      	add	r2, pc, #4	; (adr r2, 8009118 <UART_SetConfig+0x1a8>)
 8009114:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8009118:	08009131 	.word	0x08009131
 800911c:	08009139 	.word	0x08009139
 8009120:	08009141 	.word	0x08009141
 8009124:	08009149 	.word	0x08009149
 8009128:	08009151 	.word	0x08009151
 800912c:	08009159 	.word	0x08009159
 8009130:	2300      	movs	r3, #0
 8009132:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 8009136:	e1ec      	b.n	8009512 <UART_SetConfig+0x5a2>
 8009138:	2304      	movs	r3, #4
 800913a:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 800913e:	e1e8      	b.n	8009512 <UART_SetConfig+0x5a2>
 8009140:	2308      	movs	r3, #8
 8009142:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 8009146:	e1e4      	b.n	8009512 <UART_SetConfig+0x5a2>
 8009148:	2310      	movs	r3, #16
 800914a:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 800914e:	e1e0      	b.n	8009512 <UART_SetConfig+0x5a2>
 8009150:	2320      	movs	r3, #32
 8009152:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 8009156:	e1dc      	b.n	8009512 <UART_SetConfig+0x5a2>
 8009158:	2340      	movs	r3, #64	; 0x40
 800915a:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 800915e:	e1d8      	b.n	8009512 <UART_SetConfig+0x5a2>
 8009160:	2380      	movs	r3, #128	; 0x80
 8009162:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 8009166:	e1d4      	b.n	8009512 <UART_SetConfig+0x5a2>
 8009168:	687b      	ldr	r3, [r7, #4]
 800916a:	681b      	ldr	r3, [r3, #0]
 800916c:	4a51      	ldr	r2, [pc, #324]	; (80092b4 <UART_SetConfig+0x344>)
 800916e:	4293      	cmp	r3, r2
 8009170:	d130      	bne.n	80091d4 <UART_SetConfig+0x264>
 8009172:	4b4e      	ldr	r3, [pc, #312]	; (80092ac <UART_SetConfig+0x33c>)
 8009174:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8009176:	f003 0307 	and.w	r3, r3, #7
 800917a:	2b05      	cmp	r3, #5
 800917c:	d826      	bhi.n	80091cc <UART_SetConfig+0x25c>
 800917e:	a201      	add	r2, pc, #4	; (adr r2, 8009184 <UART_SetConfig+0x214>)
 8009180:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8009184:	0800919d 	.word	0x0800919d
 8009188:	080091a5 	.word	0x080091a5
 800918c:	080091ad 	.word	0x080091ad
 8009190:	080091b5 	.word	0x080091b5
 8009194:	080091bd 	.word	0x080091bd
 8009198:	080091c5 	.word	0x080091c5
 800919c:	2300      	movs	r3, #0
 800919e:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 80091a2:	e1b6      	b.n	8009512 <UART_SetConfig+0x5a2>
 80091a4:	2304      	movs	r3, #4
 80091a6:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 80091aa:	e1b2      	b.n	8009512 <UART_SetConfig+0x5a2>
 80091ac:	2308      	movs	r3, #8
 80091ae:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 80091b2:	e1ae      	b.n	8009512 <UART_SetConfig+0x5a2>
 80091b4:	2310      	movs	r3, #16
 80091b6:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 80091ba:	e1aa      	b.n	8009512 <UART_SetConfig+0x5a2>
 80091bc:	2320      	movs	r3, #32
 80091be:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 80091c2:	e1a6      	b.n	8009512 <UART_SetConfig+0x5a2>
 80091c4:	2340      	movs	r3, #64	; 0x40
 80091c6:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 80091ca:	e1a2      	b.n	8009512 <UART_SetConfig+0x5a2>
 80091cc:	2380      	movs	r3, #128	; 0x80
 80091ce:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 80091d2:	e19e      	b.n	8009512 <UART_SetConfig+0x5a2>
 80091d4:	687b      	ldr	r3, [r7, #4]
 80091d6:	681b      	ldr	r3, [r3, #0]
 80091d8:	4a37      	ldr	r2, [pc, #220]	; (80092b8 <UART_SetConfig+0x348>)
 80091da:	4293      	cmp	r3, r2
 80091dc:	d130      	bne.n	8009240 <UART_SetConfig+0x2d0>
 80091de:	4b33      	ldr	r3, [pc, #204]	; (80092ac <UART_SetConfig+0x33c>)
 80091e0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80091e2:	f003 0307 	and.w	r3, r3, #7
 80091e6:	2b05      	cmp	r3, #5
 80091e8:	d826      	bhi.n	8009238 <UART_SetConfig+0x2c8>
 80091ea:	a201      	add	r2, pc, #4	; (adr r2, 80091f0 <UART_SetConfig+0x280>)
 80091ec:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80091f0:	08009209 	.word	0x08009209
 80091f4:	08009211 	.word	0x08009211
 80091f8:	08009219 	.word	0x08009219
 80091fc:	08009221 	.word	0x08009221
 8009200:	08009229 	.word	0x08009229
 8009204:	08009231 	.word	0x08009231
 8009208:	2300      	movs	r3, #0
 800920a:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 800920e:	e180      	b.n	8009512 <UART_SetConfig+0x5a2>
 8009210:	2304      	movs	r3, #4
 8009212:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 8009216:	e17c      	b.n	8009512 <UART_SetConfig+0x5a2>
 8009218:	2308      	movs	r3, #8
 800921a:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 800921e:	e178      	b.n	8009512 <UART_SetConfig+0x5a2>
 8009220:	2310      	movs	r3, #16
 8009222:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 8009226:	e174      	b.n	8009512 <UART_SetConfig+0x5a2>
 8009228:	2320      	movs	r3, #32
 800922a:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 800922e:	e170      	b.n	8009512 <UART_SetConfig+0x5a2>
 8009230:	2340      	movs	r3, #64	; 0x40
 8009232:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 8009236:	e16c      	b.n	8009512 <UART_SetConfig+0x5a2>
 8009238:	2380      	movs	r3, #128	; 0x80
 800923a:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 800923e:	e168      	b.n	8009512 <UART_SetConfig+0x5a2>
 8009240:	687b      	ldr	r3, [r7, #4]
 8009242:	681b      	ldr	r3, [r3, #0]
 8009244:	4a1d      	ldr	r2, [pc, #116]	; (80092bc <UART_SetConfig+0x34c>)
 8009246:	4293      	cmp	r3, r2
 8009248:	d142      	bne.n	80092d0 <UART_SetConfig+0x360>
 800924a:	4b18      	ldr	r3, [pc, #96]	; (80092ac <UART_SetConfig+0x33c>)
 800924c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800924e:	f003 0307 	and.w	r3, r3, #7
 8009252:	2b05      	cmp	r3, #5
 8009254:	d838      	bhi.n	80092c8 <UART_SetConfig+0x358>
 8009256:	a201      	add	r2, pc, #4	; (adr r2, 800925c <UART_SetConfig+0x2ec>)
 8009258:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800925c:	08009275 	.word	0x08009275
 8009260:	0800927d 	.word	0x0800927d
 8009264:	08009285 	.word	0x08009285
 8009268:	0800928d 	.word	0x0800928d
 800926c:	08009295 	.word	0x08009295
 8009270:	080092c1 	.word	0x080092c1
 8009274:	2300      	movs	r3, #0
 8009276:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 800927a:	e14a      	b.n	8009512 <UART_SetConfig+0x5a2>
 800927c:	2304      	movs	r3, #4
 800927e:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 8009282:	e146      	b.n	8009512 <UART_SetConfig+0x5a2>
 8009284:	2308      	movs	r3, #8
 8009286:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 800928a:	e142      	b.n	8009512 <UART_SetConfig+0x5a2>
 800928c:	2310      	movs	r3, #16
 800928e:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 8009292:	e13e      	b.n	8009512 <UART_SetConfig+0x5a2>
 8009294:	2320      	movs	r3, #32
 8009296:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 800929a:	e13a      	b.n	8009512 <UART_SetConfig+0x5a2>
 800929c:	cfff69f3 	.word	0xcfff69f3
 80092a0:	58000c00 	.word	0x58000c00
 80092a4:	11fff4ff 	.word	0x11fff4ff
 80092a8:	40011000 	.word	0x40011000
 80092ac:	58024400 	.word	0x58024400
 80092b0:	40004400 	.word	0x40004400
 80092b4:	40004800 	.word	0x40004800
 80092b8:	40004c00 	.word	0x40004c00
 80092bc:	40005000 	.word	0x40005000
 80092c0:	2340      	movs	r3, #64	; 0x40
 80092c2:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 80092c6:	e124      	b.n	8009512 <UART_SetConfig+0x5a2>
 80092c8:	2380      	movs	r3, #128	; 0x80
 80092ca:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 80092ce:	e120      	b.n	8009512 <UART_SetConfig+0x5a2>
 80092d0:	687b      	ldr	r3, [r7, #4]
 80092d2:	681b      	ldr	r3, [r3, #0]
 80092d4:	4acc      	ldr	r2, [pc, #816]	; (8009608 <UART_SetConfig+0x698>)
 80092d6:	4293      	cmp	r3, r2
 80092d8:	d176      	bne.n	80093c8 <UART_SetConfig+0x458>
 80092da:	4bcc      	ldr	r3, [pc, #816]	; (800960c <UART_SetConfig+0x69c>)
 80092dc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80092de:	f003 0338 	and.w	r3, r3, #56	; 0x38
 80092e2:	2b28      	cmp	r3, #40	; 0x28
 80092e4:	d86c      	bhi.n	80093c0 <UART_SetConfig+0x450>
 80092e6:	a201      	add	r2, pc, #4	; (adr r2, 80092ec <UART_SetConfig+0x37c>)
 80092e8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80092ec:	08009391 	.word	0x08009391
 80092f0:	080093c1 	.word	0x080093c1
 80092f4:	080093c1 	.word	0x080093c1
 80092f8:	080093c1 	.word	0x080093c1
 80092fc:	080093c1 	.word	0x080093c1
 8009300:	080093c1 	.word	0x080093c1
 8009304:	080093c1 	.word	0x080093c1
 8009308:	080093c1 	.word	0x080093c1
 800930c:	08009399 	.word	0x08009399
 8009310:	080093c1 	.word	0x080093c1
 8009314:	080093c1 	.word	0x080093c1
 8009318:	080093c1 	.word	0x080093c1
 800931c:	080093c1 	.word	0x080093c1
 8009320:	080093c1 	.word	0x080093c1
 8009324:	080093c1 	.word	0x080093c1
 8009328:	080093c1 	.word	0x080093c1
 800932c:	080093a1 	.word	0x080093a1
 8009330:	080093c1 	.word	0x080093c1
 8009334:	080093c1 	.word	0x080093c1
 8009338:	080093c1 	.word	0x080093c1
 800933c:	080093c1 	.word	0x080093c1
 8009340:	080093c1 	.word	0x080093c1
 8009344:	080093c1 	.word	0x080093c1
 8009348:	080093c1 	.word	0x080093c1
 800934c:	080093a9 	.word	0x080093a9
 8009350:	080093c1 	.word	0x080093c1
 8009354:	080093c1 	.word	0x080093c1
 8009358:	080093c1 	.word	0x080093c1
 800935c:	080093c1 	.word	0x080093c1
 8009360:	080093c1 	.word	0x080093c1
 8009364:	080093c1 	.word	0x080093c1
 8009368:	080093c1 	.word	0x080093c1
 800936c:	080093b1 	.word	0x080093b1
 8009370:	080093c1 	.word	0x080093c1
 8009374:	080093c1 	.word	0x080093c1
 8009378:	080093c1 	.word	0x080093c1
 800937c:	080093c1 	.word	0x080093c1
 8009380:	080093c1 	.word	0x080093c1
 8009384:	080093c1 	.word	0x080093c1
 8009388:	080093c1 	.word	0x080093c1
 800938c:	080093b9 	.word	0x080093b9
 8009390:	2301      	movs	r3, #1
 8009392:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 8009396:	e0bc      	b.n	8009512 <UART_SetConfig+0x5a2>
 8009398:	2304      	movs	r3, #4
 800939a:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 800939e:	e0b8      	b.n	8009512 <UART_SetConfig+0x5a2>
 80093a0:	2308      	movs	r3, #8
 80093a2:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 80093a6:	e0b4      	b.n	8009512 <UART_SetConfig+0x5a2>
 80093a8:	2310      	movs	r3, #16
 80093aa:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 80093ae:	e0b0      	b.n	8009512 <UART_SetConfig+0x5a2>
 80093b0:	2320      	movs	r3, #32
 80093b2:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 80093b6:	e0ac      	b.n	8009512 <UART_SetConfig+0x5a2>
 80093b8:	2340      	movs	r3, #64	; 0x40
 80093ba:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 80093be:	e0a8      	b.n	8009512 <UART_SetConfig+0x5a2>
 80093c0:	2380      	movs	r3, #128	; 0x80
 80093c2:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 80093c6:	e0a4      	b.n	8009512 <UART_SetConfig+0x5a2>
 80093c8:	687b      	ldr	r3, [r7, #4]
 80093ca:	681b      	ldr	r3, [r3, #0]
 80093cc:	4a90      	ldr	r2, [pc, #576]	; (8009610 <UART_SetConfig+0x6a0>)
 80093ce:	4293      	cmp	r3, r2
 80093d0:	d130      	bne.n	8009434 <UART_SetConfig+0x4c4>
 80093d2:	4b8e      	ldr	r3, [pc, #568]	; (800960c <UART_SetConfig+0x69c>)
 80093d4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80093d6:	f003 0307 	and.w	r3, r3, #7
 80093da:	2b05      	cmp	r3, #5
 80093dc:	d826      	bhi.n	800942c <UART_SetConfig+0x4bc>
 80093de:	a201      	add	r2, pc, #4	; (adr r2, 80093e4 <UART_SetConfig+0x474>)
 80093e0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80093e4:	080093fd 	.word	0x080093fd
 80093e8:	08009405 	.word	0x08009405
 80093ec:	0800940d 	.word	0x0800940d
 80093f0:	08009415 	.word	0x08009415
 80093f4:	0800941d 	.word	0x0800941d
 80093f8:	08009425 	.word	0x08009425
 80093fc:	2300      	movs	r3, #0
 80093fe:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 8009402:	e086      	b.n	8009512 <UART_SetConfig+0x5a2>
 8009404:	2304      	movs	r3, #4
 8009406:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 800940a:	e082      	b.n	8009512 <UART_SetConfig+0x5a2>
 800940c:	2308      	movs	r3, #8
 800940e:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 8009412:	e07e      	b.n	8009512 <UART_SetConfig+0x5a2>
 8009414:	2310      	movs	r3, #16
 8009416:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 800941a:	e07a      	b.n	8009512 <UART_SetConfig+0x5a2>
 800941c:	2320      	movs	r3, #32
 800941e:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 8009422:	e076      	b.n	8009512 <UART_SetConfig+0x5a2>
 8009424:	2340      	movs	r3, #64	; 0x40
 8009426:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 800942a:	e072      	b.n	8009512 <UART_SetConfig+0x5a2>
 800942c:	2380      	movs	r3, #128	; 0x80
 800942e:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 8009432:	e06e      	b.n	8009512 <UART_SetConfig+0x5a2>
 8009434:	687b      	ldr	r3, [r7, #4]
 8009436:	681b      	ldr	r3, [r3, #0]
 8009438:	4a76      	ldr	r2, [pc, #472]	; (8009614 <UART_SetConfig+0x6a4>)
 800943a:	4293      	cmp	r3, r2
 800943c:	d130      	bne.n	80094a0 <UART_SetConfig+0x530>
 800943e:	4b73      	ldr	r3, [pc, #460]	; (800960c <UART_SetConfig+0x69c>)
 8009440:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8009442:	f003 0307 	and.w	r3, r3, #7
 8009446:	2b05      	cmp	r3, #5
 8009448:	d826      	bhi.n	8009498 <UART_SetConfig+0x528>
 800944a:	a201      	add	r2, pc, #4	; (adr r2, 8009450 <UART_SetConfig+0x4e0>)
 800944c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8009450:	08009469 	.word	0x08009469
 8009454:	08009471 	.word	0x08009471
 8009458:	08009479 	.word	0x08009479
 800945c:	08009481 	.word	0x08009481
 8009460:	08009489 	.word	0x08009489
 8009464:	08009491 	.word	0x08009491
 8009468:	2300      	movs	r3, #0
 800946a:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 800946e:	e050      	b.n	8009512 <UART_SetConfig+0x5a2>
 8009470:	2304      	movs	r3, #4
 8009472:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 8009476:	e04c      	b.n	8009512 <UART_SetConfig+0x5a2>
 8009478:	2308      	movs	r3, #8
 800947a:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 800947e:	e048      	b.n	8009512 <UART_SetConfig+0x5a2>
 8009480:	2310      	movs	r3, #16
 8009482:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 8009486:	e044      	b.n	8009512 <UART_SetConfig+0x5a2>
 8009488:	2320      	movs	r3, #32
 800948a:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 800948e:	e040      	b.n	8009512 <UART_SetConfig+0x5a2>
 8009490:	2340      	movs	r3, #64	; 0x40
 8009492:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 8009496:	e03c      	b.n	8009512 <UART_SetConfig+0x5a2>
 8009498:	2380      	movs	r3, #128	; 0x80
 800949a:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 800949e:	e038      	b.n	8009512 <UART_SetConfig+0x5a2>
 80094a0:	687b      	ldr	r3, [r7, #4]
 80094a2:	681b      	ldr	r3, [r3, #0]
 80094a4:	4a5c      	ldr	r2, [pc, #368]	; (8009618 <UART_SetConfig+0x6a8>)
 80094a6:	4293      	cmp	r3, r2
 80094a8:	d130      	bne.n	800950c <UART_SetConfig+0x59c>
 80094aa:	4b58      	ldr	r3, [pc, #352]	; (800960c <UART_SetConfig+0x69c>)
 80094ac:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80094ae:	f003 0307 	and.w	r3, r3, #7
 80094b2:	2b05      	cmp	r3, #5
 80094b4:	d826      	bhi.n	8009504 <UART_SetConfig+0x594>
 80094b6:	a201      	add	r2, pc, #4	; (adr r2, 80094bc <UART_SetConfig+0x54c>)
 80094b8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80094bc:	080094d5 	.word	0x080094d5
 80094c0:	080094dd 	.word	0x080094dd
 80094c4:	080094e5 	.word	0x080094e5
 80094c8:	080094ed 	.word	0x080094ed
 80094cc:	080094f5 	.word	0x080094f5
 80094d0:	080094fd 	.word	0x080094fd
 80094d4:	2302      	movs	r3, #2
 80094d6:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 80094da:	e01a      	b.n	8009512 <UART_SetConfig+0x5a2>
 80094dc:	2304      	movs	r3, #4
 80094de:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 80094e2:	e016      	b.n	8009512 <UART_SetConfig+0x5a2>
 80094e4:	2308      	movs	r3, #8
 80094e6:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 80094ea:	e012      	b.n	8009512 <UART_SetConfig+0x5a2>
 80094ec:	2310      	movs	r3, #16
 80094ee:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 80094f2:	e00e      	b.n	8009512 <UART_SetConfig+0x5a2>
 80094f4:	2320      	movs	r3, #32
 80094f6:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 80094fa:	e00a      	b.n	8009512 <UART_SetConfig+0x5a2>
 80094fc:	2340      	movs	r3, #64	; 0x40
 80094fe:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 8009502:	e006      	b.n	8009512 <UART_SetConfig+0x5a2>
 8009504:	2380      	movs	r3, #128	; 0x80
 8009506:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 800950a:	e002      	b.n	8009512 <UART_SetConfig+0x5a2>
 800950c:	2380      	movs	r3, #128	; 0x80
 800950e:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33

  /* Check LPUART instance */
  if (UART_INSTANCE_LOWPOWER(huart))
 8009512:	687b      	ldr	r3, [r7, #4]
 8009514:	681b      	ldr	r3, [r3, #0]
 8009516:	4a40      	ldr	r2, [pc, #256]	; (8009618 <UART_SetConfig+0x6a8>)
 8009518:	4293      	cmp	r3, r2
 800951a:	f040 80ef 	bne.w	80096fc <UART_SetConfig+0x78c>
  {
    /* Retrieve frequency clock */
    switch (clocksource)
 800951e:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8009522:	2b20      	cmp	r3, #32
 8009524:	dc46      	bgt.n	80095b4 <UART_SetConfig+0x644>
 8009526:	2b02      	cmp	r3, #2
 8009528:	f2c0 8081 	blt.w	800962e <UART_SetConfig+0x6be>
 800952c:	3b02      	subs	r3, #2
 800952e:	2b1e      	cmp	r3, #30
 8009530:	d87d      	bhi.n	800962e <UART_SetConfig+0x6be>
 8009532:	a201      	add	r2, pc, #4	; (adr r2, 8009538 <UART_SetConfig+0x5c8>)
 8009534:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8009538:	080095bb 	.word	0x080095bb
 800953c:	0800962f 	.word	0x0800962f
 8009540:	080095c3 	.word	0x080095c3
 8009544:	0800962f 	.word	0x0800962f
 8009548:	0800962f 	.word	0x0800962f
 800954c:	0800962f 	.word	0x0800962f
 8009550:	080095d3 	.word	0x080095d3
 8009554:	0800962f 	.word	0x0800962f
 8009558:	0800962f 	.word	0x0800962f
 800955c:	0800962f 	.word	0x0800962f
 8009560:	0800962f 	.word	0x0800962f
 8009564:	0800962f 	.word	0x0800962f
 8009568:	0800962f 	.word	0x0800962f
 800956c:	0800962f 	.word	0x0800962f
 8009570:	080095e3 	.word	0x080095e3
 8009574:	0800962f 	.word	0x0800962f
 8009578:	0800962f 	.word	0x0800962f
 800957c:	0800962f 	.word	0x0800962f
 8009580:	0800962f 	.word	0x0800962f
 8009584:	0800962f 	.word	0x0800962f
 8009588:	0800962f 	.word	0x0800962f
 800958c:	0800962f 	.word	0x0800962f
 8009590:	0800962f 	.word	0x0800962f
 8009594:	0800962f 	.word	0x0800962f
 8009598:	0800962f 	.word	0x0800962f
 800959c:	0800962f 	.word	0x0800962f
 80095a0:	0800962f 	.word	0x0800962f
 80095a4:	0800962f 	.word	0x0800962f
 80095a8:	0800962f 	.word	0x0800962f
 80095ac:	0800962f 	.word	0x0800962f
 80095b0:	08009621 	.word	0x08009621
 80095b4:	2b40      	cmp	r3, #64	; 0x40
 80095b6:	d036      	beq.n	8009626 <UART_SetConfig+0x6b6>
 80095b8:	e039      	b.n	800962e <UART_SetConfig+0x6be>
    {
      case UART_CLOCKSOURCE_D3PCLK1:
        pclk = HAL_RCCEx_GetD3PCLK1Freq();
 80095ba:	f7fc fbd9 	bl	8005d70 <HAL_RCCEx_GetD3PCLK1Freq>
 80095be:	62f8      	str	r0, [r7, #44]	; 0x2c
        break;
 80095c0:	e03b      	b.n	800963a <UART_SetConfig+0x6ca>
      case UART_CLOCKSOURCE_PLL2:
        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 80095c2:	f107 0314 	add.w	r3, r7, #20
 80095c6:	4618      	mov	r0, r3
 80095c8:	f7fc fbe8 	bl	8005d9c <HAL_RCCEx_GetPLL2ClockFreq>
        pclk = pll2_clocks.PLL2_Q_Frequency;
 80095cc:	69bb      	ldr	r3, [r7, #24]
 80095ce:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 80095d0:	e033      	b.n	800963a <UART_SetConfig+0x6ca>
      case UART_CLOCKSOURCE_PLL3:
        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 80095d2:	f107 0308 	add.w	r3, r7, #8
 80095d6:	4618      	mov	r0, r3
 80095d8:	f7fc fd34 	bl	8006044 <HAL_RCCEx_GetPLL3ClockFreq>
        pclk = pll3_clocks.PLL3_Q_Frequency;
 80095dc:	68fb      	ldr	r3, [r7, #12]
 80095de:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 80095e0:	e02b      	b.n	800963a <UART_SetConfig+0x6ca>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 80095e2:	4b0a      	ldr	r3, [pc, #40]	; (800960c <UART_SetConfig+0x69c>)
 80095e4:	681b      	ldr	r3, [r3, #0]
 80095e6:	f003 0320 	and.w	r3, r3, #32
 80095ea:	2b00      	cmp	r3, #0
 80095ec:	d009      	beq.n	8009602 <UART_SetConfig+0x692>
        {
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
 80095ee:	4b07      	ldr	r3, [pc, #28]	; (800960c <UART_SetConfig+0x69c>)
 80095f0:	681b      	ldr	r3, [r3, #0]
 80095f2:	08db      	lsrs	r3, r3, #3
 80095f4:	f003 0303 	and.w	r3, r3, #3
 80095f8:	4a08      	ldr	r2, [pc, #32]	; (800961c <UART_SetConfig+0x6ac>)
 80095fa:	fa22 f303 	lsr.w	r3, r2, r3
 80095fe:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
 8009600:	e01b      	b.n	800963a <UART_SetConfig+0x6ca>
          pclk = (uint32_t) HSI_VALUE;
 8009602:	4b06      	ldr	r3, [pc, #24]	; (800961c <UART_SetConfig+0x6ac>)
 8009604:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8009606:	e018      	b.n	800963a <UART_SetConfig+0x6ca>
 8009608:	40011400 	.word	0x40011400
 800960c:	58024400 	.word	0x58024400
 8009610:	40007800 	.word	0x40007800
 8009614:	40007c00 	.word	0x40007c00
 8009618:	58000c00 	.word	0x58000c00
 800961c:	03d09000 	.word	0x03d09000
      case UART_CLOCKSOURCE_CSI:
        pclk = (uint32_t) CSI_VALUE;
 8009620:	4bc4      	ldr	r3, [pc, #784]	; (8009934 <UART_SetConfig+0x9c4>)
 8009622:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8009624:	e009      	b.n	800963a <UART_SetConfig+0x6ca>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 8009626:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800962a:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800962c:	e005      	b.n	800963a <UART_SetConfig+0x6ca>
      default:
        pclk = 0U;
 800962e:	2300      	movs	r3, #0
 8009630:	62fb      	str	r3, [r7, #44]	; 0x2c
        ret = HAL_ERROR;
 8009632:	2301      	movs	r3, #1
 8009634:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
        break;
 8009638:	bf00      	nop
    }

    /* If proper clock source reported */
    if (pclk != 0U)
 800963a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800963c:	2b00      	cmp	r3, #0
 800963e:	f000 81da 	beq.w	80099f6 <UART_SetConfig+0xa86>
    {
      /* Compute clock after Prescaler */
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 8009642:	687b      	ldr	r3, [r7, #4]
 8009644:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009646:	4abc      	ldr	r2, [pc, #752]	; (8009938 <UART_SetConfig+0x9c8>)
 8009648:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 800964c:	461a      	mov	r2, r3
 800964e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009650:	fbb3 f3f2 	udiv	r3, r3, r2
 8009654:	623b      	str	r3, [r7, #32]

      /* Ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8009656:	687b      	ldr	r3, [r7, #4]
 8009658:	685a      	ldr	r2, [r3, #4]
 800965a:	4613      	mov	r3, r2
 800965c:	005b      	lsls	r3, r3, #1
 800965e:	4413      	add	r3, r2
 8009660:	6a3a      	ldr	r2, [r7, #32]
 8009662:	429a      	cmp	r2, r3
 8009664:	d305      	bcc.n	8009672 <UART_SetConfig+0x702>
          (lpuart_ker_ck_pres > (4096U * huart->Init.BaudRate)))
 8009666:	687b      	ldr	r3, [r7, #4]
 8009668:	685b      	ldr	r3, [r3, #4]
 800966a:	031b      	lsls	r3, r3, #12
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 800966c:	6a3a      	ldr	r2, [r7, #32]
 800966e:	429a      	cmp	r2, r3
 8009670:	d903      	bls.n	800967a <UART_SetConfig+0x70a>
      {
        ret = HAL_ERROR;
 8009672:	2301      	movs	r3, #1
 8009674:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
 8009678:	e1bd      	b.n	80099f6 <UART_SetConfig+0xa86>
      }
      else
      {
        /* Check computed UsartDiv value is in allocated range
           (it is forbidden to write values lower than 0x300 in the LPUART_BRR register) */
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800967a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800967c:	4618      	mov	r0, r3
 800967e:	f04f 0100 	mov.w	r1, #0
 8009682:	687b      	ldr	r3, [r7, #4]
 8009684:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009686:	4aac      	ldr	r2, [pc, #688]	; (8009938 <UART_SetConfig+0x9c8>)
 8009688:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 800968c:	b29a      	uxth	r2, r3
 800968e:	f04f 0300 	mov.w	r3, #0
 8009692:	f7f6 fe8d 	bl	80003b0 <__aeabi_uldivmod>
 8009696:	4602      	mov	r2, r0
 8009698:	460b      	mov	r3, r1
 800969a:	4610      	mov	r0, r2
 800969c:	4619      	mov	r1, r3
 800969e:	f04f 0200 	mov.w	r2, #0
 80096a2:	f04f 0300 	mov.w	r3, #0
 80096a6:	020b      	lsls	r3, r1, #8
 80096a8:	ea43 6310 	orr.w	r3, r3, r0, lsr #24
 80096ac:	0202      	lsls	r2, r0, #8
 80096ae:	6879      	ldr	r1, [r7, #4]
 80096b0:	6849      	ldr	r1, [r1, #4]
 80096b2:	0849      	lsrs	r1, r1, #1
 80096b4:	4608      	mov	r0, r1
 80096b6:	f04f 0100 	mov.w	r1, #0
 80096ba:	1814      	adds	r4, r2, r0
 80096bc:	eb43 0501 	adc.w	r5, r3, r1
 80096c0:	687b      	ldr	r3, [r7, #4]
 80096c2:	685b      	ldr	r3, [r3, #4]
 80096c4:	461a      	mov	r2, r3
 80096c6:	f04f 0300 	mov.w	r3, #0
 80096ca:	4620      	mov	r0, r4
 80096cc:	4629      	mov	r1, r5
 80096ce:	f7f6 fe6f 	bl	80003b0 <__aeabi_uldivmod>
 80096d2:	4602      	mov	r2, r0
 80096d4:	460b      	mov	r3, r1
 80096d6:	4613      	mov	r3, r2
 80096d8:	62bb      	str	r3, [r7, #40]	; 0x28
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 80096da:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80096dc:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 80096e0:	d308      	bcc.n	80096f4 <UART_SetConfig+0x784>
 80096e2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80096e4:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 80096e8:	d204      	bcs.n	80096f4 <UART_SetConfig+0x784>
        {
          huart->Instance->BRR = usartdiv;
 80096ea:	687b      	ldr	r3, [r7, #4]
 80096ec:	681b      	ldr	r3, [r3, #0]
 80096ee:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80096f0:	60da      	str	r2, [r3, #12]
 80096f2:	e180      	b.n	80099f6 <UART_SetConfig+0xa86>
        }
        else
        {
          ret = HAL_ERROR;
 80096f4:	2301      	movs	r3, #1
 80096f6:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
 80096fa:	e17c      	b.n	80099f6 <UART_SetConfig+0xa86>
      } /* if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) ||
                (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate) )) */
    } /* if (pclk != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80096fc:	687b      	ldr	r3, [r7, #4]
 80096fe:	69db      	ldr	r3, [r3, #28]
 8009700:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8009704:	f040 80be 	bne.w	8009884 <UART_SetConfig+0x914>
  {
    switch (clocksource)
 8009708:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800970c:	2b20      	cmp	r3, #32
 800970e:	dc49      	bgt.n	80097a4 <UART_SetConfig+0x834>
 8009710:	2b00      	cmp	r3, #0
 8009712:	db7c      	blt.n	800980e <UART_SetConfig+0x89e>
 8009714:	2b20      	cmp	r3, #32
 8009716:	d87a      	bhi.n	800980e <UART_SetConfig+0x89e>
 8009718:	a201      	add	r2, pc, #4	; (adr r2, 8009720 <UART_SetConfig+0x7b0>)
 800971a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800971e:	bf00      	nop
 8009720:	080097ab 	.word	0x080097ab
 8009724:	080097b3 	.word	0x080097b3
 8009728:	0800980f 	.word	0x0800980f
 800972c:	0800980f 	.word	0x0800980f
 8009730:	080097bb 	.word	0x080097bb
 8009734:	0800980f 	.word	0x0800980f
 8009738:	0800980f 	.word	0x0800980f
 800973c:	0800980f 	.word	0x0800980f
 8009740:	080097cb 	.word	0x080097cb
 8009744:	0800980f 	.word	0x0800980f
 8009748:	0800980f 	.word	0x0800980f
 800974c:	0800980f 	.word	0x0800980f
 8009750:	0800980f 	.word	0x0800980f
 8009754:	0800980f 	.word	0x0800980f
 8009758:	0800980f 	.word	0x0800980f
 800975c:	0800980f 	.word	0x0800980f
 8009760:	080097db 	.word	0x080097db
 8009764:	0800980f 	.word	0x0800980f
 8009768:	0800980f 	.word	0x0800980f
 800976c:	0800980f 	.word	0x0800980f
 8009770:	0800980f 	.word	0x0800980f
 8009774:	0800980f 	.word	0x0800980f
 8009778:	0800980f 	.word	0x0800980f
 800977c:	0800980f 	.word	0x0800980f
 8009780:	0800980f 	.word	0x0800980f
 8009784:	0800980f 	.word	0x0800980f
 8009788:	0800980f 	.word	0x0800980f
 800978c:	0800980f 	.word	0x0800980f
 8009790:	0800980f 	.word	0x0800980f
 8009794:	0800980f 	.word	0x0800980f
 8009798:	0800980f 	.word	0x0800980f
 800979c:	0800980f 	.word	0x0800980f
 80097a0:	08009801 	.word	0x08009801
 80097a4:	2b40      	cmp	r3, #64	; 0x40
 80097a6:	d02e      	beq.n	8009806 <UART_SetConfig+0x896>
 80097a8:	e031      	b.n	800980e <UART_SetConfig+0x89e>
    {
      case UART_CLOCKSOURCE_D2PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 80097aa:	f7fb fb33 	bl	8004e14 <HAL_RCC_GetPCLK1Freq>
 80097ae:	62f8      	str	r0, [r7, #44]	; 0x2c
        break;
 80097b0:	e033      	b.n	800981a <UART_SetConfig+0x8aa>
      case UART_CLOCKSOURCE_D2PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
 80097b2:	f7fb fb45 	bl	8004e40 <HAL_RCC_GetPCLK2Freq>
 80097b6:	62f8      	str	r0, [r7, #44]	; 0x2c
        break;
 80097b8:	e02f      	b.n	800981a <UART_SetConfig+0x8aa>
      case UART_CLOCKSOURCE_PLL2:
        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 80097ba:	f107 0314 	add.w	r3, r7, #20
 80097be:	4618      	mov	r0, r3
 80097c0:	f7fc faec 	bl	8005d9c <HAL_RCCEx_GetPLL2ClockFreq>
        pclk = pll2_clocks.PLL2_Q_Frequency;
 80097c4:	69bb      	ldr	r3, [r7, #24]
 80097c6:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 80097c8:	e027      	b.n	800981a <UART_SetConfig+0x8aa>
      case UART_CLOCKSOURCE_PLL3:
        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 80097ca:	f107 0308 	add.w	r3, r7, #8
 80097ce:	4618      	mov	r0, r3
 80097d0:	f7fc fc38 	bl	8006044 <HAL_RCCEx_GetPLL3ClockFreq>
        pclk = pll3_clocks.PLL3_Q_Frequency;
 80097d4:	68fb      	ldr	r3, [r7, #12]
 80097d6:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 80097d8:	e01f      	b.n	800981a <UART_SetConfig+0x8aa>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 80097da:	4b58      	ldr	r3, [pc, #352]	; (800993c <UART_SetConfig+0x9cc>)
 80097dc:	681b      	ldr	r3, [r3, #0]
 80097de:	f003 0320 	and.w	r3, r3, #32
 80097e2:	2b00      	cmp	r3, #0
 80097e4:	d009      	beq.n	80097fa <UART_SetConfig+0x88a>
        {
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
 80097e6:	4b55      	ldr	r3, [pc, #340]	; (800993c <UART_SetConfig+0x9cc>)
 80097e8:	681b      	ldr	r3, [r3, #0]
 80097ea:	08db      	lsrs	r3, r3, #3
 80097ec:	f003 0303 	and.w	r3, r3, #3
 80097f0:	4a53      	ldr	r2, [pc, #332]	; (8009940 <UART_SetConfig+0x9d0>)
 80097f2:	fa22 f303 	lsr.w	r3, r2, r3
 80097f6:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
 80097f8:	e00f      	b.n	800981a <UART_SetConfig+0x8aa>
          pclk = (uint32_t) HSI_VALUE;
 80097fa:	4b51      	ldr	r3, [pc, #324]	; (8009940 <UART_SetConfig+0x9d0>)
 80097fc:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 80097fe:	e00c      	b.n	800981a <UART_SetConfig+0x8aa>
      case UART_CLOCKSOURCE_CSI:
        pclk = (uint32_t) CSI_VALUE;
 8009800:	4b4c      	ldr	r3, [pc, #304]	; (8009934 <UART_SetConfig+0x9c4>)
 8009802:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8009804:	e009      	b.n	800981a <UART_SetConfig+0x8aa>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 8009806:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800980a:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800980c:	e005      	b.n	800981a <UART_SetConfig+0x8aa>
      default:
        pclk = 0U;
 800980e:	2300      	movs	r3, #0
 8009810:	62fb      	str	r3, [r7, #44]	; 0x2c
        ret = HAL_ERROR;
 8009812:	2301      	movs	r3, #1
 8009814:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
        break;
 8009818:	bf00      	nop
    }

    /* USARTDIV must be greater than or equal to 0d16 */
    if (pclk != 0U)
 800981a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800981c:	2b00      	cmp	r3, #0
 800981e:	f000 80ea 	beq.w	80099f6 <UART_SetConfig+0xa86>
    {
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8009822:	687b      	ldr	r3, [r7, #4]
 8009824:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009826:	4a44      	ldr	r2, [pc, #272]	; (8009938 <UART_SetConfig+0x9c8>)
 8009828:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 800982c:	461a      	mov	r2, r3
 800982e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009830:	fbb3 f3f2 	udiv	r3, r3, r2
 8009834:	005a      	lsls	r2, r3, #1
 8009836:	687b      	ldr	r3, [r7, #4]
 8009838:	685b      	ldr	r3, [r3, #4]
 800983a:	085b      	lsrs	r3, r3, #1
 800983c:	441a      	add	r2, r3
 800983e:	687b      	ldr	r3, [r7, #4]
 8009840:	685b      	ldr	r3, [r3, #4]
 8009842:	fbb2 f3f3 	udiv	r3, r2, r3
 8009846:	62bb      	str	r3, [r7, #40]	; 0x28
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8009848:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800984a:	2b0f      	cmp	r3, #15
 800984c:	d916      	bls.n	800987c <UART_SetConfig+0x90c>
 800984e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009850:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8009854:	d212      	bcs.n	800987c <UART_SetConfig+0x90c>
      {
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 8009856:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009858:	b29b      	uxth	r3, r3
 800985a:	f023 030f 	bic.w	r3, r3, #15
 800985e:	84fb      	strh	r3, [r7, #38]	; 0x26
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8009860:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009862:	085b      	lsrs	r3, r3, #1
 8009864:	b29b      	uxth	r3, r3
 8009866:	f003 0307 	and.w	r3, r3, #7
 800986a:	b29a      	uxth	r2, r3
 800986c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800986e:	4313      	orrs	r3, r2
 8009870:	84fb      	strh	r3, [r7, #38]	; 0x26
        huart->Instance->BRR = brrtemp;
 8009872:	687b      	ldr	r3, [r7, #4]
 8009874:	681b      	ldr	r3, [r3, #0]
 8009876:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8009878:	60da      	str	r2, [r3, #12]
 800987a:	e0bc      	b.n	80099f6 <UART_SetConfig+0xa86>
      }
      else
      {
        ret = HAL_ERROR;
 800987c:	2301      	movs	r3, #1
 800987e:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
 8009882:	e0b8      	b.n	80099f6 <UART_SetConfig+0xa86>
      }
    }
  }
  else
  {
    switch (clocksource)
 8009884:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8009888:	2b20      	cmp	r3, #32
 800988a:	dc4b      	bgt.n	8009924 <UART_SetConfig+0x9b4>
 800988c:	2b00      	cmp	r3, #0
 800988e:	f2c0 8087 	blt.w	80099a0 <UART_SetConfig+0xa30>
 8009892:	2b20      	cmp	r3, #32
 8009894:	f200 8084 	bhi.w	80099a0 <UART_SetConfig+0xa30>
 8009898:	a201      	add	r2, pc, #4	; (adr r2, 80098a0 <UART_SetConfig+0x930>)
 800989a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800989e:	bf00      	nop
 80098a0:	0800992b 	.word	0x0800992b
 80098a4:	08009945 	.word	0x08009945
 80098a8:	080099a1 	.word	0x080099a1
 80098ac:	080099a1 	.word	0x080099a1
 80098b0:	0800994d 	.word	0x0800994d
 80098b4:	080099a1 	.word	0x080099a1
 80098b8:	080099a1 	.word	0x080099a1
 80098bc:	080099a1 	.word	0x080099a1
 80098c0:	0800995d 	.word	0x0800995d
 80098c4:	080099a1 	.word	0x080099a1
 80098c8:	080099a1 	.word	0x080099a1
 80098cc:	080099a1 	.word	0x080099a1
 80098d0:	080099a1 	.word	0x080099a1
 80098d4:	080099a1 	.word	0x080099a1
 80098d8:	080099a1 	.word	0x080099a1
 80098dc:	080099a1 	.word	0x080099a1
 80098e0:	0800996d 	.word	0x0800996d
 80098e4:	080099a1 	.word	0x080099a1
 80098e8:	080099a1 	.word	0x080099a1
 80098ec:	080099a1 	.word	0x080099a1
 80098f0:	080099a1 	.word	0x080099a1
 80098f4:	080099a1 	.word	0x080099a1
 80098f8:	080099a1 	.word	0x080099a1
 80098fc:	080099a1 	.word	0x080099a1
 8009900:	080099a1 	.word	0x080099a1
 8009904:	080099a1 	.word	0x080099a1
 8009908:	080099a1 	.word	0x080099a1
 800990c:	080099a1 	.word	0x080099a1
 8009910:	080099a1 	.word	0x080099a1
 8009914:	080099a1 	.word	0x080099a1
 8009918:	080099a1 	.word	0x080099a1
 800991c:	080099a1 	.word	0x080099a1
 8009920:	08009993 	.word	0x08009993
 8009924:	2b40      	cmp	r3, #64	; 0x40
 8009926:	d037      	beq.n	8009998 <UART_SetConfig+0xa28>
 8009928:	e03a      	b.n	80099a0 <UART_SetConfig+0xa30>
    {
      case UART_CLOCKSOURCE_D2PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 800992a:	f7fb fa73 	bl	8004e14 <HAL_RCC_GetPCLK1Freq>
 800992e:	62f8      	str	r0, [r7, #44]	; 0x2c
        break;
 8009930:	e03c      	b.n	80099ac <UART_SetConfig+0xa3c>
 8009932:	bf00      	nop
 8009934:	003d0900 	.word	0x003d0900
 8009938:	0802294c 	.word	0x0802294c
 800993c:	58024400 	.word	0x58024400
 8009940:	03d09000 	.word	0x03d09000
      case UART_CLOCKSOURCE_D2PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
 8009944:	f7fb fa7c 	bl	8004e40 <HAL_RCC_GetPCLK2Freq>
 8009948:	62f8      	str	r0, [r7, #44]	; 0x2c
        break;
 800994a:	e02f      	b.n	80099ac <UART_SetConfig+0xa3c>
      case UART_CLOCKSOURCE_PLL2:
        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 800994c:	f107 0314 	add.w	r3, r7, #20
 8009950:	4618      	mov	r0, r3
 8009952:	f7fc fa23 	bl	8005d9c <HAL_RCCEx_GetPLL2ClockFreq>
        pclk = pll2_clocks.PLL2_Q_Frequency;
 8009956:	69bb      	ldr	r3, [r7, #24]
 8009958:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800995a:	e027      	b.n	80099ac <UART_SetConfig+0xa3c>
      case UART_CLOCKSOURCE_PLL3:
        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 800995c:	f107 0308 	add.w	r3, r7, #8
 8009960:	4618      	mov	r0, r3
 8009962:	f7fc fb6f 	bl	8006044 <HAL_RCCEx_GetPLL3ClockFreq>
        pclk = pll3_clocks.PLL3_Q_Frequency;
 8009966:	68fb      	ldr	r3, [r7, #12]
 8009968:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800996a:	e01f      	b.n	80099ac <UART_SetConfig+0xa3c>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800996c:	4b2c      	ldr	r3, [pc, #176]	; (8009a20 <UART_SetConfig+0xab0>)
 800996e:	681b      	ldr	r3, [r3, #0]
 8009970:	f003 0320 	and.w	r3, r3, #32
 8009974:	2b00      	cmp	r3, #0
 8009976:	d009      	beq.n	800998c <UART_SetConfig+0xa1c>
        {
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
 8009978:	4b29      	ldr	r3, [pc, #164]	; (8009a20 <UART_SetConfig+0xab0>)
 800997a:	681b      	ldr	r3, [r3, #0]
 800997c:	08db      	lsrs	r3, r3, #3
 800997e:	f003 0303 	and.w	r3, r3, #3
 8009982:	4a28      	ldr	r2, [pc, #160]	; (8009a24 <UART_SetConfig+0xab4>)
 8009984:	fa22 f303 	lsr.w	r3, r2, r3
 8009988:	62fb      	str	r3, [r7, #44]	; 0x2c
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
 800998a:	e00f      	b.n	80099ac <UART_SetConfig+0xa3c>
          pclk = (uint32_t) HSI_VALUE;
 800998c:	4b25      	ldr	r3, [pc, #148]	; (8009a24 <UART_SetConfig+0xab4>)
 800998e:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8009990:	e00c      	b.n	80099ac <UART_SetConfig+0xa3c>
      case UART_CLOCKSOURCE_CSI:
        pclk = (uint32_t) CSI_VALUE;
 8009992:	4b25      	ldr	r3, [pc, #148]	; (8009a28 <UART_SetConfig+0xab8>)
 8009994:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 8009996:	e009      	b.n	80099ac <UART_SetConfig+0xa3c>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 8009998:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800999c:	62fb      	str	r3, [r7, #44]	; 0x2c
        break;
 800999e:	e005      	b.n	80099ac <UART_SetConfig+0xa3c>
      default:
        pclk = 0U;
 80099a0:	2300      	movs	r3, #0
 80099a2:	62fb      	str	r3, [r7, #44]	; 0x2c
        ret = HAL_ERROR;
 80099a4:	2301      	movs	r3, #1
 80099a6:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
        break;
 80099aa:	bf00      	nop
    }

    if (pclk != 0U)
 80099ac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80099ae:	2b00      	cmp	r3, #0
 80099b0:	d021      	beq.n	80099f6 <UART_SetConfig+0xa86>
    {
      /* USARTDIV must be greater than or equal to 0d16 */
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 80099b2:	687b      	ldr	r3, [r7, #4]
 80099b4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80099b6:	4a1d      	ldr	r2, [pc, #116]	; (8009a2c <UART_SetConfig+0xabc>)
 80099b8:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 80099bc:	461a      	mov	r2, r3
 80099be:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80099c0:	fbb3 f2f2 	udiv	r2, r3, r2
 80099c4:	687b      	ldr	r3, [r7, #4]
 80099c6:	685b      	ldr	r3, [r3, #4]
 80099c8:	085b      	lsrs	r3, r3, #1
 80099ca:	441a      	add	r2, r3
 80099cc:	687b      	ldr	r3, [r7, #4]
 80099ce:	685b      	ldr	r3, [r3, #4]
 80099d0:	fbb2 f3f3 	udiv	r3, r2, r3
 80099d4:	62bb      	str	r3, [r7, #40]	; 0x28
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 80099d6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80099d8:	2b0f      	cmp	r3, #15
 80099da:	d909      	bls.n	80099f0 <UART_SetConfig+0xa80>
 80099dc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80099de:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80099e2:	d205      	bcs.n	80099f0 <UART_SetConfig+0xa80>
      {
        huart->Instance->BRR = (uint16_t)usartdiv;
 80099e4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80099e6:	b29a      	uxth	r2, r3
 80099e8:	687b      	ldr	r3, [r7, #4]
 80099ea:	681b      	ldr	r3, [r3, #0]
 80099ec:	60da      	str	r2, [r3, #12]
 80099ee:	e002      	b.n	80099f6 <UART_SetConfig+0xa86>
      }
      else
      {
        ret = HAL_ERROR;
 80099f0:	2301      	movs	r3, #1
 80099f2:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
      }
    }
  }

  /* Initialize the number of data to process during RX/TX ISR execution */
  huart->NbTxDataToProcess = 1;
 80099f6:	687b      	ldr	r3, [r7, #4]
 80099f8:	2201      	movs	r2, #1
 80099fa:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
  huart->NbRxDataToProcess = 1;
 80099fe:	687b      	ldr	r3, [r7, #4]
 8009a00:	2201      	movs	r2, #1
 8009a02:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 8009a06:	687b      	ldr	r3, [r7, #4]
 8009a08:	2200      	movs	r2, #0
 8009a0a:	671a      	str	r2, [r3, #112]	; 0x70
  huart->TxISR = NULL;
 8009a0c:	687b      	ldr	r3, [r7, #4]
 8009a0e:	2200      	movs	r2, #0
 8009a10:	675a      	str	r2, [r3, #116]	; 0x74

  return ret;
 8009a12:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
}
 8009a16:	4618      	mov	r0, r3
 8009a18:	3738      	adds	r7, #56	; 0x38
 8009a1a:	46bd      	mov	sp, r7
 8009a1c:	bdb0      	pop	{r4, r5, r7, pc}
 8009a1e:	bf00      	nop
 8009a20:	58024400 	.word	0x58024400
 8009a24:	03d09000 	.word	0x03d09000
 8009a28:	003d0900 	.word	0x003d0900
 8009a2c:	0802294c 	.word	0x0802294c

08009a30 <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
 8009a30:	b480      	push	{r7}
 8009a32:	b083      	sub	sp, #12
 8009a34:	af00      	add	r7, sp, #0
 8009a36:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8009a38:	687b      	ldr	r3, [r7, #4]
 8009a3a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009a3c:	f003 0301 	and.w	r3, r3, #1
 8009a40:	2b00      	cmp	r3, #0
 8009a42:	d00a      	beq.n	8009a5a <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 8009a44:	687b      	ldr	r3, [r7, #4]
 8009a46:	681b      	ldr	r3, [r3, #0]
 8009a48:	685b      	ldr	r3, [r3, #4]
 8009a4a:	f423 3100 	bic.w	r1, r3, #131072	; 0x20000
 8009a4e:	687b      	ldr	r3, [r7, #4]
 8009a50:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8009a52:	687b      	ldr	r3, [r7, #4]
 8009a54:	681b      	ldr	r3, [r3, #0]
 8009a56:	430a      	orrs	r2, r1
 8009a58:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 8009a5a:	687b      	ldr	r3, [r7, #4]
 8009a5c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009a5e:	f003 0302 	and.w	r3, r3, #2
 8009a62:	2b00      	cmp	r3, #0
 8009a64:	d00a      	beq.n	8009a7c <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 8009a66:	687b      	ldr	r3, [r7, #4]
 8009a68:	681b      	ldr	r3, [r3, #0]
 8009a6a:	685b      	ldr	r3, [r3, #4]
 8009a6c:	f423 3180 	bic.w	r1, r3, #65536	; 0x10000
 8009a70:	687b      	ldr	r3, [r7, #4]
 8009a72:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8009a74:	687b      	ldr	r3, [r7, #4]
 8009a76:	681b      	ldr	r3, [r3, #0]
 8009a78:	430a      	orrs	r2, r1
 8009a7a:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 8009a7c:	687b      	ldr	r3, [r7, #4]
 8009a7e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009a80:	f003 0304 	and.w	r3, r3, #4
 8009a84:	2b00      	cmp	r3, #0
 8009a86:	d00a      	beq.n	8009a9e <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 8009a88:	687b      	ldr	r3, [r7, #4]
 8009a8a:	681b      	ldr	r3, [r3, #0]
 8009a8c:	685b      	ldr	r3, [r3, #4]
 8009a8e:	f423 2180 	bic.w	r1, r3, #262144	; 0x40000
 8009a92:	687b      	ldr	r3, [r7, #4]
 8009a94:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8009a96:	687b      	ldr	r3, [r7, #4]
 8009a98:	681b      	ldr	r3, [r3, #0]
 8009a9a:	430a      	orrs	r2, r1
 8009a9c:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 8009a9e:	687b      	ldr	r3, [r7, #4]
 8009aa0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009aa2:	f003 0308 	and.w	r3, r3, #8
 8009aa6:	2b00      	cmp	r3, #0
 8009aa8:	d00a      	beq.n	8009ac0 <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 8009aaa:	687b      	ldr	r3, [r7, #4]
 8009aac:	681b      	ldr	r3, [r3, #0]
 8009aae:	685b      	ldr	r3, [r3, #4]
 8009ab0:	f423 4100 	bic.w	r1, r3, #32768	; 0x8000
 8009ab4:	687b      	ldr	r3, [r7, #4]
 8009ab6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8009ab8:	687b      	ldr	r3, [r7, #4]
 8009aba:	681b      	ldr	r3, [r3, #0]
 8009abc:	430a      	orrs	r2, r1
 8009abe:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 8009ac0:	687b      	ldr	r3, [r7, #4]
 8009ac2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009ac4:	f003 0310 	and.w	r3, r3, #16
 8009ac8:	2b00      	cmp	r3, #0
 8009aca:	d00a      	beq.n	8009ae2 <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 8009acc:	687b      	ldr	r3, [r7, #4]
 8009ace:	681b      	ldr	r3, [r3, #0]
 8009ad0:	689b      	ldr	r3, [r3, #8]
 8009ad2:	f423 5180 	bic.w	r1, r3, #4096	; 0x1000
 8009ad6:	687b      	ldr	r3, [r7, #4]
 8009ad8:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8009ada:	687b      	ldr	r3, [r7, #4]
 8009adc:	681b      	ldr	r3, [r3, #0]
 8009ade:	430a      	orrs	r2, r1
 8009ae0:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 8009ae2:	687b      	ldr	r3, [r7, #4]
 8009ae4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009ae6:	f003 0320 	and.w	r3, r3, #32
 8009aea:	2b00      	cmp	r3, #0
 8009aec:	d00a      	beq.n	8009b04 <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 8009aee:	687b      	ldr	r3, [r7, #4]
 8009af0:	681b      	ldr	r3, [r3, #0]
 8009af2:	689b      	ldr	r3, [r3, #8]
 8009af4:	f423 5100 	bic.w	r1, r3, #8192	; 0x2000
 8009af8:	687b      	ldr	r3, [r7, #4]
 8009afa:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8009afc:	687b      	ldr	r3, [r7, #4]
 8009afe:	681b      	ldr	r3, [r3, #0]
 8009b00:	430a      	orrs	r2, r1
 8009b02:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 8009b04:	687b      	ldr	r3, [r7, #4]
 8009b06:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009b08:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8009b0c:	2b00      	cmp	r3, #0
 8009b0e:	d01a      	beq.n	8009b46 <UART_AdvFeatureConfig+0x116>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8009b10:	687b      	ldr	r3, [r7, #4]
 8009b12:	681b      	ldr	r3, [r3, #0]
 8009b14:	685b      	ldr	r3, [r3, #4]
 8009b16:	f423 1180 	bic.w	r1, r3, #1048576	; 0x100000
 8009b1a:	687b      	ldr	r3, [r7, #4]
 8009b1c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8009b1e:	687b      	ldr	r3, [r7, #4]
 8009b20:	681b      	ldr	r3, [r3, #0]
 8009b22:	430a      	orrs	r2, r1
 8009b24:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8009b26:	687b      	ldr	r3, [r7, #4]
 8009b28:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009b2a:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8009b2e:	d10a      	bne.n	8009b46 <UART_AdvFeatureConfig+0x116>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 8009b30:	687b      	ldr	r3, [r7, #4]
 8009b32:	681b      	ldr	r3, [r3, #0]
 8009b34:	685b      	ldr	r3, [r3, #4]
 8009b36:	f423 01c0 	bic.w	r1, r3, #6291456	; 0x600000
 8009b3a:	687b      	ldr	r3, [r7, #4]
 8009b3c:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8009b3e:	687b      	ldr	r3, [r7, #4]
 8009b40:	681b      	ldr	r3, [r3, #0]
 8009b42:	430a      	orrs	r2, r1
 8009b44:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 8009b46:	687b      	ldr	r3, [r7, #4]
 8009b48:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009b4a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8009b4e:	2b00      	cmp	r3, #0
 8009b50:	d00a      	beq.n	8009b68 <UART_AdvFeatureConfig+0x138>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 8009b52:	687b      	ldr	r3, [r7, #4]
 8009b54:	681b      	ldr	r3, [r3, #0]
 8009b56:	685b      	ldr	r3, [r3, #4]
 8009b58:	f423 2100 	bic.w	r1, r3, #524288	; 0x80000
 8009b5c:	687b      	ldr	r3, [r7, #4]
 8009b5e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8009b60:	687b      	ldr	r3, [r7, #4]
 8009b62:	681b      	ldr	r3, [r3, #0]
 8009b64:	430a      	orrs	r2, r1
 8009b66:	605a      	str	r2, [r3, #4]
  }
}
 8009b68:	bf00      	nop
 8009b6a:	370c      	adds	r7, #12
 8009b6c:	46bd      	mov	sp, r7
 8009b6e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009b72:	4770      	bx	lr

08009b74 <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 8009b74:	b580      	push	{r7, lr}
 8009b76:	b086      	sub	sp, #24
 8009b78:	af02      	add	r7, sp, #8
 8009b7a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8009b7c:	687b      	ldr	r3, [r7, #4]
 8009b7e:	2200      	movs	r2, #0
 8009b80:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
 8009b84:	f7f6 fde0 	bl	8000748 <HAL_GetTick>
 8009b88:	60f8      	str	r0, [r7, #12]

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8009b8a:	687b      	ldr	r3, [r7, #4]
 8009b8c:	681b      	ldr	r3, [r3, #0]
 8009b8e:	681b      	ldr	r3, [r3, #0]
 8009b90:	f003 0308 	and.w	r3, r3, #8
 8009b94:	2b08      	cmp	r3, #8
 8009b96:	d10e      	bne.n	8009bb6 <UART_CheckIdleState+0x42>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8009b98:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 8009b9c:	9300      	str	r3, [sp, #0]
 8009b9e:	68fb      	ldr	r3, [r7, #12]
 8009ba0:	2200      	movs	r2, #0
 8009ba2:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 8009ba6:	6878      	ldr	r0, [r7, #4]
 8009ba8:	f000 f82f 	bl	8009c0a <UART_WaitOnFlagUntilTimeout>
 8009bac:	4603      	mov	r3, r0
 8009bae:	2b00      	cmp	r3, #0
 8009bb0:	d001      	beq.n	8009bb6 <UART_CheckIdleState+0x42>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 8009bb2:	2303      	movs	r3, #3
 8009bb4:	e025      	b.n	8009c02 <UART_CheckIdleState+0x8e>
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 8009bb6:	687b      	ldr	r3, [r7, #4]
 8009bb8:	681b      	ldr	r3, [r3, #0]
 8009bba:	681b      	ldr	r3, [r3, #0]
 8009bbc:	f003 0304 	and.w	r3, r3, #4
 8009bc0:	2b04      	cmp	r3, #4
 8009bc2:	d10e      	bne.n	8009be2 <UART_CheckIdleState+0x6e>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8009bc4:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 8009bc8:	9300      	str	r3, [sp, #0]
 8009bca:	68fb      	ldr	r3, [r7, #12]
 8009bcc:	2200      	movs	r2, #0
 8009bce:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 8009bd2:	6878      	ldr	r0, [r7, #4]
 8009bd4:	f000 f819 	bl	8009c0a <UART_WaitOnFlagUntilTimeout>
 8009bd8:	4603      	mov	r3, r0
 8009bda:	2b00      	cmp	r3, #0
 8009bdc:	d001      	beq.n	8009be2 <UART_CheckIdleState+0x6e>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 8009bde:	2303      	movs	r3, #3
 8009be0:	e00f      	b.n	8009c02 <UART_CheckIdleState+0x8e>
    }
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
 8009be2:	687b      	ldr	r3, [r7, #4]
 8009be4:	2220      	movs	r2, #32
 8009be6:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  huart->RxState = HAL_UART_STATE_READY;
 8009bea:	687b      	ldr	r3, [r7, #4]
 8009bec:	2220      	movs	r2, #32
 8009bee:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 8009bf2:	687b      	ldr	r3, [r7, #4]
 8009bf4:	2200      	movs	r2, #0
 8009bf6:	66da      	str	r2, [r3, #108]	; 0x6c

  __HAL_UNLOCK(huart);
 8009bf8:	687b      	ldr	r3, [r7, #4]
 8009bfa:	2200      	movs	r2, #0
 8009bfc:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

  return HAL_OK;
 8009c00:	2300      	movs	r3, #0
}
 8009c02:	4618      	mov	r0, r3
 8009c04:	3710      	adds	r7, #16
 8009c06:	46bd      	mov	sp, r7
 8009c08:	bd80      	pop	{r7, pc}

08009c0a <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
 8009c0a:	b580      	push	{r7, lr}
 8009c0c:	b09c      	sub	sp, #112	; 0x70
 8009c0e:	af00      	add	r7, sp, #0
 8009c10:	60f8      	str	r0, [r7, #12]
 8009c12:	60b9      	str	r1, [r7, #8]
 8009c14:	603b      	str	r3, [r7, #0]
 8009c16:	4613      	mov	r3, r2
 8009c18:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8009c1a:	e0a9      	b.n	8009d70 <UART_WaitOnFlagUntilTimeout+0x166>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 8009c1c:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8009c1e:	f1b3 3fff 	cmp.w	r3, #4294967295
 8009c22:	f000 80a5 	beq.w	8009d70 <UART_WaitOnFlagUntilTimeout+0x166>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8009c26:	f7f6 fd8f 	bl	8000748 <HAL_GetTick>
 8009c2a:	4602      	mov	r2, r0
 8009c2c:	683b      	ldr	r3, [r7, #0]
 8009c2e:	1ad3      	subs	r3, r2, r3
 8009c30:	6fba      	ldr	r2, [r7, #120]	; 0x78
 8009c32:	429a      	cmp	r2, r3
 8009c34:	d302      	bcc.n	8009c3c <UART_WaitOnFlagUntilTimeout+0x32>
 8009c36:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 8009c38:	2b00      	cmp	r3, #0
 8009c3a:	d140      	bne.n	8009cbe <UART_WaitOnFlagUntilTimeout+0xb4>
      {
        /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error)
           interrupts for the interrupt process */
        ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
 8009c3c:	68fb      	ldr	r3, [r7, #12]
 8009c3e:	681b      	ldr	r3, [r3, #0]
 8009c40:	653b      	str	r3, [r7, #80]	; 0x50
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8009c42:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 8009c44:	e853 3f00 	ldrex	r3, [r3]
 8009c48:	64fb      	str	r3, [r7, #76]	; 0x4c
   return(result);
 8009c4a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8009c4c:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 8009c50:	667b      	str	r3, [r7, #100]	; 0x64
 8009c52:	68fb      	ldr	r3, [r7, #12]
 8009c54:	681b      	ldr	r3, [r3, #0]
 8009c56:	461a      	mov	r2, r3
 8009c58:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8009c5a:	65fb      	str	r3, [r7, #92]	; 0x5c
 8009c5c:	65ba      	str	r2, [r7, #88]	; 0x58
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8009c5e:	6db9      	ldr	r1, [r7, #88]	; 0x58
 8009c60:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8009c62:	e841 2300 	strex	r3, r2, [r1]
 8009c66:	657b      	str	r3, [r7, #84]	; 0x54
   return(result);
 8009c68:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8009c6a:	2b00      	cmp	r3, #0
 8009c6c:	d1e6      	bne.n	8009c3c <UART_WaitOnFlagUntilTimeout+0x32>
                                                USART_CR1_TXEIE_TXFNFIE));
        ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8009c6e:	68fb      	ldr	r3, [r7, #12]
 8009c70:	681b      	ldr	r3, [r3, #0]
 8009c72:	3308      	adds	r3, #8
 8009c74:	63fb      	str	r3, [r7, #60]	; 0x3c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8009c76:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8009c78:	e853 3f00 	ldrex	r3, [r3]
 8009c7c:	63bb      	str	r3, [r7, #56]	; 0x38
   return(result);
 8009c7e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8009c80:	f023 0301 	bic.w	r3, r3, #1
 8009c84:	663b      	str	r3, [r7, #96]	; 0x60
 8009c86:	68fb      	ldr	r3, [r7, #12]
 8009c88:	681b      	ldr	r3, [r3, #0]
 8009c8a:	3308      	adds	r3, #8
 8009c8c:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8009c8e:	64ba      	str	r2, [r7, #72]	; 0x48
 8009c90:	647b      	str	r3, [r7, #68]	; 0x44
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8009c92:	6c79      	ldr	r1, [r7, #68]	; 0x44
 8009c94:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8009c96:	e841 2300 	strex	r3, r2, [r1]
 8009c9a:	643b      	str	r3, [r7, #64]	; 0x40
   return(result);
 8009c9c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009c9e:	2b00      	cmp	r3, #0
 8009ca0:	d1e5      	bne.n	8009c6e <UART_WaitOnFlagUntilTimeout+0x64>

        huart->gState = HAL_UART_STATE_READY;
 8009ca2:	68fb      	ldr	r3, [r7, #12]
 8009ca4:	2220      	movs	r2, #32
 8009ca6:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
        huart->RxState = HAL_UART_STATE_READY;
 8009caa:	68fb      	ldr	r3, [r7, #12]
 8009cac:	2220      	movs	r2, #32
 8009cae:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

        __HAL_UNLOCK(huart);
 8009cb2:	68fb      	ldr	r3, [r7, #12]
 8009cb4:	2200      	movs	r2, #0
 8009cb6:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

        return HAL_TIMEOUT;
 8009cba:	2303      	movs	r3, #3
 8009cbc:	e069      	b.n	8009d92 <UART_WaitOnFlagUntilTimeout+0x188>
      }

      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 8009cbe:	68fb      	ldr	r3, [r7, #12]
 8009cc0:	681b      	ldr	r3, [r3, #0]
 8009cc2:	681b      	ldr	r3, [r3, #0]
 8009cc4:	f003 0304 	and.w	r3, r3, #4
 8009cc8:	2b00      	cmp	r3, #0
 8009cca:	d051      	beq.n	8009d70 <UART_WaitOnFlagUntilTimeout+0x166>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 8009ccc:	68fb      	ldr	r3, [r7, #12]
 8009cce:	681b      	ldr	r3, [r3, #0]
 8009cd0:	69db      	ldr	r3, [r3, #28]
 8009cd2:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8009cd6:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8009cda:	d149      	bne.n	8009d70 <UART_WaitOnFlagUntilTimeout+0x166>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 8009cdc:	68fb      	ldr	r3, [r7, #12]
 8009cde:	681b      	ldr	r3, [r3, #0]
 8009ce0:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8009ce4:	621a      	str	r2, [r3, #32]

          /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error)
             interrupts for the interrupt process */
          ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE |
 8009ce6:	68fb      	ldr	r3, [r7, #12]
 8009ce8:	681b      	ldr	r3, [r3, #0]
 8009cea:	62bb      	str	r3, [r7, #40]	; 0x28
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8009cec:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009cee:	e853 3f00 	ldrex	r3, [r3]
 8009cf2:	627b      	str	r3, [r7, #36]	; 0x24
   return(result);
 8009cf4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009cf6:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 8009cfa:	66fb      	str	r3, [r7, #108]	; 0x6c
 8009cfc:	68fb      	ldr	r3, [r7, #12]
 8009cfe:	681b      	ldr	r3, [r3, #0]
 8009d00:	461a      	mov	r2, r3
 8009d02:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8009d04:	637b      	str	r3, [r7, #52]	; 0x34
 8009d06:	633a      	str	r2, [r7, #48]	; 0x30
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8009d08:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8009d0a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8009d0c:	e841 2300 	strex	r3, r2, [r1]
 8009d10:	62fb      	str	r3, [r7, #44]	; 0x2c
   return(result);
 8009d12:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009d14:	2b00      	cmp	r3, #0
 8009d16:	d1e6      	bne.n	8009ce6 <UART_WaitOnFlagUntilTimeout+0xdc>
                                                  USART_CR1_TXEIE_TXFNFIE));
          ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8009d18:	68fb      	ldr	r3, [r7, #12]
 8009d1a:	681b      	ldr	r3, [r3, #0]
 8009d1c:	3308      	adds	r3, #8
 8009d1e:	617b      	str	r3, [r7, #20]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8009d20:	697b      	ldr	r3, [r7, #20]
 8009d22:	e853 3f00 	ldrex	r3, [r3]
 8009d26:	613b      	str	r3, [r7, #16]
   return(result);
 8009d28:	693b      	ldr	r3, [r7, #16]
 8009d2a:	f023 0301 	bic.w	r3, r3, #1
 8009d2e:	66bb      	str	r3, [r7, #104]	; 0x68
 8009d30:	68fb      	ldr	r3, [r7, #12]
 8009d32:	681b      	ldr	r3, [r3, #0]
 8009d34:	3308      	adds	r3, #8
 8009d36:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8009d38:	623a      	str	r2, [r7, #32]
 8009d3a:	61fb      	str	r3, [r7, #28]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8009d3c:	69f9      	ldr	r1, [r7, #28]
 8009d3e:	6a3a      	ldr	r2, [r7, #32]
 8009d40:	e841 2300 	strex	r3, r2, [r1]
 8009d44:	61bb      	str	r3, [r7, #24]
   return(result);
 8009d46:	69bb      	ldr	r3, [r7, #24]
 8009d48:	2b00      	cmp	r3, #0
 8009d4a:	d1e5      	bne.n	8009d18 <UART_WaitOnFlagUntilTimeout+0x10e>

          huart->gState = HAL_UART_STATE_READY;
 8009d4c:	68fb      	ldr	r3, [r7, #12]
 8009d4e:	2220      	movs	r2, #32
 8009d50:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
          huart->RxState = HAL_UART_STATE_READY;
 8009d54:	68fb      	ldr	r3, [r7, #12]
 8009d56:	2220      	movs	r2, #32
 8009d58:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 8009d5c:	68fb      	ldr	r3, [r7, #12]
 8009d5e:	2220      	movs	r2, #32
 8009d60:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 8009d64:	68fb      	ldr	r3, [r7, #12]
 8009d66:	2200      	movs	r2, #0
 8009d68:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

          return HAL_TIMEOUT;
 8009d6c:	2303      	movs	r3, #3
 8009d6e:	e010      	b.n	8009d92 <UART_WaitOnFlagUntilTimeout+0x188>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8009d70:	68fb      	ldr	r3, [r7, #12]
 8009d72:	681b      	ldr	r3, [r3, #0]
 8009d74:	69da      	ldr	r2, [r3, #28]
 8009d76:	68bb      	ldr	r3, [r7, #8]
 8009d78:	4013      	ands	r3, r2
 8009d7a:	68ba      	ldr	r2, [r7, #8]
 8009d7c:	429a      	cmp	r2, r3
 8009d7e:	bf0c      	ite	eq
 8009d80:	2301      	moveq	r3, #1
 8009d82:	2300      	movne	r3, #0
 8009d84:	b2db      	uxtb	r3, r3
 8009d86:	461a      	mov	r2, r3
 8009d88:	79fb      	ldrb	r3, [r7, #7]
 8009d8a:	429a      	cmp	r2, r3
 8009d8c:	f43f af46 	beq.w	8009c1c <UART_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
 8009d90:	2300      	movs	r3, #0
}
 8009d92:	4618      	mov	r0, r3
 8009d94:	3770      	adds	r7, #112	; 0x70
 8009d96:	46bd      	mov	sp, r7
 8009d98:	bd80      	pop	{r7, pc}
	...

08009d9c <UART_Start_Receive_DMA>:
  * @param  pData Pointer to data buffer (u8 or u16 data elements).
  * @param  Size  Amount of data elements (u8 or u16) to be received.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_Start_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
 8009d9c:	b580      	push	{r7, lr}
 8009d9e:	b096      	sub	sp, #88	; 0x58
 8009da0:	af00      	add	r7, sp, #0
 8009da2:	60f8      	str	r0, [r7, #12]
 8009da4:	60b9      	str	r1, [r7, #8]
 8009da6:	4613      	mov	r3, r2
 8009da8:	80fb      	strh	r3, [r7, #6]
  huart->pRxBuffPtr = pData;
 8009daa:	68fb      	ldr	r3, [r7, #12]
 8009dac:	68ba      	ldr	r2, [r7, #8]
 8009dae:	659a      	str	r2, [r3, #88]	; 0x58
  huart->RxXferSize = Size;
 8009db0:	68fb      	ldr	r3, [r7, #12]
 8009db2:	88fa      	ldrh	r2, [r7, #6]
 8009db4:	f8a3 205c 	strh.w	r2, [r3, #92]	; 0x5c

  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8009db8:	68fb      	ldr	r3, [r7, #12]
 8009dba:	2200      	movs	r2, #0
 8009dbc:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 8009dc0:	68fb      	ldr	r3, [r7, #12]
 8009dc2:	2222      	movs	r2, #34	; 0x22
 8009dc4:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  if (huart->hdmarx != NULL)
 8009dc8:	68fb      	ldr	r3, [r7, #12]
 8009dca:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8009dcc:	2b00      	cmp	r3, #0
 8009dce:	d02c      	beq.n	8009e2a <UART_Start_Receive_DMA+0x8e>
  {
    /* Set the UART DMA transfer complete callback */
    huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
 8009dd0:	68fb      	ldr	r3, [r7, #12]
 8009dd2:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8009dd4:	4a42      	ldr	r2, [pc, #264]	; (8009ee0 <UART_Start_Receive_DMA+0x144>)
 8009dd6:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Set the UART DMA Half transfer complete callback */
    huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
 8009dd8:	68fb      	ldr	r3, [r7, #12]
 8009dda:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8009ddc:	4a41      	ldr	r2, [pc, #260]	; (8009ee4 <UART_Start_Receive_DMA+0x148>)
 8009dde:	641a      	str	r2, [r3, #64]	; 0x40

    /* Set the DMA error callback */
    huart->hdmarx->XferErrorCallback = UART_DMAError;
 8009de0:	68fb      	ldr	r3, [r7, #12]
 8009de2:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8009de4:	4a40      	ldr	r2, [pc, #256]	; (8009ee8 <UART_Start_Receive_DMA+0x14c>)
 8009de6:	64da      	str	r2, [r3, #76]	; 0x4c

    /* Set the DMA abort callback */
    huart->hdmarx->XferAbortCallback = NULL;
 8009de8:	68fb      	ldr	r3, [r7, #12]
 8009dea:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8009dec:	2200      	movs	r2, #0
 8009dee:	651a      	str	r2, [r3, #80]	; 0x50

    /* Enable the DMA channel */
    if (HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->RDR, (uint32_t)huart->pRxBuffPtr, Size) != HAL_OK)
 8009df0:	68fb      	ldr	r3, [r7, #12]
 8009df2:	6fd8      	ldr	r0, [r3, #124]	; 0x7c
 8009df4:	68fb      	ldr	r3, [r7, #12]
 8009df6:	681b      	ldr	r3, [r3, #0]
 8009df8:	3324      	adds	r3, #36	; 0x24
 8009dfa:	4619      	mov	r1, r3
 8009dfc:	68fb      	ldr	r3, [r7, #12]
 8009dfe:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8009e00:	461a      	mov	r2, r3
 8009e02:	88fb      	ldrh	r3, [r7, #6]
 8009e04:	f7f7 faf2 	bl	80013ec <HAL_DMA_Start_IT>
 8009e08:	4603      	mov	r3, r0
 8009e0a:	2b00      	cmp	r3, #0
 8009e0c:	d00d      	beq.n	8009e2a <UART_Start_Receive_DMA+0x8e>
    {
      /* Set error code to DMA */
      huart->ErrorCode = HAL_UART_ERROR_DMA;
 8009e0e:	68fb      	ldr	r3, [r7, #12]
 8009e10:	2210      	movs	r2, #16
 8009e12:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

      __HAL_UNLOCK(huart);
 8009e16:	68fb      	ldr	r3, [r7, #12]
 8009e18:	2200      	movs	r2, #0
 8009e1a:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

      /* Restore huart->RxState to ready */
      huart->RxState = HAL_UART_STATE_READY;
 8009e1e:	68fb      	ldr	r3, [r7, #12]
 8009e20:	2220      	movs	r2, #32
 8009e22:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

      return HAL_ERROR;
 8009e26:	2301      	movs	r3, #1
 8009e28:	e055      	b.n	8009ed6 <UART_Start_Receive_DMA+0x13a>
    }
  }
  __HAL_UNLOCK(huart);
 8009e2a:	68fb      	ldr	r3, [r7, #12]
 8009e2c:	2200      	movs	r2, #0
 8009e2e:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

  /* Enable the UART Parity Error Interrupt */
  if (huart->Init.Parity != UART_PARITY_NONE)
 8009e32:	68fb      	ldr	r3, [r7, #12]
 8009e34:	691b      	ldr	r3, [r3, #16]
 8009e36:	2b00      	cmp	r3, #0
 8009e38:	d018      	beq.n	8009e6c <UART_Start_Receive_DMA+0xd0>
  {
    ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 8009e3a:	68fb      	ldr	r3, [r7, #12]
 8009e3c:	681b      	ldr	r3, [r3, #0]
 8009e3e:	63fb      	str	r3, [r7, #60]	; 0x3c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8009e40:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8009e42:	e853 3f00 	ldrex	r3, [r3]
 8009e46:	63bb      	str	r3, [r7, #56]	; 0x38
   return(result);
 8009e48:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8009e4a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8009e4e:	657b      	str	r3, [r7, #84]	; 0x54
 8009e50:	68fb      	ldr	r3, [r7, #12]
 8009e52:	681b      	ldr	r3, [r3, #0]
 8009e54:	461a      	mov	r2, r3
 8009e56:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8009e58:	64bb      	str	r3, [r7, #72]	; 0x48
 8009e5a:	647a      	str	r2, [r7, #68]	; 0x44
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8009e5c:	6c79      	ldr	r1, [r7, #68]	; 0x44
 8009e5e:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8009e60:	e841 2300 	strex	r3, r2, [r1]
 8009e64:	643b      	str	r3, [r7, #64]	; 0x40
   return(result);
 8009e66:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009e68:	2b00      	cmp	r3, #0
 8009e6a:	d1e6      	bne.n	8009e3a <UART_Start_Receive_DMA+0x9e>
  }

  /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8009e6c:	68fb      	ldr	r3, [r7, #12]
 8009e6e:	681b      	ldr	r3, [r3, #0]
 8009e70:	3308      	adds	r3, #8
 8009e72:	62bb      	str	r3, [r7, #40]	; 0x28
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8009e74:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009e76:	e853 3f00 	ldrex	r3, [r3]
 8009e7a:	627b      	str	r3, [r7, #36]	; 0x24
   return(result);
 8009e7c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009e7e:	f043 0301 	orr.w	r3, r3, #1
 8009e82:	653b      	str	r3, [r7, #80]	; 0x50
 8009e84:	68fb      	ldr	r3, [r7, #12]
 8009e86:	681b      	ldr	r3, [r3, #0]
 8009e88:	3308      	adds	r3, #8
 8009e8a:	6d3a      	ldr	r2, [r7, #80]	; 0x50
 8009e8c:	637a      	str	r2, [r7, #52]	; 0x34
 8009e8e:	633b      	str	r3, [r7, #48]	; 0x30
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8009e90:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8009e92:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8009e94:	e841 2300 	strex	r3, r2, [r1]
 8009e98:	62fb      	str	r3, [r7, #44]	; 0x2c
   return(result);
 8009e9a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009e9c:	2b00      	cmp	r3, #0
 8009e9e:	d1e5      	bne.n	8009e6c <UART_Start_Receive_DMA+0xd0>

  /* Enable the DMA transfer for the receiver request by setting the DMAR bit
  in the UART CR3 register */
  ATOMIC_SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8009ea0:	68fb      	ldr	r3, [r7, #12]
 8009ea2:	681b      	ldr	r3, [r3, #0]
 8009ea4:	3308      	adds	r3, #8
 8009ea6:	617b      	str	r3, [r7, #20]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8009ea8:	697b      	ldr	r3, [r7, #20]
 8009eaa:	e853 3f00 	ldrex	r3, [r3]
 8009eae:	613b      	str	r3, [r7, #16]
   return(result);
 8009eb0:	693b      	ldr	r3, [r7, #16]
 8009eb2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8009eb6:	64fb      	str	r3, [r7, #76]	; 0x4c
 8009eb8:	68fb      	ldr	r3, [r7, #12]
 8009eba:	681b      	ldr	r3, [r3, #0]
 8009ebc:	3308      	adds	r3, #8
 8009ebe:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8009ec0:	623a      	str	r2, [r7, #32]
 8009ec2:	61fb      	str	r3, [r7, #28]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8009ec4:	69f9      	ldr	r1, [r7, #28]
 8009ec6:	6a3a      	ldr	r2, [r7, #32]
 8009ec8:	e841 2300 	strex	r3, r2, [r1]
 8009ecc:	61bb      	str	r3, [r7, #24]
   return(result);
 8009ece:	69bb      	ldr	r3, [r7, #24]
 8009ed0:	2b00      	cmp	r3, #0
 8009ed2:	d1e5      	bne.n	8009ea0 <UART_Start_Receive_DMA+0x104>

  return HAL_OK;
 8009ed4:	2300      	movs	r3, #0
}
 8009ed6:	4618      	mov	r0, r3
 8009ed8:	3758      	adds	r7, #88	; 0x58
 8009eda:	46bd      	mov	sp, r7
 8009edc:	bd80      	pop	{r7, pc}
 8009ede:	bf00      	nop
 8009ee0:	0800a0ef 	.word	0x0800a0ef
 8009ee4:	0800a211 	.word	0x0800a211
 8009ee8:	0800a249 	.word	0x0800a249

08009eec <UART_EndTxTransfer>:
  * @brief  End ongoing Tx transfer on UART peripheral (following error detection or Transmit completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
{
 8009eec:	b480      	push	{r7}
 8009eee:	b08f      	sub	sp, #60	; 0x3c
 8009ef0:	af00      	add	r7, sp, #0
 8009ef2:	6078      	str	r0, [r7, #4]
  /* Disable TXEIE, TCIE, TXFT interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE | USART_CR1_TCIE));
 8009ef4:	687b      	ldr	r3, [r7, #4]
 8009ef6:	681b      	ldr	r3, [r3, #0]
 8009ef8:	623b      	str	r3, [r7, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8009efa:	6a3b      	ldr	r3, [r7, #32]
 8009efc:	e853 3f00 	ldrex	r3, [r3]
 8009f00:	61fb      	str	r3, [r7, #28]
   return(result);
 8009f02:	69fb      	ldr	r3, [r7, #28]
 8009f04:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 8009f08:	637b      	str	r3, [r7, #52]	; 0x34
 8009f0a:	687b      	ldr	r3, [r7, #4]
 8009f0c:	681b      	ldr	r3, [r3, #0]
 8009f0e:	461a      	mov	r2, r3
 8009f10:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009f12:	62fb      	str	r3, [r7, #44]	; 0x2c
 8009f14:	62ba      	str	r2, [r7, #40]	; 0x28
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8009f16:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8009f18:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8009f1a:	e841 2300 	strex	r3, r2, [r1]
 8009f1e:	627b      	str	r3, [r7, #36]	; 0x24
   return(result);
 8009f20:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009f22:	2b00      	cmp	r3, #0
 8009f24:	d1e6      	bne.n	8009ef4 <UART_EndTxTransfer+0x8>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_TXFTIE));
 8009f26:	687b      	ldr	r3, [r7, #4]
 8009f28:	681b      	ldr	r3, [r3, #0]
 8009f2a:	3308      	adds	r3, #8
 8009f2c:	60fb      	str	r3, [r7, #12]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8009f2e:	68fb      	ldr	r3, [r7, #12]
 8009f30:	e853 3f00 	ldrex	r3, [r3]
 8009f34:	60bb      	str	r3, [r7, #8]
   return(result);
 8009f36:	68bb      	ldr	r3, [r7, #8]
 8009f38:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 8009f3c:	633b      	str	r3, [r7, #48]	; 0x30
 8009f3e:	687b      	ldr	r3, [r7, #4]
 8009f40:	681b      	ldr	r3, [r3, #0]
 8009f42:	3308      	adds	r3, #8
 8009f44:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8009f46:	61ba      	str	r2, [r7, #24]
 8009f48:	617b      	str	r3, [r7, #20]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8009f4a:	6979      	ldr	r1, [r7, #20]
 8009f4c:	69ba      	ldr	r2, [r7, #24]
 8009f4e:	e841 2300 	strex	r3, r2, [r1]
 8009f52:	613b      	str	r3, [r7, #16]
   return(result);
 8009f54:	693b      	ldr	r3, [r7, #16]
 8009f56:	2b00      	cmp	r3, #0
 8009f58:	d1e5      	bne.n	8009f26 <UART_EndTxTransfer+0x3a>

  /* At end of Tx process, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 8009f5a:	687b      	ldr	r3, [r7, #4]
 8009f5c:	2220      	movs	r2, #32
 8009f5e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
}
 8009f62:	bf00      	nop
 8009f64:	373c      	adds	r7, #60	; 0x3c
 8009f66:	46bd      	mov	sp, r7
 8009f68:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009f6c:	4770      	bx	lr
	...

08009f70 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 8009f70:	b480      	push	{r7}
 8009f72:	b095      	sub	sp, #84	; 0x54
 8009f74:	af00      	add	r7, sp, #0
 8009f76:	6078      	str	r0, [r7, #4]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 8009f78:	687b      	ldr	r3, [r7, #4]
 8009f7a:	681b      	ldr	r3, [r3, #0]
 8009f7c:	637b      	str	r3, [r7, #52]	; 0x34
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8009f7e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009f80:	e853 3f00 	ldrex	r3, [r3]
 8009f84:	633b      	str	r3, [r7, #48]	; 0x30
   return(result);
 8009f86:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8009f88:	f423 7390 	bic.w	r3, r3, #288	; 0x120
 8009f8c:	64fb      	str	r3, [r7, #76]	; 0x4c
 8009f8e:	687b      	ldr	r3, [r7, #4]
 8009f90:	681b      	ldr	r3, [r3, #0]
 8009f92:	461a      	mov	r2, r3
 8009f94:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8009f96:	643b      	str	r3, [r7, #64]	; 0x40
 8009f98:	63fa      	str	r2, [r7, #60]	; 0x3c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8009f9a:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 8009f9c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8009f9e:	e841 2300 	strex	r3, r2, [r1]
 8009fa2:	63bb      	str	r3, [r7, #56]	; 0x38
   return(result);
 8009fa4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8009fa6:	2b00      	cmp	r3, #0
 8009fa8:	d1e6      	bne.n	8009f78 <UART_EndRxTransfer+0x8>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 8009faa:	687b      	ldr	r3, [r7, #4]
 8009fac:	681b      	ldr	r3, [r3, #0]
 8009fae:	3308      	adds	r3, #8
 8009fb0:	623b      	str	r3, [r7, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8009fb2:	6a3b      	ldr	r3, [r7, #32]
 8009fb4:	e853 3f00 	ldrex	r3, [r3]
 8009fb8:	61fb      	str	r3, [r7, #28]
   return(result);
 8009fba:	69fa      	ldr	r2, [r7, #28]
 8009fbc:	4b1e      	ldr	r3, [pc, #120]	; (800a038 <UART_EndRxTransfer+0xc8>)
 8009fbe:	4013      	ands	r3, r2
 8009fc0:	64bb      	str	r3, [r7, #72]	; 0x48
 8009fc2:	687b      	ldr	r3, [r7, #4]
 8009fc4:	681b      	ldr	r3, [r3, #0]
 8009fc6:	3308      	adds	r3, #8
 8009fc8:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8009fca:	62fa      	str	r2, [r7, #44]	; 0x2c
 8009fcc:	62bb      	str	r3, [r7, #40]	; 0x28
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8009fce:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8009fd0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8009fd2:	e841 2300 	strex	r3, r2, [r1]
 8009fd6:	627b      	str	r3, [r7, #36]	; 0x24
   return(result);
 8009fd8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009fda:	2b00      	cmp	r3, #0
 8009fdc:	d1e5      	bne.n	8009faa <UART_EndRxTransfer+0x3a>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 8009fde:	687b      	ldr	r3, [r7, #4]
 8009fe0:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8009fe2:	2b01      	cmp	r3, #1
 8009fe4:	d118      	bne.n	800a018 <UART_EndRxTransfer+0xa8>
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 8009fe6:	687b      	ldr	r3, [r7, #4]
 8009fe8:	681b      	ldr	r3, [r3, #0]
 8009fea:	60fb      	str	r3, [r7, #12]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8009fec:	68fb      	ldr	r3, [r7, #12]
 8009fee:	e853 3f00 	ldrex	r3, [r3]
 8009ff2:	60bb      	str	r3, [r7, #8]
   return(result);
 8009ff4:	68bb      	ldr	r3, [r7, #8]
 8009ff6:	f023 0310 	bic.w	r3, r3, #16
 8009ffa:	647b      	str	r3, [r7, #68]	; 0x44
 8009ffc:	687b      	ldr	r3, [r7, #4]
 8009ffe:	681b      	ldr	r3, [r3, #0]
 800a000:	461a      	mov	r2, r3
 800a002:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800a004:	61bb      	str	r3, [r7, #24]
 800a006:	617a      	str	r2, [r7, #20]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800a008:	6979      	ldr	r1, [r7, #20]
 800a00a:	69ba      	ldr	r2, [r7, #24]
 800a00c:	e841 2300 	strex	r3, r2, [r1]
 800a010:	613b      	str	r3, [r7, #16]
   return(result);
 800a012:	693b      	ldr	r3, [r7, #16]
 800a014:	2b00      	cmp	r3, #0
 800a016:	d1e6      	bne.n	8009fe6 <UART_EndRxTransfer+0x76>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 800a018:	687b      	ldr	r3, [r7, #4]
 800a01a:	2220      	movs	r2, #32
 800a01c:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800a020:	687b      	ldr	r3, [r7, #4]
 800a022:	2200      	movs	r2, #0
 800a024:	66da      	str	r2, [r3, #108]	; 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 800a026:	687b      	ldr	r3, [r7, #4]
 800a028:	2200      	movs	r2, #0
 800a02a:	671a      	str	r2, [r3, #112]	; 0x70
}
 800a02c:	bf00      	nop
 800a02e:	3754      	adds	r7, #84	; 0x54
 800a030:	46bd      	mov	sp, r7
 800a032:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a036:	4770      	bx	lr
 800a038:	effffffe 	.word	0xeffffffe

0800a03c <UART_DMATransmitCplt>:
  * @brief DMA UART transmit process complete callback.
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
{
 800a03c:	b580      	push	{r7, lr}
 800a03e:	b090      	sub	sp, #64	; 0x40
 800a040:	af00      	add	r7, sp, #0
 800a042:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 800a044:	687b      	ldr	r3, [r7, #4]
 800a046:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800a048:	63fb      	str	r3, [r7, #60]	; 0x3c

  /* DMA Normal mode */
  if (hdma->Init.Mode != DMA_CIRCULAR)
 800a04a:	687b      	ldr	r3, [r7, #4]
 800a04c:	69db      	ldr	r3, [r3, #28]
 800a04e:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800a052:	d037      	beq.n	800a0c4 <UART_DMATransmitCplt+0x88>
  {
    huart->TxXferCount = 0U;
 800a054:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a056:	2200      	movs	r2, #0
 800a058:	f8a3 2056 	strh.w	r2, [r3, #86]	; 0x56

    /* Disable the DMA transfer for transmit request by resetting the DMAT bit
       in the UART CR3 register */
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
 800a05c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a05e:	681b      	ldr	r3, [r3, #0]
 800a060:	3308      	adds	r3, #8
 800a062:	627b      	str	r3, [r7, #36]	; 0x24
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800a064:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a066:	e853 3f00 	ldrex	r3, [r3]
 800a06a:	623b      	str	r3, [r7, #32]
   return(result);
 800a06c:	6a3b      	ldr	r3, [r7, #32]
 800a06e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800a072:	63bb      	str	r3, [r7, #56]	; 0x38
 800a074:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a076:	681b      	ldr	r3, [r3, #0]
 800a078:	3308      	adds	r3, #8
 800a07a:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800a07c:	633a      	str	r2, [r7, #48]	; 0x30
 800a07e:	62fb      	str	r3, [r7, #44]	; 0x2c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800a080:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800a082:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800a084:	e841 2300 	strex	r3, r2, [r1]
 800a088:	62bb      	str	r3, [r7, #40]	; 0x28
   return(result);
 800a08a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a08c:	2b00      	cmp	r3, #0
 800a08e:	d1e5      	bne.n	800a05c <UART_DMATransmitCplt+0x20>

    /* Enable the UART Transmit Complete Interrupt */
    ATOMIC_SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 800a090:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a092:	681b      	ldr	r3, [r3, #0]
 800a094:	613b      	str	r3, [r7, #16]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800a096:	693b      	ldr	r3, [r7, #16]
 800a098:	e853 3f00 	ldrex	r3, [r3]
 800a09c:	60fb      	str	r3, [r7, #12]
   return(result);
 800a09e:	68fb      	ldr	r3, [r7, #12]
 800a0a0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800a0a4:	637b      	str	r3, [r7, #52]	; 0x34
 800a0a6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a0a8:	681b      	ldr	r3, [r3, #0]
 800a0aa:	461a      	mov	r2, r3
 800a0ac:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a0ae:	61fb      	str	r3, [r7, #28]
 800a0b0:	61ba      	str	r2, [r7, #24]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800a0b2:	69b9      	ldr	r1, [r7, #24]
 800a0b4:	69fa      	ldr	r2, [r7, #28]
 800a0b6:	e841 2300 	strex	r3, r2, [r1]
 800a0ba:	617b      	str	r3, [r7, #20]
   return(result);
 800a0bc:	697b      	ldr	r3, [r7, #20]
 800a0be:	2b00      	cmp	r3, #0
 800a0c0:	d1e6      	bne.n	800a090 <UART_DMATransmitCplt+0x54>
#else
    /*Call legacy weak Tx complete callback*/
    HAL_UART_TxCpltCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
  }
}
 800a0c2:	e002      	b.n	800a0ca <UART_DMATransmitCplt+0x8e>
    HAL_UART_TxCpltCallback(huart);
 800a0c4:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 800a0c6:	f017 fd45 	bl	8021b54 <HAL_UART_TxCpltCallback>
}
 800a0ca:	bf00      	nop
 800a0cc:	3740      	adds	r7, #64	; 0x40
 800a0ce:	46bd      	mov	sp, r7
 800a0d0:	bd80      	pop	{r7, pc}

0800a0d2 <UART_DMATxHalfCplt>:
  * @brief DMA UART transmit process half complete callback.
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
{
 800a0d2:	b580      	push	{r7, lr}
 800a0d4:	b084      	sub	sp, #16
 800a0d6:	af00      	add	r7, sp, #0
 800a0d8:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 800a0da:	687b      	ldr	r3, [r7, #4]
 800a0dc:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800a0de:	60fb      	str	r3, [r7, #12]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx Half complete callback*/
  huart->TxHalfCpltCallback(huart);
#else
  /*Call legacy weak Tx Half complete callback*/
  HAL_UART_TxHalfCpltCallback(huart);
 800a0e0:	68f8      	ldr	r0, [r7, #12]
 800a0e2:	f7fe ff1b 	bl	8008f1c <HAL_UART_TxHalfCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 800a0e6:	bf00      	nop
 800a0e8:	3710      	adds	r7, #16
 800a0ea:	46bd      	mov	sp, r7
 800a0ec:	bd80      	pop	{r7, pc}

0800a0ee <UART_DMAReceiveCplt>:
  * @brief DMA UART receive process complete callback.
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
{
 800a0ee:	b580      	push	{r7, lr}
 800a0f0:	b09c      	sub	sp, #112	; 0x70
 800a0f2:	af00      	add	r7, sp, #0
 800a0f4:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 800a0f6:	687b      	ldr	r3, [r7, #4]
 800a0f8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800a0fa:	66fb      	str	r3, [r7, #108]	; 0x6c

  /* DMA Normal mode */
  if (hdma->Init.Mode != DMA_CIRCULAR)
 800a0fc:	687b      	ldr	r3, [r7, #4]
 800a0fe:	69db      	ldr	r3, [r3, #28]
 800a100:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800a104:	d071      	beq.n	800a1ea <UART_DMAReceiveCplt+0xfc>
  {
    huart->RxXferCount = 0U;
 800a106:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a108:	2200      	movs	r2, #0
 800a10a:	f8a3 205e 	strh.w	r2, [r3, #94]	; 0x5e

    /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 800a10e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a110:	681b      	ldr	r3, [r3, #0]
 800a112:	64fb      	str	r3, [r7, #76]	; 0x4c
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800a114:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a116:	e853 3f00 	ldrex	r3, [r3]
 800a11a:	64bb      	str	r3, [r7, #72]	; 0x48
   return(result);
 800a11c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800a11e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800a122:	66bb      	str	r3, [r7, #104]	; 0x68
 800a124:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a126:	681b      	ldr	r3, [r3, #0]
 800a128:	461a      	mov	r2, r3
 800a12a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 800a12c:	65bb      	str	r3, [r7, #88]	; 0x58
 800a12e:	657a      	str	r2, [r7, #84]	; 0x54
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800a130:	6d79      	ldr	r1, [r7, #84]	; 0x54
 800a132:	6dba      	ldr	r2, [r7, #88]	; 0x58
 800a134:	e841 2300 	strex	r3, r2, [r1]
 800a138:	653b      	str	r3, [r7, #80]	; 0x50
   return(result);
 800a13a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800a13c:	2b00      	cmp	r3, #0
 800a13e:	d1e6      	bne.n	800a10e <UART_DMAReceiveCplt+0x20>
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800a140:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a142:	681b      	ldr	r3, [r3, #0]
 800a144:	3308      	adds	r3, #8
 800a146:	63bb      	str	r3, [r7, #56]	; 0x38
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800a148:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800a14a:	e853 3f00 	ldrex	r3, [r3]
 800a14e:	637b      	str	r3, [r7, #52]	; 0x34
   return(result);
 800a150:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a152:	f023 0301 	bic.w	r3, r3, #1
 800a156:	667b      	str	r3, [r7, #100]	; 0x64
 800a158:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a15a:	681b      	ldr	r3, [r3, #0]
 800a15c:	3308      	adds	r3, #8
 800a15e:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 800a160:	647a      	str	r2, [r7, #68]	; 0x44
 800a162:	643b      	str	r3, [r7, #64]	; 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800a164:	6c39      	ldr	r1, [r7, #64]	; 0x40
 800a166:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800a168:	e841 2300 	strex	r3, r2, [r1]
 800a16c:	63fb      	str	r3, [r7, #60]	; 0x3c
   return(result);
 800a16e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a170:	2b00      	cmp	r3, #0
 800a172:	d1e5      	bne.n	800a140 <UART_DMAReceiveCplt+0x52>

    /* Disable the DMA transfer for the receiver request by resetting the DMAR bit
       in the UART CR3 register */
    ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 800a174:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a176:	681b      	ldr	r3, [r3, #0]
 800a178:	3308      	adds	r3, #8
 800a17a:	627b      	str	r3, [r7, #36]	; 0x24
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800a17c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800a17e:	e853 3f00 	ldrex	r3, [r3]
 800a182:	623b      	str	r3, [r7, #32]
   return(result);
 800a184:	6a3b      	ldr	r3, [r7, #32]
 800a186:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800a18a:	663b      	str	r3, [r7, #96]	; 0x60
 800a18c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a18e:	681b      	ldr	r3, [r3, #0]
 800a190:	3308      	adds	r3, #8
 800a192:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 800a194:	633a      	str	r2, [r7, #48]	; 0x30
 800a196:	62fb      	str	r3, [r7, #44]	; 0x2c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800a198:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 800a19a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800a19c:	e841 2300 	strex	r3, r2, [r1]
 800a1a0:	62bb      	str	r3, [r7, #40]	; 0x28
   return(result);
 800a1a2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a1a4:	2b00      	cmp	r3, #0
 800a1a6:	d1e5      	bne.n	800a174 <UART_DMAReceiveCplt+0x86>

    /* At end of Rx process, restore huart->RxState to Ready */
    huart->RxState = HAL_UART_STATE_READY;
 800a1a8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a1aa:	2220      	movs	r2, #32
 800a1ac:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

    /* If Reception till IDLE event has been selected, Disable IDLE Interrupt */
    if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800a1b0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a1b2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800a1b4:	2b01      	cmp	r3, #1
 800a1b6:	d118      	bne.n	800a1ea <UART_DMAReceiveCplt+0xfc>
    {
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800a1b8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a1ba:	681b      	ldr	r3, [r3, #0]
 800a1bc:	613b      	str	r3, [r7, #16]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800a1be:	693b      	ldr	r3, [r7, #16]
 800a1c0:	e853 3f00 	ldrex	r3, [r3]
 800a1c4:	60fb      	str	r3, [r7, #12]
   return(result);
 800a1c6:	68fb      	ldr	r3, [r7, #12]
 800a1c8:	f023 0310 	bic.w	r3, r3, #16
 800a1cc:	65fb      	str	r3, [r7, #92]	; 0x5c
 800a1ce:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a1d0:	681b      	ldr	r3, [r3, #0]
 800a1d2:	461a      	mov	r2, r3
 800a1d4:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800a1d6:	61fb      	str	r3, [r7, #28]
 800a1d8:	61ba      	str	r2, [r7, #24]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800a1da:	69b9      	ldr	r1, [r7, #24]
 800a1dc:	69fa      	ldr	r2, [r7, #28]
 800a1de:	e841 2300 	strex	r3, r2, [r1]
 800a1e2:	617b      	str	r3, [r7, #20]
   return(result);
 800a1e4:	697b      	ldr	r3, [r7, #20]
 800a1e6:	2b00      	cmp	r3, #0
 800a1e8:	d1e6      	bne.n	800a1b8 <UART_DMAReceiveCplt+0xca>
    }
  }

  /* Check current reception Mode :
     If Reception till IDLE event has been selected : use Rx Event callback */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800a1ea:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a1ec:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800a1ee:	2b01      	cmp	r3, #1
 800a1f0:	d107      	bne.n	800a202 <UART_DMAReceiveCplt+0x114>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    /*Call registered Rx Event callback*/
    huart->RxEventCallback(huart, huart->RxXferSize);
#else
    /*Call legacy weak Rx Event callback*/
    HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 800a1f2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a1f4:	f8b3 305c 	ldrh.w	r3, [r3, #92]	; 0x5c
 800a1f8:	4619      	mov	r1, r3
 800a1fa:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 800a1fc:	f7fe feac 	bl	8008f58 <HAL_UARTEx_RxEventCallback>
#else
    /*Call legacy weak Rx complete callback*/
    HAL_UART_RxCpltCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
  }
}
 800a200:	e002      	b.n	800a208 <UART_DMAReceiveCplt+0x11a>
    HAL_UART_RxCpltCallback(huart);
 800a202:	6ef8      	ldr	r0, [r7, #108]	; 0x6c
 800a204:	f017 fccc 	bl	8021ba0 <HAL_UART_RxCpltCallback>
}
 800a208:	bf00      	nop
 800a20a:	3770      	adds	r7, #112	; 0x70
 800a20c:	46bd      	mov	sp, r7
 800a20e:	bd80      	pop	{r7, pc}

0800a210 <UART_DMARxHalfCplt>:
  * @brief DMA UART receive process half complete callback.
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
{
 800a210:	b580      	push	{r7, lr}
 800a212:	b084      	sub	sp, #16
 800a214:	af00      	add	r7, sp, #0
 800a216:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 800a218:	687b      	ldr	r3, [r7, #4]
 800a21a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800a21c:	60fb      	str	r3, [r7, #12]

  /* Check current reception Mode :
     If Reception till IDLE event has been selected : use Rx Event callback */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800a21e:	68fb      	ldr	r3, [r7, #12]
 800a220:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800a222:	2b01      	cmp	r3, #1
 800a224:	d109      	bne.n	800a23a <UART_DMARxHalfCplt+0x2a>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    /*Call registered Rx Event callback*/
    huart->RxEventCallback(huart, huart->RxXferSize / 2U);
#else
    /*Call legacy weak Rx Event callback*/
    HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize / 2U);
 800a226:	68fb      	ldr	r3, [r7, #12]
 800a228:	f8b3 305c 	ldrh.w	r3, [r3, #92]	; 0x5c
 800a22c:	085b      	lsrs	r3, r3, #1
 800a22e:	b29b      	uxth	r3, r3
 800a230:	4619      	mov	r1, r3
 800a232:	68f8      	ldr	r0, [r7, #12]
 800a234:	f7fe fe90 	bl	8008f58 <HAL_UARTEx_RxEventCallback>
#else
    /*Call legacy weak Rx Half complete callback*/
    HAL_UART_RxHalfCpltCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
  }
}
 800a238:	e002      	b.n	800a240 <UART_DMARxHalfCplt+0x30>
    HAL_UART_RxHalfCpltCallback(huart);
 800a23a:	68f8      	ldr	r0, [r7, #12]
 800a23c:	f7fe fe78 	bl	8008f30 <HAL_UART_RxHalfCpltCallback>
}
 800a240:	bf00      	nop
 800a242:	3710      	adds	r7, #16
 800a244:	46bd      	mov	sp, r7
 800a246:	bd80      	pop	{r7, pc}

0800a248 <UART_DMAError>:
  * @brief DMA UART communication error callback.
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMAError(DMA_HandleTypeDef *hdma)
{
 800a248:	b580      	push	{r7, lr}
 800a24a:	b086      	sub	sp, #24
 800a24c:	af00      	add	r7, sp, #0
 800a24e:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 800a250:	687b      	ldr	r3, [r7, #4]
 800a252:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800a254:	617b      	str	r3, [r7, #20]

  const HAL_UART_StateTypeDef gstate = huart->gState;
 800a256:	697b      	ldr	r3, [r7, #20]
 800a258:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800a25c:	613b      	str	r3, [r7, #16]
  const HAL_UART_StateTypeDef rxstate = huart->RxState;
 800a25e:	697b      	ldr	r3, [r7, #20]
 800a260:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800a264:	60fb      	str	r3, [r7, #12]

  /* Stop UART DMA Tx request if ongoing */
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
 800a266:	697b      	ldr	r3, [r7, #20]
 800a268:	681b      	ldr	r3, [r3, #0]
 800a26a:	689b      	ldr	r3, [r3, #8]
 800a26c:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800a270:	2b80      	cmp	r3, #128	; 0x80
 800a272:	d109      	bne.n	800a288 <UART_DMAError+0x40>
 800a274:	693b      	ldr	r3, [r7, #16]
 800a276:	2b21      	cmp	r3, #33	; 0x21
 800a278:	d106      	bne.n	800a288 <UART_DMAError+0x40>
      (gstate == HAL_UART_STATE_BUSY_TX))
  {
    huart->TxXferCount = 0U;
 800a27a:	697b      	ldr	r3, [r7, #20]
 800a27c:	2200      	movs	r2, #0
 800a27e:	f8a3 2056 	strh.w	r2, [r3, #86]	; 0x56
    UART_EndTxTransfer(huart);
 800a282:	6978      	ldr	r0, [r7, #20]
 800a284:	f7ff fe32 	bl	8009eec <UART_EndTxTransfer>
  }

  /* Stop UART DMA Rx request if ongoing */
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) &&
 800a288:	697b      	ldr	r3, [r7, #20]
 800a28a:	681b      	ldr	r3, [r3, #0]
 800a28c:	689b      	ldr	r3, [r3, #8]
 800a28e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800a292:	2b40      	cmp	r3, #64	; 0x40
 800a294:	d109      	bne.n	800a2aa <UART_DMAError+0x62>
 800a296:	68fb      	ldr	r3, [r7, #12]
 800a298:	2b22      	cmp	r3, #34	; 0x22
 800a29a:	d106      	bne.n	800a2aa <UART_DMAError+0x62>
      (rxstate == HAL_UART_STATE_BUSY_RX))
  {
    huart->RxXferCount = 0U;
 800a29c:	697b      	ldr	r3, [r7, #20]
 800a29e:	2200      	movs	r2, #0
 800a2a0:	f8a3 205e 	strh.w	r2, [r3, #94]	; 0x5e
    UART_EndRxTransfer(huart);
 800a2a4:	6978      	ldr	r0, [r7, #20]
 800a2a6:	f7ff fe63 	bl	8009f70 <UART_EndRxTransfer>
  }

  huart->ErrorCode |= HAL_UART_ERROR_DMA;
 800a2aa:	697b      	ldr	r3, [r7, #20]
 800a2ac:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800a2b0:	f043 0210 	orr.w	r2, r3, #16
 800a2b4:	697b      	ldr	r3, [r7, #20]
 800a2b6:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 800a2ba:	6978      	ldr	r0, [r7, #20]
 800a2bc:	f7fe fe42 	bl	8008f44 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 800a2c0:	bf00      	nop
 800a2c2:	3718      	adds	r7, #24
 800a2c4:	46bd      	mov	sp, r7
 800a2c6:	bd80      	pop	{r7, pc}

0800a2c8 <UART_DMAAbortOnError>:
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */
static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 800a2c8:	b580      	push	{r7, lr}
 800a2ca:	b084      	sub	sp, #16
 800a2cc:	af00      	add	r7, sp, #0
 800a2ce:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 800a2d0:	687b      	ldr	r3, [r7, #4]
 800a2d2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800a2d4:	60fb      	str	r3, [r7, #12]
  huart->RxXferCount = 0U;
 800a2d6:	68fb      	ldr	r3, [r7, #12]
 800a2d8:	2200      	movs	r2, #0
 800a2da:	f8a3 205e 	strh.w	r2, [r3, #94]	; 0x5e
  huart->TxXferCount = 0U;
 800a2de:	68fb      	ldr	r3, [r7, #12]
 800a2e0:	2200      	movs	r2, #0
 800a2e2:	f8a3 2056 	strh.w	r2, [r3, #86]	; 0x56
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
 800a2e6:	68f8      	ldr	r0, [r7, #12]
 800a2e8:	f7fe fe2c 	bl	8008f44 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 800a2ec:	bf00      	nop
 800a2ee:	3710      	adds	r7, #16
 800a2f0:	46bd      	mov	sp, r7
 800a2f2:	bd80      	pop	{r7, pc}

0800a2f4 <UART_EndTransmit_IT>:
  * @param  huart pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
 800a2f4:	b580      	push	{r7, lr}
 800a2f6:	b088      	sub	sp, #32
 800a2f8:	af00      	add	r7, sp, #0
 800a2fa:	6078      	str	r0, [r7, #4]
  /* Disable the UART Transmit Complete Interrupt */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 800a2fc:	687b      	ldr	r3, [r7, #4]
 800a2fe:	681b      	ldr	r3, [r3, #0]
 800a300:	60fb      	str	r3, [r7, #12]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800a302:	68fb      	ldr	r3, [r7, #12]
 800a304:	e853 3f00 	ldrex	r3, [r3]
 800a308:	60bb      	str	r3, [r7, #8]
   return(result);
 800a30a:	68bb      	ldr	r3, [r7, #8]
 800a30c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800a310:	61fb      	str	r3, [r7, #28]
 800a312:	687b      	ldr	r3, [r7, #4]
 800a314:	681b      	ldr	r3, [r3, #0]
 800a316:	461a      	mov	r2, r3
 800a318:	69fb      	ldr	r3, [r7, #28]
 800a31a:	61bb      	str	r3, [r7, #24]
 800a31c:	617a      	str	r2, [r7, #20]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800a31e:	6979      	ldr	r1, [r7, #20]
 800a320:	69ba      	ldr	r2, [r7, #24]
 800a322:	e841 2300 	strex	r3, r2, [r1]
 800a326:	613b      	str	r3, [r7, #16]
   return(result);
 800a328:	693b      	ldr	r3, [r7, #16]
 800a32a:	2b00      	cmp	r3, #0
 800a32c:	d1e6      	bne.n	800a2fc <UART_EndTransmit_IT+0x8>

  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 800a32e:	687b      	ldr	r3, [r7, #4]
 800a330:	2220      	movs	r2, #32
 800a332:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  /* Cleat TxISR function pointer */
  huart->TxISR = NULL;
 800a336:	687b      	ldr	r3, [r7, #4]
 800a338:	2200      	movs	r2, #0
 800a33a:	675a      	str	r2, [r3, #116]	; 0x74
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx complete callback*/
  huart->TxCpltCallback(huart);
#else
  /*Call legacy weak Tx complete callback*/
  HAL_UART_TxCpltCallback(huart);
 800a33c:	6878      	ldr	r0, [r7, #4]
 800a33e:	f017 fc09 	bl	8021b54 <HAL_UART_TxCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
 800a342:	bf00      	nop
 800a344:	3720      	adds	r7, #32
 800a346:	46bd      	mov	sp, r7
 800a348:	bd80      	pop	{r7, pc}

0800a34a <HAL_UARTEx_WakeupCallback>:
  * @brief UART wakeup from Stop mode callback.
  * @param huart UART handle.
  * @retval None
  */
__weak void HAL_UARTEx_WakeupCallback(UART_HandleTypeDef *huart)
{
 800a34a:	b480      	push	{r7}
 800a34c:	b083      	sub	sp, #12
 800a34e:	af00      	add	r7, sp, #0
 800a350:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_WakeupCallback can be implemented in the user file.
   */
}
 800a352:	bf00      	nop
 800a354:	370c      	adds	r7, #12
 800a356:	46bd      	mov	sp, r7
 800a358:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a35c:	4770      	bx	lr

0800a35e <HAL_UARTEx_RxFifoFullCallback>:
  * @brief  UART RX Fifo full callback.
  * @param  huart UART handle.
  * @retval None
  */
__weak void HAL_UARTEx_RxFifoFullCallback(UART_HandleTypeDef *huart)
{
 800a35e:	b480      	push	{r7}
 800a360:	b083      	sub	sp, #12
 800a362:	af00      	add	r7, sp, #0
 800a364:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_RxFifoFullCallback can be implemented in the user file.
   */
}
 800a366:	bf00      	nop
 800a368:	370c      	adds	r7, #12
 800a36a:	46bd      	mov	sp, r7
 800a36c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a370:	4770      	bx	lr

0800a372 <HAL_UARTEx_TxFifoEmptyCallback>:
  * @brief  UART TX Fifo empty callback.
  * @param  huart UART handle.
  * @retval None
  */
__weak void HAL_UARTEx_TxFifoEmptyCallback(UART_HandleTypeDef *huart)
{
 800a372:	b480      	push	{r7}
 800a374:	b083      	sub	sp, #12
 800a376:	af00      	add	r7, sp, #0
 800a378:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_TxFifoEmptyCallback can be implemented in the user file.
   */
}
 800a37a:	bf00      	nop
 800a37c:	370c      	adds	r7, #12
 800a37e:	46bd      	mov	sp, r7
 800a380:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a384:	4770      	bx	lr

0800a386 <HAL_UARTEx_DisableFifoMode>:
  * @brief  Disable the FIFO mode.
  * @param huart      UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_DisableFifoMode(UART_HandleTypeDef *huart)
{
 800a386:	b480      	push	{r7}
 800a388:	b085      	sub	sp, #20
 800a38a:	af00      	add	r7, sp, #0
 800a38c:	6078      	str	r0, [r7, #4]

  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));

  /* Process Locked */
  __HAL_LOCK(huart);
 800a38e:	687b      	ldr	r3, [r7, #4]
 800a390:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
 800a394:	2b01      	cmp	r3, #1
 800a396:	d101      	bne.n	800a39c <HAL_UARTEx_DisableFifoMode+0x16>
 800a398:	2302      	movs	r3, #2
 800a39a:	e027      	b.n	800a3ec <HAL_UARTEx_DisableFifoMode+0x66>
 800a39c:	687b      	ldr	r3, [r7, #4]
 800a39e:	2201      	movs	r2, #1
 800a3a0:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

  huart->gState = HAL_UART_STATE_BUSY;
 800a3a4:	687b      	ldr	r3, [r7, #4]
 800a3a6:	2224      	movs	r2, #36	; 0x24
 800a3a8:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 800a3ac:	687b      	ldr	r3, [r7, #4]
 800a3ae:	681b      	ldr	r3, [r3, #0]
 800a3b0:	681b      	ldr	r3, [r3, #0]
 800a3b2:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 800a3b4:	687b      	ldr	r3, [r7, #4]
 800a3b6:	681b      	ldr	r3, [r3, #0]
 800a3b8:	681a      	ldr	r2, [r3, #0]
 800a3ba:	687b      	ldr	r3, [r7, #4]
 800a3bc:	681b      	ldr	r3, [r3, #0]
 800a3be:	f022 0201 	bic.w	r2, r2, #1
 800a3c2:	601a      	str	r2, [r3, #0]

  /* Enable FIFO mode */
  CLEAR_BIT(tmpcr1, USART_CR1_FIFOEN);
 800a3c4:	68fb      	ldr	r3, [r7, #12]
 800a3c6:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
 800a3ca:	60fb      	str	r3, [r7, #12]
  huart->FifoMode = UART_FIFOMODE_DISABLE;
 800a3cc:	687b      	ldr	r3, [r7, #4]
 800a3ce:	2200      	movs	r2, #0
 800a3d0:	665a      	str	r2, [r3, #100]	; 0x64

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 800a3d2:	687b      	ldr	r3, [r7, #4]
 800a3d4:	681b      	ldr	r3, [r3, #0]
 800a3d6:	68fa      	ldr	r2, [r7, #12]
 800a3d8:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
 800a3da:	687b      	ldr	r3, [r7, #4]
 800a3dc:	2220      	movs	r2, #32
 800a3de:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 800a3e2:	687b      	ldr	r3, [r7, #4]
 800a3e4:	2200      	movs	r2, #0
 800a3e6:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

  return HAL_OK;
 800a3ea:	2300      	movs	r3, #0
}
 800a3ec:	4618      	mov	r0, r3
 800a3ee:	3714      	adds	r7, #20
 800a3f0:	46bd      	mov	sp, r7
 800a3f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a3f6:	4770      	bx	lr

0800a3f8 <HAL_UARTEx_SetTxFifoThreshold>:
  *            @arg @ref UART_TXFIFO_THRESHOLD_7_8
  *            @arg @ref UART_TXFIFO_THRESHOLD_8_8
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_SetTxFifoThreshold(UART_HandleTypeDef *huart, uint32_t Threshold)
{
 800a3f8:	b580      	push	{r7, lr}
 800a3fa:	b084      	sub	sp, #16
 800a3fc:	af00      	add	r7, sp, #0
 800a3fe:	6078      	str	r0, [r7, #4]
 800a400:	6039      	str	r1, [r7, #0]
  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
  assert_param(IS_UART_TXFIFO_THRESHOLD(Threshold));

  /* Process Locked */
  __HAL_LOCK(huart);
 800a402:	687b      	ldr	r3, [r7, #4]
 800a404:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
 800a408:	2b01      	cmp	r3, #1
 800a40a:	d101      	bne.n	800a410 <HAL_UARTEx_SetTxFifoThreshold+0x18>
 800a40c:	2302      	movs	r3, #2
 800a40e:	e02d      	b.n	800a46c <HAL_UARTEx_SetTxFifoThreshold+0x74>
 800a410:	687b      	ldr	r3, [r7, #4]
 800a412:	2201      	movs	r2, #1
 800a414:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

  huart->gState = HAL_UART_STATE_BUSY;
 800a418:	687b      	ldr	r3, [r7, #4]
 800a41a:	2224      	movs	r2, #36	; 0x24
 800a41c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 800a420:	687b      	ldr	r3, [r7, #4]
 800a422:	681b      	ldr	r3, [r3, #0]
 800a424:	681b      	ldr	r3, [r3, #0]
 800a426:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 800a428:	687b      	ldr	r3, [r7, #4]
 800a42a:	681b      	ldr	r3, [r3, #0]
 800a42c:	681a      	ldr	r2, [r3, #0]
 800a42e:	687b      	ldr	r3, [r7, #4]
 800a430:	681b      	ldr	r3, [r3, #0]
 800a432:	f022 0201 	bic.w	r2, r2, #1
 800a436:	601a      	str	r2, [r3, #0]

  /* Update TX threshold configuration */
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
 800a438:	687b      	ldr	r3, [r7, #4]
 800a43a:	681b      	ldr	r3, [r3, #0]
 800a43c:	689b      	ldr	r3, [r3, #8]
 800a43e:	f023 4160 	bic.w	r1, r3, #3758096384	; 0xe0000000
 800a442:	687b      	ldr	r3, [r7, #4]
 800a444:	681b      	ldr	r3, [r3, #0]
 800a446:	683a      	ldr	r2, [r7, #0]
 800a448:	430a      	orrs	r2, r1
 800a44a:	609a      	str	r2, [r3, #8]

  /* Determine the number of data to process during RX/TX ISR execution */
  UARTEx_SetNbDataToProcess(huart);
 800a44c:	6878      	ldr	r0, [r7, #4]
 800a44e:	f000 f84f 	bl	800a4f0 <UARTEx_SetNbDataToProcess>

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 800a452:	687b      	ldr	r3, [r7, #4]
 800a454:	681b      	ldr	r3, [r3, #0]
 800a456:	68fa      	ldr	r2, [r7, #12]
 800a458:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
 800a45a:	687b      	ldr	r3, [r7, #4]
 800a45c:	2220      	movs	r2, #32
 800a45e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 800a462:	687b      	ldr	r3, [r7, #4]
 800a464:	2200      	movs	r2, #0
 800a466:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

  return HAL_OK;
 800a46a:	2300      	movs	r3, #0
}
 800a46c:	4618      	mov	r0, r3
 800a46e:	3710      	adds	r7, #16
 800a470:	46bd      	mov	sp, r7
 800a472:	bd80      	pop	{r7, pc}

0800a474 <HAL_UARTEx_SetRxFifoThreshold>:
  *            @arg @ref UART_RXFIFO_THRESHOLD_7_8
  *            @arg @ref UART_RXFIFO_THRESHOLD_8_8
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_SetRxFifoThreshold(UART_HandleTypeDef *huart, uint32_t Threshold)
{
 800a474:	b580      	push	{r7, lr}
 800a476:	b084      	sub	sp, #16
 800a478:	af00      	add	r7, sp, #0
 800a47a:	6078      	str	r0, [r7, #4]
 800a47c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
  assert_param(IS_UART_RXFIFO_THRESHOLD(Threshold));

  /* Process Locked */
  __HAL_LOCK(huart);
 800a47e:	687b      	ldr	r3, [r7, #4]
 800a480:	f893 3080 	ldrb.w	r3, [r3, #128]	; 0x80
 800a484:	2b01      	cmp	r3, #1
 800a486:	d101      	bne.n	800a48c <HAL_UARTEx_SetRxFifoThreshold+0x18>
 800a488:	2302      	movs	r3, #2
 800a48a:	e02d      	b.n	800a4e8 <HAL_UARTEx_SetRxFifoThreshold+0x74>
 800a48c:	687b      	ldr	r3, [r7, #4]
 800a48e:	2201      	movs	r2, #1
 800a490:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

  huart->gState = HAL_UART_STATE_BUSY;
 800a494:	687b      	ldr	r3, [r7, #4]
 800a496:	2224      	movs	r2, #36	; 0x24
 800a498:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 800a49c:	687b      	ldr	r3, [r7, #4]
 800a49e:	681b      	ldr	r3, [r3, #0]
 800a4a0:	681b      	ldr	r3, [r3, #0]
 800a4a2:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 800a4a4:	687b      	ldr	r3, [r7, #4]
 800a4a6:	681b      	ldr	r3, [r3, #0]
 800a4a8:	681a      	ldr	r2, [r3, #0]
 800a4aa:	687b      	ldr	r3, [r7, #4]
 800a4ac:	681b      	ldr	r3, [r3, #0]
 800a4ae:	f022 0201 	bic.w	r2, r2, #1
 800a4b2:	601a      	str	r2, [r3, #0]

  /* Update RX threshold configuration */
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
 800a4b4:	687b      	ldr	r3, [r7, #4]
 800a4b6:	681b      	ldr	r3, [r3, #0]
 800a4b8:	689b      	ldr	r3, [r3, #8]
 800a4ba:	f023 6160 	bic.w	r1, r3, #234881024	; 0xe000000
 800a4be:	687b      	ldr	r3, [r7, #4]
 800a4c0:	681b      	ldr	r3, [r3, #0]
 800a4c2:	683a      	ldr	r2, [r7, #0]
 800a4c4:	430a      	orrs	r2, r1
 800a4c6:	609a      	str	r2, [r3, #8]

  /* Determine the number of data to process during RX/TX ISR execution */
  UARTEx_SetNbDataToProcess(huart);
 800a4c8:	6878      	ldr	r0, [r7, #4]
 800a4ca:	f000 f811 	bl	800a4f0 <UARTEx_SetNbDataToProcess>

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 800a4ce:	687b      	ldr	r3, [r7, #4]
 800a4d0:	681b      	ldr	r3, [r3, #0]
 800a4d2:	68fa      	ldr	r2, [r7, #12]
 800a4d4:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
 800a4d6:	687b      	ldr	r3, [r7, #4]
 800a4d8:	2220      	movs	r2, #32
 800a4da:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 800a4de:	687b      	ldr	r3, [r7, #4]
 800a4e0:	2200      	movs	r2, #0
 800a4e2:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80

  return HAL_OK;
 800a4e6:	2300      	movs	r3, #0
}
 800a4e8:	4618      	mov	r0, r3
 800a4ea:	3710      	adds	r7, #16
 800a4ec:	46bd      	mov	sp, r7
 800a4ee:	bd80      	pop	{r7, pc}

0800a4f0 <UARTEx_SetNbDataToProcess>:
  *       the UART configuration registers.
  * @param huart UART handle.
  * @retval None
  */
static void UARTEx_SetNbDataToProcess(UART_HandleTypeDef *huart)
{
 800a4f0:	b480      	push	{r7}
 800a4f2:	b085      	sub	sp, #20
 800a4f4:	af00      	add	r7, sp, #0
 800a4f6:	6078      	str	r0, [r7, #4]
  uint8_t rx_fifo_threshold;
  uint8_t tx_fifo_threshold;
  static const uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
  static const uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};

  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 800a4f8:	687b      	ldr	r3, [r7, #4]
 800a4fa:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800a4fc:	2b00      	cmp	r3, #0
 800a4fe:	d108      	bne.n	800a512 <UARTEx_SetNbDataToProcess+0x22>
  {
    huart->NbTxDataToProcess = 1U;
 800a500:	687b      	ldr	r3, [r7, #4]
 800a502:	2201      	movs	r2, #1
 800a504:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
    huart->NbRxDataToProcess = 1U;
 800a508:	687b      	ldr	r3, [r7, #4]
 800a50a:	2201      	movs	r2, #1
 800a50c:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
                               (uint16_t)denominator[tx_fifo_threshold];
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
                               (uint16_t)denominator[rx_fifo_threshold];
  }
}
 800a510:	e031      	b.n	800a576 <UARTEx_SetNbDataToProcess+0x86>
    rx_fifo_depth = RX_FIFO_DEPTH;
 800a512:	2310      	movs	r3, #16
 800a514:	73fb      	strb	r3, [r7, #15]
    tx_fifo_depth = TX_FIFO_DEPTH;
 800a516:	2310      	movs	r3, #16
 800a518:	73bb      	strb	r3, [r7, #14]
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
 800a51a:	687b      	ldr	r3, [r7, #4]
 800a51c:	681b      	ldr	r3, [r3, #0]
 800a51e:	689b      	ldr	r3, [r3, #8]
 800a520:	0e5b      	lsrs	r3, r3, #25
 800a522:	b2db      	uxtb	r3, r3
 800a524:	f003 0307 	and.w	r3, r3, #7
 800a528:	737b      	strb	r3, [r7, #13]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 800a52a:	687b      	ldr	r3, [r7, #4]
 800a52c:	681b      	ldr	r3, [r3, #0]
 800a52e:	689b      	ldr	r3, [r3, #8]
 800a530:	0f5b      	lsrs	r3, r3, #29
 800a532:	b2db      	uxtb	r3, r3
 800a534:	f003 0307 	and.w	r3, r3, #7
 800a538:	733b      	strb	r3, [r7, #12]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 800a53a:	7bbb      	ldrb	r3, [r7, #14]
 800a53c:	7b3a      	ldrb	r2, [r7, #12]
 800a53e:	4911      	ldr	r1, [pc, #68]	; (800a584 <UARTEx_SetNbDataToProcess+0x94>)
 800a540:	5c8a      	ldrb	r2, [r1, r2]
 800a542:	fb02 f303 	mul.w	r3, r2, r3
                               (uint16_t)denominator[tx_fifo_threshold];
 800a546:	7b3a      	ldrb	r2, [r7, #12]
 800a548:	490f      	ldr	r1, [pc, #60]	; (800a588 <UARTEx_SetNbDataToProcess+0x98>)
 800a54a:	5c8a      	ldrb	r2, [r1, r2]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 800a54c:	fb93 f3f2 	sdiv	r3, r3, r2
 800a550:	b29a      	uxth	r2, r3
 800a552:	687b      	ldr	r3, [r7, #4]
 800a554:	f8a3 206a 	strh.w	r2, [r3, #106]	; 0x6a
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 800a558:	7bfb      	ldrb	r3, [r7, #15]
 800a55a:	7b7a      	ldrb	r2, [r7, #13]
 800a55c:	4909      	ldr	r1, [pc, #36]	; (800a584 <UARTEx_SetNbDataToProcess+0x94>)
 800a55e:	5c8a      	ldrb	r2, [r1, r2]
 800a560:	fb02 f303 	mul.w	r3, r2, r3
                               (uint16_t)denominator[rx_fifo_threshold];
 800a564:	7b7a      	ldrb	r2, [r7, #13]
 800a566:	4908      	ldr	r1, [pc, #32]	; (800a588 <UARTEx_SetNbDataToProcess+0x98>)
 800a568:	5c8a      	ldrb	r2, [r1, r2]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 800a56a:	fb93 f3f2 	sdiv	r3, r3, r2
 800a56e:	b29a      	uxth	r2, r3
 800a570:	687b      	ldr	r3, [r7, #4]
 800a572:	f8a3 2068 	strh.w	r2, [r3, #104]	; 0x68
}
 800a576:	bf00      	nop
 800a578:	3714      	adds	r7, #20
 800a57a:	46bd      	mov	sp, r7
 800a57c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a580:	4770      	bx	lr
 800a582:	bf00      	nop
 800a584:	08022964 	.word	0x08022964
 800a588:	0802296c 	.word	0x0802296c

0800a58c <osKernelStart>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osKernelStart (void)
{
 800a58c:	b580      	push	{r7, lr}
 800a58e:	af00      	add	r7, sp, #0
  vTaskStartScheduler();
 800a590:	f001 f8c2 	bl	800b718 <vTaskStartScheduler>
  
  return osOK;
 800a594:	2300      	movs	r3, #0
}
 800a596:	4618      	mov	r0, r3
 800a598:	bd80      	pop	{r7, pc}

0800a59a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 800a59a:	b480      	push	{r7}
 800a59c:	b083      	sub	sp, #12
 800a59e:	af00      	add	r7, sp, #0
 800a5a0:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800a5a2:	687b      	ldr	r3, [r7, #4]
 800a5a4:	f103 0208 	add.w	r2, r3, #8
 800a5a8:	687b      	ldr	r3, [r7, #4]
 800a5aa:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 800a5ac:	687b      	ldr	r3, [r7, #4]
 800a5ae:	f04f 32ff 	mov.w	r2, #4294967295
 800a5b2:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800a5b4:	687b      	ldr	r3, [r7, #4]
 800a5b6:	f103 0208 	add.w	r2, r3, #8
 800a5ba:	687b      	ldr	r3, [r7, #4]
 800a5bc:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800a5be:	687b      	ldr	r3, [r7, #4]
 800a5c0:	f103 0208 	add.w	r2, r3, #8
 800a5c4:	687b      	ldr	r3, [r7, #4]
 800a5c6:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 800a5c8:	687b      	ldr	r3, [r7, #4]
 800a5ca:	2200      	movs	r2, #0
 800a5cc:	601a      	str	r2, [r3, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 800a5ce:	bf00      	nop
 800a5d0:	370c      	adds	r7, #12
 800a5d2:	46bd      	mov	sp, r7
 800a5d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a5d8:	4770      	bx	lr

0800a5da <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
 800a5da:	b480      	push	{r7}
 800a5dc:	b083      	sub	sp, #12
 800a5de:	af00      	add	r7, sp, #0
 800a5e0:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
 800a5e2:	687b      	ldr	r3, [r7, #4]
 800a5e4:	2200      	movs	r2, #0
 800a5e6:	611a      	str	r2, [r3, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 800a5e8:	bf00      	nop
 800a5ea:	370c      	adds	r7, #12
 800a5ec:	46bd      	mov	sp, r7
 800a5ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a5f2:	4770      	bx	lr

0800a5f4 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 800a5f4:	b480      	push	{r7}
 800a5f6:	b085      	sub	sp, #20
 800a5f8:	af00      	add	r7, sp, #0
 800a5fa:	6078      	str	r0, [r7, #4]
 800a5fc:	6039      	str	r1, [r7, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
 800a5fe:	687b      	ldr	r3, [r7, #4]
 800a600:	685b      	ldr	r3, [r3, #4]
 800a602:	60fb      	str	r3, [r7, #12]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 800a604:	683b      	ldr	r3, [r7, #0]
 800a606:	68fa      	ldr	r2, [r7, #12]
 800a608:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 800a60a:	68fb      	ldr	r3, [r7, #12]
 800a60c:	689a      	ldr	r2, [r3, #8]
 800a60e:	683b      	ldr	r3, [r7, #0]
 800a610:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 800a612:	68fb      	ldr	r3, [r7, #12]
 800a614:	689b      	ldr	r3, [r3, #8]
 800a616:	683a      	ldr	r2, [r7, #0]
 800a618:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
 800a61a:	68fb      	ldr	r3, [r7, #12]
 800a61c:	683a      	ldr	r2, [r7, #0]
 800a61e:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
 800a620:	683b      	ldr	r3, [r7, #0]
 800a622:	687a      	ldr	r2, [r7, #4]
 800a624:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 800a626:	687b      	ldr	r3, [r7, #4]
 800a628:	681b      	ldr	r3, [r3, #0]
 800a62a:	1c5a      	adds	r2, r3, #1
 800a62c:	687b      	ldr	r3, [r7, #4]
 800a62e:	601a      	str	r2, [r3, #0]
}
 800a630:	bf00      	nop
 800a632:	3714      	adds	r7, #20
 800a634:	46bd      	mov	sp, r7
 800a636:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a63a:	4770      	bx	lr

0800a63c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 800a63c:	b480      	push	{r7}
 800a63e:	b085      	sub	sp, #20
 800a640:	af00      	add	r7, sp, #0
 800a642:	6078      	str	r0, [r7, #4]
 800a644:	6039      	str	r1, [r7, #0]
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 800a646:	683b      	ldr	r3, [r7, #0]
 800a648:	681b      	ldr	r3, [r3, #0]
 800a64a:	60bb      	str	r3, [r7, #8]
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 800a64c:	68bb      	ldr	r3, [r7, #8]
 800a64e:	f1b3 3fff 	cmp.w	r3, #4294967295
 800a652:	d103      	bne.n	800a65c <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 800a654:	687b      	ldr	r3, [r7, #4]
 800a656:	691b      	ldr	r3, [r3, #16]
 800a658:	60fb      	str	r3, [r7, #12]
 800a65a:	e00c      	b.n	800a676 <vListInsert+0x3a>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 800a65c:	687b      	ldr	r3, [r7, #4]
 800a65e:	3308      	adds	r3, #8
 800a660:	60fb      	str	r3, [r7, #12]
 800a662:	e002      	b.n	800a66a <vListInsert+0x2e>
 800a664:	68fb      	ldr	r3, [r7, #12]
 800a666:	685b      	ldr	r3, [r3, #4]
 800a668:	60fb      	str	r3, [r7, #12]
 800a66a:	68fb      	ldr	r3, [r7, #12]
 800a66c:	685b      	ldr	r3, [r3, #4]
 800a66e:	681b      	ldr	r3, [r3, #0]
 800a670:	68ba      	ldr	r2, [r7, #8]
 800a672:	429a      	cmp	r2, r3
 800a674:	d2f6      	bcs.n	800a664 <vListInsert+0x28>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 800a676:	68fb      	ldr	r3, [r7, #12]
 800a678:	685a      	ldr	r2, [r3, #4]
 800a67a:	683b      	ldr	r3, [r7, #0]
 800a67c:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 800a67e:	683b      	ldr	r3, [r7, #0]
 800a680:	685b      	ldr	r3, [r3, #4]
 800a682:	683a      	ldr	r2, [r7, #0]
 800a684:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 800a686:	683b      	ldr	r3, [r7, #0]
 800a688:	68fa      	ldr	r2, [r7, #12]
 800a68a:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = pxNewListItem;
 800a68c:	68fb      	ldr	r3, [r7, #12]
 800a68e:	683a      	ldr	r2, [r7, #0]
 800a690:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
 800a692:	683b      	ldr	r3, [r7, #0]
 800a694:	687a      	ldr	r2, [r7, #4]
 800a696:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 800a698:	687b      	ldr	r3, [r7, #4]
 800a69a:	681b      	ldr	r3, [r3, #0]
 800a69c:	1c5a      	adds	r2, r3, #1
 800a69e:	687b      	ldr	r3, [r7, #4]
 800a6a0:	601a      	str	r2, [r3, #0]
}
 800a6a2:	bf00      	nop
 800a6a4:	3714      	adds	r7, #20
 800a6a6:	46bd      	mov	sp, r7
 800a6a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a6ac:	4770      	bx	lr

0800a6ae <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 800a6ae:	b480      	push	{r7}
 800a6b0:	b085      	sub	sp, #20
 800a6b2:	af00      	add	r7, sp, #0
 800a6b4:	6078      	str	r0, [r7, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
 800a6b6:	687b      	ldr	r3, [r7, #4]
 800a6b8:	691b      	ldr	r3, [r3, #16]
 800a6ba:	60fb      	str	r3, [r7, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 800a6bc:	687b      	ldr	r3, [r7, #4]
 800a6be:	685b      	ldr	r3, [r3, #4]
 800a6c0:	687a      	ldr	r2, [r7, #4]
 800a6c2:	6892      	ldr	r2, [r2, #8]
 800a6c4:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 800a6c6:	687b      	ldr	r3, [r7, #4]
 800a6c8:	689b      	ldr	r3, [r3, #8]
 800a6ca:	687a      	ldr	r2, [r7, #4]
 800a6cc:	6852      	ldr	r2, [r2, #4]
 800a6ce:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 800a6d0:	68fb      	ldr	r3, [r7, #12]
 800a6d2:	685b      	ldr	r3, [r3, #4]
 800a6d4:	687a      	ldr	r2, [r7, #4]
 800a6d6:	429a      	cmp	r2, r3
 800a6d8:	d103      	bne.n	800a6e2 <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 800a6da:	687b      	ldr	r3, [r7, #4]
 800a6dc:	689a      	ldr	r2, [r3, #8]
 800a6de:	68fb      	ldr	r3, [r7, #12]
 800a6e0:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
 800a6e2:	687b      	ldr	r3, [r7, #4]
 800a6e4:	2200      	movs	r2, #0
 800a6e6:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
 800a6e8:	68fb      	ldr	r3, [r7, #12]
 800a6ea:	681b      	ldr	r3, [r3, #0]
 800a6ec:	1e5a      	subs	r2, r3, #1
 800a6ee:	68fb      	ldr	r3, [r7, #12]
 800a6f0:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 800a6f2:	68fb      	ldr	r3, [r7, #12]
 800a6f4:	681b      	ldr	r3, [r3, #0]
}
 800a6f6:	4618      	mov	r0, r3
 800a6f8:	3714      	adds	r7, #20
 800a6fa:	46bd      	mov	sp, r7
 800a6fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a700:	4770      	bx	lr
	...

0800a704 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
 800a704:	b580      	push	{r7, lr}
 800a706:	b084      	sub	sp, #16
 800a708:	af00      	add	r7, sp, #0
 800a70a:	6078      	str	r0, [r7, #4]
 800a70c:	6039      	str	r1, [r7, #0]
Queue_t * const pxQueue = xQueue;
 800a70e:	687b      	ldr	r3, [r7, #4]
 800a710:	60fb      	str	r3, [r7, #12]

	configASSERT( pxQueue );
 800a712:	68fb      	ldr	r3, [r7, #12]
 800a714:	2b00      	cmp	r3, #0
 800a716:	d10a      	bne.n	800a72e <xQueueGenericReset+0x2a>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 800a718:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a71c:	f383 8811 	msr	BASEPRI, r3
 800a720:	f3bf 8f6f 	isb	sy
 800a724:	f3bf 8f4f 	dsb	sy
 800a728:	60bb      	str	r3, [r7, #8]
		"	msr basepri, %0											\n" \
		"	isb														\n" \
		"	dsb														\n" \
		:"=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);
}
 800a72a:	bf00      	nop
 800a72c:	e7fe      	b.n	800a72c <xQueueGenericReset+0x28>

	taskENTER_CRITICAL();
 800a72e:	f002 fb21 	bl	800cd74 <vPortEnterCritical>
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800a732:	68fb      	ldr	r3, [r7, #12]
 800a734:	681a      	ldr	r2, [r3, #0]
 800a736:	68fb      	ldr	r3, [r7, #12]
 800a738:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800a73a:	68f9      	ldr	r1, [r7, #12]
 800a73c:	6c09      	ldr	r1, [r1, #64]	; 0x40
 800a73e:	fb01 f303 	mul.w	r3, r1, r3
 800a742:	441a      	add	r2, r3
 800a744:	68fb      	ldr	r3, [r7, #12]
 800a746:	609a      	str	r2, [r3, #8]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 800a748:	68fb      	ldr	r3, [r7, #12]
 800a74a:	2200      	movs	r2, #0
 800a74c:	639a      	str	r2, [r3, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
 800a74e:	68fb      	ldr	r3, [r7, #12]
 800a750:	681a      	ldr	r2, [r3, #0]
 800a752:	68fb      	ldr	r3, [r7, #12]
 800a754:	605a      	str	r2, [r3, #4]
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800a756:	68fb      	ldr	r3, [r7, #12]
 800a758:	681a      	ldr	r2, [r3, #0]
 800a75a:	68fb      	ldr	r3, [r7, #12]
 800a75c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800a75e:	3b01      	subs	r3, #1
 800a760:	68f9      	ldr	r1, [r7, #12]
 800a762:	6c09      	ldr	r1, [r1, #64]	; 0x40
 800a764:	fb01 f303 	mul.w	r3, r1, r3
 800a768:	441a      	add	r2, r3
 800a76a:	68fb      	ldr	r3, [r7, #12]
 800a76c:	60da      	str	r2, [r3, #12]
		pxQueue->cRxLock = queueUNLOCKED;
 800a76e:	68fb      	ldr	r3, [r7, #12]
 800a770:	22ff      	movs	r2, #255	; 0xff
 800a772:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 800a776:	68fb      	ldr	r3, [r7, #12]
 800a778:	22ff      	movs	r2, #255	; 0xff
 800a77a:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

		if( xNewQueue == pdFALSE )
 800a77e:	683b      	ldr	r3, [r7, #0]
 800a780:	2b00      	cmp	r3, #0
 800a782:	d114      	bne.n	800a7ae <xQueueGenericReset+0xaa>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800a784:	68fb      	ldr	r3, [r7, #12]
 800a786:	691b      	ldr	r3, [r3, #16]
 800a788:	2b00      	cmp	r3, #0
 800a78a:	d01a      	beq.n	800a7c2 <xQueueGenericReset+0xbe>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800a78c:	68fb      	ldr	r3, [r7, #12]
 800a78e:	3310      	adds	r3, #16
 800a790:	4618      	mov	r0, r3
 800a792:	f001 fa3d 	bl	800bc10 <xTaskRemoveFromEventList>
 800a796:	4603      	mov	r3, r0
 800a798:	2b00      	cmp	r3, #0
 800a79a:	d012      	beq.n	800a7c2 <xQueueGenericReset+0xbe>
				{
					queueYIELD_IF_USING_PREEMPTION();
 800a79c:	4b0c      	ldr	r3, [pc, #48]	; (800a7d0 <xQueueGenericReset+0xcc>)
 800a79e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800a7a2:	601a      	str	r2, [r3, #0]
 800a7a4:	f3bf 8f4f 	dsb	sy
 800a7a8:	f3bf 8f6f 	isb	sy
 800a7ac:	e009      	b.n	800a7c2 <xQueueGenericReset+0xbe>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 800a7ae:	68fb      	ldr	r3, [r7, #12]
 800a7b0:	3310      	adds	r3, #16
 800a7b2:	4618      	mov	r0, r3
 800a7b4:	f7ff fef1 	bl	800a59a <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 800a7b8:	68fb      	ldr	r3, [r7, #12]
 800a7ba:	3324      	adds	r3, #36	; 0x24
 800a7bc:	4618      	mov	r0, r3
 800a7be:	f7ff feec 	bl	800a59a <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
 800a7c2:	f002 fb07 	bl	800cdd4 <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
 800a7c6:	2301      	movs	r3, #1
}
 800a7c8:	4618      	mov	r0, r3
 800a7ca:	3710      	adds	r7, #16
 800a7cc:	46bd      	mov	sp, r7
 800a7ce:	bd80      	pop	{r7, pc}
 800a7d0:	e000ed04 	.word	0xe000ed04

0800a7d4 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
 800a7d4:	b580      	push	{r7, lr}
 800a7d6:	b08a      	sub	sp, #40	; 0x28
 800a7d8:	af02      	add	r7, sp, #8
 800a7da:	60f8      	str	r0, [r7, #12]
 800a7dc:	60b9      	str	r1, [r7, #8]
 800a7de:	4613      	mov	r3, r2
 800a7e0:	71fb      	strb	r3, [r7, #7]
	Queue_t *pxNewQueue;
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 800a7e2:	68fb      	ldr	r3, [r7, #12]
 800a7e4:	2b00      	cmp	r3, #0
 800a7e6:	d10a      	bne.n	800a7fe <xQueueGenericCreate+0x2a>
	__asm volatile
 800a7e8:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a7ec:	f383 8811 	msr	BASEPRI, r3
 800a7f0:	f3bf 8f6f 	isb	sy
 800a7f4:	f3bf 8f4f 	dsb	sy
 800a7f8:	613b      	str	r3, [r7, #16]
}
 800a7fa:	bf00      	nop
 800a7fc:	e7fe      	b.n	800a7fc <xQueueGenericCreate+0x28>

		/* Allocate enough space to hold the maximum number of items that
		can be in the queue at any time.  It is valid for uxItemSize to be
		zero in the case the queue is used as a semaphore. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800a7fe:	68fb      	ldr	r3, [r7, #12]
 800a800:	68ba      	ldr	r2, [r7, #8]
 800a802:	fb02 f303 	mul.w	r3, r2, r3
 800a806:	61fb      	str	r3, [r7, #28]
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 800a808:	69fb      	ldr	r3, [r7, #28]
 800a80a:	3348      	adds	r3, #72	; 0x48
 800a80c:	4618      	mov	r0, r3
 800a80e:	f002 fbd3 	bl	800cfb8 <pvPortMalloc>
 800a812:	61b8      	str	r0, [r7, #24]

		if( pxNewQueue != NULL )
 800a814:	69bb      	ldr	r3, [r7, #24]
 800a816:	2b00      	cmp	r3, #0
 800a818:	d00d      	beq.n	800a836 <xQueueGenericCreate+0x62>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
 800a81a:	69bb      	ldr	r3, [r7, #24]
 800a81c:	617b      	str	r3, [r7, #20]
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800a81e:	697b      	ldr	r3, [r7, #20]
 800a820:	3348      	adds	r3, #72	; 0x48
 800a822:	617b      	str	r3, [r7, #20]
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 800a824:	79fa      	ldrb	r2, [r7, #7]
 800a826:	69bb      	ldr	r3, [r7, #24]
 800a828:	9300      	str	r3, [sp, #0]
 800a82a:	4613      	mov	r3, r2
 800a82c:	697a      	ldr	r2, [r7, #20]
 800a82e:	68b9      	ldr	r1, [r7, #8]
 800a830:	68f8      	ldr	r0, [r7, #12]
 800a832:	f000 f805 	bl	800a840 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
 800a836:	69bb      	ldr	r3, [r7, #24]
	}
 800a838:	4618      	mov	r0, r3
 800a83a:	3720      	adds	r7, #32
 800a83c:	46bd      	mov	sp, r7
 800a83e:	bd80      	pop	{r7, pc}

0800a840 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
 800a840:	b580      	push	{r7, lr}
 800a842:	b084      	sub	sp, #16
 800a844:	af00      	add	r7, sp, #0
 800a846:	60f8      	str	r0, [r7, #12]
 800a848:	60b9      	str	r1, [r7, #8]
 800a84a:	607a      	str	r2, [r7, #4]
 800a84c:	70fb      	strb	r3, [r7, #3]
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
 800a84e:	68bb      	ldr	r3, [r7, #8]
 800a850:	2b00      	cmp	r3, #0
 800a852:	d103      	bne.n	800a85c <prvInitialiseNewQueue+0x1c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 800a854:	69bb      	ldr	r3, [r7, #24]
 800a856:	69ba      	ldr	r2, [r7, #24]
 800a858:	601a      	str	r2, [r3, #0]
 800a85a:	e002      	b.n	800a862 <prvInitialiseNewQueue+0x22>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 800a85c:	69bb      	ldr	r3, [r7, #24]
 800a85e:	687a      	ldr	r2, [r7, #4]
 800a860:	601a      	str	r2, [r3, #0]
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
 800a862:	69bb      	ldr	r3, [r7, #24]
 800a864:	68fa      	ldr	r2, [r7, #12]
 800a866:	63da      	str	r2, [r3, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
 800a868:	69bb      	ldr	r3, [r7, #24]
 800a86a:	68ba      	ldr	r2, [r7, #8]
 800a86c:	641a      	str	r2, [r3, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 800a86e:	2101      	movs	r1, #1
 800a870:	69b8      	ldr	r0, [r7, #24]
 800a872:	f7ff ff47 	bl	800a704 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
 800a876:	bf00      	nop
 800a878:	3710      	adds	r7, #16
 800a87a:	46bd      	mov	sp, r7
 800a87c:	bd80      	pop	{r7, pc}

0800a87e <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
 800a87e:	b580      	push	{r7, lr}
 800a880:	b082      	sub	sp, #8
 800a882:	af00      	add	r7, sp, #0
 800a884:	6078      	str	r0, [r7, #4]
		if( pxNewQueue != NULL )
 800a886:	687b      	ldr	r3, [r7, #4]
 800a888:	2b00      	cmp	r3, #0
 800a88a:	d00e      	beq.n	800a8aa <prvInitialiseMutex+0x2c>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 800a88c:	687b      	ldr	r3, [r7, #4]
 800a88e:	2200      	movs	r2, #0
 800a890:	609a      	str	r2, [r3, #8]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 800a892:	687b      	ldr	r3, [r7, #4]
 800a894:	2200      	movs	r2, #0
 800a896:	601a      	str	r2, [r3, #0]

			/* In case this is a recursive mutex. */
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 800a898:	687b      	ldr	r3, [r7, #4]
 800a89a:	2200      	movs	r2, #0
 800a89c:	60da      	str	r2, [r3, #12]

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 800a89e:	2300      	movs	r3, #0
 800a8a0:	2200      	movs	r2, #0
 800a8a2:	2100      	movs	r1, #0
 800a8a4:	6878      	ldr	r0, [r7, #4]
 800a8a6:	f000 f81d 	bl	800a8e4 <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
 800a8aa:	bf00      	nop
 800a8ac:	3708      	adds	r7, #8
 800a8ae:	46bd      	mov	sp, r7
 800a8b0:	bd80      	pop	{r7, pc}

0800a8b2 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
 800a8b2:	b580      	push	{r7, lr}
 800a8b4:	b086      	sub	sp, #24
 800a8b6:	af00      	add	r7, sp, #0
 800a8b8:	4603      	mov	r3, r0
 800a8ba:	71fb      	strb	r3, [r7, #7]
	QueueHandle_t xNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
 800a8bc:	2301      	movs	r3, #1
 800a8be:	617b      	str	r3, [r7, #20]
 800a8c0:	2300      	movs	r3, #0
 800a8c2:	613b      	str	r3, [r7, #16]

		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
 800a8c4:	79fb      	ldrb	r3, [r7, #7]
 800a8c6:	461a      	mov	r2, r3
 800a8c8:	6939      	ldr	r1, [r7, #16]
 800a8ca:	6978      	ldr	r0, [r7, #20]
 800a8cc:	f7ff ff82 	bl	800a7d4 <xQueueGenericCreate>
 800a8d0:	60f8      	str	r0, [r7, #12]
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
 800a8d2:	68f8      	ldr	r0, [r7, #12]
 800a8d4:	f7ff ffd3 	bl	800a87e <prvInitialiseMutex>

		return xNewQueue;
 800a8d8:	68fb      	ldr	r3, [r7, #12]
	}
 800a8da:	4618      	mov	r0, r3
 800a8dc:	3718      	adds	r7, #24
 800a8de:	46bd      	mov	sp, r7
 800a8e0:	bd80      	pop	{r7, pc}
	...

0800a8e4 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
 800a8e4:	b580      	push	{r7, lr}
 800a8e6:	b08e      	sub	sp, #56	; 0x38
 800a8e8:	af00      	add	r7, sp, #0
 800a8ea:	60f8      	str	r0, [r7, #12]
 800a8ec:	60b9      	str	r1, [r7, #8]
 800a8ee:	607a      	str	r2, [r7, #4]
 800a8f0:	603b      	str	r3, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 800a8f2:	2300      	movs	r3, #0
 800a8f4:	637b      	str	r3, [r7, #52]	; 0x34
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
 800a8f6:	68fb      	ldr	r3, [r7, #12]
 800a8f8:	633b      	str	r3, [r7, #48]	; 0x30

	configASSERT( pxQueue );
 800a8fa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a8fc:	2b00      	cmp	r3, #0
 800a8fe:	d10a      	bne.n	800a916 <xQueueGenericSend+0x32>
	__asm volatile
 800a900:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a904:	f383 8811 	msr	BASEPRI, r3
 800a908:	f3bf 8f6f 	isb	sy
 800a90c:	f3bf 8f4f 	dsb	sy
 800a910:	62bb      	str	r3, [r7, #40]	; 0x28
}
 800a912:	bf00      	nop
 800a914:	e7fe      	b.n	800a914 <xQueueGenericSend+0x30>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800a916:	68bb      	ldr	r3, [r7, #8]
 800a918:	2b00      	cmp	r3, #0
 800a91a:	d103      	bne.n	800a924 <xQueueGenericSend+0x40>
 800a91c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a91e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800a920:	2b00      	cmp	r3, #0
 800a922:	d101      	bne.n	800a928 <xQueueGenericSend+0x44>
 800a924:	2301      	movs	r3, #1
 800a926:	e000      	b.n	800a92a <xQueueGenericSend+0x46>
 800a928:	2300      	movs	r3, #0
 800a92a:	2b00      	cmp	r3, #0
 800a92c:	d10a      	bne.n	800a944 <xQueueGenericSend+0x60>
	__asm volatile
 800a92e:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a932:	f383 8811 	msr	BASEPRI, r3
 800a936:	f3bf 8f6f 	isb	sy
 800a93a:	f3bf 8f4f 	dsb	sy
 800a93e:	627b      	str	r3, [r7, #36]	; 0x24
}
 800a940:	bf00      	nop
 800a942:	e7fe      	b.n	800a942 <xQueueGenericSend+0x5e>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 800a944:	683b      	ldr	r3, [r7, #0]
 800a946:	2b02      	cmp	r3, #2
 800a948:	d103      	bne.n	800a952 <xQueueGenericSend+0x6e>
 800a94a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a94c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800a94e:	2b01      	cmp	r3, #1
 800a950:	d101      	bne.n	800a956 <xQueueGenericSend+0x72>
 800a952:	2301      	movs	r3, #1
 800a954:	e000      	b.n	800a958 <xQueueGenericSend+0x74>
 800a956:	2300      	movs	r3, #0
 800a958:	2b00      	cmp	r3, #0
 800a95a:	d10a      	bne.n	800a972 <xQueueGenericSend+0x8e>
	__asm volatile
 800a95c:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a960:	f383 8811 	msr	BASEPRI, r3
 800a964:	f3bf 8f6f 	isb	sy
 800a968:	f3bf 8f4f 	dsb	sy
 800a96c:	623b      	str	r3, [r7, #32]
}
 800a96e:	bf00      	nop
 800a970:	e7fe      	b.n	800a970 <xQueueGenericSend+0x8c>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 800a972:	f001 faff 	bl	800bf74 <xTaskGetSchedulerState>
 800a976:	4603      	mov	r3, r0
 800a978:	2b00      	cmp	r3, #0
 800a97a:	d102      	bne.n	800a982 <xQueueGenericSend+0x9e>
 800a97c:	687b      	ldr	r3, [r7, #4]
 800a97e:	2b00      	cmp	r3, #0
 800a980:	d101      	bne.n	800a986 <xQueueGenericSend+0xa2>
 800a982:	2301      	movs	r3, #1
 800a984:	e000      	b.n	800a988 <xQueueGenericSend+0xa4>
 800a986:	2300      	movs	r3, #0
 800a988:	2b00      	cmp	r3, #0
 800a98a:	d10a      	bne.n	800a9a2 <xQueueGenericSend+0xbe>
	__asm volatile
 800a98c:	f04f 0350 	mov.w	r3, #80	; 0x50
 800a990:	f383 8811 	msr	BASEPRI, r3
 800a994:	f3bf 8f6f 	isb	sy
 800a998:	f3bf 8f4f 	dsb	sy
 800a99c:	61fb      	str	r3, [r7, #28]
}
 800a99e:	bf00      	nop
 800a9a0:	e7fe      	b.n	800a9a0 <xQueueGenericSend+0xbc>
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 800a9a2:	f002 f9e7 	bl	800cd74 <vPortEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800a9a6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a9a8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800a9aa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a9ac:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800a9ae:	429a      	cmp	r2, r3
 800a9b0:	d302      	bcc.n	800a9b8 <xQueueGenericSend+0xd4>
 800a9b2:	683b      	ldr	r3, [r7, #0]
 800a9b4:	2b02      	cmp	r3, #2
 800a9b6:	d129      	bne.n	800aa0c <xQueueGenericSend+0x128>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800a9b8:	683a      	ldr	r2, [r7, #0]
 800a9ba:	68b9      	ldr	r1, [r7, #8]
 800a9bc:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800a9be:	f000 fbbb 	bl	800b138 <prvCopyDataToQueue>
 800a9c2:	62f8      	str	r0, [r7, #44]	; 0x2c

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800a9c4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a9c6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a9c8:	2b00      	cmp	r3, #0
 800a9ca:	d010      	beq.n	800a9ee <xQueueGenericSend+0x10a>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800a9cc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800a9ce:	3324      	adds	r3, #36	; 0x24
 800a9d0:	4618      	mov	r0, r3
 800a9d2:	f001 f91d 	bl	800bc10 <xTaskRemoveFromEventList>
 800a9d6:	4603      	mov	r3, r0
 800a9d8:	2b00      	cmp	r3, #0
 800a9da:	d013      	beq.n	800aa04 <xQueueGenericSend+0x120>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
 800a9dc:	4b3f      	ldr	r3, [pc, #252]	; (800aadc <xQueueGenericSend+0x1f8>)
 800a9de:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800a9e2:	601a      	str	r2, [r3, #0]
 800a9e4:	f3bf 8f4f 	dsb	sy
 800a9e8:	f3bf 8f6f 	isb	sy
 800a9ec:	e00a      	b.n	800aa04 <xQueueGenericSend+0x120>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
 800a9ee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800a9f0:	2b00      	cmp	r3, #0
 800a9f2:	d007      	beq.n	800aa04 <xQueueGenericSend+0x120>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
 800a9f4:	4b39      	ldr	r3, [pc, #228]	; (800aadc <xQueueGenericSend+0x1f8>)
 800a9f6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800a9fa:	601a      	str	r2, [r3, #0]
 800a9fc:	f3bf 8f4f 	dsb	sy
 800aa00:	f3bf 8f6f 	isb	sy
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
 800aa04:	f002 f9e6 	bl	800cdd4 <vPortExitCritical>
				return pdPASS;
 800aa08:	2301      	movs	r3, #1
 800aa0a:	e063      	b.n	800aad4 <xQueueGenericSend+0x1f0>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 800aa0c:	687b      	ldr	r3, [r7, #4]
 800aa0e:	2b00      	cmp	r3, #0
 800aa10:	d103      	bne.n	800aa1a <xQueueGenericSend+0x136>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 800aa12:	f002 f9df 	bl	800cdd4 <vPortExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
 800aa16:	2300      	movs	r3, #0
 800aa18:	e05c      	b.n	800aad4 <xQueueGenericSend+0x1f0>
				}
				else if( xEntryTimeSet == pdFALSE )
 800aa1a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800aa1c:	2b00      	cmp	r3, #0
 800aa1e:	d106      	bne.n	800aa2e <xQueueGenericSend+0x14a>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
 800aa20:	f107 0314 	add.w	r3, r7, #20
 800aa24:	4618      	mov	r0, r3
 800aa26:	f001 f955 	bl	800bcd4 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 800aa2a:	2301      	movs	r3, #1
 800aa2c:	637b      	str	r3, [r7, #52]	; 0x34
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 800aa2e:	f002 f9d1 	bl	800cdd4 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 800aa32:	f000 fec9 	bl	800b7c8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800aa36:	f002 f99d 	bl	800cd74 <vPortEnterCritical>
 800aa3a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800aa3c:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 800aa40:	b25b      	sxtb	r3, r3
 800aa42:	f1b3 3fff 	cmp.w	r3, #4294967295
 800aa46:	d103      	bne.n	800aa50 <xQueueGenericSend+0x16c>
 800aa48:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800aa4a:	2200      	movs	r2, #0
 800aa4c:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 800aa50:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800aa52:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 800aa56:	b25b      	sxtb	r3, r3
 800aa58:	f1b3 3fff 	cmp.w	r3, #4294967295
 800aa5c:	d103      	bne.n	800aa66 <xQueueGenericSend+0x182>
 800aa5e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800aa60:	2200      	movs	r2, #0
 800aa62:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 800aa66:	f002 f9b5 	bl	800cdd4 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800aa6a:	1d3a      	adds	r2, r7, #4
 800aa6c:	f107 0314 	add.w	r3, r7, #20
 800aa70:	4611      	mov	r1, r2
 800aa72:	4618      	mov	r0, r3
 800aa74:	f001 f944 	bl	800bd00 <xTaskCheckForTimeOut>
 800aa78:	4603      	mov	r3, r0
 800aa7a:	2b00      	cmp	r3, #0
 800aa7c:	d124      	bne.n	800aac8 <xQueueGenericSend+0x1e4>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 800aa7e:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800aa80:	f000 fc52 	bl	800b328 <prvIsQueueFull>
 800aa84:	4603      	mov	r3, r0
 800aa86:	2b00      	cmp	r3, #0
 800aa88:	d018      	beq.n	800aabc <xQueueGenericSend+0x1d8>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 800aa8a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800aa8c:	3310      	adds	r3, #16
 800aa8e:	687a      	ldr	r2, [r7, #4]
 800aa90:	4611      	mov	r1, r2
 800aa92:	4618      	mov	r0, r3
 800aa94:	f001 f86c 	bl	800bb70 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
 800aa98:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800aa9a:	f000 fbdd 	bl	800b258 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
 800aa9e:	f000 fea1 	bl	800b7e4 <xTaskResumeAll>
 800aaa2:	4603      	mov	r3, r0
 800aaa4:	2b00      	cmp	r3, #0
 800aaa6:	f47f af7c 	bne.w	800a9a2 <xQueueGenericSend+0xbe>
				{
					portYIELD_WITHIN_API();
 800aaaa:	4b0c      	ldr	r3, [pc, #48]	; (800aadc <xQueueGenericSend+0x1f8>)
 800aaac:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800aab0:	601a      	str	r2, [r3, #0]
 800aab2:	f3bf 8f4f 	dsb	sy
 800aab6:	f3bf 8f6f 	isb	sy
 800aaba:	e772      	b.n	800a9a2 <xQueueGenericSend+0xbe>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 800aabc:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800aabe:	f000 fbcb 	bl	800b258 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 800aac2:	f000 fe8f 	bl	800b7e4 <xTaskResumeAll>
 800aac6:	e76c      	b.n	800a9a2 <xQueueGenericSend+0xbe>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
 800aac8:	6b38      	ldr	r0, [r7, #48]	; 0x30
 800aaca:	f000 fbc5 	bl	800b258 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 800aace:	f000 fe89 	bl	800b7e4 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
 800aad2:	2300      	movs	r3, #0
		}
	} /*lint -restore */
}
 800aad4:	4618      	mov	r0, r3
 800aad6:	3738      	adds	r7, #56	; 0x38
 800aad8:	46bd      	mov	sp, r7
 800aada:	bd80      	pop	{r7, pc}
 800aadc:	e000ed04 	.word	0xe000ed04

0800aae0 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
 800aae0:	b580      	push	{r7, lr}
 800aae2:	b090      	sub	sp, #64	; 0x40
 800aae4:	af00      	add	r7, sp, #0
 800aae6:	60f8      	str	r0, [r7, #12]
 800aae8:	60b9      	str	r1, [r7, #8]
 800aaea:	607a      	str	r2, [r7, #4]
 800aaec:	603b      	str	r3, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
 800aaee:	68fb      	ldr	r3, [r7, #12]
 800aaf0:	63bb      	str	r3, [r7, #56]	; 0x38

	configASSERT( pxQueue );
 800aaf2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800aaf4:	2b00      	cmp	r3, #0
 800aaf6:	d10a      	bne.n	800ab0e <xQueueGenericSendFromISR+0x2e>
	__asm volatile
 800aaf8:	f04f 0350 	mov.w	r3, #80	; 0x50
 800aafc:	f383 8811 	msr	BASEPRI, r3
 800ab00:	f3bf 8f6f 	isb	sy
 800ab04:	f3bf 8f4f 	dsb	sy
 800ab08:	62bb      	str	r3, [r7, #40]	; 0x28
}
 800ab0a:	bf00      	nop
 800ab0c:	e7fe      	b.n	800ab0c <xQueueGenericSendFromISR+0x2c>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800ab0e:	68bb      	ldr	r3, [r7, #8]
 800ab10:	2b00      	cmp	r3, #0
 800ab12:	d103      	bne.n	800ab1c <xQueueGenericSendFromISR+0x3c>
 800ab14:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ab16:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800ab18:	2b00      	cmp	r3, #0
 800ab1a:	d101      	bne.n	800ab20 <xQueueGenericSendFromISR+0x40>
 800ab1c:	2301      	movs	r3, #1
 800ab1e:	e000      	b.n	800ab22 <xQueueGenericSendFromISR+0x42>
 800ab20:	2300      	movs	r3, #0
 800ab22:	2b00      	cmp	r3, #0
 800ab24:	d10a      	bne.n	800ab3c <xQueueGenericSendFromISR+0x5c>
	__asm volatile
 800ab26:	f04f 0350 	mov.w	r3, #80	; 0x50
 800ab2a:	f383 8811 	msr	BASEPRI, r3
 800ab2e:	f3bf 8f6f 	isb	sy
 800ab32:	f3bf 8f4f 	dsb	sy
 800ab36:	627b      	str	r3, [r7, #36]	; 0x24
}
 800ab38:	bf00      	nop
 800ab3a:	e7fe      	b.n	800ab3a <xQueueGenericSendFromISR+0x5a>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 800ab3c:	683b      	ldr	r3, [r7, #0]
 800ab3e:	2b02      	cmp	r3, #2
 800ab40:	d103      	bne.n	800ab4a <xQueueGenericSendFromISR+0x6a>
 800ab42:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ab44:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800ab46:	2b01      	cmp	r3, #1
 800ab48:	d101      	bne.n	800ab4e <xQueueGenericSendFromISR+0x6e>
 800ab4a:	2301      	movs	r3, #1
 800ab4c:	e000      	b.n	800ab50 <xQueueGenericSendFromISR+0x70>
 800ab4e:	2300      	movs	r3, #0
 800ab50:	2b00      	cmp	r3, #0
 800ab52:	d10a      	bne.n	800ab6a <xQueueGenericSendFromISR+0x8a>
	__asm volatile
 800ab54:	f04f 0350 	mov.w	r3, #80	; 0x50
 800ab58:	f383 8811 	msr	BASEPRI, r3
 800ab5c:	f3bf 8f6f 	isb	sy
 800ab60:	f3bf 8f4f 	dsb	sy
 800ab64:	623b      	str	r3, [r7, #32]
}
 800ab66:	bf00      	nop
 800ab68:	e7fe      	b.n	800ab68 <xQueueGenericSendFromISR+0x88>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800ab6a:	f002 f9e5 	bl	800cf38 <vPortValidateInterruptPriority>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
 800ab6e:	f3ef 8211 	mrs	r2, BASEPRI
 800ab72:	f04f 0350 	mov.w	r3, #80	; 0x50
 800ab76:	f383 8811 	msr	BASEPRI, r3
 800ab7a:	f3bf 8f6f 	isb	sy
 800ab7e:	f3bf 8f4f 	dsb	sy
 800ab82:	61fa      	str	r2, [r7, #28]
 800ab84:	61bb      	str	r3, [r7, #24]
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
 800ab86:	69fb      	ldr	r3, [r7, #28]
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800ab88:	637b      	str	r3, [r7, #52]	; 0x34
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800ab8a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ab8c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800ab8e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ab90:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800ab92:	429a      	cmp	r2, r3
 800ab94:	d302      	bcc.n	800ab9c <xQueueGenericSendFromISR+0xbc>
 800ab96:	683b      	ldr	r3, [r7, #0]
 800ab98:	2b02      	cmp	r3, #2
 800ab9a:	d12f      	bne.n	800abfc <xQueueGenericSendFromISR+0x11c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
 800ab9c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800ab9e:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 800aba2:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 800aba6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800aba8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800abaa:	62fb      	str	r3, [r7, #44]	; 0x2c
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800abac:	683a      	ldr	r2, [r7, #0]
 800abae:	68b9      	ldr	r1, [r7, #8]
 800abb0:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 800abb2:	f000 fac1 	bl	800b138 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
 800abb6:	f997 3033 	ldrsb.w	r3, [r7, #51]	; 0x33
 800abba:	f1b3 3fff 	cmp.w	r3, #4294967295
 800abbe:	d112      	bne.n	800abe6 <xQueueGenericSendFromISR+0x106>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800abc0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800abc2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800abc4:	2b00      	cmp	r3, #0
 800abc6:	d016      	beq.n	800abf6 <xQueueGenericSendFromISR+0x116>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800abc8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800abca:	3324      	adds	r3, #36	; 0x24
 800abcc:	4618      	mov	r0, r3
 800abce:	f001 f81f 	bl	800bc10 <xTaskRemoveFromEventList>
 800abd2:	4603      	mov	r3, r0
 800abd4:	2b00      	cmp	r3, #0
 800abd6:	d00e      	beq.n	800abf6 <xQueueGenericSendFromISR+0x116>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 800abd8:	687b      	ldr	r3, [r7, #4]
 800abda:	2b00      	cmp	r3, #0
 800abdc:	d00b      	beq.n	800abf6 <xQueueGenericSendFromISR+0x116>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 800abde:	687b      	ldr	r3, [r7, #4]
 800abe0:	2201      	movs	r2, #1
 800abe2:	601a      	str	r2, [r3, #0]
 800abe4:	e007      	b.n	800abf6 <xQueueGenericSendFromISR+0x116>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 800abe6:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 800abea:	3301      	adds	r3, #1
 800abec:	b2db      	uxtb	r3, r3
 800abee:	b25a      	sxtb	r2, r3
 800abf0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800abf2:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
			}

			xReturn = pdPASS;
 800abf6:	2301      	movs	r3, #1
 800abf8:	63fb      	str	r3, [r7, #60]	; 0x3c
		{
 800abfa:	e001      	b.n	800ac00 <xQueueGenericSendFromISR+0x120>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 800abfc:	2300      	movs	r3, #0
 800abfe:	63fb      	str	r3, [r7, #60]	; 0x3c
 800ac00:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800ac02:	617b      	str	r3, [r7, #20]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 800ac04:	697b      	ldr	r3, [r7, #20]
 800ac06:	f383 8811 	msr	BASEPRI, r3
	(
		"	msr basepri, %0	" :: "r" ( ulNewMaskValue ) : "memory"
	);
}
 800ac0a:	bf00      	nop
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 800ac0c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
}
 800ac0e:	4618      	mov	r0, r3
 800ac10:	3740      	adds	r7, #64	; 0x40
 800ac12:	46bd      	mov	sp, r7
 800ac14:	bd80      	pop	{r7, pc}

0800ac16 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
 800ac16:	b580      	push	{r7, lr}
 800ac18:	b08e      	sub	sp, #56	; 0x38
 800ac1a:	af00      	add	r7, sp, #0
 800ac1c:	6078      	str	r0, [r7, #4]
 800ac1e:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
 800ac20:	687b      	ldr	r3, [r7, #4]
 800ac22:	633b      	str	r3, [r7, #48]	; 0x30
	item size is 0.  Don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */

	configASSERT( pxQueue );
 800ac24:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ac26:	2b00      	cmp	r3, #0
 800ac28:	d10a      	bne.n	800ac40 <xQueueGiveFromISR+0x2a>
	__asm volatile
 800ac2a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800ac2e:	f383 8811 	msr	BASEPRI, r3
 800ac32:	f3bf 8f6f 	isb	sy
 800ac36:	f3bf 8f4f 	dsb	sy
 800ac3a:	623b      	str	r3, [r7, #32]
}
 800ac3c:	bf00      	nop
 800ac3e:	e7fe      	b.n	800ac3e <xQueueGiveFromISR+0x28>

	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
	if the item size is not 0. */
	configASSERT( pxQueue->uxItemSize == 0 );
 800ac40:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ac42:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800ac44:	2b00      	cmp	r3, #0
 800ac46:	d00a      	beq.n	800ac5e <xQueueGiveFromISR+0x48>
	__asm volatile
 800ac48:	f04f 0350 	mov.w	r3, #80	; 0x50
 800ac4c:	f383 8811 	msr	BASEPRI, r3
 800ac50:	f3bf 8f6f 	isb	sy
 800ac54:	f3bf 8f4f 	dsb	sy
 800ac58:	61fb      	str	r3, [r7, #28]
}
 800ac5a:	bf00      	nop
 800ac5c:	e7fe      	b.n	800ac5c <xQueueGiveFromISR+0x46>

	/* Normally a mutex would not be given from an interrupt, especially if
	there is a mutex holder, as priority inheritance makes no sense for an
	interrupts, only tasks. */
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
 800ac5e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ac60:	681b      	ldr	r3, [r3, #0]
 800ac62:	2b00      	cmp	r3, #0
 800ac64:	d103      	bne.n	800ac6e <xQueueGiveFromISR+0x58>
 800ac66:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ac68:	689b      	ldr	r3, [r3, #8]
 800ac6a:	2b00      	cmp	r3, #0
 800ac6c:	d101      	bne.n	800ac72 <xQueueGiveFromISR+0x5c>
 800ac6e:	2301      	movs	r3, #1
 800ac70:	e000      	b.n	800ac74 <xQueueGiveFromISR+0x5e>
 800ac72:	2300      	movs	r3, #0
 800ac74:	2b00      	cmp	r3, #0
 800ac76:	d10a      	bne.n	800ac8e <xQueueGiveFromISR+0x78>
	__asm volatile
 800ac78:	f04f 0350 	mov.w	r3, #80	; 0x50
 800ac7c:	f383 8811 	msr	BASEPRI, r3
 800ac80:	f3bf 8f6f 	isb	sy
 800ac84:	f3bf 8f4f 	dsb	sy
 800ac88:	61bb      	str	r3, [r7, #24]
}
 800ac8a:	bf00      	nop
 800ac8c:	e7fe      	b.n	800ac8c <xQueueGiveFromISR+0x76>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800ac8e:	f002 f953 	bl	800cf38 <vPortValidateInterruptPriority>
	__asm volatile
 800ac92:	f3ef 8211 	mrs	r2, BASEPRI
 800ac96:	f04f 0350 	mov.w	r3, #80	; 0x50
 800ac9a:	f383 8811 	msr	BASEPRI, r3
 800ac9e:	f3bf 8f6f 	isb	sy
 800aca2:	f3bf 8f4f 	dsb	sy
 800aca6:	617a      	str	r2, [r7, #20]
 800aca8:	613b      	str	r3, [r7, #16]
	return ulOriginalBASEPRI;
 800acaa:	697b      	ldr	r3, [r7, #20]

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800acac:	62fb      	str	r3, [r7, #44]	; 0x2c
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800acae:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800acb0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800acb2:	62bb      	str	r3, [r7, #40]	; 0x28

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
 800acb4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800acb6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800acb8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800acba:	429a      	cmp	r2, r3
 800acbc:	d22b      	bcs.n	800ad16 <xQueueGiveFromISR+0x100>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
 800acbe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800acc0:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 800acc4:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 800acc8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800acca:	1c5a      	adds	r2, r3, #1
 800accc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800acce:	639a      	str	r2, [r3, #56]	; 0x38

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
 800acd0:	f997 3027 	ldrsb.w	r3, [r7, #39]	; 0x27
 800acd4:	f1b3 3fff 	cmp.w	r3, #4294967295
 800acd8:	d112      	bne.n	800ad00 <xQueueGiveFromISR+0xea>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800acda:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800acdc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800acde:	2b00      	cmp	r3, #0
 800ace0:	d016      	beq.n	800ad10 <xQueueGiveFromISR+0xfa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800ace2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ace4:	3324      	adds	r3, #36	; 0x24
 800ace6:	4618      	mov	r0, r3
 800ace8:	f000 ff92 	bl	800bc10 <xTaskRemoveFromEventList>
 800acec:	4603      	mov	r3, r0
 800acee:	2b00      	cmp	r3, #0
 800acf0:	d00e      	beq.n	800ad10 <xQueueGiveFromISR+0xfa>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 800acf2:	683b      	ldr	r3, [r7, #0]
 800acf4:	2b00      	cmp	r3, #0
 800acf6:	d00b      	beq.n	800ad10 <xQueueGiveFromISR+0xfa>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 800acf8:	683b      	ldr	r3, [r7, #0]
 800acfa:	2201      	movs	r2, #1
 800acfc:	601a      	str	r2, [r3, #0]
 800acfe:	e007      	b.n	800ad10 <xQueueGiveFromISR+0xfa>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 800ad00:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800ad04:	3301      	adds	r3, #1
 800ad06:	b2db      	uxtb	r3, r3
 800ad08:	b25a      	sxtb	r2, r3
 800ad0a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800ad0c:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
			}

			xReturn = pdPASS;
 800ad10:	2301      	movs	r3, #1
 800ad12:	637b      	str	r3, [r7, #52]	; 0x34
 800ad14:	e001      	b.n	800ad1a <xQueueGiveFromISR+0x104>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 800ad16:	2300      	movs	r3, #0
 800ad18:	637b      	str	r3, [r7, #52]	; 0x34
 800ad1a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ad1c:	60fb      	str	r3, [r7, #12]
	__asm volatile
 800ad1e:	68fb      	ldr	r3, [r7, #12]
 800ad20:	f383 8811 	msr	BASEPRI, r3
}
 800ad24:	bf00      	nop
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 800ad26:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
 800ad28:	4618      	mov	r0, r3
 800ad2a:	3738      	adds	r7, #56	; 0x38
 800ad2c:	46bd      	mov	sp, r7
 800ad2e:	bd80      	pop	{r7, pc}

0800ad30 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
 800ad30:	b580      	push	{r7, lr}
 800ad32:	b08c      	sub	sp, #48	; 0x30
 800ad34:	af00      	add	r7, sp, #0
 800ad36:	60f8      	str	r0, [r7, #12]
 800ad38:	60b9      	str	r1, [r7, #8]
 800ad3a:	607a      	str	r2, [r7, #4]
BaseType_t xEntryTimeSet = pdFALSE;
 800ad3c:	2300      	movs	r3, #0
 800ad3e:	62fb      	str	r3, [r7, #44]	; 0x2c
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
 800ad40:	68fb      	ldr	r3, [r7, #12]
 800ad42:	62bb      	str	r3, [r7, #40]	; 0x28

	/* Check the pointer is not NULL. */
	configASSERT( ( pxQueue ) );
 800ad44:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ad46:	2b00      	cmp	r3, #0
 800ad48:	d10a      	bne.n	800ad60 <xQueueReceive+0x30>
	__asm volatile
 800ad4a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800ad4e:	f383 8811 	msr	BASEPRI, r3
 800ad52:	f3bf 8f6f 	isb	sy
 800ad56:	f3bf 8f4f 	dsb	sy
 800ad5a:	623b      	str	r3, [r7, #32]
}
 800ad5c:	bf00      	nop
 800ad5e:	e7fe      	b.n	800ad5e <xQueueReceive+0x2e>

	/* The buffer into which data is received can only be NULL if the data size
	is zero (so no data is copied into the buffer. */
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800ad60:	68bb      	ldr	r3, [r7, #8]
 800ad62:	2b00      	cmp	r3, #0
 800ad64:	d103      	bne.n	800ad6e <xQueueReceive+0x3e>
 800ad66:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ad68:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800ad6a:	2b00      	cmp	r3, #0
 800ad6c:	d101      	bne.n	800ad72 <xQueueReceive+0x42>
 800ad6e:	2301      	movs	r3, #1
 800ad70:	e000      	b.n	800ad74 <xQueueReceive+0x44>
 800ad72:	2300      	movs	r3, #0
 800ad74:	2b00      	cmp	r3, #0
 800ad76:	d10a      	bne.n	800ad8e <xQueueReceive+0x5e>
	__asm volatile
 800ad78:	f04f 0350 	mov.w	r3, #80	; 0x50
 800ad7c:	f383 8811 	msr	BASEPRI, r3
 800ad80:	f3bf 8f6f 	isb	sy
 800ad84:	f3bf 8f4f 	dsb	sy
 800ad88:	61fb      	str	r3, [r7, #28]
}
 800ad8a:	bf00      	nop
 800ad8c:	e7fe      	b.n	800ad8c <xQueueReceive+0x5c>

	/* Cannot block if the scheduler is suspended. */
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 800ad8e:	f001 f8f1 	bl	800bf74 <xTaskGetSchedulerState>
 800ad92:	4603      	mov	r3, r0
 800ad94:	2b00      	cmp	r3, #0
 800ad96:	d102      	bne.n	800ad9e <xQueueReceive+0x6e>
 800ad98:	687b      	ldr	r3, [r7, #4]
 800ad9a:	2b00      	cmp	r3, #0
 800ad9c:	d101      	bne.n	800ada2 <xQueueReceive+0x72>
 800ad9e:	2301      	movs	r3, #1
 800ada0:	e000      	b.n	800ada4 <xQueueReceive+0x74>
 800ada2:	2300      	movs	r3, #0
 800ada4:	2b00      	cmp	r3, #0
 800ada6:	d10a      	bne.n	800adbe <xQueueReceive+0x8e>
	__asm volatile
 800ada8:	f04f 0350 	mov.w	r3, #80	; 0x50
 800adac:	f383 8811 	msr	BASEPRI, r3
 800adb0:	f3bf 8f6f 	isb	sy
 800adb4:	f3bf 8f4f 	dsb	sy
 800adb8:	61bb      	str	r3, [r7, #24]
}
 800adba:	bf00      	nop
 800adbc:	e7fe      	b.n	800adbc <xQueueReceive+0x8c>
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 800adbe:	f001 ffd9 	bl	800cd74 <vPortEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800adc2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800adc4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800adc6:	627b      	str	r3, [r7, #36]	; 0x24

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 800adc8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800adca:	2b00      	cmp	r3, #0
 800adcc:	d01f      	beq.n	800ae0e <xQueueReceive+0xde>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 800adce:	68b9      	ldr	r1, [r7, #8]
 800add0:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800add2:	f000 fa1b 	bl	800b20c <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 800add6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800add8:	1e5a      	subs	r2, r3, #1
 800adda:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800addc:	639a      	str	r2, [r3, #56]	; 0x38

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800adde:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ade0:	691b      	ldr	r3, [r3, #16]
 800ade2:	2b00      	cmp	r3, #0
 800ade4:	d00f      	beq.n	800ae06 <xQueueReceive+0xd6>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800ade6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ade8:	3310      	adds	r3, #16
 800adea:	4618      	mov	r0, r3
 800adec:	f000 ff10 	bl	800bc10 <xTaskRemoveFromEventList>
 800adf0:	4603      	mov	r3, r0
 800adf2:	2b00      	cmp	r3, #0
 800adf4:	d007      	beq.n	800ae06 <xQueueReceive+0xd6>
					{
						queueYIELD_IF_USING_PREEMPTION();
 800adf6:	4b3d      	ldr	r3, [pc, #244]	; (800aeec <xQueueReceive+0x1bc>)
 800adf8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800adfc:	601a      	str	r2, [r3, #0]
 800adfe:	f3bf 8f4f 	dsb	sy
 800ae02:	f3bf 8f6f 	isb	sy
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
 800ae06:	f001 ffe5 	bl	800cdd4 <vPortExitCritical>
				return pdPASS;
 800ae0a:	2301      	movs	r3, #1
 800ae0c:	e069      	b.n	800aee2 <xQueueReceive+0x1b2>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 800ae0e:	687b      	ldr	r3, [r7, #4]
 800ae10:	2b00      	cmp	r3, #0
 800ae12:	d103      	bne.n	800ae1c <xQueueReceive+0xec>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 800ae14:	f001 ffde 	bl	800cdd4 <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 800ae18:	2300      	movs	r3, #0
 800ae1a:	e062      	b.n	800aee2 <xQueueReceive+0x1b2>
				}
				else if( xEntryTimeSet == pdFALSE )
 800ae1c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ae1e:	2b00      	cmp	r3, #0
 800ae20:	d106      	bne.n	800ae30 <xQueueReceive+0x100>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
 800ae22:	f107 0310 	add.w	r3, r7, #16
 800ae26:	4618      	mov	r0, r3
 800ae28:	f000 ff54 	bl	800bcd4 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 800ae2c:	2301      	movs	r3, #1
 800ae2e:	62fb      	str	r3, [r7, #44]	; 0x2c
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 800ae30:	f001 ffd0 	bl	800cdd4 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 800ae34:	f000 fcc8 	bl	800b7c8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800ae38:	f001 ff9c 	bl	800cd74 <vPortEnterCritical>
 800ae3c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ae3e:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 800ae42:	b25b      	sxtb	r3, r3
 800ae44:	f1b3 3fff 	cmp.w	r3, #4294967295
 800ae48:	d103      	bne.n	800ae52 <xQueueReceive+0x122>
 800ae4a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ae4c:	2200      	movs	r2, #0
 800ae4e:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 800ae52:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ae54:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 800ae58:	b25b      	sxtb	r3, r3
 800ae5a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800ae5e:	d103      	bne.n	800ae68 <xQueueReceive+0x138>
 800ae60:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ae62:	2200      	movs	r2, #0
 800ae64:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 800ae68:	f001 ffb4 	bl	800cdd4 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800ae6c:	1d3a      	adds	r2, r7, #4
 800ae6e:	f107 0310 	add.w	r3, r7, #16
 800ae72:	4611      	mov	r1, r2
 800ae74:	4618      	mov	r0, r3
 800ae76:	f000 ff43 	bl	800bd00 <xTaskCheckForTimeOut>
 800ae7a:	4603      	mov	r3, r0
 800ae7c:	2b00      	cmp	r3, #0
 800ae7e:	d123      	bne.n	800aec8 <xQueueReceive+0x198>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 800ae80:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800ae82:	f000 fa3b 	bl	800b2fc <prvIsQueueEmpty>
 800ae86:	4603      	mov	r3, r0
 800ae88:	2b00      	cmp	r3, #0
 800ae8a:	d017      	beq.n	800aebc <xQueueReceive+0x18c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 800ae8c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ae8e:	3324      	adds	r3, #36	; 0x24
 800ae90:	687a      	ldr	r2, [r7, #4]
 800ae92:	4611      	mov	r1, r2
 800ae94:	4618      	mov	r0, r3
 800ae96:	f000 fe6b 	bl	800bb70 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 800ae9a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800ae9c:	f000 f9dc 	bl	800b258 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 800aea0:	f000 fca0 	bl	800b7e4 <xTaskResumeAll>
 800aea4:	4603      	mov	r3, r0
 800aea6:	2b00      	cmp	r3, #0
 800aea8:	d189      	bne.n	800adbe <xQueueReceive+0x8e>
				{
					portYIELD_WITHIN_API();
 800aeaa:	4b10      	ldr	r3, [pc, #64]	; (800aeec <xQueueReceive+0x1bc>)
 800aeac:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800aeb0:	601a      	str	r2, [r3, #0]
 800aeb2:	f3bf 8f4f 	dsb	sy
 800aeb6:	f3bf 8f6f 	isb	sy
 800aeba:	e780      	b.n	800adbe <xQueueReceive+0x8e>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
 800aebc:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800aebe:	f000 f9cb 	bl	800b258 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 800aec2:	f000 fc8f 	bl	800b7e4 <xTaskResumeAll>
 800aec6:	e77a      	b.n	800adbe <xQueueReceive+0x8e>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
 800aec8:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800aeca:	f000 f9c5 	bl	800b258 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 800aece:	f000 fc89 	bl	800b7e4 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 800aed2:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800aed4:	f000 fa12 	bl	800b2fc <prvIsQueueEmpty>
 800aed8:	4603      	mov	r3, r0
 800aeda:	2b00      	cmp	r3, #0
 800aedc:	f43f af6f 	beq.w	800adbe <xQueueReceive+0x8e>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
 800aee0:	2300      	movs	r3, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
 800aee2:	4618      	mov	r0, r3
 800aee4:	3730      	adds	r7, #48	; 0x30
 800aee6:	46bd      	mov	sp, r7
 800aee8:	bd80      	pop	{r7, pc}
 800aeea:	bf00      	nop
 800aeec:	e000ed04 	.word	0xe000ed04

0800aef0 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
 800aef0:	b580      	push	{r7, lr}
 800aef2:	b08e      	sub	sp, #56	; 0x38
 800aef4:	af00      	add	r7, sp, #0
 800aef6:	6078      	str	r0, [r7, #4]
 800aef8:	6039      	str	r1, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE;
 800aefa:	2300      	movs	r3, #0
 800aefc:	637b      	str	r3, [r7, #52]	; 0x34
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
 800aefe:	687b      	ldr	r3, [r7, #4]
 800af00:	62fb      	str	r3, [r7, #44]	; 0x2c

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
 800af02:	2300      	movs	r3, #0
 800af04:	633b      	str	r3, [r7, #48]	; 0x30
#endif

	/* Check the queue pointer is not NULL. */
	configASSERT( ( pxQueue ) );
 800af06:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800af08:	2b00      	cmp	r3, #0
 800af0a:	d10a      	bne.n	800af22 <xQueueSemaphoreTake+0x32>
	__asm volatile
 800af0c:	f04f 0350 	mov.w	r3, #80	; 0x50
 800af10:	f383 8811 	msr	BASEPRI, r3
 800af14:	f3bf 8f6f 	isb	sy
 800af18:	f3bf 8f4f 	dsb	sy
 800af1c:	623b      	str	r3, [r7, #32]
}
 800af1e:	bf00      	nop
 800af20:	e7fe      	b.n	800af20 <xQueueSemaphoreTake+0x30>

	/* Check this really is a semaphore, in which case the item size will be
	0. */
	configASSERT( pxQueue->uxItemSize == 0 );
 800af22:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800af24:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800af26:	2b00      	cmp	r3, #0
 800af28:	d00a      	beq.n	800af40 <xQueueSemaphoreTake+0x50>
	__asm volatile
 800af2a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800af2e:	f383 8811 	msr	BASEPRI, r3
 800af32:	f3bf 8f6f 	isb	sy
 800af36:	f3bf 8f4f 	dsb	sy
 800af3a:	61fb      	str	r3, [r7, #28]
}
 800af3c:	bf00      	nop
 800af3e:	e7fe      	b.n	800af3e <xQueueSemaphoreTake+0x4e>

	/* Cannot block if the scheduler is suspended. */
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 800af40:	f001 f818 	bl	800bf74 <xTaskGetSchedulerState>
 800af44:	4603      	mov	r3, r0
 800af46:	2b00      	cmp	r3, #0
 800af48:	d102      	bne.n	800af50 <xQueueSemaphoreTake+0x60>
 800af4a:	683b      	ldr	r3, [r7, #0]
 800af4c:	2b00      	cmp	r3, #0
 800af4e:	d101      	bne.n	800af54 <xQueueSemaphoreTake+0x64>
 800af50:	2301      	movs	r3, #1
 800af52:	e000      	b.n	800af56 <xQueueSemaphoreTake+0x66>
 800af54:	2300      	movs	r3, #0
 800af56:	2b00      	cmp	r3, #0
 800af58:	d10a      	bne.n	800af70 <xQueueSemaphoreTake+0x80>
	__asm volatile
 800af5a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800af5e:	f383 8811 	msr	BASEPRI, r3
 800af62:	f3bf 8f6f 	isb	sy
 800af66:	f3bf 8f4f 	dsb	sy
 800af6a:	61bb      	str	r3, [r7, #24]
}
 800af6c:	bf00      	nop
 800af6e:	e7fe      	b.n	800af6e <xQueueSemaphoreTake+0x7e>
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 800af70:	f001 ff00 	bl	800cd74 <vPortEnterCritical>
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 800af74:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800af76:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800af78:	62bb      	str	r3, [r7, #40]	; 0x28

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 800af7a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800af7c:	2b00      	cmp	r3, #0
 800af7e:	d024      	beq.n	800afca <xQueueSemaphoreTake+0xda>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
 800af80:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800af82:	1e5a      	subs	r2, r3, #1
 800af84:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800af86:	639a      	str	r2, [r3, #56]	; 0x38

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800af88:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800af8a:	681b      	ldr	r3, [r3, #0]
 800af8c:	2b00      	cmp	r3, #0
 800af8e:	d104      	bne.n	800af9a <xQueueSemaphoreTake+0xaa>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
 800af90:	f001 f998 	bl	800c2c4 <pvTaskIncrementMutexHeldCount>
 800af94:	4602      	mov	r2, r0
 800af96:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800af98:	609a      	str	r2, [r3, #8]
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800af9a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800af9c:	691b      	ldr	r3, [r3, #16]
 800af9e:	2b00      	cmp	r3, #0
 800afa0:	d00f      	beq.n	800afc2 <xQueueSemaphoreTake+0xd2>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800afa2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800afa4:	3310      	adds	r3, #16
 800afa6:	4618      	mov	r0, r3
 800afa8:	f000 fe32 	bl	800bc10 <xTaskRemoveFromEventList>
 800afac:	4603      	mov	r3, r0
 800afae:	2b00      	cmp	r3, #0
 800afb0:	d007      	beq.n	800afc2 <xQueueSemaphoreTake+0xd2>
					{
						queueYIELD_IF_USING_PREEMPTION();
 800afb2:	4b54      	ldr	r3, [pc, #336]	; (800b104 <xQueueSemaphoreTake+0x214>)
 800afb4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800afb8:	601a      	str	r2, [r3, #0]
 800afba:	f3bf 8f4f 	dsb	sy
 800afbe:	f3bf 8f6f 	isb	sy
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
 800afc2:	f001 ff07 	bl	800cdd4 <vPortExitCritical>
				return pdPASS;
 800afc6:	2301      	movs	r3, #1
 800afc8:	e097      	b.n	800b0fa <xQueueSemaphoreTake+0x20a>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 800afca:	683b      	ldr	r3, [r7, #0]
 800afcc:	2b00      	cmp	r3, #0
 800afce:	d111      	bne.n	800aff4 <xQueueSemaphoreTake+0x104>
					/* For inheritance to have occurred there must have been an
					initial timeout, and an adjusted timeout cannot become 0, as
					if it were 0 the function would have exited. */
					#if( configUSE_MUTEXES == 1 )
					{
						configASSERT( xInheritanceOccurred == pdFALSE );
 800afd0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800afd2:	2b00      	cmp	r3, #0
 800afd4:	d00a      	beq.n	800afec <xQueueSemaphoreTake+0xfc>
	__asm volatile
 800afd6:	f04f 0350 	mov.w	r3, #80	; 0x50
 800afda:	f383 8811 	msr	BASEPRI, r3
 800afde:	f3bf 8f6f 	isb	sy
 800afe2:	f3bf 8f4f 	dsb	sy
 800afe6:	617b      	str	r3, [r7, #20]
}
 800afe8:	bf00      	nop
 800afea:	e7fe      	b.n	800afea <xQueueSemaphoreTake+0xfa>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
 800afec:	f001 fef2 	bl	800cdd4 <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 800aff0:	2300      	movs	r3, #0
 800aff2:	e082      	b.n	800b0fa <xQueueSemaphoreTake+0x20a>
				}
				else if( xEntryTimeSet == pdFALSE )
 800aff4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800aff6:	2b00      	cmp	r3, #0
 800aff8:	d106      	bne.n	800b008 <xQueueSemaphoreTake+0x118>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
 800affa:	f107 030c 	add.w	r3, r7, #12
 800affe:	4618      	mov	r0, r3
 800b000:	f000 fe68 	bl	800bcd4 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 800b004:	2301      	movs	r3, #1
 800b006:	637b      	str	r3, [r7, #52]	; 0x34
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 800b008:	f001 fee4 	bl	800cdd4 <vPortExitCritical>

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
 800b00c:	f000 fbdc 	bl	800b7c8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800b010:	f001 feb0 	bl	800cd74 <vPortEnterCritical>
 800b014:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b016:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 800b01a:	b25b      	sxtb	r3, r3
 800b01c:	f1b3 3fff 	cmp.w	r3, #4294967295
 800b020:	d103      	bne.n	800b02a <xQueueSemaphoreTake+0x13a>
 800b022:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b024:	2200      	movs	r2, #0
 800b026:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 800b02a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b02c:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 800b030:	b25b      	sxtb	r3, r3
 800b032:	f1b3 3fff 	cmp.w	r3, #4294967295
 800b036:	d103      	bne.n	800b040 <xQueueSemaphoreTake+0x150>
 800b038:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b03a:	2200      	movs	r2, #0
 800b03c:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 800b040:	f001 fec8 	bl	800cdd4 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800b044:	463a      	mov	r2, r7
 800b046:	f107 030c 	add.w	r3, r7, #12
 800b04a:	4611      	mov	r1, r2
 800b04c:	4618      	mov	r0, r3
 800b04e:	f000 fe57 	bl	800bd00 <xTaskCheckForTimeOut>
 800b052:	4603      	mov	r3, r0
 800b054:	2b00      	cmp	r3, #0
 800b056:	d132      	bne.n	800b0be <xQueueSemaphoreTake+0x1ce>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 800b058:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800b05a:	f000 f94f 	bl	800b2fc <prvIsQueueEmpty>
 800b05e:	4603      	mov	r3, r0
 800b060:	2b00      	cmp	r3, #0
 800b062:	d026      	beq.n	800b0b2 <xQueueSemaphoreTake+0x1c2>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800b064:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b066:	681b      	ldr	r3, [r3, #0]
 800b068:	2b00      	cmp	r3, #0
 800b06a:	d109      	bne.n	800b080 <xQueueSemaphoreTake+0x190>
					{
						taskENTER_CRITICAL();
 800b06c:	f001 fe82 	bl	800cd74 <vPortEnterCritical>
						{
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
 800b070:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b072:	689b      	ldr	r3, [r3, #8]
 800b074:	4618      	mov	r0, r3
 800b076:	f000 ff9b 	bl	800bfb0 <xTaskPriorityInherit>
 800b07a:	6338      	str	r0, [r7, #48]	; 0x30
						}
						taskEXIT_CRITICAL();
 800b07c:	f001 feaa 	bl	800cdd4 <vPortExitCritical>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 800b080:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b082:	3324      	adds	r3, #36	; 0x24
 800b084:	683a      	ldr	r2, [r7, #0]
 800b086:	4611      	mov	r1, r2
 800b088:	4618      	mov	r0, r3
 800b08a:	f000 fd71 	bl	800bb70 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 800b08e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800b090:	f000 f8e2 	bl	800b258 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 800b094:	f000 fba6 	bl	800b7e4 <xTaskResumeAll>
 800b098:	4603      	mov	r3, r0
 800b09a:	2b00      	cmp	r3, #0
 800b09c:	f47f af68 	bne.w	800af70 <xQueueSemaphoreTake+0x80>
				{
					portYIELD_WITHIN_API();
 800b0a0:	4b18      	ldr	r3, [pc, #96]	; (800b104 <xQueueSemaphoreTake+0x214>)
 800b0a2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800b0a6:	601a      	str	r2, [r3, #0]
 800b0a8:	f3bf 8f4f 	dsb	sy
 800b0ac:	f3bf 8f6f 	isb	sy
 800b0b0:	e75e      	b.n	800af70 <xQueueSemaphoreTake+0x80>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
 800b0b2:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800b0b4:	f000 f8d0 	bl	800b258 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 800b0b8:	f000 fb94 	bl	800b7e4 <xTaskResumeAll>
 800b0bc:	e758      	b.n	800af70 <xQueueSemaphoreTake+0x80>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
 800b0be:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800b0c0:	f000 f8ca 	bl	800b258 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 800b0c4:	f000 fb8e 	bl	800b7e4 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 800b0c8:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800b0ca:	f000 f917 	bl	800b2fc <prvIsQueueEmpty>
 800b0ce:	4603      	mov	r3, r0
 800b0d0:	2b00      	cmp	r3, #0
 800b0d2:	f43f af4d 	beq.w	800af70 <xQueueSemaphoreTake+0x80>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
 800b0d6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b0d8:	2b00      	cmp	r3, #0
 800b0da:	d00d      	beq.n	800b0f8 <xQueueSemaphoreTake+0x208>
					{
						taskENTER_CRITICAL();
 800b0dc:	f001 fe4a 	bl	800cd74 <vPortEnterCritical>
							/* This task blocking on the mutex caused another
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
 800b0e0:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800b0e2:	f000 f811 	bl	800b108 <prvGetDisinheritPriorityAfterTimeout>
 800b0e6:	6278      	str	r0, [r7, #36]	; 0x24
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
 800b0e8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b0ea:	689b      	ldr	r3, [r3, #8]
 800b0ec:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800b0ee:	4618      	mov	r0, r3
 800b0f0:	f001 f85a 	bl	800c1a8 <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
 800b0f4:	f001 fe6e 	bl	800cdd4 <vPortExitCritical>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
 800b0f8:	2300      	movs	r3, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
 800b0fa:	4618      	mov	r0, r3
 800b0fc:	3738      	adds	r7, #56	; 0x38
 800b0fe:	46bd      	mov	sp, r7
 800b100:	bd80      	pop	{r7, pc}
 800b102:	bf00      	nop
 800b104:	e000ed04 	.word	0xe000ed04

0800b108 <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
 800b108:	b480      	push	{r7}
 800b10a:	b085      	sub	sp, #20
 800b10c:	af00      	add	r7, sp, #0
 800b10e:	6078      	str	r0, [r7, #4]
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
 800b110:	687b      	ldr	r3, [r7, #4]
 800b112:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b114:	2b00      	cmp	r3, #0
 800b116:	d006      	beq.n	800b126 <prvGetDisinheritPriorityAfterTimeout+0x1e>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
 800b118:	687b      	ldr	r3, [r7, #4]
 800b11a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b11c:	681b      	ldr	r3, [r3, #0]
 800b11e:	f1c3 0307 	rsb	r3, r3, #7
 800b122:	60fb      	str	r3, [r7, #12]
 800b124:	e001      	b.n	800b12a <prvGetDisinheritPriorityAfterTimeout+0x22>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
 800b126:	2300      	movs	r3, #0
 800b128:	60fb      	str	r3, [r7, #12]
		}

		return uxHighestPriorityOfWaitingTasks;
 800b12a:	68fb      	ldr	r3, [r7, #12]
	}
 800b12c:	4618      	mov	r0, r3
 800b12e:	3714      	adds	r7, #20
 800b130:	46bd      	mov	sp, r7
 800b132:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b136:	4770      	bx	lr

0800b138 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 800b138:	b580      	push	{r7, lr}
 800b13a:	b086      	sub	sp, #24
 800b13c:	af00      	add	r7, sp, #0
 800b13e:	60f8      	str	r0, [r7, #12]
 800b140:	60b9      	str	r1, [r7, #8]
 800b142:	607a      	str	r2, [r7, #4]
BaseType_t xReturn = pdFALSE;
 800b144:	2300      	movs	r3, #0
 800b146:	617b      	str	r3, [r7, #20]
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800b148:	68fb      	ldr	r3, [r7, #12]
 800b14a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800b14c:	613b      	str	r3, [r7, #16]

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 800b14e:	68fb      	ldr	r3, [r7, #12]
 800b150:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800b152:	2b00      	cmp	r3, #0
 800b154:	d10d      	bne.n	800b172 <prvCopyDataToQueue+0x3a>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800b156:	68fb      	ldr	r3, [r7, #12]
 800b158:	681b      	ldr	r3, [r3, #0]
 800b15a:	2b00      	cmp	r3, #0
 800b15c:	d14d      	bne.n	800b1fa <prvCopyDataToQueue+0xc2>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 800b15e:	68fb      	ldr	r3, [r7, #12]
 800b160:	689b      	ldr	r3, [r3, #8]
 800b162:	4618      	mov	r0, r3
 800b164:	f000 ff9a 	bl	800c09c <xTaskPriorityDisinherit>
 800b168:	6178      	str	r0, [r7, #20]
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
 800b16a:	68fb      	ldr	r3, [r7, #12]
 800b16c:	2200      	movs	r2, #0
 800b16e:	609a      	str	r2, [r3, #8]
 800b170:	e043      	b.n	800b1fa <prvCopyDataToQueue+0xc2>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
 800b172:	687b      	ldr	r3, [r7, #4]
 800b174:	2b00      	cmp	r3, #0
 800b176:	d119      	bne.n	800b1ac <prvCopyDataToQueue+0x74>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 800b178:	68fb      	ldr	r3, [r7, #12]
 800b17a:	6858      	ldr	r0, [r3, #4]
 800b17c:	68fb      	ldr	r3, [r7, #12]
 800b17e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800b180:	461a      	mov	r2, r3
 800b182:	68b9      	ldr	r1, [r7, #8]
 800b184:	f016 fd68 	bl	8021c58 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 800b188:	68fb      	ldr	r3, [r7, #12]
 800b18a:	685a      	ldr	r2, [r3, #4]
 800b18c:	68fb      	ldr	r3, [r7, #12]
 800b18e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800b190:	441a      	add	r2, r3
 800b192:	68fb      	ldr	r3, [r7, #12]
 800b194:	605a      	str	r2, [r3, #4]
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800b196:	68fb      	ldr	r3, [r7, #12]
 800b198:	685a      	ldr	r2, [r3, #4]
 800b19a:	68fb      	ldr	r3, [r7, #12]
 800b19c:	689b      	ldr	r3, [r3, #8]
 800b19e:	429a      	cmp	r2, r3
 800b1a0:	d32b      	bcc.n	800b1fa <prvCopyDataToQueue+0xc2>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 800b1a2:	68fb      	ldr	r3, [r7, #12]
 800b1a4:	681a      	ldr	r2, [r3, #0]
 800b1a6:	68fb      	ldr	r3, [r7, #12]
 800b1a8:	605a      	str	r2, [r3, #4]
 800b1aa:	e026      	b.n	800b1fa <prvCopyDataToQueue+0xc2>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
 800b1ac:	68fb      	ldr	r3, [r7, #12]
 800b1ae:	68d8      	ldr	r0, [r3, #12]
 800b1b0:	68fb      	ldr	r3, [r7, #12]
 800b1b2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800b1b4:	461a      	mov	r2, r3
 800b1b6:	68b9      	ldr	r1, [r7, #8]
 800b1b8:	f016 fd4e 	bl	8021c58 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 800b1bc:	68fb      	ldr	r3, [r7, #12]
 800b1be:	68da      	ldr	r2, [r3, #12]
 800b1c0:	68fb      	ldr	r3, [r7, #12]
 800b1c2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800b1c4:	425b      	negs	r3, r3
 800b1c6:	441a      	add	r2, r3
 800b1c8:	68fb      	ldr	r3, [r7, #12]
 800b1ca:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800b1cc:	68fb      	ldr	r3, [r7, #12]
 800b1ce:	68da      	ldr	r2, [r3, #12]
 800b1d0:	68fb      	ldr	r3, [r7, #12]
 800b1d2:	681b      	ldr	r3, [r3, #0]
 800b1d4:	429a      	cmp	r2, r3
 800b1d6:	d207      	bcs.n	800b1e8 <prvCopyDataToQueue+0xb0>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 800b1d8:	68fb      	ldr	r3, [r7, #12]
 800b1da:	689a      	ldr	r2, [r3, #8]
 800b1dc:	68fb      	ldr	r3, [r7, #12]
 800b1de:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800b1e0:	425b      	negs	r3, r3
 800b1e2:	441a      	add	r2, r3
 800b1e4:	68fb      	ldr	r3, [r7, #12]
 800b1e6:	60da      	str	r2, [r3, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
 800b1e8:	687b      	ldr	r3, [r7, #4]
 800b1ea:	2b02      	cmp	r3, #2
 800b1ec:	d105      	bne.n	800b1fa <prvCopyDataToQueue+0xc2>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 800b1ee:	693b      	ldr	r3, [r7, #16]
 800b1f0:	2b00      	cmp	r3, #0
 800b1f2:	d002      	beq.n	800b1fa <prvCopyDataToQueue+0xc2>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
 800b1f4:	693b      	ldr	r3, [r7, #16]
 800b1f6:	3b01      	subs	r3, #1
 800b1f8:	613b      	str	r3, [r7, #16]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 800b1fa:	693b      	ldr	r3, [r7, #16]
 800b1fc:	1c5a      	adds	r2, r3, #1
 800b1fe:	68fb      	ldr	r3, [r7, #12]
 800b200:	639a      	str	r2, [r3, #56]	; 0x38

	return xReturn;
 800b202:	697b      	ldr	r3, [r7, #20]
}
 800b204:	4618      	mov	r0, r3
 800b206:	3718      	adds	r7, #24
 800b208:	46bd      	mov	sp, r7
 800b20a:	bd80      	pop	{r7, pc}

0800b20c <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
 800b20c:	b580      	push	{r7, lr}
 800b20e:	b082      	sub	sp, #8
 800b210:	af00      	add	r7, sp, #0
 800b212:	6078      	str	r0, [r7, #4]
 800b214:	6039      	str	r1, [r7, #0]
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 800b216:	687b      	ldr	r3, [r7, #4]
 800b218:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800b21a:	2b00      	cmp	r3, #0
 800b21c:	d018      	beq.n	800b250 <prvCopyDataFromQueue+0x44>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 800b21e:	687b      	ldr	r3, [r7, #4]
 800b220:	68da      	ldr	r2, [r3, #12]
 800b222:	687b      	ldr	r3, [r7, #4]
 800b224:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800b226:	441a      	add	r2, r3
 800b228:	687b      	ldr	r3, [r7, #4]
 800b22a:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 800b22c:	687b      	ldr	r3, [r7, #4]
 800b22e:	68da      	ldr	r2, [r3, #12]
 800b230:	687b      	ldr	r3, [r7, #4]
 800b232:	689b      	ldr	r3, [r3, #8]
 800b234:	429a      	cmp	r2, r3
 800b236:	d303      	bcc.n	800b240 <prvCopyDataFromQueue+0x34>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 800b238:	687b      	ldr	r3, [r7, #4]
 800b23a:	681a      	ldr	r2, [r3, #0]
 800b23c:	687b      	ldr	r3, [r7, #4]
 800b23e:	60da      	str	r2, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 800b240:	687b      	ldr	r3, [r7, #4]
 800b242:	68d9      	ldr	r1, [r3, #12]
 800b244:	687b      	ldr	r3, [r7, #4]
 800b246:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800b248:	461a      	mov	r2, r3
 800b24a:	6838      	ldr	r0, [r7, #0]
 800b24c:	f016 fd04 	bl	8021c58 <memcpy>
	}
}
 800b250:	bf00      	nop
 800b252:	3708      	adds	r7, #8
 800b254:	46bd      	mov	sp, r7
 800b256:	bd80      	pop	{r7, pc}

0800b258 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 800b258:	b580      	push	{r7, lr}
 800b25a:	b084      	sub	sp, #16
 800b25c:	af00      	add	r7, sp, #0
 800b25e:	6078      	str	r0, [r7, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 800b260:	f001 fd88 	bl	800cd74 <vPortEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
 800b264:	687b      	ldr	r3, [r7, #4]
 800b266:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 800b26a:	73fb      	strb	r3, [r7, #15]

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800b26c:	e011      	b.n	800b292 <prvUnlockQueue+0x3a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800b26e:	687b      	ldr	r3, [r7, #4]
 800b270:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b272:	2b00      	cmp	r3, #0
 800b274:	d012      	beq.n	800b29c <prvUnlockQueue+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800b276:	687b      	ldr	r3, [r7, #4]
 800b278:	3324      	adds	r3, #36	; 0x24
 800b27a:	4618      	mov	r0, r3
 800b27c:	f000 fcc8 	bl	800bc10 <xTaskRemoveFromEventList>
 800b280:	4603      	mov	r3, r0
 800b282:	2b00      	cmp	r3, #0
 800b284:	d001      	beq.n	800b28a <prvUnlockQueue+0x32>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
 800b286:	f000 fdad 	bl	800bde4 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
 800b28a:	7bfb      	ldrb	r3, [r7, #15]
 800b28c:	3b01      	subs	r3, #1
 800b28e:	b2db      	uxtb	r3, r3
 800b290:	73fb      	strb	r3, [r7, #15]
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800b292:	f997 300f 	ldrsb.w	r3, [r7, #15]
 800b296:	2b00      	cmp	r3, #0
 800b298:	dce9      	bgt.n	800b26e <prvUnlockQueue+0x16>
 800b29a:	e000      	b.n	800b29e <prvUnlockQueue+0x46>
					break;
 800b29c:	bf00      	nop
		}

		pxQueue->cTxLock = queueUNLOCKED;
 800b29e:	687b      	ldr	r3, [r7, #4]
 800b2a0:	22ff      	movs	r2, #255	; 0xff
 800b2a2:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
 800b2a6:	f001 fd95 	bl	800cdd4 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 800b2aa:	f001 fd63 	bl	800cd74 <vPortEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
 800b2ae:	687b      	ldr	r3, [r7, #4]
 800b2b0:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 800b2b4:	73bb      	strb	r3, [r7, #14]

		while( cRxLock > queueLOCKED_UNMODIFIED )
 800b2b6:	e011      	b.n	800b2dc <prvUnlockQueue+0x84>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800b2b8:	687b      	ldr	r3, [r7, #4]
 800b2ba:	691b      	ldr	r3, [r3, #16]
 800b2bc:	2b00      	cmp	r3, #0
 800b2be:	d012      	beq.n	800b2e6 <prvUnlockQueue+0x8e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800b2c0:	687b      	ldr	r3, [r7, #4]
 800b2c2:	3310      	adds	r3, #16
 800b2c4:	4618      	mov	r0, r3
 800b2c6:	f000 fca3 	bl	800bc10 <xTaskRemoveFromEventList>
 800b2ca:	4603      	mov	r3, r0
 800b2cc:	2b00      	cmp	r3, #0
 800b2ce:	d001      	beq.n	800b2d4 <prvUnlockQueue+0x7c>
				{
					vTaskMissedYield();
 800b2d0:	f000 fd88 	bl	800bde4 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
 800b2d4:	7bbb      	ldrb	r3, [r7, #14]
 800b2d6:	3b01      	subs	r3, #1
 800b2d8:	b2db      	uxtb	r3, r3
 800b2da:	73bb      	strb	r3, [r7, #14]
		while( cRxLock > queueLOCKED_UNMODIFIED )
 800b2dc:	f997 300e 	ldrsb.w	r3, [r7, #14]
 800b2e0:	2b00      	cmp	r3, #0
 800b2e2:	dce9      	bgt.n	800b2b8 <prvUnlockQueue+0x60>
 800b2e4:	e000      	b.n	800b2e8 <prvUnlockQueue+0x90>
			}
			else
			{
				break;
 800b2e6:	bf00      	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
 800b2e8:	687b      	ldr	r3, [r7, #4]
 800b2ea:	22ff      	movs	r2, #255	; 0xff
 800b2ec:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
 800b2f0:	f001 fd70 	bl	800cdd4 <vPortExitCritical>
}
 800b2f4:	bf00      	nop
 800b2f6:	3710      	adds	r7, #16
 800b2f8:	46bd      	mov	sp, r7
 800b2fa:	bd80      	pop	{r7, pc}

0800b2fc <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
 800b2fc:	b580      	push	{r7, lr}
 800b2fe:	b084      	sub	sp, #16
 800b300:	af00      	add	r7, sp, #0
 800b302:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
 800b304:	f001 fd36 	bl	800cd74 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 800b308:	687b      	ldr	r3, [r7, #4]
 800b30a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800b30c:	2b00      	cmp	r3, #0
 800b30e:	d102      	bne.n	800b316 <prvIsQueueEmpty+0x1a>
		{
			xReturn = pdTRUE;
 800b310:	2301      	movs	r3, #1
 800b312:	60fb      	str	r3, [r7, #12]
 800b314:	e001      	b.n	800b31a <prvIsQueueEmpty+0x1e>
		}
		else
		{
			xReturn = pdFALSE;
 800b316:	2300      	movs	r3, #0
 800b318:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
 800b31a:	f001 fd5b 	bl	800cdd4 <vPortExitCritical>

	return xReturn;
 800b31e:	68fb      	ldr	r3, [r7, #12]
}
 800b320:	4618      	mov	r0, r3
 800b322:	3710      	adds	r7, #16
 800b324:	46bd      	mov	sp, r7
 800b326:	bd80      	pop	{r7, pc}

0800b328 <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
 800b328:	b580      	push	{r7, lr}
 800b32a:	b084      	sub	sp, #16
 800b32c:	af00      	add	r7, sp, #0
 800b32e:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
 800b330:	f001 fd20 	bl	800cd74 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 800b334:	687b      	ldr	r3, [r7, #4]
 800b336:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800b338:	687b      	ldr	r3, [r7, #4]
 800b33a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800b33c:	429a      	cmp	r2, r3
 800b33e:	d102      	bne.n	800b346 <prvIsQueueFull+0x1e>
		{
			xReturn = pdTRUE;
 800b340:	2301      	movs	r3, #1
 800b342:	60fb      	str	r3, [r7, #12]
 800b344:	e001      	b.n	800b34a <prvIsQueueFull+0x22>
		}
		else
		{
			xReturn = pdFALSE;
 800b346:	2300      	movs	r3, #0
 800b348:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
 800b34a:	f001 fd43 	bl	800cdd4 <vPortExitCritical>

	return xReturn;
 800b34e:	68fb      	ldr	r3, [r7, #12]
}
 800b350:	4618      	mov	r0, r3
 800b352:	3710      	adds	r7, #16
 800b354:	46bd      	mov	sp, r7
 800b356:	bd80      	pop	{r7, pc}

0800b358 <vQueueAddToRegistry>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
 800b358:	b480      	push	{r7}
 800b35a:	b085      	sub	sp, #20
 800b35c:	af00      	add	r7, sp, #0
 800b35e:	6078      	str	r0, [r7, #4]
 800b360:	6039      	str	r1, [r7, #0]
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 800b362:	2300      	movs	r3, #0
 800b364:	60fb      	str	r3, [r7, #12]
 800b366:	e014      	b.n	800b392 <vQueueAddToRegistry+0x3a>
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 800b368:	4a0f      	ldr	r2, [pc, #60]	; (800b3a8 <vQueueAddToRegistry+0x50>)
 800b36a:	68fb      	ldr	r3, [r7, #12]
 800b36c:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 800b370:	2b00      	cmp	r3, #0
 800b372:	d10b      	bne.n	800b38c <vQueueAddToRegistry+0x34>
			{
				/* Store the information on this queue. */
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 800b374:	490c      	ldr	r1, [pc, #48]	; (800b3a8 <vQueueAddToRegistry+0x50>)
 800b376:	68fb      	ldr	r3, [r7, #12]
 800b378:	683a      	ldr	r2, [r7, #0]
 800b37a:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
				xQueueRegistry[ ux ].xHandle = xQueue;
 800b37e:	4a0a      	ldr	r2, [pc, #40]	; (800b3a8 <vQueueAddToRegistry+0x50>)
 800b380:	68fb      	ldr	r3, [r7, #12]
 800b382:	00db      	lsls	r3, r3, #3
 800b384:	4413      	add	r3, r2
 800b386:	687a      	ldr	r2, [r7, #4]
 800b388:	605a      	str	r2, [r3, #4]

				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
				break;
 800b38a:	e006      	b.n	800b39a <vQueueAddToRegistry+0x42>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 800b38c:	68fb      	ldr	r3, [r7, #12]
 800b38e:	3301      	adds	r3, #1
 800b390:	60fb      	str	r3, [r7, #12]
 800b392:	68fb      	ldr	r3, [r7, #12]
 800b394:	2b07      	cmp	r3, #7
 800b396:	d9e7      	bls.n	800b368 <vQueueAddToRegistry+0x10>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 800b398:	bf00      	nop
 800b39a:	bf00      	nop
 800b39c:	3714      	adds	r7, #20
 800b39e:	46bd      	mov	sp, r7
 800b3a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b3a4:	4770      	bx	lr
 800b3a6:	bf00      	nop
 800b3a8:	24062440 	.word	0x24062440

0800b3ac <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 800b3ac:	b580      	push	{r7, lr}
 800b3ae:	b086      	sub	sp, #24
 800b3b0:	af00      	add	r7, sp, #0
 800b3b2:	60f8      	str	r0, [r7, #12]
 800b3b4:	60b9      	str	r1, [r7, #8]
 800b3b6:	607a      	str	r2, [r7, #4]
	Queue_t * const pxQueue = xQueue;
 800b3b8:	68fb      	ldr	r3, [r7, #12]
 800b3ba:	617b      	str	r3, [r7, #20]
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 800b3bc:	f001 fcda 	bl	800cd74 <vPortEnterCritical>
 800b3c0:	697b      	ldr	r3, [r7, #20]
 800b3c2:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 800b3c6:	b25b      	sxtb	r3, r3
 800b3c8:	f1b3 3fff 	cmp.w	r3, #4294967295
 800b3cc:	d103      	bne.n	800b3d6 <vQueueWaitForMessageRestricted+0x2a>
 800b3ce:	697b      	ldr	r3, [r7, #20]
 800b3d0:	2200      	movs	r2, #0
 800b3d2:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 800b3d6:	697b      	ldr	r3, [r7, #20]
 800b3d8:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 800b3dc:	b25b      	sxtb	r3, r3
 800b3de:	f1b3 3fff 	cmp.w	r3, #4294967295
 800b3e2:	d103      	bne.n	800b3ec <vQueueWaitForMessageRestricted+0x40>
 800b3e4:	697b      	ldr	r3, [r7, #20]
 800b3e6:	2200      	movs	r2, #0
 800b3e8:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 800b3ec:	f001 fcf2 	bl	800cdd4 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 800b3f0:	697b      	ldr	r3, [r7, #20]
 800b3f2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800b3f4:	2b00      	cmp	r3, #0
 800b3f6:	d106      	bne.n	800b406 <vQueueWaitForMessageRestricted+0x5a>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 800b3f8:	697b      	ldr	r3, [r7, #20]
 800b3fa:	3324      	adds	r3, #36	; 0x24
 800b3fc:	687a      	ldr	r2, [r7, #4]
 800b3fe:	68b9      	ldr	r1, [r7, #8]
 800b400:	4618      	mov	r0, r3
 800b402:	f000 fbd9 	bl	800bbb8 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
 800b406:	6978      	ldr	r0, [r7, #20]
 800b408:	f7ff ff26 	bl	800b258 <prvUnlockQueue>
	}
 800b40c:	bf00      	nop
 800b40e:	3718      	adds	r7, #24
 800b410:	46bd      	mov	sp, r7
 800b412:	bd80      	pop	{r7, pc}

0800b414 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
 800b414:	b580      	push	{r7, lr}
 800b416:	b08c      	sub	sp, #48	; 0x30
 800b418:	af04      	add	r7, sp, #16
 800b41a:	60f8      	str	r0, [r7, #12]
 800b41c:	60b9      	str	r1, [r7, #8]
 800b41e:	603b      	str	r3, [r7, #0]
 800b420:	4613      	mov	r3, r2
 800b422:	80fb      	strh	r3, [r7, #6]
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 800b424:	88fb      	ldrh	r3, [r7, #6]
 800b426:	009b      	lsls	r3, r3, #2
 800b428:	4618      	mov	r0, r3
 800b42a:	f001 fdc5 	bl	800cfb8 <pvPortMalloc>
 800b42e:	6178      	str	r0, [r7, #20]

			if( pxStack != NULL )
 800b430:	697b      	ldr	r3, [r7, #20]
 800b432:	2b00      	cmp	r3, #0
 800b434:	d00e      	beq.n	800b454 <xTaskCreate+0x40>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 800b436:	20b4      	movs	r0, #180	; 0xb4
 800b438:	f001 fdbe 	bl	800cfb8 <pvPortMalloc>
 800b43c:	61f8      	str	r0, [r7, #28]

				if( pxNewTCB != NULL )
 800b43e:	69fb      	ldr	r3, [r7, #28]
 800b440:	2b00      	cmp	r3, #0
 800b442:	d003      	beq.n	800b44c <xTaskCreate+0x38>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
 800b444:	69fb      	ldr	r3, [r7, #28]
 800b446:	697a      	ldr	r2, [r7, #20]
 800b448:	631a      	str	r2, [r3, #48]	; 0x30
 800b44a:	e005      	b.n	800b458 <xTaskCreate+0x44>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
 800b44c:	6978      	ldr	r0, [r7, #20]
 800b44e:	f001 fe7f 	bl	800d150 <vPortFree>
 800b452:	e001      	b.n	800b458 <xTaskCreate+0x44>
				}
			}
			else
			{
				pxNewTCB = NULL;
 800b454:	2300      	movs	r3, #0
 800b456:	61fb      	str	r3, [r7, #28]
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
 800b458:	69fb      	ldr	r3, [r7, #28]
 800b45a:	2b00      	cmp	r3, #0
 800b45c:	d013      	beq.n	800b486 <xTaskCreate+0x72>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 800b45e:	88fa      	ldrh	r2, [r7, #6]
 800b460:	2300      	movs	r3, #0
 800b462:	9303      	str	r3, [sp, #12]
 800b464:	69fb      	ldr	r3, [r7, #28]
 800b466:	9302      	str	r3, [sp, #8]
 800b468:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b46a:	9301      	str	r3, [sp, #4]
 800b46c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b46e:	9300      	str	r3, [sp, #0]
 800b470:	683b      	ldr	r3, [r7, #0]
 800b472:	68b9      	ldr	r1, [r7, #8]
 800b474:	68f8      	ldr	r0, [r7, #12]
 800b476:	f000 f80f 	bl	800b498 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
 800b47a:	69f8      	ldr	r0, [r7, #28]
 800b47c:	f000 f8ae 	bl	800b5dc <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
 800b480:	2301      	movs	r3, #1
 800b482:	61bb      	str	r3, [r7, #24]
 800b484:	e002      	b.n	800b48c <xTaskCreate+0x78>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 800b486:	f04f 33ff 	mov.w	r3, #4294967295
 800b48a:	61bb      	str	r3, [r7, #24]
		}

		return xReturn;
 800b48c:	69bb      	ldr	r3, [r7, #24]
	}
 800b48e:	4618      	mov	r0, r3
 800b490:	3720      	adds	r7, #32
 800b492:	46bd      	mov	sp, r7
 800b494:	bd80      	pop	{r7, pc}
	...

0800b498 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
 800b498:	b580      	push	{r7, lr}
 800b49a:	b088      	sub	sp, #32
 800b49c:	af00      	add	r7, sp, #0
 800b49e:	60f8      	str	r0, [r7, #12]
 800b4a0:	60b9      	str	r1, [r7, #8]
 800b4a2:	607a      	str	r2, [r7, #4]
 800b4a4:	603b      	str	r3, [r7, #0]
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 800b4a6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b4a8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800b4aa:	6879      	ldr	r1, [r7, #4]
 800b4ac:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
 800b4b0:	440b      	add	r3, r1
 800b4b2:	009b      	lsls	r3, r3, #2
 800b4b4:	4413      	add	r3, r2
 800b4b6:	61bb      	str	r3, [r7, #24]
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 800b4b8:	69bb      	ldr	r3, [r7, #24]
 800b4ba:	f023 0307 	bic.w	r3, r3, #7
 800b4be:	61bb      	str	r3, [r7, #24]

		/* Check the alignment of the calculated top of stack is correct. */
		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
 800b4c0:	69bb      	ldr	r3, [r7, #24]
 800b4c2:	f003 0307 	and.w	r3, r3, #7
 800b4c6:	2b00      	cmp	r3, #0
 800b4c8:	d00a      	beq.n	800b4e0 <prvInitialiseNewTask+0x48>
	__asm volatile
 800b4ca:	f04f 0350 	mov.w	r3, #80	; 0x50
 800b4ce:	f383 8811 	msr	BASEPRI, r3
 800b4d2:	f3bf 8f6f 	isb	sy
 800b4d6:	f3bf 8f4f 	dsb	sy
 800b4da:	617b      	str	r3, [r7, #20]
}
 800b4dc:	bf00      	nop
 800b4de:	e7fe      	b.n	800b4de <prvInitialiseNewTask+0x46>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
 800b4e0:	68bb      	ldr	r3, [r7, #8]
 800b4e2:	2b00      	cmp	r3, #0
 800b4e4:	d01f      	beq.n	800b526 <prvInitialiseNewTask+0x8e>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 800b4e6:	2300      	movs	r3, #0
 800b4e8:	61fb      	str	r3, [r7, #28]
 800b4ea:	e012      	b.n	800b512 <prvInitialiseNewTask+0x7a>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800b4ec:	68ba      	ldr	r2, [r7, #8]
 800b4ee:	69fb      	ldr	r3, [r7, #28]
 800b4f0:	4413      	add	r3, r2
 800b4f2:	7819      	ldrb	r1, [r3, #0]
 800b4f4:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800b4f6:	69fb      	ldr	r3, [r7, #28]
 800b4f8:	4413      	add	r3, r2
 800b4fa:	3334      	adds	r3, #52	; 0x34
 800b4fc:	460a      	mov	r2, r1
 800b4fe:	701a      	strb	r2, [r3, #0]

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
 800b500:	68ba      	ldr	r2, [r7, #8]
 800b502:	69fb      	ldr	r3, [r7, #28]
 800b504:	4413      	add	r3, r2
 800b506:	781b      	ldrb	r3, [r3, #0]
 800b508:	2b00      	cmp	r3, #0
 800b50a:	d006      	beq.n	800b51a <prvInitialiseNewTask+0x82>
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 800b50c:	69fb      	ldr	r3, [r7, #28]
 800b50e:	3301      	adds	r3, #1
 800b510:	61fb      	str	r3, [r7, #28]
 800b512:	69fb      	ldr	r3, [r7, #28]
 800b514:	2b0f      	cmp	r3, #15
 800b516:	d9e9      	bls.n	800b4ec <prvInitialiseNewTask+0x54>
 800b518:	e000      	b.n	800b51c <prvInitialiseNewTask+0x84>
			{
				break;
 800b51a:	bf00      	nop
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 800b51c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b51e:	2200      	movs	r2, #0
 800b520:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
 800b524:	e003      	b.n	800b52e <prvInitialiseNewTask+0x96>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
 800b526:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b528:	2200      	movs	r2, #0
 800b52a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 800b52e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b530:	2b06      	cmp	r3, #6
 800b532:	d901      	bls.n	800b538 <prvInitialiseNewTask+0xa0>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 800b534:	2306      	movs	r3, #6
 800b536:	62bb      	str	r3, [r7, #40]	; 0x28
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
 800b538:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b53a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800b53c:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
 800b53e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b540:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800b542:	645a      	str	r2, [r3, #68]	; 0x44
		pxNewTCB->uxMutexesHeld = 0;
 800b544:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b546:	2200      	movs	r2, #0
 800b548:	649a      	str	r2, [r3, #72]	; 0x48
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 800b54a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b54c:	3304      	adds	r3, #4
 800b54e:	4618      	mov	r0, r3
 800b550:	f7ff f843 	bl	800a5da <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 800b554:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b556:	3318      	adds	r3, #24
 800b558:	4618      	mov	r0, r3
 800b55a:	f7ff f83e 	bl	800a5da <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 800b55e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b560:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800b562:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800b564:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b566:	f1c3 0207 	rsb	r2, r3, #7
 800b56a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b56c:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 800b56e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b570:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800b572:	625a      	str	r2, [r3, #36]	; 0x24
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
 800b574:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b576:	2200      	movs	r2, #0
 800b578:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800b57c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b57e:	2200      	movs	r2, #0
 800b580:	f883 20b0 	strb.w	r2, [r3, #176]	; 0xb0
	#if ( configUSE_NEWLIB_REENTRANT == 1 )
	{
		/* Initialise this task's Newlib reent structure.
		See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
		for additional information. */
		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
 800b584:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b586:	334c      	adds	r3, #76	; 0x4c
 800b588:	2260      	movs	r2, #96	; 0x60
 800b58a:	2100      	movs	r1, #0
 800b58c:	4618      	mov	r0, r3
 800b58e:	f016 fb71 	bl	8021c74 <memset>
 800b592:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b594:	4a0e      	ldr	r2, [pc, #56]	; (800b5d0 <prvInitialiseNewTask+0x138>)
 800b596:	651a      	str	r2, [r3, #80]	; 0x50
 800b598:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b59a:	4a0e      	ldr	r2, [pc, #56]	; (800b5d4 <prvInitialiseNewTask+0x13c>)
 800b59c:	655a      	str	r2, [r3, #84]	; 0x54
 800b59e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b5a0:	4a0d      	ldr	r2, [pc, #52]	; (800b5d8 <prvInitialiseNewTask+0x140>)
 800b5a2:	659a      	str	r2, [r3, #88]	; 0x58
	}
	#endif

	#if( INCLUDE_xTaskAbortDelay == 1 )
	{
		pxNewTCB->ucDelayAborted = pdFALSE;
 800b5a4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b5a6:	2200      	movs	r2, #0
 800b5a8:	f883 20b1 	strb.w	r2, [r3, #177]	; 0xb1
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800b5ac:	683a      	ldr	r2, [r7, #0]
 800b5ae:	68f9      	ldr	r1, [r7, #12]
 800b5b0:	69b8      	ldr	r0, [r7, #24]
 800b5b2:	f001 fab3 	bl	800cb1c <pxPortInitialiseStack>
 800b5b6:	4602      	mov	r2, r0
 800b5b8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b5ba:	601a      	str	r2, [r3, #0]
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
 800b5bc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b5be:	2b00      	cmp	r3, #0
 800b5c0:	d002      	beq.n	800b5c8 <prvInitialiseNewTask+0x130>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 800b5c2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b5c4:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800b5c6:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 800b5c8:	bf00      	nop
 800b5ca:	3720      	adds	r7, #32
 800b5cc:	46bd      	mov	sp, r7
 800b5ce:	bd80      	pop	{r7, pc}
 800b5d0:	080d9dc8 	.word	0x080d9dc8
 800b5d4:	080d9de8 	.word	0x080d9de8
 800b5d8:	080d9da8 	.word	0x080d9da8

0800b5dc <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
 800b5dc:	b580      	push	{r7, lr}
 800b5de:	b082      	sub	sp, #8
 800b5e0:	af00      	add	r7, sp, #0
 800b5e2:	6078      	str	r0, [r7, #4]
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
 800b5e4:	f001 fbc6 	bl	800cd74 <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
 800b5e8:	4b2a      	ldr	r3, [pc, #168]	; (800b694 <prvAddNewTaskToReadyList+0xb8>)
 800b5ea:	681b      	ldr	r3, [r3, #0]
 800b5ec:	3301      	adds	r3, #1
 800b5ee:	4a29      	ldr	r2, [pc, #164]	; (800b694 <prvAddNewTaskToReadyList+0xb8>)
 800b5f0:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
 800b5f2:	4b29      	ldr	r3, [pc, #164]	; (800b698 <prvAddNewTaskToReadyList+0xbc>)
 800b5f4:	681b      	ldr	r3, [r3, #0]
 800b5f6:	2b00      	cmp	r3, #0
 800b5f8:	d109      	bne.n	800b60e <prvAddNewTaskToReadyList+0x32>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
 800b5fa:	4a27      	ldr	r2, [pc, #156]	; (800b698 <prvAddNewTaskToReadyList+0xbc>)
 800b5fc:	687b      	ldr	r3, [r7, #4]
 800b5fe:	6013      	str	r3, [r2, #0]

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 800b600:	4b24      	ldr	r3, [pc, #144]	; (800b694 <prvAddNewTaskToReadyList+0xb8>)
 800b602:	681b      	ldr	r3, [r3, #0]
 800b604:	2b01      	cmp	r3, #1
 800b606:	d110      	bne.n	800b62a <prvAddNewTaskToReadyList+0x4e>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
 800b608:	f000 fc10 	bl	800be2c <prvInitialiseTaskLists>
 800b60c:	e00d      	b.n	800b62a <prvAddNewTaskToReadyList+0x4e>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
 800b60e:	4b23      	ldr	r3, [pc, #140]	; (800b69c <prvAddNewTaskToReadyList+0xc0>)
 800b610:	681b      	ldr	r3, [r3, #0]
 800b612:	2b00      	cmp	r3, #0
 800b614:	d109      	bne.n	800b62a <prvAddNewTaskToReadyList+0x4e>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 800b616:	4b20      	ldr	r3, [pc, #128]	; (800b698 <prvAddNewTaskToReadyList+0xbc>)
 800b618:	681b      	ldr	r3, [r3, #0]
 800b61a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800b61c:	687b      	ldr	r3, [r7, #4]
 800b61e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b620:	429a      	cmp	r2, r3
 800b622:	d802      	bhi.n	800b62a <prvAddNewTaskToReadyList+0x4e>
				{
					pxCurrentTCB = pxNewTCB;
 800b624:	4a1c      	ldr	r2, [pc, #112]	; (800b698 <prvAddNewTaskToReadyList+0xbc>)
 800b626:	687b      	ldr	r3, [r7, #4]
 800b628:	6013      	str	r3, [r2, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
 800b62a:	4b1d      	ldr	r3, [pc, #116]	; (800b6a0 <prvAddNewTaskToReadyList+0xc4>)
 800b62c:	681b      	ldr	r3, [r3, #0]
 800b62e:	3301      	adds	r3, #1
 800b630:	4a1b      	ldr	r2, [pc, #108]	; (800b6a0 <prvAddNewTaskToReadyList+0xc4>)
 800b632:	6013      	str	r3, [r2, #0]
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
 800b634:	687b      	ldr	r3, [r7, #4]
 800b636:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b638:	2201      	movs	r2, #1
 800b63a:	409a      	lsls	r2, r3
 800b63c:	4b19      	ldr	r3, [pc, #100]	; (800b6a4 <prvAddNewTaskToReadyList+0xc8>)
 800b63e:	681b      	ldr	r3, [r3, #0]
 800b640:	4313      	orrs	r3, r2
 800b642:	4a18      	ldr	r2, [pc, #96]	; (800b6a4 <prvAddNewTaskToReadyList+0xc8>)
 800b644:	6013      	str	r3, [r2, #0]
 800b646:	687b      	ldr	r3, [r7, #4]
 800b648:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800b64a:	4613      	mov	r3, r2
 800b64c:	009b      	lsls	r3, r3, #2
 800b64e:	4413      	add	r3, r2
 800b650:	009b      	lsls	r3, r3, #2
 800b652:	4a15      	ldr	r2, [pc, #84]	; (800b6a8 <prvAddNewTaskToReadyList+0xcc>)
 800b654:	441a      	add	r2, r3
 800b656:	687b      	ldr	r3, [r7, #4]
 800b658:	3304      	adds	r3, #4
 800b65a:	4619      	mov	r1, r3
 800b65c:	4610      	mov	r0, r2
 800b65e:	f7fe ffc9 	bl	800a5f4 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
 800b662:	f001 fbb7 	bl	800cdd4 <vPortExitCritical>

	if( xSchedulerRunning != pdFALSE )
 800b666:	4b0d      	ldr	r3, [pc, #52]	; (800b69c <prvAddNewTaskToReadyList+0xc0>)
 800b668:	681b      	ldr	r3, [r3, #0]
 800b66a:	2b00      	cmp	r3, #0
 800b66c:	d00e      	beq.n	800b68c <prvAddNewTaskToReadyList+0xb0>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 800b66e:	4b0a      	ldr	r3, [pc, #40]	; (800b698 <prvAddNewTaskToReadyList+0xbc>)
 800b670:	681b      	ldr	r3, [r3, #0]
 800b672:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800b674:	687b      	ldr	r3, [r7, #4]
 800b676:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b678:	429a      	cmp	r2, r3
 800b67a:	d207      	bcs.n	800b68c <prvAddNewTaskToReadyList+0xb0>
		{
			taskYIELD_IF_USING_PREEMPTION();
 800b67c:	4b0b      	ldr	r3, [pc, #44]	; (800b6ac <prvAddNewTaskToReadyList+0xd0>)
 800b67e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800b682:	601a      	str	r2, [r3, #0]
 800b684:	f3bf 8f4f 	dsb	sy
 800b688:	f3bf 8f6f 	isb	sy
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 800b68c:	bf00      	nop
 800b68e:	3708      	adds	r7, #8
 800b690:	46bd      	mov	sp, r7
 800b692:	bd80      	pop	{r7, pc}
 800b694:	24000364 	.word	0x24000364
 800b698:	24000264 	.word	0x24000264
 800b69c:	24000370 	.word	0x24000370
 800b6a0:	24000380 	.word	0x24000380
 800b6a4:	2400036c 	.word	0x2400036c
 800b6a8:	24000268 	.word	0x24000268
 800b6ac:	e000ed04 	.word	0xe000ed04

0800b6b0 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 800b6b0:	b580      	push	{r7, lr}
 800b6b2:	b084      	sub	sp, #16
 800b6b4:	af00      	add	r7, sp, #0
 800b6b6:	6078      	str	r0, [r7, #4]
	BaseType_t xAlreadyYielded = pdFALSE;
 800b6b8:	2300      	movs	r3, #0
 800b6ba:	60fb      	str	r3, [r7, #12]

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 800b6bc:	687b      	ldr	r3, [r7, #4]
 800b6be:	2b00      	cmp	r3, #0
 800b6c0:	d017      	beq.n	800b6f2 <vTaskDelay+0x42>
		{
			configASSERT( uxSchedulerSuspended == 0 );
 800b6c2:	4b13      	ldr	r3, [pc, #76]	; (800b710 <vTaskDelay+0x60>)
 800b6c4:	681b      	ldr	r3, [r3, #0]
 800b6c6:	2b00      	cmp	r3, #0
 800b6c8:	d00a      	beq.n	800b6e0 <vTaskDelay+0x30>
	__asm volatile
 800b6ca:	f04f 0350 	mov.w	r3, #80	; 0x50
 800b6ce:	f383 8811 	msr	BASEPRI, r3
 800b6d2:	f3bf 8f6f 	isb	sy
 800b6d6:	f3bf 8f4f 	dsb	sy
 800b6da:	60bb      	str	r3, [r7, #8]
}
 800b6dc:	bf00      	nop
 800b6de:	e7fe      	b.n	800b6de <vTaskDelay+0x2e>
			vTaskSuspendAll();
 800b6e0:	f000 f872 	bl	800b7c8 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 800b6e4:	2100      	movs	r1, #0
 800b6e6:	6878      	ldr	r0, [r7, #4]
 800b6e8:	f000 fe00 	bl	800c2ec <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 800b6ec:	f000 f87a 	bl	800b7e4 <xTaskResumeAll>
 800b6f0:	60f8      	str	r0, [r7, #12]
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 800b6f2:	68fb      	ldr	r3, [r7, #12]
 800b6f4:	2b00      	cmp	r3, #0
 800b6f6:	d107      	bne.n	800b708 <vTaskDelay+0x58>
		{
			portYIELD_WITHIN_API();
 800b6f8:	4b06      	ldr	r3, [pc, #24]	; (800b714 <vTaskDelay+0x64>)
 800b6fa:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800b6fe:	601a      	str	r2, [r3, #0]
 800b700:	f3bf 8f4f 	dsb	sy
 800b704:	f3bf 8f6f 	isb	sy
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 800b708:	bf00      	nop
 800b70a:	3710      	adds	r7, #16
 800b70c:	46bd      	mov	sp, r7
 800b70e:	bd80      	pop	{r7, pc}
 800b710:	2400038c 	.word	0x2400038c
 800b714:	e000ed04 	.word	0xe000ed04

0800b718 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 800b718:	b580      	push	{r7, lr}
 800b71a:	b086      	sub	sp, #24
 800b71c:	af02      	add	r7, sp, #8
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
 800b71e:	4b22      	ldr	r3, [pc, #136]	; (800b7a8 <vTaskStartScheduler+0x90>)
 800b720:	9301      	str	r3, [sp, #4]
 800b722:	2300      	movs	r3, #0
 800b724:	9300      	str	r3, [sp, #0]
 800b726:	2300      	movs	r3, #0
 800b728:	f44f 7280 	mov.w	r2, #256	; 0x100
 800b72c:	491f      	ldr	r1, [pc, #124]	; (800b7ac <vTaskStartScheduler+0x94>)
 800b72e:	4820      	ldr	r0, [pc, #128]	; (800b7b0 <vTaskStartScheduler+0x98>)
 800b730:	f7ff fe70 	bl	800b414 <xTaskCreate>
 800b734:	60f8      	str	r0, [r7, #12]
	}
	#endif /* configSUPPORT_STATIC_ALLOCATION */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
 800b736:	68fb      	ldr	r3, [r7, #12]
 800b738:	2b01      	cmp	r3, #1
 800b73a:	d102      	bne.n	800b742 <vTaskStartScheduler+0x2a>
		{
			xReturn = xTimerCreateTimerTask();
 800b73c:	f000 fe40 	bl	800c3c0 <xTimerCreateTimerTask>
 800b740:	60f8      	str	r0, [r7, #12]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 800b742:	68fb      	ldr	r3, [r7, #12]
 800b744:	2b01      	cmp	r3, #1
 800b746:	d11b      	bne.n	800b780 <vTaskStartScheduler+0x68>
	__asm volatile
 800b748:	f04f 0350 	mov.w	r3, #80	; 0x50
 800b74c:	f383 8811 	msr	BASEPRI, r3
 800b750:	f3bf 8f6f 	isb	sy
 800b754:	f3bf 8f4f 	dsb	sy
 800b758:	60bb      	str	r3, [r7, #8]
}
 800b75a:	bf00      	nop
		{
			/* Switch Newlib's _impure_ptr variable to point to the _reent
			structure specific to the task that will run first.
			See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
 800b75c:	4b15      	ldr	r3, [pc, #84]	; (800b7b4 <vTaskStartScheduler+0x9c>)
 800b75e:	681b      	ldr	r3, [r3, #0]
 800b760:	334c      	adds	r3, #76	; 0x4c
 800b762:	4a15      	ldr	r2, [pc, #84]	; (800b7b8 <vTaskStartScheduler+0xa0>)
 800b764:	6013      	str	r3, [r2, #0]
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
 800b766:	4b15      	ldr	r3, [pc, #84]	; (800b7bc <vTaskStartScheduler+0xa4>)
 800b768:	f04f 32ff 	mov.w	r2, #4294967295
 800b76c:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
 800b76e:	4b14      	ldr	r3, [pc, #80]	; (800b7c0 <vTaskStartScheduler+0xa8>)
 800b770:	2201      	movs	r2, #1
 800b772:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 800b774:	4b13      	ldr	r3, [pc, #76]	; (800b7c4 <vTaskStartScheduler+0xac>)
 800b776:	2200      	movs	r2, #0
 800b778:	601a      	str	r2, [r3, #0]

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 800b77a:	f001 fa59 	bl	800cc30 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
 800b77e:	e00e      	b.n	800b79e <vTaskStartScheduler+0x86>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 800b780:	68fb      	ldr	r3, [r7, #12]
 800b782:	f1b3 3fff 	cmp.w	r3, #4294967295
 800b786:	d10a      	bne.n	800b79e <vTaskStartScheduler+0x86>
	__asm volatile
 800b788:	f04f 0350 	mov.w	r3, #80	; 0x50
 800b78c:	f383 8811 	msr	BASEPRI, r3
 800b790:	f3bf 8f6f 	isb	sy
 800b794:	f3bf 8f4f 	dsb	sy
 800b798:	607b      	str	r3, [r7, #4]
}
 800b79a:	bf00      	nop
 800b79c:	e7fe      	b.n	800b79c <vTaskStartScheduler+0x84>
}
 800b79e:	bf00      	nop
 800b7a0:	3710      	adds	r7, #16
 800b7a2:	46bd      	mov	sp, r7
 800b7a4:	bd80      	pop	{r7, pc}
 800b7a6:	bf00      	nop
 800b7a8:	24000388 	.word	0x24000388
 800b7ac:	080225bc 	.word	0x080225bc
 800b7b0:	0800bdfd 	.word	0x0800bdfd
 800b7b4:	24000264 	.word	0x24000264
 800b7b8:	240001e4 	.word	0x240001e4
 800b7bc:	24000384 	.word	0x24000384
 800b7c0:	24000370 	.word	0x24000370
 800b7c4:	24000368 	.word	0x24000368

0800b7c8 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
 800b7c8:	b480      	push	{r7}
 800b7ca:	af00      	add	r7, sp, #0
	do not otherwise exhibit real time behaviour. */
	portSOFTWARE_BARRIER();

	/* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
	is used to allow calls to vTaskSuspendAll() to nest. */
	++uxSchedulerSuspended;
 800b7cc:	4b04      	ldr	r3, [pc, #16]	; (800b7e0 <vTaskSuspendAll+0x18>)
 800b7ce:	681b      	ldr	r3, [r3, #0]
 800b7d0:	3301      	adds	r3, #1
 800b7d2:	4a03      	ldr	r2, [pc, #12]	; (800b7e0 <vTaskSuspendAll+0x18>)
 800b7d4:	6013      	str	r3, [r2, #0]

	/* Enforces ordering for ports and optimised compilers that may otherwise place
	the above increment elsewhere. */
	portMEMORY_BARRIER();
}
 800b7d6:	bf00      	nop
 800b7d8:	46bd      	mov	sp, r7
 800b7da:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b7de:	4770      	bx	lr
 800b7e0:	2400038c 	.word	0x2400038c

0800b7e4 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 800b7e4:	b580      	push	{r7, lr}
 800b7e6:	b084      	sub	sp, #16
 800b7e8:	af00      	add	r7, sp, #0
TCB_t *pxTCB = NULL;
 800b7ea:	2300      	movs	r3, #0
 800b7ec:	60fb      	str	r3, [r7, #12]
BaseType_t xAlreadyYielded = pdFALSE;
 800b7ee:	2300      	movs	r3, #0
 800b7f0:	60bb      	str	r3, [r7, #8]

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
 800b7f2:	4b41      	ldr	r3, [pc, #260]	; (800b8f8 <xTaskResumeAll+0x114>)
 800b7f4:	681b      	ldr	r3, [r3, #0]
 800b7f6:	2b00      	cmp	r3, #0
 800b7f8:	d10a      	bne.n	800b810 <xTaskResumeAll+0x2c>
	__asm volatile
 800b7fa:	f04f 0350 	mov.w	r3, #80	; 0x50
 800b7fe:	f383 8811 	msr	BASEPRI, r3
 800b802:	f3bf 8f6f 	isb	sy
 800b806:	f3bf 8f4f 	dsb	sy
 800b80a:	603b      	str	r3, [r7, #0]
}
 800b80c:	bf00      	nop
 800b80e:	e7fe      	b.n	800b80e <xTaskResumeAll+0x2a>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 800b810:	f001 fab0 	bl	800cd74 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 800b814:	4b38      	ldr	r3, [pc, #224]	; (800b8f8 <xTaskResumeAll+0x114>)
 800b816:	681b      	ldr	r3, [r3, #0]
 800b818:	3b01      	subs	r3, #1
 800b81a:	4a37      	ldr	r2, [pc, #220]	; (800b8f8 <xTaskResumeAll+0x114>)
 800b81c:	6013      	str	r3, [r2, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800b81e:	4b36      	ldr	r3, [pc, #216]	; (800b8f8 <xTaskResumeAll+0x114>)
 800b820:	681b      	ldr	r3, [r3, #0]
 800b822:	2b00      	cmp	r3, #0
 800b824:	d161      	bne.n	800b8ea <xTaskResumeAll+0x106>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 800b826:	4b35      	ldr	r3, [pc, #212]	; (800b8fc <xTaskResumeAll+0x118>)
 800b828:	681b      	ldr	r3, [r3, #0]
 800b82a:	2b00      	cmp	r3, #0
 800b82c:	d05d      	beq.n	800b8ea <xTaskResumeAll+0x106>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 800b82e:	e02e      	b.n	800b88e <xTaskResumeAll+0xaa>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800b830:	4b33      	ldr	r3, [pc, #204]	; (800b900 <xTaskResumeAll+0x11c>)
 800b832:	68db      	ldr	r3, [r3, #12]
 800b834:	68db      	ldr	r3, [r3, #12]
 800b836:	60fb      	str	r3, [r7, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800b838:	68fb      	ldr	r3, [r7, #12]
 800b83a:	3318      	adds	r3, #24
 800b83c:	4618      	mov	r0, r3
 800b83e:	f7fe ff36 	bl	800a6ae <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800b842:	68fb      	ldr	r3, [r7, #12]
 800b844:	3304      	adds	r3, #4
 800b846:	4618      	mov	r0, r3
 800b848:	f7fe ff31 	bl	800a6ae <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800b84c:	68fb      	ldr	r3, [r7, #12]
 800b84e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b850:	2201      	movs	r2, #1
 800b852:	409a      	lsls	r2, r3
 800b854:	4b2b      	ldr	r3, [pc, #172]	; (800b904 <xTaskResumeAll+0x120>)
 800b856:	681b      	ldr	r3, [r3, #0]
 800b858:	4313      	orrs	r3, r2
 800b85a:	4a2a      	ldr	r2, [pc, #168]	; (800b904 <xTaskResumeAll+0x120>)
 800b85c:	6013      	str	r3, [r2, #0]
 800b85e:	68fb      	ldr	r3, [r7, #12]
 800b860:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800b862:	4613      	mov	r3, r2
 800b864:	009b      	lsls	r3, r3, #2
 800b866:	4413      	add	r3, r2
 800b868:	009b      	lsls	r3, r3, #2
 800b86a:	4a27      	ldr	r2, [pc, #156]	; (800b908 <xTaskResumeAll+0x124>)
 800b86c:	441a      	add	r2, r3
 800b86e:	68fb      	ldr	r3, [r7, #12]
 800b870:	3304      	adds	r3, #4
 800b872:	4619      	mov	r1, r3
 800b874:	4610      	mov	r0, r2
 800b876:	f7fe febd 	bl	800a5f4 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800b87a:	68fb      	ldr	r3, [r7, #12]
 800b87c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800b87e:	4b23      	ldr	r3, [pc, #140]	; (800b90c <xTaskResumeAll+0x128>)
 800b880:	681b      	ldr	r3, [r3, #0]
 800b882:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b884:	429a      	cmp	r2, r3
 800b886:	d302      	bcc.n	800b88e <xTaskResumeAll+0xaa>
					{
						xYieldPending = pdTRUE;
 800b888:	4b21      	ldr	r3, [pc, #132]	; (800b910 <xTaskResumeAll+0x12c>)
 800b88a:	2201      	movs	r2, #1
 800b88c:	601a      	str	r2, [r3, #0]
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 800b88e:	4b1c      	ldr	r3, [pc, #112]	; (800b900 <xTaskResumeAll+0x11c>)
 800b890:	681b      	ldr	r3, [r3, #0]
 800b892:	2b00      	cmp	r3, #0
 800b894:	d1cc      	bne.n	800b830 <xTaskResumeAll+0x4c>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
 800b896:	68fb      	ldr	r3, [r7, #12]
 800b898:	2b00      	cmp	r3, #0
 800b89a:	d001      	beq.n	800b8a0 <xTaskResumeAll+0xbc>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
 800b89c:	f000 fb4a 	bl	800bf34 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 800b8a0:	4b1c      	ldr	r3, [pc, #112]	; (800b914 <xTaskResumeAll+0x130>)
 800b8a2:	681b      	ldr	r3, [r3, #0]
 800b8a4:	607b      	str	r3, [r7, #4]

					if( xPendedCounts > ( TickType_t ) 0U )
 800b8a6:	687b      	ldr	r3, [r7, #4]
 800b8a8:	2b00      	cmp	r3, #0
 800b8aa:	d010      	beq.n	800b8ce <xTaskResumeAll+0xea>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
 800b8ac:	f000 f846 	bl	800b93c <xTaskIncrementTick>
 800b8b0:	4603      	mov	r3, r0
 800b8b2:	2b00      	cmp	r3, #0
 800b8b4:	d002      	beq.n	800b8bc <xTaskResumeAll+0xd8>
							{
								xYieldPending = pdTRUE;
 800b8b6:	4b16      	ldr	r3, [pc, #88]	; (800b910 <xTaskResumeAll+0x12c>)
 800b8b8:	2201      	movs	r2, #1
 800b8ba:	601a      	str	r2, [r3, #0]
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--xPendedCounts;
 800b8bc:	687b      	ldr	r3, [r7, #4]
 800b8be:	3b01      	subs	r3, #1
 800b8c0:	607b      	str	r3, [r7, #4]
						} while( xPendedCounts > ( TickType_t ) 0U );
 800b8c2:	687b      	ldr	r3, [r7, #4]
 800b8c4:	2b00      	cmp	r3, #0
 800b8c6:	d1f1      	bne.n	800b8ac <xTaskResumeAll+0xc8>

						xPendedTicks = 0;
 800b8c8:	4b12      	ldr	r3, [pc, #72]	; (800b914 <xTaskResumeAll+0x130>)
 800b8ca:	2200      	movs	r2, #0
 800b8cc:	601a      	str	r2, [r3, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
 800b8ce:	4b10      	ldr	r3, [pc, #64]	; (800b910 <xTaskResumeAll+0x12c>)
 800b8d0:	681b      	ldr	r3, [r3, #0]
 800b8d2:	2b00      	cmp	r3, #0
 800b8d4:	d009      	beq.n	800b8ea <xTaskResumeAll+0x106>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
 800b8d6:	2301      	movs	r3, #1
 800b8d8:	60bb      	str	r3, [r7, #8]
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 800b8da:	4b0f      	ldr	r3, [pc, #60]	; (800b918 <xTaskResumeAll+0x134>)
 800b8dc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800b8e0:	601a      	str	r2, [r3, #0]
 800b8e2:	f3bf 8f4f 	dsb	sy
 800b8e6:	f3bf 8f6f 	isb	sy
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 800b8ea:	f001 fa73 	bl	800cdd4 <vPortExitCritical>

	return xAlreadyYielded;
 800b8ee:	68bb      	ldr	r3, [r7, #8]
}
 800b8f0:	4618      	mov	r0, r3
 800b8f2:	3710      	adds	r7, #16
 800b8f4:	46bd      	mov	sp, r7
 800b8f6:	bd80      	pop	{r7, pc}
 800b8f8:	2400038c 	.word	0x2400038c
 800b8fc:	24000364 	.word	0x24000364
 800b900:	24000324 	.word	0x24000324
 800b904:	2400036c 	.word	0x2400036c
 800b908:	24000268 	.word	0x24000268
 800b90c:	24000264 	.word	0x24000264
 800b910:	24000378 	.word	0x24000378
 800b914:	24000374 	.word	0x24000374
 800b918:	e000ed04 	.word	0xe000ed04

0800b91c <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
 800b91c:	b480      	push	{r7}
 800b91e:	b083      	sub	sp, #12
 800b920:	af00      	add	r7, sp, #0
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
 800b922:	4b05      	ldr	r3, [pc, #20]	; (800b938 <xTaskGetTickCount+0x1c>)
 800b924:	681b      	ldr	r3, [r3, #0]
 800b926:	607b      	str	r3, [r7, #4]
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
 800b928:	687b      	ldr	r3, [r7, #4]
}
 800b92a:	4618      	mov	r0, r3
 800b92c:	370c      	adds	r7, #12
 800b92e:	46bd      	mov	sp, r7
 800b930:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b934:	4770      	bx	lr
 800b936:	bf00      	nop
 800b938:	24000368 	.word	0x24000368

0800b93c <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 800b93c:	b580      	push	{r7, lr}
 800b93e:	b086      	sub	sp, #24
 800b940:	af00      	add	r7, sp, #0
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 800b942:	2300      	movs	r3, #0
 800b944:	617b      	str	r3, [r7, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800b946:	4b4e      	ldr	r3, [pc, #312]	; (800ba80 <xTaskIncrementTick+0x144>)
 800b948:	681b      	ldr	r3, [r3, #0]
 800b94a:	2b00      	cmp	r3, #0
 800b94c:	f040 808e 	bne.w	800ba6c <xTaskIncrementTick+0x130>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 800b950:	4b4c      	ldr	r3, [pc, #304]	; (800ba84 <xTaskIncrementTick+0x148>)
 800b952:	681b      	ldr	r3, [r3, #0]
 800b954:	3301      	adds	r3, #1
 800b956:	613b      	str	r3, [r7, #16]

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
 800b958:	4a4a      	ldr	r2, [pc, #296]	; (800ba84 <xTaskIncrementTick+0x148>)
 800b95a:	693b      	ldr	r3, [r7, #16]
 800b95c:	6013      	str	r3, [r2, #0]

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 800b95e:	693b      	ldr	r3, [r7, #16]
 800b960:	2b00      	cmp	r3, #0
 800b962:	d120      	bne.n	800b9a6 <xTaskIncrementTick+0x6a>
		{
			taskSWITCH_DELAYED_LISTS();
 800b964:	4b48      	ldr	r3, [pc, #288]	; (800ba88 <xTaskIncrementTick+0x14c>)
 800b966:	681b      	ldr	r3, [r3, #0]
 800b968:	681b      	ldr	r3, [r3, #0]
 800b96a:	2b00      	cmp	r3, #0
 800b96c:	d00a      	beq.n	800b984 <xTaskIncrementTick+0x48>
	__asm volatile
 800b96e:	f04f 0350 	mov.w	r3, #80	; 0x50
 800b972:	f383 8811 	msr	BASEPRI, r3
 800b976:	f3bf 8f6f 	isb	sy
 800b97a:	f3bf 8f4f 	dsb	sy
 800b97e:	603b      	str	r3, [r7, #0]
}
 800b980:	bf00      	nop
 800b982:	e7fe      	b.n	800b982 <xTaskIncrementTick+0x46>
 800b984:	4b40      	ldr	r3, [pc, #256]	; (800ba88 <xTaskIncrementTick+0x14c>)
 800b986:	681b      	ldr	r3, [r3, #0]
 800b988:	60fb      	str	r3, [r7, #12]
 800b98a:	4b40      	ldr	r3, [pc, #256]	; (800ba8c <xTaskIncrementTick+0x150>)
 800b98c:	681b      	ldr	r3, [r3, #0]
 800b98e:	4a3e      	ldr	r2, [pc, #248]	; (800ba88 <xTaskIncrementTick+0x14c>)
 800b990:	6013      	str	r3, [r2, #0]
 800b992:	4a3e      	ldr	r2, [pc, #248]	; (800ba8c <xTaskIncrementTick+0x150>)
 800b994:	68fb      	ldr	r3, [r7, #12]
 800b996:	6013      	str	r3, [r2, #0]
 800b998:	4b3d      	ldr	r3, [pc, #244]	; (800ba90 <xTaskIncrementTick+0x154>)
 800b99a:	681b      	ldr	r3, [r3, #0]
 800b99c:	3301      	adds	r3, #1
 800b99e:	4a3c      	ldr	r2, [pc, #240]	; (800ba90 <xTaskIncrementTick+0x154>)
 800b9a0:	6013      	str	r3, [r2, #0]
 800b9a2:	f000 fac7 	bl	800bf34 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
 800b9a6:	4b3b      	ldr	r3, [pc, #236]	; (800ba94 <xTaskIncrementTick+0x158>)
 800b9a8:	681b      	ldr	r3, [r3, #0]
 800b9aa:	693a      	ldr	r2, [r7, #16]
 800b9ac:	429a      	cmp	r2, r3
 800b9ae:	d348      	bcc.n	800ba42 <xTaskIncrementTick+0x106>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800b9b0:	4b35      	ldr	r3, [pc, #212]	; (800ba88 <xTaskIncrementTick+0x14c>)
 800b9b2:	681b      	ldr	r3, [r3, #0]
 800b9b4:	681b      	ldr	r3, [r3, #0]
 800b9b6:	2b00      	cmp	r3, #0
 800b9b8:	d104      	bne.n	800b9c4 <xTaskIncrementTick+0x88>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800b9ba:	4b36      	ldr	r3, [pc, #216]	; (800ba94 <xTaskIncrementTick+0x158>)
 800b9bc:	f04f 32ff 	mov.w	r2, #4294967295
 800b9c0:	601a      	str	r2, [r3, #0]
					break;
 800b9c2:	e03e      	b.n	800ba42 <xTaskIncrementTick+0x106>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800b9c4:	4b30      	ldr	r3, [pc, #192]	; (800ba88 <xTaskIncrementTick+0x14c>)
 800b9c6:	681b      	ldr	r3, [r3, #0]
 800b9c8:	68db      	ldr	r3, [r3, #12]
 800b9ca:	68db      	ldr	r3, [r3, #12]
 800b9cc:	60bb      	str	r3, [r7, #8]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 800b9ce:	68bb      	ldr	r3, [r7, #8]
 800b9d0:	685b      	ldr	r3, [r3, #4]
 800b9d2:	607b      	str	r3, [r7, #4]

					if( xConstTickCount < xItemValue )
 800b9d4:	693a      	ldr	r2, [r7, #16]
 800b9d6:	687b      	ldr	r3, [r7, #4]
 800b9d8:	429a      	cmp	r2, r3
 800b9da:	d203      	bcs.n	800b9e4 <xTaskIncrementTick+0xa8>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
 800b9dc:	4a2d      	ldr	r2, [pc, #180]	; (800ba94 <xTaskIncrementTick+0x158>)
 800b9de:	687b      	ldr	r3, [r7, #4]
 800b9e0:	6013      	str	r3, [r2, #0]
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
 800b9e2:	e02e      	b.n	800ba42 <xTaskIncrementTick+0x106>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800b9e4:	68bb      	ldr	r3, [r7, #8]
 800b9e6:	3304      	adds	r3, #4
 800b9e8:	4618      	mov	r0, r3
 800b9ea:	f7fe fe60 	bl	800a6ae <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800b9ee:	68bb      	ldr	r3, [r7, #8]
 800b9f0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b9f2:	2b00      	cmp	r3, #0
 800b9f4:	d004      	beq.n	800ba00 <xTaskIncrementTick+0xc4>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800b9f6:	68bb      	ldr	r3, [r7, #8]
 800b9f8:	3318      	adds	r3, #24
 800b9fa:	4618      	mov	r0, r3
 800b9fc:	f7fe fe57 	bl	800a6ae <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
 800ba00:	68bb      	ldr	r3, [r7, #8]
 800ba02:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800ba04:	2201      	movs	r2, #1
 800ba06:	409a      	lsls	r2, r3
 800ba08:	4b23      	ldr	r3, [pc, #140]	; (800ba98 <xTaskIncrementTick+0x15c>)
 800ba0a:	681b      	ldr	r3, [r3, #0]
 800ba0c:	4313      	orrs	r3, r2
 800ba0e:	4a22      	ldr	r2, [pc, #136]	; (800ba98 <xTaskIncrementTick+0x15c>)
 800ba10:	6013      	str	r3, [r2, #0]
 800ba12:	68bb      	ldr	r3, [r7, #8]
 800ba14:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800ba16:	4613      	mov	r3, r2
 800ba18:	009b      	lsls	r3, r3, #2
 800ba1a:	4413      	add	r3, r2
 800ba1c:	009b      	lsls	r3, r3, #2
 800ba1e:	4a1f      	ldr	r2, [pc, #124]	; (800ba9c <xTaskIncrementTick+0x160>)
 800ba20:	441a      	add	r2, r3
 800ba22:	68bb      	ldr	r3, [r7, #8]
 800ba24:	3304      	adds	r3, #4
 800ba26:	4619      	mov	r1, r3
 800ba28:	4610      	mov	r0, r2
 800ba2a:	f7fe fde3 	bl	800a5f4 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800ba2e:	68bb      	ldr	r3, [r7, #8]
 800ba30:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800ba32:	4b1b      	ldr	r3, [pc, #108]	; (800baa0 <xTaskIncrementTick+0x164>)
 800ba34:	681b      	ldr	r3, [r3, #0]
 800ba36:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800ba38:	429a      	cmp	r2, r3
 800ba3a:	d3b9      	bcc.n	800b9b0 <xTaskIncrementTick+0x74>
						{
							xSwitchRequired = pdTRUE;
 800ba3c:	2301      	movs	r3, #1
 800ba3e:	617b      	str	r3, [r7, #20]
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800ba40:	e7b6      	b.n	800b9b0 <xTaskIncrementTick+0x74>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 800ba42:	4b17      	ldr	r3, [pc, #92]	; (800baa0 <xTaskIncrementTick+0x164>)
 800ba44:	681b      	ldr	r3, [r3, #0]
 800ba46:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800ba48:	4914      	ldr	r1, [pc, #80]	; (800ba9c <xTaskIncrementTick+0x160>)
 800ba4a:	4613      	mov	r3, r2
 800ba4c:	009b      	lsls	r3, r3, #2
 800ba4e:	4413      	add	r3, r2
 800ba50:	009b      	lsls	r3, r3, #2
 800ba52:	440b      	add	r3, r1
 800ba54:	681b      	ldr	r3, [r3, #0]
 800ba56:	2b01      	cmp	r3, #1
 800ba58:	d901      	bls.n	800ba5e <xTaskIncrementTick+0x122>
			{
				xSwitchRequired = pdTRUE;
 800ba5a:	2301      	movs	r3, #1
 800ba5c:	617b      	str	r3, [r7, #20]
		}
		#endif /* configUSE_TICK_HOOK */

		#if ( configUSE_PREEMPTION == 1 )
		{
			if( xYieldPending != pdFALSE )
 800ba5e:	4b11      	ldr	r3, [pc, #68]	; (800baa4 <xTaskIncrementTick+0x168>)
 800ba60:	681b      	ldr	r3, [r3, #0]
 800ba62:	2b00      	cmp	r3, #0
 800ba64:	d007      	beq.n	800ba76 <xTaskIncrementTick+0x13a>
			{
				xSwitchRequired = pdTRUE;
 800ba66:	2301      	movs	r3, #1
 800ba68:	617b      	str	r3, [r7, #20]
 800ba6a:	e004      	b.n	800ba76 <xTaskIncrementTick+0x13a>
		}
		#endif /* configUSE_PREEMPTION */
	}
	else
	{
		++xPendedTicks;
 800ba6c:	4b0e      	ldr	r3, [pc, #56]	; (800baa8 <xTaskIncrementTick+0x16c>)
 800ba6e:	681b      	ldr	r3, [r3, #0]
 800ba70:	3301      	adds	r3, #1
 800ba72:	4a0d      	ldr	r2, [pc, #52]	; (800baa8 <xTaskIncrementTick+0x16c>)
 800ba74:	6013      	str	r3, [r2, #0]
			vApplicationTickHook();
		}
		#endif
	}

	return xSwitchRequired;
 800ba76:	697b      	ldr	r3, [r7, #20]
}
 800ba78:	4618      	mov	r0, r3
 800ba7a:	3718      	adds	r7, #24
 800ba7c:	46bd      	mov	sp, r7
 800ba7e:	bd80      	pop	{r7, pc}
 800ba80:	2400038c 	.word	0x2400038c
 800ba84:	24000368 	.word	0x24000368
 800ba88:	2400031c 	.word	0x2400031c
 800ba8c:	24000320 	.word	0x24000320
 800ba90:	2400037c 	.word	0x2400037c
 800ba94:	24000384 	.word	0x24000384
 800ba98:	2400036c 	.word	0x2400036c
 800ba9c:	24000268 	.word	0x24000268
 800baa0:	24000264 	.word	0x24000264
 800baa4:	24000378 	.word	0x24000378
 800baa8:	24000374 	.word	0x24000374

0800baac <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 800baac:	b480      	push	{r7}
 800baae:	b087      	sub	sp, #28
 800bab0:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 800bab2:	4b29      	ldr	r3, [pc, #164]	; (800bb58 <vTaskSwitchContext+0xac>)
 800bab4:	681b      	ldr	r3, [r3, #0]
 800bab6:	2b00      	cmp	r3, #0
 800bab8:	d003      	beq.n	800bac2 <vTaskSwitchContext+0x16>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 800baba:	4b28      	ldr	r3, [pc, #160]	; (800bb5c <vTaskSwitchContext+0xb0>)
 800babc:	2201      	movs	r2, #1
 800babe:	601a      	str	r2, [r3, #0]
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
 800bac0:	e044      	b.n	800bb4c <vTaskSwitchContext+0xa0>
		xYieldPending = pdFALSE;
 800bac2:	4b26      	ldr	r3, [pc, #152]	; (800bb5c <vTaskSwitchContext+0xb0>)
 800bac4:	2200      	movs	r2, #0
 800bac6:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800bac8:	4b25      	ldr	r3, [pc, #148]	; (800bb60 <vTaskSwitchContext+0xb4>)
 800baca:	681b      	ldr	r3, [r3, #0]
 800bacc:	60fb      	str	r3, [r7, #12]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 800bace:	68fb      	ldr	r3, [r7, #12]
 800bad0:	fab3 f383 	clz	r3, r3
 800bad4:	72fb      	strb	r3, [r7, #11]
		return ucReturn;
 800bad6:	7afb      	ldrb	r3, [r7, #11]
 800bad8:	f1c3 031f 	rsb	r3, r3, #31
 800badc:	617b      	str	r3, [r7, #20]
 800bade:	4921      	ldr	r1, [pc, #132]	; (800bb64 <vTaskSwitchContext+0xb8>)
 800bae0:	697a      	ldr	r2, [r7, #20]
 800bae2:	4613      	mov	r3, r2
 800bae4:	009b      	lsls	r3, r3, #2
 800bae6:	4413      	add	r3, r2
 800bae8:	009b      	lsls	r3, r3, #2
 800baea:	440b      	add	r3, r1
 800baec:	681b      	ldr	r3, [r3, #0]
 800baee:	2b00      	cmp	r3, #0
 800baf0:	d10a      	bne.n	800bb08 <vTaskSwitchContext+0x5c>
	__asm volatile
 800baf2:	f04f 0350 	mov.w	r3, #80	; 0x50
 800baf6:	f383 8811 	msr	BASEPRI, r3
 800bafa:	f3bf 8f6f 	isb	sy
 800bafe:	f3bf 8f4f 	dsb	sy
 800bb02:	607b      	str	r3, [r7, #4]
}
 800bb04:	bf00      	nop
 800bb06:	e7fe      	b.n	800bb06 <vTaskSwitchContext+0x5a>
 800bb08:	697a      	ldr	r2, [r7, #20]
 800bb0a:	4613      	mov	r3, r2
 800bb0c:	009b      	lsls	r3, r3, #2
 800bb0e:	4413      	add	r3, r2
 800bb10:	009b      	lsls	r3, r3, #2
 800bb12:	4a14      	ldr	r2, [pc, #80]	; (800bb64 <vTaskSwitchContext+0xb8>)
 800bb14:	4413      	add	r3, r2
 800bb16:	613b      	str	r3, [r7, #16]
 800bb18:	693b      	ldr	r3, [r7, #16]
 800bb1a:	685b      	ldr	r3, [r3, #4]
 800bb1c:	685a      	ldr	r2, [r3, #4]
 800bb1e:	693b      	ldr	r3, [r7, #16]
 800bb20:	605a      	str	r2, [r3, #4]
 800bb22:	693b      	ldr	r3, [r7, #16]
 800bb24:	685a      	ldr	r2, [r3, #4]
 800bb26:	693b      	ldr	r3, [r7, #16]
 800bb28:	3308      	adds	r3, #8
 800bb2a:	429a      	cmp	r2, r3
 800bb2c:	d104      	bne.n	800bb38 <vTaskSwitchContext+0x8c>
 800bb2e:	693b      	ldr	r3, [r7, #16]
 800bb30:	685b      	ldr	r3, [r3, #4]
 800bb32:	685a      	ldr	r2, [r3, #4]
 800bb34:	693b      	ldr	r3, [r7, #16]
 800bb36:	605a      	str	r2, [r3, #4]
 800bb38:	693b      	ldr	r3, [r7, #16]
 800bb3a:	685b      	ldr	r3, [r3, #4]
 800bb3c:	68db      	ldr	r3, [r3, #12]
 800bb3e:	4a0a      	ldr	r2, [pc, #40]	; (800bb68 <vTaskSwitchContext+0xbc>)
 800bb40:	6013      	str	r3, [r2, #0]
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
 800bb42:	4b09      	ldr	r3, [pc, #36]	; (800bb68 <vTaskSwitchContext+0xbc>)
 800bb44:	681b      	ldr	r3, [r3, #0]
 800bb46:	334c      	adds	r3, #76	; 0x4c
 800bb48:	4a08      	ldr	r2, [pc, #32]	; (800bb6c <vTaskSwitchContext+0xc0>)
 800bb4a:	6013      	str	r3, [r2, #0]
}
 800bb4c:	bf00      	nop
 800bb4e:	371c      	adds	r7, #28
 800bb50:	46bd      	mov	sp, r7
 800bb52:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bb56:	4770      	bx	lr
 800bb58:	2400038c 	.word	0x2400038c
 800bb5c:	24000378 	.word	0x24000378
 800bb60:	2400036c 	.word	0x2400036c
 800bb64:	24000268 	.word	0x24000268
 800bb68:	24000264 	.word	0x24000264
 800bb6c:	240001e4 	.word	0x240001e4

0800bb70 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
 800bb70:	b580      	push	{r7, lr}
 800bb72:	b084      	sub	sp, #16
 800bb74:	af00      	add	r7, sp, #0
 800bb76:	6078      	str	r0, [r7, #4]
 800bb78:	6039      	str	r1, [r7, #0]
	configASSERT( pxEventList );
 800bb7a:	687b      	ldr	r3, [r7, #4]
 800bb7c:	2b00      	cmp	r3, #0
 800bb7e:	d10a      	bne.n	800bb96 <vTaskPlaceOnEventList+0x26>
	__asm volatile
 800bb80:	f04f 0350 	mov.w	r3, #80	; 0x50
 800bb84:	f383 8811 	msr	BASEPRI, r3
 800bb88:	f3bf 8f6f 	isb	sy
 800bb8c:	f3bf 8f4f 	dsb	sy
 800bb90:	60fb      	str	r3, [r7, #12]
}
 800bb92:	bf00      	nop
 800bb94:	e7fe      	b.n	800bb94 <vTaskPlaceOnEventList+0x24>

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 800bb96:	4b07      	ldr	r3, [pc, #28]	; (800bbb4 <vTaskPlaceOnEventList+0x44>)
 800bb98:	681b      	ldr	r3, [r3, #0]
 800bb9a:	3318      	adds	r3, #24
 800bb9c:	4619      	mov	r1, r3
 800bb9e:	6878      	ldr	r0, [r7, #4]
 800bba0:	f7fe fd4c 	bl	800a63c <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 800bba4:	2101      	movs	r1, #1
 800bba6:	6838      	ldr	r0, [r7, #0]
 800bba8:	f000 fba0 	bl	800c2ec <prvAddCurrentTaskToDelayedList>
}
 800bbac:	bf00      	nop
 800bbae:	3710      	adds	r7, #16
 800bbb0:	46bd      	mov	sp, r7
 800bbb2:	bd80      	pop	{r7, pc}
 800bbb4:	24000264 	.word	0x24000264

0800bbb8 <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if( configUSE_TIMERS == 1 )

	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 800bbb8:	b580      	push	{r7, lr}
 800bbba:	b086      	sub	sp, #24
 800bbbc:	af00      	add	r7, sp, #0
 800bbbe:	60f8      	str	r0, [r7, #12]
 800bbc0:	60b9      	str	r1, [r7, #8]
 800bbc2:	607a      	str	r2, [r7, #4]
		configASSERT( pxEventList );
 800bbc4:	68fb      	ldr	r3, [r7, #12]
 800bbc6:	2b00      	cmp	r3, #0
 800bbc8:	d10a      	bne.n	800bbe0 <vTaskPlaceOnEventListRestricted+0x28>
	__asm volatile
 800bbca:	f04f 0350 	mov.w	r3, #80	; 0x50
 800bbce:	f383 8811 	msr	BASEPRI, r3
 800bbd2:	f3bf 8f6f 	isb	sy
 800bbd6:	f3bf 8f4f 	dsb	sy
 800bbda:	617b      	str	r3, [r7, #20]
}
 800bbdc:	bf00      	nop
 800bbde:	e7fe      	b.n	800bbde <vTaskPlaceOnEventListRestricted+0x26>

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 800bbe0:	4b0a      	ldr	r3, [pc, #40]	; (800bc0c <vTaskPlaceOnEventListRestricted+0x54>)
 800bbe2:	681b      	ldr	r3, [r3, #0]
 800bbe4:	3318      	adds	r3, #24
 800bbe6:	4619      	mov	r1, r3
 800bbe8:	68f8      	ldr	r0, [r7, #12]
 800bbea:	f7fe fd03 	bl	800a5f4 <vListInsertEnd>

		/* If the task should block indefinitely then set the block time to a
		value that will be recognised as an indefinite delay inside the
		prvAddCurrentTaskToDelayedList() function. */
		if( xWaitIndefinitely != pdFALSE )
 800bbee:	687b      	ldr	r3, [r7, #4]
 800bbf0:	2b00      	cmp	r3, #0
 800bbf2:	d002      	beq.n	800bbfa <vTaskPlaceOnEventListRestricted+0x42>
		{
			xTicksToWait = portMAX_DELAY;
 800bbf4:	f04f 33ff 	mov.w	r3, #4294967295
 800bbf8:	60bb      	str	r3, [r7, #8]
		}

		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 800bbfa:	6879      	ldr	r1, [r7, #4]
 800bbfc:	68b8      	ldr	r0, [r7, #8]
 800bbfe:	f000 fb75 	bl	800c2ec <prvAddCurrentTaskToDelayedList>
	}
 800bc02:	bf00      	nop
 800bc04:	3718      	adds	r7, #24
 800bc06:	46bd      	mov	sp, r7
 800bc08:	bd80      	pop	{r7, pc}
 800bc0a:	bf00      	nop
 800bc0c:	24000264 	.word	0x24000264

0800bc10 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
 800bc10:	b580      	push	{r7, lr}
 800bc12:	b086      	sub	sp, #24
 800bc14:	af00      	add	r7, sp, #0
 800bc16:	6078      	str	r0, [r7, #4]
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800bc18:	687b      	ldr	r3, [r7, #4]
 800bc1a:	68db      	ldr	r3, [r3, #12]
 800bc1c:	68db      	ldr	r3, [r3, #12]
 800bc1e:	613b      	str	r3, [r7, #16]
	configASSERT( pxUnblockedTCB );
 800bc20:	693b      	ldr	r3, [r7, #16]
 800bc22:	2b00      	cmp	r3, #0
 800bc24:	d10a      	bne.n	800bc3c <xTaskRemoveFromEventList+0x2c>
	__asm volatile
 800bc26:	f04f 0350 	mov.w	r3, #80	; 0x50
 800bc2a:	f383 8811 	msr	BASEPRI, r3
 800bc2e:	f3bf 8f6f 	isb	sy
 800bc32:	f3bf 8f4f 	dsb	sy
 800bc36:	60fb      	str	r3, [r7, #12]
}
 800bc38:	bf00      	nop
 800bc3a:	e7fe      	b.n	800bc3a <xTaskRemoveFromEventList+0x2a>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 800bc3c:	693b      	ldr	r3, [r7, #16]
 800bc3e:	3318      	adds	r3, #24
 800bc40:	4618      	mov	r0, r3
 800bc42:	f7fe fd34 	bl	800a6ae <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800bc46:	4b1d      	ldr	r3, [pc, #116]	; (800bcbc <xTaskRemoveFromEventList+0xac>)
 800bc48:	681b      	ldr	r3, [r3, #0]
 800bc4a:	2b00      	cmp	r3, #0
 800bc4c:	d11c      	bne.n	800bc88 <xTaskRemoveFromEventList+0x78>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 800bc4e:	693b      	ldr	r3, [r7, #16]
 800bc50:	3304      	adds	r3, #4
 800bc52:	4618      	mov	r0, r3
 800bc54:	f7fe fd2b 	bl	800a6ae <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 800bc58:	693b      	ldr	r3, [r7, #16]
 800bc5a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800bc5c:	2201      	movs	r2, #1
 800bc5e:	409a      	lsls	r2, r3
 800bc60:	4b17      	ldr	r3, [pc, #92]	; (800bcc0 <xTaskRemoveFromEventList+0xb0>)
 800bc62:	681b      	ldr	r3, [r3, #0]
 800bc64:	4313      	orrs	r3, r2
 800bc66:	4a16      	ldr	r2, [pc, #88]	; (800bcc0 <xTaskRemoveFromEventList+0xb0>)
 800bc68:	6013      	str	r3, [r2, #0]
 800bc6a:	693b      	ldr	r3, [r7, #16]
 800bc6c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800bc6e:	4613      	mov	r3, r2
 800bc70:	009b      	lsls	r3, r3, #2
 800bc72:	4413      	add	r3, r2
 800bc74:	009b      	lsls	r3, r3, #2
 800bc76:	4a13      	ldr	r2, [pc, #76]	; (800bcc4 <xTaskRemoveFromEventList+0xb4>)
 800bc78:	441a      	add	r2, r3
 800bc7a:	693b      	ldr	r3, [r7, #16]
 800bc7c:	3304      	adds	r3, #4
 800bc7e:	4619      	mov	r1, r3
 800bc80:	4610      	mov	r0, r2
 800bc82:	f7fe fcb7 	bl	800a5f4 <vListInsertEnd>
 800bc86:	e005      	b.n	800bc94 <xTaskRemoveFromEventList+0x84>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 800bc88:	693b      	ldr	r3, [r7, #16]
 800bc8a:	3318      	adds	r3, #24
 800bc8c:	4619      	mov	r1, r3
 800bc8e:	480e      	ldr	r0, [pc, #56]	; (800bcc8 <xTaskRemoveFromEventList+0xb8>)
 800bc90:	f7fe fcb0 	bl	800a5f4 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 800bc94:	693b      	ldr	r3, [r7, #16]
 800bc96:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800bc98:	4b0c      	ldr	r3, [pc, #48]	; (800bccc <xTaskRemoveFromEventList+0xbc>)
 800bc9a:	681b      	ldr	r3, [r3, #0]
 800bc9c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800bc9e:	429a      	cmp	r2, r3
 800bca0:	d905      	bls.n	800bcae <xTaskRemoveFromEventList+0x9e>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
 800bca2:	2301      	movs	r3, #1
 800bca4:	617b      	str	r3, [r7, #20]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
 800bca6:	4b0a      	ldr	r3, [pc, #40]	; (800bcd0 <xTaskRemoveFromEventList+0xc0>)
 800bca8:	2201      	movs	r2, #1
 800bcaa:	601a      	str	r2, [r3, #0]
 800bcac:	e001      	b.n	800bcb2 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		xReturn = pdFALSE;
 800bcae:	2300      	movs	r3, #0
 800bcb0:	617b      	str	r3, [r7, #20]
	}

	return xReturn;
 800bcb2:	697b      	ldr	r3, [r7, #20]
}
 800bcb4:	4618      	mov	r0, r3
 800bcb6:	3718      	adds	r7, #24
 800bcb8:	46bd      	mov	sp, r7
 800bcba:	bd80      	pop	{r7, pc}
 800bcbc:	2400038c 	.word	0x2400038c
 800bcc0:	2400036c 	.word	0x2400036c
 800bcc4:	24000268 	.word	0x24000268
 800bcc8:	24000324 	.word	0x24000324
 800bccc:	24000264 	.word	0x24000264
 800bcd0:	24000378 	.word	0x24000378

0800bcd4 <vTaskInternalSetTimeOutState>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 800bcd4:	b480      	push	{r7}
 800bcd6:	b083      	sub	sp, #12
 800bcd8:	af00      	add	r7, sp, #0
 800bcda:	6078      	str	r0, [r7, #4]
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 800bcdc:	4b06      	ldr	r3, [pc, #24]	; (800bcf8 <vTaskInternalSetTimeOutState+0x24>)
 800bcde:	681a      	ldr	r2, [r3, #0]
 800bce0:	687b      	ldr	r3, [r7, #4]
 800bce2:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 800bce4:	4b05      	ldr	r3, [pc, #20]	; (800bcfc <vTaskInternalSetTimeOutState+0x28>)
 800bce6:	681a      	ldr	r2, [r3, #0]
 800bce8:	687b      	ldr	r3, [r7, #4]
 800bcea:	605a      	str	r2, [r3, #4]
}
 800bcec:	bf00      	nop
 800bcee:	370c      	adds	r7, #12
 800bcf0:	46bd      	mov	sp, r7
 800bcf2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bcf6:	4770      	bx	lr
 800bcf8:	2400037c 	.word	0x2400037c
 800bcfc:	24000368 	.word	0x24000368

0800bd00 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
 800bd00:	b580      	push	{r7, lr}
 800bd02:	b088      	sub	sp, #32
 800bd04:	af00      	add	r7, sp, #0
 800bd06:	6078      	str	r0, [r7, #4]
 800bd08:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;

	configASSERT( pxTimeOut );
 800bd0a:	687b      	ldr	r3, [r7, #4]
 800bd0c:	2b00      	cmp	r3, #0
 800bd0e:	d10a      	bne.n	800bd26 <xTaskCheckForTimeOut+0x26>
	__asm volatile
 800bd10:	f04f 0350 	mov.w	r3, #80	; 0x50
 800bd14:	f383 8811 	msr	BASEPRI, r3
 800bd18:	f3bf 8f6f 	isb	sy
 800bd1c:	f3bf 8f4f 	dsb	sy
 800bd20:	613b      	str	r3, [r7, #16]
}
 800bd22:	bf00      	nop
 800bd24:	e7fe      	b.n	800bd24 <xTaskCheckForTimeOut+0x24>
	configASSERT( pxTicksToWait );
 800bd26:	683b      	ldr	r3, [r7, #0]
 800bd28:	2b00      	cmp	r3, #0
 800bd2a:	d10a      	bne.n	800bd42 <xTaskCheckForTimeOut+0x42>
	__asm volatile
 800bd2c:	f04f 0350 	mov.w	r3, #80	; 0x50
 800bd30:	f383 8811 	msr	BASEPRI, r3
 800bd34:	f3bf 8f6f 	isb	sy
 800bd38:	f3bf 8f4f 	dsb	sy
 800bd3c:	60fb      	str	r3, [r7, #12]
}
 800bd3e:	bf00      	nop
 800bd40:	e7fe      	b.n	800bd40 <xTaskCheckForTimeOut+0x40>

	taskENTER_CRITICAL();
 800bd42:	f001 f817 	bl	800cd74 <vPortEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
 800bd46:	4b24      	ldr	r3, [pc, #144]	; (800bdd8 <xTaskCheckForTimeOut+0xd8>)
 800bd48:	681b      	ldr	r3, [r3, #0]
 800bd4a:	61bb      	str	r3, [r7, #24]
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 800bd4c:	687b      	ldr	r3, [r7, #4]
 800bd4e:	685b      	ldr	r3, [r3, #4]
 800bd50:	69ba      	ldr	r2, [r7, #24]
 800bd52:	1ad3      	subs	r3, r2, r3
 800bd54:	617b      	str	r3, [r7, #20]

		#if( INCLUDE_xTaskAbortDelay == 1 )
			if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
 800bd56:	4b21      	ldr	r3, [pc, #132]	; (800bddc <xTaskCheckForTimeOut+0xdc>)
 800bd58:	681b      	ldr	r3, [r3, #0]
 800bd5a:	f893 30b1 	ldrb.w	r3, [r3, #177]	; 0xb1
 800bd5e:	2b00      	cmp	r3, #0
 800bd60:	d007      	beq.n	800bd72 <xTaskCheckForTimeOut+0x72>
			{
				/* The delay was aborted, which is not the same as a time out,
				but has the same result. */
				pxCurrentTCB->ucDelayAborted = pdFALSE;
 800bd62:	4b1e      	ldr	r3, [pc, #120]	; (800bddc <xTaskCheckForTimeOut+0xdc>)
 800bd64:	681b      	ldr	r3, [r3, #0]
 800bd66:	2200      	movs	r2, #0
 800bd68:	f883 20b1 	strb.w	r2, [r3, #177]	; 0xb1
				xReturn = pdTRUE;
 800bd6c:	2301      	movs	r3, #1
 800bd6e:	61fb      	str	r3, [r7, #28]
 800bd70:	e02b      	b.n	800bdca <xTaskCheckForTimeOut+0xca>
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
 800bd72:	683b      	ldr	r3, [r7, #0]
 800bd74:	681b      	ldr	r3, [r3, #0]
 800bd76:	f1b3 3fff 	cmp.w	r3, #4294967295
 800bd7a:	d102      	bne.n	800bd82 <xTaskCheckForTimeOut+0x82>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
 800bd7c:	2300      	movs	r3, #0
 800bd7e:	61fb      	str	r3, [r7, #28]
 800bd80:	e023      	b.n	800bdca <xTaskCheckForTimeOut+0xca>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 800bd82:	687b      	ldr	r3, [r7, #4]
 800bd84:	681a      	ldr	r2, [r3, #0]
 800bd86:	4b16      	ldr	r3, [pc, #88]	; (800bde0 <xTaskCheckForTimeOut+0xe0>)
 800bd88:	681b      	ldr	r3, [r3, #0]
 800bd8a:	429a      	cmp	r2, r3
 800bd8c:	d007      	beq.n	800bd9e <xTaskCheckForTimeOut+0x9e>
 800bd8e:	687b      	ldr	r3, [r7, #4]
 800bd90:	685b      	ldr	r3, [r3, #4]
 800bd92:	69ba      	ldr	r2, [r7, #24]
 800bd94:	429a      	cmp	r2, r3
 800bd96:	d302      	bcc.n	800bd9e <xTaskCheckForTimeOut+0x9e>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
 800bd98:	2301      	movs	r3, #1
 800bd9a:	61fb      	str	r3, [r7, #28]
 800bd9c:	e015      	b.n	800bdca <xTaskCheckForTimeOut+0xca>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 800bd9e:	683b      	ldr	r3, [r7, #0]
 800bda0:	681b      	ldr	r3, [r3, #0]
 800bda2:	697a      	ldr	r2, [r7, #20]
 800bda4:	429a      	cmp	r2, r3
 800bda6:	d20b      	bcs.n	800bdc0 <xTaskCheckForTimeOut+0xc0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
 800bda8:	683b      	ldr	r3, [r7, #0]
 800bdaa:	681a      	ldr	r2, [r3, #0]
 800bdac:	697b      	ldr	r3, [r7, #20]
 800bdae:	1ad2      	subs	r2, r2, r3
 800bdb0:	683b      	ldr	r3, [r7, #0]
 800bdb2:	601a      	str	r2, [r3, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
 800bdb4:	6878      	ldr	r0, [r7, #4]
 800bdb6:	f7ff ff8d 	bl	800bcd4 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
 800bdba:	2300      	movs	r3, #0
 800bdbc:	61fb      	str	r3, [r7, #28]
 800bdbe:	e004      	b.n	800bdca <xTaskCheckForTimeOut+0xca>
		}
		else
		{
			*pxTicksToWait = 0;
 800bdc0:	683b      	ldr	r3, [r7, #0]
 800bdc2:	2200      	movs	r2, #0
 800bdc4:	601a      	str	r2, [r3, #0]
			xReturn = pdTRUE;
 800bdc6:	2301      	movs	r3, #1
 800bdc8:	61fb      	str	r3, [r7, #28]
		}
	}
	taskEXIT_CRITICAL();
 800bdca:	f001 f803 	bl	800cdd4 <vPortExitCritical>

	return xReturn;
 800bdce:	69fb      	ldr	r3, [r7, #28]
}
 800bdd0:	4618      	mov	r0, r3
 800bdd2:	3720      	adds	r7, #32
 800bdd4:	46bd      	mov	sp, r7
 800bdd6:	bd80      	pop	{r7, pc}
 800bdd8:	24000368 	.word	0x24000368
 800bddc:	24000264 	.word	0x24000264
 800bde0:	2400037c 	.word	0x2400037c

0800bde4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
 800bde4:	b480      	push	{r7}
 800bde6:	af00      	add	r7, sp, #0
	xYieldPending = pdTRUE;
 800bde8:	4b03      	ldr	r3, [pc, #12]	; (800bdf8 <vTaskMissedYield+0x14>)
 800bdea:	2201      	movs	r2, #1
 800bdec:	601a      	str	r2, [r3, #0]
}
 800bdee:	bf00      	nop
 800bdf0:	46bd      	mov	sp, r7
 800bdf2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bdf6:	4770      	bx	lr
 800bdf8:	24000378 	.word	0x24000378

0800bdfc <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 800bdfc:	b580      	push	{r7, lr}
 800bdfe:	b082      	sub	sp, #8
 800be00:	af00      	add	r7, sp, #0
 800be02:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
 800be04:	f000 f852 	bl	800beac <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 800be08:	4b06      	ldr	r3, [pc, #24]	; (800be24 <prvIdleTask+0x28>)
 800be0a:	681b      	ldr	r3, [r3, #0]
 800be0c:	2b01      	cmp	r3, #1
 800be0e:	d9f9      	bls.n	800be04 <prvIdleTask+0x8>
			{
				taskYIELD();
 800be10:	4b05      	ldr	r3, [pc, #20]	; (800be28 <prvIdleTask+0x2c>)
 800be12:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800be16:	601a      	str	r2, [r3, #0]
 800be18:	f3bf 8f4f 	dsb	sy
 800be1c:	f3bf 8f6f 	isb	sy
		prvCheckTasksWaitingTermination();
 800be20:	e7f0      	b.n	800be04 <prvIdleTask+0x8>
 800be22:	bf00      	nop
 800be24:	24000268 	.word	0x24000268
 800be28:	e000ed04 	.word	0xe000ed04

0800be2c <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
 800be2c:	b580      	push	{r7, lr}
 800be2e:	b082      	sub	sp, #8
 800be30:	af00      	add	r7, sp, #0
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 800be32:	2300      	movs	r3, #0
 800be34:	607b      	str	r3, [r7, #4]
 800be36:	e00c      	b.n	800be52 <prvInitialiseTaskLists+0x26>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 800be38:	687a      	ldr	r2, [r7, #4]
 800be3a:	4613      	mov	r3, r2
 800be3c:	009b      	lsls	r3, r3, #2
 800be3e:	4413      	add	r3, r2
 800be40:	009b      	lsls	r3, r3, #2
 800be42:	4a12      	ldr	r2, [pc, #72]	; (800be8c <prvInitialiseTaskLists+0x60>)
 800be44:	4413      	add	r3, r2
 800be46:	4618      	mov	r0, r3
 800be48:	f7fe fba7 	bl	800a59a <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 800be4c:	687b      	ldr	r3, [r7, #4]
 800be4e:	3301      	adds	r3, #1
 800be50:	607b      	str	r3, [r7, #4]
 800be52:	687b      	ldr	r3, [r7, #4]
 800be54:	2b06      	cmp	r3, #6
 800be56:	d9ef      	bls.n	800be38 <prvInitialiseTaskLists+0xc>
	}

	vListInitialise( &xDelayedTaskList1 );
 800be58:	480d      	ldr	r0, [pc, #52]	; (800be90 <prvInitialiseTaskLists+0x64>)
 800be5a:	f7fe fb9e 	bl	800a59a <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 800be5e:	480d      	ldr	r0, [pc, #52]	; (800be94 <prvInitialiseTaskLists+0x68>)
 800be60:	f7fe fb9b 	bl	800a59a <vListInitialise>
	vListInitialise( &xPendingReadyList );
 800be64:	480c      	ldr	r0, [pc, #48]	; (800be98 <prvInitialiseTaskLists+0x6c>)
 800be66:	f7fe fb98 	bl	800a59a <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
 800be6a:	480c      	ldr	r0, [pc, #48]	; (800be9c <prvInitialiseTaskLists+0x70>)
 800be6c:	f7fe fb95 	bl	800a59a <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 800be70:	480b      	ldr	r0, [pc, #44]	; (800bea0 <prvInitialiseTaskLists+0x74>)
 800be72:	f7fe fb92 	bl	800a59a <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 800be76:	4b0b      	ldr	r3, [pc, #44]	; (800bea4 <prvInitialiseTaskLists+0x78>)
 800be78:	4a05      	ldr	r2, [pc, #20]	; (800be90 <prvInitialiseTaskLists+0x64>)
 800be7a:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 800be7c:	4b0a      	ldr	r3, [pc, #40]	; (800bea8 <prvInitialiseTaskLists+0x7c>)
 800be7e:	4a05      	ldr	r2, [pc, #20]	; (800be94 <prvInitialiseTaskLists+0x68>)
 800be80:	601a      	str	r2, [r3, #0]
}
 800be82:	bf00      	nop
 800be84:	3708      	adds	r7, #8
 800be86:	46bd      	mov	sp, r7
 800be88:	bd80      	pop	{r7, pc}
 800be8a:	bf00      	nop
 800be8c:	24000268 	.word	0x24000268
 800be90:	240002f4 	.word	0x240002f4
 800be94:	24000308 	.word	0x24000308
 800be98:	24000324 	.word	0x24000324
 800be9c:	24000338 	.word	0x24000338
 800bea0:	24000350 	.word	0x24000350
 800bea4:	2400031c 	.word	0x2400031c
 800bea8:	24000320 	.word	0x24000320

0800beac <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 800beac:	b580      	push	{r7, lr}
 800beae:	b082      	sub	sp, #8
 800beb0:	af00      	add	r7, sp, #0
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 800beb2:	e019      	b.n	800bee8 <prvCheckTasksWaitingTermination+0x3c>
		{
			taskENTER_CRITICAL();
 800beb4:	f000 ff5e 	bl	800cd74 <vPortEnterCritical>
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800beb8:	4b10      	ldr	r3, [pc, #64]	; (800befc <prvCheckTasksWaitingTermination+0x50>)
 800beba:	68db      	ldr	r3, [r3, #12]
 800bebc:	68db      	ldr	r3, [r3, #12]
 800bebe:	607b      	str	r3, [r7, #4]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800bec0:	687b      	ldr	r3, [r7, #4]
 800bec2:	3304      	adds	r3, #4
 800bec4:	4618      	mov	r0, r3
 800bec6:	f7fe fbf2 	bl	800a6ae <uxListRemove>
				--uxCurrentNumberOfTasks;
 800beca:	4b0d      	ldr	r3, [pc, #52]	; (800bf00 <prvCheckTasksWaitingTermination+0x54>)
 800becc:	681b      	ldr	r3, [r3, #0]
 800bece:	3b01      	subs	r3, #1
 800bed0:	4a0b      	ldr	r2, [pc, #44]	; (800bf00 <prvCheckTasksWaitingTermination+0x54>)
 800bed2:	6013      	str	r3, [r2, #0]
				--uxDeletedTasksWaitingCleanUp;
 800bed4:	4b0b      	ldr	r3, [pc, #44]	; (800bf04 <prvCheckTasksWaitingTermination+0x58>)
 800bed6:	681b      	ldr	r3, [r3, #0]
 800bed8:	3b01      	subs	r3, #1
 800beda:	4a0a      	ldr	r2, [pc, #40]	; (800bf04 <prvCheckTasksWaitingTermination+0x58>)
 800bedc:	6013      	str	r3, [r2, #0]
			}
			taskEXIT_CRITICAL();
 800bede:	f000 ff79 	bl	800cdd4 <vPortExitCritical>

			prvDeleteTCB( pxTCB );
 800bee2:	6878      	ldr	r0, [r7, #4]
 800bee4:	f000 f810 	bl	800bf08 <prvDeleteTCB>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 800bee8:	4b06      	ldr	r3, [pc, #24]	; (800bf04 <prvCheckTasksWaitingTermination+0x58>)
 800beea:	681b      	ldr	r3, [r3, #0]
 800beec:	2b00      	cmp	r3, #0
 800beee:	d1e1      	bne.n	800beb4 <prvCheckTasksWaitingTermination+0x8>
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
 800bef0:	bf00      	nop
 800bef2:	bf00      	nop
 800bef4:	3708      	adds	r7, #8
 800bef6:	46bd      	mov	sp, r7
 800bef8:	bd80      	pop	{r7, pc}
 800befa:	bf00      	nop
 800befc:	24000338 	.word	0x24000338
 800bf00:	24000364 	.word	0x24000364
 800bf04:	2400034c 	.word	0x2400034c

0800bf08 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
 800bf08:	b580      	push	{r7, lr}
 800bf0a:	b082      	sub	sp, #8
 800bf0c:	af00      	add	r7, sp, #0
 800bf0e:	6078      	str	r0, [r7, #4]
		to the task to free any memory allocated at the application level.
		See the third party link http://www.nadler.com/embedded/newlibAndFreeRTOS.html
		for additional information. */
		#if ( configUSE_NEWLIB_REENTRANT == 1 )
		{
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
 800bf10:	687b      	ldr	r3, [r7, #4]
 800bf12:	334c      	adds	r3, #76	; 0x4c
 800bf14:	4618      	mov	r0, r3
 800bf16:	f015 ff1d 	bl	8021d54 <_reclaim_reent>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
 800bf1a:	687b      	ldr	r3, [r7, #4]
 800bf1c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800bf1e:	4618      	mov	r0, r3
 800bf20:	f001 f916 	bl	800d150 <vPortFree>
			vPortFree( pxTCB );
 800bf24:	6878      	ldr	r0, [r7, #4]
 800bf26:	f001 f913 	bl	800d150 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
 800bf2a:	bf00      	nop
 800bf2c:	3708      	adds	r7, #8
 800bf2e:	46bd      	mov	sp, r7
 800bf30:	bd80      	pop	{r7, pc}
	...

0800bf34 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
 800bf34:	b480      	push	{r7}
 800bf36:	b083      	sub	sp, #12
 800bf38:	af00      	add	r7, sp, #0
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800bf3a:	4b0c      	ldr	r3, [pc, #48]	; (800bf6c <prvResetNextTaskUnblockTime+0x38>)
 800bf3c:	681b      	ldr	r3, [r3, #0]
 800bf3e:	681b      	ldr	r3, [r3, #0]
 800bf40:	2b00      	cmp	r3, #0
 800bf42:	d104      	bne.n	800bf4e <prvResetNextTaskUnblockTime+0x1a>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 800bf44:	4b0a      	ldr	r3, [pc, #40]	; (800bf70 <prvResetNextTaskUnblockTime+0x3c>)
 800bf46:	f04f 32ff 	mov.w	r2, #4294967295
 800bf4a:	601a      	str	r2, [r3, #0]
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
 800bf4c:	e008      	b.n	800bf60 <prvResetNextTaskUnblockTime+0x2c>
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800bf4e:	4b07      	ldr	r3, [pc, #28]	; (800bf6c <prvResetNextTaskUnblockTime+0x38>)
 800bf50:	681b      	ldr	r3, [r3, #0]
 800bf52:	68db      	ldr	r3, [r3, #12]
 800bf54:	68db      	ldr	r3, [r3, #12]
 800bf56:	607b      	str	r3, [r7, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 800bf58:	687b      	ldr	r3, [r7, #4]
 800bf5a:	685b      	ldr	r3, [r3, #4]
 800bf5c:	4a04      	ldr	r2, [pc, #16]	; (800bf70 <prvResetNextTaskUnblockTime+0x3c>)
 800bf5e:	6013      	str	r3, [r2, #0]
}
 800bf60:	bf00      	nop
 800bf62:	370c      	adds	r7, #12
 800bf64:	46bd      	mov	sp, r7
 800bf66:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bf6a:	4770      	bx	lr
 800bf6c:	2400031c 	.word	0x2400031c
 800bf70:	24000384 	.word	0x24000384

0800bf74 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	BaseType_t xTaskGetSchedulerState( void )
	{
 800bf74:	b480      	push	{r7}
 800bf76:	b083      	sub	sp, #12
 800bf78:	af00      	add	r7, sp, #0
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
 800bf7a:	4b0b      	ldr	r3, [pc, #44]	; (800bfa8 <xTaskGetSchedulerState+0x34>)
 800bf7c:	681b      	ldr	r3, [r3, #0]
 800bf7e:	2b00      	cmp	r3, #0
 800bf80:	d102      	bne.n	800bf88 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
 800bf82:	2301      	movs	r3, #1
 800bf84:	607b      	str	r3, [r7, #4]
 800bf86:	e008      	b.n	800bf9a <xTaskGetSchedulerState+0x26>
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800bf88:	4b08      	ldr	r3, [pc, #32]	; (800bfac <xTaskGetSchedulerState+0x38>)
 800bf8a:	681b      	ldr	r3, [r3, #0]
 800bf8c:	2b00      	cmp	r3, #0
 800bf8e:	d102      	bne.n	800bf96 <xTaskGetSchedulerState+0x22>
			{
				xReturn = taskSCHEDULER_RUNNING;
 800bf90:	2302      	movs	r3, #2
 800bf92:	607b      	str	r3, [r7, #4]
 800bf94:	e001      	b.n	800bf9a <xTaskGetSchedulerState+0x26>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
 800bf96:	2300      	movs	r3, #0
 800bf98:	607b      	str	r3, [r7, #4]
			}
		}

		return xReturn;
 800bf9a:	687b      	ldr	r3, [r7, #4]
	}
 800bf9c:	4618      	mov	r0, r3
 800bf9e:	370c      	adds	r7, #12
 800bfa0:	46bd      	mov	sp, r7
 800bfa2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bfa6:	4770      	bx	lr
 800bfa8:	24000370 	.word	0x24000370
 800bfac:	2400038c 	.word	0x2400038c

0800bfb0 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
 800bfb0:	b580      	push	{r7, lr}
 800bfb2:	b084      	sub	sp, #16
 800bfb4:	af00      	add	r7, sp, #0
 800bfb6:	6078      	str	r0, [r7, #4]
	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
 800bfb8:	687b      	ldr	r3, [r7, #4]
 800bfba:	60bb      	str	r3, [r7, #8]
	BaseType_t xReturn = pdFALSE;
 800bfbc:	2300      	movs	r3, #0
 800bfbe:	60fb      	str	r3, [r7, #12]

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
 800bfc0:	687b      	ldr	r3, [r7, #4]
 800bfc2:	2b00      	cmp	r3, #0
 800bfc4:	d05e      	beq.n	800c084 <xTaskPriorityInherit+0xd4>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 800bfc6:	68bb      	ldr	r3, [r7, #8]
 800bfc8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800bfca:	4b31      	ldr	r3, [pc, #196]	; (800c090 <xTaskPriorityInherit+0xe0>)
 800bfcc:	681b      	ldr	r3, [r3, #0]
 800bfce:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800bfd0:	429a      	cmp	r2, r3
 800bfd2:	d24e      	bcs.n	800c072 <xTaskPriorityInherit+0xc2>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 800bfd4:	68bb      	ldr	r3, [r7, #8]
 800bfd6:	699b      	ldr	r3, [r3, #24]
 800bfd8:	2b00      	cmp	r3, #0
 800bfda:	db06      	blt.n	800bfea <xTaskPriorityInherit+0x3a>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800bfdc:	4b2c      	ldr	r3, [pc, #176]	; (800c090 <xTaskPriorityInherit+0xe0>)
 800bfde:	681b      	ldr	r3, [r3, #0]
 800bfe0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800bfe2:	f1c3 0207 	rsb	r2, r3, #7
 800bfe6:	68bb      	ldr	r3, [r7, #8]
 800bfe8:	619a      	str	r2, [r3, #24]
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 800bfea:	68bb      	ldr	r3, [r7, #8]
 800bfec:	6959      	ldr	r1, [r3, #20]
 800bfee:	68bb      	ldr	r3, [r7, #8]
 800bff0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800bff2:	4613      	mov	r3, r2
 800bff4:	009b      	lsls	r3, r3, #2
 800bff6:	4413      	add	r3, r2
 800bff8:	009b      	lsls	r3, r3, #2
 800bffa:	4a26      	ldr	r2, [pc, #152]	; (800c094 <xTaskPriorityInherit+0xe4>)
 800bffc:	4413      	add	r3, r2
 800bffe:	4299      	cmp	r1, r3
 800c000:	d12f      	bne.n	800c062 <xTaskPriorityInherit+0xb2>
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800c002:	68bb      	ldr	r3, [r7, #8]
 800c004:	3304      	adds	r3, #4
 800c006:	4618      	mov	r0, r3
 800c008:	f7fe fb51 	bl	800a6ae <uxListRemove>
 800c00c:	4603      	mov	r3, r0
 800c00e:	2b00      	cmp	r3, #0
 800c010:	d10a      	bne.n	800c028 <xTaskPriorityInherit+0x78>
					{
						/* It is known that the task is in its ready list so
						there is no need to check again and the port level
						reset macro can be called directly. */
						portRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority, uxTopReadyPriority );
 800c012:	68bb      	ldr	r3, [r7, #8]
 800c014:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c016:	2201      	movs	r2, #1
 800c018:	fa02 f303 	lsl.w	r3, r2, r3
 800c01c:	43da      	mvns	r2, r3
 800c01e:	4b1e      	ldr	r3, [pc, #120]	; (800c098 <xTaskPriorityInherit+0xe8>)
 800c020:	681b      	ldr	r3, [r3, #0]
 800c022:	4013      	ands	r3, r2
 800c024:	4a1c      	ldr	r2, [pc, #112]	; (800c098 <xTaskPriorityInherit+0xe8>)
 800c026:	6013      	str	r3, [r2, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 800c028:	4b19      	ldr	r3, [pc, #100]	; (800c090 <xTaskPriorityInherit+0xe0>)
 800c02a:	681b      	ldr	r3, [r3, #0]
 800c02c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800c02e:	68bb      	ldr	r3, [r7, #8]
 800c030:	62da      	str	r2, [r3, #44]	; 0x2c
					prvAddTaskToReadyList( pxMutexHolderTCB );
 800c032:	68bb      	ldr	r3, [r7, #8]
 800c034:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c036:	2201      	movs	r2, #1
 800c038:	409a      	lsls	r2, r3
 800c03a:	4b17      	ldr	r3, [pc, #92]	; (800c098 <xTaskPriorityInherit+0xe8>)
 800c03c:	681b      	ldr	r3, [r3, #0]
 800c03e:	4313      	orrs	r3, r2
 800c040:	4a15      	ldr	r2, [pc, #84]	; (800c098 <xTaskPriorityInherit+0xe8>)
 800c042:	6013      	str	r3, [r2, #0]
 800c044:	68bb      	ldr	r3, [r7, #8]
 800c046:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800c048:	4613      	mov	r3, r2
 800c04a:	009b      	lsls	r3, r3, #2
 800c04c:	4413      	add	r3, r2
 800c04e:	009b      	lsls	r3, r3, #2
 800c050:	4a10      	ldr	r2, [pc, #64]	; (800c094 <xTaskPriorityInherit+0xe4>)
 800c052:	441a      	add	r2, r3
 800c054:	68bb      	ldr	r3, [r7, #8]
 800c056:	3304      	adds	r3, #4
 800c058:	4619      	mov	r1, r3
 800c05a:	4610      	mov	r0, r2
 800c05c:	f7fe faca 	bl	800a5f4 <vListInsertEnd>
 800c060:	e004      	b.n	800c06c <xTaskPriorityInherit+0xbc>
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 800c062:	4b0b      	ldr	r3, [pc, #44]	; (800c090 <xTaskPriorityInherit+0xe0>)
 800c064:	681b      	ldr	r3, [r3, #0]
 800c066:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800c068:	68bb      	ldr	r3, [r7, #8]
 800c06a:	62da      	str	r2, [r3, #44]	; 0x2c
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
 800c06c:	2301      	movs	r3, #1
 800c06e:	60fb      	str	r3, [r7, #12]
 800c070:	e008      	b.n	800c084 <xTaskPriorityInherit+0xd4>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 800c072:	68bb      	ldr	r3, [r7, #8]
 800c074:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800c076:	4b06      	ldr	r3, [pc, #24]	; (800c090 <xTaskPriorityInherit+0xe0>)
 800c078:	681b      	ldr	r3, [r3, #0]
 800c07a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c07c:	429a      	cmp	r2, r3
 800c07e:	d201      	bcs.n	800c084 <xTaskPriorityInherit+0xd4>
					current priority of the mutex holder is not lower than the
					priority of the task attempting to take the mutex.
					Therefore the mutex holder must have already inherited a
					priority, but inheritance would have occurred if that had
					not been the case. */
					xReturn = pdTRUE;
 800c080:	2301      	movs	r3, #1
 800c082:	60fb      	str	r3, [r7, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
 800c084:	68fb      	ldr	r3, [r7, #12]
	}
 800c086:	4618      	mov	r0, r3
 800c088:	3710      	adds	r7, #16
 800c08a:	46bd      	mov	sp, r7
 800c08c:	bd80      	pop	{r7, pc}
 800c08e:	bf00      	nop
 800c090:	24000264 	.word	0x24000264
 800c094:	24000268 	.word	0x24000268
 800c098:	2400036c 	.word	0x2400036c

0800c09c <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
 800c09c:	b580      	push	{r7, lr}
 800c09e:	b086      	sub	sp, #24
 800c0a0:	af00      	add	r7, sp, #0
 800c0a2:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = pxMutexHolder;
 800c0a4:	687b      	ldr	r3, [r7, #4]
 800c0a6:	613b      	str	r3, [r7, #16]
	BaseType_t xReturn = pdFALSE;
 800c0a8:	2300      	movs	r3, #0
 800c0aa:	617b      	str	r3, [r7, #20]

		if( pxMutexHolder != NULL )
 800c0ac:	687b      	ldr	r3, [r7, #4]
 800c0ae:	2b00      	cmp	r3, #0
 800c0b0:	d06e      	beq.n	800c190 <xTaskPriorityDisinherit+0xf4>
		{
			/* A task can only have an inherited priority if it holds the mutex.
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
 800c0b2:	4b3a      	ldr	r3, [pc, #232]	; (800c19c <xTaskPriorityDisinherit+0x100>)
 800c0b4:	681b      	ldr	r3, [r3, #0]
 800c0b6:	693a      	ldr	r2, [r7, #16]
 800c0b8:	429a      	cmp	r2, r3
 800c0ba:	d00a      	beq.n	800c0d2 <xTaskPriorityDisinherit+0x36>
	__asm volatile
 800c0bc:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c0c0:	f383 8811 	msr	BASEPRI, r3
 800c0c4:	f3bf 8f6f 	isb	sy
 800c0c8:	f3bf 8f4f 	dsb	sy
 800c0cc:	60fb      	str	r3, [r7, #12]
}
 800c0ce:	bf00      	nop
 800c0d0:	e7fe      	b.n	800c0d0 <xTaskPriorityDisinherit+0x34>
			configASSERT( pxTCB->uxMutexesHeld );
 800c0d2:	693b      	ldr	r3, [r7, #16]
 800c0d4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800c0d6:	2b00      	cmp	r3, #0
 800c0d8:	d10a      	bne.n	800c0f0 <xTaskPriorityDisinherit+0x54>
	__asm volatile
 800c0da:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c0de:	f383 8811 	msr	BASEPRI, r3
 800c0e2:	f3bf 8f6f 	isb	sy
 800c0e6:	f3bf 8f4f 	dsb	sy
 800c0ea:	60bb      	str	r3, [r7, #8]
}
 800c0ec:	bf00      	nop
 800c0ee:	e7fe      	b.n	800c0ee <xTaskPriorityDisinherit+0x52>
			( pxTCB->uxMutexesHeld )--;
 800c0f0:	693b      	ldr	r3, [r7, #16]
 800c0f2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800c0f4:	1e5a      	subs	r2, r3, #1
 800c0f6:	693b      	ldr	r3, [r7, #16]
 800c0f8:	649a      	str	r2, [r3, #72]	; 0x48

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 800c0fa:	693b      	ldr	r3, [r7, #16]
 800c0fc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800c0fe:	693b      	ldr	r3, [r7, #16]
 800c100:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800c102:	429a      	cmp	r2, r3
 800c104:	d044      	beq.n	800c190 <xTaskPriorityDisinherit+0xf4>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 800c106:	693b      	ldr	r3, [r7, #16]
 800c108:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800c10a:	2b00      	cmp	r3, #0
 800c10c:	d140      	bne.n	800c190 <xTaskPriorityDisinherit+0xf4>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready/delayed list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800c10e:	693b      	ldr	r3, [r7, #16]
 800c110:	3304      	adds	r3, #4
 800c112:	4618      	mov	r0, r3
 800c114:	f7fe facb 	bl	800a6ae <uxListRemove>
 800c118:	4603      	mov	r3, r0
 800c11a:	2b00      	cmp	r3, #0
 800c11c:	d115      	bne.n	800c14a <xTaskPriorityDisinherit+0xae>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 800c11e:	693b      	ldr	r3, [r7, #16]
 800c120:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800c122:	491f      	ldr	r1, [pc, #124]	; (800c1a0 <xTaskPriorityDisinherit+0x104>)
 800c124:	4613      	mov	r3, r2
 800c126:	009b      	lsls	r3, r3, #2
 800c128:	4413      	add	r3, r2
 800c12a:	009b      	lsls	r3, r3, #2
 800c12c:	440b      	add	r3, r1
 800c12e:	681b      	ldr	r3, [r3, #0]
 800c130:	2b00      	cmp	r3, #0
 800c132:	d10a      	bne.n	800c14a <xTaskPriorityDisinherit+0xae>
 800c134:	693b      	ldr	r3, [r7, #16]
 800c136:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c138:	2201      	movs	r2, #1
 800c13a:	fa02 f303 	lsl.w	r3, r2, r3
 800c13e:	43da      	mvns	r2, r3
 800c140:	4b18      	ldr	r3, [pc, #96]	; (800c1a4 <xTaskPriorityDisinherit+0x108>)
 800c142:	681b      	ldr	r3, [r3, #0]
 800c144:	4013      	ands	r3, r2
 800c146:	4a17      	ldr	r2, [pc, #92]	; (800c1a4 <xTaskPriorityDisinherit+0x108>)
 800c148:	6013      	str	r3, [r2, #0]
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 800c14a:	693b      	ldr	r3, [r7, #16]
 800c14c:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800c14e:	693b      	ldr	r3, [r7, #16]
 800c150:	62da      	str	r2, [r3, #44]	; 0x2c

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800c152:	693b      	ldr	r3, [r7, #16]
 800c154:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c156:	f1c3 0207 	rsb	r2, r3, #7
 800c15a:	693b      	ldr	r3, [r7, #16]
 800c15c:	619a      	str	r2, [r3, #24]
					prvAddTaskToReadyList( pxTCB );
 800c15e:	693b      	ldr	r3, [r7, #16]
 800c160:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c162:	2201      	movs	r2, #1
 800c164:	409a      	lsls	r2, r3
 800c166:	4b0f      	ldr	r3, [pc, #60]	; (800c1a4 <xTaskPriorityDisinherit+0x108>)
 800c168:	681b      	ldr	r3, [r3, #0]
 800c16a:	4313      	orrs	r3, r2
 800c16c:	4a0d      	ldr	r2, [pc, #52]	; (800c1a4 <xTaskPriorityDisinherit+0x108>)
 800c16e:	6013      	str	r3, [r2, #0]
 800c170:	693b      	ldr	r3, [r7, #16]
 800c172:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800c174:	4613      	mov	r3, r2
 800c176:	009b      	lsls	r3, r3, #2
 800c178:	4413      	add	r3, r2
 800c17a:	009b      	lsls	r3, r3, #2
 800c17c:	4a08      	ldr	r2, [pc, #32]	; (800c1a0 <xTaskPriorityDisinherit+0x104>)
 800c17e:	441a      	add	r2, r3
 800c180:	693b      	ldr	r3, [r7, #16]
 800c182:	3304      	adds	r3, #4
 800c184:	4619      	mov	r1, r3
 800c186:	4610      	mov	r0, r2
 800c188:	f7fe fa34 	bl	800a5f4 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
 800c18c:	2301      	movs	r3, #1
 800c18e:	617b      	str	r3, [r7, #20]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
 800c190:	697b      	ldr	r3, [r7, #20]
	}
 800c192:	4618      	mov	r0, r3
 800c194:	3718      	adds	r7, #24
 800c196:	46bd      	mov	sp, r7
 800c198:	bd80      	pop	{r7, pc}
 800c19a:	bf00      	nop
 800c19c:	24000264 	.word	0x24000264
 800c1a0:	24000268 	.word	0x24000268
 800c1a4:	2400036c 	.word	0x2400036c

0800c1a8 <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
 800c1a8:	b580      	push	{r7, lr}
 800c1aa:	b088      	sub	sp, #32
 800c1ac:	af00      	add	r7, sp, #0
 800c1ae:	6078      	str	r0, [r7, #4]
 800c1b0:	6039      	str	r1, [r7, #0]
	TCB_t * const pxTCB = pxMutexHolder;
 800c1b2:	687b      	ldr	r3, [r7, #4]
 800c1b4:	61bb      	str	r3, [r7, #24]
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
 800c1b6:	2301      	movs	r3, #1
 800c1b8:	617b      	str	r3, [r7, #20]

		if( pxMutexHolder != NULL )
 800c1ba:	687b      	ldr	r3, [r7, #4]
 800c1bc:	2b00      	cmp	r3, #0
 800c1be:	d077      	beq.n	800c2b0 <vTaskPriorityDisinheritAfterTimeout+0x108>
		{
			/* If pxMutexHolder is not NULL then the holder must hold at least
			one mutex. */
			configASSERT( pxTCB->uxMutexesHeld );
 800c1c0:	69bb      	ldr	r3, [r7, #24]
 800c1c2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800c1c4:	2b00      	cmp	r3, #0
 800c1c6:	d10a      	bne.n	800c1de <vTaskPriorityDisinheritAfterTimeout+0x36>
	__asm volatile
 800c1c8:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c1cc:	f383 8811 	msr	BASEPRI, r3
 800c1d0:	f3bf 8f6f 	isb	sy
 800c1d4:	f3bf 8f4f 	dsb	sy
 800c1d8:	60fb      	str	r3, [r7, #12]
}
 800c1da:	bf00      	nop
 800c1dc:	e7fe      	b.n	800c1dc <vTaskPriorityDisinheritAfterTimeout+0x34>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
 800c1de:	69bb      	ldr	r3, [r7, #24]
 800c1e0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800c1e2:	683a      	ldr	r2, [r7, #0]
 800c1e4:	429a      	cmp	r2, r3
 800c1e6:	d902      	bls.n	800c1ee <vTaskPriorityDisinheritAfterTimeout+0x46>
			{
				uxPriorityToUse = uxHighestPriorityWaitingTask;
 800c1e8:	683b      	ldr	r3, [r7, #0]
 800c1ea:	61fb      	str	r3, [r7, #28]
 800c1ec:	e002      	b.n	800c1f4 <vTaskPriorityDisinheritAfterTimeout+0x4c>
			}
			else
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
 800c1ee:	69bb      	ldr	r3, [r7, #24]
 800c1f0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800c1f2:	61fb      	str	r3, [r7, #28]
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
 800c1f4:	69bb      	ldr	r3, [r7, #24]
 800c1f6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c1f8:	69fa      	ldr	r2, [r7, #28]
 800c1fa:	429a      	cmp	r2, r3
 800c1fc:	d058      	beq.n	800c2b0 <vTaskPriorityDisinheritAfterTimeout+0x108>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 800c1fe:	69bb      	ldr	r3, [r7, #24]
 800c200:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800c202:	697a      	ldr	r2, [r7, #20]
 800c204:	429a      	cmp	r2, r3
 800c206:	d153      	bne.n	800c2b0 <vTaskPriorityDisinheritAfterTimeout+0x108>
				{
					/* If a task has timed out because it already holds the
					mutex it was trying to obtain then it cannot of inherited
					its own priority. */
					configASSERT( pxTCB != pxCurrentTCB );
 800c208:	4b2b      	ldr	r3, [pc, #172]	; (800c2b8 <vTaskPriorityDisinheritAfterTimeout+0x110>)
 800c20a:	681b      	ldr	r3, [r3, #0]
 800c20c:	69ba      	ldr	r2, [r7, #24]
 800c20e:	429a      	cmp	r2, r3
 800c210:	d10a      	bne.n	800c228 <vTaskPriorityDisinheritAfterTimeout+0x80>
	__asm volatile
 800c212:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c216:	f383 8811 	msr	BASEPRI, r3
 800c21a:	f3bf 8f6f 	isb	sy
 800c21e:	f3bf 8f4f 	dsb	sy
 800c222:	60bb      	str	r3, [r7, #8]
}
 800c224:	bf00      	nop
 800c226:	e7fe      	b.n	800c226 <vTaskPriorityDisinheritAfterTimeout+0x7e>

					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
 800c228:	69bb      	ldr	r3, [r7, #24]
 800c22a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c22c:	613b      	str	r3, [r7, #16]
					pxTCB->uxPriority = uxPriorityToUse;
 800c22e:	69bb      	ldr	r3, [r7, #24]
 800c230:	69fa      	ldr	r2, [r7, #28]
 800c232:	62da      	str	r2, [r3, #44]	; 0x2c

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 800c234:	69bb      	ldr	r3, [r7, #24]
 800c236:	699b      	ldr	r3, [r3, #24]
 800c238:	2b00      	cmp	r3, #0
 800c23a:	db04      	blt.n	800c246 <vTaskPriorityDisinheritAfterTimeout+0x9e>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800c23c:	69fb      	ldr	r3, [r7, #28]
 800c23e:	f1c3 0207 	rsb	r2, r3, #7
 800c242:	69bb      	ldr	r3, [r7, #24]
 800c244:	619a      	str	r2, [r3, #24]
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 800c246:	69bb      	ldr	r3, [r7, #24]
 800c248:	6959      	ldr	r1, [r3, #20]
 800c24a:	693a      	ldr	r2, [r7, #16]
 800c24c:	4613      	mov	r3, r2
 800c24e:	009b      	lsls	r3, r3, #2
 800c250:	4413      	add	r3, r2
 800c252:	009b      	lsls	r3, r3, #2
 800c254:	4a19      	ldr	r2, [pc, #100]	; (800c2bc <vTaskPriorityDisinheritAfterTimeout+0x114>)
 800c256:	4413      	add	r3, r2
 800c258:	4299      	cmp	r1, r3
 800c25a:	d129      	bne.n	800c2b0 <vTaskPriorityDisinheritAfterTimeout+0x108>
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800c25c:	69bb      	ldr	r3, [r7, #24]
 800c25e:	3304      	adds	r3, #4
 800c260:	4618      	mov	r0, r3
 800c262:	f7fe fa24 	bl	800a6ae <uxListRemove>
 800c266:	4603      	mov	r3, r0
 800c268:	2b00      	cmp	r3, #0
 800c26a:	d10a      	bne.n	800c282 <vTaskPriorityDisinheritAfterTimeout+0xda>
						{
							/* It is known that the task is in its ready list so
							there is no need to check again and the port level
							reset macro can be called directly. */
							portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
 800c26c:	69bb      	ldr	r3, [r7, #24]
 800c26e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c270:	2201      	movs	r2, #1
 800c272:	fa02 f303 	lsl.w	r3, r2, r3
 800c276:	43da      	mvns	r2, r3
 800c278:	4b11      	ldr	r3, [pc, #68]	; (800c2c0 <vTaskPriorityDisinheritAfterTimeout+0x118>)
 800c27a:	681b      	ldr	r3, [r3, #0]
 800c27c:	4013      	ands	r3, r2
 800c27e:	4a10      	ldr	r2, [pc, #64]	; (800c2c0 <vTaskPriorityDisinheritAfterTimeout+0x118>)
 800c280:	6013      	str	r3, [r2, #0]
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
 800c282:	69bb      	ldr	r3, [r7, #24]
 800c284:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c286:	2201      	movs	r2, #1
 800c288:	409a      	lsls	r2, r3
 800c28a:	4b0d      	ldr	r3, [pc, #52]	; (800c2c0 <vTaskPriorityDisinheritAfterTimeout+0x118>)
 800c28c:	681b      	ldr	r3, [r3, #0]
 800c28e:	4313      	orrs	r3, r2
 800c290:	4a0b      	ldr	r2, [pc, #44]	; (800c2c0 <vTaskPriorityDisinheritAfterTimeout+0x118>)
 800c292:	6013      	str	r3, [r2, #0]
 800c294:	69bb      	ldr	r3, [r7, #24]
 800c296:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800c298:	4613      	mov	r3, r2
 800c29a:	009b      	lsls	r3, r3, #2
 800c29c:	4413      	add	r3, r2
 800c29e:	009b      	lsls	r3, r3, #2
 800c2a0:	4a06      	ldr	r2, [pc, #24]	; (800c2bc <vTaskPriorityDisinheritAfterTimeout+0x114>)
 800c2a2:	441a      	add	r2, r3
 800c2a4:	69bb      	ldr	r3, [r7, #24]
 800c2a6:	3304      	adds	r3, #4
 800c2a8:	4619      	mov	r1, r3
 800c2aa:	4610      	mov	r0, r2
 800c2ac:	f7fe f9a2 	bl	800a5f4 <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 800c2b0:	bf00      	nop
 800c2b2:	3720      	adds	r7, #32
 800c2b4:	46bd      	mov	sp, r7
 800c2b6:	bd80      	pop	{r7, pc}
 800c2b8:	24000264 	.word	0x24000264
 800c2bc:	24000268 	.word	0x24000268
 800c2c0:	2400036c 	.word	0x2400036c

0800c2c4 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
 800c2c4:	b480      	push	{r7}
 800c2c6:	af00      	add	r7, sp, #0
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
 800c2c8:	4b07      	ldr	r3, [pc, #28]	; (800c2e8 <pvTaskIncrementMutexHeldCount+0x24>)
 800c2ca:	681b      	ldr	r3, [r3, #0]
 800c2cc:	2b00      	cmp	r3, #0
 800c2ce:	d004      	beq.n	800c2da <pvTaskIncrementMutexHeldCount+0x16>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
 800c2d0:	4b05      	ldr	r3, [pc, #20]	; (800c2e8 <pvTaskIncrementMutexHeldCount+0x24>)
 800c2d2:	681b      	ldr	r3, [r3, #0]
 800c2d4:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 800c2d6:	3201      	adds	r2, #1
 800c2d8:	649a      	str	r2, [r3, #72]	; 0x48
		}

		return pxCurrentTCB;
 800c2da:	4b03      	ldr	r3, [pc, #12]	; (800c2e8 <pvTaskIncrementMutexHeldCount+0x24>)
 800c2dc:	681b      	ldr	r3, [r3, #0]
	}
 800c2de:	4618      	mov	r0, r3
 800c2e0:	46bd      	mov	sp, r7
 800c2e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c2e6:	4770      	bx	lr
 800c2e8:	24000264 	.word	0x24000264

0800c2ec <prvAddCurrentTaskToDelayedList>:

#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 800c2ec:	b580      	push	{r7, lr}
 800c2ee:	b084      	sub	sp, #16
 800c2f0:	af00      	add	r7, sp, #0
 800c2f2:	6078      	str	r0, [r7, #4]
 800c2f4:	6039      	str	r1, [r7, #0]
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 800c2f6:	4b2b      	ldr	r3, [pc, #172]	; (800c3a4 <prvAddCurrentTaskToDelayedList+0xb8>)
 800c2f8:	681b      	ldr	r3, [r3, #0]
 800c2fa:	60fb      	str	r3, [r7, #12]
	#if( INCLUDE_xTaskAbortDelay == 1 )
	{
		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
		reset to pdFALSE so it can be detected as having been set to pdTRUE
		when the task leaves the Blocked state. */
		pxCurrentTCB->ucDelayAborted = pdFALSE;
 800c2fc:	4b2a      	ldr	r3, [pc, #168]	; (800c3a8 <prvAddCurrentTaskToDelayedList+0xbc>)
 800c2fe:	681b      	ldr	r3, [r3, #0]
 800c300:	2200      	movs	r2, #0
 800c302:	f883 20b1 	strb.w	r2, [r3, #177]	; 0xb1
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800c306:	4b28      	ldr	r3, [pc, #160]	; (800c3a8 <prvAddCurrentTaskToDelayedList+0xbc>)
 800c308:	681b      	ldr	r3, [r3, #0]
 800c30a:	3304      	adds	r3, #4
 800c30c:	4618      	mov	r0, r3
 800c30e:	f7fe f9ce 	bl	800a6ae <uxListRemove>
 800c312:	4603      	mov	r3, r0
 800c314:	2b00      	cmp	r3, #0
 800c316:	d10b      	bne.n	800c330 <prvAddCurrentTaskToDelayedList+0x44>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
 800c318:	4b23      	ldr	r3, [pc, #140]	; (800c3a8 <prvAddCurrentTaskToDelayedList+0xbc>)
 800c31a:	681b      	ldr	r3, [r3, #0]
 800c31c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c31e:	2201      	movs	r2, #1
 800c320:	fa02 f303 	lsl.w	r3, r2, r3
 800c324:	43da      	mvns	r2, r3
 800c326:	4b21      	ldr	r3, [pc, #132]	; (800c3ac <prvAddCurrentTaskToDelayedList+0xc0>)
 800c328:	681b      	ldr	r3, [r3, #0]
 800c32a:	4013      	ands	r3, r2
 800c32c:	4a1f      	ldr	r2, [pc, #124]	; (800c3ac <prvAddCurrentTaskToDelayedList+0xc0>)
 800c32e:	6013      	str	r3, [r2, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 800c330:	687b      	ldr	r3, [r7, #4]
 800c332:	f1b3 3fff 	cmp.w	r3, #4294967295
 800c336:	d10a      	bne.n	800c34e <prvAddCurrentTaskToDelayedList+0x62>
 800c338:	683b      	ldr	r3, [r7, #0]
 800c33a:	2b00      	cmp	r3, #0
 800c33c:	d007      	beq.n	800c34e <prvAddCurrentTaskToDelayedList+0x62>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800c33e:	4b1a      	ldr	r3, [pc, #104]	; (800c3a8 <prvAddCurrentTaskToDelayedList+0xbc>)
 800c340:	681b      	ldr	r3, [r3, #0]
 800c342:	3304      	adds	r3, #4
 800c344:	4619      	mov	r1, r3
 800c346:	481a      	ldr	r0, [pc, #104]	; (800c3b0 <prvAddCurrentTaskToDelayedList+0xc4>)
 800c348:	f7fe f954 	bl	800a5f4 <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 800c34c:	e026      	b.n	800c39c <prvAddCurrentTaskToDelayedList+0xb0>
			xTimeToWake = xConstTickCount + xTicksToWait;
 800c34e:	68fa      	ldr	r2, [r7, #12]
 800c350:	687b      	ldr	r3, [r7, #4]
 800c352:	4413      	add	r3, r2
 800c354:	60bb      	str	r3, [r7, #8]
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 800c356:	4b14      	ldr	r3, [pc, #80]	; (800c3a8 <prvAddCurrentTaskToDelayedList+0xbc>)
 800c358:	681b      	ldr	r3, [r3, #0]
 800c35a:	68ba      	ldr	r2, [r7, #8]
 800c35c:	605a      	str	r2, [r3, #4]
			if( xTimeToWake < xConstTickCount )
 800c35e:	68ba      	ldr	r2, [r7, #8]
 800c360:	68fb      	ldr	r3, [r7, #12]
 800c362:	429a      	cmp	r2, r3
 800c364:	d209      	bcs.n	800c37a <prvAddCurrentTaskToDelayedList+0x8e>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800c366:	4b13      	ldr	r3, [pc, #76]	; (800c3b4 <prvAddCurrentTaskToDelayedList+0xc8>)
 800c368:	681a      	ldr	r2, [r3, #0]
 800c36a:	4b0f      	ldr	r3, [pc, #60]	; (800c3a8 <prvAddCurrentTaskToDelayedList+0xbc>)
 800c36c:	681b      	ldr	r3, [r3, #0]
 800c36e:	3304      	adds	r3, #4
 800c370:	4619      	mov	r1, r3
 800c372:	4610      	mov	r0, r2
 800c374:	f7fe f962 	bl	800a63c <vListInsert>
}
 800c378:	e010      	b.n	800c39c <prvAddCurrentTaskToDelayedList+0xb0>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800c37a:	4b0f      	ldr	r3, [pc, #60]	; (800c3b8 <prvAddCurrentTaskToDelayedList+0xcc>)
 800c37c:	681a      	ldr	r2, [r3, #0]
 800c37e:	4b0a      	ldr	r3, [pc, #40]	; (800c3a8 <prvAddCurrentTaskToDelayedList+0xbc>)
 800c380:	681b      	ldr	r3, [r3, #0]
 800c382:	3304      	adds	r3, #4
 800c384:	4619      	mov	r1, r3
 800c386:	4610      	mov	r0, r2
 800c388:	f7fe f958 	bl	800a63c <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 800c38c:	4b0b      	ldr	r3, [pc, #44]	; (800c3bc <prvAddCurrentTaskToDelayedList+0xd0>)
 800c38e:	681b      	ldr	r3, [r3, #0]
 800c390:	68ba      	ldr	r2, [r7, #8]
 800c392:	429a      	cmp	r2, r3
 800c394:	d202      	bcs.n	800c39c <prvAddCurrentTaskToDelayedList+0xb0>
					xNextTaskUnblockTime = xTimeToWake;
 800c396:	4a09      	ldr	r2, [pc, #36]	; (800c3bc <prvAddCurrentTaskToDelayedList+0xd0>)
 800c398:	68bb      	ldr	r3, [r7, #8]
 800c39a:	6013      	str	r3, [r2, #0]
}
 800c39c:	bf00      	nop
 800c39e:	3710      	adds	r7, #16
 800c3a0:	46bd      	mov	sp, r7
 800c3a2:	bd80      	pop	{r7, pc}
 800c3a4:	24000368 	.word	0x24000368
 800c3a8:	24000264 	.word	0x24000264
 800c3ac:	2400036c 	.word	0x2400036c
 800c3b0:	24000350 	.word	0x24000350
 800c3b4:	24000320 	.word	0x24000320
 800c3b8:	2400031c 	.word	0x2400031c
 800c3bc:	24000384 	.word	0x24000384

0800c3c0 <xTimerCreateTimerTask>:
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
 800c3c0:	b580      	push	{r7, lr}
 800c3c2:	b084      	sub	sp, #16
 800c3c4:	af02      	add	r7, sp, #8
BaseType_t xReturn = pdFAIL;
 800c3c6:	2300      	movs	r3, #0
 800c3c8:	607b      	str	r3, [r7, #4]

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
 800c3ca:	f000 fb31 	bl	800ca30 <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
 800c3ce:	4b11      	ldr	r3, [pc, #68]	; (800c414 <xTimerCreateTimerTask+0x54>)
 800c3d0:	681b      	ldr	r3, [r3, #0]
 800c3d2:	2b00      	cmp	r3, #0
 800c3d4:	d00b      	beq.n	800c3ee <xTimerCreateTimerTask+0x2e>
				xReturn = pdPASS;
			}
		}
		#else
		{
			xReturn = xTaskCreate(	prvTimerTask,
 800c3d6:	4b10      	ldr	r3, [pc, #64]	; (800c418 <xTimerCreateTimerTask+0x58>)
 800c3d8:	9301      	str	r3, [sp, #4]
 800c3da:	2305      	movs	r3, #5
 800c3dc:	9300      	str	r3, [sp, #0]
 800c3de:	2300      	movs	r3, #0
 800c3e0:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800c3e4:	490d      	ldr	r1, [pc, #52]	; (800c41c <xTimerCreateTimerTask+0x5c>)
 800c3e6:	480e      	ldr	r0, [pc, #56]	; (800c420 <xTimerCreateTimerTask+0x60>)
 800c3e8:	f7ff f814 	bl	800b414 <xTaskCreate>
 800c3ec:	6078      	str	r0, [r7, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
 800c3ee:	687b      	ldr	r3, [r7, #4]
 800c3f0:	2b00      	cmp	r3, #0
 800c3f2:	d10a      	bne.n	800c40a <xTimerCreateTimerTask+0x4a>
	__asm volatile
 800c3f4:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c3f8:	f383 8811 	msr	BASEPRI, r3
 800c3fc:	f3bf 8f6f 	isb	sy
 800c400:	f3bf 8f4f 	dsb	sy
 800c404:	603b      	str	r3, [r7, #0]
}
 800c406:	bf00      	nop
 800c408:	e7fe      	b.n	800c408 <xTimerCreateTimerTask+0x48>
	return xReturn;
 800c40a:	687b      	ldr	r3, [r7, #4]
}
 800c40c:	4618      	mov	r0, r3
 800c40e:	3708      	adds	r7, #8
 800c410:	46bd      	mov	sp, r7
 800c412:	bd80      	pop	{r7, pc}
 800c414:	240003c0 	.word	0x240003c0
 800c418:	240003c4 	.word	0x240003c4
 800c41c:	080225c4 	.word	0x080225c4
 800c420:	0800c611 	.word	0x0800c611

0800c424 <xTimerCreate>:
	TimerHandle_t xTimerCreate(	const char * const pcTimerName,			/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
								const TickType_t xTimerPeriodInTicks,
								const UBaseType_t uxAutoReload,
								void * const pvTimerID,
								TimerCallbackFunction_t pxCallbackFunction )
	{
 800c424:	b580      	push	{r7, lr}
 800c426:	b088      	sub	sp, #32
 800c428:	af02      	add	r7, sp, #8
 800c42a:	60f8      	str	r0, [r7, #12]
 800c42c:	60b9      	str	r1, [r7, #8]
 800c42e:	607a      	str	r2, [r7, #4]
 800c430:	603b      	str	r3, [r7, #0]
	Timer_t *pxNewTimer;

		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
 800c432:	2028      	movs	r0, #40	; 0x28
 800c434:	f000 fdc0 	bl	800cfb8 <pvPortMalloc>
 800c438:	6178      	str	r0, [r7, #20]

		if( pxNewTimer != NULL )
 800c43a:	697b      	ldr	r3, [r7, #20]
 800c43c:	2b00      	cmp	r3, #0
 800c43e:	d00d      	beq.n	800c45c <xTimerCreate+0x38>
		{
			/* Status is thus far zero as the timer is not created statically
			and has not been started.  The auto-reload bit may get set in
			prvInitialiseNewTimer. */
			pxNewTimer->ucStatus = 0x00;
 800c440:	697b      	ldr	r3, [r7, #20]
 800c442:	2200      	movs	r2, #0
 800c444:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
 800c448:	697b      	ldr	r3, [r7, #20]
 800c44a:	9301      	str	r3, [sp, #4]
 800c44c:	6a3b      	ldr	r3, [r7, #32]
 800c44e:	9300      	str	r3, [sp, #0]
 800c450:	683b      	ldr	r3, [r7, #0]
 800c452:	687a      	ldr	r2, [r7, #4]
 800c454:	68b9      	ldr	r1, [r7, #8]
 800c456:	68f8      	ldr	r0, [r7, #12]
 800c458:	f000 f805 	bl	800c466 <prvInitialiseNewTimer>
		}

		return pxNewTimer;
 800c45c:	697b      	ldr	r3, [r7, #20]
	}
 800c45e:	4618      	mov	r0, r3
 800c460:	3718      	adds	r7, #24
 800c462:	46bd      	mov	sp, r7
 800c464:	bd80      	pop	{r7, pc}

0800c466 <prvInitialiseNewTimer>:
									const TickType_t xTimerPeriodInTicks,
									const UBaseType_t uxAutoReload,
									void * const pvTimerID,
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer )
{
 800c466:	b580      	push	{r7, lr}
 800c468:	b086      	sub	sp, #24
 800c46a:	af00      	add	r7, sp, #0
 800c46c:	60f8      	str	r0, [r7, #12]
 800c46e:	60b9      	str	r1, [r7, #8]
 800c470:	607a      	str	r2, [r7, #4]
 800c472:	603b      	str	r3, [r7, #0]
	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );
 800c474:	68bb      	ldr	r3, [r7, #8]
 800c476:	2b00      	cmp	r3, #0
 800c478:	d10a      	bne.n	800c490 <prvInitialiseNewTimer+0x2a>
	__asm volatile
 800c47a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c47e:	f383 8811 	msr	BASEPRI, r3
 800c482:	f3bf 8f6f 	isb	sy
 800c486:	f3bf 8f4f 	dsb	sy
 800c48a:	617b      	str	r3, [r7, #20]
}
 800c48c:	bf00      	nop
 800c48e:	e7fe      	b.n	800c48e <prvInitialiseNewTimer+0x28>

	if( pxNewTimer != NULL )
 800c490:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c492:	2b00      	cmp	r3, #0
 800c494:	d01e      	beq.n	800c4d4 <prvInitialiseNewTimer+0x6e>
	{
		/* Ensure the infrastructure used by the timer service task has been
		created/initialised. */
		prvCheckForValidListAndQueue();
 800c496:	f000 facb 	bl	800ca30 <prvCheckForValidListAndQueue>

		/* Initialise the timer structure members using the function
		parameters. */
		pxNewTimer->pcTimerName = pcTimerName;
 800c49a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c49c:	68fa      	ldr	r2, [r7, #12]
 800c49e:	601a      	str	r2, [r3, #0]
		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
 800c4a0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c4a2:	68ba      	ldr	r2, [r7, #8]
 800c4a4:	619a      	str	r2, [r3, #24]
		pxNewTimer->pvTimerID = pvTimerID;
 800c4a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c4a8:	683a      	ldr	r2, [r7, #0]
 800c4aa:	61da      	str	r2, [r3, #28]
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 800c4ac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c4ae:	6a3a      	ldr	r2, [r7, #32]
 800c4b0:	621a      	str	r2, [r3, #32]
		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 800c4b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c4b4:	3304      	adds	r3, #4
 800c4b6:	4618      	mov	r0, r3
 800c4b8:	f7fe f88f 	bl	800a5da <vListInitialiseItem>
		if( uxAutoReload != pdFALSE )
 800c4bc:	687b      	ldr	r3, [r7, #4]
 800c4be:	2b00      	cmp	r3, #0
 800c4c0:	d008      	beq.n	800c4d4 <prvInitialiseNewTimer+0x6e>
		{
			pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
 800c4c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c4c4:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800c4c8:	f043 0304 	orr.w	r3, r3, #4
 800c4cc:	b2da      	uxtb	r2, r3
 800c4ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c4d0:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
		}
		traceTIMER_CREATE( pxNewTimer );
	}
}
 800c4d4:	bf00      	nop
 800c4d6:	3718      	adds	r7, #24
 800c4d8:	46bd      	mov	sp, r7
 800c4da:	bd80      	pop	{r7, pc}

0800c4dc <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
 800c4dc:	b580      	push	{r7, lr}
 800c4de:	b08a      	sub	sp, #40	; 0x28
 800c4e0:	af00      	add	r7, sp, #0
 800c4e2:	60f8      	str	r0, [r7, #12]
 800c4e4:	60b9      	str	r1, [r7, #8]
 800c4e6:	607a      	str	r2, [r7, #4]
 800c4e8:	603b      	str	r3, [r7, #0]
BaseType_t xReturn = pdFAIL;
 800c4ea:	2300      	movs	r3, #0
 800c4ec:	627b      	str	r3, [r7, #36]	; 0x24
DaemonTaskMessage_t xMessage;

	configASSERT( xTimer );
 800c4ee:	68fb      	ldr	r3, [r7, #12]
 800c4f0:	2b00      	cmp	r3, #0
 800c4f2:	d10a      	bne.n	800c50a <xTimerGenericCommand+0x2e>
	__asm volatile
 800c4f4:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c4f8:	f383 8811 	msr	BASEPRI, r3
 800c4fc:	f3bf 8f6f 	isb	sy
 800c500:	f3bf 8f4f 	dsb	sy
 800c504:	623b      	str	r3, [r7, #32]
}
 800c506:	bf00      	nop
 800c508:	e7fe      	b.n	800c508 <xTimerGenericCommand+0x2c>

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
 800c50a:	4b1a      	ldr	r3, [pc, #104]	; (800c574 <xTimerGenericCommand+0x98>)
 800c50c:	681b      	ldr	r3, [r3, #0]
 800c50e:	2b00      	cmp	r3, #0
 800c510:	d02a      	beq.n	800c568 <xTimerGenericCommand+0x8c>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
 800c512:	68bb      	ldr	r3, [r7, #8]
 800c514:	617b      	str	r3, [r7, #20]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 800c516:	687b      	ldr	r3, [r7, #4]
 800c518:	61bb      	str	r3, [r7, #24]
		xMessage.u.xTimerParameters.pxTimer = xTimer;
 800c51a:	68fb      	ldr	r3, [r7, #12]
 800c51c:	61fb      	str	r3, [r7, #28]

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 800c51e:	68bb      	ldr	r3, [r7, #8]
 800c520:	2b05      	cmp	r3, #5
 800c522:	dc18      	bgt.n	800c556 <xTimerGenericCommand+0x7a>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 800c524:	f7ff fd26 	bl	800bf74 <xTaskGetSchedulerState>
 800c528:	4603      	mov	r3, r0
 800c52a:	2b02      	cmp	r3, #2
 800c52c:	d109      	bne.n	800c542 <xTimerGenericCommand+0x66>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 800c52e:	4b11      	ldr	r3, [pc, #68]	; (800c574 <xTimerGenericCommand+0x98>)
 800c530:	6818      	ldr	r0, [r3, #0]
 800c532:	f107 0114 	add.w	r1, r7, #20
 800c536:	2300      	movs	r3, #0
 800c538:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800c53a:	f7fe f9d3 	bl	800a8e4 <xQueueGenericSend>
 800c53e:	6278      	str	r0, [r7, #36]	; 0x24
 800c540:	e012      	b.n	800c568 <xTimerGenericCommand+0x8c>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 800c542:	4b0c      	ldr	r3, [pc, #48]	; (800c574 <xTimerGenericCommand+0x98>)
 800c544:	6818      	ldr	r0, [r3, #0]
 800c546:	f107 0114 	add.w	r1, r7, #20
 800c54a:	2300      	movs	r3, #0
 800c54c:	2200      	movs	r2, #0
 800c54e:	f7fe f9c9 	bl	800a8e4 <xQueueGenericSend>
 800c552:	6278      	str	r0, [r7, #36]	; 0x24
 800c554:	e008      	b.n	800c568 <xTimerGenericCommand+0x8c>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 800c556:	4b07      	ldr	r3, [pc, #28]	; (800c574 <xTimerGenericCommand+0x98>)
 800c558:	6818      	ldr	r0, [r3, #0]
 800c55a:	f107 0114 	add.w	r1, r7, #20
 800c55e:	2300      	movs	r3, #0
 800c560:	683a      	ldr	r2, [r7, #0]
 800c562:	f7fe fabd 	bl	800aae0 <xQueueGenericSendFromISR>
 800c566:	6278      	str	r0, [r7, #36]	; 0x24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
 800c568:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 800c56a:	4618      	mov	r0, r3
 800c56c:	3728      	adds	r7, #40	; 0x28
 800c56e:	46bd      	mov	sp, r7
 800c570:	bd80      	pop	{r7, pc}
 800c572:	bf00      	nop
 800c574:	240003c0 	.word	0x240003c0

0800c578 <prvProcessExpiredTimer>:
	return pxTimer->pcTimerName;
}
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
 800c578:	b580      	push	{r7, lr}
 800c57a:	b088      	sub	sp, #32
 800c57c:	af02      	add	r7, sp, #8
 800c57e:	6078      	str	r0, [r7, #4]
 800c580:	6039      	str	r1, [r7, #0]
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800c582:	4b22      	ldr	r3, [pc, #136]	; (800c60c <prvProcessExpiredTimer+0x94>)
 800c584:	681b      	ldr	r3, [r3, #0]
 800c586:	68db      	ldr	r3, [r3, #12]
 800c588:	68db      	ldr	r3, [r3, #12]
 800c58a:	617b      	str	r3, [r7, #20]

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 800c58c:	697b      	ldr	r3, [r7, #20]
 800c58e:	3304      	adds	r3, #4
 800c590:	4618      	mov	r0, r3
 800c592:	f7fe f88c 	bl	800a6ae <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto-reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 800c596:	697b      	ldr	r3, [r7, #20]
 800c598:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800c59c:	f003 0304 	and.w	r3, r3, #4
 800c5a0:	2b00      	cmp	r3, #0
 800c5a2:	d022      	beq.n	800c5ea <prvProcessExpiredTimer+0x72>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 800c5a4:	697b      	ldr	r3, [r7, #20]
 800c5a6:	699a      	ldr	r2, [r3, #24]
 800c5a8:	687b      	ldr	r3, [r7, #4]
 800c5aa:	18d1      	adds	r1, r2, r3
 800c5ac:	687b      	ldr	r3, [r7, #4]
 800c5ae:	683a      	ldr	r2, [r7, #0]
 800c5b0:	6978      	ldr	r0, [r7, #20]
 800c5b2:	f000 f8d1 	bl	800c758 <prvInsertTimerInActiveList>
 800c5b6:	4603      	mov	r3, r0
 800c5b8:	2b00      	cmp	r3, #0
 800c5ba:	d01f      	beq.n	800c5fc <prvProcessExpiredTimer+0x84>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 800c5bc:	2300      	movs	r3, #0
 800c5be:	9300      	str	r3, [sp, #0]
 800c5c0:	2300      	movs	r3, #0
 800c5c2:	687a      	ldr	r2, [r7, #4]
 800c5c4:	2100      	movs	r1, #0
 800c5c6:	6978      	ldr	r0, [r7, #20]
 800c5c8:	f7ff ff88 	bl	800c4dc <xTimerGenericCommand>
 800c5cc:	6138      	str	r0, [r7, #16]
			configASSERT( xResult );
 800c5ce:	693b      	ldr	r3, [r7, #16]
 800c5d0:	2b00      	cmp	r3, #0
 800c5d2:	d113      	bne.n	800c5fc <prvProcessExpiredTimer+0x84>
	__asm volatile
 800c5d4:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c5d8:	f383 8811 	msr	BASEPRI, r3
 800c5dc:	f3bf 8f6f 	isb	sy
 800c5e0:	f3bf 8f4f 	dsb	sy
 800c5e4:	60fb      	str	r3, [r7, #12]
}
 800c5e6:	bf00      	nop
 800c5e8:	e7fe      	b.n	800c5e8 <prvProcessExpiredTimer+0x70>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 800c5ea:	697b      	ldr	r3, [r7, #20]
 800c5ec:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800c5f0:	f023 0301 	bic.w	r3, r3, #1
 800c5f4:	b2da      	uxtb	r2, r3
 800c5f6:	697b      	ldr	r3, [r7, #20]
 800c5f8:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 800c5fc:	697b      	ldr	r3, [r7, #20]
 800c5fe:	6a1b      	ldr	r3, [r3, #32]
 800c600:	6978      	ldr	r0, [r7, #20]
 800c602:	4798      	blx	r3
}
 800c604:	bf00      	nop
 800c606:	3718      	adds	r7, #24
 800c608:	46bd      	mov	sp, r7
 800c60a:	bd80      	pop	{r7, pc}
 800c60c:	240003b8 	.word	0x240003b8

0800c610 <prvTimerTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
 800c610:	b580      	push	{r7, lr}
 800c612:	b084      	sub	sp, #16
 800c614:	af00      	add	r7, sp, #0
 800c616:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* Query the timers list to see if it contains any timers, and if so,
		obtain the time at which the next timer will expire. */
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
 800c618:	f107 0308 	add.w	r3, r7, #8
 800c61c:	4618      	mov	r0, r3
 800c61e:	f000 f857 	bl	800c6d0 <prvGetNextExpireTime>
 800c622:	60f8      	str	r0, [r7, #12]

		/* If a timer has expired, process it.  Otherwise, block this task
		until either a timer does expire, or a command is received. */
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
 800c624:	68bb      	ldr	r3, [r7, #8]
 800c626:	4619      	mov	r1, r3
 800c628:	68f8      	ldr	r0, [r7, #12]
 800c62a:	f000 f803 	bl	800c634 <prvProcessTimerOrBlockTask>

		/* Empty the command queue. */
		prvProcessReceivedCommands();
 800c62e:	f000 f8d5 	bl	800c7dc <prvProcessReceivedCommands>
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
 800c632:	e7f1      	b.n	800c618 <prvTimerTask+0x8>

0800c634 <prvProcessTimerOrBlockTask>:
	}
}
/*-----------------------------------------------------------*/

static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
 800c634:	b580      	push	{r7, lr}
 800c636:	b084      	sub	sp, #16
 800c638:	af00      	add	r7, sp, #0
 800c63a:	6078      	str	r0, [r7, #4]
 800c63c:	6039      	str	r1, [r7, #0]
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
 800c63e:	f7ff f8c3 	bl	800b7c8 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 800c642:	f107 0308 	add.w	r3, r7, #8
 800c646:	4618      	mov	r0, r3
 800c648:	f000 f866 	bl	800c718 <prvSampleTimeNow>
 800c64c:	60f8      	str	r0, [r7, #12]
		if( xTimerListsWereSwitched == pdFALSE )
 800c64e:	68bb      	ldr	r3, [r7, #8]
 800c650:	2b00      	cmp	r3, #0
 800c652:	d130      	bne.n	800c6b6 <prvProcessTimerOrBlockTask+0x82>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 800c654:	683b      	ldr	r3, [r7, #0]
 800c656:	2b00      	cmp	r3, #0
 800c658:	d10a      	bne.n	800c670 <prvProcessTimerOrBlockTask+0x3c>
 800c65a:	687a      	ldr	r2, [r7, #4]
 800c65c:	68fb      	ldr	r3, [r7, #12]
 800c65e:	429a      	cmp	r2, r3
 800c660:	d806      	bhi.n	800c670 <prvProcessTimerOrBlockTask+0x3c>
			{
				( void ) xTaskResumeAll();
 800c662:	f7ff f8bf 	bl	800b7e4 <xTaskResumeAll>
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
 800c666:	68f9      	ldr	r1, [r7, #12]
 800c668:	6878      	ldr	r0, [r7, #4]
 800c66a:	f7ff ff85 	bl	800c578 <prvProcessExpiredTimer>
		else
		{
			( void ) xTaskResumeAll();
		}
	}
}
 800c66e:	e024      	b.n	800c6ba <prvProcessTimerOrBlockTask+0x86>
				if( xListWasEmpty != pdFALSE )
 800c670:	683b      	ldr	r3, [r7, #0]
 800c672:	2b00      	cmp	r3, #0
 800c674:	d008      	beq.n	800c688 <prvProcessTimerOrBlockTask+0x54>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 800c676:	4b13      	ldr	r3, [pc, #76]	; (800c6c4 <prvProcessTimerOrBlockTask+0x90>)
 800c678:	681b      	ldr	r3, [r3, #0]
 800c67a:	681b      	ldr	r3, [r3, #0]
 800c67c:	2b00      	cmp	r3, #0
 800c67e:	d101      	bne.n	800c684 <prvProcessTimerOrBlockTask+0x50>
 800c680:	2301      	movs	r3, #1
 800c682:	e000      	b.n	800c686 <prvProcessTimerOrBlockTask+0x52>
 800c684:	2300      	movs	r3, #0
 800c686:	603b      	str	r3, [r7, #0]
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 800c688:	4b0f      	ldr	r3, [pc, #60]	; (800c6c8 <prvProcessTimerOrBlockTask+0x94>)
 800c68a:	6818      	ldr	r0, [r3, #0]
 800c68c:	687a      	ldr	r2, [r7, #4]
 800c68e:	68fb      	ldr	r3, [r7, #12]
 800c690:	1ad3      	subs	r3, r2, r3
 800c692:	683a      	ldr	r2, [r7, #0]
 800c694:	4619      	mov	r1, r3
 800c696:	f7fe fe89 	bl	800b3ac <vQueueWaitForMessageRestricted>
				if( xTaskResumeAll() == pdFALSE )
 800c69a:	f7ff f8a3 	bl	800b7e4 <xTaskResumeAll>
 800c69e:	4603      	mov	r3, r0
 800c6a0:	2b00      	cmp	r3, #0
 800c6a2:	d10a      	bne.n	800c6ba <prvProcessTimerOrBlockTask+0x86>
					portYIELD_WITHIN_API();
 800c6a4:	4b09      	ldr	r3, [pc, #36]	; (800c6cc <prvProcessTimerOrBlockTask+0x98>)
 800c6a6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800c6aa:	601a      	str	r2, [r3, #0]
 800c6ac:	f3bf 8f4f 	dsb	sy
 800c6b0:	f3bf 8f6f 	isb	sy
}
 800c6b4:	e001      	b.n	800c6ba <prvProcessTimerOrBlockTask+0x86>
			( void ) xTaskResumeAll();
 800c6b6:	f7ff f895 	bl	800b7e4 <xTaskResumeAll>
}
 800c6ba:	bf00      	nop
 800c6bc:	3710      	adds	r7, #16
 800c6be:	46bd      	mov	sp, r7
 800c6c0:	bd80      	pop	{r7, pc}
 800c6c2:	bf00      	nop
 800c6c4:	240003bc 	.word	0x240003bc
 800c6c8:	240003c0 	.word	0x240003c0
 800c6cc:	e000ed04 	.word	0xe000ed04

0800c6d0 <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
{
 800c6d0:	b480      	push	{r7}
 800c6d2:	b085      	sub	sp, #20
 800c6d4:	af00      	add	r7, sp, #0
 800c6d6:	6078      	str	r0, [r7, #4]
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 800c6d8:	4b0e      	ldr	r3, [pc, #56]	; (800c714 <prvGetNextExpireTime+0x44>)
 800c6da:	681b      	ldr	r3, [r3, #0]
 800c6dc:	681b      	ldr	r3, [r3, #0]
 800c6de:	2b00      	cmp	r3, #0
 800c6e0:	d101      	bne.n	800c6e6 <prvGetNextExpireTime+0x16>
 800c6e2:	2201      	movs	r2, #1
 800c6e4:	e000      	b.n	800c6e8 <prvGetNextExpireTime+0x18>
 800c6e6:	2200      	movs	r2, #0
 800c6e8:	687b      	ldr	r3, [r7, #4]
 800c6ea:	601a      	str	r2, [r3, #0]
	if( *pxListWasEmpty == pdFALSE )
 800c6ec:	687b      	ldr	r3, [r7, #4]
 800c6ee:	681b      	ldr	r3, [r3, #0]
 800c6f0:	2b00      	cmp	r3, #0
 800c6f2:	d105      	bne.n	800c700 <prvGetNextExpireTime+0x30>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 800c6f4:	4b07      	ldr	r3, [pc, #28]	; (800c714 <prvGetNextExpireTime+0x44>)
 800c6f6:	681b      	ldr	r3, [r3, #0]
 800c6f8:	68db      	ldr	r3, [r3, #12]
 800c6fa:	681b      	ldr	r3, [r3, #0]
 800c6fc:	60fb      	str	r3, [r7, #12]
 800c6fe:	e001      	b.n	800c704 <prvGetNextExpireTime+0x34>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
 800c700:	2300      	movs	r3, #0
 800c702:	60fb      	str	r3, [r7, #12]
	}

	return xNextExpireTime;
 800c704:	68fb      	ldr	r3, [r7, #12]
}
 800c706:	4618      	mov	r0, r3
 800c708:	3714      	adds	r7, #20
 800c70a:	46bd      	mov	sp, r7
 800c70c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c710:	4770      	bx	lr
 800c712:	bf00      	nop
 800c714:	240003b8 	.word	0x240003b8

0800c718 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
 800c718:	b580      	push	{r7, lr}
 800c71a:	b084      	sub	sp, #16
 800c71c:	af00      	add	r7, sp, #0
 800c71e:	6078      	str	r0, [r7, #4]
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 800c720:	f7ff f8fc 	bl	800b91c <xTaskGetTickCount>
 800c724:	60f8      	str	r0, [r7, #12]

	if( xTimeNow < xLastTime )
 800c726:	4b0b      	ldr	r3, [pc, #44]	; (800c754 <prvSampleTimeNow+0x3c>)
 800c728:	681b      	ldr	r3, [r3, #0]
 800c72a:	68fa      	ldr	r2, [r7, #12]
 800c72c:	429a      	cmp	r2, r3
 800c72e:	d205      	bcs.n	800c73c <prvSampleTimeNow+0x24>
	{
		prvSwitchTimerLists();
 800c730:	f000 f91a 	bl	800c968 <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
 800c734:	687b      	ldr	r3, [r7, #4]
 800c736:	2201      	movs	r2, #1
 800c738:	601a      	str	r2, [r3, #0]
 800c73a:	e002      	b.n	800c742 <prvSampleTimeNow+0x2a>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
 800c73c:	687b      	ldr	r3, [r7, #4]
 800c73e:	2200      	movs	r2, #0
 800c740:	601a      	str	r2, [r3, #0]
	}

	xLastTime = xTimeNow;
 800c742:	4a04      	ldr	r2, [pc, #16]	; (800c754 <prvSampleTimeNow+0x3c>)
 800c744:	68fb      	ldr	r3, [r7, #12]
 800c746:	6013      	str	r3, [r2, #0]

	return xTimeNow;
 800c748:	68fb      	ldr	r3, [r7, #12]
}
 800c74a:	4618      	mov	r0, r3
 800c74c:	3710      	adds	r7, #16
 800c74e:	46bd      	mov	sp, r7
 800c750:	bd80      	pop	{r7, pc}
 800c752:	bf00      	nop
 800c754:	240003c8 	.word	0x240003c8

0800c758 <prvInsertTimerInActiveList>:
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
 800c758:	b580      	push	{r7, lr}
 800c75a:	b086      	sub	sp, #24
 800c75c:	af00      	add	r7, sp, #0
 800c75e:	60f8      	str	r0, [r7, #12]
 800c760:	60b9      	str	r1, [r7, #8]
 800c762:	607a      	str	r2, [r7, #4]
 800c764:	603b      	str	r3, [r7, #0]
BaseType_t xProcessTimerNow = pdFALSE;
 800c766:	2300      	movs	r3, #0
 800c768:	617b      	str	r3, [r7, #20]

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 800c76a:	68fb      	ldr	r3, [r7, #12]
 800c76c:	68ba      	ldr	r2, [r7, #8]
 800c76e:	605a      	str	r2, [r3, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 800c770:	68fb      	ldr	r3, [r7, #12]
 800c772:	68fa      	ldr	r2, [r7, #12]
 800c774:	611a      	str	r2, [r3, #16]

	if( xNextExpiryTime <= xTimeNow )
 800c776:	68ba      	ldr	r2, [r7, #8]
 800c778:	687b      	ldr	r3, [r7, #4]
 800c77a:	429a      	cmp	r2, r3
 800c77c:	d812      	bhi.n	800c7a4 <prvInsertTimerInActiveList+0x4c>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800c77e:	687a      	ldr	r2, [r7, #4]
 800c780:	683b      	ldr	r3, [r7, #0]
 800c782:	1ad2      	subs	r2, r2, r3
 800c784:	68fb      	ldr	r3, [r7, #12]
 800c786:	699b      	ldr	r3, [r3, #24]
 800c788:	429a      	cmp	r2, r3
 800c78a:	d302      	bcc.n	800c792 <prvInsertTimerInActiveList+0x3a>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
 800c78c:	2301      	movs	r3, #1
 800c78e:	617b      	str	r3, [r7, #20]
 800c790:	e01b      	b.n	800c7ca <prvInsertTimerInActiveList+0x72>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 800c792:	4b10      	ldr	r3, [pc, #64]	; (800c7d4 <prvInsertTimerInActiveList+0x7c>)
 800c794:	681a      	ldr	r2, [r3, #0]
 800c796:	68fb      	ldr	r3, [r7, #12]
 800c798:	3304      	adds	r3, #4
 800c79a:	4619      	mov	r1, r3
 800c79c:	4610      	mov	r0, r2
 800c79e:	f7fd ff4d 	bl	800a63c <vListInsert>
 800c7a2:	e012      	b.n	800c7ca <prvInsertTimerInActiveList+0x72>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 800c7a4:	687a      	ldr	r2, [r7, #4]
 800c7a6:	683b      	ldr	r3, [r7, #0]
 800c7a8:	429a      	cmp	r2, r3
 800c7aa:	d206      	bcs.n	800c7ba <prvInsertTimerInActiveList+0x62>
 800c7ac:	68ba      	ldr	r2, [r7, #8]
 800c7ae:	683b      	ldr	r3, [r7, #0]
 800c7b0:	429a      	cmp	r2, r3
 800c7b2:	d302      	bcc.n	800c7ba <prvInsertTimerInActiveList+0x62>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
 800c7b4:	2301      	movs	r3, #1
 800c7b6:	617b      	str	r3, [r7, #20]
 800c7b8:	e007      	b.n	800c7ca <prvInsertTimerInActiveList+0x72>
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 800c7ba:	4b07      	ldr	r3, [pc, #28]	; (800c7d8 <prvInsertTimerInActiveList+0x80>)
 800c7bc:	681a      	ldr	r2, [r3, #0]
 800c7be:	68fb      	ldr	r3, [r7, #12]
 800c7c0:	3304      	adds	r3, #4
 800c7c2:	4619      	mov	r1, r3
 800c7c4:	4610      	mov	r0, r2
 800c7c6:	f7fd ff39 	bl	800a63c <vListInsert>
		}
	}

	return xProcessTimerNow;
 800c7ca:	697b      	ldr	r3, [r7, #20]
}
 800c7cc:	4618      	mov	r0, r3
 800c7ce:	3718      	adds	r7, #24
 800c7d0:	46bd      	mov	sp, r7
 800c7d2:	bd80      	pop	{r7, pc}
 800c7d4:	240003bc 	.word	0x240003bc
 800c7d8:	240003b8 	.word	0x240003b8

0800c7dc <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

static void	prvProcessReceivedCommands( void )
{
 800c7dc:	b580      	push	{r7, lr}
 800c7de:	b08c      	sub	sp, #48	; 0x30
 800c7e0:	af02      	add	r7, sp, #8
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 800c7e2:	e0ae      	b.n	800c942 <prvProcessReceivedCommands+0x166>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 800c7e4:	68bb      	ldr	r3, [r7, #8]
 800c7e6:	2b00      	cmp	r3, #0
 800c7e8:	f2c0 80aa 	blt.w	800c940 <prvProcessReceivedCommands+0x164>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
 800c7ec:	693b      	ldr	r3, [r7, #16]
 800c7ee:	627b      	str	r3, [r7, #36]	; 0x24

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
 800c7f0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c7f2:	695b      	ldr	r3, [r3, #20]
 800c7f4:	2b00      	cmp	r3, #0
 800c7f6:	d004      	beq.n	800c802 <prvProcessReceivedCommands+0x26>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 800c7f8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c7fa:	3304      	adds	r3, #4
 800c7fc:	4618      	mov	r0, r3
 800c7fe:	f7fd ff56 	bl	800a6ae <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 800c802:	1d3b      	adds	r3, r7, #4
 800c804:	4618      	mov	r0, r3
 800c806:	f7ff ff87 	bl	800c718 <prvSampleTimeNow>
 800c80a:	6238      	str	r0, [r7, #32]

			switch( xMessage.xMessageID )
 800c80c:	68bb      	ldr	r3, [r7, #8]
 800c80e:	2b09      	cmp	r3, #9
 800c810:	f200 8097 	bhi.w	800c942 <prvProcessReceivedCommands+0x166>
 800c814:	a201      	add	r2, pc, #4	; (adr r2, 800c81c <prvProcessReceivedCommands+0x40>)
 800c816:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800c81a:	bf00      	nop
 800c81c:	0800c845 	.word	0x0800c845
 800c820:	0800c845 	.word	0x0800c845
 800c824:	0800c845 	.word	0x0800c845
 800c828:	0800c8b9 	.word	0x0800c8b9
 800c82c:	0800c8cd 	.word	0x0800c8cd
 800c830:	0800c917 	.word	0x0800c917
 800c834:	0800c845 	.word	0x0800c845
 800c838:	0800c845 	.word	0x0800c845
 800c83c:	0800c8b9 	.word	0x0800c8b9
 800c840:	0800c8cd 	.word	0x0800c8cd
				case tmrCOMMAND_START_FROM_ISR :
				case tmrCOMMAND_RESET :
				case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 800c844:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c846:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800c84a:	f043 0301 	orr.w	r3, r3, #1
 800c84e:	b2da      	uxtb	r2, r3
 800c850:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c852:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 800c856:	68fa      	ldr	r2, [r7, #12]
 800c858:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c85a:	699b      	ldr	r3, [r3, #24]
 800c85c:	18d1      	adds	r1, r2, r3
 800c85e:	68fb      	ldr	r3, [r7, #12]
 800c860:	6a3a      	ldr	r2, [r7, #32]
 800c862:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800c864:	f7ff ff78 	bl	800c758 <prvInsertTimerInActiveList>
 800c868:	4603      	mov	r3, r0
 800c86a:	2b00      	cmp	r3, #0
 800c86c:	d069      	beq.n	800c942 <prvProcessReceivedCommands+0x166>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 800c86e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c870:	6a1b      	ldr	r3, [r3, #32]
 800c872:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800c874:	4798      	blx	r3
						traceTIMER_EXPIRED( pxTimer );

						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 800c876:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c878:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800c87c:	f003 0304 	and.w	r3, r3, #4
 800c880:	2b00      	cmp	r3, #0
 800c882:	d05e      	beq.n	800c942 <prvProcessReceivedCommands+0x166>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 800c884:	68fa      	ldr	r2, [r7, #12]
 800c886:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c888:	699b      	ldr	r3, [r3, #24]
 800c88a:	441a      	add	r2, r3
 800c88c:	2300      	movs	r3, #0
 800c88e:	9300      	str	r3, [sp, #0]
 800c890:	2300      	movs	r3, #0
 800c892:	2100      	movs	r1, #0
 800c894:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800c896:	f7ff fe21 	bl	800c4dc <xTimerGenericCommand>
 800c89a:	61f8      	str	r0, [r7, #28]
							configASSERT( xResult );
 800c89c:	69fb      	ldr	r3, [r7, #28]
 800c89e:	2b00      	cmp	r3, #0
 800c8a0:	d14f      	bne.n	800c942 <prvProcessReceivedCommands+0x166>
	__asm volatile
 800c8a2:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c8a6:	f383 8811 	msr	BASEPRI, r3
 800c8aa:	f3bf 8f6f 	isb	sy
 800c8ae:	f3bf 8f4f 	dsb	sy
 800c8b2:	61bb      	str	r3, [r7, #24]
}
 800c8b4:	bf00      	nop
 800c8b6:	e7fe      	b.n	800c8b6 <prvProcessReceivedCommands+0xda>
					break;

				case tmrCOMMAND_STOP :
				case tmrCOMMAND_STOP_FROM_ISR :
					/* The timer has already been removed from the active list. */
					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 800c8b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c8ba:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800c8be:	f023 0301 	bic.w	r3, r3, #1
 800c8c2:	b2da      	uxtb	r2, r3
 800c8c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c8c6:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
					break;
 800c8ca:	e03a      	b.n	800c942 <prvProcessReceivedCommands+0x166>

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 800c8cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c8ce:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800c8d2:	f043 0301 	orr.w	r3, r3, #1
 800c8d6:	b2da      	uxtb	r2, r3
 800c8d8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c8da:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 800c8de:	68fa      	ldr	r2, [r7, #12]
 800c8e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c8e2:	619a      	str	r2, [r3, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 800c8e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c8e6:	699b      	ldr	r3, [r3, #24]
 800c8e8:	2b00      	cmp	r3, #0
 800c8ea:	d10a      	bne.n	800c902 <prvProcessReceivedCommands+0x126>
	__asm volatile
 800c8ec:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c8f0:	f383 8811 	msr	BASEPRI, r3
 800c8f4:	f3bf 8f6f 	isb	sy
 800c8f8:	f3bf 8f4f 	dsb	sy
 800c8fc:	617b      	str	r3, [r7, #20]
}
 800c8fe:	bf00      	nop
 800c900:	e7fe      	b.n	800c900 <prvProcessReceivedCommands+0x124>
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 800c902:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c904:	699a      	ldr	r2, [r3, #24]
 800c906:	6a3b      	ldr	r3, [r7, #32]
 800c908:	18d1      	adds	r1, r2, r3
 800c90a:	6a3b      	ldr	r3, [r7, #32]
 800c90c:	6a3a      	ldr	r2, [r7, #32]
 800c90e:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800c910:	f7ff ff22 	bl	800c758 <prvInsertTimerInActiveList>
					break;
 800c914:	e015      	b.n	800c942 <prvProcessReceivedCommands+0x166>
					#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
					{
						/* The timer has already been removed from the active list,
						just free up the memory if the memory was dynamically
						allocated. */
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
 800c916:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c918:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800c91c:	f003 0302 	and.w	r3, r3, #2
 800c920:	2b00      	cmp	r3, #0
 800c922:	d103      	bne.n	800c92c <prvProcessReceivedCommands+0x150>
						{
							vPortFree( pxTimer );
 800c924:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800c926:	f000 fc13 	bl	800d150 <vPortFree>
 800c92a:	e00a      	b.n	800c942 <prvProcessReceivedCommands+0x166>
						}
						else
						{
							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 800c92c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c92e:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800c932:	f023 0301 	bic.w	r3, r3, #1
 800c936:	b2da      	uxtb	r2, r3
 800c938:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c93a:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
						no need to free the memory - just mark the timer as
						"not active". */
						pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
					}
					#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
					break;
 800c93e:	e000      	b.n	800c942 <prvProcessReceivedCommands+0x166>

				default	:
					/* Don't expect to get here. */
					break;
			}
		}
 800c940:	bf00      	nop
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 800c942:	4b08      	ldr	r3, [pc, #32]	; (800c964 <prvProcessReceivedCommands+0x188>)
 800c944:	681b      	ldr	r3, [r3, #0]
 800c946:	f107 0108 	add.w	r1, r7, #8
 800c94a:	2200      	movs	r2, #0
 800c94c:	4618      	mov	r0, r3
 800c94e:	f7fe f9ef 	bl	800ad30 <xQueueReceive>
 800c952:	4603      	mov	r3, r0
 800c954:	2b00      	cmp	r3, #0
 800c956:	f47f af45 	bne.w	800c7e4 <prvProcessReceivedCommands+0x8>
	}
}
 800c95a:	bf00      	nop
 800c95c:	bf00      	nop
 800c95e:	3728      	adds	r7, #40	; 0x28
 800c960:	46bd      	mov	sp, r7
 800c962:	bd80      	pop	{r7, pc}
 800c964:	240003c0 	.word	0x240003c0

0800c968 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
 800c968:	b580      	push	{r7, lr}
 800c96a:	b088      	sub	sp, #32
 800c96c:	af02      	add	r7, sp, #8

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 800c96e:	e048      	b.n	800ca02 <prvSwitchTimerLists+0x9a>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 800c970:	4b2d      	ldr	r3, [pc, #180]	; (800ca28 <prvSwitchTimerLists+0xc0>)
 800c972:	681b      	ldr	r3, [r3, #0]
 800c974:	68db      	ldr	r3, [r3, #12]
 800c976:	681b      	ldr	r3, [r3, #0]
 800c978:	613b      	str	r3, [r7, #16]

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800c97a:	4b2b      	ldr	r3, [pc, #172]	; (800ca28 <prvSwitchTimerLists+0xc0>)
 800c97c:	681b      	ldr	r3, [r3, #0]
 800c97e:	68db      	ldr	r3, [r3, #12]
 800c980:	68db      	ldr	r3, [r3, #12]
 800c982:	60fb      	str	r3, [r7, #12]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 800c984:	68fb      	ldr	r3, [r7, #12]
 800c986:	3304      	adds	r3, #4
 800c988:	4618      	mov	r0, r3
 800c98a:	f7fd fe90 	bl	800a6ae <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 800c98e:	68fb      	ldr	r3, [r7, #12]
 800c990:	6a1b      	ldr	r3, [r3, #32]
 800c992:	68f8      	ldr	r0, [r7, #12]
 800c994:	4798      	blx	r3

		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 800c996:	68fb      	ldr	r3, [r7, #12]
 800c998:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800c99c:	f003 0304 	and.w	r3, r3, #4
 800c9a0:	2b00      	cmp	r3, #0
 800c9a2:	d02e      	beq.n	800ca02 <prvSwitchTimerLists+0x9a>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 800c9a4:	68fb      	ldr	r3, [r7, #12]
 800c9a6:	699b      	ldr	r3, [r3, #24]
 800c9a8:	693a      	ldr	r2, [r7, #16]
 800c9aa:	4413      	add	r3, r2
 800c9ac:	60bb      	str	r3, [r7, #8]
			if( xReloadTime > xNextExpireTime )
 800c9ae:	68ba      	ldr	r2, [r7, #8]
 800c9b0:	693b      	ldr	r3, [r7, #16]
 800c9b2:	429a      	cmp	r2, r3
 800c9b4:	d90e      	bls.n	800c9d4 <prvSwitchTimerLists+0x6c>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 800c9b6:	68fb      	ldr	r3, [r7, #12]
 800c9b8:	68ba      	ldr	r2, [r7, #8]
 800c9ba:	605a      	str	r2, [r3, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 800c9bc:	68fb      	ldr	r3, [r7, #12]
 800c9be:	68fa      	ldr	r2, [r7, #12]
 800c9c0:	611a      	str	r2, [r3, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 800c9c2:	4b19      	ldr	r3, [pc, #100]	; (800ca28 <prvSwitchTimerLists+0xc0>)
 800c9c4:	681a      	ldr	r2, [r3, #0]
 800c9c6:	68fb      	ldr	r3, [r7, #12]
 800c9c8:	3304      	adds	r3, #4
 800c9ca:	4619      	mov	r1, r3
 800c9cc:	4610      	mov	r0, r2
 800c9ce:	f7fd fe35 	bl	800a63c <vListInsert>
 800c9d2:	e016      	b.n	800ca02 <prvSwitchTimerLists+0x9a>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 800c9d4:	2300      	movs	r3, #0
 800c9d6:	9300      	str	r3, [sp, #0]
 800c9d8:	2300      	movs	r3, #0
 800c9da:	693a      	ldr	r2, [r7, #16]
 800c9dc:	2100      	movs	r1, #0
 800c9de:	68f8      	ldr	r0, [r7, #12]
 800c9e0:	f7ff fd7c 	bl	800c4dc <xTimerGenericCommand>
 800c9e4:	6078      	str	r0, [r7, #4]
				configASSERT( xResult );
 800c9e6:	687b      	ldr	r3, [r7, #4]
 800c9e8:	2b00      	cmp	r3, #0
 800c9ea:	d10a      	bne.n	800ca02 <prvSwitchTimerLists+0x9a>
	__asm volatile
 800c9ec:	f04f 0350 	mov.w	r3, #80	; 0x50
 800c9f0:	f383 8811 	msr	BASEPRI, r3
 800c9f4:	f3bf 8f6f 	isb	sy
 800c9f8:	f3bf 8f4f 	dsb	sy
 800c9fc:	603b      	str	r3, [r7, #0]
}
 800c9fe:	bf00      	nop
 800ca00:	e7fe      	b.n	800ca00 <prvSwitchTimerLists+0x98>
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 800ca02:	4b09      	ldr	r3, [pc, #36]	; (800ca28 <prvSwitchTimerLists+0xc0>)
 800ca04:	681b      	ldr	r3, [r3, #0]
 800ca06:	681b      	ldr	r3, [r3, #0]
 800ca08:	2b00      	cmp	r3, #0
 800ca0a:	d1b1      	bne.n	800c970 <prvSwitchTimerLists+0x8>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
 800ca0c:	4b06      	ldr	r3, [pc, #24]	; (800ca28 <prvSwitchTimerLists+0xc0>)
 800ca0e:	681b      	ldr	r3, [r3, #0]
 800ca10:	617b      	str	r3, [r7, #20]
	pxCurrentTimerList = pxOverflowTimerList;
 800ca12:	4b06      	ldr	r3, [pc, #24]	; (800ca2c <prvSwitchTimerLists+0xc4>)
 800ca14:	681b      	ldr	r3, [r3, #0]
 800ca16:	4a04      	ldr	r2, [pc, #16]	; (800ca28 <prvSwitchTimerLists+0xc0>)
 800ca18:	6013      	str	r3, [r2, #0]
	pxOverflowTimerList = pxTemp;
 800ca1a:	4a04      	ldr	r2, [pc, #16]	; (800ca2c <prvSwitchTimerLists+0xc4>)
 800ca1c:	697b      	ldr	r3, [r7, #20]
 800ca1e:	6013      	str	r3, [r2, #0]
}
 800ca20:	bf00      	nop
 800ca22:	3718      	adds	r7, #24
 800ca24:	46bd      	mov	sp, r7
 800ca26:	bd80      	pop	{r7, pc}
 800ca28:	240003b8 	.word	0x240003b8
 800ca2c:	240003bc 	.word	0x240003bc

0800ca30 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
 800ca30:	b580      	push	{r7, lr}
 800ca32:	af00      	add	r7, sp, #0
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
 800ca34:	f000 f99e 	bl	800cd74 <vPortEnterCritical>
	{
		if( xTimerQueue == NULL )
 800ca38:	4b12      	ldr	r3, [pc, #72]	; (800ca84 <prvCheckForValidListAndQueue+0x54>)
 800ca3a:	681b      	ldr	r3, [r3, #0]
 800ca3c:	2b00      	cmp	r3, #0
 800ca3e:	d11d      	bne.n	800ca7c <prvCheckForValidListAndQueue+0x4c>
		{
			vListInitialise( &xActiveTimerList1 );
 800ca40:	4811      	ldr	r0, [pc, #68]	; (800ca88 <prvCheckForValidListAndQueue+0x58>)
 800ca42:	f7fd fdaa 	bl	800a59a <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 800ca46:	4811      	ldr	r0, [pc, #68]	; (800ca8c <prvCheckForValidListAndQueue+0x5c>)
 800ca48:	f7fd fda7 	bl	800a59a <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
 800ca4c:	4b10      	ldr	r3, [pc, #64]	; (800ca90 <prvCheckForValidListAndQueue+0x60>)
 800ca4e:	4a0e      	ldr	r2, [pc, #56]	; (800ca88 <prvCheckForValidListAndQueue+0x58>)
 800ca50:	601a      	str	r2, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
 800ca52:	4b10      	ldr	r3, [pc, #64]	; (800ca94 <prvCheckForValidListAndQueue+0x64>)
 800ca54:	4a0d      	ldr	r2, [pc, #52]	; (800ca8c <prvCheckForValidListAndQueue+0x5c>)
 800ca56:	601a      	str	r2, [r3, #0]

				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
			}
			#else
			{
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
 800ca58:	2200      	movs	r2, #0
 800ca5a:	210c      	movs	r1, #12
 800ca5c:	2010      	movs	r0, #16
 800ca5e:	f7fd feb9 	bl	800a7d4 <xQueueGenericCreate>
 800ca62:	4603      	mov	r3, r0
 800ca64:	4a07      	ldr	r2, [pc, #28]	; (800ca84 <prvCheckForValidListAndQueue+0x54>)
 800ca66:	6013      	str	r3, [r2, #0]
			}
			#endif

			#if ( configQUEUE_REGISTRY_SIZE > 0 )
			{
				if( xTimerQueue != NULL )
 800ca68:	4b06      	ldr	r3, [pc, #24]	; (800ca84 <prvCheckForValidListAndQueue+0x54>)
 800ca6a:	681b      	ldr	r3, [r3, #0]
 800ca6c:	2b00      	cmp	r3, #0
 800ca6e:	d005      	beq.n	800ca7c <prvCheckForValidListAndQueue+0x4c>
				{
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 800ca70:	4b04      	ldr	r3, [pc, #16]	; (800ca84 <prvCheckForValidListAndQueue+0x54>)
 800ca72:	681b      	ldr	r3, [r3, #0]
 800ca74:	4908      	ldr	r1, [pc, #32]	; (800ca98 <prvCheckForValidListAndQueue+0x68>)
 800ca76:	4618      	mov	r0, r3
 800ca78:	f7fe fc6e 	bl	800b358 <vQueueAddToRegistry>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 800ca7c:	f000 f9aa 	bl	800cdd4 <vPortExitCritical>
}
 800ca80:	bf00      	nop
 800ca82:	bd80      	pop	{r7, pc}
 800ca84:	240003c0 	.word	0x240003c0
 800ca88:	24000390 	.word	0x24000390
 800ca8c:	240003a4 	.word	0x240003a4
 800ca90:	240003b8 	.word	0x240003b8
 800ca94:	240003bc 	.word	0x240003bc
 800ca98:	080225cc 	.word	0x080225cc

0800ca9c <pvTimerGetTimerID>:
	return xReturn;
} /*lint !e818 Can't be pointer to const due to the typedef. */
/*-----------------------------------------------------------*/

void *pvTimerGetTimerID( const TimerHandle_t xTimer )
{
 800ca9c:	b580      	push	{r7, lr}
 800ca9e:	b086      	sub	sp, #24
 800caa0:	af00      	add	r7, sp, #0
 800caa2:	6078      	str	r0, [r7, #4]
Timer_t * const pxTimer = xTimer;
 800caa4:	687b      	ldr	r3, [r7, #4]
 800caa6:	617b      	str	r3, [r7, #20]
void *pvReturn;

	configASSERT( xTimer );
 800caa8:	687b      	ldr	r3, [r7, #4]
 800caaa:	2b00      	cmp	r3, #0
 800caac:	d10a      	bne.n	800cac4 <pvTimerGetTimerID+0x28>
	__asm volatile
 800caae:	f04f 0350 	mov.w	r3, #80	; 0x50
 800cab2:	f383 8811 	msr	BASEPRI, r3
 800cab6:	f3bf 8f6f 	isb	sy
 800caba:	f3bf 8f4f 	dsb	sy
 800cabe:	60fb      	str	r3, [r7, #12]
}
 800cac0:	bf00      	nop
 800cac2:	e7fe      	b.n	800cac2 <pvTimerGetTimerID+0x26>

	taskENTER_CRITICAL();
 800cac4:	f000 f956 	bl	800cd74 <vPortEnterCritical>
	{
		pvReturn = pxTimer->pvTimerID;
 800cac8:	697b      	ldr	r3, [r7, #20]
 800caca:	69db      	ldr	r3, [r3, #28]
 800cacc:	613b      	str	r3, [r7, #16]
	}
	taskEXIT_CRITICAL();
 800cace:	f000 f981 	bl	800cdd4 <vPortExitCritical>

	return pvReturn;
 800cad2:	693b      	ldr	r3, [r7, #16]
}
 800cad4:	4618      	mov	r0, r3
 800cad6:	3718      	adds	r7, #24
 800cad8:	46bd      	mov	sp, r7
 800cada:	bd80      	pop	{r7, pc}

0800cadc <vTimerSetTimerID>:
/*-----------------------------------------------------------*/

void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID )
{
 800cadc:	b580      	push	{r7, lr}
 800cade:	b084      	sub	sp, #16
 800cae0:	af00      	add	r7, sp, #0
 800cae2:	6078      	str	r0, [r7, #4]
 800cae4:	6039      	str	r1, [r7, #0]
Timer_t * const pxTimer = xTimer;
 800cae6:	687b      	ldr	r3, [r7, #4]
 800cae8:	60fb      	str	r3, [r7, #12]

	configASSERT( xTimer );
 800caea:	687b      	ldr	r3, [r7, #4]
 800caec:	2b00      	cmp	r3, #0
 800caee:	d10a      	bne.n	800cb06 <vTimerSetTimerID+0x2a>
	__asm volatile
 800caf0:	f04f 0350 	mov.w	r3, #80	; 0x50
 800caf4:	f383 8811 	msr	BASEPRI, r3
 800caf8:	f3bf 8f6f 	isb	sy
 800cafc:	f3bf 8f4f 	dsb	sy
 800cb00:	60bb      	str	r3, [r7, #8]
}
 800cb02:	bf00      	nop
 800cb04:	e7fe      	b.n	800cb04 <vTimerSetTimerID+0x28>

	taskENTER_CRITICAL();
 800cb06:	f000 f935 	bl	800cd74 <vPortEnterCritical>
	{
		pxTimer->pvTimerID = pvNewID;
 800cb0a:	68fb      	ldr	r3, [r7, #12]
 800cb0c:	683a      	ldr	r2, [r7, #0]
 800cb0e:	61da      	str	r2, [r3, #28]
	}
	taskEXIT_CRITICAL();
 800cb10:	f000 f960 	bl	800cdd4 <vPortExitCritical>
}
 800cb14:	bf00      	nop
 800cb16:	3710      	adds	r7, #16
 800cb18:	46bd      	mov	sp, r7
 800cb1a:	bd80      	pop	{r7, pc}

0800cb1c <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
 800cb1c:	b480      	push	{r7}
 800cb1e:	b085      	sub	sp, #20
 800cb20:	af00      	add	r7, sp, #0
 800cb22:	60f8      	str	r0, [r7, #12]
 800cb24:	60b9      	str	r1, [r7, #8]
 800cb26:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */

	/* Offset added to account for the way the MCU uses the stack on entry/exit
	of interrupts, and to ensure alignment. */
	pxTopOfStack--;
 800cb28:	68fb      	ldr	r3, [r7, #12]
 800cb2a:	3b04      	subs	r3, #4
 800cb2c:	60fb      	str	r3, [r7, #12]

	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 800cb2e:	68fb      	ldr	r3, [r7, #12]
 800cb30:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 800cb34:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 800cb36:	68fb      	ldr	r3, [r7, #12]
 800cb38:	3b04      	subs	r3, #4
 800cb3a:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 800cb3c:	68bb      	ldr	r3, [r7, #8]
 800cb3e:	f023 0201 	bic.w	r2, r3, #1
 800cb42:	68fb      	ldr	r3, [r7, #12]
 800cb44:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 800cb46:	68fb      	ldr	r3, [r7, #12]
 800cb48:	3b04      	subs	r3, #4
 800cb4a:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 800cb4c:	4a0c      	ldr	r2, [pc, #48]	; (800cb80 <pxPortInitialiseStack+0x64>)
 800cb4e:	68fb      	ldr	r3, [r7, #12]
 800cb50:	601a      	str	r2, [r3, #0]

	/* Save code space by skipping register initialisation. */
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
 800cb52:	68fb      	ldr	r3, [r7, #12]
 800cb54:	3b14      	subs	r3, #20
 800cb56:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 800cb58:	687a      	ldr	r2, [r7, #4]
 800cb5a:	68fb      	ldr	r3, [r7, #12]
 800cb5c:	601a      	str	r2, [r3, #0]

	/* A save method is being used that requires each task to maintain its
	own exec return value. */
	pxTopOfStack--;
 800cb5e:	68fb      	ldr	r3, [r7, #12]
 800cb60:	3b04      	subs	r3, #4
 800cb62:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
 800cb64:	68fb      	ldr	r3, [r7, #12]
 800cb66:	f06f 0202 	mvn.w	r2, #2
 800cb6a:	601a      	str	r2, [r3, #0]

	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
 800cb6c:	68fb      	ldr	r3, [r7, #12]
 800cb6e:	3b20      	subs	r3, #32
 800cb70:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
 800cb72:	68fb      	ldr	r3, [r7, #12]
}
 800cb74:	4618      	mov	r0, r3
 800cb76:	3714      	adds	r7, #20
 800cb78:	46bd      	mov	sp, r7
 800cb7a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cb7e:	4770      	bx	lr
 800cb80:	0800cb85 	.word	0x0800cb85

0800cb84 <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
 800cb84:	b480      	push	{r7}
 800cb86:	b085      	sub	sp, #20
 800cb88:	af00      	add	r7, sp, #0
volatile uint32_t ulDummy = 0;
 800cb8a:	2300      	movs	r3, #0
 800cb8c:	607b      	str	r3, [r7, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 800cb8e:	4b12      	ldr	r3, [pc, #72]	; (800cbd8 <prvTaskExitError+0x54>)
 800cb90:	681b      	ldr	r3, [r3, #0]
 800cb92:	f1b3 3fff 	cmp.w	r3, #4294967295
 800cb96:	d00a      	beq.n	800cbae <prvTaskExitError+0x2a>
	__asm volatile
 800cb98:	f04f 0350 	mov.w	r3, #80	; 0x50
 800cb9c:	f383 8811 	msr	BASEPRI, r3
 800cba0:	f3bf 8f6f 	isb	sy
 800cba4:	f3bf 8f4f 	dsb	sy
 800cba8:	60fb      	str	r3, [r7, #12]
}
 800cbaa:	bf00      	nop
 800cbac:	e7fe      	b.n	800cbac <prvTaskExitError+0x28>
	__asm volatile
 800cbae:	f04f 0350 	mov.w	r3, #80	; 0x50
 800cbb2:	f383 8811 	msr	BASEPRI, r3
 800cbb6:	f3bf 8f6f 	isb	sy
 800cbba:	f3bf 8f4f 	dsb	sy
 800cbbe:	60bb      	str	r3, [r7, #8]
}
 800cbc0:	bf00      	nop
	portDISABLE_INTERRUPTS();
	while( ulDummy == 0 )
 800cbc2:	bf00      	nop
 800cbc4:	687b      	ldr	r3, [r7, #4]
 800cbc6:	2b00      	cmp	r3, #0
 800cbc8:	d0fc      	beq.n	800cbc4 <prvTaskExitError+0x40>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
 800cbca:	bf00      	nop
 800cbcc:	bf00      	nop
 800cbce:	3714      	adds	r7, #20
 800cbd0:	46bd      	mov	sp, r7
 800cbd2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cbd6:	4770      	bx	lr
 800cbd8:	24000008 	.word	0x24000008
 800cbdc:	00000000 	.word	0x00000000

0800cbe0 <SVC_Handler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 800cbe0:	4b07      	ldr	r3, [pc, #28]	; (800cc00 <pxCurrentTCBConst2>)
 800cbe2:	6819      	ldr	r1, [r3, #0]
 800cbe4:	6808      	ldr	r0, [r1, #0]
 800cbe6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800cbea:	f380 8809 	msr	PSP, r0
 800cbee:	f3bf 8f6f 	isb	sy
 800cbf2:	f04f 0000 	mov.w	r0, #0
 800cbf6:	f380 8811 	msr	BASEPRI, r0
 800cbfa:	4770      	bx	lr
 800cbfc:	f3af 8000 	nop.w

0800cc00 <pxCurrentTCBConst2>:
 800cc00:	24000264 	.word	0x24000264
					"	bx r14							\n"
					"									\n"
					"	.align 4						\n"
					"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
				);
}
 800cc04:	bf00      	nop
 800cc06:	bf00      	nop

0800cc08 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(
 800cc08:	4808      	ldr	r0, [pc, #32]	; (800cc2c <prvPortStartFirstTask+0x24>)
 800cc0a:	6800      	ldr	r0, [r0, #0]
 800cc0c:	6800      	ldr	r0, [r0, #0]
 800cc0e:	f380 8808 	msr	MSP, r0
 800cc12:	f04f 0000 	mov.w	r0, #0
 800cc16:	f380 8814 	msr	CONTROL, r0
 800cc1a:	b662      	cpsie	i
 800cc1c:	b661      	cpsie	f
 800cc1e:	f3bf 8f4f 	dsb	sy
 800cc22:	f3bf 8f6f 	isb	sy
 800cc26:	df00      	svc	0
 800cc28:	bf00      	nop
					" dsb					\n"
					" isb					\n"
					" svc 0					\n" /* System call to start first task. */
					" nop					\n"
				);
}
 800cc2a:	bf00      	nop
 800cc2c:	e000ed08 	.word	0xe000ed08

0800cc30 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
 800cc30:	b580      	push	{r7, lr}
 800cc32:	b086      	sub	sp, #24
 800cc34:	af00      	add	r7, sp, #0
	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );

	/* This port can be used on all revisions of the Cortex-M7 core other than
	the r0p1 parts.  r0p1 parts should use the port from the
	/source/portable/GCC/ARM_CM7/r0p1 directory. */
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 800cc36:	4b46      	ldr	r3, [pc, #280]	; (800cd50 <xPortStartScheduler+0x120>)
 800cc38:	681b      	ldr	r3, [r3, #0]
 800cc3a:	4a46      	ldr	r2, [pc, #280]	; (800cd54 <xPortStartScheduler+0x124>)
 800cc3c:	4293      	cmp	r3, r2
 800cc3e:	d10a      	bne.n	800cc56 <xPortStartScheduler+0x26>
	__asm volatile
 800cc40:	f04f 0350 	mov.w	r3, #80	; 0x50
 800cc44:	f383 8811 	msr	BASEPRI, r3
 800cc48:	f3bf 8f6f 	isb	sy
 800cc4c:	f3bf 8f4f 	dsb	sy
 800cc50:	613b      	str	r3, [r7, #16]
}
 800cc52:	bf00      	nop
 800cc54:	e7fe      	b.n	800cc54 <xPortStartScheduler+0x24>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 800cc56:	4b3e      	ldr	r3, [pc, #248]	; (800cd50 <xPortStartScheduler+0x120>)
 800cc58:	681b      	ldr	r3, [r3, #0]
 800cc5a:	4a3f      	ldr	r2, [pc, #252]	; (800cd58 <xPortStartScheduler+0x128>)
 800cc5c:	4293      	cmp	r3, r2
 800cc5e:	d10a      	bne.n	800cc76 <xPortStartScheduler+0x46>
	__asm volatile
 800cc60:	f04f 0350 	mov.w	r3, #80	; 0x50
 800cc64:	f383 8811 	msr	BASEPRI, r3
 800cc68:	f3bf 8f6f 	isb	sy
 800cc6c:	f3bf 8f4f 	dsb	sy
 800cc70:	60fb      	str	r3, [r7, #12]
}
 800cc72:	bf00      	nop
 800cc74:	e7fe      	b.n	800cc74 <xPortStartScheduler+0x44>

	#if( configASSERT_DEFINED == 1 )
	{
		volatile uint32_t ulOriginalPriority;
		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
 800cc76:	4b39      	ldr	r3, [pc, #228]	; (800cd5c <xPortStartScheduler+0x12c>)
 800cc78:	617b      	str	r3, [r7, #20]
		functions can be called.  ISR safe functions are those that end in
		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
		ensure interrupt entry is as fast and simple as possible.

		Save the interrupt priority value that is about to be clobbered. */
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 800cc7a:	697b      	ldr	r3, [r7, #20]
 800cc7c:	781b      	ldrb	r3, [r3, #0]
 800cc7e:	b2db      	uxtb	r3, r3
 800cc80:	607b      	str	r3, [r7, #4]

		/* Determine the number of priority bits available.  First write to all
		possible bits. */
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 800cc82:	697b      	ldr	r3, [r7, #20]
 800cc84:	22ff      	movs	r2, #255	; 0xff
 800cc86:	701a      	strb	r2, [r3, #0]

		/* Read the value back to see how many bits stuck. */
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 800cc88:	697b      	ldr	r3, [r7, #20]
 800cc8a:	781b      	ldrb	r3, [r3, #0]
 800cc8c:	b2db      	uxtb	r3, r3
 800cc8e:	70fb      	strb	r3, [r7, #3]

		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 800cc90:	78fb      	ldrb	r3, [r7, #3]
 800cc92:	b2db      	uxtb	r3, r3
 800cc94:	f003 0350 	and.w	r3, r3, #80	; 0x50
 800cc98:	b2da      	uxtb	r2, r3
 800cc9a:	4b31      	ldr	r3, [pc, #196]	; (800cd60 <xPortStartScheduler+0x130>)
 800cc9c:	701a      	strb	r2, [r3, #0]

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 800cc9e:	4b31      	ldr	r3, [pc, #196]	; (800cd64 <xPortStartScheduler+0x134>)
 800cca0:	2207      	movs	r2, #7
 800cca2:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 800cca4:	e009      	b.n	800ccba <xPortStartScheduler+0x8a>
		{
			ulMaxPRIGROUPValue--;
 800cca6:	4b2f      	ldr	r3, [pc, #188]	; (800cd64 <xPortStartScheduler+0x134>)
 800cca8:	681b      	ldr	r3, [r3, #0]
 800ccaa:	3b01      	subs	r3, #1
 800ccac:	4a2d      	ldr	r2, [pc, #180]	; (800cd64 <xPortStartScheduler+0x134>)
 800ccae:	6013      	str	r3, [r2, #0]
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 800ccb0:	78fb      	ldrb	r3, [r7, #3]
 800ccb2:	b2db      	uxtb	r3, r3
 800ccb4:	005b      	lsls	r3, r3, #1
 800ccb6:	b2db      	uxtb	r3, r3
 800ccb8:	70fb      	strb	r3, [r7, #3]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 800ccba:	78fb      	ldrb	r3, [r7, #3]
 800ccbc:	b2db      	uxtb	r3, r3
 800ccbe:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800ccc2:	2b80      	cmp	r3, #128	; 0x80
 800ccc4:	d0ef      	beq.n	800cca6 <xPortStartScheduler+0x76>
		#ifdef configPRIO_BITS
		{
			/* Check the FreeRTOS configuration that defines the number of
			priority bits matches the number of priority bits actually queried
			from the hardware. */
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
 800ccc6:	4b27      	ldr	r3, [pc, #156]	; (800cd64 <xPortStartScheduler+0x134>)
 800ccc8:	681b      	ldr	r3, [r3, #0]
 800ccca:	f1c3 0307 	rsb	r3, r3, #7
 800ccce:	2b04      	cmp	r3, #4
 800ccd0:	d00a      	beq.n	800cce8 <xPortStartScheduler+0xb8>
	__asm volatile
 800ccd2:	f04f 0350 	mov.w	r3, #80	; 0x50
 800ccd6:	f383 8811 	msr	BASEPRI, r3
 800ccda:	f3bf 8f6f 	isb	sy
 800ccde:	f3bf 8f4f 	dsb	sy
 800cce2:	60bb      	str	r3, [r7, #8]
}
 800cce4:	bf00      	nop
 800cce6:	e7fe      	b.n	800cce6 <xPortStartScheduler+0xb6>
		}
		#endif

		/* Shift the priority group value back to its position within the AIRCR
		register. */
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 800cce8:	4b1e      	ldr	r3, [pc, #120]	; (800cd64 <xPortStartScheduler+0x134>)
 800ccea:	681b      	ldr	r3, [r3, #0]
 800ccec:	021b      	lsls	r3, r3, #8
 800ccee:	4a1d      	ldr	r2, [pc, #116]	; (800cd64 <xPortStartScheduler+0x134>)
 800ccf0:	6013      	str	r3, [r2, #0]
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 800ccf2:	4b1c      	ldr	r3, [pc, #112]	; (800cd64 <xPortStartScheduler+0x134>)
 800ccf4:	681b      	ldr	r3, [r3, #0]
 800ccf6:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800ccfa:	4a1a      	ldr	r2, [pc, #104]	; (800cd64 <xPortStartScheduler+0x134>)
 800ccfc:	6013      	str	r3, [r2, #0]

		/* Restore the clobbered interrupt priority register to its original
		value. */
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 800ccfe:	687b      	ldr	r3, [r7, #4]
 800cd00:	b2da      	uxtb	r2, r3
 800cd02:	697b      	ldr	r3, [r7, #20]
 800cd04:	701a      	strb	r2, [r3, #0]
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 800cd06:	4b18      	ldr	r3, [pc, #96]	; (800cd68 <xPortStartScheduler+0x138>)
 800cd08:	681b      	ldr	r3, [r3, #0]
 800cd0a:	4a17      	ldr	r2, [pc, #92]	; (800cd68 <xPortStartScheduler+0x138>)
 800cd0c:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 800cd10:	6013      	str	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 800cd12:	4b15      	ldr	r3, [pc, #84]	; (800cd68 <xPortStartScheduler+0x138>)
 800cd14:	681b      	ldr	r3, [r3, #0]
 800cd16:	4a14      	ldr	r2, [pc, #80]	; (800cd68 <xPortStartScheduler+0x138>)
 800cd18:	f043 4370 	orr.w	r3, r3, #4026531840	; 0xf0000000
 800cd1c:	6013      	str	r3, [r2, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
 800cd1e:	f000 f8dd 	bl	800cedc <vPortSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 800cd22:	4b12      	ldr	r3, [pc, #72]	; (800cd6c <xPortStartScheduler+0x13c>)
 800cd24:	2200      	movs	r2, #0
 800cd26:	601a      	str	r2, [r3, #0]

	/* Ensure the VFP is enabled - it should be anyway. */
	vPortEnableVFP();
 800cd28:	f000 f8fc 	bl	800cf24 <vPortEnableVFP>

	/* Lazy save always. */
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 800cd2c:	4b10      	ldr	r3, [pc, #64]	; (800cd70 <xPortStartScheduler+0x140>)
 800cd2e:	681b      	ldr	r3, [r3, #0]
 800cd30:	4a0f      	ldr	r2, [pc, #60]	; (800cd70 <xPortStartScheduler+0x140>)
 800cd32:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
 800cd36:	6013      	str	r3, [r2, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
 800cd38:	f7ff ff66 	bl	800cc08 <prvPortStartFirstTask>
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS.  Call
	vTaskSwitchContext() so link time optimisation does not remove the
	symbol. */
	vTaskSwitchContext();
 800cd3c:	f7fe feb6 	bl	800baac <vTaskSwitchContext>
	prvTaskExitError();
 800cd40:	f7ff ff20 	bl	800cb84 <prvTaskExitError>

	/* Should not get here! */
	return 0;
 800cd44:	2300      	movs	r3, #0
}
 800cd46:	4618      	mov	r0, r3
 800cd48:	3718      	adds	r7, #24
 800cd4a:	46bd      	mov	sp, r7
 800cd4c:	bd80      	pop	{r7, pc}
 800cd4e:	bf00      	nop
 800cd50:	e000ed00 	.word	0xe000ed00
 800cd54:	410fc271 	.word	0x410fc271
 800cd58:	410fc270 	.word	0x410fc270
 800cd5c:	e000e400 	.word	0xe000e400
 800cd60:	240003cc 	.word	0x240003cc
 800cd64:	240003d0 	.word	0x240003d0
 800cd68:	e000ed20 	.word	0xe000ed20
 800cd6c:	24000008 	.word	0x24000008
 800cd70:	e000ef34 	.word	0xe000ef34

0800cd74 <vPortEnterCritical>:
	configASSERT( uxCriticalNesting == 1000UL );
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
 800cd74:	b480      	push	{r7}
 800cd76:	b083      	sub	sp, #12
 800cd78:	af00      	add	r7, sp, #0
	__asm volatile
 800cd7a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800cd7e:	f383 8811 	msr	BASEPRI, r3
 800cd82:	f3bf 8f6f 	isb	sy
 800cd86:	f3bf 8f4f 	dsb	sy
 800cd8a:	607b      	str	r3, [r7, #4]
}
 800cd8c:	bf00      	nop
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
 800cd8e:	4b0f      	ldr	r3, [pc, #60]	; (800cdcc <vPortEnterCritical+0x58>)
 800cd90:	681b      	ldr	r3, [r3, #0]
 800cd92:	3301      	adds	r3, #1
 800cd94:	4a0d      	ldr	r2, [pc, #52]	; (800cdcc <vPortEnterCritical+0x58>)
 800cd96:	6013      	str	r3, [r2, #0]
	/* This is not the interrupt safe version of the enter critical function so
	assert() if it is being called from an interrupt context.  Only API
	functions that end in "FromISR" can be used in an interrupt.  Only assert if
	the critical nesting count is 1 to protect against recursive calls if the
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
 800cd98:	4b0c      	ldr	r3, [pc, #48]	; (800cdcc <vPortEnterCritical+0x58>)
 800cd9a:	681b      	ldr	r3, [r3, #0]
 800cd9c:	2b01      	cmp	r3, #1
 800cd9e:	d10f      	bne.n	800cdc0 <vPortEnterCritical+0x4c>
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 800cda0:	4b0b      	ldr	r3, [pc, #44]	; (800cdd0 <vPortEnterCritical+0x5c>)
 800cda2:	681b      	ldr	r3, [r3, #0]
 800cda4:	b2db      	uxtb	r3, r3
 800cda6:	2b00      	cmp	r3, #0
 800cda8:	d00a      	beq.n	800cdc0 <vPortEnterCritical+0x4c>
	__asm volatile
 800cdaa:	f04f 0350 	mov.w	r3, #80	; 0x50
 800cdae:	f383 8811 	msr	BASEPRI, r3
 800cdb2:	f3bf 8f6f 	isb	sy
 800cdb6:	f3bf 8f4f 	dsb	sy
 800cdba:	603b      	str	r3, [r7, #0]
}
 800cdbc:	bf00      	nop
 800cdbe:	e7fe      	b.n	800cdbe <vPortEnterCritical+0x4a>
	}
}
 800cdc0:	bf00      	nop
 800cdc2:	370c      	adds	r7, #12
 800cdc4:	46bd      	mov	sp, r7
 800cdc6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cdca:	4770      	bx	lr
 800cdcc:	24000008 	.word	0x24000008
 800cdd0:	e000ed04 	.word	0xe000ed04

0800cdd4 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
 800cdd4:	b480      	push	{r7}
 800cdd6:	b083      	sub	sp, #12
 800cdd8:	af00      	add	r7, sp, #0
	configASSERT( uxCriticalNesting );
 800cdda:	4b12      	ldr	r3, [pc, #72]	; (800ce24 <vPortExitCritical+0x50>)
 800cddc:	681b      	ldr	r3, [r3, #0]
 800cdde:	2b00      	cmp	r3, #0
 800cde0:	d10a      	bne.n	800cdf8 <vPortExitCritical+0x24>
	__asm volatile
 800cde2:	f04f 0350 	mov.w	r3, #80	; 0x50
 800cde6:	f383 8811 	msr	BASEPRI, r3
 800cdea:	f3bf 8f6f 	isb	sy
 800cdee:	f3bf 8f4f 	dsb	sy
 800cdf2:	607b      	str	r3, [r7, #4]
}
 800cdf4:	bf00      	nop
 800cdf6:	e7fe      	b.n	800cdf6 <vPortExitCritical+0x22>
	uxCriticalNesting--;
 800cdf8:	4b0a      	ldr	r3, [pc, #40]	; (800ce24 <vPortExitCritical+0x50>)
 800cdfa:	681b      	ldr	r3, [r3, #0]
 800cdfc:	3b01      	subs	r3, #1
 800cdfe:	4a09      	ldr	r2, [pc, #36]	; (800ce24 <vPortExitCritical+0x50>)
 800ce00:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 800ce02:	4b08      	ldr	r3, [pc, #32]	; (800ce24 <vPortExitCritical+0x50>)
 800ce04:	681b      	ldr	r3, [r3, #0]
 800ce06:	2b00      	cmp	r3, #0
 800ce08:	d105      	bne.n	800ce16 <vPortExitCritical+0x42>
 800ce0a:	2300      	movs	r3, #0
 800ce0c:	603b      	str	r3, [r7, #0]
	__asm volatile
 800ce0e:	683b      	ldr	r3, [r7, #0]
 800ce10:	f383 8811 	msr	BASEPRI, r3
}
 800ce14:	bf00      	nop
	{
		portENABLE_INTERRUPTS();
	}
}
 800ce16:	bf00      	nop
 800ce18:	370c      	adds	r7, #12
 800ce1a:	46bd      	mov	sp, r7
 800ce1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ce20:	4770      	bx	lr
 800ce22:	bf00      	nop
 800ce24:	24000008 	.word	0x24000008
	...

0800ce30 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 800ce30:	f3ef 8009 	mrs	r0, PSP
 800ce34:	f3bf 8f6f 	isb	sy
 800ce38:	4b15      	ldr	r3, [pc, #84]	; (800ce90 <pxCurrentTCBConst>)
 800ce3a:	681a      	ldr	r2, [r3, #0]
 800ce3c:	f01e 0f10 	tst.w	lr, #16
 800ce40:	bf08      	it	eq
 800ce42:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 800ce46:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ce4a:	6010      	str	r0, [r2, #0]
 800ce4c:	e92d 0009 	stmdb	sp!, {r0, r3}
 800ce50:	f04f 0050 	mov.w	r0, #80	; 0x50
 800ce54:	f380 8811 	msr	BASEPRI, r0
 800ce58:	f3bf 8f4f 	dsb	sy
 800ce5c:	f3bf 8f6f 	isb	sy
 800ce60:	f7fe fe24 	bl	800baac <vTaskSwitchContext>
 800ce64:	f04f 0000 	mov.w	r0, #0
 800ce68:	f380 8811 	msr	BASEPRI, r0
 800ce6c:	bc09      	pop	{r0, r3}
 800ce6e:	6819      	ldr	r1, [r3, #0]
 800ce70:	6808      	ldr	r0, [r1, #0]
 800ce72:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ce76:	f01e 0f10 	tst.w	lr, #16
 800ce7a:	bf08      	it	eq
 800ce7c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 800ce80:	f380 8809 	msr	PSP, r0
 800ce84:	f3bf 8f6f 	isb	sy
 800ce88:	4770      	bx	lr
 800ce8a:	bf00      	nop
 800ce8c:	f3af 8000 	nop.w

0800ce90 <pxCurrentTCBConst>:
 800ce90:	24000264 	.word	0x24000264
	"										\n"
	"	.align 4							\n"
	"pxCurrentTCBConst: .word pxCurrentTCB	\n"
	::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
	);
}
 800ce94:	bf00      	nop
 800ce96:	bf00      	nop

0800ce98 <SysTick_Handler>:
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 800ce98:	b580      	push	{r7, lr}
 800ce9a:	b082      	sub	sp, #8
 800ce9c:	af00      	add	r7, sp, #0
	__asm volatile
 800ce9e:	f04f 0350 	mov.w	r3, #80	; 0x50
 800cea2:	f383 8811 	msr	BASEPRI, r3
 800cea6:	f3bf 8f6f 	isb	sy
 800ceaa:	f3bf 8f4f 	dsb	sy
 800ceae:	607b      	str	r3, [r7, #4]
}
 800ceb0:	bf00      	nop
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 800ceb2:	f7fe fd43 	bl	800b93c <xTaskIncrementTick>
 800ceb6:	4603      	mov	r3, r0
 800ceb8:	2b00      	cmp	r3, #0
 800ceba:	d003      	beq.n	800cec4 <SysTick_Handler+0x2c>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 800cebc:	4b06      	ldr	r3, [pc, #24]	; (800ced8 <SysTick_Handler+0x40>)
 800cebe:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800cec2:	601a      	str	r2, [r3, #0]
 800cec4:	2300      	movs	r3, #0
 800cec6:	603b      	str	r3, [r7, #0]
	__asm volatile
 800cec8:	683b      	ldr	r3, [r7, #0]
 800ceca:	f383 8811 	msr	BASEPRI, r3
}
 800cece:	bf00      	nop
		}
	}
	portENABLE_INTERRUPTS();
}
 800ced0:	bf00      	nop
 800ced2:	3708      	adds	r7, #8
 800ced4:	46bd      	mov	sp, r7
 800ced6:	bd80      	pop	{r7, pc}
 800ced8:	e000ed04 	.word	0xe000ed04

0800cedc <vPortSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
{
 800cedc:	b480      	push	{r7}
 800cede:	af00      	add	r7, sp, #0
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Stop and clear the SysTick. */
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 800cee0:	4b0b      	ldr	r3, [pc, #44]	; (800cf10 <vPortSetupTimerInterrupt+0x34>)
 800cee2:	2200      	movs	r2, #0
 800cee4:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 800cee6:	4b0b      	ldr	r3, [pc, #44]	; (800cf14 <vPortSetupTimerInterrupt+0x38>)
 800cee8:	2200      	movs	r2, #0
 800ceea:	601a      	str	r2, [r3, #0]

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800ceec:	4b0a      	ldr	r3, [pc, #40]	; (800cf18 <vPortSetupTimerInterrupt+0x3c>)
 800ceee:	681b      	ldr	r3, [r3, #0]
 800cef0:	4a0a      	ldr	r2, [pc, #40]	; (800cf1c <vPortSetupTimerInterrupt+0x40>)
 800cef2:	fba2 2303 	umull	r2, r3, r2, r3
 800cef6:	099b      	lsrs	r3, r3, #6
 800cef8:	4a09      	ldr	r2, [pc, #36]	; (800cf20 <vPortSetupTimerInterrupt+0x44>)
 800cefa:	3b01      	subs	r3, #1
 800cefc:	6013      	str	r3, [r2, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 800cefe:	4b04      	ldr	r3, [pc, #16]	; (800cf10 <vPortSetupTimerInterrupt+0x34>)
 800cf00:	2207      	movs	r2, #7
 800cf02:	601a      	str	r2, [r3, #0]
}
 800cf04:	bf00      	nop
 800cf06:	46bd      	mov	sp, r7
 800cf08:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cf0c:	4770      	bx	lr
 800cf0e:	bf00      	nop
 800cf10:	e000e010 	.word	0xe000e010
 800cf14:	e000e018 	.word	0xe000e018
 800cf18:	240001a4 	.word	0x240001a4
 800cf1c:	10624dd3 	.word	0x10624dd3
 800cf20:	e000e014 	.word	0xe000e014

0800cf24 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 800cf24:	f8df 000c 	ldr.w	r0, [pc, #12]	; 800cf34 <vPortEnableVFP+0x10>
 800cf28:	6801      	ldr	r1, [r0, #0]
 800cf2a:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800cf2e:	6001      	str	r1, [r0, #0]
 800cf30:	4770      	bx	lr
		"								\n"
		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
		"	str r1, [r0]				\n"
		"	bx r14						"
	);
}
 800cf32:	bf00      	nop
 800cf34:	e000ed88 	.word	0xe000ed88

0800cf38 <vPortValidateInterruptPriority>:
/*-----------------------------------------------------------*/

#if( configASSERT_DEFINED == 1 )

	void vPortValidateInterruptPriority( void )
	{
 800cf38:	b480      	push	{r7}
 800cf3a:	b085      	sub	sp, #20
 800cf3c:	af00      	add	r7, sp, #0
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
 800cf3e:	f3ef 8305 	mrs	r3, IPSR
 800cf42:	60fb      	str	r3, [r7, #12]

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 800cf44:	68fb      	ldr	r3, [r7, #12]
 800cf46:	2b0f      	cmp	r3, #15
 800cf48:	d914      	bls.n	800cf74 <vPortValidateInterruptPriority+0x3c>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 800cf4a:	4a17      	ldr	r2, [pc, #92]	; (800cfa8 <vPortValidateInterruptPriority+0x70>)
 800cf4c:	68fb      	ldr	r3, [r7, #12]
 800cf4e:	4413      	add	r3, r2
 800cf50:	781b      	ldrb	r3, [r3, #0]
 800cf52:	72fb      	strb	r3, [r7, #11]
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 800cf54:	4b15      	ldr	r3, [pc, #84]	; (800cfac <vPortValidateInterruptPriority+0x74>)
 800cf56:	781b      	ldrb	r3, [r3, #0]
 800cf58:	7afa      	ldrb	r2, [r7, #11]
 800cf5a:	429a      	cmp	r2, r3
 800cf5c:	d20a      	bcs.n	800cf74 <vPortValidateInterruptPriority+0x3c>
	__asm volatile
 800cf5e:	f04f 0350 	mov.w	r3, #80	; 0x50
 800cf62:	f383 8811 	msr	BASEPRI, r3
 800cf66:	f3bf 8f6f 	isb	sy
 800cf6a:	f3bf 8f4f 	dsb	sy
 800cf6e:	607b      	str	r3, [r7, #4]
}
 800cf70:	bf00      	nop
 800cf72:	e7fe      	b.n	800cf72 <vPortValidateInterruptPriority+0x3a>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredictable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 800cf74:	4b0e      	ldr	r3, [pc, #56]	; (800cfb0 <vPortValidateInterruptPriority+0x78>)
 800cf76:	681b      	ldr	r3, [r3, #0]
 800cf78:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
 800cf7c:	4b0d      	ldr	r3, [pc, #52]	; (800cfb4 <vPortValidateInterruptPriority+0x7c>)
 800cf7e:	681b      	ldr	r3, [r3, #0]
 800cf80:	429a      	cmp	r2, r3
 800cf82:	d90a      	bls.n	800cf9a <vPortValidateInterruptPriority+0x62>
	__asm volatile
 800cf84:	f04f 0350 	mov.w	r3, #80	; 0x50
 800cf88:	f383 8811 	msr	BASEPRI, r3
 800cf8c:	f3bf 8f6f 	isb	sy
 800cf90:	f3bf 8f4f 	dsb	sy
 800cf94:	603b      	str	r3, [r7, #0]
}
 800cf96:	bf00      	nop
 800cf98:	e7fe      	b.n	800cf98 <vPortValidateInterruptPriority+0x60>
	}
 800cf9a:	bf00      	nop
 800cf9c:	3714      	adds	r7, #20
 800cf9e:	46bd      	mov	sp, r7
 800cfa0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cfa4:	4770      	bx	lr
 800cfa6:	bf00      	nop
 800cfa8:	e000e3f0 	.word	0xe000e3f0
 800cfac:	240003cc 	.word	0x240003cc
 800cfb0:	e000ed0c 	.word	0xe000ed0c
 800cfb4:	240003d0 	.word	0x240003d0

0800cfb8 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 800cfb8:	b580      	push	{r7, lr}
 800cfba:	b08a      	sub	sp, #40	; 0x28
 800cfbc:	af00      	add	r7, sp, #0
 800cfbe:	6078      	str	r0, [r7, #4]
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
 800cfc0:	2300      	movs	r3, #0
 800cfc2:	61fb      	str	r3, [r7, #28]

	vTaskSuspendAll();
 800cfc4:	f7fe fc00 	bl	800b7c8 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
 800cfc8:	4b5b      	ldr	r3, [pc, #364]	; (800d138 <pvPortMalloc+0x180>)
 800cfca:	681b      	ldr	r3, [r3, #0]
 800cfcc:	2b00      	cmp	r3, #0
 800cfce:	d101      	bne.n	800cfd4 <pvPortMalloc+0x1c>
		{
			prvHeapInit();
 800cfd0:	f000 f920 	bl	800d214 <prvHeapInit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 800cfd4:	4b59      	ldr	r3, [pc, #356]	; (800d13c <pvPortMalloc+0x184>)
 800cfd6:	681a      	ldr	r2, [r3, #0]
 800cfd8:	687b      	ldr	r3, [r7, #4]
 800cfda:	4013      	ands	r3, r2
 800cfdc:	2b00      	cmp	r3, #0
 800cfde:	f040 8093 	bne.w	800d108 <pvPortMalloc+0x150>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
 800cfe2:	687b      	ldr	r3, [r7, #4]
 800cfe4:	2b00      	cmp	r3, #0
 800cfe6:	d01d      	beq.n	800d024 <pvPortMalloc+0x6c>
			{
				xWantedSize += xHeapStructSize;
 800cfe8:	2208      	movs	r2, #8
 800cfea:	687b      	ldr	r3, [r7, #4]
 800cfec:	4413      	add	r3, r2
 800cfee:	607b      	str	r3, [r7, #4]

				/* Ensure that blocks are always aligned to the required number
				of bytes. */
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 800cff0:	687b      	ldr	r3, [r7, #4]
 800cff2:	f003 0307 	and.w	r3, r3, #7
 800cff6:	2b00      	cmp	r3, #0
 800cff8:	d014      	beq.n	800d024 <pvPortMalloc+0x6c>
				{
					/* Byte alignment required. */
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 800cffa:	687b      	ldr	r3, [r7, #4]
 800cffc:	f023 0307 	bic.w	r3, r3, #7
 800d000:	3308      	adds	r3, #8
 800d002:	607b      	str	r3, [r7, #4]
					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
 800d004:	687b      	ldr	r3, [r7, #4]
 800d006:	f003 0307 	and.w	r3, r3, #7
 800d00a:	2b00      	cmp	r3, #0
 800d00c:	d00a      	beq.n	800d024 <pvPortMalloc+0x6c>
	__asm volatile
 800d00e:	f04f 0350 	mov.w	r3, #80	; 0x50
 800d012:	f383 8811 	msr	BASEPRI, r3
 800d016:	f3bf 8f6f 	isb	sy
 800d01a:	f3bf 8f4f 	dsb	sy
 800d01e:	617b      	str	r3, [r7, #20]
}
 800d020:	bf00      	nop
 800d022:	e7fe      	b.n	800d022 <pvPortMalloc+0x6a>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 800d024:	687b      	ldr	r3, [r7, #4]
 800d026:	2b00      	cmp	r3, #0
 800d028:	d06e      	beq.n	800d108 <pvPortMalloc+0x150>
 800d02a:	4b45      	ldr	r3, [pc, #276]	; (800d140 <pvPortMalloc+0x188>)
 800d02c:	681b      	ldr	r3, [r3, #0]
 800d02e:	687a      	ldr	r2, [r7, #4]
 800d030:	429a      	cmp	r2, r3
 800d032:	d869      	bhi.n	800d108 <pvPortMalloc+0x150>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
 800d034:	4b43      	ldr	r3, [pc, #268]	; (800d144 <pvPortMalloc+0x18c>)
 800d036:	623b      	str	r3, [r7, #32]
				pxBlock = xStart.pxNextFreeBlock;
 800d038:	4b42      	ldr	r3, [pc, #264]	; (800d144 <pvPortMalloc+0x18c>)
 800d03a:	681b      	ldr	r3, [r3, #0]
 800d03c:	627b      	str	r3, [r7, #36]	; 0x24
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 800d03e:	e004      	b.n	800d04a <pvPortMalloc+0x92>
				{
					pxPreviousBlock = pxBlock;
 800d040:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d042:	623b      	str	r3, [r7, #32]
					pxBlock = pxBlock->pxNextFreeBlock;
 800d044:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d046:	681b      	ldr	r3, [r3, #0]
 800d048:	627b      	str	r3, [r7, #36]	; 0x24
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 800d04a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d04c:	685b      	ldr	r3, [r3, #4]
 800d04e:	687a      	ldr	r2, [r7, #4]
 800d050:	429a      	cmp	r2, r3
 800d052:	d903      	bls.n	800d05c <pvPortMalloc+0xa4>
 800d054:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d056:	681b      	ldr	r3, [r3, #0]
 800d058:	2b00      	cmp	r3, #0
 800d05a:	d1f1      	bne.n	800d040 <pvPortMalloc+0x88>
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
 800d05c:	4b36      	ldr	r3, [pc, #216]	; (800d138 <pvPortMalloc+0x180>)
 800d05e:	681b      	ldr	r3, [r3, #0]
 800d060:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800d062:	429a      	cmp	r2, r3
 800d064:	d050      	beq.n	800d108 <pvPortMalloc+0x150>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 800d066:	6a3b      	ldr	r3, [r7, #32]
 800d068:	681b      	ldr	r3, [r3, #0]
 800d06a:	2208      	movs	r2, #8
 800d06c:	4413      	add	r3, r2
 800d06e:	61fb      	str	r3, [r7, #28]

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 800d070:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d072:	681a      	ldr	r2, [r3, #0]
 800d074:	6a3b      	ldr	r3, [r7, #32]
 800d076:	601a      	str	r2, [r3, #0]

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 800d078:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d07a:	685a      	ldr	r2, [r3, #4]
 800d07c:	687b      	ldr	r3, [r7, #4]
 800d07e:	1ad2      	subs	r2, r2, r3
 800d080:	2308      	movs	r3, #8
 800d082:	005b      	lsls	r3, r3, #1
 800d084:	429a      	cmp	r2, r3
 800d086:	d91f      	bls.n	800d0c8 <pvPortMalloc+0x110>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 800d088:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800d08a:	687b      	ldr	r3, [r7, #4]
 800d08c:	4413      	add	r3, r2
 800d08e:	61bb      	str	r3, [r7, #24]
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 800d090:	69bb      	ldr	r3, [r7, #24]
 800d092:	f003 0307 	and.w	r3, r3, #7
 800d096:	2b00      	cmp	r3, #0
 800d098:	d00a      	beq.n	800d0b0 <pvPortMalloc+0xf8>
	__asm volatile
 800d09a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800d09e:	f383 8811 	msr	BASEPRI, r3
 800d0a2:	f3bf 8f6f 	isb	sy
 800d0a6:	f3bf 8f4f 	dsb	sy
 800d0aa:	613b      	str	r3, [r7, #16]
}
 800d0ac:	bf00      	nop
 800d0ae:	e7fe      	b.n	800d0ae <pvPortMalloc+0xf6>

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 800d0b0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d0b2:	685a      	ldr	r2, [r3, #4]
 800d0b4:	687b      	ldr	r3, [r7, #4]
 800d0b6:	1ad2      	subs	r2, r2, r3
 800d0b8:	69bb      	ldr	r3, [r7, #24]
 800d0ba:	605a      	str	r2, [r3, #4]
						pxBlock->xBlockSize = xWantedSize;
 800d0bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d0be:	687a      	ldr	r2, [r7, #4]
 800d0c0:	605a      	str	r2, [r3, #4]

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 800d0c2:	69b8      	ldr	r0, [r7, #24]
 800d0c4:	f000 f90a 	bl	800d2dc <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
 800d0c8:	4b1d      	ldr	r3, [pc, #116]	; (800d140 <pvPortMalloc+0x188>)
 800d0ca:	681a      	ldr	r2, [r3, #0]
 800d0cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d0ce:	685b      	ldr	r3, [r3, #4]
 800d0d0:	1ad3      	subs	r3, r2, r3
 800d0d2:	4a1b      	ldr	r2, [pc, #108]	; (800d140 <pvPortMalloc+0x188>)
 800d0d4:	6013      	str	r3, [r2, #0]

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 800d0d6:	4b1a      	ldr	r3, [pc, #104]	; (800d140 <pvPortMalloc+0x188>)
 800d0d8:	681a      	ldr	r2, [r3, #0]
 800d0da:	4b1b      	ldr	r3, [pc, #108]	; (800d148 <pvPortMalloc+0x190>)
 800d0dc:	681b      	ldr	r3, [r3, #0]
 800d0de:	429a      	cmp	r2, r3
 800d0e0:	d203      	bcs.n	800d0ea <pvPortMalloc+0x132>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 800d0e2:	4b17      	ldr	r3, [pc, #92]	; (800d140 <pvPortMalloc+0x188>)
 800d0e4:	681b      	ldr	r3, [r3, #0]
 800d0e6:	4a18      	ldr	r2, [pc, #96]	; (800d148 <pvPortMalloc+0x190>)
 800d0e8:	6013      	str	r3, [r2, #0]
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 800d0ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d0ec:	685a      	ldr	r2, [r3, #4]
 800d0ee:	4b13      	ldr	r3, [pc, #76]	; (800d13c <pvPortMalloc+0x184>)
 800d0f0:	681b      	ldr	r3, [r3, #0]
 800d0f2:	431a      	orrs	r2, r3
 800d0f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d0f6:	605a      	str	r2, [r3, #4]
					pxBlock->pxNextFreeBlock = NULL;
 800d0f8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d0fa:	2200      	movs	r2, #0
 800d0fc:	601a      	str	r2, [r3, #0]
					xNumberOfSuccessfulAllocations++;
 800d0fe:	4b13      	ldr	r3, [pc, #76]	; (800d14c <pvPortMalloc+0x194>)
 800d100:	681b      	ldr	r3, [r3, #0]
 800d102:	3301      	adds	r3, #1
 800d104:	4a11      	ldr	r2, [pc, #68]	; (800d14c <pvPortMalloc+0x194>)
 800d106:	6013      	str	r3, [r2, #0]
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 800d108:	f7fe fb6c 	bl	800b7e4 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 800d10c:	69fb      	ldr	r3, [r7, #28]
 800d10e:	f003 0307 	and.w	r3, r3, #7
 800d112:	2b00      	cmp	r3, #0
 800d114:	d00a      	beq.n	800d12c <pvPortMalloc+0x174>
	__asm volatile
 800d116:	f04f 0350 	mov.w	r3, #80	; 0x50
 800d11a:	f383 8811 	msr	BASEPRI, r3
 800d11e:	f3bf 8f6f 	isb	sy
 800d122:	f3bf 8f4f 	dsb	sy
 800d126:	60fb      	str	r3, [r7, #12]
}
 800d128:	bf00      	nop
 800d12a:	e7fe      	b.n	800d12a <pvPortMalloc+0x172>
	return pvReturn;
 800d12c:	69fb      	ldr	r3, [r7, #28]
}
 800d12e:	4618      	mov	r0, r3
 800d130:	3728      	adds	r7, #40	; 0x28
 800d132:	46bd      	mov	sp, r7
 800d134:	bd80      	pop	{r7, pc}
 800d136:	bf00      	nop
 800d138:	24061e5c 	.word	0x24061e5c
 800d13c:	24061e70 	.word	0x24061e70
 800d140:	24061e60 	.word	0x24061e60
 800d144:	24061e54 	.word	0x24061e54
 800d148:	24061e64 	.word	0x24061e64
 800d14c:	24061e68 	.word	0x24061e68

0800d150 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 800d150:	b580      	push	{r7, lr}
 800d152:	b086      	sub	sp, #24
 800d154:	af00      	add	r7, sp, #0
 800d156:	6078      	str	r0, [r7, #4]
uint8_t *puc = ( uint8_t * ) pv;
 800d158:	687b      	ldr	r3, [r7, #4]
 800d15a:	617b      	str	r3, [r7, #20]
BlockLink_t *pxLink;

	if( pv != NULL )
 800d15c:	687b      	ldr	r3, [r7, #4]
 800d15e:	2b00      	cmp	r3, #0
 800d160:	d04d      	beq.n	800d1fe <vPortFree+0xae>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
 800d162:	2308      	movs	r3, #8
 800d164:	425b      	negs	r3, r3
 800d166:	697a      	ldr	r2, [r7, #20]
 800d168:	4413      	add	r3, r2
 800d16a:	617b      	str	r3, [r7, #20]

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
 800d16c:	697b      	ldr	r3, [r7, #20]
 800d16e:	613b      	str	r3, [r7, #16]

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 800d170:	693b      	ldr	r3, [r7, #16]
 800d172:	685a      	ldr	r2, [r3, #4]
 800d174:	4b24      	ldr	r3, [pc, #144]	; (800d208 <vPortFree+0xb8>)
 800d176:	681b      	ldr	r3, [r3, #0]
 800d178:	4013      	ands	r3, r2
 800d17a:	2b00      	cmp	r3, #0
 800d17c:	d10a      	bne.n	800d194 <vPortFree+0x44>
	__asm volatile
 800d17e:	f04f 0350 	mov.w	r3, #80	; 0x50
 800d182:	f383 8811 	msr	BASEPRI, r3
 800d186:	f3bf 8f6f 	isb	sy
 800d18a:	f3bf 8f4f 	dsb	sy
 800d18e:	60fb      	str	r3, [r7, #12]
}
 800d190:	bf00      	nop
 800d192:	e7fe      	b.n	800d192 <vPortFree+0x42>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 800d194:	693b      	ldr	r3, [r7, #16]
 800d196:	681b      	ldr	r3, [r3, #0]
 800d198:	2b00      	cmp	r3, #0
 800d19a:	d00a      	beq.n	800d1b2 <vPortFree+0x62>
	__asm volatile
 800d19c:	f04f 0350 	mov.w	r3, #80	; 0x50
 800d1a0:	f383 8811 	msr	BASEPRI, r3
 800d1a4:	f3bf 8f6f 	isb	sy
 800d1a8:	f3bf 8f4f 	dsb	sy
 800d1ac:	60bb      	str	r3, [r7, #8]
}
 800d1ae:	bf00      	nop
 800d1b0:	e7fe      	b.n	800d1b0 <vPortFree+0x60>

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
 800d1b2:	693b      	ldr	r3, [r7, #16]
 800d1b4:	685a      	ldr	r2, [r3, #4]
 800d1b6:	4b14      	ldr	r3, [pc, #80]	; (800d208 <vPortFree+0xb8>)
 800d1b8:	681b      	ldr	r3, [r3, #0]
 800d1ba:	4013      	ands	r3, r2
 800d1bc:	2b00      	cmp	r3, #0
 800d1be:	d01e      	beq.n	800d1fe <vPortFree+0xae>
		{
			if( pxLink->pxNextFreeBlock == NULL )
 800d1c0:	693b      	ldr	r3, [r7, #16]
 800d1c2:	681b      	ldr	r3, [r3, #0]
 800d1c4:	2b00      	cmp	r3, #0
 800d1c6:	d11a      	bne.n	800d1fe <vPortFree+0xae>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 800d1c8:	693b      	ldr	r3, [r7, #16]
 800d1ca:	685a      	ldr	r2, [r3, #4]
 800d1cc:	4b0e      	ldr	r3, [pc, #56]	; (800d208 <vPortFree+0xb8>)
 800d1ce:	681b      	ldr	r3, [r3, #0]
 800d1d0:	43db      	mvns	r3, r3
 800d1d2:	401a      	ands	r2, r3
 800d1d4:	693b      	ldr	r3, [r7, #16]
 800d1d6:	605a      	str	r2, [r3, #4]

				vTaskSuspendAll();
 800d1d8:	f7fe faf6 	bl	800b7c8 <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
 800d1dc:	693b      	ldr	r3, [r7, #16]
 800d1de:	685a      	ldr	r2, [r3, #4]
 800d1e0:	4b0a      	ldr	r3, [pc, #40]	; (800d20c <vPortFree+0xbc>)
 800d1e2:	681b      	ldr	r3, [r3, #0]
 800d1e4:	4413      	add	r3, r2
 800d1e6:	4a09      	ldr	r2, [pc, #36]	; (800d20c <vPortFree+0xbc>)
 800d1e8:	6013      	str	r3, [r2, #0]
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 800d1ea:	6938      	ldr	r0, [r7, #16]
 800d1ec:	f000 f876 	bl	800d2dc <prvInsertBlockIntoFreeList>
					xNumberOfSuccessfulFrees++;
 800d1f0:	4b07      	ldr	r3, [pc, #28]	; (800d210 <vPortFree+0xc0>)
 800d1f2:	681b      	ldr	r3, [r3, #0]
 800d1f4:	3301      	adds	r3, #1
 800d1f6:	4a06      	ldr	r2, [pc, #24]	; (800d210 <vPortFree+0xc0>)
 800d1f8:	6013      	str	r3, [r2, #0]
				}
				( void ) xTaskResumeAll();
 800d1fa:	f7fe faf3 	bl	800b7e4 <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
 800d1fe:	bf00      	nop
 800d200:	3718      	adds	r7, #24
 800d202:	46bd      	mov	sp, r7
 800d204:	bd80      	pop	{r7, pc}
 800d206:	bf00      	nop
 800d208:	24061e70 	.word	0x24061e70
 800d20c:	24061e60 	.word	0x24061e60
 800d210:	24061e6c 	.word	0x24061e6c

0800d214 <prvHeapInit>:
	/* This just exists to keep the linker quiet. */
}
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
 800d214:	b480      	push	{r7}
 800d216:	b085      	sub	sp, #20
 800d218:	af00      	add	r7, sp, #0
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;
size_t uxAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 800d21a:	4b29      	ldr	r3, [pc, #164]	; (800d2c0 <prvHeapInit+0xac>)
 800d21c:	60bb      	str	r3, [r7, #8]

	/* Ensure the heap starts on a correctly aligned boundary. */
	uxAddress = ( size_t ) ucHeap;
 800d21e:	4b29      	ldr	r3, [pc, #164]	; (800d2c4 <prvHeapInit+0xb0>)
 800d220:	60fb      	str	r3, [r7, #12]

	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 800d222:	68fb      	ldr	r3, [r7, #12]
 800d224:	f003 0307 	and.w	r3, r3, #7
 800d228:	2b00      	cmp	r3, #0
 800d22a:	d00c      	beq.n	800d246 <prvHeapInit+0x32>
	{
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 800d22c:	68fb      	ldr	r3, [r7, #12]
 800d22e:	3307      	adds	r3, #7
 800d230:	60fb      	str	r3, [r7, #12]
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800d232:	68fb      	ldr	r3, [r7, #12]
 800d234:	f023 0307 	bic.w	r3, r3, #7
 800d238:	60fb      	str	r3, [r7, #12]
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 800d23a:	68ba      	ldr	r2, [r7, #8]
 800d23c:	68fb      	ldr	r3, [r7, #12]
 800d23e:	1ad3      	subs	r3, r2, r3
 800d240:	4a20      	ldr	r2, [pc, #128]	; (800d2c4 <prvHeapInit+0xb0>)
 800d242:	4413      	add	r3, r2
 800d244:	60bb      	str	r3, [r7, #8]
	}

	pucAlignedHeap = ( uint8_t * ) uxAddress;
 800d246:	68fb      	ldr	r3, [r7, #12]
 800d248:	607b      	str	r3, [r7, #4]

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 800d24a:	4a1f      	ldr	r2, [pc, #124]	; (800d2c8 <prvHeapInit+0xb4>)
 800d24c:	687b      	ldr	r3, [r7, #4]
 800d24e:	6013      	str	r3, [r2, #0]
	xStart.xBlockSize = ( size_t ) 0;
 800d250:	4b1d      	ldr	r3, [pc, #116]	; (800d2c8 <prvHeapInit+0xb4>)
 800d252:	2200      	movs	r2, #0
 800d254:	605a      	str	r2, [r3, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 800d256:	687b      	ldr	r3, [r7, #4]
 800d258:	68ba      	ldr	r2, [r7, #8]
 800d25a:	4413      	add	r3, r2
 800d25c:	60fb      	str	r3, [r7, #12]
	uxAddress -= xHeapStructSize;
 800d25e:	2208      	movs	r2, #8
 800d260:	68fb      	ldr	r3, [r7, #12]
 800d262:	1a9b      	subs	r3, r3, r2
 800d264:	60fb      	str	r3, [r7, #12]
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800d266:	68fb      	ldr	r3, [r7, #12]
 800d268:	f023 0307 	bic.w	r3, r3, #7
 800d26c:	60fb      	str	r3, [r7, #12]
	pxEnd = ( void * ) uxAddress;
 800d26e:	68fb      	ldr	r3, [r7, #12]
 800d270:	4a16      	ldr	r2, [pc, #88]	; (800d2cc <prvHeapInit+0xb8>)
 800d272:	6013      	str	r3, [r2, #0]
	pxEnd->xBlockSize = 0;
 800d274:	4b15      	ldr	r3, [pc, #84]	; (800d2cc <prvHeapInit+0xb8>)
 800d276:	681b      	ldr	r3, [r3, #0]
 800d278:	2200      	movs	r2, #0
 800d27a:	605a      	str	r2, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
 800d27c:	4b13      	ldr	r3, [pc, #76]	; (800d2cc <prvHeapInit+0xb8>)
 800d27e:	681b      	ldr	r3, [r3, #0]
 800d280:	2200      	movs	r2, #0
 800d282:	601a      	str	r2, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
 800d284:	687b      	ldr	r3, [r7, #4]
 800d286:	603b      	str	r3, [r7, #0]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 800d288:	683b      	ldr	r3, [r7, #0]
 800d28a:	68fa      	ldr	r2, [r7, #12]
 800d28c:	1ad2      	subs	r2, r2, r3
 800d28e:	683b      	ldr	r3, [r7, #0]
 800d290:	605a      	str	r2, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 800d292:	4b0e      	ldr	r3, [pc, #56]	; (800d2cc <prvHeapInit+0xb8>)
 800d294:	681a      	ldr	r2, [r3, #0]
 800d296:	683b      	ldr	r3, [r7, #0]
 800d298:	601a      	str	r2, [r3, #0]

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800d29a:	683b      	ldr	r3, [r7, #0]
 800d29c:	685b      	ldr	r3, [r3, #4]
 800d29e:	4a0c      	ldr	r2, [pc, #48]	; (800d2d0 <prvHeapInit+0xbc>)
 800d2a0:	6013      	str	r3, [r2, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800d2a2:	683b      	ldr	r3, [r7, #0]
 800d2a4:	685b      	ldr	r3, [r3, #4]
 800d2a6:	4a0b      	ldr	r2, [pc, #44]	; (800d2d4 <prvHeapInit+0xc0>)
 800d2a8:	6013      	str	r3, [r2, #0]

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 800d2aa:	4b0b      	ldr	r3, [pc, #44]	; (800d2d8 <prvHeapInit+0xc4>)
 800d2ac:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 800d2b0:	601a      	str	r2, [r3, #0]
}
 800d2b2:	bf00      	nop
 800d2b4:	3714      	adds	r7, #20
 800d2b6:	46bd      	mov	sp, r7
 800d2b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d2bc:	4770      	bx	lr
 800d2be:	bf00      	nop
 800d2c0:	00061a80 	.word	0x00061a80
 800d2c4:	240003d4 	.word	0x240003d4
 800d2c8:	24061e54 	.word	0x24061e54
 800d2cc:	24061e5c 	.word	0x24061e5c
 800d2d0:	24061e64 	.word	0x24061e64
 800d2d4:	24061e60 	.word	0x24061e60
 800d2d8:	24061e70 	.word	0x24061e70

0800d2dc <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 800d2dc:	b480      	push	{r7}
 800d2de:	b085      	sub	sp, #20
 800d2e0:	af00      	add	r7, sp, #0
 800d2e2:	6078      	str	r0, [r7, #4]
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 800d2e4:	4b28      	ldr	r3, [pc, #160]	; (800d388 <prvInsertBlockIntoFreeList+0xac>)
 800d2e6:	60fb      	str	r3, [r7, #12]
 800d2e8:	e002      	b.n	800d2f0 <prvInsertBlockIntoFreeList+0x14>
 800d2ea:	68fb      	ldr	r3, [r7, #12]
 800d2ec:	681b      	ldr	r3, [r3, #0]
 800d2ee:	60fb      	str	r3, [r7, #12]
 800d2f0:	68fb      	ldr	r3, [r7, #12]
 800d2f2:	681b      	ldr	r3, [r3, #0]
 800d2f4:	687a      	ldr	r2, [r7, #4]
 800d2f6:	429a      	cmp	r2, r3
 800d2f8:	d8f7      	bhi.n	800d2ea <prvInsertBlockIntoFreeList+0xe>
		/* Nothing to do here, just iterate to the right position. */
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
 800d2fa:	68fb      	ldr	r3, [r7, #12]
 800d2fc:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 800d2fe:	68fb      	ldr	r3, [r7, #12]
 800d300:	685b      	ldr	r3, [r3, #4]
 800d302:	68ba      	ldr	r2, [r7, #8]
 800d304:	4413      	add	r3, r2
 800d306:	687a      	ldr	r2, [r7, #4]
 800d308:	429a      	cmp	r2, r3
 800d30a:	d108      	bne.n	800d31e <prvInsertBlockIntoFreeList+0x42>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 800d30c:	68fb      	ldr	r3, [r7, #12]
 800d30e:	685a      	ldr	r2, [r3, #4]
 800d310:	687b      	ldr	r3, [r7, #4]
 800d312:	685b      	ldr	r3, [r3, #4]
 800d314:	441a      	add	r2, r3
 800d316:	68fb      	ldr	r3, [r7, #12]
 800d318:	605a      	str	r2, [r3, #4]
		pxBlockToInsert = pxIterator;
 800d31a:	68fb      	ldr	r3, [r7, #12]
 800d31c:	607b      	str	r3, [r7, #4]
		mtCOVERAGE_TEST_MARKER();
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
 800d31e:	687b      	ldr	r3, [r7, #4]
 800d320:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 800d322:	687b      	ldr	r3, [r7, #4]
 800d324:	685b      	ldr	r3, [r3, #4]
 800d326:	68ba      	ldr	r2, [r7, #8]
 800d328:	441a      	add	r2, r3
 800d32a:	68fb      	ldr	r3, [r7, #12]
 800d32c:	681b      	ldr	r3, [r3, #0]
 800d32e:	429a      	cmp	r2, r3
 800d330:	d118      	bne.n	800d364 <prvInsertBlockIntoFreeList+0x88>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 800d332:	68fb      	ldr	r3, [r7, #12]
 800d334:	681a      	ldr	r2, [r3, #0]
 800d336:	4b15      	ldr	r3, [pc, #84]	; (800d38c <prvInsertBlockIntoFreeList+0xb0>)
 800d338:	681b      	ldr	r3, [r3, #0]
 800d33a:	429a      	cmp	r2, r3
 800d33c:	d00d      	beq.n	800d35a <prvInsertBlockIntoFreeList+0x7e>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 800d33e:	687b      	ldr	r3, [r7, #4]
 800d340:	685a      	ldr	r2, [r3, #4]
 800d342:	68fb      	ldr	r3, [r7, #12]
 800d344:	681b      	ldr	r3, [r3, #0]
 800d346:	685b      	ldr	r3, [r3, #4]
 800d348:	441a      	add	r2, r3
 800d34a:	687b      	ldr	r3, [r7, #4]
 800d34c:	605a      	str	r2, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 800d34e:	68fb      	ldr	r3, [r7, #12]
 800d350:	681b      	ldr	r3, [r3, #0]
 800d352:	681a      	ldr	r2, [r3, #0]
 800d354:	687b      	ldr	r3, [r7, #4]
 800d356:	601a      	str	r2, [r3, #0]
 800d358:	e008      	b.n	800d36c <prvInsertBlockIntoFreeList+0x90>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
 800d35a:	4b0c      	ldr	r3, [pc, #48]	; (800d38c <prvInsertBlockIntoFreeList+0xb0>)
 800d35c:	681a      	ldr	r2, [r3, #0]
 800d35e:	687b      	ldr	r3, [r7, #4]
 800d360:	601a      	str	r2, [r3, #0]
 800d362:	e003      	b.n	800d36c <prvInsertBlockIntoFreeList+0x90>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 800d364:	68fb      	ldr	r3, [r7, #12]
 800d366:	681a      	ldr	r2, [r3, #0]
 800d368:	687b      	ldr	r3, [r7, #4]
 800d36a:	601a      	str	r2, [r3, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 800d36c:	68fa      	ldr	r2, [r7, #12]
 800d36e:	687b      	ldr	r3, [r7, #4]
 800d370:	429a      	cmp	r2, r3
 800d372:	d002      	beq.n	800d37a <prvInsertBlockIntoFreeList+0x9e>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 800d374:	68fb      	ldr	r3, [r7, #12]
 800d376:	687a      	ldr	r2, [r7, #4]
 800d378:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 800d37a:	bf00      	nop
 800d37c:	3714      	adds	r7, #20
 800d37e:	46bd      	mov	sp, r7
 800d380:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d384:	4770      	bx	lr
 800d386:	bf00      	nop
 800d388:	24061e54 	.word	0x24061e54
 800d38c:	24061e5c 	.word	0x24061e5c

0800d390 <SSD_init_hack>:
	SSD_writeRegion(&area, kaboom);

	osDelay(2000);
}

void SSD_init_hack(){
 800d390:	b580      	push	{r7, lr}
 800d392:	af00      	add	r7, sp, #0
	txCpltSemHack = xSemaphoreCreateBinary();
 800d394:	2203      	movs	r2, #3
 800d396:	2100      	movs	r1, #0
 800d398:	2001      	movs	r0, #1
 800d39a:	f7fd fa1b 	bl	800a7d4 <xQueueGenericCreate>
 800d39e:	4603      	mov	r3, r0
 800d3a0:	4a05      	ldr	r2, [pc, #20]	; (800d3b8 <SSD_init_hack+0x28>)
 800d3a2:	6013      	str	r3, [r2, #0]
	xSemaphoreGive(txCpltSemHack);
 800d3a4:	4b04      	ldr	r3, [pc, #16]	; (800d3b8 <SSD_init_hack+0x28>)
 800d3a6:	6818      	ldr	r0, [r3, #0]
 800d3a8:	2300      	movs	r3, #0
 800d3aa:	2200      	movs	r2, #0
 800d3ac:	2100      	movs	r1, #0
 800d3ae:	f7fd fa99 	bl	800a8e4 <xQueueGenericSend>
//	area.y1 = 0;
//	area.y2 = 63;
//	SSD_writeRegion_hack(&area, kaboom);

//	osDelay(2000);
}
 800d3b2:	bf00      	nop
 800d3b4:	bd80      	pop	{r7, pc}
 800d3b6:	bf00      	nop
 800d3b8:	24062480 	.word	0x24062480

0800d3bc <SSD_writeRegion_hack>:
//	}
	spiSendBuf(buf, len);
	setCS(1);
}

void SSD_writeRegion_hack(lv_area_t * area, uint8_t* buf){
 800d3bc:	b580      	push	{r7, lr}
 800d3be:	b088      	sub	sp, #32
 800d3c0:	af00      	add	r7, sp, #0
 800d3c2:	6078      	str	r0, [r7, #4]
 800d3c4:	6039      	str	r1, [r7, #0]
	static uint8_t* dmabuf = NULL;
	vPortFree(dmabuf);
 800d3c6:	4b35      	ldr	r3, [pc, #212]	; (800d49c <SSD_writeRegion_hack+0xe0>)
 800d3c8:	681b      	ldr	r3, [r3, #0]
 800d3ca:	4618      	mov	r0, r3
 800d3cc:	f7ff fec0 	bl	800d150 <vPortFree>
	size_t dx = area->x2-area->x1+1;
 800d3d0:	687b      	ldr	r3, [r7, #4]
 800d3d2:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 800d3d6:	461a      	mov	r2, r3
 800d3d8:	687b      	ldr	r3, [r7, #4]
 800d3da:	f9b3 3000 	ldrsh.w	r3, [r3]
 800d3de:	1ad3      	subs	r3, r2, r3
 800d3e0:	3301      	adds	r3, #1
 800d3e2:	61fb      	str	r3, [r7, #28]
	size_t dy = area->y2-area->y1+1;
 800d3e4:	687b      	ldr	r3, [r7, #4]
 800d3e6:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800d3ea:	461a      	mov	r2, r3
 800d3ec:	687b      	ldr	r3, [r7, #4]
 800d3ee:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800d3f2:	1ad3      	subs	r3, r2, r3
 800d3f4:	3301      	adds	r3, #1
 800d3f6:	61bb      	str	r3, [r7, #24]
	size_t len = dx*dy/2;
 800d3f8:	69fb      	ldr	r3, [r7, #28]
 800d3fa:	69ba      	ldr	r2, [r7, #24]
 800d3fc:	fb02 f303 	mul.w	r3, r2, r3
 800d400:	085b      	lsrs	r3, r3, #1
 800d402:	617b      	str	r3, [r7, #20]
	uint8_t buf2[5] = {0xa5, 0+area->y1, 0+area->y2, 28+area->x1/4, 28+(area->x2)/4};
 800d404:	23a5      	movs	r3, #165	; 0xa5
 800d406:	733b      	strb	r3, [r7, #12]
 800d408:	687b      	ldr	r3, [r7, #4]
 800d40a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800d40e:	b2db      	uxtb	r3, r3
 800d410:	737b      	strb	r3, [r7, #13]
 800d412:	687b      	ldr	r3, [r7, #4]
 800d414:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800d418:	b2db      	uxtb	r3, r3
 800d41a:	73bb      	strb	r3, [r7, #14]
 800d41c:	687b      	ldr	r3, [r7, #4]
 800d41e:	f9b3 3000 	ldrsh.w	r3, [r3]
 800d422:	2b00      	cmp	r3, #0
 800d424:	da00      	bge.n	800d428 <SSD_writeRegion_hack+0x6c>
 800d426:	3303      	adds	r3, #3
 800d428:	109b      	asrs	r3, r3, #2
 800d42a:	b21b      	sxth	r3, r3
 800d42c:	b2db      	uxtb	r3, r3
 800d42e:	331c      	adds	r3, #28
 800d430:	b2db      	uxtb	r3, r3
 800d432:	73fb      	strb	r3, [r7, #15]
 800d434:	687b      	ldr	r3, [r7, #4]
 800d436:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 800d43a:	2b00      	cmp	r3, #0
 800d43c:	da00      	bge.n	800d440 <SSD_writeRegion_hack+0x84>
 800d43e:	3303      	adds	r3, #3
 800d440:	109b      	asrs	r3, r3, #2
 800d442:	b21b      	sxth	r3, r3
 800d444:	b2db      	uxtb	r3, r3
 800d446:	331c      	adds	r3, #28
 800d448:	b2db      	uxtb	r3, r3
 800d44a:	743b      	strb	r3, [r7, #16]
	xSemaphoreTake(txCpltSemHack, portMAX_DELAY);
 800d44c:	4b14      	ldr	r3, [pc, #80]	; (800d4a0 <SSD_writeRegion_hack+0xe4>)
 800d44e:	681b      	ldr	r3, [r3, #0]
 800d450:	f04f 31ff 	mov.w	r1, #4294967295
 800d454:	4618      	mov	r0, r3
 800d456:	f7fd fd4b 	bl	800aef0 <xQueueSemaphoreTake>
	HAL_UART_Transmit(&huart2, buf2, 5, 10);
 800d45a:	f107 010c 	add.w	r1, r7, #12
 800d45e:	230a      	movs	r3, #10
 800d460:	2205      	movs	r2, #5
 800d462:	4810      	ldr	r0, [pc, #64]	; (800d4a4 <SSD_writeRegion_hack+0xe8>)
 800d464:	f7fb f83e 	bl	80084e4 <HAL_UART_Transmit>
	dmabuf = pvPortMalloc(len);
 800d468:	6978      	ldr	r0, [r7, #20]
 800d46a:	f7ff fda5 	bl	800cfb8 <pvPortMalloc>
 800d46e:	4603      	mov	r3, r0
 800d470:	4a0a      	ldr	r2, [pc, #40]	; (800d49c <SSD_writeRegion_hack+0xe0>)
 800d472:	6013      	str	r3, [r2, #0]
	memcpy(dmabuf, buf, len);
 800d474:	4b09      	ldr	r3, [pc, #36]	; (800d49c <SSD_writeRegion_hack+0xe0>)
 800d476:	681b      	ldr	r3, [r3, #0]
 800d478:	697a      	ldr	r2, [r7, #20]
 800d47a:	6839      	ldr	r1, [r7, #0]
 800d47c:	4618      	mov	r0, r3
 800d47e:	f014 fbeb 	bl	8021c58 <memcpy>
	HAL_UART_Transmit_DMA(&huart2, dmabuf, len);
 800d482:	4b06      	ldr	r3, [pc, #24]	; (800d49c <SSD_writeRegion_hack+0xe0>)
 800d484:	681b      	ldr	r3, [r3, #0]
 800d486:	697a      	ldr	r2, [r7, #20]
 800d488:	b292      	uxth	r2, r2
 800d48a:	4619      	mov	r1, r3
 800d48c:	4805      	ldr	r0, [pc, #20]	; (800d4a4 <SSD_writeRegion_hack+0xe8>)
 800d48e:	f7fb f8bf 	bl	8008610 <HAL_UART_Transmit_DMA>
}
 800d492:	bf00      	nop
 800d494:	3720      	adds	r7, #32
 800d496:	46bd      	mov	sp, r7
 800d498:	bd80      	pop	{r7, pc}
 800d49a:	bf00      	nop
 800d49c:	24061e78 	.word	0x24061e78
 800d4a0:	24062480 	.word	0x24062480
 800d4a4:	24063020 	.word	0x24063020

0800d4a8 <my_rounder_cb>:
		spiSendByte(0);
		setCS(1);
	}
}

void my_rounder_cb(lv_disp_drv_t* disp_drv, lv_area_t* area){
 800d4a8:	b480      	push	{r7}
 800d4aa:	b083      	sub	sp, #12
 800d4ac:	af00      	add	r7, sp, #0
 800d4ae:	6078      	str	r0, [r7, #4]
 800d4b0:	6039      	str	r1, [r7, #0]
  /* Update the areas as needed. Can be only larger.
   * For example to always have lines 8 px height:*/
   area->x1 = area->x1 & 0xfffffffc;
 800d4b2:	683b      	ldr	r3, [r7, #0]
 800d4b4:	f9b3 3000 	ldrsh.w	r3, [r3]
 800d4b8:	f023 0303 	bic.w	r3, r3, #3
 800d4bc:	b21a      	sxth	r2, r3
 800d4be:	683b      	ldr	r3, [r7, #0]
 800d4c0:	801a      	strh	r2, [r3, #0]
   area->x2 = area->x2 | 0x3;
 800d4c2:	683b      	ldr	r3, [r7, #0]
 800d4c4:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 800d4c8:	f043 0303 	orr.w	r3, r3, #3
 800d4cc:	b21a      	sxth	r2, r3
 800d4ce:	683b      	ldr	r3, [r7, #0]
 800d4d0:	809a      	strh	r2, [r3, #4]
}
 800d4d2:	bf00      	nop
 800d4d4:	370c      	adds	r7, #12
 800d4d6:	46bd      	mov	sp, r7
 800d4d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d4dc:	4770      	bx	lr

0800d4de <my_disp_flush_hack>:
	SSD_writeRegion(area, buf);
	vPortFree(buf);
	lv_disp_flush_ready(disp_drv);         /* Indicate you are ready with the flushing*/
}

void my_disp_flush_hack(lv_disp_drv_t* disp_drv, const lv_area_t* area, lv_color_t* color_p){
 800d4de:	b580      	push	{r7, lr}
 800d4e0:	b08c      	sub	sp, #48	; 0x30
 800d4e2:	af00      	add	r7, sp, #0
 800d4e4:	60f8      	str	r0, [r7, #12]
 800d4e6:	60b9      	str	r1, [r7, #8]
 800d4e8:	607a      	str	r2, [r7, #4]
	uint32_t dx = area->x2-area->x1+1;
 800d4ea:	68bb      	ldr	r3, [r7, #8]
 800d4ec:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 800d4f0:	461a      	mov	r2, r3
 800d4f2:	68bb      	ldr	r3, [r7, #8]
 800d4f4:	f9b3 3000 	ldrsh.w	r3, [r3]
 800d4f8:	1ad3      	subs	r3, r2, r3
 800d4fa:	3301      	adds	r3, #1
 800d4fc:	623b      	str	r3, [r7, #32]
	uint32_t dy = area->y2-area->y1+1;
 800d4fe:	68bb      	ldr	r3, [r7, #8]
 800d500:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800d504:	461a      	mov	r2, r3
 800d506:	68bb      	ldr	r3, [r7, #8]
 800d508:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800d50c:	1ad3      	subs	r3, r2, r3
 800d50e:	3301      	adds	r3, #1
 800d510:	61fb      	str	r3, [r7, #28]
	uint32_t len = dx*dy;
 800d512:	6a3b      	ldr	r3, [r7, #32]
 800d514:	69fa      	ldr	r2, [r7, #28]
 800d516:	fb02 f303 	mul.w	r3, r2, r3
 800d51a:	61bb      	str	r3, [r7, #24]
	uint8_t* buf = pvPortMalloc(len/2);
 800d51c:	69bb      	ldr	r3, [r7, #24]
 800d51e:	085b      	lsrs	r3, r3, #1
 800d520:	4618      	mov	r0, r3
 800d522:	f7ff fd49 	bl	800cfb8 <pvPortMalloc>
 800d526:	6178      	str	r0, [r7, #20]
	uint8_t* bufp = buf;
 800d528:	697b      	ldr	r3, [r7, #20]
 800d52a:	62fb      	str	r3, [r7, #44]	; 0x2c
			*bufp = color_p++->full&0xf0;
			*bufp++ |= (color_p++->full&0xf0)>>4;
		}
	}
#else if LV_COLOR_DEPTH == 16
	for(size_t i = 0; i < dy; i++){
 800d52c:	2300      	movs	r3, #0
 800d52e:	62bb      	str	r3, [r7, #40]	; 0x28
 800d530:	e04a      	b.n	800d5c8 <my_disp_flush_hack+0xea>
		for(size_t j = 0; j < dx; j+=4){
 800d532:	2300      	movs	r3, #0
 800d534:	627b      	str	r3, [r7, #36]	; 0x24
 800d536:	e040      	b.n	800d5ba <my_disp_flush_hack+0xdc>
			*bufp = color_p++->ch.green>>2<<4;
 800d538:	687b      	ldr	r3, [r7, #4]
 800d53a:	1c9a      	adds	r2, r3, #2
 800d53c:	607a      	str	r2, [r7, #4]
 800d53e:	881b      	ldrh	r3, [r3, #0]
 800d540:	f3c3 1345 	ubfx	r3, r3, #5, #6
 800d544:	b2db      	uxtb	r3, r3
 800d546:	109b      	asrs	r3, r3, #2
 800d548:	b2db      	uxtb	r3, r3
 800d54a:	011b      	lsls	r3, r3, #4
 800d54c:	b2da      	uxtb	r2, r3
 800d54e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d550:	701a      	strb	r2, [r3, #0]
			*bufp++ |= color_p++->ch.green>>2;
 800d552:	687b      	ldr	r3, [r7, #4]
 800d554:	1c9a      	adds	r2, r3, #2
 800d556:	607a      	str	r2, [r7, #4]
 800d558:	881b      	ldrh	r3, [r3, #0]
 800d55a:	f3c3 1345 	ubfx	r3, r3, #5, #6
 800d55e:	b2db      	uxtb	r3, r3
 800d560:	1098      	asrs	r0, r3, #2
 800d562:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d564:	1c5a      	adds	r2, r3, #1
 800d566:	62fa      	str	r2, [r7, #44]	; 0x2c
 800d568:	781a      	ldrb	r2, [r3, #0]
 800d56a:	b251      	sxtb	r1, r2
 800d56c:	b242      	sxtb	r2, r0
 800d56e:	430a      	orrs	r2, r1
 800d570:	b252      	sxtb	r2, r2
 800d572:	b2d2      	uxtb	r2, r2
 800d574:	701a      	strb	r2, [r3, #0]
			*bufp = color_p++->ch.green>>2<<4;
 800d576:	687b      	ldr	r3, [r7, #4]
 800d578:	1c9a      	adds	r2, r3, #2
 800d57a:	607a      	str	r2, [r7, #4]
 800d57c:	881b      	ldrh	r3, [r3, #0]
 800d57e:	f3c3 1345 	ubfx	r3, r3, #5, #6
 800d582:	b2db      	uxtb	r3, r3
 800d584:	109b      	asrs	r3, r3, #2
 800d586:	b2db      	uxtb	r3, r3
 800d588:	011b      	lsls	r3, r3, #4
 800d58a:	b2da      	uxtb	r2, r3
 800d58c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d58e:	701a      	strb	r2, [r3, #0]
			*bufp++ |= color_p++->ch.green>>2;
 800d590:	687b      	ldr	r3, [r7, #4]
 800d592:	1c9a      	adds	r2, r3, #2
 800d594:	607a      	str	r2, [r7, #4]
 800d596:	881b      	ldrh	r3, [r3, #0]
 800d598:	f3c3 1345 	ubfx	r3, r3, #5, #6
 800d59c:	b2db      	uxtb	r3, r3
 800d59e:	1098      	asrs	r0, r3, #2
 800d5a0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800d5a2:	1c5a      	adds	r2, r3, #1
 800d5a4:	62fa      	str	r2, [r7, #44]	; 0x2c
 800d5a6:	781a      	ldrb	r2, [r3, #0]
 800d5a8:	b251      	sxtb	r1, r2
 800d5aa:	b242      	sxtb	r2, r0
 800d5ac:	430a      	orrs	r2, r1
 800d5ae:	b252      	sxtb	r2, r2
 800d5b0:	b2d2      	uxtb	r2, r2
 800d5b2:	701a      	strb	r2, [r3, #0]
		for(size_t j = 0; j < dx; j+=4){
 800d5b4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d5b6:	3304      	adds	r3, #4
 800d5b8:	627b      	str	r3, [r7, #36]	; 0x24
 800d5ba:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800d5bc:	6a3b      	ldr	r3, [r7, #32]
 800d5be:	429a      	cmp	r2, r3
 800d5c0:	d3ba      	bcc.n	800d538 <my_disp_flush_hack+0x5a>
	for(size_t i = 0; i < dy; i++){
 800d5c2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d5c4:	3301      	adds	r3, #1
 800d5c6:	62bb      	str	r3, [r7, #40]	; 0x28
 800d5c8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800d5ca:	69fb      	ldr	r3, [r7, #28]
 800d5cc:	429a      	cmp	r2, r3
 800d5ce:	d3b0      	bcc.n	800d532 <my_disp_flush_hack+0x54>
		}
	}
#endif
	SSD_writeRegion_hack(area, buf);
 800d5d0:	6979      	ldr	r1, [r7, #20]
 800d5d2:	68b8      	ldr	r0, [r7, #8]
 800d5d4:	f7ff fef2 	bl	800d3bc <SSD_writeRegion_hack>
	vPortFree(buf);
 800d5d8:	6978      	ldr	r0, [r7, #20]
 800d5da:	f7ff fdb9 	bl	800d150 <vPortFree>
	lv_disp_flush_ready(disp_drv);         /* Indicate you are ready with the flushing*/
 800d5de:	68f8      	ldr	r0, [r7, #12]
 800d5e0:	f00f fdf7 	bl	801d1d2 <lv_disp_flush_ready>
}
 800d5e4:	bf00      	nop
 800d5e6:	3730      	adds	r7, #48	; 0x30
 800d5e8:	46bd      	mov	sp, r7
 800d5ea:	bd80      	pop	{r7, pc}

0800d5ec <HAL_SPI_TxCpltCallback>:
static void spiSendBuf(uint8_t* buf, size_t len){
	xSemaphoreTake(txCpltSem, portMAX_DELAY);
	HAL_SPI_Transmit_DMA(hspi, buf, len);
}

void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi){
 800d5ec:	b580      	push	{r7, lr}
 800d5ee:	b082      	sub	sp, #8
 800d5f0:	af00      	add	r7, sp, #0
 800d5f2:	6078      	str	r0, [r7, #4]
	if(hspi == &hspi2){
 800d5f4:	687b      	ldr	r3, [r7, #4]
 800d5f6:	4a06      	ldr	r2, [pc, #24]	; (800d610 <HAL_SPI_TxCpltCallback+0x24>)
 800d5f8:	4293      	cmp	r3, r2
 800d5fa:	d105      	bne.n	800d608 <HAL_SPI_TxCpltCallback+0x1c>
		xSemaphoreGiveFromISR(txCpltSem, NULL);
 800d5fc:	4b05      	ldr	r3, [pc, #20]	; (800d614 <HAL_SPI_TxCpltCallback+0x28>)
 800d5fe:	681b      	ldr	r3, [r3, #0]
 800d600:	2100      	movs	r1, #0
 800d602:	4618      	mov	r0, r3
 800d604:	f7fd fb07 	bl	800ac16 <xQueueGiveFromISR>
	}
}
 800d608:	bf00      	nop
 800d60a:	3708      	adds	r7, #8
 800d60c:	46bd      	mov	sp, r7
 800d60e:	bd80      	pop	{r7, pc}
 800d610:	2406259c 	.word	0x2406259c
 800d614:	24061e74 	.word	0x24061e74

0800d618 <HAL_SPI_TxRxCpltCallback>:
// ##        ##   ##  ##       ##       ##     ##  ##   ##  ##       ##  ##
// ##       ##     ## ##       ##       ########  ##     ## ##       #####
// ##       ######### ##       ##       ##     ## ######### ##       ##  ##
// ##    ## ##     ## ##       ##       ##     ## ##     ## ##    ## ##   ##
//  ######  ##     ## ######## ######## ########  ##     ##  ######  ##    ##
HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef* hspi){
 800d618:	b580      	push	{r7, lr}
 800d61a:	b084      	sub	sp, #16
 800d61c:	af00      	add	r7, sp, #0
 800d61e:	6078      	str	r0, [r7, #4]
	for(int i = 0; i < NUM_SPIS; i++){
 800d620:	2300      	movs	r3, #0
 800d622:	60fb      	str	r3, [r7, #12]
 800d624:	e012      	b.n	800d64c <HAL_SPI_TxRxCpltCallback+0x34>
		if(hspis[i] == hspi){
 800d626:	4a0d      	ldr	r2, [pc, #52]	; (800d65c <HAL_SPI_TxRxCpltCallback+0x44>)
 800d628:	68fb      	ldr	r3, [r7, #12]
 800d62a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800d62e:	687a      	ldr	r2, [r7, #4]
 800d630:	429a      	cmp	r2, r3
 800d632:	d108      	bne.n	800d646 <HAL_SPI_TxRxCpltCallback+0x2e>
			xSemaphoreGiveFromISR(bspis[i]->spiSem, NULL);
 800d634:	4a0a      	ldr	r2, [pc, #40]	; (800d660 <HAL_SPI_TxRxCpltCallback+0x48>)
 800d636:	68fb      	ldr	r3, [r7, #12]
 800d638:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800d63c:	691b      	ldr	r3, [r3, #16]
 800d63e:	2100      	movs	r1, #0
 800d640:	4618      	mov	r0, r3
 800d642:	f7fd fae8 	bl	800ac16 <xQueueGiveFromISR>
	for(int i = 0; i < NUM_SPIS; i++){
 800d646:	68fb      	ldr	r3, [r7, #12]
 800d648:	3301      	adds	r3, #1
 800d64a:	60fb      	str	r3, [r7, #12]
 800d64c:	68fb      	ldr	r3, [r7, #12]
 800d64e:	2b02      	cmp	r3, #2
 800d650:	dde9      	ble.n	800d626 <HAL_SPI_TxRxCpltCallback+0xe>
		}
	}
}
 800d652:	bf00      	nop
 800d654:	bf00      	nop
 800d656:	3710      	adds	r7, #16
 800d658:	46bd      	mov	sp, r7
 800d65a:	bd80      	pop	{r7, pc}
 800d65c:	24061e88 	.word	0x24061e88
 800d660:	24061e7c 	.word	0x24061e7c

0800d664 <lv_color_make>:
}
#elif LV_COLOR_DEPTH == 16
#if LV_COLOR_16_SWAP == 0
#define LV_COLOR_MAKE(r8, g8, b8) ((lv_color_t){{b8 >> 3, g8 >> 2, r8 >> 3}})
static inline lv_color_t lv_color_make(uint8_t r8, uint8_t g8, uint8_t b8)
{
 800d664:	b480      	push	{r7}
 800d666:	b085      	sub	sp, #20
 800d668:	af00      	add	r7, sp, #0
 800d66a:	4603      	mov	r3, r0
 800d66c:	71fb      	strb	r3, [r7, #7]
 800d66e:	460b      	mov	r3, r1
 800d670:	71bb      	strb	r3, [r7, #6]
 800d672:	4613      	mov	r3, r2
 800d674:	717b      	strb	r3, [r7, #5]
    lv_color_t color;
    color.ch.blue  = (uint16_t)(b8 >> 3);
 800d676:	797b      	ldrb	r3, [r7, #5]
 800d678:	08db      	lsrs	r3, r3, #3
 800d67a:	b2db      	uxtb	r3, r3
 800d67c:	f003 031f 	and.w	r3, r3, #31
 800d680:	b2da      	uxtb	r2, r3
 800d682:	7b3b      	ldrb	r3, [r7, #12]
 800d684:	f362 0304 	bfi	r3, r2, #0, #5
 800d688:	733b      	strb	r3, [r7, #12]
    color.ch.green = (uint16_t)(g8 >> 2);
 800d68a:	79bb      	ldrb	r3, [r7, #6]
 800d68c:	089b      	lsrs	r3, r3, #2
 800d68e:	b2db      	uxtb	r3, r3
 800d690:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800d694:	b2da      	uxtb	r2, r3
 800d696:	89bb      	ldrh	r3, [r7, #12]
 800d698:	f362 134a 	bfi	r3, r2, #5, #6
 800d69c:	81bb      	strh	r3, [r7, #12]
    color.ch.red   = (uint16_t)(r8 >> 3);
 800d69e:	79fb      	ldrb	r3, [r7, #7]
 800d6a0:	08db      	lsrs	r3, r3, #3
 800d6a2:	b2db      	uxtb	r3, r3
 800d6a4:	f003 031f 	and.w	r3, r3, #31
 800d6a8:	b2da      	uxtb	r2, r3
 800d6aa:	7b7b      	ldrb	r3, [r7, #13]
 800d6ac:	f362 03c7 	bfi	r3, r2, #3, #5
 800d6b0:	737b      	strb	r3, [r7, #13]
    return color;
 800d6b2:	89bb      	ldrh	r3, [r7, #12]
}
 800d6b4:	4618      	mov	r0, r3
 800d6b6:	3714      	adds	r7, #20
 800d6b8:	46bd      	mov	sp, r7
 800d6ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d6be:	4770      	bx	lr

0800d6c0 <lv_color_hex3>:
{
    return lv_color_make((uint8_t)((c >> 16) & 0xFF), (uint8_t)((c >> 8) & 0xFF), (uint8_t)(c & 0xFF));
}

static inline lv_color_t lv_color_hex3(uint32_t c)
{
 800d6c0:	b580      	push	{r7, lr}
 800d6c2:	b082      	sub	sp, #8
 800d6c4:	af00      	add	r7, sp, #0
 800d6c6:	6078      	str	r0, [r7, #4]
    return lv_color_make((uint8_t)(((c >> 4) & 0xF0) | ((c >> 8) & 0xF)), (uint8_t)((c & 0xF0) | ((c & 0xF0) >> 4)),
 800d6c8:	687b      	ldr	r3, [r7, #4]
 800d6ca:	091b      	lsrs	r3, r3, #4
 800d6cc:	b2db      	uxtb	r3, r3
 800d6ce:	f023 030f 	bic.w	r3, r3, #15
 800d6d2:	b2da      	uxtb	r2, r3
 800d6d4:	687b      	ldr	r3, [r7, #4]
 800d6d6:	0a1b      	lsrs	r3, r3, #8
 800d6d8:	b2db      	uxtb	r3, r3
 800d6da:	f003 030f 	and.w	r3, r3, #15
 800d6de:	b2db      	uxtb	r3, r3
 800d6e0:	4313      	orrs	r3, r2
 800d6e2:	b2d8      	uxtb	r0, r3
 800d6e4:	687b      	ldr	r3, [r7, #4]
 800d6e6:	b2db      	uxtb	r3, r3
 800d6e8:	f023 030f 	bic.w	r3, r3, #15
 800d6ec:	b2da      	uxtb	r2, r3
 800d6ee:	687b      	ldr	r3, [r7, #4]
 800d6f0:	091b      	lsrs	r3, r3, #4
 800d6f2:	b2db      	uxtb	r3, r3
 800d6f4:	f003 030f 	and.w	r3, r3, #15
 800d6f8:	b2db      	uxtb	r3, r3
 800d6fa:	4313      	orrs	r3, r2
 800d6fc:	b2d9      	uxtb	r1, r3
                         (uint8_t)((c & 0xF) | ((c & 0xF) << 4)));
 800d6fe:	687b      	ldr	r3, [r7, #4]
 800d700:	b2db      	uxtb	r3, r3
 800d702:	f003 030f 	and.w	r3, r3, #15
 800d706:	b2da      	uxtb	r2, r3
 800d708:	687b      	ldr	r3, [r7, #4]
 800d70a:	b2db      	uxtb	r3, r3
 800d70c:	011b      	lsls	r3, r3, #4
 800d70e:	b2db      	uxtb	r3, r3
    return lv_color_make((uint8_t)(((c >> 4) & 0xF0) | ((c >> 8) & 0xF)), (uint8_t)((c & 0xF0) | ((c & 0xF0) >> 4)),
 800d710:	4313      	orrs	r3, r2
 800d712:	b2db      	uxtb	r3, r3
 800d714:	461a      	mov	r2, r3
 800d716:	f7ff ffa5 	bl	800d664 <lv_color_make>
 800d71a:	4603      	mov	r3, r0
}
 800d71c:	4618      	mov	r0, r3
 800d71e:	3708      	adds	r7, #8
 800d720:	46bd      	mov	sp, r7
 800d722:	bd80      	pop	{r7, pc}

0800d724 <lv_scr_act>:
/**
 * Get the active screen of the default display
 * @return pointer to the active screen
 */
static inline lv_obj_t * lv_scr_act(void)
{
 800d724:	b580      	push	{r7, lr}
 800d726:	af00      	add	r7, sp, #0
    return lv_disp_get_scr_act(lv_disp_get_default());
 800d728:	f00f fce8 	bl	801d0fc <lv_disp_get_default>
 800d72c:	4603      	mov	r3, r0
 800d72e:	4618      	mov	r0, r3
 800d730:	f004 fd58 	bl	80121e4 <lv_disp_get_scr_act>
 800d734:	4603      	mov	r3, r0
}
 800d736:	4618      	mov	r0, r3
 800d738:	bd80      	pop	{r7, pc}

0800d73a <lv_label_set_style>:
 * @param label pointer to an label object
 * @param type which style should be get (can be only `LV_LABEL_STYLE_MAIN`)
 * @param style pointer to a style
 */
static inline void lv_label_set_style(lv_obj_t * label, lv_label_style_t type, const lv_style_t * style)
{
 800d73a:	b580      	push	{r7, lr}
 800d73c:	b084      	sub	sp, #16
 800d73e:	af00      	add	r7, sp, #0
 800d740:	60f8      	str	r0, [r7, #12]
 800d742:	460b      	mov	r3, r1
 800d744:	607a      	str	r2, [r7, #4]
 800d746:	72fb      	strb	r3, [r7, #11]
    (void)type; /*Unused*/
    lv_obj_set_style(label, style);
 800d748:	6879      	ldr	r1, [r7, #4]
 800d74a:	68f8      	ldr	r0, [r7, #12]
 800d74c:	f006 f965 	bl	8013a1a <lv_obj_set_style>
}
 800d750:	bf00      	nop
 800d752:	3710      	adds	r7, #16
 800d754:	46bd      	mov	sp, r7
 800d756:	bd80      	pop	{r7, pc}

0800d758 <initStyles>:
static lv_style_t motAccTxtStl;
static lv_style_t motLedStl;

static lv_style_t textMsgStl;

static void initStyles(){
 800d758:	b598      	push	{r3, r4, r7, lr}
 800d75a:	af00      	add	r7, sp, #0
	// Screen Background
	lv_style_copy(&screenStl, &lv_style_transp_tight);
 800d75c:	4986      	ldr	r1, [pc, #536]	; (800d978 <initStyles+0x220>)
 800d75e:	4887      	ldr	r0, [pc, #540]	; (800d97c <initStyles+0x224>)
 800d760:	f007 fe0c 	bl	801537c <lv_style_copy>
	screenStl.body.main_color = lv_color_hex3(0x000);
 800d764:	4c85      	ldr	r4, [pc, #532]	; (800d97c <initStyles+0x224>)
 800d766:	2000      	movs	r0, #0
 800d768:	f7ff ffaa 	bl	800d6c0 <lv_color_hex3>
 800d76c:	8060      	strh	r0, [r4, #2]
	screenStl.text.color = lv_color_hex3(0x0F0);
 800d76e:	4c83      	ldr	r4, [pc, #524]	; (800d97c <initStyles+0x224>)
 800d770:	20f0      	movs	r0, #240	; 0xf0
 800d772:	f7ff ffa5 	bl	800d6c0 <lv_color_hex3>
 800d776:	8420      	strh	r0, [r4, #32]
	screenStl.text.font = &Hack_8_2FA1F;
 800d778:	4b80      	ldr	r3, [pc, #512]	; (800d97c <initStyles+0x224>)
 800d77a:	4a81      	ldr	r2, [pc, #516]	; (800d980 <initStyles+0x228>)
 800d77c:	625a      	str	r2, [r3, #36]	; 0x24
	// Indicator Bar Style
	lv_style_copy(&barStl, &lv_style_plain);
 800d77e:	4981      	ldr	r1, [pc, #516]	; (800d984 <initStyles+0x22c>)
 800d780:	4881      	ldr	r0, [pc, #516]	; (800d988 <initStyles+0x230>)
 800d782:	f007 fdfb 	bl	801537c <lv_style_copy>
	barStl.body.main_color = lv_color_hex3(0xaaa);
 800d786:	4c80      	ldr	r4, [pc, #512]	; (800d988 <initStyles+0x230>)
 800d788:	f640 20aa 	movw	r0, #2730	; 0xaaa
 800d78c:	f7ff ff98 	bl	800d6c0 <lv_color_hex3>
 800d790:	8060      	strh	r0, [r4, #2]
	barStl.body.opa = 255;
 800d792:	4b7d      	ldr	r3, [pc, #500]	; (800d988 <initStyles+0x230>)
 800d794:	22ff      	movs	r2, #255	; 0xff
 800d796:	721a      	strb	r2, [r3, #8]
	// Big Number
	lv_style_copy(&bigNumStl, &lv_style_transp_tight);
 800d798:	4977      	ldr	r1, [pc, #476]	; (800d978 <initStyles+0x220>)
 800d79a:	487c      	ldr	r0, [pc, #496]	; (800d98c <initStyles+0x234>)
 800d79c:	f007 fdee 	bl	801537c <lv_style_copy>
	bigNumStl.body.main_color = lv_color_hex3(0x000);
 800d7a0:	4c7a      	ldr	r4, [pc, #488]	; (800d98c <initStyles+0x234>)
 800d7a2:	2000      	movs	r0, #0
 800d7a4:	f7ff ff8c 	bl	800d6c0 <lv_color_hex3>
 800d7a8:	8060      	strh	r0, [r4, #2]
	bigNumStl.text.color = lv_color_hex3(0x0F0);
 800d7aa:	4c78      	ldr	r4, [pc, #480]	; (800d98c <initStyles+0x234>)
 800d7ac:	20f0      	movs	r0, #240	; 0xf0
 800d7ae:	f7ff ff87 	bl	800d6c0 <lv_color_hex3>
 800d7b2:	8420      	strh	r0, [r4, #32]
	bigNumStl.text.font = &Hack_32_2FA1F;
 800d7b4:	4b75      	ldr	r3, [pc, #468]	; (800d98c <initStyles+0x234>)
 800d7b6:	4a76      	ldr	r2, [pc, #472]	; (800d990 <initStyles+0x238>)
 800d7b8:	625a      	str	r2, [r3, #36]	; 0x24
	// Target Speed
	lv_style_copy(&targetSpeedStl, &bigNumStl);
 800d7ba:	4974      	ldr	r1, [pc, #464]	; (800d98c <initStyles+0x234>)
 800d7bc:	4875      	ldr	r0, [pc, #468]	; (800d994 <initStyles+0x23c>)
 800d7be:	f007 fddd 	bl	801537c <lv_style_copy>
	targetSpeedStl.text.font = &Hack_16_2FA1F;
 800d7c2:	4b74      	ldr	r3, [pc, #464]	; (800d994 <initStyles+0x23c>)
 800d7c4:	4a74      	ldr	r2, [pc, #464]	; (800d998 <initStyles+0x240>)
 800d7c6:	625a      	str	r2, [r3, #36]	; 0x24
	// Big Number's Units
	lv_style_copy(&bigUnitStl, &lv_style_transp_tight);
 800d7c8:	496b      	ldr	r1, [pc, #428]	; (800d978 <initStyles+0x220>)
 800d7ca:	4874      	ldr	r0, [pc, #464]	; (800d99c <initStyles+0x244>)
 800d7cc:	f007 fdd6 	bl	801537c <lv_style_copy>
	bigUnitStl.body.main_color = lv_color_hex3(0x000);
 800d7d0:	4c72      	ldr	r4, [pc, #456]	; (800d99c <initStyles+0x244>)
 800d7d2:	2000      	movs	r0, #0
 800d7d4:	f7ff ff74 	bl	800d6c0 <lv_color_hex3>
 800d7d8:	8060      	strh	r0, [r4, #2]
	bigUnitStl.text.color = lv_color_hex3(0x090);
 800d7da:	4c70      	ldr	r4, [pc, #448]	; (800d99c <initStyles+0x244>)
 800d7dc:	2090      	movs	r0, #144	; 0x90
 800d7de:	f7ff ff6f 	bl	800d6c0 <lv_color_hex3>
 800d7e2:	8420      	strh	r0, [r4, #32]
	bigUnitStl.text.font = &Hack_16_2FA1F;
 800d7e4:	4b6d      	ldr	r3, [pc, #436]	; (800d99c <initStyles+0x244>)
 800d7e6:	4a6c      	ldr	r2, [pc, #432]	; (800d998 <initStyles+0x240>)
 800d7e8:	625a      	str	r2, [r3, #36]	; 0x24
	// Screen Divider
	lv_style_copy(&scrDivStl, &lv_style_transp_tight);
 800d7ea:	4963      	ldr	r1, [pc, #396]	; (800d978 <initStyles+0x220>)
 800d7ec:	486c      	ldr	r0, [pc, #432]	; (800d9a0 <initStyles+0x248>)
 800d7ee:	f007 fdc5 	bl	801537c <lv_style_copy>
	scrDivStl.body.main_color = lv_color_hex3(0x0C0);
 800d7f2:	4c6b      	ldr	r4, [pc, #428]	; (800d9a0 <initStyles+0x248>)
 800d7f4:	20c0      	movs	r0, #192	; 0xc0
 800d7f6:	f7ff ff63 	bl	800d6c0 <lv_color_hex3>
 800d7fa:	8060      	strh	r0, [r4, #2]
	scrDivStl.body.border.width = 1;
 800d7fc:	4b68      	ldr	r3, [pc, #416]	; (800d9a0 <initStyles+0x248>)
 800d7fe:	2201      	movs	r2, #1
 800d800:	819a      	strh	r2, [r3, #12]
	scrDivStl.body.border.color = lv_color_hex3(0x0C0);
 800d802:	4c67      	ldr	r4, [pc, #412]	; (800d9a0 <initStyles+0x248>)
 800d804:	20c0      	movs	r0, #192	; 0xc0
 800d806:	f7ff ff5b 	bl	800d6c0 <lv_color_hex3>
 800d80a:	8160      	strh	r0, [r4, #10]
	// Small Text
	lv_style_copy(&smlTxtStl, &bigNumStl);
 800d80c:	495f      	ldr	r1, [pc, #380]	; (800d98c <initStyles+0x234>)
 800d80e:	4865      	ldr	r0, [pc, #404]	; (800d9a4 <initStyles+0x24c>)
 800d810:	f007 fdb4 	bl	801537c <lv_style_copy>
	smlTxtStl.text.font = &Hack_8_2FA1F;
 800d814:	4b63      	ldr	r3, [pc, #396]	; (800d9a4 <initStyles+0x24c>)
 800d816:	4a5a      	ldr	r2, [pc, #360]	; (800d980 <initStyles+0x228>)
 800d818:	625a      	str	r2, [r3, #36]	; 0x24
	// Main Power Style
	lv_style_copy(&pwrTxtStl, &bigNumStl);
 800d81a:	495c      	ldr	r1, [pc, #368]	; (800d98c <initStyles+0x234>)
 800d81c:	4862      	ldr	r0, [pc, #392]	; (800d9a8 <initStyles+0x250>)
 800d81e:	f007 fdad 	bl	801537c <lv_style_copy>
	pwrTxtStl.text.font = &Hack_12_2FA1F;
 800d822:	4b61      	ldr	r3, [pc, #388]	; (800d9a8 <initStyles+0x250>)
 800d824:	4a61      	ldr	r2, [pc, #388]	; (800d9ac <initStyles+0x254>)
 800d826:	625a      	str	r2, [r3, #36]	; 0x24
	// Gear Text Style
	lv_style_copy(&gearTxtStl, &bigNumStl);
 800d828:	4958      	ldr	r1, [pc, #352]	; (800d98c <initStyles+0x234>)
 800d82a:	4861      	ldr	r0, [pc, #388]	; (800d9b0 <initStyles+0x258>)
 800d82c:	f007 fda6 	bl	801537c <lv_style_copy>
	gearTxtStl.text.font = &Hack_24_2FA1F;
 800d830:	4b5f      	ldr	r3, [pc, #380]	; (800d9b0 <initStyles+0x258>)
 800d832:	4a60      	ldr	r2, [pc, #384]	; (800d9b4 <initStyles+0x25c>)
 800d834:	625a      	str	r2, [r3, #36]	; 0x24
	gearTxtStl.text.color = lv_color_hex3(0x0C0);
 800d836:	4c5e      	ldr	r4, [pc, #376]	; (800d9b0 <initStyles+0x258>)
 800d838:	20c0      	movs	r0, #192	; 0xc0
 800d83a:	f7ff ff41 	bl	800d6c0 <lv_color_hex3>
 800d83e:	8420      	strh	r0, [r4, #32]
	// Main screen VFM Style
	lv_style_copy(&mainVfmStl, &bigNumStl);
 800d840:	4952      	ldr	r1, [pc, #328]	; (800d98c <initStyles+0x234>)
 800d842:	485d      	ldr	r0, [pc, #372]	; (800d9b8 <initStyles+0x260>)
 800d844:	f007 fd9a 	bl	801537c <lv_style_copy>
	mainVfmStl.text.font = &DISP_Ds_24_7F;
 800d848:	4b5b      	ldr	r3, [pc, #364]	; (800d9b8 <initStyles+0x260>)
 800d84a:	4a5c      	ldr	r2, [pc, #368]	; (800d9bc <initStyles+0x264>)
 800d84c:	625a      	str	r2, [r3, #36]	; 0x24
	mainVfmStl.text.color = lv_color_hex3(0xCCC);
 800d84e:	4c5a      	ldr	r4, [pc, #360]	; (800d9b8 <initStyles+0x260>)
 800d850:	f640 40cc 	movw	r0, #3276	; 0xccc
 800d854:	f7ff ff34 	bl	800d6c0 <lv_color_hex3>
 800d858:	8420      	strh	r0, [r4, #32]
	// Mot On Box Style
	lv_style_copy(&motOnStl, &lv_style_plain);
 800d85a:	494a      	ldr	r1, [pc, #296]	; (800d984 <initStyles+0x22c>)
 800d85c:	4858      	ldr	r0, [pc, #352]	; (800d9c0 <initStyles+0x268>)
 800d85e:	f007 fd8d 	bl	801537c <lv_style_copy>
	motOnStl.text.font = &Hack_16_2FA1F;
 800d862:	4b57      	ldr	r3, [pc, #348]	; (800d9c0 <initStyles+0x268>)
 800d864:	4a4c      	ldr	r2, [pc, #304]	; (800d998 <initStyles+0x240>)
 800d866:	625a      	str	r2, [r3, #36]	; 0x24
	motOnStl.text.color = lv_color_hex3(0xFFF);
 800d868:	4c55      	ldr	r4, [pc, #340]	; (800d9c0 <initStyles+0x268>)
 800d86a:	f640 70ff 	movw	r0, #4095	; 0xfff
 800d86e:	f7ff ff27 	bl	800d6c0 <lv_color_hex3>
 800d872:	8420      	strh	r0, [r4, #32]
	motOnStl.body.border.width = 2;
 800d874:	4b52      	ldr	r3, [pc, #328]	; (800d9c0 <initStyles+0x268>)
 800d876:	2202      	movs	r2, #2
 800d878:	819a      	strh	r2, [r3, #12]
	motOnStl.body.border.color = lv_color_hex3(0xFFF);
 800d87a:	4c51      	ldr	r4, [pc, #324]	; (800d9c0 <initStyles+0x268>)
 800d87c:	f640 70ff 	movw	r0, #4095	; 0xfff
 800d880:	f7ff ff1e 	bl	800d6c0 <lv_color_hex3>
 800d884:	8160      	strh	r0, [r4, #10]
	motOnStl.body.opa = 255;
 800d886:	4b4e      	ldr	r3, [pc, #312]	; (800d9c0 <initStyles+0x268>)
 800d888:	22ff      	movs	r2, #255	; 0xff
 800d88a:	721a      	strb	r2, [r3, #8]
	motOnStl.body.border.opa = 255;
 800d88c:	4b4c      	ldr	r3, [pc, #304]	; (800d9c0 <initStyles+0x268>)
 800d88e:	22ff      	movs	r2, #255	; 0xff
 800d890:	73da      	strb	r2, [r3, #15]
	motOnStl.body.main_color = lv_color_hex3(0x000);
 800d892:	4c4b      	ldr	r4, [pc, #300]	; (800d9c0 <initStyles+0x268>)
 800d894:	2000      	movs	r0, #0
 800d896:	f7ff ff13 	bl	800d6c0 <lv_color_hex3>
 800d89a:	8060      	strh	r0, [r4, #2]
	motOnStl.body.grad_color = lv_color_hex3(0x000);
 800d89c:	4c48      	ldr	r4, [pc, #288]	; (800d9c0 <initStyles+0x268>)
 800d89e:	2000      	movs	r0, #0
 800d8a0:	f7ff ff0e 	bl	800d6c0 <lv_color_hex3>
 800d8a4:	80a0      	strh	r0, [r4, #4]
	motOnStl.body.padding.inner = 7;
 800d8a6:	4b46      	ldr	r3, [pc, #280]	; (800d9c0 <initStyles+0x268>)
 800d8a8:	2207      	movs	r2, #7
 800d8aa:	83da      	strh	r2, [r3, #30]

	// motVfmStl
	lv_style_copy(&motVfmStl, &bigNumStl);
 800d8ac:	4937      	ldr	r1, [pc, #220]	; (800d98c <initStyles+0x234>)
 800d8ae:	4845      	ldr	r0, [pc, #276]	; (800d9c4 <initStyles+0x26c>)
 800d8b0:	f007 fd64 	bl	801537c <lv_style_copy>
	motVfmStl.text.font = &DISP_Ds_55_7F;
 800d8b4:	4b43      	ldr	r3, [pc, #268]	; (800d9c4 <initStyles+0x26c>)
 800d8b6:	4a44      	ldr	r2, [pc, #272]	; (800d9c8 <initStyles+0x270>)
 800d8b8:	625a      	str	r2, [r3, #36]	; 0x24
	motVfmStl.text.color = lv_color_hex3(0xCCC);
 800d8ba:	4c42      	ldr	r4, [pc, #264]	; (800d9c4 <initStyles+0x26c>)
 800d8bc:	f640 40cc 	movw	r0, #3276	; 0xccc
 800d8c0:	f7ff fefe 	bl	800d6c0 <lv_color_hex3>
 800d8c4:	8420      	strh	r0, [r4, #32]
	motLcdStl.text.letter_space = 1;
 800d8c6:	4b41      	ldr	r3, [pc, #260]	; (800d9cc <initStyles+0x274>)
 800d8c8:	2201      	movs	r2, #1
 800d8ca:	851a      	strh	r2, [r3, #40]	; 0x28
	// motLcdStl
	lv_style_copy(&motLcdStl, &bigNumStl);
 800d8cc:	492f      	ldr	r1, [pc, #188]	; (800d98c <initStyles+0x234>)
 800d8ce:	483f      	ldr	r0, [pc, #252]	; (800d9cc <initStyles+0x274>)
 800d8d0:	f007 fd54 	bl	801537c <lv_style_copy>
	motLcdStl.text.font = &DISP_Thumb_8_7F;
 800d8d4:	4b3d      	ldr	r3, [pc, #244]	; (800d9cc <initStyles+0x274>)
 800d8d6:	4a3e      	ldr	r2, [pc, #248]	; (800d9d0 <initStyles+0x278>)
 800d8d8:	625a      	str	r2, [r3, #36]	; 0x24
	motLcdStl.text.color = lv_color_hex3(0xFFF);
 800d8da:	4c3c      	ldr	r4, [pc, #240]	; (800d9cc <initStyles+0x274>)
 800d8dc:	f640 70ff 	movw	r0, #4095	; 0xfff
 800d8e0:	f7ff feee 	bl	800d6c0 <lv_color_hex3>
 800d8e4:	8420      	strh	r0, [r4, #32]
	motLcdStl.text.line_space = 0;
 800d8e6:	4b39      	ldr	r3, [pc, #228]	; (800d9cc <initStyles+0x274>)
 800d8e8:	2200      	movs	r2, #0
 800d8ea:	855a      	strh	r2, [r3, #42]	; 0x2a
	// motMtaStl
	lv_style_copy(&motMtaStl, &bigNumStl);
 800d8ec:	4927      	ldr	r1, [pc, #156]	; (800d98c <initStyles+0x234>)
 800d8ee:	4839      	ldr	r0, [pc, #228]	; (800d9d4 <initStyles+0x27c>)
 800d8f0:	f007 fd44 	bl	801537c <lv_style_copy>
	motMtaStl.text.font = &Hack_16_2FA1F;
 800d8f4:	4b37      	ldr	r3, [pc, #220]	; (800d9d4 <initStyles+0x27c>)
 800d8f6:	4a28      	ldr	r2, [pc, #160]	; (800d998 <initStyles+0x240>)
 800d8f8:	625a      	str	r2, [r3, #36]	; 0x24
	motMtaStl.text.color = lv_color_hex3(0xFFF);
 800d8fa:	4c36      	ldr	r4, [pc, #216]	; (800d9d4 <initStyles+0x27c>)
 800d8fc:	f640 70ff 	movw	r0, #4095	; 0xfff
 800d900:	f7ff fede 	bl	800d6c0 <lv_color_hex3>
 800d904:	8420      	strh	r0, [r4, #32]
	// motAccArcStl
	lv_style_copy(&motAccArcStl, &lv_style_plain);
 800d906:	491f      	ldr	r1, [pc, #124]	; (800d984 <initStyles+0x22c>)
 800d908:	4833      	ldr	r0, [pc, #204]	; (800d9d8 <initStyles+0x280>)
 800d90a:	f007 fd37 	bl	801537c <lv_style_copy>
	motAccArcStl.line.color = lv_color_hex3(0xFFF);
 800d90e:	4c32      	ldr	r4, [pc, #200]	; (800d9d8 <initStyles+0x280>)
 800d910:	f640 70ff 	movw	r0, #4095	; 0xfff
 800d914:	f7ff fed4 	bl	800d6c0 <lv_color_hex3>
 800d918:	86a0      	strh	r0, [r4, #52]	; 0x34
	motAccArcStl.line.width = 2;
 800d91a:	4b2f      	ldr	r3, [pc, #188]	; (800d9d8 <initStyles+0x280>)
 800d91c:	2202      	movs	r2, #2
 800d91e:	86da      	strh	r2, [r3, #54]	; 0x36
	motAccArcStl.line.opa = 255;
 800d920:	4b2d      	ldr	r3, [pc, #180]	; (800d9d8 <initStyles+0x280>)
 800d922:	22ff      	movs	r2, #255	; 0xff
 800d924:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
	motOnStl.body.opa = 255;
 800d928:	4b25      	ldr	r3, [pc, #148]	; (800d9c0 <initStyles+0x268>)
 800d92a:	22ff      	movs	r2, #255	; 0xff
 800d92c:	721a      	strb	r2, [r3, #8]
	// motAccTxtStl
	lv_style_copy(&motAccTxtStl, &bigNumStl);
 800d92e:	4917      	ldr	r1, [pc, #92]	; (800d98c <initStyles+0x234>)
 800d930:	482a      	ldr	r0, [pc, #168]	; (800d9dc <initStyles+0x284>)
 800d932:	f007 fd23 	bl	801537c <lv_style_copy>
	motAccTxtStl.text.font = &Hack_12_2FA1F;
 800d936:	4b29      	ldr	r3, [pc, #164]	; (800d9dc <initStyles+0x284>)
 800d938:	4a1c      	ldr	r2, [pc, #112]	; (800d9ac <initStyles+0x254>)
 800d93a:	625a      	str	r2, [r3, #36]	; 0x24
	motAccTxtStl.text.color = lv_color_hex3(0xFFF);
 800d93c:	4c27      	ldr	r4, [pc, #156]	; (800d9dc <initStyles+0x284>)
 800d93e:	f640 70ff 	movw	r0, #4095	; 0xfff
 800d942:	f7ff febd 	bl	800d6c0 <lv_color_hex3>
 800d946:	8420      	strh	r0, [r4, #32]
	// motLedStl
	lv_style_copy(&motLedStl, &barStl);
 800d948:	490f      	ldr	r1, [pc, #60]	; (800d988 <initStyles+0x230>)
 800d94a:	4825      	ldr	r0, [pc, #148]	; (800d9e0 <initStyles+0x288>)
 800d94c:	f007 fd16 	bl	801537c <lv_style_copy>
	motLedStl.body.radius = LV_RADIUS_CIRCLE;
 800d950:	4b23      	ldr	r3, [pc, #140]	; (800d9e0 <initStyles+0x288>)
 800d952:	f647 4218 	movw	r2, #31768	; 0x7c18
 800d956:	80da      	strh	r2, [r3, #6]

	// textMsgStl
	lv_style_copy(&textMsgStl, &bigNumStl);
 800d958:	490c      	ldr	r1, [pc, #48]	; (800d98c <initStyles+0x234>)
 800d95a:	4822      	ldr	r0, [pc, #136]	; (800d9e4 <initStyles+0x28c>)
 800d95c:	f007 fd0e 	bl	801537c <lv_style_copy>
	textMsgStl.text.font = &Hack_12_2FA1F;
 800d960:	4b20      	ldr	r3, [pc, #128]	; (800d9e4 <initStyles+0x28c>)
 800d962:	4a12      	ldr	r2, [pc, #72]	; (800d9ac <initStyles+0x254>)
 800d964:	625a      	str	r2, [r3, #36]	; 0x24
	textMsgStl.text.color = lv_color_hex3(0xFFF);
 800d966:	4c1f      	ldr	r4, [pc, #124]	; (800d9e4 <initStyles+0x28c>)
 800d968:	f640 70ff 	movw	r0, #4095	; 0xfff
 800d96c:	f7ff fea8 	bl	800d6c0 <lv_color_hex3>
 800d970:	8420      	strh	r0, [r4, #32]
}
 800d972:	bf00      	nop
 800d974:	bd98      	pop	{r3, r4, r7, pc}
 800d976:	bf00      	nop
 800d978:	24063444 	.word	0x24063444
 800d97c:	24061ea8 	.word	0x24061ea8
 800d980:	2400018c 	.word	0x2400018c
 800d984:	240634f8 	.word	0x240634f8
 800d988:	24061ee4 	.word	0x24061ee4
 800d98c:	24061f20 	.word	0x24061f20
 800d990:	24000160 	.word	0x24000160
 800d994:	24061f5c 	.word	0x24061f5c
 800d998:	24000108 	.word	0x24000108
 800d99c:	24061f98 	.word	0x24061f98
 800d9a0:	24061fd4 	.word	0x24061fd4
 800d9a4:	24062010 	.word	0x24062010
 800d9a8:	2406204c 	.word	0x2406204c
 800d9ac:	240000dc 	.word	0x240000dc
 800d9b0:	24062088 	.word	0x24062088
 800d9b4:	24000134 	.word	0x24000134
 800d9b8:	240620c4 	.word	0x240620c4
 800d9bc:	24000028 	.word	0x24000028
 800d9c0:	24062100 	.word	0x24062100
 800d9c4:	2406213c 	.word	0x2406213c
 800d9c8:	24000054 	.word	0x24000054
 800d9cc:	24062178 	.word	0x24062178
 800d9d0:	24000080 	.word	0x24000080
 800d9d4:	240621b4 	.word	0x240621b4
 800d9d8:	240621f0 	.word	0x240621f0
 800d9dc:	2406222c 	.word	0x2406222c
 800d9e0:	24062268 	.word	0x24062268
 800d9e4:	240622a4 	.word	0x240622a4

0800d9e8 <createObjects>:

static lv_obj_t* textBgImg = NULL;
static lv_obj_t* textMsgLabel = NULL;
static lv_obj_t* textNotifImg = NULL;

static void createObjects(){
 800d9e8:	b580      	push	{r7, lr}
 800d9ea:	af00      	add	r7, sp, #0
	lv_obj_set_style(lv_scr_act(), &screenStl);
 800d9ec:	f7ff fe9a 	bl	800d724 <lv_scr_act>
 800d9f0:	4603      	mov	r3, r0
 800d9f2:	49b7      	ldr	r1, [pc, #732]	; (800dcd0 <createObjects+0x2e8>)
 800d9f4:	4618      	mov	r0, r3
 800d9f6:	f006 f810 	bl	8013a1a <lv_obj_set_style>

	// Main Screen
	backgroundImg = lv_img_create(lv_scr_act(), NULL);
 800d9fa:	f7ff fe93 	bl	800d724 <lv_scr_act>
 800d9fe:	4603      	mov	r3, r0
 800da00:	2100      	movs	r1, #0
 800da02:	4618      	mov	r0, r3
 800da04:	f011 fd78 	bl	801f4f8 <lv_img_create>
 800da08:	4603      	mov	r3, r0
 800da0a:	4ab2      	ldr	r2, [pc, #712]	; (800dcd4 <createObjects+0x2ec>)
 800da0c:	6013      	str	r3, [r2, #0]
	lv_img_set_src(backgroundImg, &DISP_main_bg);
 800da0e:	4bb1      	ldr	r3, [pc, #708]	; (800dcd4 <createObjects+0x2ec>)
 800da10:	681b      	ldr	r3, [r3, #0]
 800da12:	49b1      	ldr	r1, [pc, #708]	; (800dcd8 <createObjects+0x2f0>)
 800da14:	4618      	mov	r0, r3
 800da16:	f011 fe0d 	bl	801f634 <lv_img_set_src>
	lv_obj_set_pos(backgroundImg, 0, 0);
 800da1a:	4bae      	ldr	r3, [pc, #696]	; (800dcd4 <createObjects+0x2ec>)
 800da1c:	681b      	ldr	r3, [r3, #0]
 800da1e:	2200      	movs	r2, #0
 800da20:	2100      	movs	r1, #0
 800da22:	4618      	mov	r0, r3
 800da24:	f005 f9db 	bl	8012dde <lv_obj_set_pos>

	bigSpeedLabel = lv_label_create(backgroundImg, NULL);
 800da28:	4baa      	ldr	r3, [pc, #680]	; (800dcd4 <createObjects+0x2ec>)
 800da2a:	681b      	ldr	r3, [r3, #0]
 800da2c:	2100      	movs	r1, #0
 800da2e:	4618      	mov	r0, r3
 800da30:	f012 f8fa 	bl	801fc28 <lv_label_create>
 800da34:	4603      	mov	r3, r0
 800da36:	4aa9      	ldr	r2, [pc, #676]	; (800dcdc <createObjects+0x2f4>)
 800da38:	6013      	str	r3, [r2, #0]
	lv_label_set_text(bigSpeedLabel, "  0");
 800da3a:	4ba8      	ldr	r3, [pc, #672]	; (800dcdc <createObjects+0x2f4>)
 800da3c:	681b      	ldr	r3, [r3, #0]
 800da3e:	49a8      	ldr	r1, [pc, #672]	; (800dce0 <createObjects+0x2f8>)
 800da40:	4618      	mov	r0, r3
 800da42:	f012 fa23 	bl	801fe8c <lv_label_set_text>
	lv_label_set_style(bigSpeedLabel, LV_LABEL_STYLE_MAIN, &bigNumStl);
 800da46:	4ba5      	ldr	r3, [pc, #660]	; (800dcdc <createObjects+0x2f4>)
 800da48:	681b      	ldr	r3, [r3, #0]
 800da4a:	4aa6      	ldr	r2, [pc, #664]	; (800dce4 <createObjects+0x2fc>)
 800da4c:	2100      	movs	r1, #0
 800da4e:	4618      	mov	r0, r3
 800da50:	f7ff fe73 	bl	800d73a <lv_label_set_style>
	lv_label_set_align(bigSpeedLabel, LV_LABEL_ALIGN_LEFT);
 800da54:	4ba1      	ldr	r3, [pc, #644]	; (800dcdc <createObjects+0x2f4>)
 800da56:	681b      	ldr	r3, [r3, #0]
 800da58:	2100      	movs	r1, #0
 800da5a:	4618      	mov	r0, r3
 800da5c:	f012 fb0e 	bl	802007c <lv_label_set_align>
	lv_obj_set_pos(bigSpeedLabel, -4, 6);
 800da60:	4b9e      	ldr	r3, [pc, #632]	; (800dcdc <createObjects+0x2f4>)
 800da62:	681b      	ldr	r3, [r3, #0]
 800da64:	2206      	movs	r2, #6
 800da66:	f06f 0103 	mvn.w	r1, #3
 800da6a:	4618      	mov	r0, r3
 800da6c:	f005 f9b7 	bl	8012dde <lv_obj_set_pos>

	bigUnitLabel = lv_label_create(backgroundImg, NULL);
 800da70:	4b98      	ldr	r3, [pc, #608]	; (800dcd4 <createObjects+0x2ec>)
 800da72:	681b      	ldr	r3, [r3, #0]
 800da74:	2100      	movs	r1, #0
 800da76:	4618      	mov	r0, r3
 800da78:	f012 f8d6 	bl	801fc28 <lv_label_create>
 800da7c:	4603      	mov	r3, r0
 800da7e:	4a9a      	ldr	r2, [pc, #616]	; (800dce8 <createObjects+0x300>)
 800da80:	6013      	str	r3, [r2, #0]
	lv_label_set_text(bigUnitLabel, "kmph");
 800da82:	4b99      	ldr	r3, [pc, #612]	; (800dce8 <createObjects+0x300>)
 800da84:	681b      	ldr	r3, [r3, #0]
 800da86:	4999      	ldr	r1, [pc, #612]	; (800dcec <createObjects+0x304>)
 800da88:	4618      	mov	r0, r3
 800da8a:	f012 f9ff 	bl	801fe8c <lv_label_set_text>
	lv_label_set_style(bigUnitLabel, LV_LABEL_STYLE_MAIN, &bigUnitStl);
 800da8e:	4b96      	ldr	r3, [pc, #600]	; (800dce8 <createObjects+0x300>)
 800da90:	681b      	ldr	r3, [r3, #0]
 800da92:	4a97      	ldr	r2, [pc, #604]	; (800dcf0 <createObjects+0x308>)
 800da94:	2100      	movs	r1, #0
 800da96:	4618      	mov	r0, r3
 800da98:	f7ff fe4f 	bl	800d73a <lv_label_set_style>
	lv_label_set_align(bigUnitLabel, LV_LABEL_ALIGN_LEFT);
 800da9c:	4b92      	ldr	r3, [pc, #584]	; (800dce8 <createObjects+0x300>)
 800da9e:	681b      	ldr	r3, [r3, #0]
 800daa0:	2100      	movs	r1, #0
 800daa2:	4618      	mov	r0, r3
 800daa4:	f012 faea 	bl	802007c <lv_label_set_align>
	lv_obj_set_pos(bigUnitLabel, 54, 22);
 800daa8:	4b8f      	ldr	r3, [pc, #572]	; (800dce8 <createObjects+0x300>)
 800daaa:	681b      	ldr	r3, [r3, #0]
 800daac:	2216      	movs	r2, #22
 800daae:	2136      	movs	r1, #54	; 0x36
 800dab0:	4618      	mov	r0, r3
 800dab2:	f005 f994 	bl	8012dde <lv_obj_set_pos>

	targetSpeedLabel = lv_label_create(backgroundImg, NULL);
 800dab6:	4b87      	ldr	r3, [pc, #540]	; (800dcd4 <createObjects+0x2ec>)
 800dab8:	681b      	ldr	r3, [r3, #0]
 800daba:	2100      	movs	r1, #0
 800dabc:	4618      	mov	r0, r3
 800dabe:	f012 f8b3 	bl	801fc28 <lv_label_create>
 800dac2:	4603      	mov	r3, r0
 800dac4:	4a8b      	ldr	r2, [pc, #556]	; (800dcf4 <createObjects+0x30c>)
 800dac6:	6013      	str	r3, [r2, #0]
	lv_label_set_text(targetSpeedLabel, "000");
 800dac8:	4b8a      	ldr	r3, [pc, #552]	; (800dcf4 <createObjects+0x30c>)
 800daca:	681b      	ldr	r3, [r3, #0]
 800dacc:	498a      	ldr	r1, [pc, #552]	; (800dcf8 <createObjects+0x310>)
 800dace:	4618      	mov	r0, r3
 800dad0:	f012 f9dc 	bl	801fe8c <lv_label_set_text>
	lv_label_set_style(targetSpeedLabel, LV_LABEL_STYLE_MAIN, &targetSpeedStl);
 800dad4:	4b87      	ldr	r3, [pc, #540]	; (800dcf4 <createObjects+0x30c>)
 800dad6:	681b      	ldr	r3, [r3, #0]
 800dad8:	4a88      	ldr	r2, [pc, #544]	; (800dcfc <createObjects+0x314>)
 800dada:	2100      	movs	r1, #0
 800dadc:	4618      	mov	r0, r3
 800dade:	f7ff fe2c 	bl	800d73a <lv_label_set_style>
	lv_label_set_align(targetSpeedLabel, LV_LABEL_ALIGN_LEFT);
 800dae2:	4b84      	ldr	r3, [pc, #528]	; (800dcf4 <createObjects+0x30c>)
 800dae4:	681b      	ldr	r3, [r3, #0]
 800dae6:	2100      	movs	r1, #0
 800dae8:	4618      	mov	r0, r3
 800daea:	f012 fac7 	bl	802007c <lv_label_set_align>
	lv_obj_set_pos(targetSpeedLabel, 73, -3);
 800daee:	4b81      	ldr	r3, [pc, #516]	; (800dcf4 <createObjects+0x30c>)
 800daf0:	681b      	ldr	r3, [r3, #0]
 800daf2:	f06f 0202 	mvn.w	r2, #2
 800daf6:	2149      	movs	r1, #73	; 0x49
 800daf8:	4618      	mov	r0, r3
 800dafa:	f005 f970 	bl	8012dde <lv_obj_set_pos>

	battPwrLabel = lv_label_create(backgroundImg, NULL);
 800dafe:	4b75      	ldr	r3, [pc, #468]	; (800dcd4 <createObjects+0x2ec>)
 800db00:	681b      	ldr	r3, [r3, #0]
 800db02:	2100      	movs	r1, #0
 800db04:	4618      	mov	r0, r3
 800db06:	f012 f88f 	bl	801fc28 <lv_label_create>
 800db0a:	4603      	mov	r3, r0
 800db0c:	4a7c      	ldr	r2, [pc, #496]	; (800dd00 <createObjects+0x318>)
 800db0e:	6013      	str	r3, [r2, #0]
	lv_label_set_text(battPwrLabel, " 0.00#999999 V, +# 0.00#999999 A, -#    0#999999 W OUT");
 800db10:	4b7b      	ldr	r3, [pc, #492]	; (800dd00 <createObjects+0x318>)
 800db12:	681b      	ldr	r3, [r3, #0]
 800db14:	497b      	ldr	r1, [pc, #492]	; (800dd04 <createObjects+0x31c>)
 800db16:	4618      	mov	r0, r3
 800db18:	f012 f9b8 	bl	801fe8c <lv_label_set_text>
	lv_label_set_recolor(battPwrLabel, true);
 800db1c:	4b78      	ldr	r3, [pc, #480]	; (800dd00 <createObjects+0x318>)
 800db1e:	681b      	ldr	r3, [r3, #0]
 800db20:	2101      	movs	r1, #1
 800db22:	4618      	mov	r0, r3
 800db24:	f012 face 	bl	80200c4 <lv_label_set_recolor>
	lv_label_set_style(battPwrLabel, LV_LABEL_STYLE_MAIN, &pwrTxtStl);
 800db28:	4b75      	ldr	r3, [pc, #468]	; (800dd00 <createObjects+0x318>)
 800db2a:	681b      	ldr	r3, [r3, #0]
 800db2c:	4a76      	ldr	r2, [pc, #472]	; (800dd08 <createObjects+0x320>)
 800db2e:	2100      	movs	r1, #0
 800db30:	4618      	mov	r0, r3
 800db32:	f7ff fe02 	bl	800d73a <lv_label_set_style>
	lv_label_set_align(battPwrLabel, LV_LABEL_ALIGN_LEFT);
 800db36:	4b72      	ldr	r3, [pc, #456]	; (800dd00 <createObjects+0x318>)
 800db38:	681b      	ldr	r3, [r3, #0]
 800db3a:	2100      	movs	r1, #0
 800db3c:	4618      	mov	r0, r3
 800db3e:	f012 fa9d 	bl	802007c <lv_label_set_align>
	lv_obj_set_pos(battPwrLabel, 37, 40);
 800db42:	4b6f      	ldr	r3, [pc, #444]	; (800dd00 <createObjects+0x318>)
 800db44:	681b      	ldr	r3, [r3, #0]
 800db46:	2228      	movs	r2, #40	; 0x28
 800db48:	2125      	movs	r1, #37	; 0x25
 800db4a:	4618      	mov	r0, r3
 800db4c:	f005 f947 	bl	8012dde <lv_obj_set_pos>

	arrayPwrLabel = lv_label_create(backgroundImg, NULL);
 800db50:	4b60      	ldr	r3, [pc, #384]	; (800dcd4 <createObjects+0x2ec>)
 800db52:	681b      	ldr	r3, [r3, #0]
 800db54:	2100      	movs	r1, #0
 800db56:	4618      	mov	r0, r3
 800db58:	f012 f866 	bl	801fc28 <lv_label_create>
 800db5c:	4603      	mov	r3, r0
 800db5e:	4a6b      	ldr	r2, [pc, #428]	; (800dd0c <createObjects+0x324>)
 800db60:	6013      	str	r3, [r2, #0]
	lv_label_set_text(arrayPwrLabel, " 0.00#999999 V, +# 0.00#999999 A, +#    0#999999 W OUT");
 800db62:	4b6a      	ldr	r3, [pc, #424]	; (800dd0c <createObjects+0x324>)
 800db64:	681b      	ldr	r3, [r3, #0]
 800db66:	496a      	ldr	r1, [pc, #424]	; (800dd10 <createObjects+0x328>)
 800db68:	4618      	mov	r0, r3
 800db6a:	f012 f98f 	bl	801fe8c <lv_label_set_text>
	lv_label_set_recolor(arrayPwrLabel, true);
 800db6e:	4b67      	ldr	r3, [pc, #412]	; (800dd0c <createObjects+0x324>)
 800db70:	681b      	ldr	r3, [r3, #0]
 800db72:	2101      	movs	r1, #1
 800db74:	4618      	mov	r0, r3
 800db76:	f012 faa5 	bl	80200c4 <lv_label_set_recolor>
	lv_label_set_style(arrayPwrLabel, LV_LABEL_STYLE_MAIN, &pwrTxtStl);
 800db7a:	4b64      	ldr	r3, [pc, #400]	; (800dd0c <createObjects+0x324>)
 800db7c:	681b      	ldr	r3, [r3, #0]
 800db7e:	4a62      	ldr	r2, [pc, #392]	; (800dd08 <createObjects+0x320>)
 800db80:	2100      	movs	r1, #0
 800db82:	4618      	mov	r0, r3
 800db84:	f7ff fdd9 	bl	800d73a <lv_label_set_style>
	lv_label_set_align(arrayPwrLabel, LV_LABEL_ALIGN_LEFT);
 800db88:	4b60      	ldr	r3, [pc, #384]	; (800dd0c <createObjects+0x324>)
 800db8a:	681b      	ldr	r3, [r3, #0]
 800db8c:	2100      	movs	r1, #0
 800db8e:	4618      	mov	r0, r3
 800db90:	f012 fa74 	bl	802007c <lv_label_set_align>
	lv_obj_set_pos(arrayPwrLabel, 37, 51);
 800db94:	4b5d      	ldr	r3, [pc, #372]	; (800dd0c <createObjects+0x324>)
 800db96:	681b      	ldr	r3, [r3, #0]
 800db98:	2233      	movs	r2, #51	; 0x33
 800db9a:	2125      	movs	r1, #37	; 0x25
 800db9c:	4618      	mov	r0, r3
 800db9e:	f005 f91e 	bl	8012dde <lv_obj_set_pos>

	bmsAlertMessageLabel = lv_label_create(backgroundImg, NULL);
 800dba2:	4b4c      	ldr	r3, [pc, #304]	; (800dcd4 <createObjects+0x2ec>)
 800dba4:	681b      	ldr	r3, [r3, #0]
 800dba6:	2100      	movs	r1, #0
 800dba8:	4618      	mov	r0, r3
 800dbaa:	f012 f83d 	bl	801fc28 <lv_label_create>
 800dbae:	4603      	mov	r3, r0
 800dbb0:	4a58      	ldr	r2, [pc, #352]	; (800dd14 <createObjects+0x32c>)
 800dbb2:	6013      	str	r3, [r2, #0]
	lv_label_set_text(bmsAlertMessageLabel, BMS_ALERT_MSG_RESET);
 800dbb4:	4b57      	ldr	r3, [pc, #348]	; (800dd14 <createObjects+0x32c>)
 800dbb6:	681b      	ldr	r3, [r3, #0]
 800dbb8:	4a57      	ldr	r2, [pc, #348]	; (800dd18 <createObjects+0x330>)
 800dbba:	6812      	ldr	r2, [r2, #0]
 800dbbc:	4611      	mov	r1, r2
 800dbbe:	4618      	mov	r0, r3
 800dbc0:	f012 f964 	bl	801fe8c <lv_label_set_text>
	lv_label_set_style(bmsAlertMessageLabel, LV_LABEL_STYLE_MAIN, &smlTxtStl);
 800dbc4:	4b53      	ldr	r3, [pc, #332]	; (800dd14 <createObjects+0x32c>)
 800dbc6:	681b      	ldr	r3, [r3, #0]
 800dbc8:	4a54      	ldr	r2, [pc, #336]	; (800dd1c <createObjects+0x334>)
 800dbca:	2100      	movs	r1, #0
 800dbcc:	4618      	mov	r0, r3
 800dbce:	f7ff fdb4 	bl	800d73a <lv_label_set_style>
	lv_label_set_align(bmsAlertMessageLabel, LV_LABEL_ALIGN_LEFT);
 800dbd2:	4b50      	ldr	r3, [pc, #320]	; (800dd14 <createObjects+0x32c>)
 800dbd4:	681b      	ldr	r3, [r3, #0]
 800dbd6:	2100      	movs	r1, #0
 800dbd8:	4618      	mov	r0, r3
 800dbda:	f012 fa4f 	bl	802007c <lv_label_set_align>
	lv_label_set_long_mode(bmsAlertMessageLabel, LV_LABEL_LONG_SROLL_CIRC);
 800dbde:	4b4d      	ldr	r3, [pc, #308]	; (800dd14 <createObjects+0x32c>)
 800dbe0:	681b      	ldr	r3, [r3, #0]
 800dbe2:	2104      	movs	r1, #4
 800dbe4:	4618      	mov	r0, r3
 800dbe6:	f012 f9ed 	bl	801ffc4 <lv_label_set_long_mode>
	lv_obj_set_pos(bmsAlertMessageLabel, 133, 30);
 800dbea:	4b4a      	ldr	r3, [pc, #296]	; (800dd14 <createObjects+0x32c>)
 800dbec:	681b      	ldr	r3, [r3, #0]
 800dbee:	221e      	movs	r2, #30
 800dbf0:	2185      	movs	r1, #133	; 0x85
 800dbf2:	4618      	mov	r0, r3
 800dbf4:	f005 f8f3 	bl	8012dde <lv_obj_set_pos>
	lv_obj_set_width(bmsAlertMessageLabel, 122);
 800dbf8:	4b46      	ldr	r3, [pc, #280]	; (800dd14 <createObjects+0x32c>)
 800dbfa:	681b      	ldr	r3, [r3, #0]
 800dbfc:	217a      	movs	r1, #122	; 0x7a
 800dbfe:	4618      	mov	r0, r3
 800dc00:	f005 fa1b 	bl	801303a <lv_obj_set_width>

	gearTxtLabel = lv_label_create(backgroundImg, NULL);
 800dc04:	4b33      	ldr	r3, [pc, #204]	; (800dcd4 <createObjects+0x2ec>)
 800dc06:	681b      	ldr	r3, [r3, #0]
 800dc08:	2100      	movs	r1, #0
 800dc0a:	4618      	mov	r0, r3
 800dc0c:	f012 f80c 	bl	801fc28 <lv_label_create>
 800dc10:	4603      	mov	r3, r0
 800dc12:	4a43      	ldr	r2, [pc, #268]	; (800dd20 <createObjects+0x338>)
 800dc14:	6013      	str	r3, [r2, #0]
	lv_label_set_text(gearTxtLabel, "P");
 800dc16:	4b42      	ldr	r3, [pc, #264]	; (800dd20 <createObjects+0x338>)
 800dc18:	681b      	ldr	r3, [r3, #0]
 800dc1a:	4942      	ldr	r1, [pc, #264]	; (800dd24 <createObjects+0x33c>)
 800dc1c:	4618      	mov	r0, r3
 800dc1e:	f012 f935 	bl	801fe8c <lv_label_set_text>
	lv_label_set_style(gearTxtLabel, LV_LABEL_STYLE_MAIN, &gearTxtStl);
 800dc22:	4b3f      	ldr	r3, [pc, #252]	; (800dd20 <createObjects+0x338>)
 800dc24:	681b      	ldr	r3, [r3, #0]
 800dc26:	4a40      	ldr	r2, [pc, #256]	; (800dd28 <createObjects+0x340>)
 800dc28:	2100      	movs	r1, #0
 800dc2a:	4618      	mov	r0, r3
 800dc2c:	f7ff fd85 	bl	800d73a <lv_label_set_style>
	lv_label_set_align(gearTxtLabel, LV_LABEL_ALIGN_LEFT);
 800dc30:	4b3b      	ldr	r3, [pc, #236]	; (800dd20 <createObjects+0x338>)
 800dc32:	681b      	ldr	r3, [r3, #0]
 800dc34:	2100      	movs	r1, #0
 800dc36:	4618      	mov	r0, r3
 800dc38:	f012 fa20 	bl	802007c <lv_label_set_align>
	lv_obj_set_pos(gearTxtLabel, 132, 0);
 800dc3c:	4b38      	ldr	r3, [pc, #224]	; (800dd20 <createObjects+0x338>)
 800dc3e:	681b      	ldr	r3, [r3, #0]
 800dc40:	2200      	movs	r2, #0
 800dc42:	2184      	movs	r1, #132	; 0x84
 800dc44:	4618      	mov	r0, r3
 800dc46:	f005 f8ca 	bl	8012dde <lv_obj_set_pos>

	mainVfmLabel = lv_label_create(backgroundImg, NULL);
 800dc4a:	4b22      	ldr	r3, [pc, #136]	; (800dcd4 <createObjects+0x2ec>)
 800dc4c:	681b      	ldr	r3, [r3, #0]
 800dc4e:	2100      	movs	r1, #0
 800dc50:	4618      	mov	r0, r3
 800dc52:	f011 ffe9 	bl	801fc28 <lv_label_create>
 800dc56:	4603      	mov	r3, r0
 800dc58:	4a34      	ldr	r2, [pc, #208]	; (800dd2c <createObjects+0x344>)
 800dc5a:	6013      	str	r3, [r2, #0]
	lv_label_set_text(mainVfmLabel, "01");
 800dc5c:	4b33      	ldr	r3, [pc, #204]	; (800dd2c <createObjects+0x344>)
 800dc5e:	681b      	ldr	r3, [r3, #0]
 800dc60:	4933      	ldr	r1, [pc, #204]	; (800dd30 <createObjects+0x348>)
 800dc62:	4618      	mov	r0, r3
 800dc64:	f012 f912 	bl	801fe8c <lv_label_set_text>
	lv_label_set_style(mainVfmLabel, LV_LABEL_STYLE_MAIN, &mainVfmStl);
 800dc68:	4b30      	ldr	r3, [pc, #192]	; (800dd2c <createObjects+0x344>)
 800dc6a:	681b      	ldr	r3, [r3, #0]
 800dc6c:	4a31      	ldr	r2, [pc, #196]	; (800dd34 <createObjects+0x34c>)
 800dc6e:	2100      	movs	r1, #0
 800dc70:	4618      	mov	r0, r3
 800dc72:	f7ff fd62 	bl	800d73a <lv_label_set_style>
	lv_label_set_align(mainVfmLabel, LV_LABEL_ALIGN_LEFT);
 800dc76:	4b2d      	ldr	r3, [pc, #180]	; (800dd2c <createObjects+0x344>)
 800dc78:	681b      	ldr	r3, [r3, #0]
 800dc7a:	2100      	movs	r1, #0
 800dc7c:	4618      	mov	r0, r3
 800dc7e:	f012 f9fd 	bl	802007c <lv_label_set_align>
	lv_obj_set_pos(mainVfmLabel, 220, 9);
 800dc82:	4b2a      	ldr	r3, [pc, #168]	; (800dd2c <createObjects+0x344>)
 800dc84:	681b      	ldr	r3, [r3, #0]
 800dc86:	2209      	movs	r2, #9
 800dc88:	21dc      	movs	r1, #220	; 0xdc
 800dc8a:	4618      	mov	r0, r3
 800dc8c:	f005 f8a7 	bl	8012dde <lv_obj_set_pos>

	leftArrowImg = lv_img_create(backgroundImg, NULL);
 800dc90:	4b10      	ldr	r3, [pc, #64]	; (800dcd4 <createObjects+0x2ec>)
 800dc92:	681b      	ldr	r3, [r3, #0]
 800dc94:	2100      	movs	r1, #0
 800dc96:	4618      	mov	r0, r3
 800dc98:	f011 fc2e 	bl	801f4f8 <lv_img_create>
 800dc9c:	4603      	mov	r3, r0
 800dc9e:	4a26      	ldr	r2, [pc, #152]	; (800dd38 <createObjects+0x350>)
 800dca0:	6013      	str	r3, [r2, #0]
	lv_img_set_src(leftArrowImg, &DISP_left_arrow);
 800dca2:	4b25      	ldr	r3, [pc, #148]	; (800dd38 <createObjects+0x350>)
 800dca4:	681b      	ldr	r3, [r3, #0]
 800dca6:	4925      	ldr	r1, [pc, #148]	; (800dd3c <createObjects+0x354>)
 800dca8:	4618      	mov	r0, r3
 800dcaa:	f011 fcc3 	bl	801f634 <lv_img_set_src>
	lv_obj_set_pos(leftArrowImg, 149, 6);
 800dcae:	4b22      	ldr	r3, [pc, #136]	; (800dd38 <createObjects+0x350>)
 800dcb0:	681b      	ldr	r3, [r3, #0]
 800dcb2:	2206      	movs	r2, #6
 800dcb4:	2195      	movs	r1, #149	; 0x95
 800dcb6:	4618      	mov	r0, r3
 800dcb8:	f005 f891 	bl	8012dde <lv_obj_set_pos>
	lv_obj_set_hidden(leftArrowImg, 1);
 800dcbc:	4b1e      	ldr	r3, [pc, #120]	; (800dd38 <createObjects+0x350>)
 800dcbe:	681b      	ldr	r3, [r3, #0]
 800dcc0:	2101      	movs	r1, #1
 800dcc2:	4618      	mov	r0, r3
 800dcc4:	f005 fecf 	bl	8013a66 <lv_obj_set_hidden>

	rightArrowImg = lv_img_create(backgroundImg, NULL);
 800dcc8:	4b02      	ldr	r3, [pc, #8]	; (800dcd4 <createObjects+0x2ec>)
 800dcca:	681b      	ldr	r3, [r3, #0]
 800dccc:	2100      	movs	r1, #0
 800dcce:	e037      	b.n	800dd40 <createObjects+0x358>
 800dcd0:	24061ea8 	.word	0x24061ea8
 800dcd4:	240622e0 	.word	0x240622e0
 800dcd8:	0802f7e4 	.word	0x0802f7e4
 800dcdc:	240622e4 	.word	0x240622e4
 800dce0:	08022738 	.word	0x08022738
 800dce4:	24061f20 	.word	0x24061f20
 800dce8:	240622e8 	.word	0x240622e8
 800dcec:	0802273c 	.word	0x0802273c
 800dcf0:	24061f98 	.word	0x24061f98
 800dcf4:	240622ec 	.word	0x240622ec
 800dcf8:	08022744 	.word	0x08022744
 800dcfc:	24061f5c 	.word	0x24061f5c
 800dd00:	240622f0 	.word	0x240622f0
 800dd04:	08022748 	.word	0x08022748
 800dd08:	2406204c 	.word	0x2406204c
 800dd0c:	240622f4 	.word	0x240622f4
 800dd10:	08022784 	.word	0x08022784
 800dd14:	240622f8 	.word	0x240622f8
 800dd18:	2400019c 	.word	0x2400019c
 800dd1c:	24062010 	.word	0x24062010
 800dd20:	24062300 	.word	0x24062300
 800dd24:	080227c0 	.word	0x080227c0
 800dd28:	24062088 	.word	0x24062088
 800dd2c:	24062304 	.word	0x24062304
 800dd30:	080227c4 	.word	0x080227c4
 800dd34:	240620c4 	.word	0x240620c4
 800dd38:	24062310 	.word	0x24062310
 800dd3c:	24000090 	.word	0x24000090
 800dd40:	4618      	mov	r0, r3
 800dd42:	f011 fbd9 	bl	801f4f8 <lv_img_create>
 800dd46:	4603      	mov	r3, r0
 800dd48:	4ab6      	ldr	r2, [pc, #728]	; (800e024 <createObjects+0x63c>)
 800dd4a:	6013      	str	r3, [r2, #0]
	lv_img_set_src(rightArrowImg, &DISP_right_arrow);
 800dd4c:	4bb5      	ldr	r3, [pc, #724]	; (800e024 <createObjects+0x63c>)
 800dd4e:	681b      	ldr	r3, [r3, #0]
 800dd50:	49b5      	ldr	r1, [pc, #724]	; (800e028 <createObjects+0x640>)
 800dd52:	4618      	mov	r0, r3
 800dd54:	f011 fc6e 	bl	801f634 <lv_img_set_src>
	lv_obj_set_pos(rightArrowImg, 191, 6);
 800dd58:	4bb2      	ldr	r3, [pc, #712]	; (800e024 <createObjects+0x63c>)
 800dd5a:	681b      	ldr	r3, [r3, #0]
 800dd5c:	2206      	movs	r2, #6
 800dd5e:	21bf      	movs	r1, #191	; 0xbf
 800dd60:	4618      	mov	r0, r3
 800dd62:	f005 f83c 	bl	8012dde <lv_obj_set_pos>
	lv_obj_set_hidden(rightArrowImg, 1);
 800dd66:	4baf      	ldr	r3, [pc, #700]	; (800e024 <createObjects+0x63c>)
 800dd68:	681b      	ldr	r3, [r3, #0]
 800dd6a:	2101      	movs	r1, #1
 800dd6c:	4618      	mov	r0, r3
 800dd6e:	f005 fe7a 	bl	8013a66 <lv_obj_set_hidden>

	stopSignImg = lv_img_create(backgroundImg, NULL);
 800dd72:	4bae      	ldr	r3, [pc, #696]	; (800e02c <createObjects+0x644>)
 800dd74:	681b      	ldr	r3, [r3, #0]
 800dd76:	2100      	movs	r1, #0
 800dd78:	4618      	mov	r0, r3
 800dd7a:	f011 fbbd 	bl	801f4f8 <lv_img_create>
 800dd7e:	4603      	mov	r3, r0
 800dd80:	4aab      	ldr	r2, [pc, #684]	; (800e030 <createObjects+0x648>)
 800dd82:	6013      	str	r3, [r2, #0]
	lv_img_set_src(stopSignImg, &DISP_stop_sign);
 800dd84:	4baa      	ldr	r3, [pc, #680]	; (800e030 <createObjects+0x648>)
 800dd86:	681b      	ldr	r3, [r3, #0]
 800dd88:	49aa      	ldr	r1, [pc, #680]	; (800e034 <createObjects+0x64c>)
 800dd8a:	4618      	mov	r0, r3
 800dd8c:	f011 fc52 	bl	801f634 <lv_img_set_src>
	lv_obj_set_pos(stopSignImg, 111, 13);
 800dd90:	4ba7      	ldr	r3, [pc, #668]	; (800e030 <createObjects+0x648>)
 800dd92:	681b      	ldr	r3, [r3, #0]
 800dd94:	220d      	movs	r2, #13
 800dd96:	216f      	movs	r1, #111	; 0x6f
 800dd98:	4618      	mov	r0, r3
 800dd9a:	f005 f820 	bl	8012dde <lv_obj_set_pos>
	lv_obj_set_hidden(stopSignImg, 1);
 800dd9e:	4ba4      	ldr	r3, [pc, #656]	; (800e030 <createObjects+0x648>)
 800dda0:	681b      	ldr	r3, [r3, #0]
 800dda2:	2101      	movs	r1, #1
 800dda4:	4618      	mov	r0, r3
 800dda6:	f005 fe5e 	bl	8013a66 <lv_obj_set_hidden>

	triangleSignImg = lv_img_create(backgroundImg, NULL);
 800ddaa:	4ba0      	ldr	r3, [pc, #640]	; (800e02c <createObjects+0x644>)
 800ddac:	681b      	ldr	r3, [r3, #0]
 800ddae:	2100      	movs	r1, #0
 800ddb0:	4618      	mov	r0, r3
 800ddb2:	f011 fba1 	bl	801f4f8 <lv_img_create>
 800ddb6:	4603      	mov	r3, r0
 800ddb8:	4a9f      	ldr	r2, [pc, #636]	; (800e038 <createObjects+0x650>)
 800ddba:	6013      	str	r3, [r2, #0]
	lv_img_set_src(triangleSignImg, &DISP_triangle_sign);
 800ddbc:	4b9e      	ldr	r3, [pc, #632]	; (800e038 <createObjects+0x650>)
 800ddbe:	681b      	ldr	r3, [r3, #0]
 800ddc0:	499e      	ldr	r1, [pc, #632]	; (800e03c <createObjects+0x654>)
 800ddc2:	4618      	mov	r0, r3
 800ddc4:	f011 fc36 	bl	801f634 <lv_img_set_src>
	lv_obj_set_pos(triangleSignImg, 171, 6);
 800ddc8:	4b9b      	ldr	r3, [pc, #620]	; (800e038 <createObjects+0x650>)
 800ddca:	681b      	ldr	r3, [r3, #0]
 800ddcc:	2206      	movs	r2, #6
 800ddce:	21ab      	movs	r1, #171	; 0xab
 800ddd0:	4618      	mov	r0, r3
 800ddd2:	f005 f804 	bl	8012dde <lv_obj_set_pos>
	lv_obj_set_hidden(triangleSignImg, 1);
 800ddd6:	4b98      	ldr	r3, [pc, #608]	; (800e038 <createObjects+0x650>)
 800ddd8:	681b      	ldr	r3, [r3, #0]
 800ddda:	2101      	movs	r1, #1
 800dddc:	4618      	mov	r0, r3
 800ddde:	f005 fe42 	bl	8013a66 <lv_obj_set_hidden>

	accPositionObj = lv_obj_create(backgroundImg, NULL);
 800dde2:	4b92      	ldr	r3, [pc, #584]	; (800e02c <createObjects+0x644>)
 800dde4:	681b      	ldr	r3, [r3, #0]
 800dde6:	2100      	movs	r1, #0
 800dde8:	4618      	mov	r0, r3
 800ddea:	f004 fcc9 	bl	8012780 <lv_obj_create>
 800ddee:	4603      	mov	r3, r0
 800ddf0:	4a93      	ldr	r2, [pc, #588]	; (800e040 <createObjects+0x658>)
 800ddf2:	6013      	str	r3, [r2, #0]
	lv_obj_set_style(accPositionObj, &barStl);
 800ddf4:	4b92      	ldr	r3, [pc, #584]	; (800e040 <createObjects+0x658>)
 800ddf6:	681b      	ldr	r3, [r3, #0]
 800ddf8:	4992      	ldr	r1, [pc, #584]	; (800e044 <createObjects+0x65c>)
 800ddfa:	4618      	mov	r0, r3
 800ddfc:	f005 fe0d 	bl	8013a1a <lv_obj_set_style>
	lv_obj_set_pos(accPositionObj, 56, 18);
 800de00:	4b8f      	ldr	r3, [pc, #572]	; (800e040 <createObjects+0x658>)
 800de02:	681b      	ldr	r3, [r3, #0]
 800de04:	2212      	movs	r2, #18
 800de06:	2138      	movs	r1, #56	; 0x38
 800de08:	4618      	mov	r0, r3
 800de0a:	f004 ffe8 	bl	8012dde <lv_obj_set_pos>
	lv_obj_set_width(accPositionObj, 0);
 800de0e:	4b8c      	ldr	r3, [pc, #560]	; (800e040 <createObjects+0x658>)
 800de10:	681b      	ldr	r3, [r3, #0]
 800de12:	2100      	movs	r1, #0
 800de14:	4618      	mov	r0, r3
 800de16:	f005 f910 	bl	801303a <lv_obj_set_width>
	lv_obj_set_height(accPositionObj, 2);
 800de1a:	4b89      	ldr	r3, [pc, #548]	; (800e040 <createObjects+0x658>)
 800de1c:	681b      	ldr	r3, [r3, #0]
 800de1e:	2102      	movs	r1, #2
 800de20:	4618      	mov	r0, r3
 800de22:	f005 f91f 	bl	8013064 <lv_obj_set_height>

	motOnLabel = lv_obj_create(backgroundImg, NULL);
 800de26:	4b81      	ldr	r3, [pc, #516]	; (800e02c <createObjects+0x644>)
 800de28:	681b      	ldr	r3, [r3, #0]
 800de2a:	2100      	movs	r1, #0
 800de2c:	4618      	mov	r0, r3
 800de2e:	f004 fca7 	bl	8012780 <lv_obj_create>
 800de32:	4603      	mov	r3, r0
 800de34:	4a84      	ldr	r2, [pc, #528]	; (800e048 <createObjects+0x660>)
 800de36:	6013      	str	r3, [r2, #0]
	lv_obj_set_style(motOnLabel, &motOnStl);
 800de38:	4b83      	ldr	r3, [pc, #524]	; (800e048 <createObjects+0x660>)
 800de3a:	681b      	ldr	r3, [r3, #0]
 800de3c:	4983      	ldr	r1, [pc, #524]	; (800e04c <createObjects+0x664>)
 800de3e:	4618      	mov	r0, r3
 800de40:	f005 fdeb 	bl	8013a1a <lv_obj_set_style>
	lv_obj_set_pos(motOnLabel, 63, 8);
 800de44:	4b80      	ldr	r3, [pc, #512]	; (800e048 <createObjects+0x660>)
 800de46:	681b      	ldr	r3, [r3, #0]
 800de48:	2208      	movs	r2, #8
 800de4a:	213f      	movs	r1, #63	; 0x3f
 800de4c:	4618      	mov	r0, r3
 800de4e:	f004 ffc6 	bl	8012dde <lv_obj_set_pos>
	lv_obj_set_width(motOnLabel, 130);
 800de52:	4b7d      	ldr	r3, [pc, #500]	; (800e048 <createObjects+0x660>)
 800de54:	681b      	ldr	r3, [r3, #0]
 800de56:	2182      	movs	r1, #130	; 0x82
 800de58:	4618      	mov	r0, r3
 800de5a:	f005 f8ee 	bl	801303a <lv_obj_set_width>
	lv_obj_set_height(motOnLabel, 48);
 800de5e:	4b7a      	ldr	r3, [pc, #488]	; (800e048 <createObjects+0x660>)
 800de60:	681b      	ldr	r3, [r3, #0]
 800de62:	2130      	movs	r1, #48	; 0x30
 800de64:	4618      	mov	r0, r3
 800de66:	f005 f8fd 	bl	8013064 <lv_obj_set_height>
	lv_obj_set_hidden(motOnLabel, 1);
 800de6a:	4b77      	ldr	r3, [pc, #476]	; (800e048 <createObjects+0x660>)
 800de6c:	681b      	ldr	r3, [r3, #0]
 800de6e:	2101      	movs	r1, #1
 800de70:	4618      	mov	r0, r3
 800de72:	f005 fdf8 	bl	8013a66 <lv_obj_set_hidden>

	motOnLabelText = lv_label_create(motOnLabel, NULL);
 800de76:	4b74      	ldr	r3, [pc, #464]	; (800e048 <createObjects+0x660>)
 800de78:	681b      	ldr	r3, [r3, #0]
 800de7a:	2100      	movs	r1, #0
 800de7c:	4618      	mov	r0, r3
 800de7e:	f011 fed3 	bl	801fc28 <lv_label_create>
 800de82:	4603      	mov	r3, r0
 800de84:	4a72      	ldr	r2, [pc, #456]	; (800e050 <createObjects+0x668>)
 800de86:	6013      	str	r3, [r2, #0]
	lv_label_set_text(motOnLabelText, "Press SEL to\ntoggle motor");
 800de88:	4b71      	ldr	r3, [pc, #452]	; (800e050 <createObjects+0x668>)
 800de8a:	681b      	ldr	r3, [r3, #0]
 800de8c:	4971      	ldr	r1, [pc, #452]	; (800e054 <createObjects+0x66c>)
 800de8e:	4618      	mov	r0, r3
 800de90:	f011 fffc 	bl	801fe8c <lv_label_set_text>
	lv_label_set_style(motOnLabelText, LV_LABEL_STYLE_MAIN, &motOnStl);
 800de94:	4b6e      	ldr	r3, [pc, #440]	; (800e050 <createObjects+0x668>)
 800de96:	681b      	ldr	r3, [r3, #0]
 800de98:	4a6c      	ldr	r2, [pc, #432]	; (800e04c <createObjects+0x664>)
 800de9a:	2100      	movs	r1, #0
 800de9c:	4618      	mov	r0, r3
 800de9e:	f7ff fc4c 	bl	800d73a <lv_label_set_style>
	lv_obj_set_style(motOnLabelText, &motOnStl);
 800dea2:	4b6b      	ldr	r3, [pc, #428]	; (800e050 <createObjects+0x668>)
 800dea4:	681b      	ldr	r3, [r3, #0]
 800dea6:	4969      	ldr	r1, [pc, #420]	; (800e04c <createObjects+0x664>)
 800dea8:	4618      	mov	r0, r3
 800deaa:	f005 fdb6 	bl	8013a1a <lv_obj_set_style>
	lv_label_set_align(motOnLabelText, LV_LABEL_ALIGN_CENTER);
 800deae:	4b68      	ldr	r3, [pc, #416]	; (800e050 <createObjects+0x668>)
 800deb0:	681b      	ldr	r3, [r3, #0]
 800deb2:	2101      	movs	r1, #1
 800deb4:	4618      	mov	r0, r3
 800deb6:	f012 f8e1 	bl	802007c <lv_label_set_align>
	lv_obj_set_pos(motOnLabelText, 5, 2);
 800deba:	4b65      	ldr	r3, [pc, #404]	; (800e050 <createObjects+0x668>)
 800debc:	681b      	ldr	r3, [r3, #0]
 800debe:	2202      	movs	r2, #2
 800dec0:	2105      	movs	r1, #5
 800dec2:	4618      	mov	r0, r3
 800dec4:	f004 ff8b 	bl	8012dde <lv_obj_set_pos>
	lv_obj_set_width(motOnLabelText, 130);
 800dec8:	4b61      	ldr	r3, [pc, #388]	; (800e050 <createObjects+0x668>)
 800deca:	681b      	ldr	r3, [r3, #0]
 800decc:	2182      	movs	r1, #130	; 0x82
 800dece:	4618      	mov	r0, r3
 800ded0:	f005 f8b3 	bl	801303a <lv_obj_set_width>
	lv_obj_set_height(motOnLabelText, 48);
 800ded4:	4b5e      	ldr	r3, [pc, #376]	; (800e050 <createObjects+0x668>)
 800ded6:	681b      	ldr	r3, [r3, #0]
 800ded8:	2130      	movs	r1, #48	; 0x30
 800deda:	4618      	mov	r0, r3
 800dedc:	f005 f8c2 	bl	8013064 <lv_obj_set_height>

	// Motor Screen
	motBgImg = lv_img_create(lv_scr_act(), NULL);
 800dee0:	f7ff fc20 	bl	800d724 <lv_scr_act>
 800dee4:	4603      	mov	r3, r0
 800dee6:	2100      	movs	r1, #0
 800dee8:	4618      	mov	r0, r3
 800deea:	f011 fb05 	bl	801f4f8 <lv_img_create>
 800deee:	4603      	mov	r3, r0
 800def0:	4a59      	ldr	r2, [pc, #356]	; (800e058 <createObjects+0x670>)
 800def2:	6013      	str	r3, [r2, #0]
	lv_img_set_src(motBgImg, &DISP_mot_bg);
 800def4:	4b58      	ldr	r3, [pc, #352]	; (800e058 <createObjects+0x670>)
 800def6:	681b      	ldr	r3, [r3, #0]
 800def8:	4958      	ldr	r1, [pc, #352]	; (800e05c <createObjects+0x674>)
 800defa:	4618      	mov	r0, r3
 800defc:	f011 fb9a 	bl	801f634 <lv_img_set_src>
	lv_obj_set_pos(motBgImg, 0, 0);
 800df00:	4b55      	ldr	r3, [pc, #340]	; (800e058 <createObjects+0x670>)
 800df02:	681b      	ldr	r3, [r3, #0]
 800df04:	2200      	movs	r2, #0
 800df06:	2100      	movs	r1, #0
 800df08:	4618      	mov	r0, r3
 800df0a:	f004 ff68 	bl	8012dde <lv_obj_set_pos>

	motVfmLabel = lv_label_create(motBgImg, NULL);
 800df0e:	4b52      	ldr	r3, [pc, #328]	; (800e058 <createObjects+0x670>)
 800df10:	681b      	ldr	r3, [r3, #0]
 800df12:	2100      	movs	r1, #0
 800df14:	4618      	mov	r0, r3
 800df16:	f011 fe87 	bl	801fc28 <lv_label_create>
 800df1a:	4603      	mov	r3, r0
 800df1c:	4a50      	ldr	r2, [pc, #320]	; (800e060 <createObjects+0x678>)
 800df1e:	6013      	str	r3, [r2, #0]
	lv_label_set_text(motVfmLabel, "01");
 800df20:	4b4f      	ldr	r3, [pc, #316]	; (800e060 <createObjects+0x678>)
 800df22:	681b      	ldr	r3, [r3, #0]
 800df24:	494f      	ldr	r1, [pc, #316]	; (800e064 <createObjects+0x67c>)
 800df26:	4618      	mov	r0, r3
 800df28:	f011 ffb0 	bl	801fe8c <lv_label_set_text>
	lv_label_set_style(motVfmLabel, LV_LABEL_STYLE_MAIN, &motVfmStl);
 800df2c:	4b4c      	ldr	r3, [pc, #304]	; (800e060 <createObjects+0x678>)
 800df2e:	681b      	ldr	r3, [r3, #0]
 800df30:	4a4d      	ldr	r2, [pc, #308]	; (800e068 <createObjects+0x680>)
 800df32:	2100      	movs	r1, #0
 800df34:	4618      	mov	r0, r3
 800df36:	f7ff fc00 	bl	800d73a <lv_label_set_style>
	lv_label_set_align(motVfmLabel, LV_LABEL_ALIGN_LEFT);
 800df3a:	4b49      	ldr	r3, [pc, #292]	; (800e060 <createObjects+0x678>)
 800df3c:	681b      	ldr	r3, [r3, #0]
 800df3e:	2100      	movs	r1, #0
 800df40:	4618      	mov	r0, r3
 800df42:	f012 f89b 	bl	802007c <lv_label_set_align>
	lv_obj_set_pos(motVfmLabel, -3, 10);
 800df46:	4b46      	ldr	r3, [pc, #280]	; (800e060 <createObjects+0x678>)
 800df48:	681b      	ldr	r3, [r3, #0]
 800df4a:	220a      	movs	r2, #10
 800df4c:	f06f 0102 	mvn.w	r1, #2
 800df50:	4618      	mov	r0, r3
 800df52:	f004 ff44 	bl	8012dde <lv_obj_set_pos>

	motLcdLabel = lv_label_create(motBgImg, NULL);
 800df56:	4b40      	ldr	r3, [pc, #256]	; (800e058 <createObjects+0x670>)
 800df58:	681b      	ldr	r3, [r3, #0]
 800df5a:	2100      	movs	r1, #0
 800df5c:	4618      	mov	r0, r3
 800df5e:	f011 fe63 	bl	801fc28 <lv_label_create>
 800df62:	4603      	mov	r3, r0
 800df64:	4a41      	ldr	r2, [pc, #260]	; (800e06c <createObjects+0x684>)
 800df66:	6013      	str	r3, [r2, #0]
	lv_label_set_text(motLcdLabel, "Lorem Ipsum Dolor Lo\nrem Ipsum Dolor Lore\nm Ipsum Dolor Lorem \nIpsum Dolor Lorem Ip");
 800df68:	4b40      	ldr	r3, [pc, #256]	; (800e06c <createObjects+0x684>)
 800df6a:	681b      	ldr	r3, [r3, #0]
 800df6c:	4940      	ldr	r1, [pc, #256]	; (800e070 <createObjects+0x688>)
 800df6e:	4618      	mov	r0, r3
 800df70:	f011 ff8c 	bl	801fe8c <lv_label_set_text>
	lv_label_set_style(motLcdLabel, LV_LABEL_STYLE_MAIN, &motLcdStl);
 800df74:	4b3d      	ldr	r3, [pc, #244]	; (800e06c <createObjects+0x684>)
 800df76:	681b      	ldr	r3, [r3, #0]
 800df78:	4a3e      	ldr	r2, [pc, #248]	; (800e074 <createObjects+0x68c>)
 800df7a:	2100      	movs	r1, #0
 800df7c:	4618      	mov	r0, r3
 800df7e:	f7ff fbdc 	bl	800d73a <lv_label_set_style>
	lv_label_set_align(motLcdLabel, LV_LABEL_ALIGN_LEFT);
 800df82:	4b3a      	ldr	r3, [pc, #232]	; (800e06c <createObjects+0x684>)
 800df84:	681b      	ldr	r3, [r3, #0]
 800df86:	2100      	movs	r1, #0
 800df88:	4618      	mov	r0, r3
 800df8a:	f012 f877 	bl	802007c <lv_label_set_align>
	lv_obj_set_pos(motLcdLabel, 74, 19);
 800df8e:	4b37      	ldr	r3, [pc, #220]	; (800e06c <createObjects+0x684>)
 800df90:	681b      	ldr	r3, [r3, #0]
 800df92:	2213      	movs	r2, #19
 800df94:	214a      	movs	r1, #74	; 0x4a
 800df96:	4618      	mov	r0, r3
 800df98:	f004 ff21 	bl	8012dde <lv_obj_set_pos>

	motMtaLabel = lv_label_create(motBgImg, NULL);
 800df9c:	4b2e      	ldr	r3, [pc, #184]	; (800e058 <createObjects+0x670>)
 800df9e:	681b      	ldr	r3, [r3, #0]
 800dfa0:	2100      	movs	r1, #0
 800dfa2:	4618      	mov	r0, r3
 800dfa4:	f011 fe40 	bl	801fc28 <lv_label_create>
 800dfa8:	4603      	mov	r3, r0
 800dfaa:	4a33      	ldr	r2, [pc, #204]	; (800e078 <createObjects+0x690>)
 800dfac:	6013      	str	r3, [r2, #0]
	lv_label_set_text(motMtaLabel, "00/15");
 800dfae:	4b32      	ldr	r3, [pc, #200]	; (800e078 <createObjects+0x690>)
 800dfb0:	681b      	ldr	r3, [r3, #0]
 800dfb2:	4932      	ldr	r1, [pc, #200]	; (800e07c <createObjects+0x694>)
 800dfb4:	4618      	mov	r0, r3
 800dfb6:	f011 ff69 	bl	801fe8c <lv_label_set_text>
	lv_label_set_style(motMtaLabel, LV_LABEL_STYLE_MAIN, &motMtaStl);
 800dfba:	4b2f      	ldr	r3, [pc, #188]	; (800e078 <createObjects+0x690>)
 800dfbc:	681b      	ldr	r3, [r3, #0]
 800dfbe:	4a30      	ldr	r2, [pc, #192]	; (800e080 <createObjects+0x698>)
 800dfc0:	2100      	movs	r1, #0
 800dfc2:	4618      	mov	r0, r3
 800dfc4:	f7ff fbb9 	bl	800d73a <lv_label_set_style>
	lv_label_set_align(motMtaLabel, LV_LABEL_ALIGN_LEFT);
 800dfc8:	4b2b      	ldr	r3, [pc, #172]	; (800e078 <createObjects+0x690>)
 800dfca:	681b      	ldr	r3, [r3, #0]
 800dfcc:	2100      	movs	r1, #0
 800dfce:	4618      	mov	r0, r3
 800dfd0:	f012 f854 	bl	802007c <lv_label_set_align>
	lv_obj_set_pos(motMtaLabel, 101, 48);
 800dfd4:	4b28      	ldr	r3, [pc, #160]	; (800e078 <createObjects+0x690>)
 800dfd6:	681b      	ldr	r3, [r3, #0]
 800dfd8:	2230      	movs	r2, #48	; 0x30
 800dfda:	2165      	movs	r1, #101	; 0x65
 800dfdc:	4618      	mov	r0, r3
 800dfde:	f004 fefe 	bl	8012dde <lv_obj_set_pos>

	motAccLabel = lv_label_create(motBgImg, NULL);
 800dfe2:	4b1d      	ldr	r3, [pc, #116]	; (800e058 <createObjects+0x670>)
 800dfe4:	681b      	ldr	r3, [r3, #0]
 800dfe6:	2100      	movs	r1, #0
 800dfe8:	4618      	mov	r0, r3
 800dfea:	f011 fe1d 	bl	801fc28 <lv_label_create>
 800dfee:	4603      	mov	r3, r0
 800dff0:	4a24      	ldr	r2, [pc, #144]	; (800e084 <createObjects+0x69c>)
 800dff2:	6013      	str	r3, [r2, #0]
	lv_label_set_text(motAccLabel, "000");
 800dff4:	4b23      	ldr	r3, [pc, #140]	; (800e084 <createObjects+0x69c>)
 800dff6:	681b      	ldr	r3, [r3, #0]
 800dff8:	4923      	ldr	r1, [pc, #140]	; (800e088 <createObjects+0x6a0>)
 800dffa:	4618      	mov	r0, r3
 800dffc:	f011 ff46 	bl	801fe8c <lv_label_set_text>
	lv_label_set_style(motAccLabel, LV_LABEL_STYLE_MAIN, &motAccTxtStl);
 800e000:	4b20      	ldr	r3, [pc, #128]	; (800e084 <createObjects+0x69c>)
 800e002:	681b      	ldr	r3, [r3, #0]
 800e004:	4a21      	ldr	r2, [pc, #132]	; (800e08c <createObjects+0x6a4>)
 800e006:	2100      	movs	r1, #0
 800e008:	4618      	mov	r0, r3
 800e00a:	f7ff fb96 	bl	800d73a <lv_label_set_style>
	lv_label_set_align(motAccLabel, LV_LABEL_ALIGN_LEFT);
 800e00e:	4b1d      	ldr	r3, [pc, #116]	; (800e084 <createObjects+0x69c>)
 800e010:	681b      	ldr	r3, [r3, #0]
 800e012:	2100      	movs	r1, #0
 800e014:	4618      	mov	r0, r3
 800e016:	f012 f831 	bl	802007c <lv_label_set_align>
	lv_obj_set_pos(motAccLabel, 232, 6);
 800e01a:	4b1a      	ldr	r3, [pc, #104]	; (800e084 <createObjects+0x69c>)
 800e01c:	681b      	ldr	r3, [r3, #0]
 800e01e:	2206      	movs	r2, #6
 800e020:	21e8      	movs	r1, #232	; 0xe8
 800e022:	e035      	b.n	800e090 <createObjects+0x6a8>
 800e024:	24062314 	.word	0x24062314
 800e028:	2400009c 	.word	0x2400009c
 800e02c:	240622e0 	.word	0x240622e0
 800e030:	24062318 	.word	0x24062318
 800e034:	240000a8 	.word	0x240000a8
 800e038:	2406231c 	.word	0x2406231c
 800e03c:	240000b4 	.word	0x240000b4
 800e040:	240622fc 	.word	0x240622fc
 800e044:	24061ee4 	.word	0x24061ee4
 800e048:	24062308 	.word	0x24062308
 800e04c:	24062100 	.word	0x24062100
 800e050:	2406230c 	.word	0x2406230c
 800e054:	080227c8 	.word	0x080227c8
 800e058:	24062320 	.word	0x24062320
 800e05c:	08031830 	.word	0x08031830
 800e060:	24062324 	.word	0x24062324
 800e064:	080227c4 	.word	0x080227c4
 800e068:	2406213c 	.word	0x2406213c
 800e06c:	24062328 	.word	0x24062328
 800e070:	080227e4 	.word	0x080227e4
 800e074:	24062178 	.word	0x24062178
 800e078:	2406232c 	.word	0x2406232c
 800e07c:	08022838 	.word	0x08022838
 800e080:	240621b4 	.word	0x240621b4
 800e084:	24062350 	.word	0x24062350
 800e088:	08022744 	.word	0x08022744
 800e08c:	2406222c 	.word	0x2406222c
 800e090:	4618      	mov	r0, r3
 800e092:	f004 fea4 	bl	8012dde <lv_obj_set_pos>

	motRegenLabel = lv_label_create(motBgImg, NULL);
 800e096:	4bb9      	ldr	r3, [pc, #740]	; (800e37c <createObjects+0x994>)
 800e098:	681b      	ldr	r3, [r3, #0]
 800e09a:	2100      	movs	r1, #0
 800e09c:	4618      	mov	r0, r3
 800e09e:	f011 fdc3 	bl	801fc28 <lv_label_create>
 800e0a2:	4603      	mov	r3, r0
 800e0a4:	4ab6      	ldr	r2, [pc, #728]	; (800e380 <createObjects+0x998>)
 800e0a6:	6013      	str	r3, [r2, #0]
	lv_label_set_text(motRegenLabel, "000");
 800e0a8:	4bb5      	ldr	r3, [pc, #724]	; (800e380 <createObjects+0x998>)
 800e0aa:	681b      	ldr	r3, [r3, #0]
 800e0ac:	49b5      	ldr	r1, [pc, #724]	; (800e384 <createObjects+0x99c>)
 800e0ae:	4618      	mov	r0, r3
 800e0b0:	f011 feec 	bl	801fe8c <lv_label_set_text>
	lv_label_set_style(motRegenLabel, LV_LABEL_STYLE_MAIN, &motAccTxtStl);
 800e0b4:	4bb2      	ldr	r3, [pc, #712]	; (800e380 <createObjects+0x998>)
 800e0b6:	681b      	ldr	r3, [r3, #0]
 800e0b8:	4ab3      	ldr	r2, [pc, #716]	; (800e388 <createObjects+0x9a0>)
 800e0ba:	2100      	movs	r1, #0
 800e0bc:	4618      	mov	r0, r3
 800e0be:	f7ff fb3c 	bl	800d73a <lv_label_set_style>
	lv_label_set_align(motRegenLabel, LV_LABEL_ALIGN_LEFT);
 800e0c2:	4baf      	ldr	r3, [pc, #700]	; (800e380 <createObjects+0x998>)
 800e0c4:	681b      	ldr	r3, [r3, #0]
 800e0c6:	2100      	movs	r1, #0
 800e0c8:	4618      	mov	r0, r3
 800e0ca:	f011 ffd7 	bl	802007c <lv_label_set_align>
	lv_obj_set_pos(motRegenLabel, 232, 39);
 800e0ce:	4bac      	ldr	r3, [pc, #688]	; (800e380 <createObjects+0x998>)
 800e0d0:	681b      	ldr	r3, [r3, #0]
 800e0d2:	2227      	movs	r2, #39	; 0x27
 800e0d4:	21e8      	movs	r1, #232	; 0xe8
 800e0d6:	4618      	mov	r0, r3
 800e0d8:	f004 fe81 	bl	8012dde <lv_obj_set_pos>

	motFwdImg = lv_img_create(motBgImg, NULL);
 800e0dc:	4ba7      	ldr	r3, [pc, #668]	; (800e37c <createObjects+0x994>)
 800e0de:	681b      	ldr	r3, [r3, #0]
 800e0e0:	2100      	movs	r1, #0
 800e0e2:	4618      	mov	r0, r3
 800e0e4:	f011 fa08 	bl	801f4f8 <lv_img_create>
 800e0e8:	4603      	mov	r3, r0
 800e0ea:	4aa8      	ldr	r2, [pc, #672]	; (800e38c <createObjects+0x9a4>)
 800e0ec:	6013      	str	r3, [r2, #0]
	lv_img_set_src(motFwdImg, &DISP_Mot_Fwd_img);
 800e0ee:	4ba7      	ldr	r3, [pc, #668]	; (800e38c <createObjects+0x9a4>)
 800e0f0:	681b      	ldr	r3, [r3, #0]
 800e0f2:	49a7      	ldr	r1, [pc, #668]	; (800e390 <createObjects+0x9a8>)
 800e0f4:	4618      	mov	r0, r3
 800e0f6:	f011 fa9d 	bl	801f634 <lv_img_set_src>
	lv_obj_set_pos(motFwdImg, 167, 18);
 800e0fa:	4ba4      	ldr	r3, [pc, #656]	; (800e38c <createObjects+0x9a4>)
 800e0fc:	681b      	ldr	r3, [r3, #0]
 800e0fe:	2212      	movs	r2, #18
 800e100:	21a7      	movs	r1, #167	; 0xa7
 800e102:	4618      	mov	r0, r3
 800e104:	f004 fe6b 	bl	8012dde <lv_obj_set_pos>
	lv_obj_set_hidden(motFwdImg, 1);
 800e108:	4ba0      	ldr	r3, [pc, #640]	; (800e38c <createObjects+0x9a4>)
 800e10a:	681b      	ldr	r3, [r3, #0]
 800e10c:	2101      	movs	r1, #1
 800e10e:	4618      	mov	r0, r3
 800e110:	f005 fca9 	bl	8013a66 <lv_obj_set_hidden>

	motRevImg = lv_img_create(motBgImg, NULL);
 800e114:	4b99      	ldr	r3, [pc, #612]	; (800e37c <createObjects+0x994>)
 800e116:	681b      	ldr	r3, [r3, #0]
 800e118:	2100      	movs	r1, #0
 800e11a:	4618      	mov	r0, r3
 800e11c:	f011 f9ec 	bl	801f4f8 <lv_img_create>
 800e120:	4603      	mov	r3, r0
 800e122:	4a9c      	ldr	r2, [pc, #624]	; (800e394 <createObjects+0x9ac>)
 800e124:	6013      	str	r3, [r2, #0]
	lv_img_set_src(motRevImg, &DISP_Mot_Rev_img);
 800e126:	4b9b      	ldr	r3, [pc, #620]	; (800e394 <createObjects+0x9ac>)
 800e128:	681b      	ldr	r3, [r3, #0]
 800e12a:	499b      	ldr	r1, [pc, #620]	; (800e398 <createObjects+0x9b0>)
 800e12c:	4618      	mov	r0, r3
 800e12e:	f011 fa81 	bl	801f634 <lv_img_set_src>
	lv_obj_set_pos(motRevImg, 192, 18);
 800e132:	4b98      	ldr	r3, [pc, #608]	; (800e394 <createObjects+0x9ac>)
 800e134:	681b      	ldr	r3, [r3, #0]
 800e136:	2212      	movs	r2, #18
 800e138:	21c0      	movs	r1, #192	; 0xc0
 800e13a:	4618      	mov	r0, r3
 800e13c:	f004 fe4f 	bl	8012dde <lv_obj_set_pos>
	lv_obj_set_hidden(motRevImg, 1);
 800e140:	4b94      	ldr	r3, [pc, #592]	; (800e394 <createObjects+0x9ac>)
 800e142:	681b      	ldr	r3, [r3, #0]
 800e144:	2101      	movs	r1, #1
 800e146:	4618      	mov	r0, r3
 800e148:	f005 fc8d 	bl	8013a66 <lv_obj_set_hidden>

	motPwrImg = lv_img_create(motBgImg, NULL);
 800e14c:	4b8b      	ldr	r3, [pc, #556]	; (800e37c <createObjects+0x994>)
 800e14e:	681b      	ldr	r3, [r3, #0]
 800e150:	2100      	movs	r1, #0
 800e152:	4618      	mov	r0, r3
 800e154:	f011 f9d0 	bl	801f4f8 <lv_img_create>
 800e158:	4603      	mov	r3, r0
 800e15a:	4a90      	ldr	r2, [pc, #576]	; (800e39c <createObjects+0x9b4>)
 800e15c:	6013      	str	r3, [r2, #0]
	lv_img_set_src(motPwrImg, &DISP_Mot_Pwr_img);
 800e15e:	4b8f      	ldr	r3, [pc, #572]	; (800e39c <createObjects+0x9b4>)
 800e160:	681b      	ldr	r3, [r3, #0]
 800e162:	498f      	ldr	r1, [pc, #572]	; (800e3a0 <createObjects+0x9b8>)
 800e164:	4618      	mov	r0, r3
 800e166:	f011 fa65 	bl	801f634 <lv_img_set_src>
	lv_obj_set_pos(motPwrImg, 167, 34);
 800e16a:	4b8c      	ldr	r3, [pc, #560]	; (800e39c <createObjects+0x9b4>)
 800e16c:	681b      	ldr	r3, [r3, #0]
 800e16e:	2222      	movs	r2, #34	; 0x22
 800e170:	21a7      	movs	r1, #167	; 0xa7
 800e172:	4618      	mov	r0, r3
 800e174:	f004 fe33 	bl	8012dde <lv_obj_set_pos>
	lv_obj_set_hidden(motPwrImg, 1);
 800e178:	4b88      	ldr	r3, [pc, #544]	; (800e39c <createObjects+0x9b4>)
 800e17a:	681b      	ldr	r3, [r3, #0]
 800e17c:	2101      	movs	r1, #1
 800e17e:	4618      	mov	r0, r3
 800e180:	f005 fc71 	bl	8013a66 <lv_obj_set_hidden>

	motEcoImg = lv_img_create(motBgImg, NULL);
 800e184:	4b7d      	ldr	r3, [pc, #500]	; (800e37c <createObjects+0x994>)
 800e186:	681b      	ldr	r3, [r3, #0]
 800e188:	2100      	movs	r1, #0
 800e18a:	4618      	mov	r0, r3
 800e18c:	f011 f9b4 	bl	801f4f8 <lv_img_create>
 800e190:	4603      	mov	r3, r0
 800e192:	4a84      	ldr	r2, [pc, #528]	; (800e3a4 <createObjects+0x9bc>)
 800e194:	6013      	str	r3, [r2, #0]
	lv_img_set_src(motEcoImg, &DISP_Mot_Eco_img);
 800e196:	4b83      	ldr	r3, [pc, #524]	; (800e3a4 <createObjects+0x9bc>)
 800e198:	681b      	ldr	r3, [r3, #0]
 800e19a:	4983      	ldr	r1, [pc, #524]	; (800e3a8 <createObjects+0x9c0>)
 800e19c:	4618      	mov	r0, r3
 800e19e:	f011 fa49 	bl	801f634 <lv_img_set_src>
	lv_obj_set_pos(motEcoImg, 192, 34);
 800e1a2:	4b80      	ldr	r3, [pc, #512]	; (800e3a4 <createObjects+0x9bc>)
 800e1a4:	681b      	ldr	r3, [r3, #0]
 800e1a6:	2222      	movs	r2, #34	; 0x22
 800e1a8:	21c0      	movs	r1, #192	; 0xc0
 800e1aa:	4618      	mov	r0, r3
 800e1ac:	f004 fe17 	bl	8012dde <lv_obj_set_pos>
	lv_obj_set_hidden(motEcoImg, 1);
 800e1b0:	4b7c      	ldr	r3, [pc, #496]	; (800e3a4 <createObjects+0x9bc>)
 800e1b2:	681b      	ldr	r3, [r3, #0]
 800e1b4:	2101      	movs	r1, #1
 800e1b6:	4618      	mov	r0, r3
 800e1b8:	f005 fc55 	bl	8013a66 <lv_obj_set_hidden>

	motOnImg = lv_img_create(motBgImg, NULL);
 800e1bc:	4b6f      	ldr	r3, [pc, #444]	; (800e37c <createObjects+0x994>)
 800e1be:	681b      	ldr	r3, [r3, #0]
 800e1c0:	2100      	movs	r1, #0
 800e1c2:	4618      	mov	r0, r3
 800e1c4:	f011 f998 	bl	801f4f8 <lv_img_create>
 800e1c8:	4603      	mov	r3, r0
 800e1ca:	4a78      	ldr	r2, [pc, #480]	; (800e3ac <createObjects+0x9c4>)
 800e1cc:	6013      	str	r3, [r2, #0]
	lv_img_set_src(motOnImg, &DISP_Mot_On_img);
 800e1ce:	4b77      	ldr	r3, [pc, #476]	; (800e3ac <createObjects+0x9c4>)
 800e1d0:	681b      	ldr	r3, [r3, #0]
 800e1d2:	4977      	ldr	r1, [pc, #476]	; (800e3b0 <createObjects+0x9c8>)
 800e1d4:	4618      	mov	r0, r3
 800e1d6:	f011 fa2d 	bl	801f634 <lv_img_set_src>
	lv_obj_set_pos(motOnImg, 167, 50);
 800e1da:	4b74      	ldr	r3, [pc, #464]	; (800e3ac <createObjects+0x9c4>)
 800e1dc:	681b      	ldr	r3, [r3, #0]
 800e1de:	2232      	movs	r2, #50	; 0x32
 800e1e0:	21a7      	movs	r1, #167	; 0xa7
 800e1e2:	4618      	mov	r0, r3
 800e1e4:	f004 fdfb 	bl	8012dde <lv_obj_set_pos>
	lv_obj_set_hidden(motOnImg, 1);
 800e1e8:	4b70      	ldr	r3, [pc, #448]	; (800e3ac <createObjects+0x9c4>)
 800e1ea:	681b      	ldr	r3, [r3, #0]
 800e1ec:	2101      	movs	r1, #1
 800e1ee:	4618      	mov	r0, r3
 800e1f0:	f005 fc39 	bl	8013a66 <lv_obj_set_hidden>

	motOffImg = lv_img_create(motBgImg, NULL);
 800e1f4:	4b61      	ldr	r3, [pc, #388]	; (800e37c <createObjects+0x994>)
 800e1f6:	681b      	ldr	r3, [r3, #0]
 800e1f8:	2100      	movs	r1, #0
 800e1fa:	4618      	mov	r0, r3
 800e1fc:	f011 f97c 	bl	801f4f8 <lv_img_create>
 800e200:	4603      	mov	r3, r0
 800e202:	4a6c      	ldr	r2, [pc, #432]	; (800e3b4 <createObjects+0x9cc>)
 800e204:	6013      	str	r3, [r2, #0]
	lv_img_set_src(motOffImg, &DISP_Mot_Off_img);
 800e206:	4b6b      	ldr	r3, [pc, #428]	; (800e3b4 <createObjects+0x9cc>)
 800e208:	681b      	ldr	r3, [r3, #0]
 800e20a:	496b      	ldr	r1, [pc, #428]	; (800e3b8 <createObjects+0x9d0>)
 800e20c:	4618      	mov	r0, r3
 800e20e:	f011 fa11 	bl	801f634 <lv_img_set_src>
	lv_obj_set_pos(motOffImg, 192, 50);
 800e212:	4b68      	ldr	r3, [pc, #416]	; (800e3b4 <createObjects+0x9cc>)
 800e214:	681b      	ldr	r3, [r3, #0]
 800e216:	2232      	movs	r2, #50	; 0x32
 800e218:	21c0      	movs	r1, #192	; 0xc0
 800e21a:	4618      	mov	r0, r3
 800e21c:	f004 fddf 	bl	8012dde <lv_obj_set_pos>
	lv_obj_set_hidden(motOffImg, 1);
 800e220:	4b64      	ldr	r3, [pc, #400]	; (800e3b4 <createObjects+0x9cc>)
 800e222:	681b      	ldr	r3, [r3, #0]
 800e224:	2101      	movs	r1, #1
 800e226:	4618      	mov	r0, r3
 800e228:	f005 fc1d 	bl	8013a66 <lv_obj_set_hidden>

	motAccArc = lv_arc_create(motBgImg, NULL);
 800e22c:	4b53      	ldr	r3, [pc, #332]	; (800e37c <createObjects+0x994>)
 800e22e:	681b      	ldr	r3, [r3, #0]
 800e230:	2100      	movs	r1, #0
 800e232:	4618      	mov	r0, r3
 800e234:	f010 fedc 	bl	801eff0 <lv_arc_create>
 800e238:	4603      	mov	r3, r0
 800e23a:	4a60      	ldr	r2, [pc, #384]	; (800e3bc <createObjects+0x9d4>)
 800e23c:	6013      	str	r3, [r2, #0]
	lv_arc_set_style(motAccArc, LV_ARC_STYLE_MAIN, &motAccArcStl);
 800e23e:	4b5f      	ldr	r3, [pc, #380]	; (800e3bc <createObjects+0x9d4>)
 800e240:	681b      	ldr	r3, [r3, #0]
 800e242:	4a5f      	ldr	r2, [pc, #380]	; (800e3c0 <createObjects+0x9d8>)
 800e244:	2100      	movs	r1, #0
 800e246:	4618      	mov	r0, r3
 800e248:	f010 ff77 	bl	801f13a <lv_arc_set_style>
	lv_arc_set_angles(motAccArc, 315, 315);
 800e24c:	4b5b      	ldr	r3, [pc, #364]	; (800e3bc <createObjects+0x9d4>)
 800e24e:	681b      	ldr	r3, [r3, #0]
 800e250:	f240 123b 	movw	r2, #315	; 0x13b
 800e254:	f240 113b 	movw	r1, #315	; 0x13b
 800e258:	4618      	mov	r0, r3
 800e25a:	f010 ff45 	bl	801f0e8 <lv_arc_set_angles>
	lv_obj_set_size(motAccArc, 28, 28);
 800e25e:	4b57      	ldr	r3, [pc, #348]	; (800e3bc <createObjects+0x9d4>)
 800e260:	681b      	ldr	r3, [r3, #0]
 800e262:	221c      	movs	r2, #28
 800e264:	211c      	movs	r1, #28
 800e266:	4618      	mov	r0, r3
 800e268:	f004 fe6e 	bl	8012f48 <lv_obj_set_size>
	lv_obj_set_pos(motAccArc, 228, 0);
 800e26c:	4b53      	ldr	r3, [pc, #332]	; (800e3bc <createObjects+0x9d4>)
 800e26e:	681b      	ldr	r3, [r3, #0]
 800e270:	2200      	movs	r2, #0
 800e272:	21e4      	movs	r1, #228	; 0xe4
 800e274:	4618      	mov	r0, r3
 800e276:	f004 fdb2 	bl	8012dde <lv_obj_set_pos>

	motRegenArc = lv_arc_create(motBgImg, NULL);
 800e27a:	4b40      	ldr	r3, [pc, #256]	; (800e37c <createObjects+0x994>)
 800e27c:	681b      	ldr	r3, [r3, #0]
 800e27e:	2100      	movs	r1, #0
 800e280:	4618      	mov	r0, r3
 800e282:	f010 feb5 	bl	801eff0 <lv_arc_create>
 800e286:	4603      	mov	r3, r0
 800e288:	4a4e      	ldr	r2, [pc, #312]	; (800e3c4 <createObjects+0x9dc>)
 800e28a:	6013      	str	r3, [r2, #0]
	lv_arc_set_style(motRegenArc, LV_ARC_STYLE_MAIN, &motAccArcStl);
 800e28c:	4b4d      	ldr	r3, [pc, #308]	; (800e3c4 <createObjects+0x9dc>)
 800e28e:	681b      	ldr	r3, [r3, #0]
 800e290:	4a4b      	ldr	r2, [pc, #300]	; (800e3c0 <createObjects+0x9d8>)
 800e292:	2100      	movs	r1, #0
 800e294:	4618      	mov	r0, r3
 800e296:	f010 ff50 	bl	801f13a <lv_arc_set_style>
	lv_obj_set_size(motRegenArc, 28, 28);
 800e29a:	4b4a      	ldr	r3, [pc, #296]	; (800e3c4 <createObjects+0x9dc>)
 800e29c:	681b      	ldr	r3, [r3, #0]
 800e29e:	221c      	movs	r2, #28
 800e2a0:	211c      	movs	r1, #28
 800e2a2:	4618      	mov	r0, r3
 800e2a4:	f004 fe50 	bl	8012f48 <lv_obj_set_size>
	lv_obj_set_pos(motRegenArc, 228, 33);
 800e2a8:	4b46      	ldr	r3, [pc, #280]	; (800e3c4 <createObjects+0x9dc>)
 800e2aa:	681b      	ldr	r3, [r3, #0]
 800e2ac:	2221      	movs	r2, #33	; 0x21
 800e2ae:	21e4      	movs	r1, #228	; 0xe4
 800e2b0:	4618      	mov	r0, r3
 800e2b2:	f004 fd94 	bl	8012dde <lv_obj_set_pos>
	lv_arc_set_angles(motRegenArc, 315, 315);
 800e2b6:	4b43      	ldr	r3, [pc, #268]	; (800e3c4 <createObjects+0x9dc>)
 800e2b8:	681b      	ldr	r3, [r3, #0]
 800e2ba:	f240 123b 	movw	r2, #315	; 0x13b
 800e2be:	f240 113b 	movw	r1, #315	; 0x13b
 800e2c2:	4618      	mov	r0, r3
 800e2c4:	f010 ff10 	bl	801f0e8 <lv_arc_set_angles>

	motLedCirc = lv_obj_create(motBgImg, NULL);
 800e2c8:	4b2c      	ldr	r3, [pc, #176]	; (800e37c <createObjects+0x994>)
 800e2ca:	681b      	ldr	r3, [r3, #0]
 800e2cc:	2100      	movs	r1, #0
 800e2ce:	4618      	mov	r0, r3
 800e2d0:	f004 fa56 	bl	8012780 <lv_obj_create>
 800e2d4:	4603      	mov	r3, r0
 800e2d6:	4a3c      	ldr	r2, [pc, #240]	; (800e3c8 <createObjects+0x9e0>)
 800e2d8:	6013      	str	r3, [r2, #0]
	lv_arc_set_style(motLedCirc, LV_ARC_STYLE_MAIN, &motLedStl);
 800e2da:	4b3b      	ldr	r3, [pc, #236]	; (800e3c8 <createObjects+0x9e0>)
 800e2dc:	681b      	ldr	r3, [r3, #0]
 800e2de:	4a3b      	ldr	r2, [pc, #236]	; (800e3cc <createObjects+0x9e4>)
 800e2e0:	2100      	movs	r1, #0
 800e2e2:	4618      	mov	r0, r3
 800e2e4:	f010 ff29 	bl	801f13a <lv_arc_set_style>
	lv_arc_set_angles(motLedCirc, 0, 360);
 800e2e8:	4b37      	ldr	r3, [pc, #220]	; (800e3c8 <createObjects+0x9e0>)
 800e2ea:	681b      	ldr	r3, [r3, #0]
 800e2ec:	f44f 72b4 	mov.w	r2, #360	; 0x168
 800e2f0:	2100      	movs	r1, #0
 800e2f2:	4618      	mov	r0, r3
 800e2f4:	f010 fef8 	bl	801f0e8 <lv_arc_set_angles>
	lv_obj_set_pos(motLedCirc, 192, 2);
 800e2f8:	4b33      	ldr	r3, [pc, #204]	; (800e3c8 <createObjects+0x9e0>)
 800e2fa:	681b      	ldr	r3, [r3, #0]
 800e2fc:	2202      	movs	r2, #2
 800e2fe:	21c0      	movs	r1, #192	; 0xc0
 800e300:	4618      	mov	r0, r3
 800e302:	f004 fd6c 	bl	8012dde <lv_obj_set_pos>
	lv_obj_set_size(motLedCirc, 12, 12);
 800e306:	4b30      	ldr	r3, [pc, #192]	; (800e3c8 <createObjects+0x9e0>)
 800e308:	681b      	ldr	r3, [r3, #0]
 800e30a:	220c      	movs	r2, #12
 800e30c:	210c      	movs	r1, #12
 800e30e:	4618      	mov	r0, r3
 800e310:	f004 fe1a 	bl	8012f48 <lv_obj_set_size>

	textBgImg = lv_img_create(lv_scr_act(), NULL);
 800e314:	f7ff fa06 	bl	800d724 <lv_scr_act>
 800e318:	4603      	mov	r3, r0
 800e31a:	2100      	movs	r1, #0
 800e31c:	4618      	mov	r0, r3
 800e31e:	f011 f8eb 	bl	801f4f8 <lv_img_create>
 800e322:	4603      	mov	r3, r0
 800e324:	4a2a      	ldr	r2, [pc, #168]	; (800e3d0 <createObjects+0x9e8>)
 800e326:	6013      	str	r3, [r2, #0]
	lv_img_set_src(textBgImg, &DISP_Text_bg);
 800e328:	4b29      	ldr	r3, [pc, #164]	; (800e3d0 <createObjects+0x9e8>)
 800e32a:	681b      	ldr	r3, [r3, #0]
 800e32c:	4929      	ldr	r1, [pc, #164]	; (800e3d4 <createObjects+0x9ec>)
 800e32e:	4618      	mov	r0, r3
 800e330:	f011 f980 	bl	801f634 <lv_img_set_src>
	lv_obj_set_pos(textBgImg, 0, 0);
 800e334:	4b26      	ldr	r3, [pc, #152]	; (800e3d0 <createObjects+0x9e8>)
 800e336:	681b      	ldr	r3, [r3, #0]
 800e338:	2200      	movs	r2, #0
 800e33a:	2100      	movs	r1, #0
 800e33c:	4618      	mov	r0, r3
 800e33e:	f004 fd4e 	bl	8012dde <lv_obj_set_pos>
	lv_obj_set_hidden(textBgImg, 1);
 800e342:	4b23      	ldr	r3, [pc, #140]	; (800e3d0 <createObjects+0x9e8>)
 800e344:	681b      	ldr	r3, [r3, #0]
 800e346:	2101      	movs	r1, #1
 800e348:	4618      	mov	r0, r3
 800e34a:	f005 fb8c 	bl	8013a66 <lv_obj_set_hidden>

	textMsgLabel = lv_label_create(textBgImg, NULL);
 800e34e:	4b20      	ldr	r3, [pc, #128]	; (800e3d0 <createObjects+0x9e8>)
 800e350:	681b      	ldr	r3, [r3, #0]
 800e352:	2100      	movs	r1, #0
 800e354:	4618      	mov	r0, r3
 800e356:	f011 fc67 	bl	801fc28 <lv_label_create>
 800e35a:	4603      	mov	r3, r0
 800e35c:	4a1e      	ldr	r2, [pc, #120]	; (800e3d8 <createObjects+0x9f0>)
 800e35e:	6013      	str	r3, [r2, #0]
	lv_label_set_text(textMsgLabel, "000");
 800e360:	4b1d      	ldr	r3, [pc, #116]	; (800e3d8 <createObjects+0x9f0>)
 800e362:	681b      	ldr	r3, [r3, #0]
 800e364:	4907      	ldr	r1, [pc, #28]	; (800e384 <createObjects+0x99c>)
 800e366:	4618      	mov	r0, r3
 800e368:	f011 fd90 	bl	801fe8c <lv_label_set_text>
	lv_label_set_style(textMsgLabel, LV_LABEL_STYLE_MAIN, &textMsgStl);
 800e36c:	4b1a      	ldr	r3, [pc, #104]	; (800e3d8 <createObjects+0x9f0>)
 800e36e:	681b      	ldr	r3, [r3, #0]
 800e370:	4a1a      	ldr	r2, [pc, #104]	; (800e3dc <createObjects+0x9f4>)
 800e372:	2100      	movs	r1, #0
 800e374:	4618      	mov	r0, r3
 800e376:	f7ff f9e0 	bl	800d73a <lv_label_set_style>
 800e37a:	e031      	b.n	800e3e0 <createObjects+0x9f8>
 800e37c:	24062320 	.word	0x24062320
 800e380:	24062354 	.word	0x24062354
 800e384:	08022744 	.word	0x08022744
 800e388:	2406222c 	.word	0x2406222c
 800e38c:	24062330 	.word	0x24062330
 800e390:	0802bc28 	.word	0x0802bc28
 800e394:	24062334 	.word	0x24062334
 800e398:	0802c038 	.word	0x0802c038
 800e39c:	24062338 	.word	0x24062338
 800e3a0:	0802bf34 	.word	0x0802bf34
 800e3a4:	2406233c 	.word	0x2406233c
 800e3a8:	0802bb24 	.word	0x0802bb24
 800e3ac:	24062340 	.word	0x24062340
 800e3b0:	0802be30 	.word	0x0802be30
 800e3b4:	24062344 	.word	0x24062344
 800e3b8:	0802bd2c 	.word	0x0802bd2c
 800e3bc:	24062348 	.word	0x24062348
 800e3c0:	240621f0 	.word	0x240621f0
 800e3c4:	2406234c 	.word	0x2406234c
 800e3c8:	24062358 	.word	0x24062358
 800e3cc:	24062268 	.word	0x24062268
 800e3d0:	2406235c 	.word	0x2406235c
 800e3d4:	0802d094 	.word	0x0802d094
 800e3d8:	24062360 	.word	0x24062360
 800e3dc:	240622a4 	.word	0x240622a4
	lv_label_set_align(textMsgLabel, LV_LABEL_ALIGN_LEFT);
 800e3e0:	4b1b      	ldr	r3, [pc, #108]	; (800e450 <createObjects+0xa68>)
 800e3e2:	681b      	ldr	r3, [r3, #0]
 800e3e4:	2100      	movs	r1, #0
 800e3e6:	4618      	mov	r0, r3
 800e3e8:	f011 fe48 	bl	802007c <lv_label_set_align>
	lv_obj_set_pos(textMsgLabel, 0, -2);
 800e3ec:	4b18      	ldr	r3, [pc, #96]	; (800e450 <createObjects+0xa68>)
 800e3ee:	681b      	ldr	r3, [r3, #0]
 800e3f0:	f06f 0201 	mvn.w	r2, #1
 800e3f4:	2100      	movs	r1, #0
 800e3f6:	4618      	mov	r0, r3
 800e3f8:	f004 fcf1 	bl	8012dde <lv_obj_set_pos>
	lv_obj_set_size(textMsgLabel, 256, 66);
 800e3fc:	4b14      	ldr	r3, [pc, #80]	; (800e450 <createObjects+0xa68>)
 800e3fe:	681b      	ldr	r3, [r3, #0]
 800e400:	2242      	movs	r2, #66	; 0x42
 800e402:	f44f 7180 	mov.w	r1, #256	; 0x100
 800e406:	4618      	mov	r0, r3
 800e408:	f004 fd9e 	bl	8012f48 <lv_obj_set_size>

	textNotifImg = lv_img_create(lv_scr_act(), NULL);
 800e40c:	f7ff f98a 	bl	800d724 <lv_scr_act>
 800e410:	4603      	mov	r3, r0
 800e412:	2100      	movs	r1, #0
 800e414:	4618      	mov	r0, r3
 800e416:	f011 f86f 	bl	801f4f8 <lv_img_create>
 800e41a:	4603      	mov	r3, r0
 800e41c:	4a0d      	ldr	r2, [pc, #52]	; (800e454 <createObjects+0xa6c>)
 800e41e:	6013      	str	r3, [r2, #0]
	lv_img_set_src(textNotifImg, &DISP_bubble_img);
 800e420:	4b0c      	ldr	r3, [pc, #48]	; (800e454 <createObjects+0xa6c>)
 800e422:	681b      	ldr	r3, [r3, #0]
 800e424:	490c      	ldr	r1, [pc, #48]	; (800e458 <createObjects+0xa70>)
 800e426:	4618      	mov	r0, r3
 800e428:	f011 f904 	bl	801f634 <lv_img_set_src>
	lv_obj_set_pos(textNotifImg, -1, -1);
 800e42c:	4b09      	ldr	r3, [pc, #36]	; (800e454 <createObjects+0xa6c>)
 800e42e:	681b      	ldr	r3, [r3, #0]
 800e430:	f04f 32ff 	mov.w	r2, #4294967295
 800e434:	f04f 31ff 	mov.w	r1, #4294967295
 800e438:	4618      	mov	r0, r3
 800e43a:	f004 fcd0 	bl	8012dde <lv_obj_set_pos>
	lv_obj_set_hidden(textNotifImg, 1);
 800e43e:	4b05      	ldr	r3, [pc, #20]	; (800e454 <createObjects+0xa6c>)
 800e440:	681b      	ldr	r3, [r3, #0]
 800e442:	2101      	movs	r1, #1
 800e444:	4618      	mov	r0, r3
 800e446:	f005 fb0e 	bl	8013a66 <lv_obj_set_hidden>
}
 800e44a:	bf00      	nop
 800e44c:	bd80      	pop	{r7, pc}
 800e44e:	bf00      	nop
 800e450:	24062360 	.word	0x24062360
 800e454:	24062364 	.word	0x24062364
 800e458:	0802d6a4 	.word	0x0802d6a4

0800e45c <showMainPage>:
//######   ##     ## ## ## ## ##
//##       ##     ## ##  #### ##
//##       ##     ## ##   ### ##    ##
//##        #######  ##    ##  ######

static void showMainPage(uint8_t en){
 800e45c:	b580      	push	{r7, lr}
 800e45e:	b082      	sub	sp, #8
 800e460:	af00      	add	r7, sp, #0
 800e462:	4603      	mov	r3, r0
 800e464:	71fb      	strb	r3, [r7, #7]
	xSemaphoreTake(dispMtx, portMAX_DELAY);
 800e466:	4b38      	ldr	r3, [pc, #224]	; (800e548 <showMainPage+0xec>)
 800e468:	681b      	ldr	r3, [r3, #0]
 800e46a:	f04f 31ff 	mov.w	r1, #4294967295
 800e46e:	4618      	mov	r0, r3
 800e470:	f7fc fd3e 	bl	800aef0 <xQueueSemaphoreTake>
	if(en){
 800e474:	79fb      	ldrb	r3, [r7, #7]
 800e476:	2b00      	cmp	r3, #0
 800e478:	d04f      	beq.n	800e51a <showMainPage+0xbe>
		lv_obj_set_hidden(leftArrowImg, !state.leftOn);
 800e47a:	4b34      	ldr	r3, [pc, #208]	; (800e54c <showMainPage+0xf0>)
 800e47c:	681a      	ldr	r2, [r3, #0]
 800e47e:	4b34      	ldr	r3, [pc, #208]	; (800e550 <showMainPage+0xf4>)
 800e480:	7a1b      	ldrb	r3, [r3, #8]
 800e482:	f003 0302 	and.w	r3, r3, #2
 800e486:	b2db      	uxtb	r3, r3
 800e488:	2b00      	cmp	r3, #0
 800e48a:	bf0c      	ite	eq
 800e48c:	2301      	moveq	r3, #1
 800e48e:	2300      	movne	r3, #0
 800e490:	b2db      	uxtb	r3, r3
 800e492:	4619      	mov	r1, r3
 800e494:	4610      	mov	r0, r2
 800e496:	f005 fae6 	bl	8013a66 <lv_obj_set_hidden>
		lv_obj_set_hidden(rightArrowImg, !state.rightOn);
 800e49a:	4b2e      	ldr	r3, [pc, #184]	; (800e554 <showMainPage+0xf8>)
 800e49c:	681a      	ldr	r2, [r3, #0]
 800e49e:	4b2c      	ldr	r3, [pc, #176]	; (800e550 <showMainPage+0xf4>)
 800e4a0:	7a1b      	ldrb	r3, [r3, #8]
 800e4a2:	f003 0304 	and.w	r3, r3, #4
 800e4a6:	b2db      	uxtb	r3, r3
 800e4a8:	2b00      	cmp	r3, #0
 800e4aa:	bf0c      	ite	eq
 800e4ac:	2301      	moveq	r3, #1
 800e4ae:	2300      	movne	r3, #0
 800e4b0:	b2db      	uxtb	r3, r3
 800e4b2:	4619      	mov	r1, r3
 800e4b4:	4610      	mov	r0, r2
 800e4b6:	f005 fad6 	bl	8013a66 <lv_obj_set_hidden>
		lv_obj_set_hidden(stopSignImg, !state.stopOn);
 800e4ba:	4b27      	ldr	r3, [pc, #156]	; (800e558 <showMainPage+0xfc>)
 800e4bc:	681a      	ldr	r2, [r3, #0]
 800e4be:	4b24      	ldr	r3, [pc, #144]	; (800e550 <showMainPage+0xf4>)
 800e4c0:	7a1b      	ldrb	r3, [r3, #8]
 800e4c2:	f003 0308 	and.w	r3, r3, #8
 800e4c6:	b2db      	uxtb	r3, r3
 800e4c8:	2b00      	cmp	r3, #0
 800e4ca:	bf0c      	ite	eq
 800e4cc:	2301      	moveq	r3, #1
 800e4ce:	2300      	movne	r3, #0
 800e4d0:	b2db      	uxtb	r3, r3
 800e4d2:	4619      	mov	r1, r3
 800e4d4:	4610      	mov	r0, r2
 800e4d6:	f005 fac6 	bl	8013a66 <lv_obj_set_hidden>
		lv_obj_set_hidden(triangleSignImg, !state.hazardOn);
 800e4da:	4b20      	ldr	r3, [pc, #128]	; (800e55c <showMainPage+0x100>)
 800e4dc:	681a      	ldr	r2, [r3, #0]
 800e4de:	4b1c      	ldr	r3, [pc, #112]	; (800e550 <showMainPage+0xf4>)
 800e4e0:	7a1b      	ldrb	r3, [r3, #8]
 800e4e2:	f003 0310 	and.w	r3, r3, #16
 800e4e6:	b2db      	uxtb	r3, r3
 800e4e8:	2b00      	cmp	r3, #0
 800e4ea:	bf0c      	ite	eq
 800e4ec:	2301      	moveq	r3, #1
 800e4ee:	2300      	movne	r3, #0
 800e4f0:	b2db      	uxtb	r3, r3
 800e4f2:	4619      	mov	r1, r3
 800e4f4:	4610      	mov	r0, r2
 800e4f6:	f005 fab6 	bl	8013a66 <lv_obj_set_hidden>
		lv_obj_set_hidden(motOnLabel,!state.motOnWindow);
 800e4fa:	4b19      	ldr	r3, [pc, #100]	; (800e560 <showMainPage+0x104>)
 800e4fc:	681a      	ldr	r2, [r3, #0]
 800e4fe:	4b14      	ldr	r3, [pc, #80]	; (800e550 <showMainPage+0xf4>)
 800e500:	785b      	ldrb	r3, [r3, #1]
 800e502:	f003 0308 	and.w	r3, r3, #8
 800e506:	b2db      	uxtb	r3, r3
 800e508:	2b00      	cmp	r3, #0
 800e50a:	bf0c      	ite	eq
 800e50c:	2301      	moveq	r3, #1
 800e50e:	2300      	movne	r3, #0
 800e510:	b2db      	uxtb	r3, r3
 800e512:	4619      	mov	r1, r3
 800e514:	4610      	mov	r0, r2
 800e516:	f005 faa6 	bl	8013a66 <lv_obj_set_hidden>
	}
	lv_obj_set_hidden(backgroundImg,!en);
 800e51a:	4b12      	ldr	r3, [pc, #72]	; (800e564 <showMainPage+0x108>)
 800e51c:	681a      	ldr	r2, [r3, #0]
 800e51e:	79fb      	ldrb	r3, [r7, #7]
 800e520:	2b00      	cmp	r3, #0
 800e522:	bf0c      	ite	eq
 800e524:	2301      	moveq	r3, #1
 800e526:	2300      	movne	r3, #0
 800e528:	b2db      	uxtb	r3, r3
 800e52a:	4619      	mov	r1, r3
 800e52c:	4610      	mov	r0, r2
 800e52e:	f005 fa9a 	bl	8013a66 <lv_obj_set_hidden>
	xSemaphoreGive(dispMtx);
 800e532:	4b05      	ldr	r3, [pc, #20]	; (800e548 <showMainPage+0xec>)
 800e534:	6818      	ldr	r0, [r3, #0]
 800e536:	2300      	movs	r3, #0
 800e538:	2200      	movs	r2, #0
 800e53a:	2100      	movs	r1, #0
 800e53c:	f7fc f9d2 	bl	800a8e4 <xQueueGenericSend>
}
 800e540:	bf00      	nop
 800e542:	3708      	adds	r7, #8
 800e544:	46bd      	mov	sp, r7
 800e546:	bd80      	pop	{r7, pc}
 800e548:	24061e94 	.word	0x24061e94
 800e54c:	24062310 	.word	0x24062310
 800e550:	24061e9c 	.word	0x24061e9c
 800e554:	24062314 	.word	0x24062314
 800e558:	24062318 	.word	0x24062318
 800e55c:	2406231c 	.word	0x2406231c
 800e560:	24062308 	.word	0x24062308
 800e564:	240622e0 	.word	0x240622e0

0800e568 <showMotPage>:

static void showMotPage(uint8_t en){
 800e568:	b580      	push	{r7, lr}
 800e56a:	b082      	sub	sp, #8
 800e56c:	af00      	add	r7, sp, #0
 800e56e:	4603      	mov	r3, r0
 800e570:	71fb      	strb	r3, [r7, #7]
	xSemaphoreTake(dispMtx, portMAX_DELAY);
 800e572:	4b48      	ldr	r3, [pc, #288]	; (800e694 <showMotPage+0x12c>)
 800e574:	681b      	ldr	r3, [r3, #0]
 800e576:	f04f 31ff 	mov.w	r1, #4294967295
 800e57a:	4618      	mov	r0, r3
 800e57c:	f7fc fcb8 	bl	800aef0 <xQueueSemaphoreTake>
	if(en){
 800e580:	79fb      	ldrb	r3, [r7, #7]
 800e582:	2b00      	cmp	r3, #0
 800e584:	d06f      	beq.n	800e666 <showMotPage+0xfe>
		lv_obj_set_hidden(motFwdImg, !state.fwd);
 800e586:	4b44      	ldr	r3, [pc, #272]	; (800e698 <showMotPage+0x130>)
 800e588:	681a      	ldr	r2, [r3, #0]
 800e58a:	4b44      	ldr	r3, [pc, #272]	; (800e69c <showMotPage+0x134>)
 800e58c:	7a1b      	ldrb	r3, [r3, #8]
 800e58e:	f003 0301 	and.w	r3, r3, #1
 800e592:	b2db      	uxtb	r3, r3
 800e594:	2b00      	cmp	r3, #0
 800e596:	bf0c      	ite	eq
 800e598:	2301      	moveq	r3, #1
 800e59a:	2300      	movne	r3, #0
 800e59c:	b2db      	uxtb	r3, r3
 800e59e:	4619      	mov	r1, r3
 800e5a0:	4610      	mov	r0, r2
 800e5a2:	f005 fa60 	bl	8013a66 <lv_obj_set_hidden>
		lv_obj_set_hidden(motRevImg, state.fwd);
 800e5a6:	4b3e      	ldr	r3, [pc, #248]	; (800e6a0 <showMotPage+0x138>)
 800e5a8:	681a      	ldr	r2, [r3, #0]
 800e5aa:	4b3c      	ldr	r3, [pc, #240]	; (800e69c <showMotPage+0x134>)
 800e5ac:	7a1b      	ldrb	r3, [r3, #8]
 800e5ae:	f3c3 0300 	ubfx	r3, r3, #0, #1
 800e5b2:	b2db      	uxtb	r3, r3
 800e5b4:	2b00      	cmp	r3, #0
 800e5b6:	bf14      	ite	ne
 800e5b8:	2301      	movne	r3, #1
 800e5ba:	2300      	moveq	r3, #0
 800e5bc:	b2db      	uxtb	r3, r3
 800e5be:	4619      	mov	r1, r3
 800e5c0:	4610      	mov	r0, r2
 800e5c2:	f005 fa50 	bl	8013a66 <lv_obj_set_hidden>
		lv_obj_set_hidden(motPwrImg, state.eco);
 800e5c6:	4b37      	ldr	r3, [pc, #220]	; (800e6a4 <showMotPage+0x13c>)
 800e5c8:	681a      	ldr	r2, [r3, #0]
 800e5ca:	4b34      	ldr	r3, [pc, #208]	; (800e69c <showMotPage+0x134>)
 800e5cc:	7a1b      	ldrb	r3, [r3, #8]
 800e5ce:	f3c3 1380 	ubfx	r3, r3, #6, #1
 800e5d2:	b2db      	uxtb	r3, r3
 800e5d4:	2b00      	cmp	r3, #0
 800e5d6:	bf14      	ite	ne
 800e5d8:	2301      	movne	r3, #1
 800e5da:	2300      	moveq	r3, #0
 800e5dc:	b2db      	uxtb	r3, r3
 800e5de:	4619      	mov	r1, r3
 800e5e0:	4610      	mov	r0, r2
 800e5e2:	f005 fa40 	bl	8013a66 <lv_obj_set_hidden>
		lv_obj_set_hidden(motEcoImg, !state.eco);
 800e5e6:	4b30      	ldr	r3, [pc, #192]	; (800e6a8 <showMotPage+0x140>)
 800e5e8:	681a      	ldr	r2, [r3, #0]
 800e5ea:	4b2c      	ldr	r3, [pc, #176]	; (800e69c <showMotPage+0x134>)
 800e5ec:	7a1b      	ldrb	r3, [r3, #8]
 800e5ee:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800e5f2:	b2db      	uxtb	r3, r3
 800e5f4:	2b00      	cmp	r3, #0
 800e5f6:	bf0c      	ite	eq
 800e5f8:	2301      	moveq	r3, #1
 800e5fa:	2300      	movne	r3, #0
 800e5fc:	b2db      	uxtb	r3, r3
 800e5fe:	4619      	mov	r1, r3
 800e600:	4610      	mov	r0, r2
 800e602:	f005 fa30 	bl	8013a66 <lv_obj_set_hidden>
		lv_obj_set_hidden(motOnImg, !state.motOn);
 800e606:	4b29      	ldr	r3, [pc, #164]	; (800e6ac <showMotPage+0x144>)
 800e608:	681a      	ldr	r2, [r3, #0]
 800e60a:	4b24      	ldr	r3, [pc, #144]	; (800e69c <showMotPage+0x134>)
 800e60c:	78db      	ldrb	r3, [r3, #3]
 800e60e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800e612:	b2db      	uxtb	r3, r3
 800e614:	2b00      	cmp	r3, #0
 800e616:	bf0c      	ite	eq
 800e618:	2301      	moveq	r3, #1
 800e61a:	2300      	movne	r3, #0
 800e61c:	b2db      	uxtb	r3, r3
 800e61e:	4619      	mov	r1, r3
 800e620:	4610      	mov	r0, r2
 800e622:	f005 fa20 	bl	8013a66 <lv_obj_set_hidden>
		lv_obj_set_hidden(motOffImg, state.motOn);
 800e626:	4b22      	ldr	r3, [pc, #136]	; (800e6b0 <showMotPage+0x148>)
 800e628:	681a      	ldr	r2, [r3, #0]
 800e62a:	4b1c      	ldr	r3, [pc, #112]	; (800e69c <showMotPage+0x134>)
 800e62c:	78db      	ldrb	r3, [r3, #3]
 800e62e:	f3c3 1380 	ubfx	r3, r3, #6, #1
 800e632:	b2db      	uxtb	r3, r3
 800e634:	2b00      	cmp	r3, #0
 800e636:	bf14      	ite	ne
 800e638:	2301      	movne	r3, #1
 800e63a:	2300      	moveq	r3, #0
 800e63c:	b2db      	uxtb	r3, r3
 800e63e:	4619      	mov	r1, r3
 800e640:	4610      	mov	r0, r2
 800e642:	f005 fa10 	bl	8013a66 <lv_obj_set_hidden>
		lv_obj_set_hidden(motLedCirc, !state.motLedOn);
 800e646:	4b1b      	ldr	r3, [pc, #108]	; (800e6b4 <showMotPage+0x14c>)
 800e648:	681a      	ldr	r2, [r3, #0]
 800e64a:	4b14      	ldr	r3, [pc, #80]	; (800e69c <showMotPage+0x134>)
 800e64c:	7a1b      	ldrb	r3, [r3, #8]
 800e64e:	f003 0320 	and.w	r3, r3, #32
 800e652:	b2db      	uxtb	r3, r3
 800e654:	2b00      	cmp	r3, #0
 800e656:	bf0c      	ite	eq
 800e658:	2301      	moveq	r3, #1
 800e65a:	2300      	movne	r3, #0
 800e65c:	b2db      	uxtb	r3, r3
 800e65e:	4619      	mov	r1, r3
 800e660:	4610      	mov	r0, r2
 800e662:	f005 fa00 	bl	8013a66 <lv_obj_set_hidden>
	}
	lv_obj_set_hidden(motBgImg,!en);
 800e666:	4b14      	ldr	r3, [pc, #80]	; (800e6b8 <showMotPage+0x150>)
 800e668:	681a      	ldr	r2, [r3, #0]
 800e66a:	79fb      	ldrb	r3, [r7, #7]
 800e66c:	2b00      	cmp	r3, #0
 800e66e:	bf0c      	ite	eq
 800e670:	2301      	moveq	r3, #1
 800e672:	2300      	movne	r3, #0
 800e674:	b2db      	uxtb	r3, r3
 800e676:	4619      	mov	r1, r3
 800e678:	4610      	mov	r0, r2
 800e67a:	f005 f9f4 	bl	8013a66 <lv_obj_set_hidden>
	xSemaphoreGive(dispMtx);
 800e67e:	4b05      	ldr	r3, [pc, #20]	; (800e694 <showMotPage+0x12c>)
 800e680:	6818      	ldr	r0, [r3, #0]
 800e682:	2300      	movs	r3, #0
 800e684:	2200      	movs	r2, #0
 800e686:	2100      	movs	r1, #0
 800e688:	f7fc f92c 	bl	800a8e4 <xQueueGenericSend>
}
 800e68c:	bf00      	nop
 800e68e:	3708      	adds	r7, #8
 800e690:	46bd      	mov	sp, r7
 800e692:	bd80      	pop	{r7, pc}
 800e694:	24061e94 	.word	0x24061e94
 800e698:	24062330 	.word	0x24062330
 800e69c:	24061e9c 	.word	0x24061e9c
 800e6a0:	24062334 	.word	0x24062334
 800e6a4:	24062338 	.word	0x24062338
 800e6a8:	2406233c 	.word	0x2406233c
 800e6ac:	24062340 	.word	0x24062340
 800e6b0:	24062344 	.word	0x24062344
 800e6b4:	24062358 	.word	0x24062358
 800e6b8:	24062320 	.word	0x24062320

0800e6bc <showTextPage>:

static void showTextPage(uint8_t en){
 800e6bc:	b580      	push	{r7, lr}
 800e6be:	b082      	sub	sp, #8
 800e6c0:	af00      	add	r7, sp, #0
 800e6c2:	4603      	mov	r3, r0
 800e6c4:	71fb      	strb	r3, [r7, #7]
	xSemaphoreTake(dispMtx, portMAX_DELAY);
 800e6c6:	4b16      	ldr	r3, [pc, #88]	; (800e720 <showTextPage+0x64>)
 800e6c8:	681b      	ldr	r3, [r3, #0]
 800e6ca:	f04f 31ff 	mov.w	r1, #4294967295
 800e6ce:	4618      	mov	r0, r3
 800e6d0:	f7fc fc0e 	bl	800aef0 <xQueueSemaphoreTake>
	lv_obj_set_hidden(textBgImg, !en);
 800e6d4:	4b13      	ldr	r3, [pc, #76]	; (800e724 <showTextPage+0x68>)
 800e6d6:	681a      	ldr	r2, [r3, #0]
 800e6d8:	79fb      	ldrb	r3, [r7, #7]
 800e6da:	2b00      	cmp	r3, #0
 800e6dc:	bf0c      	ite	eq
 800e6de:	2301      	moveq	r3, #1
 800e6e0:	2300      	movne	r3, #0
 800e6e2:	b2db      	uxtb	r3, r3
 800e6e4:	4619      	mov	r1, r3
 800e6e6:	4610      	mov	r0, r2
 800e6e8:	f005 f9bd 	bl	8013a66 <lv_obj_set_hidden>
	if(en){
 800e6ec:	79fb      	ldrb	r3, [r7, #7]
 800e6ee:	2b00      	cmp	r3, #0
 800e6f0:	d00a      	beq.n	800e708 <showTextPage+0x4c>
		lv_obj_set_hidden(textNotifImg, 1);
 800e6f2:	4b0d      	ldr	r3, [pc, #52]	; (800e728 <showTextPage+0x6c>)
 800e6f4:	681b      	ldr	r3, [r3, #0]
 800e6f6:	2101      	movs	r1, #1
 800e6f8:	4618      	mov	r0, r3
 800e6fa:	f005 f9b4 	bl	8013a66 <lv_obj_set_hidden>
		state.msg = 0;
 800e6fe:	4a0b      	ldr	r2, [pc, #44]	; (800e72c <showTextPage+0x70>)
 800e700:	7a13      	ldrb	r3, [r2, #8]
 800e702:	f36f 13c7 	bfc	r3, #7, #1
 800e706:	7213      	strb	r3, [r2, #8]
	}
	xSemaphoreGive(dispMtx);
 800e708:	4b05      	ldr	r3, [pc, #20]	; (800e720 <showTextPage+0x64>)
 800e70a:	6818      	ldr	r0, [r3, #0]
 800e70c:	2300      	movs	r3, #0
 800e70e:	2200      	movs	r2, #0
 800e710:	2100      	movs	r1, #0
 800e712:	f7fc f8e7 	bl	800a8e4 <xQueueGenericSend>
}
 800e716:	bf00      	nop
 800e718:	3708      	adds	r7, #8
 800e71a:	46bd      	mov	sp, r7
 800e71c:	bd80      	pop	{r7, pc}
 800e71e:	bf00      	nop
 800e720:	24061e94 	.word	0x24061e94
 800e724:	2406235c 	.word	0x2406235c
 800e728:	24062364 	.word	0x24062364
 800e72c:	24061e9c 	.word	0x24061e9c

0800e730 <displayInit>:
		osDelay(500);
	}
	vTaskDelete(NULL);
}

void displayInit(){
 800e730:	b590      	push	{r4, r7, lr}
 800e732:	b087      	sub	sp, #28
 800e734:	af02      	add	r7, sp, #8
	dispMtx = xSemaphoreCreateMutex();
 800e736:	2001      	movs	r0, #1
 800e738:	f7fc f8bb 	bl	800a8b2 <xQueueCreateMutex>
 800e73c:	4603      	mov	r3, r0
 800e73e:	4a34      	ldr	r2, [pc, #208]	; (800e810 <displayInit+0xe0>)
 800e740:	6013      	str	r3, [r2, #0]
//	xSemaphoreTake(dispMtx, portMAX_DELAY);
//	osDelay(50);
	SSD_init_hack();
 800e742:	f7fe fe25 	bl	800d390 <SSD_init_hack>
	lv_init();
 800e746:	f003 ffed 	bl	8012724 <lv_init>
	initStyles();
 800e74a:	f7ff f805 	bl	800d758 <initStyles>
	xTimerStart(xTimerCreate("", 1, pdTRUE, NULL, lvglTick),0);
 800e74e:	4b31      	ldr	r3, [pc, #196]	; (800e814 <displayInit+0xe4>)
 800e750:	9300      	str	r3, [sp, #0]
 800e752:	2300      	movs	r3, #0
 800e754:	2201      	movs	r2, #1
 800e756:	2101      	movs	r1, #1
 800e758:	482f      	ldr	r0, [pc, #188]	; (800e818 <displayInit+0xe8>)
 800e75a:	f7fd fe63 	bl	800c424 <xTimerCreate>
 800e75e:	4604      	mov	r4, r0
 800e760:	f7fd f8dc 	bl	800b91c <xTaskGetTickCount>
 800e764:	4602      	mov	r2, r0
 800e766:	2300      	movs	r3, #0
 800e768:	9300      	str	r3, [sp, #0]
 800e76a:	2300      	movs	r3, #0
 800e76c:	2101      	movs	r1, #1
 800e76e:	4620      	mov	r0, r4
 800e770:	f7fd feb4 	bl	800c4dc <xTimerGenericCommand>
	notifTmrHandle = xTimerCreate("", 500, pdTRUE, NULL, notifTmr);
 800e774:	4b29      	ldr	r3, [pc, #164]	; (800e81c <displayInit+0xec>)
 800e776:	9300      	str	r3, [sp, #0]
 800e778:	2300      	movs	r3, #0
 800e77a:	2201      	movs	r2, #1
 800e77c:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 800e780:	4825      	ldr	r0, [pc, #148]	; (800e818 <displayInit+0xe8>)
 800e782:	f7fd fe4f 	bl	800c424 <xTimerCreate>
 800e786:	4603      	mov	r3, r0
 800e788:	4a25      	ldr	r2, [pc, #148]	; (800e820 <displayInit+0xf0>)
 800e78a:	6013      	str	r3, [r2, #0]
	lv_disp_buf_t* disp_buf = pvPortMalloc(sizeof(lv_disp_buf_t));
 800e78c:	201c      	movs	r0, #28
 800e78e:	f7fe fc13 	bl	800cfb8 <pvPortMalloc>
 800e792:	60f8      	str	r0, [r7, #12]
	lv_color_t* buf = pvPortMalloc((LV_HOR_RES_MAX * LV_VER_RES_MAX) * sizeof(lv_color_t));
 800e794:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 800e798:	f7fe fc0e 	bl	800cfb8 <pvPortMalloc>
 800e79c:	60b8      	str	r0, [r7, #8]
	lv_disp_buf_init(disp_buf, buf, NULL, LV_HOR_RES_MAX * LV_VER_RES_MAX);
 800e79e:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800e7a2:	2200      	movs	r2, #0
 800e7a4:	68b9      	ldr	r1, [r7, #8]
 800e7a6:	68f8      	ldr	r0, [r7, #12]
 800e7a8:	f00e fbfb 	bl	801cfa2 <lv_disp_buf_init>
	lv_disp_drv_t* disp_drv = pvPortMalloc(sizeof(lv_disp_drv_t));
 800e7ac:	2020      	movs	r0, #32
 800e7ae:	f7fe fc03 	bl	800cfb8 <pvPortMalloc>
 800e7b2:	6078      	str	r0, [r7, #4]
	lv_disp_drv_init(disp_drv);
 800e7b4:	6878      	ldr	r0, [r7, #4]
 800e7b6:	f00e fbbe 	bl	801cf36 <lv_disp_drv_init>
	disp_drv->flush_cb = my_disp_flush_hack;
 800e7ba:	687b      	ldr	r3, [r7, #4]
 800e7bc:	4a19      	ldr	r2, [pc, #100]	; (800e824 <displayInit+0xf4>)
 800e7be:	60da      	str	r2, [r3, #12]
	disp_drv->buffer = disp_buf;
 800e7c0:	687b      	ldr	r3, [r7, #4]
 800e7c2:	68fa      	ldr	r2, [r7, #12]
 800e7c4:	605a      	str	r2, [r3, #4]
	disp_drv->rounder_cb = my_rounder_cb;
 800e7c6:	687b      	ldr	r3, [r7, #4]
 800e7c8:	4a17      	ldr	r2, [pc, #92]	; (800e828 <displayInit+0xf8>)
 800e7ca:	611a      	str	r2, [r3, #16]
	lv_disp_drv_register(disp_drv);
 800e7cc:	6878      	ldr	r0, [r7, #4]
 800e7ce:	f00e fc05 	bl	801cfdc <lv_disp_drv_register>
	createObjects();
 800e7d2:	f7ff f909 	bl	800d9e8 <createObjects>
	showMotPage(0);
 800e7d6:	2000      	movs	r0, #0
 800e7d8:	f7ff fec6 	bl	800e568 <showMotPage>
	state.vfm = 1;
 800e7dc:	4a13      	ldr	r2, [pc, #76]	; (800e82c <displayInit+0xfc>)
 800e7de:	78d3      	ldrb	r3, [r2, #3]
 800e7e0:	2101      	movs	r1, #1
 800e7e2:	f361 0303 	bfi	r3, r1, #0, #4
 800e7e6:	70d3      	strb	r3, [r2, #3]
	state.fwd = 1;
 800e7e8:	4a10      	ldr	r2, [pc, #64]	; (800e82c <displayInit+0xfc>)
 800e7ea:	7a13      	ldrb	r3, [r2, #8]
 800e7ec:	f043 0301 	orr.w	r3, r3, #1
 800e7f0:	7213      	strb	r3, [r2, #8]
	state.msg = 0;
 800e7f2:	4a0e      	ldr	r2, [pc, #56]	; (800e82c <displayInit+0xfc>)
 800e7f4:	7a13      	ldrb	r3, [r2, #8]
 800e7f6:	f36f 13c7 	bfc	r3, #7, #1
 800e7fa:	7213      	strb	r3, [r2, #8]
	state.pi = 0;
 800e7fc:	4a0b      	ldr	r2, [pc, #44]	; (800e82c <displayInit+0xfc>)
 800e7fe:	7853      	ldrb	r3, [r2, #1]
 800e800:	f36f 0300 	bfc	r3, #0, #1
 800e804:	7053      	strb	r3, [r2, #1]
//	xSemaphoreGive(dispMtx);
}
 800e806:	bf00      	nop
 800e808:	3714      	adds	r7, #20
 800e80a:	46bd      	mov	sp, r7
 800e80c:	bd90      	pop	{r4, r7, pc}
 800e80e:	bf00      	nop
 800e810:	24061e94 	.word	0x24061e94
 800e814:	0800e961 	.word	0x0800e961
 800e818:	08022840 	.word	0x08022840
 800e81c:	0800e8e9 	.word	0x0800e8e9
 800e820:	24061e98 	.word	0x24061e98
 800e824:	0800d4df 	.word	0x0800d4df
 800e828:	0800d4a9 	.word	0x0800d4a9
 800e82c:	24061e9c 	.word	0x24061e9c

0800e830 <displayTmr>:



void displayTmr(void* xTimer){
 800e830:	b580      	push	{r7, lr}
 800e832:	b088      	sub	sp, #32
 800e834:	af02      	add	r7, sp, #8
 800e836:	6078      	str	r0, [r7, #4]
	uint32_t id = pvTimerGetTimerID(xTimer);
 800e838:	6878      	ldr	r0, [r7, #4]
 800e83a:	f7fe f92f 	bl	800ca9c <pvTimerGetTimerID>
 800e83e:	4603      	mov	r3, r0
 800e840:	617b      	str	r3, [r7, #20]
	if(id == 0){
 800e842:	697b      	ldr	r3, [r7, #20]
 800e844:	2b00      	cmp	r3, #0
 800e846:	d104      	bne.n	800e852 <displayTmr+0x22>
		vTimerSetTimerID(xTimer, 1);
 800e848:	2101      	movs	r1, #1
 800e84a:	6878      	ldr	r0, [r7, #4]
 800e84c:	f7fe f946 	bl	800cadc <vTimerSetTimerID>
		if(xSemaphoreTake(dispMtx, 0) == pdPASS){
			lv_task_handler();
			xSemaphoreGive(dispMtx);
		}
	}
}
 800e850:	e042      	b.n	800e8d8 <displayTmr+0xa8>
	}else if(id == 1){
 800e852:	697b      	ldr	r3, [r7, #20]
 800e854:	2b01      	cmp	r3, #1
 800e856:	d11c      	bne.n	800e892 <displayTmr+0x62>
		area.x1 = 0;
 800e858:	2300      	movs	r3, #0
 800e85a:	81bb      	strh	r3, [r7, #12]
		area.x2 = 255;
 800e85c:	23ff      	movs	r3, #255	; 0xff
 800e85e:	823b      	strh	r3, [r7, #16]
		area.y1 = 0;
 800e860:	2300      	movs	r3, #0
 800e862:	81fb      	strh	r3, [r7, #14]
		area.y2 = 63;
 800e864:	233f      	movs	r3, #63	; 0x3f
 800e866:	827b      	strh	r3, [r7, #18]
		SSD_writeRegion_hack(&area, kaboom);
 800e868:	f107 030c 	add.w	r3, r7, #12
 800e86c:	491c      	ldr	r1, [pc, #112]	; (800e8e0 <displayTmr+0xb0>)
 800e86e:	4618      	mov	r0, r3
 800e870:	f7fe fda4 	bl	800d3bc <SSD_writeRegion_hack>
		xTimerChangePeriod(xTimer, 1975, portMAX_DELAY);
 800e874:	f04f 33ff 	mov.w	r3, #4294967295
 800e878:	9300      	str	r3, [sp, #0]
 800e87a:	2300      	movs	r3, #0
 800e87c:	f240 72b7 	movw	r2, #1975	; 0x7b7
 800e880:	2104      	movs	r1, #4
 800e882:	6878      	ldr	r0, [r7, #4]
 800e884:	f7fd fe2a 	bl	800c4dc <xTimerGenericCommand>
		vTimerSetTimerID(xTimer, 2);
 800e888:	2102      	movs	r1, #2
 800e88a:	6878      	ldr	r0, [r7, #4]
 800e88c:	f7fe f926 	bl	800cadc <vTimerSetTimerID>
}
 800e890:	e022      	b.n	800e8d8 <displayTmr+0xa8>
	}else if(id == 2){
 800e892:	697b      	ldr	r3, [r7, #20]
 800e894:	2b02      	cmp	r3, #2
 800e896:	d10d      	bne.n	800e8b4 <displayTmr+0x84>
		xTimerChangePeriod(xTimer, 25, portMAX_DELAY);
 800e898:	f04f 33ff 	mov.w	r3, #4294967295
 800e89c:	9300      	str	r3, [sp, #0]
 800e89e:	2300      	movs	r3, #0
 800e8a0:	2219      	movs	r2, #25
 800e8a2:	2104      	movs	r1, #4
 800e8a4:	6878      	ldr	r0, [r7, #4]
 800e8a6:	f7fd fe19 	bl	800c4dc <xTimerGenericCommand>
		vTimerSetTimerID(xTimer, 3);
 800e8aa:	2103      	movs	r1, #3
 800e8ac:	6878      	ldr	r0, [r7, #4]
 800e8ae:	f7fe f915 	bl	800cadc <vTimerSetTimerID>
}
 800e8b2:	e011      	b.n	800e8d8 <displayTmr+0xa8>
		if(xSemaphoreTake(dispMtx, 0) == pdPASS){
 800e8b4:	4b0b      	ldr	r3, [pc, #44]	; (800e8e4 <displayTmr+0xb4>)
 800e8b6:	681b      	ldr	r3, [r3, #0]
 800e8b8:	2100      	movs	r1, #0
 800e8ba:	4618      	mov	r0, r3
 800e8bc:	f7fc fb18 	bl	800aef0 <xQueueSemaphoreTake>
 800e8c0:	4603      	mov	r3, r0
 800e8c2:	2b01      	cmp	r3, #1
 800e8c4:	d108      	bne.n	800e8d8 <displayTmr+0xa8>
			lv_task_handler();
 800e8c6:	f00f fcc5 	bl	801e254 <lv_task_handler>
			xSemaphoreGive(dispMtx);
 800e8ca:	4b06      	ldr	r3, [pc, #24]	; (800e8e4 <displayTmr+0xb4>)
 800e8cc:	6818      	ldr	r0, [r3, #0]
 800e8ce:	2300      	movs	r3, #0
 800e8d0:	2200      	movs	r2, #0
 800e8d2:	2100      	movs	r1, #0
 800e8d4:	f7fc f806 	bl	800a8e4 <xQueueGenericSend>
}
 800e8d8:	bf00      	nop
 800e8da:	3718      	adds	r7, #24
 800e8dc:	46bd      	mov	sp, r7
 800e8de:	bd80      	pop	{r7, pc}
 800e8e0:	080d7c98 	.word	0x080d7c98
 800e8e4:	24061e94 	.word	0x24061e94

0800e8e8 <notifTmr>:

static void notifTmr(TimerHandle_t xTimer){
 800e8e8:	b590      	push	{r4, r7, lr}
 800e8ea:	b085      	sub	sp, #20
 800e8ec:	af02      	add	r7, sp, #8
 800e8ee:	6078      	str	r0, [r7, #4]
	if(state.msg){
 800e8f0:	4b18      	ldr	r3, [pc, #96]	; (800e954 <notifTmr+0x6c>)
 800e8f2:	7a1b      	ldrb	r3, [r3, #8]
 800e8f4:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800e8f8:	b2db      	uxtb	r3, r3
 800e8fa:	2b00      	cmp	r3, #0
 800e8fc:	d017      	beq.n	800e92e <notifTmr+0x46>
		lv_obj_set_hidden(textNotifImg, !lv_obj_get_hidden(textNotifImg));
 800e8fe:	4b16      	ldr	r3, [pc, #88]	; (800e958 <notifTmr+0x70>)
 800e900:	681c      	ldr	r4, [r3, #0]
 800e902:	4b15      	ldr	r3, [pc, #84]	; (800e958 <notifTmr+0x70>)
 800e904:	681b      	ldr	r3, [r3, #0]
 800e906:	4618      	mov	r0, r3
 800e908:	f005 faf2 	bl	8013ef0 <lv_obj_get_hidden>
 800e90c:	4603      	mov	r3, r0
 800e90e:	2b00      	cmp	r3, #0
 800e910:	bf14      	ite	ne
 800e912:	2301      	movne	r3, #1
 800e914:	2300      	moveq	r3, #0
 800e916:	b2db      	uxtb	r3, r3
 800e918:	f083 0301 	eor.w	r3, r3, #1
 800e91c:	b2db      	uxtb	r3, r3
 800e91e:	f003 0301 	and.w	r3, r3, #1
 800e922:	b2db      	uxtb	r3, r3
 800e924:	4619      	mov	r1, r3
 800e926:	4620      	mov	r0, r4
 800e928:	f005 f89d 	bl	8013a66 <lv_obj_set_hidden>
	}else{
		lv_obj_set_hidden(textNotifImg, 1);
		xTimerStop(notifTmrHandle, 0);
	}
}
 800e92c:	e00e      	b.n	800e94c <notifTmr+0x64>
		lv_obj_set_hidden(textNotifImg, 1);
 800e92e:	4b0a      	ldr	r3, [pc, #40]	; (800e958 <notifTmr+0x70>)
 800e930:	681b      	ldr	r3, [r3, #0]
 800e932:	2101      	movs	r1, #1
 800e934:	4618      	mov	r0, r3
 800e936:	f005 f896 	bl	8013a66 <lv_obj_set_hidden>
		xTimerStop(notifTmrHandle, 0);
 800e93a:	4b08      	ldr	r3, [pc, #32]	; (800e95c <notifTmr+0x74>)
 800e93c:	6818      	ldr	r0, [r3, #0]
 800e93e:	2300      	movs	r3, #0
 800e940:	9300      	str	r3, [sp, #0]
 800e942:	2300      	movs	r3, #0
 800e944:	2200      	movs	r2, #0
 800e946:	2103      	movs	r1, #3
 800e948:	f7fd fdc8 	bl	800c4dc <xTimerGenericCommand>
}
 800e94c:	bf00      	nop
 800e94e:	370c      	adds	r7, #12
 800e950:	46bd      	mov	sp, r7
 800e952:	bd90      	pop	{r4, r7, pc}
 800e954:	24061e9c 	.word	0x24061e9c
 800e958:	24062364 	.word	0x24062364
 800e95c:	24061e98 	.word	0x24061e98

0800e960 <lvglTick>:
		xSemaphoreGive(dispMtx);
		osDelay(10);
	}
}

static void lvglTick(void* id){
 800e960:	b580      	push	{r7, lr}
 800e962:	b082      	sub	sp, #8
 800e964:	af00      	add	r7, sp, #0
 800e966:	6078      	str	r0, [r7, #4]
	lv_tick_inc(1);
 800e968:	2001      	movs	r0, #1
 800e96a:	f00e fc9f 	bl	801d2ac <lv_tick_inc>
}
 800e96e:	bf00      	nop
 800e970:	3708      	adds	r7, #8
 800e972:	46bd      	mov	sp, r7
 800e974:	bd80      	pop	{r7, pc}
	...

0800e978 <updateMotSpeed>:

static void updateMotSpeed(){
 800e978:	b580      	push	{r7, lr}
 800e97a:	b084      	sub	sp, #16
 800e97c:	af00      	add	r7, sp, #0
	float speed = state.pi ? (float)state.speedPulse / 16.0f * WHEEL_DIA_M : (float)state.speedPulse / 16.0f * WHEEL_CIRC_M * 3.6f;
 800e97e:	4b27      	ldr	r3, [pc, #156]	; (800ea1c <updateMotSpeed+0xa4>)
 800e980:	785b      	ldrb	r3, [r3, #1]
 800e982:	f003 0301 	and.w	r3, r3, #1
 800e986:	b2db      	uxtb	r3, r3
 800e988:	2b00      	cmp	r3, #0
 800e98a:	d00e      	beq.n	800e9aa <updateMotSpeed+0x32>
 800e98c:	4b23      	ldr	r3, [pc, #140]	; (800ea1c <updateMotSpeed+0xa4>)
 800e98e:	889b      	ldrh	r3, [r3, #4]
 800e990:	ee07 3a90 	vmov	s15, r3
 800e994:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 800e998:	eef3 6a00 	vmov.f32	s13, #48	; 0x41800000  16.0
 800e99c:	eec7 7a26 	vdiv.f32	s15, s14, s13
 800e9a0:	ed9f 7a1f 	vldr	s14, [pc, #124]	; 800ea20 <updateMotSpeed+0xa8>
 800e9a4:	ee67 7a87 	vmul.f32	s15, s15, s14
 800e9a8:	e011      	b.n	800e9ce <updateMotSpeed+0x56>
 800e9aa:	4b1c      	ldr	r3, [pc, #112]	; (800ea1c <updateMotSpeed+0xa4>)
 800e9ac:	889b      	ldrh	r3, [r3, #4]
 800e9ae:	ee07 3a90 	vmov	s15, r3
 800e9b2:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 800e9b6:	eef3 6a00 	vmov.f32	s13, #48	; 0x41800000  16.0
 800e9ba:	eec7 7a26 	vdiv.f32	s15, s14, s13
 800e9be:	ed9f 7a19 	vldr	s14, [pc, #100]	; 800ea24 <updateMotSpeed+0xac>
 800e9c2:	ee67 7a87 	vmul.f32	s15, s15, s14
 800e9c6:	ed9f 7a18 	vldr	s14, [pc, #96]	; 800ea28 <updateMotSpeed+0xb0>
 800e9ca:	ee67 7a87 	vmul.f32	s15, s15, s14
 800e9ce:	edc7 7a03 	vstr	s15, [r7, #12]
	uint8_t buf[10];
	sprintf(buf, "%3d", (int)speed);
 800e9d2:	edd7 7a03 	vldr	s15, [r7, #12]
 800e9d6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800e9da:	463b      	mov	r3, r7
 800e9dc:	ee17 2a90 	vmov	r2, s15
 800e9e0:	4912      	ldr	r1, [pc, #72]	; (800ea2c <updateMotSpeed+0xb4>)
 800e9e2:	4618      	mov	r0, r3
 800e9e4:	f013 fa22 	bl	8021e2c <siprintf>
	xSemaphoreTake(dispMtx, portMAX_DELAY);
 800e9e8:	4b11      	ldr	r3, [pc, #68]	; (800ea30 <updateMotSpeed+0xb8>)
 800e9ea:	681b      	ldr	r3, [r3, #0]
 800e9ec:	f04f 31ff 	mov.w	r1, #4294967295
 800e9f0:	4618      	mov	r0, r3
 800e9f2:	f7fc fa7d 	bl	800aef0 <xQueueSemaphoreTake>
	lv_label_set_text(bigSpeedLabel, buf);
 800e9f6:	4b0f      	ldr	r3, [pc, #60]	; (800ea34 <updateMotSpeed+0xbc>)
 800e9f8:	681b      	ldr	r3, [r3, #0]
 800e9fa:	463a      	mov	r2, r7
 800e9fc:	4611      	mov	r1, r2
 800e9fe:	4618      	mov	r0, r3
 800ea00:	f011 fa44 	bl	801fe8c <lv_label_set_text>
	xSemaphoreGive(dispMtx);
 800ea04:	4b0a      	ldr	r3, [pc, #40]	; (800ea30 <updateMotSpeed+0xb8>)
 800ea06:	6818      	ldr	r0, [r3, #0]
 800ea08:	2300      	movs	r3, #0
 800ea0a:	2200      	movs	r2, #0
 800ea0c:	2100      	movs	r1, #0
 800ea0e:	f7fb ff69 	bl	800a8e4 <xQueueGenericSend>
}
 800ea12:	bf00      	nop
 800ea14:	3710      	adds	r7, #16
 800ea16:	46bd      	mov	sp, r7
 800ea18:	bd80      	pop	{r7, pc}
 800ea1a:	bf00      	nop
 800ea1c:	24061e9c 	.word	0x24061e9c
 800ea20:	3f0f1aa0 	.word	0x3f0f1aa0
 800ea24:	3fe0c988 	.word	0x3fe0c988
 800ea28:	40666666 	.word	0x40666666
 800ea2c:	08022844 	.word	0x08022844
 800ea30:	24061e94 	.word	0x24061e94
 800ea34:	240622e4 	.word	0x240622e4

0800ea38 <updateGearLabel>:
	xSemaphoreTake(dispMtx, portMAX_DELAY);
	lv_label_set_text(arrayPwrLabel, buf);
	xSemaphoreGive(dispMtx);
}

static void updateGearLabel(){
 800ea38:	b580      	push	{r7, lr}
 800ea3a:	b082      	sub	sp, #8
 800ea3c:	af00      	add	r7, sp, #0
	uint8_t buf[2] = {0};
 800ea3e:	2300      	movs	r3, #0
 800ea40:	80bb      	strh	r3, [r7, #4]
	if(!state.motOn) buf[0] = 'P';
 800ea42:	4b17      	ldr	r3, [pc, #92]	; (800eaa0 <updateGearLabel+0x68>)
 800ea44:	78db      	ldrb	r3, [r3, #3]
 800ea46:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800ea4a:	b2db      	uxtb	r3, r3
 800ea4c:	2b00      	cmp	r3, #0
 800ea4e:	d102      	bne.n	800ea56 <updateGearLabel+0x1e>
 800ea50:	2350      	movs	r3, #80	; 0x50
 800ea52:	713b      	strb	r3, [r7, #4]
 800ea54:	e00b      	b.n	800ea6e <updateGearLabel+0x36>
	else{
		if(state.fwd) buf[0] = 'D';
 800ea56:	4b12      	ldr	r3, [pc, #72]	; (800eaa0 <updateGearLabel+0x68>)
 800ea58:	7a1b      	ldrb	r3, [r3, #8]
 800ea5a:	f003 0301 	and.w	r3, r3, #1
 800ea5e:	b2db      	uxtb	r3, r3
 800ea60:	2b00      	cmp	r3, #0
 800ea62:	d002      	beq.n	800ea6a <updateGearLabel+0x32>
 800ea64:	2344      	movs	r3, #68	; 0x44
 800ea66:	713b      	strb	r3, [r7, #4]
 800ea68:	e001      	b.n	800ea6e <updateGearLabel+0x36>
		else buf[0] = 'R';
 800ea6a:	2352      	movs	r3, #82	; 0x52
 800ea6c:	713b      	strb	r3, [r7, #4]
	}
	xSemaphoreTake(dispMtx, portMAX_DELAY);
 800ea6e:	4b0d      	ldr	r3, [pc, #52]	; (800eaa4 <updateGearLabel+0x6c>)
 800ea70:	681b      	ldr	r3, [r3, #0]
 800ea72:	f04f 31ff 	mov.w	r1, #4294967295
 800ea76:	4618      	mov	r0, r3
 800ea78:	f7fc fa3a 	bl	800aef0 <xQueueSemaphoreTake>
	lv_label_set_text(gearTxtLabel, buf);
 800ea7c:	4b0a      	ldr	r3, [pc, #40]	; (800eaa8 <updateGearLabel+0x70>)
 800ea7e:	681b      	ldr	r3, [r3, #0]
 800ea80:	1d3a      	adds	r2, r7, #4
 800ea82:	4611      	mov	r1, r2
 800ea84:	4618      	mov	r0, r3
 800ea86:	f011 fa01 	bl	801fe8c <lv_label_set_text>
	xSemaphoreGive(dispMtx);
 800ea8a:	4b06      	ldr	r3, [pc, #24]	; (800eaa4 <updateGearLabel+0x6c>)
 800ea8c:	6818      	ldr	r0, [r3, #0]
 800ea8e:	2300      	movs	r3, #0
 800ea90:	2200      	movs	r2, #0
 800ea92:	2100      	movs	r1, #0
 800ea94:	f7fb ff26 	bl	800a8e4 <xQueueGenericSend>
}
 800ea98:	bf00      	nop
 800ea9a:	3708      	adds	r7, #8
 800ea9c:	46bd      	mov	sp, r7
 800ea9e:	bd80      	pop	{r7, pc}
 800eaa0:	24061e9c 	.word	0x24061e9c
 800eaa4:	24061e94 	.word	0x24061e94
 800eaa8:	24062300 	.word	0x24062300

0800eaac <updateVfm>:

static void updateVfm(){
 800eaac:	b580      	push	{r7, lr}
 800eaae:	b082      	sub	sp, #8
 800eab0:	af00      	add	r7, sp, #0
	uint8_t buf[4];
	sprintf(buf, "%02d", state.vfm);
 800eab2:	4b15      	ldr	r3, [pc, #84]	; (800eb08 <updateVfm+0x5c>)
 800eab4:	78db      	ldrb	r3, [r3, #3]
 800eab6:	f3c3 0303 	ubfx	r3, r3, #0, #4
 800eaba:	b2db      	uxtb	r3, r3
 800eabc:	461a      	mov	r2, r3
 800eabe:	1d3b      	adds	r3, r7, #4
 800eac0:	4912      	ldr	r1, [pc, #72]	; (800eb0c <updateVfm+0x60>)
 800eac2:	4618      	mov	r0, r3
 800eac4:	f013 f9b2 	bl	8021e2c <siprintf>
	xSemaphoreTake(dispMtx, portMAX_DELAY);
 800eac8:	4b11      	ldr	r3, [pc, #68]	; (800eb10 <updateVfm+0x64>)
 800eaca:	681b      	ldr	r3, [r3, #0]
 800eacc:	f04f 31ff 	mov.w	r1, #4294967295
 800ead0:	4618      	mov	r0, r3
 800ead2:	f7fc fa0d 	bl	800aef0 <xQueueSemaphoreTake>
	lv_label_set_text(motVfmLabel, buf);
 800ead6:	4b0f      	ldr	r3, [pc, #60]	; (800eb14 <updateVfm+0x68>)
 800ead8:	681b      	ldr	r3, [r3, #0]
 800eada:	1d3a      	adds	r2, r7, #4
 800eadc:	4611      	mov	r1, r2
 800eade:	4618      	mov	r0, r3
 800eae0:	f011 f9d4 	bl	801fe8c <lv_label_set_text>
	lv_label_set_text(mainVfmLabel, buf);
 800eae4:	4b0c      	ldr	r3, [pc, #48]	; (800eb18 <updateVfm+0x6c>)
 800eae6:	681b      	ldr	r3, [r3, #0]
 800eae8:	1d3a      	adds	r2, r7, #4
 800eaea:	4611      	mov	r1, r2
 800eaec:	4618      	mov	r0, r3
 800eaee:	f011 f9cd 	bl	801fe8c <lv_label_set_text>
	xSemaphoreGive(dispMtx);
 800eaf2:	4b07      	ldr	r3, [pc, #28]	; (800eb10 <updateVfm+0x64>)
 800eaf4:	6818      	ldr	r0, [r3, #0]
 800eaf6:	2300      	movs	r3, #0
 800eaf8:	2200      	movs	r2, #0
 800eafa:	2100      	movs	r1, #0
 800eafc:	f7fb fef2 	bl	800a8e4 <xQueueGenericSend>
}
 800eb00:	bf00      	nop
 800eb02:	3708      	adds	r7, #8
 800eb04:	46bd      	mov	sp, r7
 800eb06:	bd80      	pop	{r7, pc}
 800eb08:	24061e9c 	.word	0x24061e9c
 800eb0c:	08022850 	.word	0x08022850
 800eb10:	24061e94 	.word	0x24061e94
 800eb14:	24062324 	.word	0x24062324
 800eb18:	24062304 	.word	0x24062304

0800eb1c <updateMta>:

static void updateMta(){
 800eb1c:	b580      	push	{r7, lr}
 800eb1e:	b082      	sub	sp, #8
 800eb20:	af00      	add	r7, sp, #0
	uint8_t buf[8];
	sprintf(buf, "%02d/15", state.mta);
 800eb22:	4b12      	ldr	r3, [pc, #72]	; (800eb6c <updateMta+0x50>)
 800eb24:	789b      	ldrb	r3, [r3, #2]
 800eb26:	f3c3 0343 	ubfx	r3, r3, #1, #4
 800eb2a:	b2db      	uxtb	r3, r3
 800eb2c:	461a      	mov	r2, r3
 800eb2e:	463b      	mov	r3, r7
 800eb30:	490f      	ldr	r1, [pc, #60]	; (800eb70 <updateMta+0x54>)
 800eb32:	4618      	mov	r0, r3
 800eb34:	f013 f97a 	bl	8021e2c <siprintf>
	xSemaphoreTake(dispMtx, portMAX_DELAY);
 800eb38:	4b0e      	ldr	r3, [pc, #56]	; (800eb74 <updateMta+0x58>)
 800eb3a:	681b      	ldr	r3, [r3, #0]
 800eb3c:	f04f 31ff 	mov.w	r1, #4294967295
 800eb40:	4618      	mov	r0, r3
 800eb42:	f7fc f9d5 	bl	800aef0 <xQueueSemaphoreTake>
	lv_label_set_text(motMtaLabel, buf);
 800eb46:	4b0c      	ldr	r3, [pc, #48]	; (800eb78 <updateMta+0x5c>)
 800eb48:	681b      	ldr	r3, [r3, #0]
 800eb4a:	463a      	mov	r2, r7
 800eb4c:	4611      	mov	r1, r2
 800eb4e:	4618      	mov	r0, r3
 800eb50:	f011 f99c 	bl	801fe8c <lv_label_set_text>
	xSemaphoreGive(dispMtx);
 800eb54:	4b07      	ldr	r3, [pc, #28]	; (800eb74 <updateMta+0x58>)
 800eb56:	6818      	ldr	r0, [r3, #0]
 800eb58:	2300      	movs	r3, #0
 800eb5a:	2200      	movs	r2, #0
 800eb5c:	2100      	movs	r1, #0
 800eb5e:	f7fb fec1 	bl	800a8e4 <xQueueGenericSend>
}
 800eb62:	bf00      	nop
 800eb64:	3708      	adds	r7, #8
 800eb66:	46bd      	mov	sp, r7
 800eb68:	bd80      	pop	{r7, pc}
 800eb6a:	bf00      	nop
 800eb6c:	24061e9c 	.word	0x24061e9c
 800eb70:	08022858 	.word	0x08022858
 800eb74:	24061e94 	.word	0x24061e94
 800eb78:	2406232c 	.word	0x2406232c

0800eb7c <updateAcc>:

static void updateAcc(){
 800eb7c:	b580      	push	{r7, lr}
 800eb7e:	b082      	sub	sp, #8
 800eb80:	af00      	add	r7, sp, #0
	uint8_t buf[8];
	sprintf(buf, "%03d", state.acc);
 800eb82:	4b28      	ldr	r3, [pc, #160]	; (800ec24 <updateAcc+0xa8>)
 800eb84:	799b      	ldrb	r3, [r3, #6]
 800eb86:	461a      	mov	r2, r3
 800eb88:	463b      	mov	r3, r7
 800eb8a:	4927      	ldr	r1, [pc, #156]	; (800ec28 <updateAcc+0xac>)
 800eb8c:	4618      	mov	r0, r3
 800eb8e:	f013 f94d 	bl	8021e2c <siprintf>
	xSemaphoreTake(dispMtx, portMAX_DELAY);
 800eb92:	4b26      	ldr	r3, [pc, #152]	; (800ec2c <updateAcc+0xb0>)
 800eb94:	681b      	ldr	r3, [r3, #0]
 800eb96:	f04f 31ff 	mov.w	r1, #4294967295
 800eb9a:	4618      	mov	r0, r3
 800eb9c:	f7fc f9a8 	bl	800aef0 <xQueueSemaphoreTake>
	lv_obj_set_width(accPositionObj, (uint32_t)state.acc*43/255);
 800eba0:	4b23      	ldr	r3, [pc, #140]	; (800ec30 <updateAcc+0xb4>)
 800eba2:	681a      	ldr	r2, [r3, #0]
 800eba4:	4b1f      	ldr	r3, [pc, #124]	; (800ec24 <updateAcc+0xa8>)
 800eba6:	799b      	ldrb	r3, [r3, #6]
 800eba8:	4619      	mov	r1, r3
 800ebaa:	232b      	movs	r3, #43	; 0x2b
 800ebac:	fb03 f301 	mul.w	r3, r3, r1
 800ebb0:	4920      	ldr	r1, [pc, #128]	; (800ec34 <updateAcc+0xb8>)
 800ebb2:	fba1 1303 	umull	r1, r3, r1, r3
 800ebb6:	09db      	lsrs	r3, r3, #7
 800ebb8:	b21b      	sxth	r3, r3
 800ebba:	4619      	mov	r1, r3
 800ebbc:	4610      	mov	r0, r2
 800ebbe:	f004 fa3c 	bl	801303a <lv_obj_set_width>
	lv_arc_set_angles(motAccArc, 315-(int)((float)state.acc*270.0f/255.0f), 315);
 800ebc2:	4b1d      	ldr	r3, [pc, #116]	; (800ec38 <updateAcc+0xbc>)
 800ebc4:	6818      	ldr	r0, [r3, #0]
 800ebc6:	4b17      	ldr	r3, [pc, #92]	; (800ec24 <updateAcc+0xa8>)
 800ebc8:	799b      	ldrb	r3, [r3, #6]
 800ebca:	ee07 3a90 	vmov	s15, r3
 800ebce:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800ebd2:	ed9f 7a1a 	vldr	s14, [pc, #104]	; 800ec3c <updateAcc+0xc0>
 800ebd6:	ee27 7a87 	vmul.f32	s14, s15, s14
 800ebda:	eddf 6a19 	vldr	s13, [pc, #100]	; 800ec40 <updateAcc+0xc4>
 800ebde:	eec7 7a26 	vdiv.f32	s15, s14, s13
 800ebe2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800ebe6:	ee17 3a90 	vmov	r3, s15
 800ebea:	b29a      	uxth	r2, r3
 800ebec:	f240 133b 	movw	r3, #315	; 0x13b
 800ebf0:	1a9b      	subs	r3, r3, r2
 800ebf2:	b29b      	uxth	r3, r3
 800ebf4:	f240 123b 	movw	r2, #315	; 0x13b
 800ebf8:	4619      	mov	r1, r3
 800ebfa:	f010 fa75 	bl	801f0e8 <lv_arc_set_angles>
	lv_label_set_text(motAccLabel, buf);
 800ebfe:	4b11      	ldr	r3, [pc, #68]	; (800ec44 <updateAcc+0xc8>)
 800ec00:	681b      	ldr	r3, [r3, #0]
 800ec02:	463a      	mov	r2, r7
 800ec04:	4611      	mov	r1, r2
 800ec06:	4618      	mov	r0, r3
 800ec08:	f011 f940 	bl	801fe8c <lv_label_set_text>
	xSemaphoreGive(dispMtx);
 800ec0c:	4b07      	ldr	r3, [pc, #28]	; (800ec2c <updateAcc+0xb0>)
 800ec0e:	6818      	ldr	r0, [r3, #0]
 800ec10:	2300      	movs	r3, #0
 800ec12:	2200      	movs	r2, #0
 800ec14:	2100      	movs	r1, #0
 800ec16:	f7fb fe65 	bl	800a8e4 <xQueueGenericSend>
}
 800ec1a:	bf00      	nop
 800ec1c:	3708      	adds	r7, #8
 800ec1e:	46bd      	mov	sp, r7
 800ec20:	bd80      	pop	{r7, pc}
 800ec22:	bf00      	nop
 800ec24:	24061e9c 	.word	0x24061e9c
 800ec28:	08022860 	.word	0x08022860
 800ec2c:	24061e94 	.word	0x24061e94
 800ec30:	240622fc 	.word	0x240622fc
 800ec34:	80808081 	.word	0x80808081
 800ec38:	24062348 	.word	0x24062348
 800ec3c:	43870000 	.word	0x43870000
 800ec40:	437f0000 	.word	0x437f0000
 800ec44:	24062350 	.word	0x24062350

0800ec48 <updateRegen>:

static void updateRegen(){
 800ec48:	b580      	push	{r7, lr}
 800ec4a:	b082      	sub	sp, #8
 800ec4c:	af00      	add	r7, sp, #0
	uint8_t buf[8];
	sprintf(buf, "%03d", state.regen);
 800ec4e:	4b1f      	ldr	r3, [pc, #124]	; (800eccc <updateRegen+0x84>)
 800ec50:	79db      	ldrb	r3, [r3, #7]
 800ec52:	461a      	mov	r2, r3
 800ec54:	463b      	mov	r3, r7
 800ec56:	491e      	ldr	r1, [pc, #120]	; (800ecd0 <updateRegen+0x88>)
 800ec58:	4618      	mov	r0, r3
 800ec5a:	f013 f8e7 	bl	8021e2c <siprintf>
	xSemaphoreTake(dispMtx, portMAX_DELAY);
 800ec5e:	4b1d      	ldr	r3, [pc, #116]	; (800ecd4 <updateRegen+0x8c>)
 800ec60:	681b      	ldr	r3, [r3, #0]
 800ec62:	f04f 31ff 	mov.w	r1, #4294967295
 800ec66:	4618      	mov	r0, r3
 800ec68:	f7fc f942 	bl	800aef0 <xQueueSemaphoreTake>
	lv_arc_set_angles(motRegenArc, 315-(int)((float)state.regen*270.0f/255.0f), 315);
 800ec6c:	4b1a      	ldr	r3, [pc, #104]	; (800ecd8 <updateRegen+0x90>)
 800ec6e:	6818      	ldr	r0, [r3, #0]
 800ec70:	4b16      	ldr	r3, [pc, #88]	; (800eccc <updateRegen+0x84>)
 800ec72:	79db      	ldrb	r3, [r3, #7]
 800ec74:	ee07 3a90 	vmov	s15, r3
 800ec78:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800ec7c:	ed9f 7a17 	vldr	s14, [pc, #92]	; 800ecdc <updateRegen+0x94>
 800ec80:	ee27 7a87 	vmul.f32	s14, s15, s14
 800ec84:	eddf 6a16 	vldr	s13, [pc, #88]	; 800ece0 <updateRegen+0x98>
 800ec88:	eec7 7a26 	vdiv.f32	s15, s14, s13
 800ec8c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 800ec90:	ee17 3a90 	vmov	r3, s15
 800ec94:	b29a      	uxth	r2, r3
 800ec96:	f240 133b 	movw	r3, #315	; 0x13b
 800ec9a:	1a9b      	subs	r3, r3, r2
 800ec9c:	b29b      	uxth	r3, r3
 800ec9e:	f240 123b 	movw	r2, #315	; 0x13b
 800eca2:	4619      	mov	r1, r3
 800eca4:	f010 fa20 	bl	801f0e8 <lv_arc_set_angles>
	lv_label_set_text(motRegenLabel, buf);
 800eca8:	4b0e      	ldr	r3, [pc, #56]	; (800ece4 <updateRegen+0x9c>)
 800ecaa:	681b      	ldr	r3, [r3, #0]
 800ecac:	463a      	mov	r2, r7
 800ecae:	4611      	mov	r1, r2
 800ecb0:	4618      	mov	r0, r3
 800ecb2:	f011 f8eb 	bl	801fe8c <lv_label_set_text>
	xSemaphoreGive(dispMtx);
 800ecb6:	4b07      	ldr	r3, [pc, #28]	; (800ecd4 <updateRegen+0x8c>)
 800ecb8:	6818      	ldr	r0, [r3, #0]
 800ecba:	2300      	movs	r3, #0
 800ecbc:	2200      	movs	r2, #0
 800ecbe:	2100      	movs	r1, #0
 800ecc0:	f7fb fe10 	bl	800a8e4 <xQueueGenericSend>
}
 800ecc4:	bf00      	nop
 800ecc6:	3708      	adds	r7, #8
 800ecc8:	46bd      	mov	sp, r7
 800ecca:	bd80      	pop	{r7, pc}
 800eccc:	24061e9c 	.word	0x24061e9c
 800ecd0:	08022860 	.word	0x08022860
 800ecd4:	24061e94 	.word	0x24061e94
 800ecd8:	2406234c 	.word	0x2406234c
 800ecdc:	43870000 	.word	0x43870000
 800ece0:	437f0000 	.word	0x437f0000
 800ece4:	24062354 	.word	0x24062354

0800ece8 <updateMotLcd>:

static void updateMotLcd(){
 800ece8:	b480      	push	{r7}
 800ecea:	af00      	add	r7, sp, #0

}
 800ecec:	bf00      	nop
 800ecee:	46bd      	mov	sp, r7
 800ecf0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ecf4:	4770      	bx	lr
	...

0800ecf8 <updateMotOnBox>:

static void updateMotOnBox(){
 800ecf8:	b580      	push	{r7, lr}
 800ecfa:	af00      	add	r7, sp, #0
	xSemaphoreTake(dispMtx, portMAX_DELAY);
 800ecfc:	4b0f      	ldr	r3, [pc, #60]	; (800ed3c <updateMotOnBox+0x44>)
 800ecfe:	681b      	ldr	r3, [r3, #0]
 800ed00:	f04f 31ff 	mov.w	r1, #4294967295
 800ed04:	4618      	mov	r0, r3
 800ed06:	f7fc f8f3 	bl	800aef0 <xQueueSemaphoreTake>
	lv_obj_set_hidden(motOnLabel, !state.motOnWindow);
 800ed0a:	4b0d      	ldr	r3, [pc, #52]	; (800ed40 <updateMotOnBox+0x48>)
 800ed0c:	681a      	ldr	r2, [r3, #0]
 800ed0e:	4b0d      	ldr	r3, [pc, #52]	; (800ed44 <updateMotOnBox+0x4c>)
 800ed10:	785b      	ldrb	r3, [r3, #1]
 800ed12:	f003 0308 	and.w	r3, r3, #8
 800ed16:	b2db      	uxtb	r3, r3
 800ed18:	2b00      	cmp	r3, #0
 800ed1a:	bf0c      	ite	eq
 800ed1c:	2301      	moveq	r3, #1
 800ed1e:	2300      	movne	r3, #0
 800ed20:	b2db      	uxtb	r3, r3
 800ed22:	4619      	mov	r1, r3
 800ed24:	4610      	mov	r0, r2
 800ed26:	f004 fe9e 	bl	8013a66 <lv_obj_set_hidden>
	xSemaphoreGive(dispMtx);
 800ed2a:	4b04      	ldr	r3, [pc, #16]	; (800ed3c <updateMotOnBox+0x44>)
 800ed2c:	6818      	ldr	r0, [r3, #0]
 800ed2e:	2300      	movs	r3, #0
 800ed30:	2200      	movs	r2, #0
 800ed32:	2100      	movs	r1, #0
 800ed34:	f7fb fdd6 	bl	800a8e4 <xQueueGenericSend>
}
 800ed38:	bf00      	nop
 800ed3a:	bd80      	pop	{r7, pc}
 800ed3c:	24061e94 	.word	0x24061e94
 800ed40:	24062308 	.word	0x24062308
 800ed44:	24061e9c 	.word	0x24061e9c

0800ed48 <disp_setMCMBPulseFreq>:
//######### ##     ## ## ## ## ##     ## ##       ######   ########   ######
//##     ## ######### ##  #### ##     ## ##       ##       ##   ##         ##
//##     ## ##     ## ##   ### ##     ## ##       ##       ##    ##  ##    ##
//##     ## ##     ## ##    ## ########  ######## ######## ##     ##  ######

void disp_setMCMBPulseFreq(uint32_t hz){ // critical
 800ed48:	b580      	push	{r7, lr}
 800ed4a:	b082      	sub	sp, #8
 800ed4c:	af00      	add	r7, sp, #0
 800ed4e:	6078      	str	r0, [r7, #4]
	state.speedPulse = hz;
 800ed50:	687b      	ldr	r3, [r7, #4]
 800ed52:	b29a      	uxth	r2, r3
 800ed54:	4b03      	ldr	r3, [pc, #12]	; (800ed64 <disp_setMCMBPulseFreq+0x1c>)
 800ed56:	809a      	strh	r2, [r3, #4]
	updateMotSpeed();
 800ed58:	f7ff fe0e 	bl	800e978 <updateMotSpeed>
}
 800ed5c:	bf00      	nop
 800ed5e:	3708      	adds	r7, #8
 800ed60:	46bd      	mov	sp, r7
 800ed62:	bd80      	pop	{r7, pc}
 800ed64:	24061e9c 	.word	0x24061e9c

0800ed68 <disp_setMCMBFwdRev>:
	lv_obj_set_hidden(motPwrImg, !pwr);
	lv_obj_set_hidden(motEcoImg, pwr);
	xSemaphoreGive(dispMtx);
}

void disp_setMCMBFwdRev(uint8_t fwd){
 800ed68:	b580      	push	{r7, lr}
 800ed6a:	b082      	sub	sp, #8
 800ed6c:	af00      	add	r7, sp, #0
 800ed6e:	4603      	mov	r3, r0
 800ed70:	71fb      	strb	r3, [r7, #7]
	state.fwd = fwd;
 800ed72:	79fb      	ldrb	r3, [r7, #7]
 800ed74:	f003 0301 	and.w	r3, r3, #1
 800ed78:	b2d9      	uxtb	r1, r3
 800ed7a:	4a18      	ldr	r2, [pc, #96]	; (800eddc <disp_setMCMBFwdRev+0x74>)
 800ed7c:	7a13      	ldrb	r3, [r2, #8]
 800ed7e:	f361 0300 	bfi	r3, r1, #0, #1
 800ed82:	7213      	strb	r3, [r2, #8]
	updateGearLabel();
 800ed84:	f7ff fe58 	bl	800ea38 <updateGearLabel>
	xSemaphoreTake(dispMtx, portMAX_DELAY);
 800ed88:	4b15      	ldr	r3, [pc, #84]	; (800ede0 <disp_setMCMBFwdRev+0x78>)
 800ed8a:	681b      	ldr	r3, [r3, #0]
 800ed8c:	f04f 31ff 	mov.w	r1, #4294967295
 800ed90:	4618      	mov	r0, r3
 800ed92:	f7fc f8ad 	bl	800aef0 <xQueueSemaphoreTake>
//	if(state.page == 1){
	lv_obj_set_hidden(motFwdImg, !fwd);
 800ed96:	4b13      	ldr	r3, [pc, #76]	; (800ede4 <disp_setMCMBFwdRev+0x7c>)
 800ed98:	681a      	ldr	r2, [r3, #0]
 800ed9a:	79fb      	ldrb	r3, [r7, #7]
 800ed9c:	2b00      	cmp	r3, #0
 800ed9e:	bf0c      	ite	eq
 800eda0:	2301      	moveq	r3, #1
 800eda2:	2300      	movne	r3, #0
 800eda4:	b2db      	uxtb	r3, r3
 800eda6:	4619      	mov	r1, r3
 800eda8:	4610      	mov	r0, r2
 800edaa:	f004 fe5c 	bl	8013a66 <lv_obj_set_hidden>
	lv_obj_set_hidden(motRevImg, fwd);
 800edae:	4b0e      	ldr	r3, [pc, #56]	; (800ede8 <disp_setMCMBFwdRev+0x80>)
 800edb0:	681a      	ldr	r2, [r3, #0]
 800edb2:	79fb      	ldrb	r3, [r7, #7]
 800edb4:	2b00      	cmp	r3, #0
 800edb6:	bf14      	ite	ne
 800edb8:	2301      	movne	r3, #1
 800edba:	2300      	moveq	r3, #0
 800edbc:	b2db      	uxtb	r3, r3
 800edbe:	4619      	mov	r1, r3
 800edc0:	4610      	mov	r0, r2
 800edc2:	f004 fe50 	bl	8013a66 <lv_obj_set_hidden>
//	}
	xSemaphoreGive(dispMtx);
 800edc6:	4b06      	ldr	r3, [pc, #24]	; (800ede0 <disp_setMCMBFwdRev+0x78>)
 800edc8:	6818      	ldr	r0, [r3, #0]
 800edca:	2300      	movs	r3, #0
 800edcc:	2200      	movs	r2, #0
 800edce:	2100      	movs	r1, #0
 800edd0:	f7fb fd88 	bl	800a8e4 <xQueueGenericSend>
}
 800edd4:	bf00      	nop
 800edd6:	3708      	adds	r7, #8
 800edd8:	46bd      	mov	sp, r7
 800edda:	bd80      	pop	{r7, pc}
 800eddc:	24061e9c 	.word	0x24061e9c
 800ede0:	24061e94 	.word	0x24061e94
 800ede4:	24062330 	.word	0x24062330
 800ede8:	24062334 	.word	0x24062334

0800edec <disp_setDCMBLeftLightState>:
void disp_setPPTMBBusCurrent(uint32_t ma){
	arrayA = ma;
	updatePptPwr();
}

void disp_setDCMBLeftLightState(uint32_t on){ // critical
 800edec:	b580      	push	{r7, lr}
 800edee:	b082      	sub	sp, #8
 800edf0:	af00      	add	r7, sp, #0
 800edf2:	6078      	str	r0, [r7, #4]
	state.leftOn = on;
 800edf4:	687b      	ldr	r3, [r7, #4]
 800edf6:	f003 0301 	and.w	r3, r3, #1
 800edfa:	b2d9      	uxtb	r1, r3
 800edfc:	4a11      	ldr	r2, [pc, #68]	; (800ee44 <disp_setDCMBLeftLightState+0x58>)
 800edfe:	7a13      	ldrb	r3, [r2, #8]
 800ee00:	f361 0341 	bfi	r3, r1, #1, #1
 800ee04:	7213      	strb	r3, [r2, #8]
	xSemaphoreTake(dispMtx, portMAX_DELAY);
 800ee06:	4b10      	ldr	r3, [pc, #64]	; (800ee48 <disp_setDCMBLeftLightState+0x5c>)
 800ee08:	681b      	ldr	r3, [r3, #0]
 800ee0a:	f04f 31ff 	mov.w	r1, #4294967295
 800ee0e:	4618      	mov	r0, r3
 800ee10:	f7fc f86e 	bl	800aef0 <xQueueSemaphoreTake>
	lv_obj_set_hidden(leftArrowImg, !on);
 800ee14:	4b0d      	ldr	r3, [pc, #52]	; (800ee4c <disp_setDCMBLeftLightState+0x60>)
 800ee16:	681a      	ldr	r2, [r3, #0]
 800ee18:	687b      	ldr	r3, [r7, #4]
 800ee1a:	2b00      	cmp	r3, #0
 800ee1c:	bf0c      	ite	eq
 800ee1e:	2301      	moveq	r3, #1
 800ee20:	2300      	movne	r3, #0
 800ee22:	b2db      	uxtb	r3, r3
 800ee24:	4619      	mov	r1, r3
 800ee26:	4610      	mov	r0, r2
 800ee28:	f004 fe1d 	bl	8013a66 <lv_obj_set_hidden>
	xSemaphoreGive(dispMtx);
 800ee2c:	4b06      	ldr	r3, [pc, #24]	; (800ee48 <disp_setDCMBLeftLightState+0x5c>)
 800ee2e:	6818      	ldr	r0, [r3, #0]
 800ee30:	2300      	movs	r3, #0
 800ee32:	2200      	movs	r2, #0
 800ee34:	2100      	movs	r1, #0
 800ee36:	f7fb fd55 	bl	800a8e4 <xQueueGenericSend>
}
 800ee3a:	bf00      	nop
 800ee3c:	3708      	adds	r7, #8
 800ee3e:	46bd      	mov	sp, r7
 800ee40:	bd80      	pop	{r7, pc}
 800ee42:	bf00      	nop
 800ee44:	24061e9c 	.word	0x24061e9c
 800ee48:	24061e94 	.word	0x24061e94
 800ee4c:	24062310 	.word	0x24062310

0800ee50 <disp_setDCMBRightLightState>:

void disp_setDCMBRightLightState(uint32_t on){ // critical
 800ee50:	b580      	push	{r7, lr}
 800ee52:	b082      	sub	sp, #8
 800ee54:	af00      	add	r7, sp, #0
 800ee56:	6078      	str	r0, [r7, #4]
	state.rightOn = on;
 800ee58:	687b      	ldr	r3, [r7, #4]
 800ee5a:	f003 0301 	and.w	r3, r3, #1
 800ee5e:	b2d9      	uxtb	r1, r3
 800ee60:	4a11      	ldr	r2, [pc, #68]	; (800eea8 <disp_setDCMBRightLightState+0x58>)
 800ee62:	7a13      	ldrb	r3, [r2, #8]
 800ee64:	f361 0382 	bfi	r3, r1, #2, #1
 800ee68:	7213      	strb	r3, [r2, #8]
	xSemaphoreTake(dispMtx, portMAX_DELAY);
 800ee6a:	4b10      	ldr	r3, [pc, #64]	; (800eeac <disp_setDCMBRightLightState+0x5c>)
 800ee6c:	681b      	ldr	r3, [r3, #0]
 800ee6e:	f04f 31ff 	mov.w	r1, #4294967295
 800ee72:	4618      	mov	r0, r3
 800ee74:	f7fc f83c 	bl	800aef0 <xQueueSemaphoreTake>
	lv_obj_set_hidden(rightArrowImg, !on);
 800ee78:	4b0d      	ldr	r3, [pc, #52]	; (800eeb0 <disp_setDCMBRightLightState+0x60>)
 800ee7a:	681a      	ldr	r2, [r3, #0]
 800ee7c:	687b      	ldr	r3, [r7, #4]
 800ee7e:	2b00      	cmp	r3, #0
 800ee80:	bf0c      	ite	eq
 800ee82:	2301      	moveq	r3, #1
 800ee84:	2300      	movne	r3, #0
 800ee86:	b2db      	uxtb	r3, r3
 800ee88:	4619      	mov	r1, r3
 800ee8a:	4610      	mov	r0, r2
 800ee8c:	f004 fdeb 	bl	8013a66 <lv_obj_set_hidden>
	xSemaphoreGive(dispMtx);
 800ee90:	4b06      	ldr	r3, [pc, #24]	; (800eeac <disp_setDCMBRightLightState+0x5c>)
 800ee92:	6818      	ldr	r0, [r3, #0]
 800ee94:	2300      	movs	r3, #0
 800ee96:	2200      	movs	r2, #0
 800ee98:	2100      	movs	r1, #0
 800ee9a:	f7fb fd23 	bl	800a8e4 <xQueueGenericSend>
}
 800ee9e:	bf00      	nop
 800eea0:	3708      	adds	r7, #8
 800eea2:	46bd      	mov	sp, r7
 800eea4:	bd80      	pop	{r7, pc}
 800eea6:	bf00      	nop
 800eea8:	24061e9c 	.word	0x24061e9c
 800eeac:	24061e94 	.word	0x24061e94
 800eeb0:	24062314 	.word	0x24062314

0800eeb4 <disp_setDCMBStopLightState>:

void disp_setDCMBStopLightState(uint32_t on){ // critical
 800eeb4:	b580      	push	{r7, lr}
 800eeb6:	b082      	sub	sp, #8
 800eeb8:	af00      	add	r7, sp, #0
 800eeba:	6078      	str	r0, [r7, #4]
	state.stopOn = on;
 800eebc:	687b      	ldr	r3, [r7, #4]
 800eebe:	f003 0301 	and.w	r3, r3, #1
 800eec2:	b2d9      	uxtb	r1, r3
 800eec4:	4a11      	ldr	r2, [pc, #68]	; (800ef0c <disp_setDCMBStopLightState+0x58>)
 800eec6:	7a13      	ldrb	r3, [r2, #8]
 800eec8:	f361 03c3 	bfi	r3, r1, #3, #1
 800eecc:	7213      	strb	r3, [r2, #8]
	xSemaphoreTake(dispMtx, portMAX_DELAY);
 800eece:	4b10      	ldr	r3, [pc, #64]	; (800ef10 <disp_setDCMBStopLightState+0x5c>)
 800eed0:	681b      	ldr	r3, [r3, #0]
 800eed2:	f04f 31ff 	mov.w	r1, #4294967295
 800eed6:	4618      	mov	r0, r3
 800eed8:	f7fc f80a 	bl	800aef0 <xQueueSemaphoreTake>
	lv_obj_set_hidden(stopSignImg, !on);
 800eedc:	4b0d      	ldr	r3, [pc, #52]	; (800ef14 <disp_setDCMBStopLightState+0x60>)
 800eede:	681a      	ldr	r2, [r3, #0]
 800eee0:	687b      	ldr	r3, [r7, #4]
 800eee2:	2b00      	cmp	r3, #0
 800eee4:	bf0c      	ite	eq
 800eee6:	2301      	moveq	r3, #1
 800eee8:	2300      	movne	r3, #0
 800eeea:	b2db      	uxtb	r3, r3
 800eeec:	4619      	mov	r1, r3
 800eeee:	4610      	mov	r0, r2
 800eef0:	f004 fdb9 	bl	8013a66 <lv_obj_set_hidden>
	xSemaphoreGive(dispMtx);
 800eef4:	4b06      	ldr	r3, [pc, #24]	; (800ef10 <disp_setDCMBStopLightState+0x5c>)
 800eef6:	6818      	ldr	r0, [r3, #0]
 800eef8:	2300      	movs	r3, #0
 800eefa:	2200      	movs	r2, #0
 800eefc:	2100      	movs	r1, #0
 800eefe:	f7fb fcf1 	bl	800a8e4 <xQueueGenericSend>
}
 800ef02:	bf00      	nop
 800ef04:	3708      	adds	r7, #8
 800ef06:	46bd      	mov	sp, r7
 800ef08:	bd80      	pop	{r7, pc}
 800ef0a:	bf00      	nop
 800ef0c:	24061e9c 	.word	0x24061e9c
 800ef10:	24061e94 	.word	0x24061e94
 800ef14:	24062318 	.word	0x24062318

0800ef18 <disp_setDCMBMotIgnitionState>:

void disp_setDCMBArrayIgnitionState(uint32_t on){
	state.arrOn = on;
	updatePptPwr();
}
void disp_setDCMBMotIgnitionState(uint32_t on){
 800ef18:	b580      	push	{r7, lr}
 800ef1a:	b082      	sub	sp, #8
 800ef1c:	af00      	add	r7, sp, #0
 800ef1e:	6078      	str	r0, [r7, #4]
	state.motOn = on;
 800ef20:	687b      	ldr	r3, [r7, #4]
 800ef22:	f003 0301 	and.w	r3, r3, #1
 800ef26:	b2d9      	uxtb	r1, r3
 800ef28:	4a22      	ldr	r2, [pc, #136]	; (800efb4 <disp_setDCMBMotIgnitionState+0x9c>)
 800ef2a:	78d3      	ldrb	r3, [r2, #3]
 800ef2c:	f361 1386 	bfi	r3, r1, #6, #1
 800ef30:	70d3      	strb	r3, [r2, #3]
	//updateMotOnSw();
	updateGearLabel();
 800ef32:	f7ff fd81 	bl	800ea38 <updateGearLabel>
	if(!on){
 800ef36:	687b      	ldr	r3, [r7, #4]
 800ef38:	2b00      	cmp	r3, #0
 800ef3a:	d137      	bne.n	800efac <disp_setDCMBMotIgnitionState+0x94>
		state.vfm = 1;
 800ef3c:	4a1d      	ldr	r2, [pc, #116]	; (800efb4 <disp_setDCMBMotIgnitionState+0x9c>)
 800ef3e:	78d3      	ldrb	r3, [r2, #3]
 800ef40:	2101      	movs	r1, #1
 800ef42:	f361 0303 	bfi	r3, r1, #0, #4
 800ef46:	70d3      	strb	r3, [r2, #3]
		updateVfm();
 800ef48:	f7ff fdb0 	bl	800eaac <updateVfm>
		if(vfmResetCallback) vfmResetCallback();
 800ef4c:	4b1a      	ldr	r3, [pc, #104]	; (800efb8 <disp_setDCMBMotIgnitionState+0xa0>)
 800ef4e:	681b      	ldr	r3, [r3, #0]
 800ef50:	2b00      	cmp	r3, #0
 800ef52:	d002      	beq.n	800ef5a <disp_setDCMBMotIgnitionState+0x42>
 800ef54:	4b18      	ldr	r3, [pc, #96]	; (800efb8 <disp_setDCMBMotIgnitionState+0xa0>)
 800ef56:	681b      	ldr	r3, [r3, #0]
 800ef58:	4798      	blx	r3
		state.mta = 0;
 800ef5a:	4a16      	ldr	r2, [pc, #88]	; (800efb4 <disp_setDCMBMotIgnitionState+0x9c>)
 800ef5c:	7893      	ldrb	r3, [r2, #2]
 800ef5e:	f36f 0344 	bfc	r3, #1, #4
 800ef62:	7093      	strb	r3, [r2, #2]
		updateMta();
 800ef64:	f7ff fdda 	bl	800eb1c <updateMta>
		if(mtaCallback) mtaCallback(0);
 800ef68:	4b14      	ldr	r3, [pc, #80]	; (800efbc <disp_setDCMBMotIgnitionState+0xa4>)
 800ef6a:	681b      	ldr	r3, [r3, #0]
 800ef6c:	2b00      	cmp	r3, #0
 800ef6e:	d003      	beq.n	800ef78 <disp_setDCMBMotIgnitionState+0x60>
 800ef70:	4b12      	ldr	r3, [pc, #72]	; (800efbc <disp_setDCMBMotIgnitionState+0xa4>)
 800ef72:	681b      	ldr	r3, [r3, #0]
 800ef74:	2000      	movs	r0, #0
 800ef76:	4798      	blx	r3
		state.acc = 0;
 800ef78:	4b0e      	ldr	r3, [pc, #56]	; (800efb4 <disp_setDCMBMotIgnitionState+0x9c>)
 800ef7a:	2200      	movs	r2, #0
 800ef7c:	719a      	strb	r2, [r3, #6]
		updateAcc();
 800ef7e:	f7ff fdfd 	bl	800eb7c <updateAcc>
		if(accResetCallback) accResetCallback();
 800ef82:	4b0f      	ldr	r3, [pc, #60]	; (800efc0 <disp_setDCMBMotIgnitionState+0xa8>)
 800ef84:	681b      	ldr	r3, [r3, #0]
 800ef86:	2b00      	cmp	r3, #0
 800ef88:	d002      	beq.n	800ef90 <disp_setDCMBMotIgnitionState+0x78>
 800ef8a:	4b0d      	ldr	r3, [pc, #52]	; (800efc0 <disp_setDCMBMotIgnitionState+0xa8>)
 800ef8c:	681b      	ldr	r3, [r3, #0]
 800ef8e:	4798      	blx	r3
		state.regen = 0;
 800ef90:	4b08      	ldr	r3, [pc, #32]	; (800efb4 <disp_setDCMBMotIgnitionState+0x9c>)
 800ef92:	2200      	movs	r2, #0
 800ef94:	71da      	strb	r2, [r3, #7]
		updateRegen();
 800ef96:	f7ff fe57 	bl	800ec48 <updateRegen>
		if(regenResetCallback) regenResetCallback();
 800ef9a:	4b0a      	ldr	r3, [pc, #40]	; (800efc4 <disp_setDCMBMotIgnitionState+0xac>)
 800ef9c:	681b      	ldr	r3, [r3, #0]
 800ef9e:	2b00      	cmp	r3, #0
 800efa0:	d002      	beq.n	800efa8 <disp_setDCMBMotIgnitionState+0x90>
 800efa2:	4b08      	ldr	r3, [pc, #32]	; (800efc4 <disp_setDCMBMotIgnitionState+0xac>)
 800efa4:	681b      	ldr	r3, [r3, #0]
 800efa6:	4798      	blx	r3
		updateMotLcd();
 800efa8:	f7ff fe9e 	bl	800ece8 <updateMotLcd>
	}
}
 800efac:	bf00      	nop
 800efae:	3708      	adds	r7, #8
 800efb0:	46bd      	mov	sp, r7
 800efb2:	bd80      	pop	{r7, pc}
 800efb4:	24061e9c 	.word	0x24061e9c
 800efb8:	24062494 	.word	0x24062494
 800efbc:	24062484 	.word	0x24062484
 800efc0:	2406248c 	.word	0x2406248c
 800efc4:	24062488 	.word	0x24062488

0800efc8 <disp_setDCMBAccPotPosition>:

void disp_setDCMBAccPotPosition(uint8_t x){
 800efc8:	b580      	push	{r7, lr}
 800efca:	b082      	sub	sp, #8
 800efcc:	af00      	add	r7, sp, #0
 800efce:	4603      	mov	r3, r0
 800efd0:	71fb      	strb	r3, [r7, #7]
	state.acc = x;
 800efd2:	4a04      	ldr	r2, [pc, #16]	; (800efe4 <disp_setDCMBAccPotPosition+0x1c>)
 800efd4:	79fb      	ldrb	r3, [r7, #7]
 800efd6:	7193      	strb	r3, [r2, #6]
	updateAcc();
 800efd8:	f7ff fdd0 	bl	800eb7c <updateAcc>
}
 800efdc:	bf00      	nop
 800efde:	3708      	adds	r7, #8
 800efe0:	46bd      	mov	sp, r7
 800efe2:	bd80      	pop	{r7, pc}
 800efe4:	24061e9c 	.word	0x24061e9c

0800efe8 <disp_attachVfmUpCallback>:

void disp_attachDriverAckCallback(void(*cb)(uint8_t x)){
	driverAckCallback = cb;
}

void disp_attachVfmUpCallback(void(*cb)(void)){
 800efe8:	b480      	push	{r7}
 800efea:	b083      	sub	sp, #12
 800efec:	af00      	add	r7, sp, #0
 800efee:	6078      	str	r0, [r7, #4]
	vfmUpCallback = cb;
 800eff0:	4a04      	ldr	r2, [pc, #16]	; (800f004 <disp_attachVfmUpCallback+0x1c>)
 800eff2:	687b      	ldr	r3, [r7, #4]
 800eff4:	6013      	str	r3, [r2, #0]
}
 800eff6:	bf00      	nop
 800eff8:	370c      	adds	r7, #12
 800effa:	46bd      	mov	sp, r7
 800effc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f000:	4770      	bx	lr
 800f002:	bf00      	nop
 800f004:	240624a0 	.word	0x240624a0

0800f008 <disp_attachVfmDownCallback>:

void disp_attachVfmDownCallback(void(*cb)(void)){
 800f008:	b480      	push	{r7}
 800f00a:	b083      	sub	sp, #12
 800f00c:	af00      	add	r7, sp, #0
 800f00e:	6078      	str	r0, [r7, #4]
	vfmDownCallback = cb;
 800f010:	4a04      	ldr	r2, [pc, #16]	; (800f024 <disp_attachVfmDownCallback+0x1c>)
 800f012:	687b      	ldr	r3, [r7, #4]
 800f014:	6013      	str	r3, [r2, #0]
}
 800f016:	bf00      	nop
 800f018:	370c      	adds	r7, #12
 800f01a:	46bd      	mov	sp, r7
 800f01c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f020:	4770      	bx	lr
 800f022:	bf00      	nop
 800f024:	2406249c 	.word	0x2406249c

0800f028 <disp_attachAccResetCallback>:

void disp_attachVfmResetCallback(void(*cb)(void)){
	vfmResetCallback = cb;
}

void disp_attachAccResetCallback(void(*cb)(void)){
 800f028:	b480      	push	{r7}
 800f02a:	b083      	sub	sp, #12
 800f02c:	af00      	add	r7, sp, #0
 800f02e:	6078      	str	r0, [r7, #4]
	accResetCallback = cb;
 800f030:	4a04      	ldr	r2, [pc, #16]	; (800f044 <disp_attachAccResetCallback+0x1c>)
 800f032:	687b      	ldr	r3, [r7, #4]
 800f034:	6013      	str	r3, [r2, #0]
}
 800f036:	bf00      	nop
 800f038:	370c      	adds	r7, #12
 800f03a:	46bd      	mov	sp, r7
 800f03c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f040:	4770      	bx	lr
 800f042:	bf00      	nop
 800f044:	2406248c 	.word	0x2406248c

0800f048 <disp_attachMotOnCallback>:

void disp_attachRegenResetCallback(void(*cb)(void)){
	regenResetCallback = cb;
}

void disp_attachMotOnCallback(void(*cb)(uint8_t on)){
 800f048:	b480      	push	{r7}
 800f04a:	b083      	sub	sp, #12
 800f04c:	af00      	add	r7, sp, #0
 800f04e:	6078      	str	r0, [r7, #4]
	motOnCallback = cb;
 800f050:	4a04      	ldr	r2, [pc, #16]	; (800f064 <disp_attachMotOnCallback+0x1c>)
 800f052:	687b      	ldr	r3, [r7, #4]
 800f054:	6013      	str	r3, [r2, #0]
}
 800f056:	bf00      	nop
 800f058:	370c      	adds	r7, #12
 800f05a:	46bd      	mov	sp, r7
 800f05c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f060:	4770      	bx	lr
 800f062:	bf00      	nop
 800f064:	24062490 	.word	0x24062490

0800f068 <disp_updateNavState>:

void disp_updateNavState(uint8_t up, uint8_t down, uint8_t left, uint8_t right, uint8_t sel, int16_t enc){
 800f068:	b590      	push	{r4, r7, lr}
 800f06a:	b085      	sub	sp, #20
 800f06c:	af00      	add	r7, sp, #0
 800f06e:	4604      	mov	r4, r0
 800f070:	4608      	mov	r0, r1
 800f072:	4611      	mov	r1, r2
 800f074:	461a      	mov	r2, r3
 800f076:	4623      	mov	r3, r4
 800f078:	71fb      	strb	r3, [r7, #7]
 800f07a:	4603      	mov	r3, r0
 800f07c:	71bb      	strb	r3, [r7, #6]
 800f07e:	460b      	mov	r3, r1
 800f080:	717b      	strb	r3, [r7, #5]
 800f082:	4613      	mov	r3, r2
 800f084:	713b      	strb	r3, [r7, #4]
	// edge detect
	int8_t upEdge = up-state.lastUp;
 800f086:	4b7e      	ldr	r3, [pc, #504]	; (800f280 <disp_updateNavState+0x218>)
 800f088:	785b      	ldrb	r3, [r3, #1]
 800f08a:	f3c3 1300 	ubfx	r3, r3, #4, #1
 800f08e:	b2db      	uxtb	r3, r3
 800f090:	461a      	mov	r2, r3
 800f092:	79fb      	ldrb	r3, [r7, #7]
 800f094:	1a9b      	subs	r3, r3, r2
 800f096:	b2db      	uxtb	r3, r3
 800f098:	73fb      	strb	r3, [r7, #15]
	int8_t downEdge = down-state.lastDown;
 800f09a:	4b79      	ldr	r3, [pc, #484]	; (800f280 <disp_updateNavState+0x218>)
 800f09c:	785b      	ldrb	r3, [r3, #1]
 800f09e:	f3c3 1340 	ubfx	r3, r3, #5, #1
 800f0a2:	b2db      	uxtb	r3, r3
 800f0a4:	461a      	mov	r2, r3
 800f0a6:	79bb      	ldrb	r3, [r7, #6]
 800f0a8:	1a9b      	subs	r3, r3, r2
 800f0aa:	b2db      	uxtb	r3, r3
 800f0ac:	73bb      	strb	r3, [r7, #14]
	int8_t leftEdge = left-state.lastLeft;
 800f0ae:	4b74      	ldr	r3, [pc, #464]	; (800f280 <disp_updateNavState+0x218>)
 800f0b0:	785b      	ldrb	r3, [r3, #1]
 800f0b2:	f3c3 1380 	ubfx	r3, r3, #6, #1
 800f0b6:	b2db      	uxtb	r3, r3
 800f0b8:	461a      	mov	r2, r3
 800f0ba:	797b      	ldrb	r3, [r7, #5]
 800f0bc:	1a9b      	subs	r3, r3, r2
 800f0be:	b2db      	uxtb	r3, r3
 800f0c0:	737b      	strb	r3, [r7, #13]
	int8_t rightEdge = right-state.lastRight;
 800f0c2:	4b6f      	ldr	r3, [pc, #444]	; (800f280 <disp_updateNavState+0x218>)
 800f0c4:	785b      	ldrb	r3, [r3, #1]
 800f0c6:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 800f0ca:	b2db      	uxtb	r3, r3
 800f0cc:	461a      	mov	r2, r3
 800f0ce:	793b      	ldrb	r3, [r7, #4]
 800f0d0:	1a9b      	subs	r3, r3, r2
 800f0d2:	b2db      	uxtb	r3, r3
 800f0d4:	733b      	strb	r3, [r7, #12]
	int8_t selEdge = sel-state.lastSel;
 800f0d6:	4b6a      	ldr	r3, [pc, #424]	; (800f280 <disp_updateNavState+0x218>)
 800f0d8:	789b      	ldrb	r3, [r3, #2]
 800f0da:	f3c3 0300 	ubfx	r3, r3, #0, #1
 800f0de:	b2db      	uxtb	r3, r3
 800f0e0:	461a      	mov	r2, r3
 800f0e2:	f897 3020 	ldrb.w	r3, [r7, #32]
 800f0e6:	1a9b      	subs	r3, r3, r2
 800f0e8:	b2db      	uxtb	r3, r3
 800f0ea:	72fb      	strb	r3, [r7, #11]
	// encoder accumulate
	state.encAcc += enc;
 800f0ec:	4b64      	ldr	r3, [pc, #400]	; (800f280 <disp_updateNavState+0x218>)
 800f0ee:	f993 3000 	ldrsb.w	r3, [r3]
 800f0f2:	b2da      	uxtb	r2, r3
 800f0f4:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800f0f6:	b2db      	uxtb	r3, r3
 800f0f8:	4413      	add	r3, r2
 800f0fa:	b2db      	uxtb	r3, r3
 800f0fc:	b25a      	sxtb	r2, r3
 800f0fe:	4b60      	ldr	r3, [pc, #384]	; (800f280 <disp_updateNavState+0x218>)
 800f100:	701a      	strb	r2, [r3, #0]
	// motor on logic
	if(state.motOnWindow == 1){
 800f102:	4b5f      	ldr	r3, [pc, #380]	; (800f280 <disp_updateNavState+0x218>)
 800f104:	785b      	ldrb	r3, [r3, #1]
 800f106:	f003 0308 	and.w	r3, r3, #8
 800f10a:	b2db      	uxtb	r3, r3
 800f10c:	2b00      	cmp	r3, #0
 800f10e:	d06f      	beq.n	800f1f0 <disp_updateNavState+0x188>
		if(selEdge == 1){
 800f110:	f997 300b 	ldrsb.w	r3, [r7, #11]
 800f114:	2b01      	cmp	r3, #1
 800f116:	d139      	bne.n	800f18c <disp_updateNavState+0x124>
			state.motOn = state.motOn ? 0 : 1;
 800f118:	4b59      	ldr	r3, [pc, #356]	; (800f280 <disp_updateNavState+0x218>)
 800f11a:	78db      	ldrb	r3, [r3, #3]
 800f11c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800f120:	b2db      	uxtb	r3, r3
 800f122:	2b00      	cmp	r3, #0
 800f124:	bf0c      	ite	eq
 800f126:	2301      	moveq	r3, #1
 800f128:	2300      	movne	r3, #0
 800f12a:	b2d9      	uxtb	r1, r3
 800f12c:	4a54      	ldr	r2, [pc, #336]	; (800f280 <disp_updateNavState+0x218>)
 800f12e:	78d3      	ldrb	r3, [r2, #3]
 800f130:	f361 1386 	bfi	r3, r1, #6, #1
 800f134:	70d3      	strb	r3, [r2, #3]
			state.motOnWindow = 0;
 800f136:	4a52      	ldr	r2, [pc, #328]	; (800f280 <disp_updateNavState+0x218>)
 800f138:	7853      	ldrb	r3, [r2, #1]
 800f13a:	f36f 03c3 	bfc	r3, #3, #1
 800f13e:	7053      	strb	r3, [r2, #1]
			updateMotOnBox();
 800f140:	f7ff fdda 	bl	800ecf8 <updateMotOnBox>
			disp_setDCMBMotIgnitionState(state.motOn);
 800f144:	4b4e      	ldr	r3, [pc, #312]	; (800f280 <disp_updateNavState+0x218>)
 800f146:	78db      	ldrb	r3, [r3, #3]
 800f148:	f3c3 1380 	ubfx	r3, r3, #6, #1
 800f14c:	b2db      	uxtb	r3, r3
 800f14e:	4618      	mov	r0, r3
 800f150:	f7ff fee2 	bl	800ef18 <disp_setDCMBMotIgnitionState>
			if(motOnCallback) motOnCallback(state.motOn);
 800f154:	4b4b      	ldr	r3, [pc, #300]	; (800f284 <disp_updateNavState+0x21c>)
 800f156:	681b      	ldr	r3, [r3, #0]
 800f158:	2b00      	cmp	r3, #0
 800f15a:	d008      	beq.n	800f16e <disp_updateNavState+0x106>
 800f15c:	4b49      	ldr	r3, [pc, #292]	; (800f284 <disp_updateNavState+0x21c>)
 800f15e:	681b      	ldr	r3, [r3, #0]
 800f160:	4a47      	ldr	r2, [pc, #284]	; (800f280 <disp_updateNavState+0x218>)
 800f162:	78d2      	ldrb	r2, [r2, #3]
 800f164:	f3c2 1280 	ubfx	r2, r2, #6, #1
 800f168:	b2d2      	uxtb	r2, r2
 800f16a:	4610      	mov	r0, r2
 800f16c:	4798      	blx	r3
			downEdge = upEdge = leftEdge = rightEdge = selEdge = state.encAcc = 0;
 800f16e:	4b44      	ldr	r3, [pc, #272]	; (800f280 <disp_updateNavState+0x218>)
 800f170:	2200      	movs	r2, #0
 800f172:	701a      	strb	r2, [r3, #0]
 800f174:	4b42      	ldr	r3, [pc, #264]	; (800f280 <disp_updateNavState+0x218>)
 800f176:	781b      	ldrb	r3, [r3, #0]
 800f178:	72fb      	strb	r3, [r7, #11]
 800f17a:	7afb      	ldrb	r3, [r7, #11]
 800f17c:	733b      	strb	r3, [r7, #12]
 800f17e:	7b3b      	ldrb	r3, [r7, #12]
 800f180:	737b      	strb	r3, [r7, #13]
 800f182:	7b7b      	ldrb	r3, [r7, #13]
 800f184:	73fb      	strb	r3, [r7, #15]
 800f186:	7bfb      	ldrb	r3, [r7, #15]
 800f188:	73bb      	strb	r3, [r7, #14]
 800f18a:	e157      	b.n	800f43c <disp_updateNavState+0x3d4>
		}else if(downEdge == 1 || upEdge == 1 || leftEdge == 1 || rightEdge == 1 || state.encAcc >= 2 || state.encAcc <= -2){
 800f18c:	f997 300e 	ldrsb.w	r3, [r7, #14]
 800f190:	2b01      	cmp	r3, #1
 800f192:	d017      	beq.n	800f1c4 <disp_updateNavState+0x15c>
 800f194:	f997 300f 	ldrsb.w	r3, [r7, #15]
 800f198:	2b01      	cmp	r3, #1
 800f19a:	d013      	beq.n	800f1c4 <disp_updateNavState+0x15c>
 800f19c:	f997 300d 	ldrsb.w	r3, [r7, #13]
 800f1a0:	2b01      	cmp	r3, #1
 800f1a2:	d00f      	beq.n	800f1c4 <disp_updateNavState+0x15c>
 800f1a4:	f997 300c 	ldrsb.w	r3, [r7, #12]
 800f1a8:	2b01      	cmp	r3, #1
 800f1aa:	d00b      	beq.n	800f1c4 <disp_updateNavState+0x15c>
 800f1ac:	4b34      	ldr	r3, [pc, #208]	; (800f280 <disp_updateNavState+0x218>)
 800f1ae:	f993 3000 	ldrsb.w	r3, [r3]
 800f1b2:	2b01      	cmp	r3, #1
 800f1b4:	dc06      	bgt.n	800f1c4 <disp_updateNavState+0x15c>
 800f1b6:	4b32      	ldr	r3, [pc, #200]	; (800f280 <disp_updateNavState+0x218>)
 800f1b8:	f993 3000 	ldrsb.w	r3, [r3]
 800f1bc:	f1b3 3fff 	cmp.w	r3, #4294967295
 800f1c0:	f280 813c 	bge.w	800f43c <disp_updateNavState+0x3d4>
			state.motOnWindow = 0;
 800f1c4:	4a2e      	ldr	r2, [pc, #184]	; (800f280 <disp_updateNavState+0x218>)
 800f1c6:	7853      	ldrb	r3, [r2, #1]
 800f1c8:	f36f 03c3 	bfc	r3, #3, #1
 800f1cc:	7053      	strb	r3, [r2, #1]
			updateMotOnBox();
 800f1ce:	f7ff fd93 	bl	800ecf8 <updateMotOnBox>
			downEdge = upEdge = leftEdge = rightEdge = selEdge = state.encAcc = 0;
 800f1d2:	4b2b      	ldr	r3, [pc, #172]	; (800f280 <disp_updateNavState+0x218>)
 800f1d4:	2200      	movs	r2, #0
 800f1d6:	701a      	strb	r2, [r3, #0]
 800f1d8:	4b29      	ldr	r3, [pc, #164]	; (800f280 <disp_updateNavState+0x218>)
 800f1da:	781b      	ldrb	r3, [r3, #0]
 800f1dc:	72fb      	strb	r3, [r7, #11]
 800f1de:	7afb      	ldrb	r3, [r7, #11]
 800f1e0:	733b      	strb	r3, [r7, #12]
 800f1e2:	7b3b      	ldrb	r3, [r7, #12]
 800f1e4:	737b      	strb	r3, [r7, #13]
 800f1e6:	7b7b      	ldrb	r3, [r7, #13]
 800f1e8:	73fb      	strb	r3, [r7, #15]
 800f1ea:	7bfb      	ldrb	r3, [r7, #15]
 800f1ec:	73bb      	strb	r3, [r7, #14]
 800f1ee:	e125      	b.n	800f43c <disp_updateNavState+0x3d4>
		}
	}else{
		if(state.page == 0){
 800f1f0:	4b23      	ldr	r3, [pc, #140]	; (800f280 <disp_updateNavState+0x218>)
 800f1f2:	785b      	ldrb	r3, [r3, #1]
 800f1f4:	f003 0302 	and.w	r3, r3, #2
 800f1f8:	b2db      	uxtb	r3, r3
 800f1fa:	2b00      	cmp	r3, #0
 800f1fc:	d118      	bne.n	800f230 <disp_updateNavState+0x1c8>
			if(downEdge == 1){
 800f1fe:	f997 300e 	ldrsb.w	r3, [r7, #14]
 800f202:	2b01      	cmp	r3, #1
 800f204:	d114      	bne.n	800f230 <disp_updateNavState+0x1c8>
				state.motOnWindow = 1;
 800f206:	4a1e      	ldr	r2, [pc, #120]	; (800f280 <disp_updateNavState+0x218>)
 800f208:	7853      	ldrb	r3, [r2, #1]
 800f20a:	f043 0308 	orr.w	r3, r3, #8
 800f20e:	7053      	strb	r3, [r2, #1]
				updateMotOnBox();
 800f210:	f7ff fd72 	bl	800ecf8 <updateMotOnBox>
				downEdge = upEdge = leftEdge = rightEdge = selEdge = state.encAcc = 0;
 800f214:	4b1a      	ldr	r3, [pc, #104]	; (800f280 <disp_updateNavState+0x218>)
 800f216:	2200      	movs	r2, #0
 800f218:	701a      	strb	r2, [r3, #0]
 800f21a:	4b19      	ldr	r3, [pc, #100]	; (800f280 <disp_updateNavState+0x218>)
 800f21c:	781b      	ldrb	r3, [r3, #0]
 800f21e:	72fb      	strb	r3, [r7, #11]
 800f220:	7afb      	ldrb	r3, [r7, #11]
 800f222:	733b      	strb	r3, [r7, #12]
 800f224:	7b3b      	ldrb	r3, [r7, #12]
 800f226:	737b      	strb	r3, [r7, #13]
 800f228:	7b7b      	ldrb	r3, [r7, #13]
 800f22a:	73fb      	strb	r3, [r7, #15]
 800f22c:	7bfb      	ldrb	r3, [r7, #15]
 800f22e:	73bb      	strb	r3, [r7, #14]
			}
		}
		// page select
		if(state.encAcc >= 2){
 800f230:	4b13      	ldr	r3, [pc, #76]	; (800f280 <disp_updateNavState+0x218>)
 800f232:	f993 3000 	ldrsb.w	r3, [r3]
 800f236:	2b01      	cmp	r3, #1
 800f238:	dd26      	ble.n	800f288 <disp_updateNavState+0x220>
			if(state.page < 2) state.page++;
 800f23a:	4b11      	ldr	r3, [pc, #68]	; (800f280 <disp_updateNavState+0x218>)
 800f23c:	785b      	ldrb	r3, [r3, #1]
 800f23e:	f3c3 0340 	ubfx	r3, r3, #1, #1
 800f242:	b2db      	uxtb	r3, r3
 800f244:	3301      	adds	r3, #1
 800f246:	f003 0301 	and.w	r3, r3, #1
 800f24a:	b2d9      	uxtb	r1, r3
 800f24c:	4a0c      	ldr	r2, [pc, #48]	; (800f280 <disp_updateNavState+0x218>)
 800f24e:	7853      	ldrb	r3, [r2, #1]
 800f250:	f361 0341 	bfi	r3, r1, #1, #1
 800f254:	7053      	strb	r3, [r2, #1]
			state.encAcc = 0;
 800f256:	4b0a      	ldr	r3, [pc, #40]	; (800f280 <disp_updateNavState+0x218>)
 800f258:	2200      	movs	r2, #0
 800f25a:	701a      	strb	r2, [r3, #0]
			if(state.page == 1){
 800f25c:	4b08      	ldr	r3, [pc, #32]	; (800f280 <disp_updateNavState+0x218>)
 800f25e:	785b      	ldrb	r3, [r3, #1]
 800f260:	f003 0302 	and.w	r3, r3, #2
 800f264:	b2db      	uxtb	r3, r3
 800f266:	2b00      	cmp	r3, #0
 800f268:	d04c      	beq.n	800f304 <disp_updateNavState+0x29c>
				showMainPage(0);
 800f26a:	2000      	movs	r0, #0
 800f26c:	f7ff f8f6 	bl	800e45c <showMainPage>
				showMotPage(1);
 800f270:	2001      	movs	r0, #1
 800f272:	f7ff f979 	bl	800e568 <showMotPage>
				showTextPage(0);
 800f276:	2000      	movs	r0, #0
 800f278:	f7ff fa20 	bl	800e6bc <showTextPage>
 800f27c:	e042      	b.n	800f304 <disp_updateNavState+0x29c>
 800f27e:	bf00      	nop
 800f280:	24061e9c 	.word	0x24061e9c
 800f284:	24062490 	.word	0x24062490
			if(state.page == 2){
				showMainPage(0);
				showMotPage(0);
				showTextPage(1);
			}
		}else if(state.encAcc <= -2){
 800f288:	4b80      	ldr	r3, [pc, #512]	; (800f48c <disp_updateNavState+0x424>)
 800f28a:	f993 3000 	ldrsb.w	r3, [r3]
 800f28e:	f1b3 3fff 	cmp.w	r3, #4294967295
 800f292:	da37      	bge.n	800f304 <disp_updateNavState+0x29c>
			if(state.page > 0) state.page--;
 800f294:	4b7d      	ldr	r3, [pc, #500]	; (800f48c <disp_updateNavState+0x424>)
 800f296:	785b      	ldrb	r3, [r3, #1]
 800f298:	f003 0302 	and.w	r3, r3, #2
 800f29c:	b2db      	uxtb	r3, r3
 800f29e:	2b00      	cmp	r3, #0
 800f2a0:	d00d      	beq.n	800f2be <disp_updateNavState+0x256>
 800f2a2:	4b7a      	ldr	r3, [pc, #488]	; (800f48c <disp_updateNavState+0x424>)
 800f2a4:	785b      	ldrb	r3, [r3, #1]
 800f2a6:	f3c3 0340 	ubfx	r3, r3, #1, #1
 800f2aa:	b2db      	uxtb	r3, r3
 800f2ac:	3301      	adds	r3, #1
 800f2ae:	f003 0301 	and.w	r3, r3, #1
 800f2b2:	b2d9      	uxtb	r1, r3
 800f2b4:	4a75      	ldr	r2, [pc, #468]	; (800f48c <disp_updateNavState+0x424>)
 800f2b6:	7853      	ldrb	r3, [r2, #1]
 800f2b8:	f361 0341 	bfi	r3, r1, #1, #1
 800f2bc:	7053      	strb	r3, [r2, #1]
			state.encAcc = 0;
 800f2be:	4b73      	ldr	r3, [pc, #460]	; (800f48c <disp_updateNavState+0x424>)
 800f2c0:	2200      	movs	r2, #0
 800f2c2:	701a      	strb	r2, [r3, #0]
			if(state.page == 0){
 800f2c4:	4b71      	ldr	r3, [pc, #452]	; (800f48c <disp_updateNavState+0x424>)
 800f2c6:	785b      	ldrb	r3, [r3, #1]
 800f2c8:	f003 0302 	and.w	r3, r3, #2
 800f2cc:	b2db      	uxtb	r3, r3
 800f2ce:	2b00      	cmp	r3, #0
 800f2d0:	d108      	bne.n	800f2e4 <disp_updateNavState+0x27c>
				showMotPage(0);
 800f2d2:	2000      	movs	r0, #0
 800f2d4:	f7ff f948 	bl	800e568 <showMotPage>
				showMainPage(1);
 800f2d8:	2001      	movs	r0, #1
 800f2da:	f7ff f8bf 	bl	800e45c <showMainPage>
				showTextPage(0);
 800f2de:	2000      	movs	r0, #0
 800f2e0:	f7ff f9ec 	bl	800e6bc <showTextPage>
			}
			if(state.page == 1){
 800f2e4:	4b69      	ldr	r3, [pc, #420]	; (800f48c <disp_updateNavState+0x424>)
 800f2e6:	785b      	ldrb	r3, [r3, #1]
 800f2e8:	f003 0302 	and.w	r3, r3, #2
 800f2ec:	b2db      	uxtb	r3, r3
 800f2ee:	2b00      	cmp	r3, #0
 800f2f0:	d008      	beq.n	800f304 <disp_updateNavState+0x29c>
				showMotPage(1);
 800f2f2:	2001      	movs	r0, #1
 800f2f4:	f7ff f938 	bl	800e568 <showMotPage>
				showMainPage(0);
 800f2f8:	2000      	movs	r0, #0
 800f2fa:	f7ff f8af 	bl	800e45c <showMainPage>
				showTextPage(0);
 800f2fe:	2000      	movs	r0, #0
 800f300:	f7ff f9dc 	bl	800e6bc <showTextPage>
			}
		}
		// mot page logic
		if(state.page == 1){
 800f304:	4b61      	ldr	r3, [pc, #388]	; (800f48c <disp_updateNavState+0x424>)
 800f306:	785b      	ldrb	r3, [r3, #1]
 800f308:	f003 0302 	and.w	r3, r3, #2
 800f30c:	b2db      	uxtb	r3, r3
 800f30e:	2b00      	cmp	r3, #0
 800f310:	f000 8094 	beq.w	800f43c <disp_updateNavState+0x3d4>
			if(downEdge == 1){
 800f314:	f997 300e 	ldrsb.w	r3, [r7, #14]
 800f318:	2b01      	cmp	r3, #1
 800f31a:	d11d      	bne.n	800f358 <disp_updateNavState+0x2f0>
				if(state.vfm > 1){
 800f31c:	4b5b      	ldr	r3, [pc, #364]	; (800f48c <disp_updateNavState+0x424>)
 800f31e:	78db      	ldrb	r3, [r3, #3]
 800f320:	f3c3 0303 	ubfx	r3, r3, #0, #4
 800f324:	b2db      	uxtb	r3, r3
 800f326:	2b01      	cmp	r3, #1
 800f328:	d916      	bls.n	800f358 <disp_updateNavState+0x2f0>
					state.vfm--;
 800f32a:	4b58      	ldr	r3, [pc, #352]	; (800f48c <disp_updateNavState+0x424>)
 800f32c:	78db      	ldrb	r3, [r3, #3]
 800f32e:	f3c3 0303 	ubfx	r3, r3, #0, #4
 800f332:	b2db      	uxtb	r3, r3
 800f334:	330f      	adds	r3, #15
 800f336:	f003 030f 	and.w	r3, r3, #15
 800f33a:	b2d9      	uxtb	r1, r3
 800f33c:	4a53      	ldr	r2, [pc, #332]	; (800f48c <disp_updateNavState+0x424>)
 800f33e:	78d3      	ldrb	r3, [r2, #3]
 800f340:	f361 0303 	bfi	r3, r1, #0, #4
 800f344:	70d3      	strb	r3, [r2, #3]
					updateVfm();
 800f346:	f7ff fbb1 	bl	800eaac <updateVfm>
					if(vfmDownCallback) vfmDownCallback();
 800f34a:	4b51      	ldr	r3, [pc, #324]	; (800f490 <disp_updateNavState+0x428>)
 800f34c:	681b      	ldr	r3, [r3, #0]
 800f34e:	2b00      	cmp	r3, #0
 800f350:	d002      	beq.n	800f358 <disp_updateNavState+0x2f0>
 800f352:	4b4f      	ldr	r3, [pc, #316]	; (800f490 <disp_updateNavState+0x428>)
 800f354:	681b      	ldr	r3, [r3, #0]
 800f356:	4798      	blx	r3
				}
			}
			if(upEdge == 1){
 800f358:	f997 300f 	ldrsb.w	r3, [r7, #15]
 800f35c:	2b01      	cmp	r3, #1
 800f35e:	d11d      	bne.n	800f39c <disp_updateNavState+0x334>
				if(state.vfm < 8){
 800f360:	4b4a      	ldr	r3, [pc, #296]	; (800f48c <disp_updateNavState+0x424>)
 800f362:	78db      	ldrb	r3, [r3, #3]
 800f364:	f3c3 0303 	ubfx	r3, r3, #0, #4
 800f368:	b2db      	uxtb	r3, r3
 800f36a:	2b07      	cmp	r3, #7
 800f36c:	d816      	bhi.n	800f39c <disp_updateNavState+0x334>
					state.vfm++;
 800f36e:	4b47      	ldr	r3, [pc, #284]	; (800f48c <disp_updateNavState+0x424>)
 800f370:	78db      	ldrb	r3, [r3, #3]
 800f372:	f3c3 0303 	ubfx	r3, r3, #0, #4
 800f376:	b2db      	uxtb	r3, r3
 800f378:	3301      	adds	r3, #1
 800f37a:	f003 030f 	and.w	r3, r3, #15
 800f37e:	b2d9      	uxtb	r1, r3
 800f380:	4a42      	ldr	r2, [pc, #264]	; (800f48c <disp_updateNavState+0x424>)
 800f382:	78d3      	ldrb	r3, [r2, #3]
 800f384:	f361 0303 	bfi	r3, r1, #0, #4
 800f388:	70d3      	strb	r3, [r2, #3]
					updateVfm();
 800f38a:	f7ff fb8f 	bl	800eaac <updateVfm>
					if(vfmUpCallback) vfmUpCallback();
 800f38e:	4b41      	ldr	r3, [pc, #260]	; (800f494 <disp_updateNavState+0x42c>)
 800f390:	681b      	ldr	r3, [r3, #0]
 800f392:	2b00      	cmp	r3, #0
 800f394:	d002      	beq.n	800f39c <disp_updateNavState+0x334>
 800f396:	4b3f      	ldr	r3, [pc, #252]	; (800f494 <disp_updateNavState+0x42c>)
 800f398:	681b      	ldr	r3, [r3, #0]
 800f39a:	4798      	blx	r3
				}
			}
			if(leftEdge == 1){
 800f39c:	f997 300d 	ldrsb.w	r3, [r7, #13]
 800f3a0:	2b01      	cmp	r3, #1
 800f3a2:	d123      	bne.n	800f3ec <disp_updateNavState+0x384>
				if(state.mta > 0){
 800f3a4:	4b39      	ldr	r3, [pc, #228]	; (800f48c <disp_updateNavState+0x424>)
 800f3a6:	789b      	ldrb	r3, [r3, #2]
 800f3a8:	f003 031e 	and.w	r3, r3, #30
 800f3ac:	b2db      	uxtb	r3, r3
 800f3ae:	2b00      	cmp	r3, #0
 800f3b0:	d01c      	beq.n	800f3ec <disp_updateNavState+0x384>
					state.mta--;
 800f3b2:	4b36      	ldr	r3, [pc, #216]	; (800f48c <disp_updateNavState+0x424>)
 800f3b4:	789b      	ldrb	r3, [r3, #2]
 800f3b6:	f3c3 0343 	ubfx	r3, r3, #1, #4
 800f3ba:	b2db      	uxtb	r3, r3
 800f3bc:	330f      	adds	r3, #15
 800f3be:	f003 030f 	and.w	r3, r3, #15
 800f3c2:	b2d9      	uxtb	r1, r3
 800f3c4:	4a31      	ldr	r2, [pc, #196]	; (800f48c <disp_updateNavState+0x424>)
 800f3c6:	7893      	ldrb	r3, [r2, #2]
 800f3c8:	f361 0344 	bfi	r3, r1, #1, #4
 800f3cc:	7093      	strb	r3, [r2, #2]
					updateMta();
 800f3ce:	f7ff fba5 	bl	800eb1c <updateMta>
					if(mtaCallback) mtaCallback(state.mta);
 800f3d2:	4b31      	ldr	r3, [pc, #196]	; (800f498 <disp_updateNavState+0x430>)
 800f3d4:	681b      	ldr	r3, [r3, #0]
 800f3d6:	2b00      	cmp	r3, #0
 800f3d8:	d008      	beq.n	800f3ec <disp_updateNavState+0x384>
 800f3da:	4b2f      	ldr	r3, [pc, #188]	; (800f498 <disp_updateNavState+0x430>)
 800f3dc:	681b      	ldr	r3, [r3, #0]
 800f3de:	4a2b      	ldr	r2, [pc, #172]	; (800f48c <disp_updateNavState+0x424>)
 800f3e0:	7892      	ldrb	r2, [r2, #2]
 800f3e2:	f3c2 0243 	ubfx	r2, r2, #1, #4
 800f3e6:	b2d2      	uxtb	r2, r2
 800f3e8:	4610      	mov	r0, r2
 800f3ea:	4798      	blx	r3
				}
			}
			if(rightEdge == 1){
 800f3ec:	f997 300c 	ldrsb.w	r3, [r7, #12]
 800f3f0:	2b01      	cmp	r3, #1
 800f3f2:	d123      	bne.n	800f43c <disp_updateNavState+0x3d4>
				if(state.mta < 15){
 800f3f4:	4b25      	ldr	r3, [pc, #148]	; (800f48c <disp_updateNavState+0x424>)
 800f3f6:	789b      	ldrb	r3, [r3, #2]
 800f3f8:	f003 031e 	and.w	r3, r3, #30
 800f3fc:	b2db      	uxtb	r3, r3
 800f3fe:	2b1e      	cmp	r3, #30
 800f400:	d01c      	beq.n	800f43c <disp_updateNavState+0x3d4>
					state.mta++;
 800f402:	4b22      	ldr	r3, [pc, #136]	; (800f48c <disp_updateNavState+0x424>)
 800f404:	789b      	ldrb	r3, [r3, #2]
 800f406:	f3c3 0343 	ubfx	r3, r3, #1, #4
 800f40a:	b2db      	uxtb	r3, r3
 800f40c:	3301      	adds	r3, #1
 800f40e:	f003 030f 	and.w	r3, r3, #15
 800f412:	b2d9      	uxtb	r1, r3
 800f414:	4a1d      	ldr	r2, [pc, #116]	; (800f48c <disp_updateNavState+0x424>)
 800f416:	7893      	ldrb	r3, [r2, #2]
 800f418:	f361 0344 	bfi	r3, r1, #1, #4
 800f41c:	7093      	strb	r3, [r2, #2]
					updateMta();
 800f41e:	f7ff fb7d 	bl	800eb1c <updateMta>
					if(mtaCallback) mtaCallback(state.mta);
 800f422:	4b1d      	ldr	r3, [pc, #116]	; (800f498 <disp_updateNavState+0x430>)
 800f424:	681b      	ldr	r3, [r3, #0]
 800f426:	2b00      	cmp	r3, #0
 800f428:	d008      	beq.n	800f43c <disp_updateNavState+0x3d4>
 800f42a:	4b1b      	ldr	r3, [pc, #108]	; (800f498 <disp_updateNavState+0x430>)
 800f42c:	681b      	ldr	r3, [r3, #0]
 800f42e:	4a17      	ldr	r2, [pc, #92]	; (800f48c <disp_updateNavState+0x424>)
 800f430:	7892      	ldrb	r2, [r2, #2]
 800f432:	f3c2 0243 	ubfx	r2, r2, #1, #4
 800f436:	b2d2      	uxtb	r2, r2
 800f438:	4610      	mov	r0, r2
 800f43a:	4798      	blx	r3
				}
			}
		}
	}
	state.lastUp = up;
 800f43c:	79fb      	ldrb	r3, [r7, #7]
 800f43e:	f003 0301 	and.w	r3, r3, #1
 800f442:	b2d9      	uxtb	r1, r3
 800f444:	4a11      	ldr	r2, [pc, #68]	; (800f48c <disp_updateNavState+0x424>)
 800f446:	7853      	ldrb	r3, [r2, #1]
 800f448:	f361 1304 	bfi	r3, r1, #4, #1
 800f44c:	7053      	strb	r3, [r2, #1]
	state.lastDown = down;
 800f44e:	79bb      	ldrb	r3, [r7, #6]
 800f450:	f003 0301 	and.w	r3, r3, #1
 800f454:	b2d9      	uxtb	r1, r3
 800f456:	4a0d      	ldr	r2, [pc, #52]	; (800f48c <disp_updateNavState+0x424>)
 800f458:	7853      	ldrb	r3, [r2, #1]
 800f45a:	f361 1345 	bfi	r3, r1, #5, #1
 800f45e:	7053      	strb	r3, [r2, #1]
	state.lastLeft = left;
 800f460:	797b      	ldrb	r3, [r7, #5]
 800f462:	f003 0301 	and.w	r3, r3, #1
 800f466:	b2d9      	uxtb	r1, r3
 800f468:	4a08      	ldr	r2, [pc, #32]	; (800f48c <disp_updateNavState+0x424>)
 800f46a:	7853      	ldrb	r3, [r2, #1]
 800f46c:	f361 1386 	bfi	r3, r1, #6, #1
 800f470:	7053      	strb	r3, [r2, #1]
	state.lastRight = right;
 800f472:	793b      	ldrb	r3, [r7, #4]
 800f474:	f003 0301 	and.w	r3, r3, #1
 800f478:	b2d9      	uxtb	r1, r3
 800f47a:	4a04      	ldr	r2, [pc, #16]	; (800f48c <disp_updateNavState+0x424>)
 800f47c:	7853      	ldrb	r3, [r2, #1]
 800f47e:	f361 13c7 	bfi	r3, r1, #7, #1
 800f482:	7053      	strb	r3, [r2, #1]
}
 800f484:	bf00      	nop
 800f486:	3714      	adds	r7, #20
 800f488:	46bd      	mov	sp, r7
 800f48a:	bd90      	pop	{r4, r7, pc}
 800f48c:	24061e9c 	.word	0x24061e9c
 800f490:	2406249c 	.word	0x2406249c
 800f494:	240624a0 	.word	0x240624a0
 800f498:	24062484 	.word	0x24062484

0800f49c <arm_boot>:
#include "h7Boot.h"
#include "main.h"
void arm_boot(){
 800f49c:	b480      	push	{r7}
 800f49e:	af00      	add	r7, sp, #0
  	*(uint32_t*)0x52002008 = 0x08192A3B;
 800f4a0:	4b10      	ldr	r3, [pc, #64]	; (800f4e4 <arm_boot+0x48>)
 800f4a2:	4a11      	ldr	r2, [pc, #68]	; (800f4e8 <arm_boot+0x4c>)
 800f4a4:	601a      	str	r2, [r3, #0]
  	*(uint32_t*)0x52002008 = 0x4C5D6E7F;
 800f4a6:	4b0f      	ldr	r3, [pc, #60]	; (800f4e4 <arm_boot+0x48>)
 800f4a8:	4a10      	ldr	r2, [pc, #64]	; (800f4ec <arm_boot+0x50>)
 800f4aa:	601a      	str	r2, [r3, #0]
  	// Write new boot address
  	*(uint32_t*)0x52002044 = 0x08000800; // default is 0x1ff00800
 800f4ac:	4b10      	ldr	r3, [pc, #64]	; (800f4f0 <arm_boot+0x54>)
 800f4ae:	f04f 2208 	mov.w	r2, #134219776	; 0x8000800
 800f4b2:	601a      	str	r2, [r3, #0]
  	// Initiate OPTSTART Request
  	*(uint32_t*)0x52002018 |= 0x00000002;
 800f4b4:	4b0f      	ldr	r3, [pc, #60]	; (800f4f4 <arm_boot+0x58>)
 800f4b6:	681b      	ldr	r3, [r3, #0]
 800f4b8:	4a0e      	ldr	r2, [pc, #56]	; (800f4f4 <arm_boot+0x58>)
 800f4ba:	f043 0302 	orr.w	r3, r3, #2
 800f4be:	6013      	str	r3, [r2, #0]
  	while(*(uint32_t*)0x52002018 & 0x00000002);
 800f4c0:	bf00      	nop
 800f4c2:	4b0c      	ldr	r3, [pc, #48]	; (800f4f4 <arm_boot+0x58>)
 800f4c4:	681b      	ldr	r3, [r3, #0]
 800f4c6:	f003 0302 	and.w	r3, r3, #2
 800f4ca:	2b00      	cmp	r3, #0
 800f4cc:	d1f9      	bne.n	800f4c2 <arm_boot+0x26>
  	// Lock OPTCR
  	*(uint32_t*)0x52002018 |= 0x00000001;
 800f4ce:	4b09      	ldr	r3, [pc, #36]	; (800f4f4 <arm_boot+0x58>)
 800f4d0:	681b      	ldr	r3, [r3, #0]
 800f4d2:	4a08      	ldr	r2, [pc, #32]	; (800f4f4 <arm_boot+0x58>)
 800f4d4:	f043 0301 	orr.w	r3, r3, #1
 800f4d8:	6013      	str	r3, [r2, #0]
}
 800f4da:	bf00      	nop
 800f4dc:	46bd      	mov	sp, r7
 800f4de:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f4e2:	4770      	bx	lr
 800f4e4:	52002008 	.word	0x52002008
 800f4e8:	08192a3b 	.word	0x08192a3b
 800f4ec:	4c5d6e7f 	.word	0x4c5d6e7f
 800f4f0:	52002044 	.word	0x52002044
 800f4f4:	52002018 	.word	0x52002018

0800f4f8 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 800f4f8:	b590      	push	{r4, r7, lr}
 800f4fa:	b083      	sub	sp, #12
 800f4fc:	af02      	add	r7, sp, #8
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 800f4fe:	f7f1 f8d3 	bl	80006a8 <HAL_Init>

  /* USER CODE BEGIN Init */
  arm_boot();
 800f502:	f7ff ffcb 	bl	800f49c <arm_boot>
  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 800f506:	f000 f8cb 	bl	800f6a0 <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 800f50a:	f000 fcc9 	bl	800fea0 <MX_GPIO_Init>
  MX_DMA_Init();
 800f50e:	f000 fc4f 	bl	800fdb0 <MX_DMA_Init>
  MX_UART4_Init();
 800f512:	f000 fb15 	bl	800fb40 <MX_UART4_Init>
  MX_RTC_Init();
 800f516:	f000 f977 	bl	800f808 <MX_RTC_Init>
  MX_USART3_UART_Init();
 800f51a:	f000 fbfb 	bl	800fd14 <MX_USART3_UART_Init>
  MX_UART8_Init();
 800f51e:	f000 fb5d 	bl	800fbdc <MX_UART8_Init>
  MX_SPI3_Init();
 800f522:	f000 f999 	bl	800f858 <MX_SPI3_Init>
  MX_USART2_UART_Init();
 800f526:	f000 fba7 	bl	800fc78 <MX_USART2_UART_Init>
  MX_TIM2_Init();
 800f52a:	f000 fa41 	bl	800f9b0 <MX_TIM2_Init>
  MX_TIM12_Init();
 800f52e:	f000 fa99 	bl	800fa64 <MX_TIM12_Init>
  MX_TIM1_Init();
 800f532:	f000 f9e9 	bl	800f908 <MX_TIM1_Init>
  MX_CRC_Init();
 800f536:	f000 f945 	bl	800f7c4 <MX_CRC_Init>
  /* USER CODE BEGIN 2 */
  HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);
 800f53a:	2100      	movs	r1, #0
 800f53c:	4841      	ldr	r0, [pc, #260]	; (800f644 <main+0x14c>)
 800f53e:	f7f7 fe3f 	bl	80071c0 <HAL_TIM_PWM_Start>
  displayInit();
 800f542:	f7ff f8f5 	bl	800e730 <displayInit>
  xTimerStart(xTimerCreate("lightsTimer", 666, pdTRUE, NULL, lightsTmr), 0);
 800f546:	4b40      	ldr	r3, [pc, #256]	; (800f648 <main+0x150>)
 800f548:	9300      	str	r3, [sp, #0]
 800f54a:	2300      	movs	r3, #0
 800f54c:	2201      	movs	r2, #1
 800f54e:	f240 219a 	movw	r1, #666	; 0x29a
 800f552:	483e      	ldr	r0, [pc, #248]	; (800f64c <main+0x154>)
 800f554:	f7fc ff66 	bl	800c424 <xTimerCreate>
 800f558:	4604      	mov	r4, r0
 800f55a:	f7fc f9df 	bl	800b91c <xTaskGetTickCount>
 800f55e:	4602      	mov	r2, r0
 800f560:	2300      	movs	r3, #0
 800f562:	9300      	str	r3, [sp, #0]
 800f564:	2300      	movs	r3, #0
 800f566:	2101      	movs	r1, #1
 800f568:	4620      	mov	r0, r4
 800f56a:	f7fc ffb7 	bl	800c4dc <xTimerGenericCommand>
  xTimerStart(xTimerCreate("mc2StateTimer", 20, pdTRUE, NULL, mc2StateTmr), 0);
 800f56e:	4b38      	ldr	r3, [pc, #224]	; (800f650 <main+0x158>)
 800f570:	9300      	str	r3, [sp, #0]
 800f572:	2300      	movs	r3, #0
 800f574:	2201      	movs	r2, #1
 800f576:	2114      	movs	r1, #20
 800f578:	4836      	ldr	r0, [pc, #216]	; (800f654 <main+0x15c>)
 800f57a:	f7fc ff53 	bl	800c424 <xTimerCreate>
 800f57e:	4604      	mov	r4, r0
 800f580:	f7fc f9cc 	bl	800b91c <xTaskGetTickCount>
 800f584:	4602      	mov	r2, r0
 800f586:	2300      	movs	r3, #0
 800f588:	9300      	str	r3, [sp, #0]
 800f58a:	2300      	movs	r3, #0
 800f58c:	2101      	movs	r1, #1
 800f58e:	4620      	mov	r0, r4
 800f590:	f7fc ffa4 	bl	800c4dc <xTimerGenericCommand>
  xTimerStart(xTimerCreate("display", 200, pdTRUE, 0, displayTmr), 0);
 800f594:	4b30      	ldr	r3, [pc, #192]	; (800f658 <main+0x160>)
 800f596:	9300      	str	r3, [sp, #0]
 800f598:	2300      	movs	r3, #0
 800f59a:	2201      	movs	r2, #1
 800f59c:	21c8      	movs	r1, #200	; 0xc8
 800f59e:	482f      	ldr	r0, [pc, #188]	; (800f65c <main+0x164>)
 800f5a0:	f7fc ff40 	bl	800c424 <xTimerCreate>
 800f5a4:	4604      	mov	r4, r0
 800f5a6:	f7fc f9b9 	bl	800b91c <xTaskGetTickCount>
 800f5aa:	4602      	mov	r2, r0
 800f5ac:	2300      	movs	r3, #0
 800f5ae:	9300      	str	r3, [sp, #0]
 800f5b0:	2300      	movs	r3, #0
 800f5b2:	2101      	movs	r1, #1
 800f5b4:	4620      	mov	r0, r4
 800f5b6:	f7fc ff91 	bl	800c4dc <xTimerGenericCommand>
  buart = B_uartStart(&huart4);
 800f5ba:	4829      	ldr	r0, [pc, #164]	; (800f660 <main+0x168>)
 800f5bc:	f012 f8b0 	bl	8021720 <B_uartStart>
 800f5c0:	4603      	mov	r3, r0
 800f5c2:	4a28      	ldr	r2, [pc, #160]	; (800f664 <main+0x16c>)
 800f5c4:	6013      	str	r3, [r2, #0]
  spbBuart = B_uartStart(&huart3);
 800f5c6:	4828      	ldr	r0, [pc, #160]	; (800f668 <main+0x170>)
 800f5c8:	f012 f8aa 	bl	8021720 <B_uartStart>
 800f5cc:	4603      	mov	r3, r0
 800f5ce:	4a27      	ldr	r2, [pc, #156]	; (800f66c <main+0x174>)
 800f5d0:	6013      	str	r3, [r2, #0]
  swBuart = B_uartStart(&huart8);
 800f5d2:	4827      	ldr	r0, [pc, #156]	; (800f670 <main+0x178>)
 800f5d4:	f012 f8a4 	bl	8021720 <B_uartStart>
 800f5d8:	4603      	mov	r3, r0
 800f5da:	4a26      	ldr	r2, [pc, #152]	; (800f674 <main+0x17c>)
 800f5dc:	6013      	str	r3, [r2, #0]
  btcp = B_tcpStart(DCMB_ID, &buart, buart, 1, &hcrc);
 800f5de:	4b21      	ldr	r3, [pc, #132]	; (800f664 <main+0x16c>)
 800f5e0:	681a      	ldr	r2, [r3, #0]
 800f5e2:	4b25      	ldr	r3, [pc, #148]	; (800f678 <main+0x180>)
 800f5e4:	9300      	str	r3, [sp, #0]
 800f5e6:	2301      	movs	r3, #1
 800f5e8:	491e      	ldr	r1, [pc, #120]	; (800f664 <main+0x16c>)
 800f5ea:	2004      	movs	r0, #4
 800f5ec:	f011 fdd0 	bl	8021190 <B_tcpStart>
 800f5f0:	4603      	mov	r3, r0
 800f5f2:	4a22      	ldr	r2, [pc, #136]	; (800f67c <main+0x184>)
 800f5f4:	6013      	str	r3, [r2, #0]
  xTaskCreate(sidePanelTask, "SidePanelTask", 1024, spbBuart, 3, NULL);
 800f5f6:	4b1d      	ldr	r3, [pc, #116]	; (800f66c <main+0x174>)
 800f5f8:	681b      	ldr	r3, [r3, #0]
 800f5fa:	2200      	movs	r2, #0
 800f5fc:	9201      	str	r2, [sp, #4]
 800f5fe:	2203      	movs	r2, #3
 800f600:	9200      	str	r2, [sp, #0]
 800f602:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800f606:	491e      	ldr	r1, [pc, #120]	; (800f680 <main+0x188>)
 800f608:	481e      	ldr	r0, [pc, #120]	; (800f684 <main+0x18c>)
 800f60a:	f7fb ff03 	bl	800b414 <xTaskCreate>
  xTaskCreate(steeringWheelTask, "SteeringWheelTask", 1024, swBuart, 5, NULL);
 800f60e:	4b19      	ldr	r3, [pc, #100]	; (800f674 <main+0x17c>)
 800f610:	681b      	ldr	r3, [r3, #0]
 800f612:	2200      	movs	r2, #0
 800f614:	9201      	str	r2, [sp, #4]
 800f616:	2205      	movs	r2, #5
 800f618:	9200      	str	r2, [sp, #0]
 800f61a:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800f61e:	491a      	ldr	r1, [pc, #104]	; (800f688 <main+0x190>)
 800f620:	481a      	ldr	r0, [pc, #104]	; (800f68c <main+0x194>)
 800f622:	f7fb fef7 	bl	800b414 <xTaskCreate>
  disp_attachMotOnCallback(motCallback);
 800f626:	481a      	ldr	r0, [pc, #104]	; (800f690 <main+0x198>)
 800f628:	f7ff fd0e 	bl	800f048 <disp_attachMotOnCallback>
  disp_attachVfmUpCallback(vfmUpCallback);
 800f62c:	4819      	ldr	r0, [pc, #100]	; (800f694 <main+0x19c>)
 800f62e:	f7ff fcdb 	bl	800efe8 <disp_attachVfmUpCallback>
  disp_attachVfmDownCallback(vfmDownCallback);
 800f632:	4819      	ldr	r0, [pc, #100]	; (800f698 <main+0x1a0>)
 800f634:	f7ff fce8 	bl	800f008 <disp_attachVfmDownCallback>
  disp_attachAccResetCallback(accResetCallback);
 800f638:	4818      	ldr	r0, [pc, #96]	; (800f69c <main+0x1a4>)
 800f63a:	f7ff fcf5 	bl	800f028 <disp_attachAccResetCallback>
#endif DEFAULT_TASK
  /* add threads, ... */
  /* USER CODE END RTOS_THREADS */

  /* Start scheduler */
  osKernelStart();
 800f63e:	f7fa ffa5 	bl	800a58c <osKernelStart>

  /* We should never get here as control is now taken by the scheduler */
  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
 800f642:	e7fe      	b.n	800f642 <main+0x14a>
 800f644:	24062f88 	.word	0x24062f88
 800f648:	08010389 	.word	0x08010389
 800f64c:	08022868 	.word	0x08022868
 800f650:	080104e1 	.word	0x080104e1
 800f654:	08022874 	.word	0x08022874
 800f658:	0800e831 	.word	0x0800e831
 800f65c:	08022884 	.word	0x08022884
 800f660:	24062e6c 	.word	0x24062e6c
 800f664:	240630b0 	.word	0x240630b0
 800f668:	24062770 	.word	0x24062770
 800f66c:	24062f84 	.word	0x24062f84
 800f670:	24062ddc 	.word	0x24062ddc
 800f674:	24062b3c 	.word	0x24062b3c
 800f678:	24062800 	.word	0x24062800
 800f67c:	24062c68 	.word	0x24062c68
 800f680:	0802288c 	.word	0x0802288c
 800f684:	08010d81 	.word	0x08010d81
 800f688:	0802289c 	.word	0x0802289c
 800f68c:	08010b3d 	.word	0x08010b3d
 800f690:	08010369 	.word	0x08010369
 800f694:	08010301 	.word	0x08010301
 800f698:	08010335 	.word	0x08010335
 800f69c:	080102e9 	.word	0x080102e9

0800f6a0 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 800f6a0:	b580      	push	{r7, lr}
 800f6a2:	b09c      	sub	sp, #112	; 0x70
 800f6a4:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 800f6a6:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800f6aa:	224c      	movs	r2, #76	; 0x4c
 800f6ac:	2100      	movs	r1, #0
 800f6ae:	4618      	mov	r0, r3
 800f6b0:	f012 fae0 	bl	8021c74 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 800f6b4:	1d3b      	adds	r3, r7, #4
 800f6b6:	2220      	movs	r2, #32
 800f6b8:	2100      	movs	r1, #0
 800f6ba:	4618      	mov	r0, r3
 800f6bc:	f012 fada 	bl	8021c74 <memset>

  /** Supply configuration update enable
  */
  HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);
 800f6c0:	2002      	movs	r0, #2
 800f6c2:	f7f4 fb77 	bl	8003db4 <HAL_PWREx_ConfigSupply>
  /** Configure the main internal regulator output voltage
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);
 800f6c6:	2300      	movs	r3, #0
 800f6c8:	603b      	str	r3, [r7, #0]
 800f6ca:	4b3b      	ldr	r3, [pc, #236]	; (800f7b8 <SystemClock_Config+0x118>)
 800f6cc:	699b      	ldr	r3, [r3, #24]
 800f6ce:	4a3a      	ldr	r2, [pc, #232]	; (800f7b8 <SystemClock_Config+0x118>)
 800f6d0:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 800f6d4:	6193      	str	r3, [r2, #24]
 800f6d6:	4b38      	ldr	r3, [pc, #224]	; (800f7b8 <SystemClock_Config+0x118>)
 800f6d8:	699b      	ldr	r3, [r3, #24]
 800f6da:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 800f6de:	603b      	str	r3, [r7, #0]
 800f6e0:	4b36      	ldr	r3, [pc, #216]	; (800f7bc <SystemClock_Config+0x11c>)
 800f6e2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800f6e4:	4a35      	ldr	r2, [pc, #212]	; (800f7bc <SystemClock_Config+0x11c>)
 800f6e6:	f043 0301 	orr.w	r3, r3, #1
 800f6ea:	62d3      	str	r3, [r2, #44]	; 0x2c
 800f6ec:	4b33      	ldr	r3, [pc, #204]	; (800f7bc <SystemClock_Config+0x11c>)
 800f6ee:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800f6f0:	f003 0301 	and.w	r3, r3, #1
 800f6f4:	603b      	str	r3, [r7, #0]
 800f6f6:	683b      	ldr	r3, [r7, #0]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
 800f6f8:	bf00      	nop
 800f6fa:	4b2f      	ldr	r3, [pc, #188]	; (800f7b8 <SystemClock_Config+0x118>)
 800f6fc:	699b      	ldr	r3, [r3, #24]
 800f6fe:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 800f702:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800f706:	d1f8      	bne.n	800f6fa <SystemClock_Config+0x5a>
  /** Macro to configure the PLL clock source
  */
  __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
 800f708:	4b2d      	ldr	r3, [pc, #180]	; (800f7c0 <SystemClock_Config+0x120>)
 800f70a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800f70c:	f023 0303 	bic.w	r3, r3, #3
 800f710:	4a2b      	ldr	r2, [pc, #172]	; (800f7c0 <SystemClock_Config+0x120>)
 800f712:	f043 0302 	orr.w	r3, r3, #2
 800f716:	6293      	str	r3, [r2, #40]	; 0x28
  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_LSI
 800f718:	230b      	movs	r3, #11
 800f71a:	627b      	str	r3, [r7, #36]	; 0x24
                              |RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 800f71c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800f720:	62bb      	str	r3, [r7, #40]	; 0x28
  RCC_OscInitStruct.HSIState = RCC_HSI_DIV1;
 800f722:	2301      	movs	r3, #1
 800f724:	633b      	str	r3, [r7, #48]	; 0x30
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 800f726:	2340      	movs	r3, #64	; 0x40
 800f728:	637b      	str	r3, [r7, #52]	; 0x34
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
 800f72a:	2301      	movs	r3, #1
 800f72c:	63bb      	str	r3, [r7, #56]	; 0x38
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800f72e:	2302      	movs	r3, #2
 800f730:	64bb      	str	r3, [r7, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 800f732:	2302      	movs	r3, #2
 800f734:	64fb      	str	r3, [r7, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLM = 2;
 800f736:	2302      	movs	r3, #2
 800f738:	653b      	str	r3, [r7, #80]	; 0x50
  RCC_OscInitStruct.PLL.PLLN = 50;
 800f73a:	2332      	movs	r3, #50	; 0x32
 800f73c:	657b      	str	r3, [r7, #84]	; 0x54
  RCC_OscInitStruct.PLL.PLLP = 2;
 800f73e:	2302      	movs	r3, #2
 800f740:	65bb      	str	r3, [r7, #88]	; 0x58
  RCC_OscInitStruct.PLL.PLLQ = 4;
 800f742:	2304      	movs	r3, #4
 800f744:	65fb      	str	r3, [r7, #92]	; 0x5c
  RCC_OscInitStruct.PLL.PLLR = 2;
 800f746:	2302      	movs	r3, #2
 800f748:	663b      	str	r3, [r7, #96]	; 0x60
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_3;
 800f74a:	230c      	movs	r3, #12
 800f74c:	667b      	str	r3, [r7, #100]	; 0x64
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
 800f74e:	2300      	movs	r3, #0
 800f750:	66bb      	str	r3, [r7, #104]	; 0x68
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
 800f752:	2300      	movs	r3, #0
 800f754:	66fb      	str	r3, [r7, #108]	; 0x6c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800f756:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800f75a:	4618      	mov	r0, r3
 800f75c:	f7f4 fb64 	bl	8003e28 <HAL_RCC_OscConfig>
 800f760:	4603      	mov	r3, r0
 800f762:	2b00      	cmp	r3, #0
 800f764:	d001      	beq.n	800f76a <SystemClock_Config+0xca>
  {
    Error_Handler();
 800f766:	f001 fc35 	bl	8010fd4 <Error_Handler>
  }
  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800f76a:	233f      	movs	r3, #63	; 0x3f
 800f76c:	607b      	str	r3, [r7, #4]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
                              |RCC_CLOCKTYPE_D3PCLK1|RCC_CLOCKTYPE_D1PCLK1;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800f76e:	2303      	movs	r3, #3
 800f770:	60bb      	str	r3, [r7, #8]
  RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
 800f772:	2300      	movs	r3, #0
 800f774:	60fb      	str	r3, [r7, #12]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
 800f776:	2308      	movs	r3, #8
 800f778:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
 800f77a:	2340      	movs	r3, #64	; 0x40
 800f77c:	617b      	str	r3, [r7, #20]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
 800f77e:	2340      	movs	r3, #64	; 0x40
 800f780:	61bb      	str	r3, [r7, #24]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
 800f782:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800f786:	61fb      	str	r3, [r7, #28]
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;
 800f788:	2340      	movs	r3, #64	; 0x40
 800f78a:	623b      	str	r3, [r7, #32]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 800f78c:	1d3b      	adds	r3, r7, #4
 800f78e:	2102      	movs	r1, #2
 800f790:	4618      	mov	r0, r3
 800f792:	f7f4 ff75 	bl	8004680 <HAL_RCC_ClockConfig>
 800f796:	4603      	mov	r3, r0
 800f798:	2b00      	cmp	r3, #0
 800f79a:	d001      	beq.n	800f7a0 <SystemClock_Config+0x100>
  {
    Error_Handler();
 800f79c:	f001 fc1a 	bl	8010fd4 <Error_Handler>
  }
  HAL_RCC_MCOConfig(RCC_MCO1, RCC_MCO1SOURCE_PLL1QCLK, RCC_MCODIV_1);
 800f7a0:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 800f7a4:	f44f 0140 	mov.w	r1, #12582912	; 0xc00000
 800f7a8:	2000      	movs	r0, #0
 800f7aa:	f7f5 f91f 	bl	80049ec <HAL_RCC_MCOConfig>
}
 800f7ae:	bf00      	nop
 800f7b0:	3770      	adds	r7, #112	; 0x70
 800f7b2:	46bd      	mov	sp, r7
 800f7b4:	bd80      	pop	{r7, pc}
 800f7b6:	bf00      	nop
 800f7b8:	58024800 	.word	0x58024800
 800f7bc:	58000400 	.word	0x58000400
 800f7c0:	58024400 	.word	0x58024400

0800f7c4 <MX_CRC_Init>:
  * @brief CRC Initialization Function
  * @param None
  * @retval None
  */
static void MX_CRC_Init(void)
{
 800f7c4:	b580      	push	{r7, lr}
 800f7c6:	af00      	add	r7, sp, #0
  /* USER CODE END CRC_Init 0 */

  /* USER CODE BEGIN CRC_Init 1 */

  /* USER CODE END CRC_Init 1 */
  hcrc.Instance = CRC;
 800f7c8:	4b0d      	ldr	r3, [pc, #52]	; (800f800 <MX_CRC_Init+0x3c>)
 800f7ca:	4a0e      	ldr	r2, [pc, #56]	; (800f804 <MX_CRC_Init+0x40>)
 800f7cc:	601a      	str	r2, [r3, #0]
  hcrc.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_ENABLE;
 800f7ce:	4b0c      	ldr	r3, [pc, #48]	; (800f800 <MX_CRC_Init+0x3c>)
 800f7d0:	2200      	movs	r2, #0
 800f7d2:	711a      	strb	r2, [r3, #4]
  hcrc.Init.DefaultInitValueUse = DEFAULT_INIT_VALUE_ENABLE;
 800f7d4:	4b0a      	ldr	r3, [pc, #40]	; (800f800 <MX_CRC_Init+0x3c>)
 800f7d6:	2200      	movs	r2, #0
 800f7d8:	715a      	strb	r2, [r3, #5]
  hcrc.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_BYTE;
 800f7da:	4b09      	ldr	r3, [pc, #36]	; (800f800 <MX_CRC_Init+0x3c>)
 800f7dc:	2220      	movs	r2, #32
 800f7de:	615a      	str	r2, [r3, #20]
  hcrc.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_ENABLE;
 800f7e0:	4b07      	ldr	r3, [pc, #28]	; (800f800 <MX_CRC_Init+0x3c>)
 800f7e2:	2280      	movs	r2, #128	; 0x80
 800f7e4:	619a      	str	r2, [r3, #24]
  hcrc.InputDataFormat = CRC_INPUTDATA_FORMAT_BYTES;
 800f7e6:	4b06      	ldr	r3, [pc, #24]	; (800f800 <MX_CRC_Init+0x3c>)
 800f7e8:	2201      	movs	r2, #1
 800f7ea:	621a      	str	r2, [r3, #32]
  if (HAL_CRC_Init(&hcrc) != HAL_OK)
 800f7ec:	4804      	ldr	r0, [pc, #16]	; (800f800 <MX_CRC_Init+0x3c>)
 800f7ee:	f7f1 f8a3 	bl	8000938 <HAL_CRC_Init>
 800f7f2:	4603      	mov	r3, r0
 800f7f4:	2b00      	cmp	r3, #0
 800f7f6:	d001      	beq.n	800f7fc <MX_CRC_Init+0x38>
  {
    Error_Handler();
 800f7f8:	f001 fbec 	bl	8010fd4 <Error_Handler>
  }
  /* USER CODE BEGIN CRC_Init 2 */

  /* USER CODE END CRC_Init 2 */

}
 800f7fc:	bf00      	nop
 800f7fe:	bd80      	pop	{r7, pc}
 800f800:	24062800 	.word	0x24062800
 800f804:	58024c00 	.word	0x58024c00

0800f808 <MX_RTC_Init>:
  * @brief RTC Initialization Function
  * @param None
  * @retval None
  */
static void MX_RTC_Init(void)
{
 800f808:	b580      	push	{r7, lr}
 800f80a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN RTC_Init 1 */

  /* USER CODE END RTC_Init 1 */
  /** Initialize RTC Only
  */
  hrtc.Instance = RTC;
 800f80c:	4b10      	ldr	r3, [pc, #64]	; (800f850 <MX_RTC_Init+0x48>)
 800f80e:	4a11      	ldr	r2, [pc, #68]	; (800f854 <MX_RTC_Init+0x4c>)
 800f810:	601a      	str	r2, [r3, #0]
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
 800f812:	4b0f      	ldr	r3, [pc, #60]	; (800f850 <MX_RTC_Init+0x48>)
 800f814:	2200      	movs	r2, #0
 800f816:	605a      	str	r2, [r3, #4]
  hrtc.Init.AsynchPrediv = 127;
 800f818:	4b0d      	ldr	r3, [pc, #52]	; (800f850 <MX_RTC_Init+0x48>)
 800f81a:	227f      	movs	r2, #127	; 0x7f
 800f81c:	609a      	str	r2, [r3, #8]
  hrtc.Init.SynchPrediv = 255;
 800f81e:	4b0c      	ldr	r3, [pc, #48]	; (800f850 <MX_RTC_Init+0x48>)
 800f820:	22ff      	movs	r2, #255	; 0xff
 800f822:	60da      	str	r2, [r3, #12]
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
 800f824:	4b0a      	ldr	r3, [pc, #40]	; (800f850 <MX_RTC_Init+0x48>)
 800f826:	2200      	movs	r2, #0
 800f828:	611a      	str	r2, [r3, #16]
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 800f82a:	4b09      	ldr	r3, [pc, #36]	; (800f850 <MX_RTC_Init+0x48>)
 800f82c:	2200      	movs	r2, #0
 800f82e:	619a      	str	r2, [r3, #24]
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 800f830:	4b07      	ldr	r3, [pc, #28]	; (800f850 <MX_RTC_Init+0x48>)
 800f832:	2200      	movs	r2, #0
 800f834:	61da      	str	r2, [r3, #28]
  hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
 800f836:	4b06      	ldr	r3, [pc, #24]	; (800f850 <MX_RTC_Init+0x48>)
 800f838:	2200      	movs	r2, #0
 800f83a:	615a      	str	r2, [r3, #20]
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
 800f83c:	4804      	ldr	r0, [pc, #16]	; (800f850 <MX_RTC_Init+0x48>)
 800f83e:	f7f6 feb9 	bl	80065b4 <HAL_RTC_Init>
 800f842:	4603      	mov	r3, r0
 800f844:	2b00      	cmp	r3, #0
 800f846:	d001      	beq.n	800f84c <MX_RTC_Init+0x44>
  {
    Error_Handler();
 800f848:	f001 fbc4 	bl	8010fd4 <Error_Handler>
  }
  /* USER CODE BEGIN RTC_Init 2 */

  /* USER CODE END RTC_Init 2 */

}
 800f84c:	bf00      	nop
 800f84e:	bd80      	pop	{r7, pc}
 800f850:	24062d6c 	.word	0x24062d6c
 800f854:	58004000 	.word	0x58004000

0800f858 <MX_SPI3_Init>:
  * @brief SPI3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SPI3_Init(void)
{
 800f858:	b580      	push	{r7, lr}
 800f85a:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN SPI3_Init 1 */

  /* USER CODE END SPI3_Init 1 */
  /* SPI3 parameter configuration*/
  hspi3.Instance = SPI3;
 800f85c:	4b28      	ldr	r3, [pc, #160]	; (800f900 <MX_SPI3_Init+0xa8>)
 800f85e:	4a29      	ldr	r2, [pc, #164]	; (800f904 <MX_SPI3_Init+0xac>)
 800f860:	601a      	str	r2, [r3, #0]
  hspi3.Init.Mode = SPI_MODE_MASTER;
 800f862:	4b27      	ldr	r3, [pc, #156]	; (800f900 <MX_SPI3_Init+0xa8>)
 800f864:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
 800f868:	605a      	str	r2, [r3, #4]
  hspi3.Init.Direction = SPI_DIRECTION_2LINES_RXONLY;
 800f86a:	4b25      	ldr	r3, [pc, #148]	; (800f900 <MX_SPI3_Init+0xa8>)
 800f86c:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 800f870:	609a      	str	r2, [r3, #8]
  hspi3.Init.DataSize = SPI_DATASIZE_16BIT;
 800f872:	4b23      	ldr	r3, [pc, #140]	; (800f900 <MX_SPI3_Init+0xa8>)
 800f874:	220f      	movs	r2, #15
 800f876:	60da      	str	r2, [r3, #12]
  hspi3.Init.CLKPolarity = SPI_POLARITY_LOW;
 800f878:	4b21      	ldr	r3, [pc, #132]	; (800f900 <MX_SPI3_Init+0xa8>)
 800f87a:	2200      	movs	r2, #0
 800f87c:	611a      	str	r2, [r3, #16]
  hspi3.Init.CLKPhase = SPI_PHASE_1EDGE;
 800f87e:	4b20      	ldr	r3, [pc, #128]	; (800f900 <MX_SPI3_Init+0xa8>)
 800f880:	2200      	movs	r2, #0
 800f882:	615a      	str	r2, [r3, #20]
  hspi3.Init.NSS = SPI_NSS_SOFT;
 800f884:	4b1e      	ldr	r3, [pc, #120]	; (800f900 <MX_SPI3_Init+0xa8>)
 800f886:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
 800f88a:	619a      	str	r2, [r3, #24]
  hspi3.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_256;
 800f88c:	4b1c      	ldr	r3, [pc, #112]	; (800f900 <MX_SPI3_Init+0xa8>)
 800f88e:	f04f 42e0 	mov.w	r2, #1879048192	; 0x70000000
 800f892:	61da      	str	r2, [r3, #28]
  hspi3.Init.FirstBit = SPI_FIRSTBIT_MSB;
 800f894:	4b1a      	ldr	r3, [pc, #104]	; (800f900 <MX_SPI3_Init+0xa8>)
 800f896:	2200      	movs	r2, #0
 800f898:	621a      	str	r2, [r3, #32]
  hspi3.Init.TIMode = SPI_TIMODE_DISABLE;
 800f89a:	4b19      	ldr	r3, [pc, #100]	; (800f900 <MX_SPI3_Init+0xa8>)
 800f89c:	2200      	movs	r2, #0
 800f89e:	625a      	str	r2, [r3, #36]	; 0x24
  hspi3.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 800f8a0:	4b17      	ldr	r3, [pc, #92]	; (800f900 <MX_SPI3_Init+0xa8>)
 800f8a2:	2200      	movs	r2, #0
 800f8a4:	629a      	str	r2, [r3, #40]	; 0x28
  hspi3.Init.CRCPolynomial = 0x0;
 800f8a6:	4b16      	ldr	r3, [pc, #88]	; (800f900 <MX_SPI3_Init+0xa8>)
 800f8a8:	2200      	movs	r2, #0
 800f8aa:	62da      	str	r2, [r3, #44]	; 0x2c
  hspi3.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
 800f8ac:	4b14      	ldr	r3, [pc, #80]	; (800f900 <MX_SPI3_Init+0xa8>)
 800f8ae:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 800f8b2:	635a      	str	r2, [r3, #52]	; 0x34
  hspi3.Init.NSSPolarity = SPI_NSS_POLARITY_LOW;
 800f8b4:	4b12      	ldr	r3, [pc, #72]	; (800f900 <MX_SPI3_Init+0xa8>)
 800f8b6:	2200      	movs	r2, #0
 800f8b8:	639a      	str	r2, [r3, #56]	; 0x38
  hspi3.Init.FifoThreshold = SPI_FIFO_THRESHOLD_01DATA;
 800f8ba:	4b11      	ldr	r3, [pc, #68]	; (800f900 <MX_SPI3_Init+0xa8>)
 800f8bc:	2200      	movs	r2, #0
 800f8be:	63da      	str	r2, [r3, #60]	; 0x3c
  hspi3.Init.TxCRCInitializationPattern = SPI_CRC_INITIALIZATION_ALL_ZERO_PATTERN;
 800f8c0:	4b0f      	ldr	r3, [pc, #60]	; (800f900 <MX_SPI3_Init+0xa8>)
 800f8c2:	2200      	movs	r2, #0
 800f8c4:	641a      	str	r2, [r3, #64]	; 0x40
  hspi3.Init.RxCRCInitializationPattern = SPI_CRC_INITIALIZATION_ALL_ZERO_PATTERN;
 800f8c6:	4b0e      	ldr	r3, [pc, #56]	; (800f900 <MX_SPI3_Init+0xa8>)
 800f8c8:	2200      	movs	r2, #0
 800f8ca:	645a      	str	r2, [r3, #68]	; 0x44
  hspi3.Init.MasterSSIdleness = SPI_MASTER_SS_IDLENESS_00CYCLE;
 800f8cc:	4b0c      	ldr	r3, [pc, #48]	; (800f900 <MX_SPI3_Init+0xa8>)
 800f8ce:	2200      	movs	r2, #0
 800f8d0:	649a      	str	r2, [r3, #72]	; 0x48
  hspi3.Init.MasterInterDataIdleness = SPI_MASTER_INTERDATA_IDLENESS_00CYCLE;
 800f8d2:	4b0b      	ldr	r3, [pc, #44]	; (800f900 <MX_SPI3_Init+0xa8>)
 800f8d4:	2200      	movs	r2, #0
 800f8d6:	64da      	str	r2, [r3, #76]	; 0x4c
  hspi3.Init.MasterReceiverAutoSusp = SPI_MASTER_RX_AUTOSUSP_DISABLE;
 800f8d8:	4b09      	ldr	r3, [pc, #36]	; (800f900 <MX_SPI3_Init+0xa8>)
 800f8da:	2200      	movs	r2, #0
 800f8dc:	651a      	str	r2, [r3, #80]	; 0x50
  hspi3.Init.MasterKeepIOState = SPI_MASTER_KEEP_IO_STATE_DISABLE;
 800f8de:	4b08      	ldr	r3, [pc, #32]	; (800f900 <MX_SPI3_Init+0xa8>)
 800f8e0:	2200      	movs	r2, #0
 800f8e2:	655a      	str	r2, [r3, #84]	; 0x54
  hspi3.Init.IOSwap = SPI_IO_SWAP_DISABLE;
 800f8e4:	4b06      	ldr	r3, [pc, #24]	; (800f900 <MX_SPI3_Init+0xa8>)
 800f8e6:	2200      	movs	r2, #0
 800f8e8:	659a      	str	r2, [r3, #88]	; 0x58
  if (HAL_SPI_Init(&hspi3) != HAL_OK)
 800f8ea:	4805      	ldr	r0, [pc, #20]	; (800f900 <MX_SPI3_Init+0xa8>)
 800f8ec:	f7f6 ff72 	bl	80067d4 <HAL_SPI_Init>
 800f8f0:	4603      	mov	r3, r0
 800f8f2:	2b00      	cmp	r3, #0
 800f8f4:	d001      	beq.n	800f8fa <MX_SPI3_Init+0xa2>
  {
    Error_Handler();
 800f8f6:	f001 fb6d 	bl	8010fd4 <Error_Handler>
  }
  /* USER CODE BEGIN SPI3_Init 2 */

  /* USER CODE END SPI3_Init 2 */

}
 800f8fa:	bf00      	nop
 800f8fc:	bd80      	pop	{r7, pc}
 800f8fe:	bf00      	nop
 800f900:	24062ab4 	.word	0x24062ab4
 800f904:	40003c00 	.word	0x40003c00

0800f908 <MX_TIM1_Init>:
  * @brief TIM1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM1_Init(void)
{
 800f908:	b580      	push	{r7, lr}
 800f90a:	b088      	sub	sp, #32
 800f90c:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN TIM1_Init 0 */

  /* USER CODE END TIM1_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 800f90e:	f107 0310 	add.w	r3, r7, #16
 800f912:	2200      	movs	r2, #0
 800f914:	601a      	str	r2, [r3, #0]
 800f916:	605a      	str	r2, [r3, #4]
 800f918:	609a      	str	r2, [r3, #8]
 800f91a:	60da      	str	r2, [r3, #12]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 800f91c:	1d3b      	adds	r3, r7, #4
 800f91e:	2200      	movs	r2, #0
 800f920:	601a      	str	r2, [r3, #0]
 800f922:	605a      	str	r2, [r3, #4]
 800f924:	609a      	str	r2, [r3, #8]

  /* USER CODE BEGIN TIM1_Init 1 */

  /* USER CODE END TIM1_Init 1 */
  htim1.Instance = TIM1;
 800f926:	4b20      	ldr	r3, [pc, #128]	; (800f9a8 <MX_TIM1_Init+0xa0>)
 800f928:	4a20      	ldr	r2, [pc, #128]	; (800f9ac <MX_TIM1_Init+0xa4>)
 800f92a:	601a      	str	r2, [r3, #0]
  htim1.Init.Prescaler = 0;
 800f92c:	4b1e      	ldr	r3, [pc, #120]	; (800f9a8 <MX_TIM1_Init+0xa0>)
 800f92e:	2200      	movs	r2, #0
 800f930:	605a      	str	r2, [r3, #4]
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 800f932:	4b1d      	ldr	r3, [pc, #116]	; (800f9a8 <MX_TIM1_Init+0xa0>)
 800f934:	2200      	movs	r2, #0
 800f936:	609a      	str	r2, [r3, #8]
  htim1.Init.Period = 65535;
 800f938:	4b1b      	ldr	r3, [pc, #108]	; (800f9a8 <MX_TIM1_Init+0xa0>)
 800f93a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800f93e:	60da      	str	r2, [r3, #12]
  htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 800f940:	4b19      	ldr	r3, [pc, #100]	; (800f9a8 <MX_TIM1_Init+0xa0>)
 800f942:	2200      	movs	r2, #0
 800f944:	611a      	str	r2, [r3, #16]
  htim1.Init.RepetitionCounter = 0;
 800f946:	4b18      	ldr	r3, [pc, #96]	; (800f9a8 <MX_TIM1_Init+0xa0>)
 800f948:	2200      	movs	r2, #0
 800f94a:	615a      	str	r2, [r3, #20]
  htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 800f94c:	4b16      	ldr	r3, [pc, #88]	; (800f9a8 <MX_TIM1_Init+0xa0>)
 800f94e:	2200      	movs	r2, #0
 800f950:	619a      	str	r2, [r3, #24]
  if (HAL_TIM_Base_Init(&htim1) != HAL_OK)
 800f952:	4815      	ldr	r0, [pc, #84]	; (800f9a8 <MX_TIM1_Init+0xa0>)
 800f954:	f7f7 fb0d 	bl	8006f72 <HAL_TIM_Base_Init>
 800f958:	4603      	mov	r3, r0
 800f95a:	2b00      	cmp	r3, #0
 800f95c:	d001      	beq.n	800f962 <MX_TIM1_Init+0x5a>
  {
    Error_Handler();
 800f95e:	f001 fb39 	bl	8010fd4 <Error_Handler>
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 800f962:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800f966:	613b      	str	r3, [r7, #16]
  if (HAL_TIM_ConfigClockSource(&htim1, &sClockSourceConfig) != HAL_OK)
 800f968:	f107 0310 	add.w	r3, r7, #16
 800f96c:	4619      	mov	r1, r3
 800f96e:	480e      	ldr	r0, [pc, #56]	; (800f9a8 <MX_TIM1_Init+0xa0>)
 800f970:	f7f7 ff68 	bl	8007844 <HAL_TIM_ConfigClockSource>
 800f974:	4603      	mov	r3, r0
 800f976:	2b00      	cmp	r3, #0
 800f978:	d001      	beq.n	800f97e <MX_TIM1_Init+0x76>
  {
    Error_Handler();
 800f97a:	f001 fb2b 	bl	8010fd4 <Error_Handler>
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 800f97e:	2300      	movs	r3, #0
 800f980:	607b      	str	r3, [r7, #4]
  sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
 800f982:	2300      	movs	r3, #0
 800f984:	60bb      	str	r3, [r7, #8]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 800f986:	2300      	movs	r3, #0
 800f988:	60fb      	str	r3, [r7, #12]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 800f98a:	1d3b      	adds	r3, r7, #4
 800f98c:	4619      	mov	r1, r3
 800f98e:	4806      	ldr	r0, [pc, #24]	; (800f9a8 <MX_TIM1_Init+0xa0>)
 800f990:	f7f8 fcac 	bl	80082ec <HAL_TIMEx_MasterConfigSynchronization>
 800f994:	4603      	mov	r3, r0
 800f996:	2b00      	cmp	r3, #0
 800f998:	d001      	beq.n	800f99e <MX_TIM1_Init+0x96>
  {
    Error_Handler();
 800f99a:	f001 fb1b 	bl	8010fd4 <Error_Handler>
  }
  /* USER CODE BEGIN TIM1_Init 2 */

  /* USER CODE END TIM1_Init 2 */

}
 800f99e:	bf00      	nop
 800f9a0:	3720      	adds	r7, #32
 800f9a2:	46bd      	mov	sp, r7
 800f9a4:	bd80      	pop	{r7, pc}
 800f9a6:	bf00      	nop
 800f9a8:	24062d90 	.word	0x24062d90
 800f9ac:	40010000 	.word	0x40010000

0800f9b0 <MX_TIM2_Init>:
  * @brief TIM2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM2_Init(void)
{
 800f9b0:	b580      	push	{r7, lr}
 800f9b2:	b08a      	sub	sp, #40	; 0x28
 800f9b4:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN TIM2_Init 0 */

  /* USER CODE END TIM2_Init 0 */

  TIM_MasterConfigTypeDef sMasterConfig = {0};
 800f9b6:	f107 031c 	add.w	r3, r7, #28
 800f9ba:	2200      	movs	r2, #0
 800f9bc:	601a      	str	r2, [r3, #0]
 800f9be:	605a      	str	r2, [r3, #4]
 800f9c0:	609a      	str	r2, [r3, #8]
  TIM_OC_InitTypeDef sConfigOC = {0};
 800f9c2:	463b      	mov	r3, r7
 800f9c4:	2200      	movs	r2, #0
 800f9c6:	601a      	str	r2, [r3, #0]
 800f9c8:	605a      	str	r2, [r3, #4]
 800f9ca:	609a      	str	r2, [r3, #8]
 800f9cc:	60da      	str	r2, [r3, #12]
 800f9ce:	611a      	str	r2, [r3, #16]
 800f9d0:	615a      	str	r2, [r3, #20]
 800f9d2:	619a      	str	r2, [r3, #24]

  /* USER CODE BEGIN TIM2_Init 1 */

  /* USER CODE END TIM2_Init 1 */
  htim2.Instance = TIM2;
 800f9d4:	4b22      	ldr	r3, [pc, #136]	; (800fa60 <MX_TIM2_Init+0xb0>)
 800f9d6:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 800f9da:	601a      	str	r2, [r3, #0]
  htim2.Init.Prescaler = 400;
 800f9dc:	4b20      	ldr	r3, [pc, #128]	; (800fa60 <MX_TIM2_Init+0xb0>)
 800f9de:	f44f 72c8 	mov.w	r2, #400	; 0x190
 800f9e2:	605a      	str	r2, [r3, #4]
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 800f9e4:	4b1e      	ldr	r3, [pc, #120]	; (800fa60 <MX_TIM2_Init+0xb0>)
 800f9e6:	2200      	movs	r2, #0
 800f9e8:	609a      	str	r2, [r3, #8]
  htim2.Init.Period = 100;
 800f9ea:	4b1d      	ldr	r3, [pc, #116]	; (800fa60 <MX_TIM2_Init+0xb0>)
 800f9ec:	2264      	movs	r2, #100	; 0x64
 800f9ee:	60da      	str	r2, [r3, #12]
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 800f9f0:	4b1b      	ldr	r3, [pc, #108]	; (800fa60 <MX_TIM2_Init+0xb0>)
 800f9f2:	2200      	movs	r2, #0
 800f9f4:	611a      	str	r2, [r3, #16]
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
 800f9f6:	4b1a      	ldr	r3, [pc, #104]	; (800fa60 <MX_TIM2_Init+0xb0>)
 800f9f8:	2280      	movs	r2, #128	; 0x80
 800f9fa:	619a      	str	r2, [r3, #24]
  if (HAL_TIM_PWM_Init(&htim2) != HAL_OK)
 800f9fc:	4818      	ldr	r0, [pc, #96]	; (800fa60 <MX_TIM2_Init+0xb0>)
 800f9fe:	f7f7 fb87 	bl	8007110 <HAL_TIM_PWM_Init>
 800fa02:	4603      	mov	r3, r0
 800fa04:	2b00      	cmp	r3, #0
 800fa06:	d001      	beq.n	800fa0c <MX_TIM2_Init+0x5c>
  {
    Error_Handler();
 800fa08:	f001 fae4 	bl	8010fd4 <Error_Handler>
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 800fa0c:	2300      	movs	r3, #0
 800fa0e:	61fb      	str	r3, [r7, #28]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 800fa10:	2300      	movs	r3, #0
 800fa12:	627b      	str	r3, [r7, #36]	; 0x24
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 800fa14:	f107 031c 	add.w	r3, r7, #28
 800fa18:	4619      	mov	r1, r3
 800fa1a:	4811      	ldr	r0, [pc, #68]	; (800fa60 <MX_TIM2_Init+0xb0>)
 800fa1c:	f7f8 fc66 	bl	80082ec <HAL_TIMEx_MasterConfigSynchronization>
 800fa20:	4603      	mov	r3, r0
 800fa22:	2b00      	cmp	r3, #0
 800fa24:	d001      	beq.n	800fa2a <MX_TIM2_Init+0x7a>
  {
    Error_Handler();
 800fa26:	f001 fad5 	bl	8010fd4 <Error_Handler>
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 800fa2a:	2360      	movs	r3, #96	; 0x60
 800fa2c:	603b      	str	r3, [r7, #0]
  sConfigOC.Pulse = 50;
 800fa2e:	2332      	movs	r3, #50	; 0x32
 800fa30:	607b      	str	r3, [r7, #4]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 800fa32:	2300      	movs	r3, #0
 800fa34:	60bb      	str	r3, [r7, #8]
  sConfigOC.OCFastMode = TIM_OCFAST_ENABLE;
 800fa36:	2304      	movs	r3, #4
 800fa38:	613b      	str	r3, [r7, #16]
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 800fa3a:	463b      	mov	r3, r7
 800fa3c:	2200      	movs	r2, #0
 800fa3e:	4619      	mov	r1, r3
 800fa40:	4807      	ldr	r0, [pc, #28]	; (800fa60 <MX_TIM2_Init+0xb0>)
 800fa42:	f7f7 fdeb 	bl	800761c <HAL_TIM_PWM_ConfigChannel>
 800fa46:	4603      	mov	r3, r0
 800fa48:	2b00      	cmp	r3, #0
 800fa4a:	d001      	beq.n	800fa50 <MX_TIM2_Init+0xa0>
  {
    Error_Handler();
 800fa4c:	f001 fac2 	bl	8010fd4 <Error_Handler>
  }
  /* USER CODE BEGIN TIM2_Init 2 */

  /* USER CODE END TIM2_Init 2 */
  HAL_TIM_MspPostInit(&htim2);
 800fa50:	4803      	ldr	r0, [pc, #12]	; (800fa60 <MX_TIM2_Init+0xb0>)
 800fa52:	f001 fe81 	bl	8011758 <HAL_TIM_MspPostInit>

}
 800fa56:	bf00      	nop
 800fa58:	3728      	adds	r7, #40	; 0x28
 800fa5a:	46bd      	mov	sp, r7
 800fa5c:	bd80      	pop	{r7, pc}
 800fa5e:	bf00      	nop
 800fa60:	24062f88 	.word	0x24062f88

0800fa64 <MX_TIM12_Init>:
  * @brief TIM12 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM12_Init(void)
{
 800fa64:	b580      	push	{r7, lr}
 800fa66:	b08c      	sub	sp, #48	; 0x30
 800fa68:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN TIM12_Init 0 */

  /* USER CODE END TIM12_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 800fa6a:	f107 0320 	add.w	r3, r7, #32
 800fa6e:	2200      	movs	r2, #0
 800fa70:	601a      	str	r2, [r3, #0]
 800fa72:	605a      	str	r2, [r3, #4]
 800fa74:	609a      	str	r2, [r3, #8]
 800fa76:	60da      	str	r2, [r3, #12]
  TIM_OC_InitTypeDef sConfigOC = {0};
 800fa78:	1d3b      	adds	r3, r7, #4
 800fa7a:	2200      	movs	r2, #0
 800fa7c:	601a      	str	r2, [r3, #0]
 800fa7e:	605a      	str	r2, [r3, #4]
 800fa80:	609a      	str	r2, [r3, #8]
 800fa82:	60da      	str	r2, [r3, #12]
 800fa84:	611a      	str	r2, [r3, #16]
 800fa86:	615a      	str	r2, [r3, #20]
 800fa88:	619a      	str	r2, [r3, #24]

  /* USER CODE BEGIN TIM12_Init 1 */

  /* USER CODE END TIM12_Init 1 */
  htim12.Instance = TIM12;
 800fa8a:	4b2b      	ldr	r3, [pc, #172]	; (800fb38 <MX_TIM12_Init+0xd4>)
 800fa8c:	4a2b      	ldr	r2, [pc, #172]	; (800fb3c <MX_TIM12_Init+0xd8>)
 800fa8e:	601a      	str	r2, [r3, #0]
  htim12.Init.Prescaler = 0;
 800fa90:	4b29      	ldr	r3, [pc, #164]	; (800fb38 <MX_TIM12_Init+0xd4>)
 800fa92:	2200      	movs	r2, #0
 800fa94:	605a      	str	r2, [r3, #4]
  htim12.Init.CounterMode = TIM_COUNTERMODE_UP;
 800fa96:	4b28      	ldr	r3, [pc, #160]	; (800fb38 <MX_TIM12_Init+0xd4>)
 800fa98:	2200      	movs	r2, #0
 800fa9a:	609a      	str	r2, [r3, #8]
  htim12.Init.Period = 65535;
 800fa9c:	4b26      	ldr	r3, [pc, #152]	; (800fb38 <MX_TIM12_Init+0xd4>)
 800fa9e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800faa2:	60da      	str	r2, [r3, #12]
  htim12.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 800faa4:	4b24      	ldr	r3, [pc, #144]	; (800fb38 <MX_TIM12_Init+0xd4>)
 800faa6:	2200      	movs	r2, #0
 800faa8:	611a      	str	r2, [r3, #16]
  htim12.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 800faaa:	4b23      	ldr	r3, [pc, #140]	; (800fb38 <MX_TIM12_Init+0xd4>)
 800faac:	2200      	movs	r2, #0
 800faae:	619a      	str	r2, [r3, #24]
  if (HAL_TIM_Base_Init(&htim12) != HAL_OK)
 800fab0:	4821      	ldr	r0, [pc, #132]	; (800fb38 <MX_TIM12_Init+0xd4>)
 800fab2:	f7f7 fa5e 	bl	8006f72 <HAL_TIM_Base_Init>
 800fab6:	4603      	mov	r3, r0
 800fab8:	2b00      	cmp	r3, #0
 800faba:	d001      	beq.n	800fac0 <MX_TIM12_Init+0x5c>
  {
    Error_Handler();
 800fabc:	f001 fa8a 	bl	8010fd4 <Error_Handler>
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 800fac0:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800fac4:	623b      	str	r3, [r7, #32]
  if (HAL_TIM_ConfigClockSource(&htim12, &sClockSourceConfig) != HAL_OK)
 800fac6:	f107 0320 	add.w	r3, r7, #32
 800faca:	4619      	mov	r1, r3
 800facc:	481a      	ldr	r0, [pc, #104]	; (800fb38 <MX_TIM12_Init+0xd4>)
 800face:	f7f7 feb9 	bl	8007844 <HAL_TIM_ConfigClockSource>
 800fad2:	4603      	mov	r3, r0
 800fad4:	2b00      	cmp	r3, #0
 800fad6:	d001      	beq.n	800fadc <MX_TIM12_Init+0x78>
  {
    Error_Handler();
 800fad8:	f001 fa7c 	bl	8010fd4 <Error_Handler>
  }
  if (HAL_TIM_PWM_Init(&htim12) != HAL_OK)
 800fadc:	4816      	ldr	r0, [pc, #88]	; (800fb38 <MX_TIM12_Init+0xd4>)
 800fade:	f7f7 fb17 	bl	8007110 <HAL_TIM_PWM_Init>
 800fae2:	4603      	mov	r3, r0
 800fae4:	2b00      	cmp	r3, #0
 800fae6:	d001      	beq.n	800faec <MX_TIM12_Init+0x88>
  {
    Error_Handler();
 800fae8:	f001 fa74 	bl	8010fd4 <Error_Handler>
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 800faec:	2360      	movs	r3, #96	; 0x60
 800faee:	607b      	str	r3, [r7, #4]
  sConfigOC.Pulse = 0;
 800faf0:	2300      	movs	r3, #0
 800faf2:	60bb      	str	r3, [r7, #8]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 800faf4:	2300      	movs	r3, #0
 800faf6:	60fb      	str	r3, [r7, #12]
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 800faf8:	2300      	movs	r3, #0
 800fafa:	617b      	str	r3, [r7, #20]
  if (HAL_TIM_PWM_ConfigChannel(&htim12, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 800fafc:	1d3b      	adds	r3, r7, #4
 800fafe:	2200      	movs	r2, #0
 800fb00:	4619      	mov	r1, r3
 800fb02:	480d      	ldr	r0, [pc, #52]	; (800fb38 <MX_TIM12_Init+0xd4>)
 800fb04:	f7f7 fd8a 	bl	800761c <HAL_TIM_PWM_ConfigChannel>
 800fb08:	4603      	mov	r3, r0
 800fb0a:	2b00      	cmp	r3, #0
 800fb0c:	d001      	beq.n	800fb12 <MX_TIM12_Init+0xae>
  {
    Error_Handler();
 800fb0e:	f001 fa61 	bl	8010fd4 <Error_Handler>
  }
  if (HAL_TIM_PWM_ConfigChannel(&htim12, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 800fb12:	1d3b      	adds	r3, r7, #4
 800fb14:	2204      	movs	r2, #4
 800fb16:	4619      	mov	r1, r3
 800fb18:	4807      	ldr	r0, [pc, #28]	; (800fb38 <MX_TIM12_Init+0xd4>)
 800fb1a:	f7f7 fd7f 	bl	800761c <HAL_TIM_PWM_ConfigChannel>
 800fb1e:	4603      	mov	r3, r0
 800fb20:	2b00      	cmp	r3, #0
 800fb22:	d001      	beq.n	800fb28 <MX_TIM12_Init+0xc4>
  {
    Error_Handler();
 800fb24:	f001 fa56 	bl	8010fd4 <Error_Handler>
  }
  /* USER CODE BEGIN TIM12_Init 2 */

  /* USER CODE END TIM12_Init 2 */
  HAL_TIM_MspPostInit(&htim12);
 800fb28:	4803      	ldr	r0, [pc, #12]	; (800fb38 <MX_TIM12_Init+0xd4>)
 800fb2a:	f001 fe15 	bl	8011758 <HAL_TIM_MspPostInit>

}
 800fb2e:	bf00      	nop
 800fb30:	3730      	adds	r7, #48	; 0x30
 800fb32:	46bd      	mov	sp, r7
 800fb34:	bd80      	pop	{r7, pc}
 800fb36:	bf00      	nop
 800fb38:	24063190 	.word	0x24063190
 800fb3c:	40001800 	.word	0x40001800

0800fb40 <MX_UART4_Init>:
  * @brief UART4 Initialization Function
  * @param None
  * @retval None
  */
static void MX_UART4_Init(void)
{
 800fb40:	b580      	push	{r7, lr}
 800fb42:	af00      	add	r7, sp, #0
  /* USER CODE END UART4_Init 0 */

  /* USER CODE BEGIN UART4_Init 1 */

  /* USER CODE END UART4_Init 1 */
  huart4.Instance = UART4;
 800fb44:	4b22      	ldr	r3, [pc, #136]	; (800fbd0 <MX_UART4_Init+0x90>)
 800fb46:	4a23      	ldr	r2, [pc, #140]	; (800fbd4 <MX_UART4_Init+0x94>)
 800fb48:	601a      	str	r2, [r3, #0]
  huart4.Init.BaudRate = 500000;
 800fb4a:	4b21      	ldr	r3, [pc, #132]	; (800fbd0 <MX_UART4_Init+0x90>)
 800fb4c:	4a22      	ldr	r2, [pc, #136]	; (800fbd8 <MX_UART4_Init+0x98>)
 800fb4e:	605a      	str	r2, [r3, #4]
  huart4.Init.WordLength = UART_WORDLENGTH_8B;
 800fb50:	4b1f      	ldr	r3, [pc, #124]	; (800fbd0 <MX_UART4_Init+0x90>)
 800fb52:	2200      	movs	r2, #0
 800fb54:	609a      	str	r2, [r3, #8]
  huart4.Init.StopBits = UART_STOPBITS_1;
 800fb56:	4b1e      	ldr	r3, [pc, #120]	; (800fbd0 <MX_UART4_Init+0x90>)
 800fb58:	2200      	movs	r2, #0
 800fb5a:	60da      	str	r2, [r3, #12]
  huart4.Init.Parity = UART_PARITY_NONE;
 800fb5c:	4b1c      	ldr	r3, [pc, #112]	; (800fbd0 <MX_UART4_Init+0x90>)
 800fb5e:	2200      	movs	r2, #0
 800fb60:	611a      	str	r2, [r3, #16]
  huart4.Init.Mode = UART_MODE_TX_RX;
 800fb62:	4b1b      	ldr	r3, [pc, #108]	; (800fbd0 <MX_UART4_Init+0x90>)
 800fb64:	220c      	movs	r2, #12
 800fb66:	615a      	str	r2, [r3, #20]
  huart4.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 800fb68:	4b19      	ldr	r3, [pc, #100]	; (800fbd0 <MX_UART4_Init+0x90>)
 800fb6a:	2200      	movs	r2, #0
 800fb6c:	619a      	str	r2, [r3, #24]
  huart4.Init.OverSampling = UART_OVERSAMPLING_16;
 800fb6e:	4b18      	ldr	r3, [pc, #96]	; (800fbd0 <MX_UART4_Init+0x90>)
 800fb70:	2200      	movs	r2, #0
 800fb72:	61da      	str	r2, [r3, #28]
  huart4.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 800fb74:	4b16      	ldr	r3, [pc, #88]	; (800fbd0 <MX_UART4_Init+0x90>)
 800fb76:	2200      	movs	r2, #0
 800fb78:	621a      	str	r2, [r3, #32]
  huart4.Init.ClockPrescaler = UART_PRESCALER_DIV1;
 800fb7a:	4b15      	ldr	r3, [pc, #84]	; (800fbd0 <MX_UART4_Init+0x90>)
 800fb7c:	2200      	movs	r2, #0
 800fb7e:	625a      	str	r2, [r3, #36]	; 0x24
  huart4.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 800fb80:	4b13      	ldr	r3, [pc, #76]	; (800fbd0 <MX_UART4_Init+0x90>)
 800fb82:	2200      	movs	r2, #0
 800fb84:	629a      	str	r2, [r3, #40]	; 0x28
  if (HAL_UART_Init(&huart4) != HAL_OK)
 800fb86:	4812      	ldr	r0, [pc, #72]	; (800fbd0 <MX_UART4_Init+0x90>)
 800fb88:	f7f8 fc5c 	bl	8008444 <HAL_UART_Init>
 800fb8c:	4603      	mov	r3, r0
 800fb8e:	2b00      	cmp	r3, #0
 800fb90:	d001      	beq.n	800fb96 <MX_UART4_Init+0x56>
  {
    Error_Handler();
 800fb92:	f001 fa1f 	bl	8010fd4 <Error_Handler>
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart4, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 800fb96:	2100      	movs	r1, #0
 800fb98:	480d      	ldr	r0, [pc, #52]	; (800fbd0 <MX_UART4_Init+0x90>)
 800fb9a:	f7fa fc2d 	bl	800a3f8 <HAL_UARTEx_SetTxFifoThreshold>
 800fb9e:	4603      	mov	r3, r0
 800fba0:	2b00      	cmp	r3, #0
 800fba2:	d001      	beq.n	800fba8 <MX_UART4_Init+0x68>
  {
    Error_Handler();
 800fba4:	f001 fa16 	bl	8010fd4 <Error_Handler>
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart4, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 800fba8:	2100      	movs	r1, #0
 800fbaa:	4809      	ldr	r0, [pc, #36]	; (800fbd0 <MX_UART4_Init+0x90>)
 800fbac:	f7fa fc62 	bl	800a474 <HAL_UARTEx_SetRxFifoThreshold>
 800fbb0:	4603      	mov	r3, r0
 800fbb2:	2b00      	cmp	r3, #0
 800fbb4:	d001      	beq.n	800fbba <MX_UART4_Init+0x7a>
  {
    Error_Handler();
 800fbb6:	f001 fa0d 	bl	8010fd4 <Error_Handler>
  }
  if (HAL_UARTEx_DisableFifoMode(&huart4) != HAL_OK)
 800fbba:	4805      	ldr	r0, [pc, #20]	; (800fbd0 <MX_UART4_Init+0x90>)
 800fbbc:	f7fa fbe3 	bl	800a386 <HAL_UARTEx_DisableFifoMode>
 800fbc0:	4603      	mov	r3, r0
 800fbc2:	2b00      	cmp	r3, #0
 800fbc4:	d001      	beq.n	800fbca <MX_UART4_Init+0x8a>
  {
    Error_Handler();
 800fbc6:	f001 fa05 	bl	8010fd4 <Error_Handler>
  }
  /* USER CODE BEGIN UART4_Init 2 */

  /* USER CODE END UART4_Init 2 */

}
 800fbca:	bf00      	nop
 800fbcc:	bd80      	pop	{r7, pc}
 800fbce:	bf00      	nop
 800fbd0:	24062e6c 	.word	0x24062e6c
 800fbd4:	40004c00 	.word	0x40004c00
 800fbd8:	0007a120 	.word	0x0007a120

0800fbdc <MX_UART8_Init>:
  * @brief UART8 Initialization Function
  * @param None
  * @retval None
  */
static void MX_UART8_Init(void)
{
 800fbdc:	b580      	push	{r7, lr}
 800fbde:	af00      	add	r7, sp, #0
  /* USER CODE END UART8_Init 0 */

  /* USER CODE BEGIN UART8_Init 1 */

  /* USER CODE END UART8_Init 1 */
  huart8.Instance = UART8;
 800fbe0:	4b22      	ldr	r3, [pc, #136]	; (800fc6c <MX_UART8_Init+0x90>)
 800fbe2:	4a23      	ldr	r2, [pc, #140]	; (800fc70 <MX_UART8_Init+0x94>)
 800fbe4:	601a      	str	r2, [r3, #0]
  huart8.Init.BaudRate = 2000000;
 800fbe6:	4b21      	ldr	r3, [pc, #132]	; (800fc6c <MX_UART8_Init+0x90>)
 800fbe8:	4a22      	ldr	r2, [pc, #136]	; (800fc74 <MX_UART8_Init+0x98>)
 800fbea:	605a      	str	r2, [r3, #4]
  huart8.Init.WordLength = UART_WORDLENGTH_8B;
 800fbec:	4b1f      	ldr	r3, [pc, #124]	; (800fc6c <MX_UART8_Init+0x90>)
 800fbee:	2200      	movs	r2, #0
 800fbf0:	609a      	str	r2, [r3, #8]
  huart8.Init.StopBits = UART_STOPBITS_1;
 800fbf2:	4b1e      	ldr	r3, [pc, #120]	; (800fc6c <MX_UART8_Init+0x90>)
 800fbf4:	2200      	movs	r2, #0
 800fbf6:	60da      	str	r2, [r3, #12]
  huart8.Init.Parity = UART_PARITY_NONE;
 800fbf8:	4b1c      	ldr	r3, [pc, #112]	; (800fc6c <MX_UART8_Init+0x90>)
 800fbfa:	2200      	movs	r2, #0
 800fbfc:	611a      	str	r2, [r3, #16]
  huart8.Init.Mode = UART_MODE_TX_RX;
 800fbfe:	4b1b      	ldr	r3, [pc, #108]	; (800fc6c <MX_UART8_Init+0x90>)
 800fc00:	220c      	movs	r2, #12
 800fc02:	615a      	str	r2, [r3, #20]
  huart8.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 800fc04:	4b19      	ldr	r3, [pc, #100]	; (800fc6c <MX_UART8_Init+0x90>)
 800fc06:	2200      	movs	r2, #0
 800fc08:	619a      	str	r2, [r3, #24]
  huart8.Init.OverSampling = UART_OVERSAMPLING_16;
 800fc0a:	4b18      	ldr	r3, [pc, #96]	; (800fc6c <MX_UART8_Init+0x90>)
 800fc0c:	2200      	movs	r2, #0
 800fc0e:	61da      	str	r2, [r3, #28]
  huart8.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 800fc10:	4b16      	ldr	r3, [pc, #88]	; (800fc6c <MX_UART8_Init+0x90>)
 800fc12:	2200      	movs	r2, #0
 800fc14:	621a      	str	r2, [r3, #32]
  huart8.Init.ClockPrescaler = UART_PRESCALER_DIV1;
 800fc16:	4b15      	ldr	r3, [pc, #84]	; (800fc6c <MX_UART8_Init+0x90>)
 800fc18:	2200      	movs	r2, #0
 800fc1a:	625a      	str	r2, [r3, #36]	; 0x24
  huart8.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 800fc1c:	4b13      	ldr	r3, [pc, #76]	; (800fc6c <MX_UART8_Init+0x90>)
 800fc1e:	2200      	movs	r2, #0
 800fc20:	629a      	str	r2, [r3, #40]	; 0x28
  if (HAL_UART_Init(&huart8) != HAL_OK)
 800fc22:	4812      	ldr	r0, [pc, #72]	; (800fc6c <MX_UART8_Init+0x90>)
 800fc24:	f7f8 fc0e 	bl	8008444 <HAL_UART_Init>
 800fc28:	4603      	mov	r3, r0
 800fc2a:	2b00      	cmp	r3, #0
 800fc2c:	d001      	beq.n	800fc32 <MX_UART8_Init+0x56>
  {
    Error_Handler();
 800fc2e:	f001 f9d1 	bl	8010fd4 <Error_Handler>
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart8, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 800fc32:	2100      	movs	r1, #0
 800fc34:	480d      	ldr	r0, [pc, #52]	; (800fc6c <MX_UART8_Init+0x90>)
 800fc36:	f7fa fbdf 	bl	800a3f8 <HAL_UARTEx_SetTxFifoThreshold>
 800fc3a:	4603      	mov	r3, r0
 800fc3c:	2b00      	cmp	r3, #0
 800fc3e:	d001      	beq.n	800fc44 <MX_UART8_Init+0x68>
  {
    Error_Handler();
 800fc40:	f001 f9c8 	bl	8010fd4 <Error_Handler>
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart8, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 800fc44:	2100      	movs	r1, #0
 800fc46:	4809      	ldr	r0, [pc, #36]	; (800fc6c <MX_UART8_Init+0x90>)
 800fc48:	f7fa fc14 	bl	800a474 <HAL_UARTEx_SetRxFifoThreshold>
 800fc4c:	4603      	mov	r3, r0
 800fc4e:	2b00      	cmp	r3, #0
 800fc50:	d001      	beq.n	800fc56 <MX_UART8_Init+0x7a>
  {
    Error_Handler();
 800fc52:	f001 f9bf 	bl	8010fd4 <Error_Handler>
  }
  if (HAL_UARTEx_DisableFifoMode(&huart8) != HAL_OK)
 800fc56:	4805      	ldr	r0, [pc, #20]	; (800fc6c <MX_UART8_Init+0x90>)
 800fc58:	f7fa fb95 	bl	800a386 <HAL_UARTEx_DisableFifoMode>
 800fc5c:	4603      	mov	r3, r0
 800fc5e:	2b00      	cmp	r3, #0
 800fc60:	d001      	beq.n	800fc66 <MX_UART8_Init+0x8a>
  {
    Error_Handler();
 800fc62:	f001 f9b7 	bl	8010fd4 <Error_Handler>
  }
  /* USER CODE BEGIN UART8_Init 2 */

  /* USER CODE END UART8_Init 2 */

}
 800fc66:	bf00      	nop
 800fc68:	bd80      	pop	{r7, pc}
 800fc6a:	bf00      	nop
 800fc6c:	24062ddc 	.word	0x24062ddc
 800fc70:	40007c00 	.word	0x40007c00
 800fc74:	001e8480 	.word	0x001e8480

0800fc78 <MX_USART2_UART_Init>:
  * @brief USART2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART2_UART_Init(void)
{
 800fc78:	b580      	push	{r7, lr}
 800fc7a:	af00      	add	r7, sp, #0
  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
 800fc7c:	4b22      	ldr	r3, [pc, #136]	; (800fd08 <MX_USART2_UART_Init+0x90>)
 800fc7e:	4a23      	ldr	r2, [pc, #140]	; (800fd0c <MX_USART2_UART_Init+0x94>)
 800fc80:	601a      	str	r2, [r3, #0]
  huart2.Init.BaudRate = 500000;
 800fc82:	4b21      	ldr	r3, [pc, #132]	; (800fd08 <MX_USART2_UART_Init+0x90>)
 800fc84:	4a22      	ldr	r2, [pc, #136]	; (800fd10 <MX_USART2_UART_Init+0x98>)
 800fc86:	605a      	str	r2, [r3, #4]
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
 800fc88:	4b1f      	ldr	r3, [pc, #124]	; (800fd08 <MX_USART2_UART_Init+0x90>)
 800fc8a:	2200      	movs	r2, #0
 800fc8c:	609a      	str	r2, [r3, #8]
  huart2.Init.StopBits = UART_STOPBITS_1;
 800fc8e:	4b1e      	ldr	r3, [pc, #120]	; (800fd08 <MX_USART2_UART_Init+0x90>)
 800fc90:	2200      	movs	r2, #0
 800fc92:	60da      	str	r2, [r3, #12]
  huart2.Init.Parity = UART_PARITY_NONE;
 800fc94:	4b1c      	ldr	r3, [pc, #112]	; (800fd08 <MX_USART2_UART_Init+0x90>)
 800fc96:	2200      	movs	r2, #0
 800fc98:	611a      	str	r2, [r3, #16]
  huart2.Init.Mode = UART_MODE_TX_RX;
 800fc9a:	4b1b      	ldr	r3, [pc, #108]	; (800fd08 <MX_USART2_UART_Init+0x90>)
 800fc9c:	220c      	movs	r2, #12
 800fc9e:	615a      	str	r2, [r3, #20]
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 800fca0:	4b19      	ldr	r3, [pc, #100]	; (800fd08 <MX_USART2_UART_Init+0x90>)
 800fca2:	2200      	movs	r2, #0
 800fca4:	619a      	str	r2, [r3, #24]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 800fca6:	4b18      	ldr	r3, [pc, #96]	; (800fd08 <MX_USART2_UART_Init+0x90>)
 800fca8:	2200      	movs	r2, #0
 800fcaa:	61da      	str	r2, [r3, #28]
  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 800fcac:	4b16      	ldr	r3, [pc, #88]	; (800fd08 <MX_USART2_UART_Init+0x90>)
 800fcae:	2200      	movs	r2, #0
 800fcb0:	621a      	str	r2, [r3, #32]
  huart2.Init.ClockPrescaler = UART_PRESCALER_DIV1;
 800fcb2:	4b15      	ldr	r3, [pc, #84]	; (800fd08 <MX_USART2_UART_Init+0x90>)
 800fcb4:	2200      	movs	r2, #0
 800fcb6:	625a      	str	r2, [r3, #36]	; 0x24
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 800fcb8:	4b13      	ldr	r3, [pc, #76]	; (800fd08 <MX_USART2_UART_Init+0x90>)
 800fcba:	2200      	movs	r2, #0
 800fcbc:	629a      	str	r2, [r3, #40]	; 0x28
  if (HAL_UART_Init(&huart2) != HAL_OK)
 800fcbe:	4812      	ldr	r0, [pc, #72]	; (800fd08 <MX_USART2_UART_Init+0x90>)
 800fcc0:	f7f8 fbc0 	bl	8008444 <HAL_UART_Init>
 800fcc4:	4603      	mov	r3, r0
 800fcc6:	2b00      	cmp	r3, #0
 800fcc8:	d001      	beq.n	800fcce <MX_USART2_UART_Init+0x56>
  {
    Error_Handler();
 800fcca:	f001 f983 	bl	8010fd4 <Error_Handler>
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart2, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 800fcce:	2100      	movs	r1, #0
 800fcd0:	480d      	ldr	r0, [pc, #52]	; (800fd08 <MX_USART2_UART_Init+0x90>)
 800fcd2:	f7fa fb91 	bl	800a3f8 <HAL_UARTEx_SetTxFifoThreshold>
 800fcd6:	4603      	mov	r3, r0
 800fcd8:	2b00      	cmp	r3, #0
 800fcda:	d001      	beq.n	800fce0 <MX_USART2_UART_Init+0x68>
  {
    Error_Handler();
 800fcdc:	f001 f97a 	bl	8010fd4 <Error_Handler>
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart2, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 800fce0:	2100      	movs	r1, #0
 800fce2:	4809      	ldr	r0, [pc, #36]	; (800fd08 <MX_USART2_UART_Init+0x90>)
 800fce4:	f7fa fbc6 	bl	800a474 <HAL_UARTEx_SetRxFifoThreshold>
 800fce8:	4603      	mov	r3, r0
 800fcea:	2b00      	cmp	r3, #0
 800fcec:	d001      	beq.n	800fcf2 <MX_USART2_UART_Init+0x7a>
  {
    Error_Handler();
 800fcee:	f001 f971 	bl	8010fd4 <Error_Handler>
  }
  if (HAL_UARTEx_DisableFifoMode(&huart2) != HAL_OK)
 800fcf2:	4805      	ldr	r0, [pc, #20]	; (800fd08 <MX_USART2_UART_Init+0x90>)
 800fcf4:	f7fa fb47 	bl	800a386 <HAL_UARTEx_DisableFifoMode>
 800fcf8:	4603      	mov	r3, r0
 800fcfa:	2b00      	cmp	r3, #0
 800fcfc:	d001      	beq.n	800fd02 <MX_USART2_UART_Init+0x8a>
  {
    Error_Handler();
 800fcfe:	f001 f969 	bl	8010fd4 <Error_Handler>
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}
 800fd02:	bf00      	nop
 800fd04:	bd80      	pop	{r7, pc}
 800fd06:	bf00      	nop
 800fd08:	24063020 	.word	0x24063020
 800fd0c:	40004400 	.word	0x40004400
 800fd10:	0007a120 	.word	0x0007a120

0800fd14 <MX_USART3_UART_Init>:
  * @brief USART3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART3_UART_Init(void)
{
 800fd14:	b580      	push	{r7, lr}
 800fd16:	af00      	add	r7, sp, #0
  /* USER CODE END USART3_Init 0 */

  /* USER CODE BEGIN USART3_Init 1 */

  /* USER CODE END USART3_Init 1 */
  huart3.Instance = USART3;
 800fd18:	4b22      	ldr	r3, [pc, #136]	; (800fda4 <MX_USART3_UART_Init+0x90>)
 800fd1a:	4a23      	ldr	r2, [pc, #140]	; (800fda8 <MX_USART3_UART_Init+0x94>)
 800fd1c:	601a      	str	r2, [r3, #0]
  huart3.Init.BaudRate = 2000000;
 800fd1e:	4b21      	ldr	r3, [pc, #132]	; (800fda4 <MX_USART3_UART_Init+0x90>)
 800fd20:	4a22      	ldr	r2, [pc, #136]	; (800fdac <MX_USART3_UART_Init+0x98>)
 800fd22:	605a      	str	r2, [r3, #4]
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
 800fd24:	4b1f      	ldr	r3, [pc, #124]	; (800fda4 <MX_USART3_UART_Init+0x90>)
 800fd26:	2200      	movs	r2, #0
 800fd28:	609a      	str	r2, [r3, #8]
  huart3.Init.StopBits = UART_STOPBITS_1;
 800fd2a:	4b1e      	ldr	r3, [pc, #120]	; (800fda4 <MX_USART3_UART_Init+0x90>)
 800fd2c:	2200      	movs	r2, #0
 800fd2e:	60da      	str	r2, [r3, #12]
  huart3.Init.Parity = UART_PARITY_NONE;
 800fd30:	4b1c      	ldr	r3, [pc, #112]	; (800fda4 <MX_USART3_UART_Init+0x90>)
 800fd32:	2200      	movs	r2, #0
 800fd34:	611a      	str	r2, [r3, #16]
  huart3.Init.Mode = UART_MODE_TX_RX;
 800fd36:	4b1b      	ldr	r3, [pc, #108]	; (800fda4 <MX_USART3_UART_Init+0x90>)
 800fd38:	220c      	movs	r2, #12
 800fd3a:	615a      	str	r2, [r3, #20]
  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 800fd3c:	4b19      	ldr	r3, [pc, #100]	; (800fda4 <MX_USART3_UART_Init+0x90>)
 800fd3e:	2200      	movs	r2, #0
 800fd40:	619a      	str	r2, [r3, #24]
  huart3.Init.OverSampling = UART_OVERSAMPLING_16;
 800fd42:	4b18      	ldr	r3, [pc, #96]	; (800fda4 <MX_USART3_UART_Init+0x90>)
 800fd44:	2200      	movs	r2, #0
 800fd46:	61da      	str	r2, [r3, #28]
  huart3.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 800fd48:	4b16      	ldr	r3, [pc, #88]	; (800fda4 <MX_USART3_UART_Init+0x90>)
 800fd4a:	2200      	movs	r2, #0
 800fd4c:	621a      	str	r2, [r3, #32]
  huart3.Init.ClockPrescaler = UART_PRESCALER_DIV1;
 800fd4e:	4b15      	ldr	r3, [pc, #84]	; (800fda4 <MX_USART3_UART_Init+0x90>)
 800fd50:	2200      	movs	r2, #0
 800fd52:	625a      	str	r2, [r3, #36]	; 0x24
  huart3.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 800fd54:	4b13      	ldr	r3, [pc, #76]	; (800fda4 <MX_USART3_UART_Init+0x90>)
 800fd56:	2200      	movs	r2, #0
 800fd58:	629a      	str	r2, [r3, #40]	; 0x28
  if (HAL_UART_Init(&huart3) != HAL_OK)
 800fd5a:	4812      	ldr	r0, [pc, #72]	; (800fda4 <MX_USART3_UART_Init+0x90>)
 800fd5c:	f7f8 fb72 	bl	8008444 <HAL_UART_Init>
 800fd60:	4603      	mov	r3, r0
 800fd62:	2b00      	cmp	r3, #0
 800fd64:	d001      	beq.n	800fd6a <MX_USART3_UART_Init+0x56>
  {
    Error_Handler();
 800fd66:	f001 f935 	bl	8010fd4 <Error_Handler>
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart3, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 800fd6a:	2100      	movs	r1, #0
 800fd6c:	480d      	ldr	r0, [pc, #52]	; (800fda4 <MX_USART3_UART_Init+0x90>)
 800fd6e:	f7fa fb43 	bl	800a3f8 <HAL_UARTEx_SetTxFifoThreshold>
 800fd72:	4603      	mov	r3, r0
 800fd74:	2b00      	cmp	r3, #0
 800fd76:	d001      	beq.n	800fd7c <MX_USART3_UART_Init+0x68>
  {
    Error_Handler();
 800fd78:	f001 f92c 	bl	8010fd4 <Error_Handler>
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart3, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 800fd7c:	2100      	movs	r1, #0
 800fd7e:	4809      	ldr	r0, [pc, #36]	; (800fda4 <MX_USART3_UART_Init+0x90>)
 800fd80:	f7fa fb78 	bl	800a474 <HAL_UARTEx_SetRxFifoThreshold>
 800fd84:	4603      	mov	r3, r0
 800fd86:	2b00      	cmp	r3, #0
 800fd88:	d001      	beq.n	800fd8e <MX_USART3_UART_Init+0x7a>
  {
    Error_Handler();
 800fd8a:	f001 f923 	bl	8010fd4 <Error_Handler>
  }
  if (HAL_UARTEx_DisableFifoMode(&huart3) != HAL_OK)
 800fd8e:	4805      	ldr	r0, [pc, #20]	; (800fda4 <MX_USART3_UART_Init+0x90>)
 800fd90:	f7fa faf9 	bl	800a386 <HAL_UARTEx_DisableFifoMode>
 800fd94:	4603      	mov	r3, r0
 800fd96:	2b00      	cmp	r3, #0
 800fd98:	d001      	beq.n	800fd9e <MX_USART3_UART_Init+0x8a>
  {
    Error_Handler();
 800fd9a:	f001 f91b 	bl	8010fd4 <Error_Handler>
  }
  /* USER CODE BEGIN USART3_Init 2 */

  /* USER CODE END USART3_Init 2 */

}
 800fd9e:	bf00      	nop
 800fda0:	bd80      	pop	{r7, pc}
 800fda2:	bf00      	nop
 800fda4:	24062770 	.word	0x24062770
 800fda8:	40004800 	.word	0x40004800
 800fdac:	001e8480 	.word	0x001e8480

0800fdb0 <MX_DMA_Init>:

/**
  * Enable DMA controller clock
  */
static void MX_DMA_Init(void)
{
 800fdb0:	b580      	push	{r7, lr}
 800fdb2:	b082      	sub	sp, #8
 800fdb4:	af00      	add	r7, sp, #0

  /* DMA controller clock enable */
  __HAL_RCC_DMA1_CLK_ENABLE();
 800fdb6:	4b39      	ldr	r3, [pc, #228]	; (800fe9c <MX_DMA_Init+0xec>)
 800fdb8:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 800fdbc:	4a37      	ldr	r2, [pc, #220]	; (800fe9c <MX_DMA_Init+0xec>)
 800fdbe:	f043 0301 	orr.w	r3, r3, #1
 800fdc2:	f8c2 30d8 	str.w	r3, [r2, #216]	; 0xd8
 800fdc6:	4b35      	ldr	r3, [pc, #212]	; (800fe9c <MX_DMA_Init+0xec>)
 800fdc8:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 800fdcc:	f003 0301 	and.w	r3, r3, #1
 800fdd0:	607b      	str	r3, [r7, #4]
 800fdd2:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_DMA2_CLK_ENABLE();
 800fdd4:	4b31      	ldr	r3, [pc, #196]	; (800fe9c <MX_DMA_Init+0xec>)
 800fdd6:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 800fdda:	4a30      	ldr	r2, [pc, #192]	; (800fe9c <MX_DMA_Init+0xec>)
 800fddc:	f043 0302 	orr.w	r3, r3, #2
 800fde0:	f8c2 30d8 	str.w	r3, [r2, #216]	; 0xd8
 800fde4:	4b2d      	ldr	r3, [pc, #180]	; (800fe9c <MX_DMA_Init+0xec>)
 800fde6:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 800fdea:	f003 0302 	and.w	r3, r3, #2
 800fdee:	603b      	str	r3, [r7, #0]
 800fdf0:	683b      	ldr	r3, [r7, #0]

  /* DMA interrupt init */
  /* DMA1_Stream0_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream0_IRQn, 5, 0);
 800fdf2:	2200      	movs	r2, #0
 800fdf4:	2105      	movs	r1, #5
 800fdf6:	200b      	movs	r0, #11
 800fdf8:	f7f0 fd76 	bl	80008e8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream0_IRQn);
 800fdfc:	200b      	movs	r0, #11
 800fdfe:	f7f0 fd8d 	bl	800091c <HAL_NVIC_EnableIRQ>
  /* DMA1_Stream1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 5, 0);
 800fe02:	2200      	movs	r2, #0
 800fe04:	2105      	movs	r1, #5
 800fe06:	200c      	movs	r0, #12
 800fe08:	f7f0 fd6e 	bl	80008e8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream1_IRQn);
 800fe0c:	200c      	movs	r0, #12
 800fe0e:	f7f0 fd85 	bl	800091c <HAL_NVIC_EnableIRQ>
  /* DMA1_Stream2_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream2_IRQn, 5, 0);
 800fe12:	2200      	movs	r2, #0
 800fe14:	2105      	movs	r1, #5
 800fe16:	200d      	movs	r0, #13
 800fe18:	f7f0 fd66 	bl	80008e8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream2_IRQn);
 800fe1c:	200d      	movs	r0, #13
 800fe1e:	f7f0 fd7d 	bl	800091c <HAL_NVIC_EnableIRQ>
  /* DMA1_Stream3_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream3_IRQn, 5, 0);
 800fe22:	2200      	movs	r2, #0
 800fe24:	2105      	movs	r1, #5
 800fe26:	200e      	movs	r0, #14
 800fe28:	f7f0 fd5e 	bl	80008e8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream3_IRQn);
 800fe2c:	200e      	movs	r0, #14
 800fe2e:	f7f0 fd75 	bl	800091c <HAL_NVIC_EnableIRQ>
  /* DMA1_Stream4_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream4_IRQn, 5, 0);
 800fe32:	2200      	movs	r2, #0
 800fe34:	2105      	movs	r1, #5
 800fe36:	200f      	movs	r0, #15
 800fe38:	f7f0 fd56 	bl	80008e8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream4_IRQn);
 800fe3c:	200f      	movs	r0, #15
 800fe3e:	f7f0 fd6d 	bl	800091c <HAL_NVIC_EnableIRQ>
  /* DMA1_Stream5_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream5_IRQn, 5, 0);
 800fe42:	2200      	movs	r2, #0
 800fe44:	2105      	movs	r1, #5
 800fe46:	2010      	movs	r0, #16
 800fe48:	f7f0 fd4e 	bl	80008e8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream5_IRQn);
 800fe4c:	2010      	movs	r0, #16
 800fe4e:	f7f0 fd65 	bl	800091c <HAL_NVIC_EnableIRQ>
  /* DMA1_Stream6_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream6_IRQn, 5, 0);
 800fe52:	2200      	movs	r2, #0
 800fe54:	2105      	movs	r1, #5
 800fe56:	2011      	movs	r0, #17
 800fe58:	f7f0 fd46 	bl	80008e8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream6_IRQn);
 800fe5c:	2011      	movs	r0, #17
 800fe5e:	f7f0 fd5d 	bl	800091c <HAL_NVIC_EnableIRQ>
  /* DMA1_Stream7_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream7_IRQn, 5, 0);
 800fe62:	2200      	movs	r2, #0
 800fe64:	2105      	movs	r1, #5
 800fe66:	202f      	movs	r0, #47	; 0x2f
 800fe68:	f7f0 fd3e 	bl	80008e8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream7_IRQn);
 800fe6c:	202f      	movs	r0, #47	; 0x2f
 800fe6e:	f7f0 fd55 	bl	800091c <HAL_NVIC_EnableIRQ>
  /* DMA2_Stream0_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream0_IRQn, 5, 0);
 800fe72:	2200      	movs	r2, #0
 800fe74:	2105      	movs	r1, #5
 800fe76:	2038      	movs	r0, #56	; 0x38
 800fe78:	f7f0 fd36 	bl	80008e8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream0_IRQn);
 800fe7c:	2038      	movs	r0, #56	; 0x38
 800fe7e:	f7f0 fd4d 	bl	800091c <HAL_NVIC_EnableIRQ>
  /* DMA2_Stream1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream1_IRQn, 5, 0);
 800fe82:	2200      	movs	r2, #0
 800fe84:	2105      	movs	r1, #5
 800fe86:	2039      	movs	r0, #57	; 0x39
 800fe88:	f7f0 fd2e 	bl	80008e8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream1_IRQn);
 800fe8c:	2039      	movs	r0, #57	; 0x39
 800fe8e:	f7f0 fd45 	bl	800091c <HAL_NVIC_EnableIRQ>

}
 800fe92:	bf00      	nop
 800fe94:	3708      	adds	r7, #8
 800fe96:	46bd      	mov	sp, r7
 800fe98:	bd80      	pop	{r7, pc}
 800fe9a:	bf00      	nop
 800fe9c:	58024400 	.word	0x58024400

0800fea0 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 800fea0:	b580      	push	{r7, lr}
 800fea2:	b090      	sub	sp, #64	; 0x40
 800fea4:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800fea6:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800feaa:	2200      	movs	r2, #0
 800feac:	601a      	str	r2, [r3, #0]
 800feae:	605a      	str	r2, [r3, #4]
 800feb0:	609a      	str	r2, [r3, #8]
 800feb2:	60da      	str	r2, [r3, #12]
 800feb4:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
 800feb6:	4bc2      	ldr	r3, [pc, #776]	; (80101c0 <MX_GPIO_Init+0x320>)
 800feb8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800febc:	4ac0      	ldr	r2, [pc, #768]	; (80101c0 <MX_GPIO_Init+0x320>)
 800febe:	f043 0310 	orr.w	r3, r3, #16
 800fec2:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 800fec6:	4bbe      	ldr	r3, [pc, #760]	; (80101c0 <MX_GPIO_Init+0x320>)
 800fec8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800fecc:	f003 0310 	and.w	r3, r3, #16
 800fed0:	62bb      	str	r3, [r7, #40]	; 0x28
 800fed2:	6abb      	ldr	r3, [r7, #40]	; 0x28
  __HAL_RCC_GPIOI_CLK_ENABLE();
 800fed4:	4bba      	ldr	r3, [pc, #744]	; (80101c0 <MX_GPIO_Init+0x320>)
 800fed6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800feda:	4ab9      	ldr	r2, [pc, #740]	; (80101c0 <MX_GPIO_Init+0x320>)
 800fedc:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800fee0:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 800fee4:	4bb6      	ldr	r3, [pc, #728]	; (80101c0 <MX_GPIO_Init+0x320>)
 800fee6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800feea:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800feee:	627b      	str	r3, [r7, #36]	; 0x24
 800fef0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  __HAL_RCC_GPIOF_CLK_ENABLE();
 800fef2:	4bb3      	ldr	r3, [pc, #716]	; (80101c0 <MX_GPIO_Init+0x320>)
 800fef4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800fef8:	4ab1      	ldr	r2, [pc, #708]	; (80101c0 <MX_GPIO_Init+0x320>)
 800fefa:	f043 0320 	orr.w	r3, r3, #32
 800fefe:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 800ff02:	4baf      	ldr	r3, [pc, #700]	; (80101c0 <MX_GPIO_Init+0x320>)
 800ff04:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800ff08:	f003 0320 	and.w	r3, r3, #32
 800ff0c:	623b      	str	r3, [r7, #32]
 800ff0e:	6a3b      	ldr	r3, [r7, #32]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 800ff10:	4bab      	ldr	r3, [pc, #684]	; (80101c0 <MX_GPIO_Init+0x320>)
 800ff12:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800ff16:	4aaa      	ldr	r2, [pc, #680]	; (80101c0 <MX_GPIO_Init+0x320>)
 800ff18:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800ff1c:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 800ff20:	4ba7      	ldr	r3, [pc, #668]	; (80101c0 <MX_GPIO_Init+0x320>)
 800ff22:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800ff26:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800ff2a:	61fb      	str	r3, [r7, #28]
 800ff2c:	69fb      	ldr	r3, [r7, #28]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800ff2e:	4ba4      	ldr	r3, [pc, #656]	; (80101c0 <MX_GPIO_Init+0x320>)
 800ff30:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800ff34:	4aa2      	ldr	r2, [pc, #648]	; (80101c0 <MX_GPIO_Init+0x320>)
 800ff36:	f043 0301 	orr.w	r3, r3, #1
 800ff3a:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 800ff3e:	4ba0      	ldr	r3, [pc, #640]	; (80101c0 <MX_GPIO_Init+0x320>)
 800ff40:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800ff44:	f003 0301 	and.w	r3, r3, #1
 800ff48:	61bb      	str	r3, [r7, #24]
 800ff4a:	69bb      	ldr	r3, [r7, #24]
  __HAL_RCC_GPIOJ_CLK_ENABLE();
 800ff4c:	4b9c      	ldr	r3, [pc, #624]	; (80101c0 <MX_GPIO_Init+0x320>)
 800ff4e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800ff52:	4a9b      	ldr	r2, [pc, #620]	; (80101c0 <MX_GPIO_Init+0x320>)
 800ff54:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800ff58:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 800ff5c:	4b98      	ldr	r3, [pc, #608]	; (80101c0 <MX_GPIO_Init+0x320>)
 800ff5e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800ff62:	f403 7300 	and.w	r3, r3, #512	; 0x200
 800ff66:	617b      	str	r3, [r7, #20]
 800ff68:	697b      	ldr	r3, [r7, #20]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 800ff6a:	4b95      	ldr	r3, [pc, #596]	; (80101c0 <MX_GPIO_Init+0x320>)
 800ff6c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800ff70:	4a93      	ldr	r2, [pc, #588]	; (80101c0 <MX_GPIO_Init+0x320>)
 800ff72:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800ff76:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 800ff7a:	4b91      	ldr	r3, [pc, #580]	; (80101c0 <MX_GPIO_Init+0x320>)
 800ff7c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800ff80:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800ff84:	613b      	str	r3, [r7, #16]
 800ff86:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 800ff88:	4b8d      	ldr	r3, [pc, #564]	; (80101c0 <MX_GPIO_Init+0x320>)
 800ff8a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800ff8e:	4a8c      	ldr	r2, [pc, #560]	; (80101c0 <MX_GPIO_Init+0x320>)
 800ff90:	f043 0302 	orr.w	r3, r3, #2
 800ff94:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 800ff98:	4b89      	ldr	r3, [pc, #548]	; (80101c0 <MX_GPIO_Init+0x320>)
 800ff9a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800ff9e:	f003 0302 	and.w	r3, r3, #2
 800ffa2:	60fb      	str	r3, [r7, #12]
 800ffa4:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 800ffa6:	4b86      	ldr	r3, [pc, #536]	; (80101c0 <MX_GPIO_Init+0x320>)
 800ffa8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800ffac:	4a84      	ldr	r2, [pc, #528]	; (80101c0 <MX_GPIO_Init+0x320>)
 800ffae:	f043 0308 	orr.w	r3, r3, #8
 800ffb2:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 800ffb6:	4b82      	ldr	r3, [pc, #520]	; (80101c0 <MX_GPIO_Init+0x320>)
 800ffb8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800ffbc:	f003 0308 	and.w	r3, r3, #8
 800ffc0:	60bb      	str	r3, [r7, #8]
 800ffc2:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOK_CLK_ENABLE();
 800ffc4:	4b7e      	ldr	r3, [pc, #504]	; (80101c0 <MX_GPIO_Init+0x320>)
 800ffc6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800ffca:	4a7d      	ldr	r2, [pc, #500]	; (80101c0 <MX_GPIO_Init+0x320>)
 800ffcc:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 800ffd0:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 800ffd4:	4b7a      	ldr	r3, [pc, #488]	; (80101c0 <MX_GPIO_Init+0x320>)
 800ffd6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800ffda:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800ffde:	607b      	str	r3, [r7, #4]
 800ffe0:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 800ffe2:	4b77      	ldr	r3, [pc, #476]	; (80101c0 <MX_GPIO_Init+0x320>)
 800ffe4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800ffe8:	4a75      	ldr	r2, [pc, #468]	; (80101c0 <MX_GPIO_Init+0x320>)
 800ffea:	f043 0304 	orr.w	r3, r3, #4
 800ffee:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 800fff2:	4b73      	ldr	r3, [pc, #460]	; (80101c0 <MX_GPIO_Init+0x320>)
 800fff4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 800fff8:	f003 0304 	and.w	r3, r3, #4
 800fffc:	603b      	str	r3, [r7, #0]
 800fffe:	683b      	ldr	r3, [r7, #0]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_3|GPIO_PIN_0, GPIO_PIN_RESET);
 8010000:	2200      	movs	r2, #0
 8010002:	2109      	movs	r1, #9
 8010004:	486f      	ldr	r0, [pc, #444]	; (80101c4 <MX_GPIO_Init+0x324>)
 8010006:	f7f3 fe97 	bl	8003d38 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOI, GPIO_PIN_9|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14
 801000a:	2200      	movs	r2, #0
 801000c:	f24f 2190 	movw	r1, #62096	; 0xf290
 8010010:	486d      	ldr	r0, [pc, #436]	; (80101c8 <MX_GPIO_Init+0x328>)
 8010012:	f7f3 fe91 	bl	8003d38 <HAL_GPIO_WritePin>
                          |GPIO_PIN_15|GPIO_PIN_4|GPIO_PIN_7, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOF, GPIO_PIN_2|GPIO_PIN_15, GPIO_PIN_RESET);
 8010016:	2200      	movs	r2, #0
 8010018:	f248 0104 	movw	r1, #32772	; 0x8004
 801001c:	486b      	ldr	r0, [pc, #428]	; (80101cc <MX_GPIO_Init+0x32c>)
 801001e:	f7f3 fe8b 	bl	8003d38 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3
 8010022:	2200      	movs	r2, #0
 8010024:	f248 013f 	movw	r1, #32831	; 0x803f
 8010028:	4869      	ldr	r0, [pc, #420]	; (80101d0 <MX_GPIO_Init+0x330>)
 801002a:	f7f3 fe85 	bl	8003d38 <HAL_GPIO_WritePin>
                          |GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_15, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOJ, GPIO_PIN_5|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_15, GPIO_PIN_RESET);
 801002e:	2200      	movs	r2, #0
 8010030:	f24b 0120 	movw	r1, #45088	; 0xb020
 8010034:	4867      	ldr	r0, [pc, #412]	; (80101d4 <MX_GPIO_Init+0x334>)
 8010036:	f7f3 fe7f 	bl	8003d38 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOH, GPIO_PIN_12, GPIO_PIN_RESET);
 801003a:	2200      	movs	r2, #0
 801003c:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8010040:	4865      	ldr	r0, [pc, #404]	; (80101d8 <MX_GPIO_Init+0x338>)
 8010042:	f7f3 fe79 	bl	8003d38 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13, GPIO_PIN_RESET);
 8010046:	2200      	movs	r2, #0
 8010048:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 801004c:	4863      	ldr	r0, [pc, #396]	; (80101dc <MX_GPIO_Init+0x33c>)
 801004e:	f7f3 fe73 	bl	8003d38 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOK, GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5
 8010052:	2200      	movs	r2, #0
 8010054:	21fc      	movs	r1, #252	; 0xfc
 8010056:	4862      	ldr	r0, [pc, #392]	; (80101e0 <MX_GPIO_Init+0x340>)
 8010058:	f7f3 fe6e 	bl	8003d38 <HAL_GPIO_WritePin>
                          |GPIO_PIN_6|GPIO_PIN_7, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOD, GPIO_PIN_3|GPIO_PIN_6, GPIO_PIN_RESET);
 801005c:	2200      	movs	r2, #0
 801005e:	2148      	movs	r1, #72	; 0x48
 8010060:	4860      	ldr	r0, [pc, #384]	; (80101e4 <MX_GPIO_Init+0x344>)
 8010062:	f7f3 fe69 	bl	8003d38 <HAL_GPIO_WritePin>

  /*Configure GPIO pins : PE3 PE0 */
  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_0;
 8010066:	2309      	movs	r3, #9
 8010068:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 801006a:	2301      	movs	r3, #1
 801006c:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 801006e:	2300      	movs	r3, #0
 8010070:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8010072:	2300      	movs	r3, #0
 8010074:	63bb      	str	r3, [r7, #56]	; 0x38
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8010076:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801007a:	4619      	mov	r1, r3
 801007c:	4851      	ldr	r0, [pc, #324]	; (80101c4 <MX_GPIO_Init+0x324>)
 801007e:	f7f3 fc93 	bl	80039a8 <HAL_GPIO_Init>

  /*Configure GPIO pins : PI9 PI12 PI13 PI14
                           PI15 PI4 PI7 */
  GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14
 8010082:	f24f 2390 	movw	r3, #62096	; 0xf290
 8010086:	62fb      	str	r3, [r7, #44]	; 0x2c
                          |GPIO_PIN_15|GPIO_PIN_4|GPIO_PIN_7;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8010088:	2301      	movs	r3, #1
 801008a:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 801008c:	2300      	movs	r3, #0
 801008e:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8010090:	2300      	movs	r3, #0
 8010092:	63bb      	str	r3, [r7, #56]	; 0x38
  HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 8010094:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8010098:	4619      	mov	r1, r3
 801009a:	484b      	ldr	r0, [pc, #300]	; (80101c8 <MX_GPIO_Init+0x328>)
 801009c:	f7f3 fc84 	bl	80039a8 <HAL_GPIO_Init>

  /*Configure GPIO pins : PF2 PF15 */
  GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_15;
 80100a0:	f248 0304 	movw	r3, #32772	; 0x8004
 80100a4:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80100a6:	2301      	movs	r3, #1
 80100a8:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80100aa:	2300      	movs	r3, #0
 80100ac:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80100ae:	2300      	movs	r3, #0
 80100b0:	63bb      	str	r3, [r7, #56]	; 0x38
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 80100b2:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80100b6:	4619      	mov	r1, r3
 80100b8:	4844      	ldr	r0, [pc, #272]	; (80101cc <MX_GPIO_Init+0x32c>)
 80100ba:	f7f3 fc75 	bl	80039a8 <HAL_GPIO_Init>

  /*Configure GPIO pin : PF7 */
  GPIO_InitStruct.Pin = GPIO_PIN_7;
 80100be:	2380      	movs	r3, #128	; 0x80
 80100c0:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80100c2:	2302      	movs	r3, #2
 80100c4:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80100c6:	2300      	movs	r3, #0
 80100c8:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80100ca:	2300      	movs	r3, #0
 80100cc:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
 80100ce:	2309      	movs	r3, #9
 80100d0:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 80100d2:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80100d6:	4619      	mov	r1, r3
 80100d8:	483c      	ldr	r0, [pc, #240]	; (80101cc <MX_GPIO_Init+0x32c>)
 80100da:	f7f3 fc65 	bl	80039a8 <HAL_GPIO_Init>

  /*Configure GPIO pin : GPIO_IN0_Pin */
  GPIO_InitStruct.Pin = GPIO_IN0_Pin;
 80100de:	2301      	movs	r3, #1
 80100e0:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 80100e2:	f44f 1388 	mov.w	r3, #1114112	; 0x110000
 80100e6:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 80100e8:	2302      	movs	r3, #2
 80100ea:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(GPIO_IN0_GPIO_Port, &GPIO_InitStruct);
 80100ec:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80100f0:	4619      	mov	r1, r3
 80100f2:	4838      	ldr	r0, [pc, #224]	; (80101d4 <MX_GPIO_Init+0x334>)
 80100f4:	f7f3 fc58 	bl	80039a8 <HAL_GPIO_Init>

  /*Configure GPIO pins : PJ1 PJ2 PJ3 PJ4
                           PJ6 PJ7 */
  GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4
 80100f8:	23de      	movs	r3, #222	; 0xde
 80100fa:	62fb      	str	r3, [r7, #44]	; 0x2c
                          |GPIO_PIN_6|GPIO_PIN_7;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 80100fc:	f44f 1388 	mov.w	r3, #1114112	; 0x110000
 8010100:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8010102:	2300      	movs	r3, #0
 8010104:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(GPIOJ, &GPIO_InitStruct);
 8010106:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801010a:	4619      	mov	r1, r3
 801010c:	4831      	ldr	r0, [pc, #196]	; (80101d4 <MX_GPIO_Init+0x334>)
 801010e:	f7f3 fc4b 	bl	80039a8 <HAL_GPIO_Init>

  /*Configure GPIO pins : PG0 PG1 PG2 PG3
                           PG4 PG5 PG15 */
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3
 8010112:	f248 033f 	movw	r3, #32831	; 0x803f
 8010116:	62fb      	str	r3, [r7, #44]	; 0x2c
                          |GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_15;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8010118:	2301      	movs	r3, #1
 801011a:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 801011c:	2300      	movs	r3, #0
 801011e:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8010120:	2300      	movs	r3, #0
 8010122:	63bb      	str	r3, [r7, #56]	; 0x38
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8010124:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8010128:	4619      	mov	r1, r3
 801012a:	4829      	ldr	r0, [pc, #164]	; (80101d0 <MX_GPIO_Init+0x330>)
 801012c:	f7f3 fc3c 	bl	80039a8 <HAL_GPIO_Init>

  /*Configure GPIO pins : PE11 PE12 PE13 PE14
                           PE15 */
  GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14
 8010130:	f44f 4378 	mov.w	r3, #63488	; 0xf800
 8010134:	62fb      	str	r3, [r7, #44]	; 0x2c
                          |GPIO_PIN_15;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8010136:	f44f 1388 	mov.w	r3, #1114112	; 0x110000
 801013a:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 801013c:	2300      	movs	r3, #0
 801013e:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8010140:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8010144:	4619      	mov	r1, r3
 8010146:	481f      	ldr	r0, [pc, #124]	; (80101c4 <MX_GPIO_Init+0x324>)
 8010148:	f7f3 fc2e 	bl	80039a8 <HAL_GPIO_Init>

  /*Configure GPIO pins : PJ5 PJ12 PJ13 PJ15 */
  GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_15;
 801014c:	f24b 0320 	movw	r3, #45088	; 0xb020
 8010150:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8010152:	2301      	movs	r3, #1
 8010154:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8010156:	2300      	movs	r3, #0
 8010158:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 801015a:	2300      	movs	r3, #0
 801015c:	63bb      	str	r3, [r7, #56]	; 0x38
  HAL_GPIO_Init(GPIOJ, &GPIO_InitStruct);
 801015e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8010162:	4619      	mov	r1, r3
 8010164:	481b      	ldr	r0, [pc, #108]	; (80101d4 <MX_GPIO_Init+0x334>)
 8010166:	f7f3 fc1f 	bl	80039a8 <HAL_GPIO_Init>

  /*Configure GPIO pin : PH12 */
  GPIO_InitStruct.Pin = GPIO_PIN_12;
 801016a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 801016e:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8010170:	2301      	movs	r3, #1
 8010172:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8010174:	2300      	movs	r3, #0
 8010176:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8010178:	2300      	movs	r3, #0
 801017a:	63bb      	str	r3, [r7, #56]	; 0x38
  HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 801017c:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8010180:	4619      	mov	r1, r3
 8010182:	4815      	ldr	r0, [pc, #84]	; (80101d8 <MX_GPIO_Init+0x338>)
 8010184:	f7f3 fc10 	bl	80039a8 <HAL_GPIO_Init>

  /*Configure GPIO pin : PB13 */
  GPIO_InitStruct.Pin = GPIO_PIN_13;
 8010188:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 801018c:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 801018e:	2301      	movs	r3, #1
 8010190:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8010192:	2300      	movs	r3, #0
 8010194:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8010196:	2300      	movs	r3, #0
 8010198:	63bb      	str	r3, [r7, #56]	; 0x38
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801019a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801019e:	4619      	mov	r1, r3
 80101a0:	480e      	ldr	r0, [pc, #56]	; (80101dc <MX_GPIO_Init+0x33c>)
 80101a2:	f7f3 fc01 	bl	80039a8 <HAL_GPIO_Init>

  /*Configure GPIO pin : GPIO_IN10_Pin */
  GPIO_InitStruct.Pin = GPIO_IN10_Pin;
 80101a6:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80101aa:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 80101ac:	f44f 1388 	mov.w	r3, #1114112	; 0x110000
 80101b0:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80101b2:	2300      	movs	r3, #0
 80101b4:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(GPIO_IN10_GPIO_Port, &GPIO_InitStruct);
 80101b6:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80101ba:	4619      	mov	r1, r3
 80101bc:	e014      	b.n	80101e8 <MX_GPIO_Init+0x348>
 80101be:	bf00      	nop
 80101c0:	58024400 	.word	0x58024400
 80101c4:	58021000 	.word	0x58021000
 80101c8:	58022000 	.word	0x58022000
 80101cc:	58021400 	.word	0x58021400
 80101d0:	58021800 	.word	0x58021800
 80101d4:	58022400 	.word	0x58022400
 80101d8:	58021c00 	.word	0x58021c00
 80101dc:	58020400 	.word	0x58020400
 80101e0:	58022800 	.word	0x58022800
 80101e4:	58020c00 	.word	0x58020c00
 80101e8:	4839      	ldr	r0, [pc, #228]	; (80102d0 <MX_GPIO_Init+0x430>)
 80101ea:	f7f3 fbdd 	bl	80039a8 <HAL_GPIO_Init>

  /*Configure GPIO pins : PK2 PK3 PK4 PK5
                           PK6 PK7 */
  GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5
 80101ee:	23fc      	movs	r3, #252	; 0xfc
 80101f0:	62fb      	str	r3, [r7, #44]	; 0x2c
                          |GPIO_PIN_6|GPIO_PIN_7;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80101f2:	2301      	movs	r3, #1
 80101f4:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80101f6:	2300      	movs	r3, #0
 80101f8:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80101fa:	2300      	movs	r3, #0
 80101fc:	63bb      	str	r3, [r7, #56]	; 0x38
  HAL_GPIO_Init(GPIOK, &GPIO_InitStruct);
 80101fe:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8010202:	4619      	mov	r1, r3
 8010204:	4833      	ldr	r0, [pc, #204]	; (80102d4 <MX_GPIO_Init+0x434>)
 8010206:	f7f3 fbcf 	bl	80039a8 <HAL_GPIO_Init>

  /*Configure GPIO pin : PG8 */
  GPIO_InitStruct.Pin = GPIO_PIN_8;
 801020a:	f44f 7380 	mov.w	r3, #256	; 0x100
 801020e:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8010210:	f44f 1388 	mov.w	r3, #1114112	; 0x110000
 8010214:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8010216:	2300      	movs	r3, #0
 8010218:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 801021a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801021e:	4619      	mov	r1, r3
 8010220:	482d      	ldr	r0, [pc, #180]	; (80102d8 <MX_GPIO_Init+0x438>)
 8010222:	f7f3 fbc1 	bl	80039a8 <HAL_GPIO_Init>

  /*Configure GPIO pin : PA8 */
  GPIO_InitStruct.Pin = GPIO_PIN_8;
 8010226:	f44f 7380 	mov.w	r3, #256	; 0x100
 801022a:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801022c:	2302      	movs	r3, #2
 801022e:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8010230:	2300      	movs	r3, #0
 8010232:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8010234:	2300      	movs	r3, #0
 8010236:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
 8010238:	2300      	movs	r3, #0
 801023a:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 801023c:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8010240:	4619      	mov	r1, r3
 8010242:	4826      	ldr	r0, [pc, #152]	; (80102dc <MX_GPIO_Init+0x43c>)
 8010244:	f7f3 fbb0 	bl	80039a8 <HAL_GPIO_Init>

  /*Configure GPIO pin : PH14 */
  GPIO_InitStruct.Pin = GPIO_PIN_14;
 8010248:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 801024c:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801024e:	2302      	movs	r3, #2
 8010250:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8010252:	2300      	movs	r3, #0
 8010254:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8010256:	2302      	movs	r3, #2
 8010258:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF9_FDCAN1;
 801025a:	2309      	movs	r3, #9
 801025c:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 801025e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8010262:	4619      	mov	r1, r3
 8010264:	481e      	ldr	r0, [pc, #120]	; (80102e0 <MX_GPIO_Init+0x440>)
 8010266:	f7f3 fb9f 	bl	80039a8 <HAL_GPIO_Init>

  /*Configure GPIO pins : PD3 PD6 */
  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_6;
 801026a:	2348      	movs	r3, #72	; 0x48
 801026c:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 801026e:	2301      	movs	r3, #1
 8010270:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8010272:	2300      	movs	r3, #0
 8010274:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8010276:	2300      	movs	r3, #0
 8010278:	63bb      	str	r3, [r7, #56]	; 0x38
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 801027a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801027e:	4619      	mov	r1, r3
 8010280:	4813      	ldr	r0, [pc, #76]	; (80102d0 <MX_GPIO_Init+0x430>)
 8010282:	f7f3 fb91 	bl	80039a8 <HAL_GPIO_Init>

  /*Configure GPIO pin : PB6 */
  GPIO_InitStruct.Pin = GPIO_PIN_6;
 8010286:	2340      	movs	r3, #64	; 0x40
 8010288:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801028a:	2302      	movs	r3, #2
 801028c:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 801028e:	2300      	movs	r3, #0
 8010290:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8010292:	2300      	movs	r3, #0
 8010294:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF9_FDCAN2;
 8010296:	2309      	movs	r3, #9
 8010298:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801029a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801029e:	4619      	mov	r1, r3
 80102a0:	4810      	ldr	r0, [pc, #64]	; (80102e4 <MX_GPIO_Init+0x444>)
 80102a2:	f7f3 fb81 	bl	80039a8 <HAL_GPIO_Init>

  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(EXTI0_IRQn, 5, 0);
 80102a6:	2200      	movs	r2, #0
 80102a8:	2105      	movs	r1, #5
 80102aa:	2006      	movs	r0, #6
 80102ac:	f7f0 fb1c 	bl	80008e8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI0_IRQn);
 80102b0:	2006      	movs	r0, #6
 80102b2:	f7f0 fb33 	bl	800091c <HAL_NVIC_EnableIRQ>

  HAL_NVIC_SetPriority(EXTI15_10_IRQn, 5, 0);
 80102b6:	2200      	movs	r2, #0
 80102b8:	2105      	movs	r1, #5
 80102ba:	2028      	movs	r0, #40	; 0x28
 80102bc:	f7f0 fb14 	bl	80008e8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
 80102c0:	2028      	movs	r0, #40	; 0x28
 80102c2:	f7f0 fb2b 	bl	800091c <HAL_NVIC_EnableIRQ>

}
 80102c6:	bf00      	nop
 80102c8:	3740      	adds	r7, #64	; 0x40
 80102ca:	46bd      	mov	sp, r7
 80102cc:	bd80      	pop	{r7, pc}
 80102ce:	bf00      	nop
 80102d0:	58020c00 	.word	0x58020c00
 80102d4:	58022800 	.word	0x58022800
 80102d8:	58021800 	.word	0x58021800
 80102dc:	58020000 	.word	0x58020000
 80102e0:	58021c00 	.word	0x58021c00
 80102e4:	58020400 	.word	0x58020400

080102e8 <accResetCallback>:

/* USER CODE BEGIN 4 */
static void accResetCallback(){
 80102e8:	b480      	push	{r7}
 80102ea:	af00      	add	r7, sp, #0
	brakeStatus = 1;
 80102ec:	4b03      	ldr	r3, [pc, #12]	; (80102fc <accResetCallback+0x14>)
 80102ee:	2201      	movs	r2, #1
 80102f0:	701a      	strb	r2, [r3, #0]
}
 80102f2:	bf00      	nop
 80102f4:	46bd      	mov	sp, r7
 80102f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80102fa:	4770      	bx	lr
 80102fc:	2406236e 	.word	0x2406236e

08010300 <vfmUpCallback>:
static void vfmUpCallback(){
 8010300:	b580      	push	{r7, lr}
 8010302:	af00      	add	r7, sp, #0
	static long lastVfmChange = 0;
	if(xTaskGetTickCount() > lastVfmChange + 500){
 8010304:	f7fb fb0a 	bl	800b91c <xTaskGetTickCount>
 8010308:	4602      	mov	r2, r0
 801030a:	4b08      	ldr	r3, [pc, #32]	; (801032c <vfmUpCallback+0x2c>)
 801030c:	681b      	ldr	r3, [r3, #0]
 801030e:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
 8010312:	429a      	cmp	r2, r3
 8010314:	d908      	bls.n	8010328 <vfmUpCallback+0x28>
		lastVfmChange = xTaskGetTickCount();
 8010316:	f7fb fb01 	bl	800b91c <xTaskGetTickCount>
 801031a:	4603      	mov	r3, r0
 801031c:	461a      	mov	r2, r3
 801031e:	4b03      	ldr	r3, [pc, #12]	; (801032c <vfmUpCallback+0x2c>)
 8010320:	601a      	str	r2, [r3, #0]
		vfmUpState = 1;
 8010322:	4b03      	ldr	r3, [pc, #12]	; (8010330 <vfmUpCallback+0x30>)
 8010324:	2201      	movs	r2, #1
 8010326:	701a      	strb	r2, [r3, #0]
	}
}
 8010328:	bf00      	nop
 801032a:	bd80      	pop	{r7, pc}
 801032c:	24062374 	.word	0x24062374
 8010330:	24062371 	.word	0x24062371

08010334 <vfmDownCallback>:
static void vfmDownCallback(){
 8010334:	b580      	push	{r7, lr}
 8010336:	af00      	add	r7, sp, #0
	static long lastVfmChange = 0;
	if(xTaskGetTickCount() > lastVfmChange + 500){
 8010338:	f7fb faf0 	bl	800b91c <xTaskGetTickCount>
 801033c:	4602      	mov	r2, r0
 801033e:	4b08      	ldr	r3, [pc, #32]	; (8010360 <vfmDownCallback+0x2c>)
 8010340:	681b      	ldr	r3, [r3, #0]
 8010342:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
 8010346:	429a      	cmp	r2, r3
 8010348:	d908      	bls.n	801035c <vfmDownCallback+0x28>
		lastVfmChange = xTaskGetTickCount();
 801034a:	f7fb fae7 	bl	800b91c <xTaskGetTickCount>
 801034e:	4603      	mov	r3, r0
 8010350:	461a      	mov	r2, r3
 8010352:	4b03      	ldr	r3, [pc, #12]	; (8010360 <vfmDownCallback+0x2c>)
 8010354:	601a      	str	r2, [r3, #0]
		vfmDownState = 1;
 8010356:	4b03      	ldr	r3, [pc, #12]	; (8010364 <vfmDownCallback+0x30>)
 8010358:	2201      	movs	r2, #1
 801035a:	701a      	strb	r2, [r3, #0]
	}
}
 801035c:	bf00      	nop
 801035e:	bd80      	pop	{r7, pc}
 8010360:	24062378 	.word	0x24062378
 8010364:	24062372 	.word	0x24062372

08010368 <motCallback>:
static void motCallback(uint8_t motState){
 8010368:	b480      	push	{r7}
 801036a:	b083      	sub	sp, #12
 801036c:	af00      	add	r7, sp, #0
 801036e:	4603      	mov	r3, r0
 8010370:	71fb      	strb	r3, [r7, #7]
	motorState =  motState;
 8010372:	4a04      	ldr	r2, [pc, #16]	; (8010384 <motCallback+0x1c>)
 8010374:	79fb      	ldrb	r3, [r7, #7]
 8010376:	7013      	strb	r3, [r2, #0]
}
 8010378:	bf00      	nop
 801037a:	370c      	adds	r7, #12
 801037c:	46bd      	mov	sp, r7
 801037e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010382:	4770      	bx	lr
 8010384:	2406236f 	.word	0x2406236f

08010388 <lightsTmr>:

static void lightsTmr(TimerHandle_t xTimer){
 8010388:	b580      	push	{r7, lr}
 801038a:	b082      	sub	sp, #8
 801038c:	af00      	add	r7, sp, #0
 801038e:	6078      	str	r0, [r7, #4]
  static uint8_t current_state = 0;
  static uint8_t buf[4] = {0x03, 0x00, 0x00, 0x00};
  static uint8_t currentCameraState = 0;
	current_state ^=1;
 8010390:	4b49      	ldr	r3, [pc, #292]	; (80104b8 <lightsTmr+0x130>)
 8010392:	781b      	ldrb	r3, [r3, #0]
 8010394:	f083 0301 	eor.w	r3, r3, #1
 8010398:	b2da      	uxtb	r2, r3
 801039a:	4b47      	ldr	r3, [pc, #284]	; (80104b8 <lightsTmr+0x130>)
 801039c:	701a      	strb	r2, [r3, #0]
	if(current_state&RIGHT_ENABLED){
 801039e:	4b46      	ldr	r3, [pc, #280]	; (80104b8 <lightsTmr+0x130>)
 80103a0:	781a      	ldrb	r2, [r3, #0]
 80103a2:	4b46      	ldr	r3, [pc, #280]	; (80104bc <lightsTmr+0x134>)
 80103a4:	781b      	ldrb	r3, [r3, #0]
 80103a6:	4013      	ands	r3, r2
 80103a8:	b2db      	uxtb	r3, r3
 80103aa:	2b00      	cmp	r3, #0
 80103ac:	d00c      	beq.n	80103c8 <lightsTmr+0x40>
		HAL_GPIO_WritePin(GPIOI, GPIO_PIN_13, GPIO_PIN_SET);
 80103ae:	2201      	movs	r2, #1
 80103b0:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80103b4:	4842      	ldr	r0, [pc, #264]	; (80104c0 <lightsTmr+0x138>)
 80103b6:	f7f3 fcbf 	bl	8003d38 <HAL_GPIO_WritePin>
		buf[2] = 0x01;
 80103ba:	4b42      	ldr	r3, [pc, #264]	; (80104c4 <lightsTmr+0x13c>)
 80103bc:	2201      	movs	r2, #1
 80103be:	709a      	strb	r2, [r3, #2]
		disp_setDCMBRightLightState(1);
 80103c0:	2001      	movs	r0, #1
 80103c2:	f7fe fd45 	bl	800ee50 <disp_setDCMBRightLightState>
 80103c6:	e00b      	b.n	80103e0 <lightsTmr+0x58>
	} else {
		HAL_GPIO_WritePin(GPIOI, GPIO_PIN_13, GPIO_PIN_RESET);
 80103c8:	2200      	movs	r2, #0
 80103ca:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80103ce:	483c      	ldr	r0, [pc, #240]	; (80104c0 <lightsTmr+0x138>)
 80103d0:	f7f3 fcb2 	bl	8003d38 <HAL_GPIO_WritePin>
		buf[2] = 0x00;
 80103d4:	4b3b      	ldr	r3, [pc, #236]	; (80104c4 <lightsTmr+0x13c>)
 80103d6:	2200      	movs	r2, #0
 80103d8:	709a      	strb	r2, [r3, #2]
		disp_setDCMBRightLightState(0);
 80103da:	2000      	movs	r0, #0
 80103dc:	f7fe fd38 	bl	800ee50 <disp_setDCMBRightLightState>
	}
	if(current_state&LEFT_ENABLED){
 80103e0:	4b35      	ldr	r3, [pc, #212]	; (80104b8 <lightsTmr+0x130>)
 80103e2:	781a      	ldrb	r2, [r3, #0]
 80103e4:	4b38      	ldr	r3, [pc, #224]	; (80104c8 <lightsTmr+0x140>)
 80103e6:	781b      	ldrb	r3, [r3, #0]
 80103e8:	4013      	ands	r3, r2
 80103ea:	b2db      	uxtb	r3, r3
 80103ec:	2b00      	cmp	r3, #0
 80103ee:	d00c      	beq.n	801040a <lightsTmr+0x82>
		HAL_GPIO_WritePin(GPIOI, GPIO_PIN_12, GPIO_PIN_SET);
 80103f0:	2201      	movs	r2, #1
 80103f2:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 80103f6:	4832      	ldr	r0, [pc, #200]	; (80104c0 <lightsTmr+0x138>)
 80103f8:	f7f3 fc9e 	bl	8003d38 <HAL_GPIO_WritePin>
		buf[1] = 0x01;
 80103fc:	4b31      	ldr	r3, [pc, #196]	; (80104c4 <lightsTmr+0x13c>)
 80103fe:	2201      	movs	r2, #1
 8010400:	705a      	strb	r2, [r3, #1]
		disp_setDCMBLeftLightState(1);
 8010402:	2001      	movs	r0, #1
 8010404:	f7fe fcf2 	bl	800edec <disp_setDCMBLeftLightState>
 8010408:	e00b      	b.n	8010422 <lightsTmr+0x9a>
	} else {
		HAL_GPIO_WritePin(GPIOI, GPIO_PIN_12, GPIO_PIN_RESET);
 801040a:	2200      	movs	r2, #0
 801040c:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8010410:	482b      	ldr	r0, [pc, #172]	; (80104c0 <lightsTmr+0x138>)
 8010412:	f7f3 fc91 	bl	8003d38 <HAL_GPIO_WritePin>
		buf[1] = 0x00;
 8010416:	4b2b      	ldr	r3, [pc, #172]	; (80104c4 <lightsTmr+0x13c>)
 8010418:	2200      	movs	r2, #0
 801041a:	705a      	strb	r2, [r3, #1]
		disp_setDCMBLeftLightState(0);
 801041c:	2000      	movs	r0, #0
 801041e:	f7fe fce5 	bl	800edec <disp_setDCMBLeftLightState>
	}
	if(currentCameraState != CAMERA_ENABLED){
 8010422:	4b2a      	ldr	r3, [pc, #168]	; (80104cc <lightsTmr+0x144>)
 8010424:	781a      	ldrb	r2, [r3, #0]
 8010426:	4b2a      	ldr	r3, [pc, #168]	; (80104d0 <lightsTmr+0x148>)
 8010428:	781b      	ldrb	r3, [r3, #0]
 801042a:	429a      	cmp	r2, r3
 801042c:	d014      	beq.n	8010458 <lightsTmr+0xd0>
		if(CAMERA_ENABLED){
 801042e:	4b28      	ldr	r3, [pc, #160]	; (80104d0 <lightsTmr+0x148>)
 8010430:	781b      	ldrb	r3, [r3, #0]
 8010432:	2b00      	cmp	r3, #0
 8010434:	d006      	beq.n	8010444 <lightsTmr+0xbc>
			HAL_GPIO_WritePin(GPIOI, GPIO_PIN_14, GPIO_PIN_SET);
 8010436:	2201      	movs	r2, #1
 8010438:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 801043c:	4820      	ldr	r0, [pc, #128]	; (80104c0 <lightsTmr+0x138>)
 801043e:	f7f3 fc7b 	bl	8003d38 <HAL_GPIO_WritePin>
 8010442:	e005      	b.n	8010450 <lightsTmr+0xc8>
		} else {
			HAL_GPIO_WritePin(GPIOI, GPIO_PIN_14, GPIO_PIN_RESET);
 8010444:	2200      	movs	r2, #0
 8010446:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 801044a:	481d      	ldr	r0, [pc, #116]	; (80104c0 <lightsTmr+0x138>)
 801044c:	f7f3 fc74 	bl	8003d38 <HAL_GPIO_WritePin>
		}
		currentCameraState = CAMERA_ENABLED;
 8010450:	4b1f      	ldr	r3, [pc, #124]	; (80104d0 <lightsTmr+0x148>)
 8010452:	781a      	ldrb	r2, [r3, #0]
 8010454:	4b1d      	ldr	r3, [pc, #116]	; (80104cc <lightsTmr+0x144>)
 8010456:	701a      	strb	r2, [r3, #0]
	}
	if((HAL_GPIO_ReadPin(GPIOI, GPIO_PIN_9) == GPIO_PIN_SET)){
 8010458:	f44f 7100 	mov.w	r1, #512	; 0x200
 801045c:	4818      	ldr	r0, [pc, #96]	; (80104c0 <lightsTmr+0x138>)
 801045e:	f7f3 fc53 	bl	8003d08 <HAL_GPIO_ReadPin>
 8010462:	4603      	mov	r3, r0
 8010464:	2b01      	cmp	r3, #1
 8010466:	d10e      	bne.n	8010486 <lightsTmr+0xfe>
		HAL_GPIO_WritePin(GPIOF, GPIO_PIN_2, GPIO_PIN_SET);
 8010468:	2201      	movs	r2, #1
 801046a:	2104      	movs	r1, #4
 801046c:	4819      	ldr	r0, [pc, #100]	; (80104d4 <lightsTmr+0x14c>)
 801046e:	f7f3 fc63 	bl	8003d38 <HAL_GPIO_WritePin>
		buf[3] = 0x01;
 8010472:	4b14      	ldr	r3, [pc, #80]	; (80104c4 <lightsTmr+0x13c>)
 8010474:	2201      	movs	r2, #1
 8010476:	70da      	strb	r2, [r3, #3]
		brakeStatus = 1;
 8010478:	4b17      	ldr	r3, [pc, #92]	; (80104d8 <lightsTmr+0x150>)
 801047a:	2201      	movs	r2, #1
 801047c:	701a      	strb	r2, [r3, #0]
		disp_setDCMBStopLightState(1);
 801047e:	2001      	movs	r0, #1
 8010480:	f7fe fd18 	bl	800eeb4 <disp_setDCMBStopLightState>
 8010484:	e00d      	b.n	80104a2 <lightsTmr+0x11a>
	} else {
		HAL_GPIO_WritePin(GPIOF, GPIO_PIN_2, GPIO_PIN_RESET);
 8010486:	2200      	movs	r2, #0
 8010488:	2104      	movs	r1, #4
 801048a:	4812      	ldr	r0, [pc, #72]	; (80104d4 <lightsTmr+0x14c>)
 801048c:	f7f3 fc54 	bl	8003d38 <HAL_GPIO_WritePin>
		buf[3] = 0x00;
 8010490:	4b0c      	ldr	r3, [pc, #48]	; (80104c4 <lightsTmr+0x13c>)
 8010492:	2200      	movs	r2, #0
 8010494:	70da      	strb	r2, [r3, #3]
		brakeStatus = 0;
 8010496:	4b10      	ldr	r3, [pc, #64]	; (80104d8 <lightsTmr+0x150>)
 8010498:	2200      	movs	r2, #0
 801049a:	701a      	strb	r2, [r3, #0]
		disp_setDCMBStopLightState(0);
 801049c:	2000      	movs	r0, #0
 801049e:	f7fe fd09 	bl	800eeb4 <disp_setDCMBStopLightState>
	}
	B_tcpSend(btcp, buf, 4);
 80104a2:	4b0e      	ldr	r3, [pc, #56]	; (80104dc <lightsTmr+0x154>)
 80104a4:	681b      	ldr	r3, [r3, #0]
 80104a6:	2204      	movs	r2, #4
 80104a8:	4906      	ldr	r1, [pc, #24]	; (80104c4 <lightsTmr+0x13c>)
 80104aa:	4618      	mov	r0, r3
 80104ac:	f010 fec8 	bl	8021240 <B_tcpSend>
}
 80104b0:	bf00      	nop
 80104b2:	3708      	adds	r7, #8
 80104b4:	46bd      	mov	sp, r7
 80104b6:	bd80      	pop	{r7, pc}
 80104b8:	2406237c 	.word	0x2406237c
 80104bc:	24062369 	.word	0x24062369
 80104c0:	58022000 	.word	0x58022000
 80104c4:	240001a0 	.word	0x240001a0
 80104c8:	24062368 	.word	0x24062368
 80104cc:	2406237d 	.word	0x2406237d
 80104d0:	2406236a 	.word	0x2406236a
 80104d4:	58021400 	.word	0x58021400
 80104d8:	2406236e 	.word	0x2406236e
 80104dc:	24062c68 	.word	0x24062c68

080104e0 <mc2StateTmr>:

static void mc2StateTmr(TimerHandle_t xTimer){
 80104e0:	b580      	push	{r7, lr}
 80104e2:	b086      	sub	sp, #24
 80104e4:	af00      	add	r7, sp, #0
 80104e6:	6078      	str	r0, [r7, #4]
	static uint8_t started = 0;
	static char buf[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	static int currentValue = 0;
	int positiveTurn = 0;
 80104e8:	2300      	movs	r3, #0
 80104ea:	613b      	str	r3, [r7, #16]
	int negativeTurn = 0;
 80104ec:	2300      	movs	r3, #0
 80104ee:	60fb      	str	r3, [r7, #12]
	int difference = 0;
 80104f0:	2300      	movs	r3, #0
 80104f2:	617b      	str	r3, [r7, #20]
	static int outputVal = 0;
	static char buf2[64];
	int accValTemp = accValue == 255 ? currentValue : accValue;
 80104f4:	4b7a      	ldr	r3, [pc, #488]	; (80106e0 <mc2StateTmr+0x200>)
 80104f6:	781b      	ldrb	r3, [r3, #0]
 80104f8:	2bff      	cmp	r3, #255	; 0xff
 80104fa:	d002      	beq.n	8010502 <mc2StateTmr+0x22>
 80104fc:	4b78      	ldr	r3, [pc, #480]	; (80106e0 <mc2StateTmr+0x200>)
 80104fe:	781b      	ldrb	r3, [r3, #0]
 8010500:	e001      	b.n	8010506 <mc2StateTmr+0x26>
 8010502:	4b78      	ldr	r3, [pc, #480]	; (80106e4 <mc2StateTmr+0x204>)
 8010504:	681b      	ldr	r3, [r3, #0]
 8010506:	60bb      	str	r3, [r7, #8]
	if(!started){
 8010508:	4b77      	ldr	r3, [pc, #476]	; (80106e8 <mc2StateTmr+0x208>)
 801050a:	781b      	ldrb	r3, [r3, #0]
 801050c:	2b00      	cmp	r3, #0
 801050e:	d109      	bne.n	8010524 <mc2StateTmr+0x44>
		started++;
 8010510:	4b75      	ldr	r3, [pc, #468]	; (80106e8 <mc2StateTmr+0x208>)
 8010512:	781b      	ldrb	r3, [r3, #0]
 8010514:	3301      	adds	r3, #1
 8010516:	b2da      	uxtb	r2, r3
 8010518:	4b73      	ldr	r3, [pc, #460]	; (80106e8 <mc2StateTmr+0x208>)
 801051a:	701a      	strb	r2, [r3, #0]
		currentValue = accValTemp;
 801051c:	4a71      	ldr	r2, [pc, #452]	; (80106e4 <mc2StateTmr+0x204>)
 801051e:	68bb      	ldr	r3, [r7, #8]
 8010520:	6013      	str	r3, [r2, #0]
//		HAL_UART_Transmit_IT(&huart2, buf2, strlen(buf2));
		// TODO other buttons
		disp_setDCMBAccPotPosition(outputVal);
		B_tcpSend(btcp, buf, 8);
	}
}
 8010522:	e0d9      	b.n	80106d8 <mc2StateTmr+0x1f8>
		positiveTurn = (currentValue + 63) % 128;
 8010524:	4b6f      	ldr	r3, [pc, #444]	; (80106e4 <mc2StateTmr+0x204>)
 8010526:	681b      	ldr	r3, [r3, #0]
 8010528:	333f      	adds	r3, #63	; 0x3f
 801052a:	425a      	negs	r2, r3
 801052c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8010530:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 8010534:	bf58      	it	pl
 8010536:	4253      	negpl	r3, r2
 8010538:	613b      	str	r3, [r7, #16]
		negativeTurn = (currentValue - 64) % 128;
 801053a:	4b6a      	ldr	r3, [pc, #424]	; (80106e4 <mc2StateTmr+0x204>)
 801053c:	681b      	ldr	r3, [r3, #0]
 801053e:	3b40      	subs	r3, #64	; 0x40
 8010540:	425a      	negs	r2, r3
 8010542:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8010546:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 801054a:	bf58      	it	pl
 801054c:	4253      	negpl	r3, r2
 801054e:	60fb      	str	r3, [r7, #12]
		if(positiveTurn > currentValue){
 8010550:	4b64      	ldr	r3, [pc, #400]	; (80106e4 <mc2StateTmr+0x204>)
 8010552:	681b      	ldr	r3, [r3, #0]
 8010554:	693a      	ldr	r2, [r7, #16]
 8010556:	429a      	cmp	r2, r3
 8010558:	dd20      	ble.n	801059c <mc2StateTmr+0xbc>
			if(accValTemp <= positiveTurn && accValTemp >= currentValue){
 801055a:	68ba      	ldr	r2, [r7, #8]
 801055c:	693b      	ldr	r3, [r7, #16]
 801055e:	429a      	cmp	r2, r3
 8010560:	dc0a      	bgt.n	8010578 <mc2StateTmr+0x98>
 8010562:	4b60      	ldr	r3, [pc, #384]	; (80106e4 <mc2StateTmr+0x204>)
 8010564:	681b      	ldr	r3, [r3, #0]
 8010566:	68ba      	ldr	r2, [r7, #8]
 8010568:	429a      	cmp	r2, r3
 801056a:	db05      	blt.n	8010578 <mc2StateTmr+0x98>
				difference = accValTemp - currentValue;
 801056c:	4b5d      	ldr	r3, [pc, #372]	; (80106e4 <mc2StateTmr+0x204>)
 801056e:	681b      	ldr	r3, [r3, #0]
 8010570:	68ba      	ldr	r2, [r7, #8]
 8010572:	1ad3      	subs	r3, r2, r3
 8010574:	617b      	str	r3, [r7, #20]
 8010576:	e032      	b.n	80105de <mc2StateTmr+0xfe>
				if(accValTemp < currentValue){
 8010578:	4b5a      	ldr	r3, [pc, #360]	; (80106e4 <mc2StateTmr+0x204>)
 801057a:	681b      	ldr	r3, [r3, #0]
 801057c:	68ba      	ldr	r2, [r7, #8]
 801057e:	429a      	cmp	r2, r3
 8010580:	da05      	bge.n	801058e <mc2StateTmr+0xae>
					difference = accValTemp - currentValue;
 8010582:	4b58      	ldr	r3, [pc, #352]	; (80106e4 <mc2StateTmr+0x204>)
 8010584:	681b      	ldr	r3, [r3, #0]
 8010586:	68ba      	ldr	r2, [r7, #8]
 8010588:	1ad3      	subs	r3, r2, r3
 801058a:	617b      	str	r3, [r7, #20]
 801058c:	e027      	b.n	80105de <mc2StateTmr+0xfe>
					difference = -(128 -(accValTemp - currentValue));
 801058e:	4b55      	ldr	r3, [pc, #340]	; (80106e4 <mc2StateTmr+0x204>)
 8010590:	681b      	ldr	r3, [r3, #0]
 8010592:	68ba      	ldr	r2, [r7, #8]
 8010594:	1ad3      	subs	r3, r2, r3
 8010596:	3b80      	subs	r3, #128	; 0x80
 8010598:	617b      	str	r3, [r7, #20]
 801059a:	e020      	b.n	80105de <mc2StateTmr+0xfe>
			if(accValTemp <= currentValue && accValTemp >= negativeTurn){
 801059c:	4b51      	ldr	r3, [pc, #324]	; (80106e4 <mc2StateTmr+0x204>)
 801059e:	681b      	ldr	r3, [r3, #0]
 80105a0:	68ba      	ldr	r2, [r7, #8]
 80105a2:	429a      	cmp	r2, r3
 80105a4:	dc09      	bgt.n	80105ba <mc2StateTmr+0xda>
 80105a6:	68ba      	ldr	r2, [r7, #8]
 80105a8:	68fb      	ldr	r3, [r7, #12]
 80105aa:	429a      	cmp	r2, r3
 80105ac:	db05      	blt.n	80105ba <mc2StateTmr+0xda>
				difference = -(currentValue - accValTemp);
 80105ae:	4b4d      	ldr	r3, [pc, #308]	; (80106e4 <mc2StateTmr+0x204>)
 80105b0:	681b      	ldr	r3, [r3, #0]
 80105b2:	68ba      	ldr	r2, [r7, #8]
 80105b4:	1ad3      	subs	r3, r2, r3
 80105b6:	617b      	str	r3, [r7, #20]
 80105b8:	e011      	b.n	80105de <mc2StateTmr+0xfe>
				if(currentValue < accValTemp){
 80105ba:	4b4a      	ldr	r3, [pc, #296]	; (80106e4 <mc2StateTmr+0x204>)
 80105bc:	681b      	ldr	r3, [r3, #0]
 80105be:	68ba      	ldr	r2, [r7, #8]
 80105c0:	429a      	cmp	r2, r3
 80105c2:	dd05      	ble.n	80105d0 <mc2StateTmr+0xf0>
					difference = accValTemp - currentValue;
 80105c4:	4b47      	ldr	r3, [pc, #284]	; (80106e4 <mc2StateTmr+0x204>)
 80105c6:	681b      	ldr	r3, [r3, #0]
 80105c8:	68ba      	ldr	r2, [r7, #8]
 80105ca:	1ad3      	subs	r3, r2, r3
 80105cc:	617b      	str	r3, [r7, #20]
 80105ce:	e006      	b.n	80105de <mc2StateTmr+0xfe>
					difference = 128 - (currentValue - accValTemp);
 80105d0:	4b44      	ldr	r3, [pc, #272]	; (80106e4 <mc2StateTmr+0x204>)
 80105d2:	681a      	ldr	r2, [r3, #0]
 80105d4:	68bb      	ldr	r3, [r7, #8]
 80105d6:	1ad3      	subs	r3, r2, r3
 80105d8:	f1c3 0380 	rsb	r3, r3, #128	; 0x80
 80105dc:	617b      	str	r3, [r7, #20]
		difference = difference < 0 ? -difference * difference : difference * difference;
 80105de:	697b      	ldr	r3, [r7, #20]
 80105e0:	2b00      	cmp	r3, #0
 80105e2:	da05      	bge.n	80105f0 <mc2StateTmr+0x110>
 80105e4:	697b      	ldr	r3, [r7, #20]
 80105e6:	425b      	negs	r3, r3
 80105e8:	697a      	ldr	r2, [r7, #20]
 80105ea:	fb02 f303 	mul.w	r3, r2, r3
 80105ee:	e002      	b.n	80105f6 <mc2StateTmr+0x116>
 80105f0:	697b      	ldr	r3, [r7, #20]
 80105f2:	fb03 f303 	mul.w	r3, r3, r3
 80105f6:	617b      	str	r3, [r7, #20]
		outputVal += difference;
 80105f8:	4b3c      	ldr	r3, [pc, #240]	; (80106ec <mc2StateTmr+0x20c>)
 80105fa:	681a      	ldr	r2, [r3, #0]
 80105fc:	697b      	ldr	r3, [r7, #20]
 80105fe:	4413      	add	r3, r2
 8010600:	4a3a      	ldr	r2, [pc, #232]	; (80106ec <mc2StateTmr+0x20c>)
 8010602:	6013      	str	r3, [r2, #0]
		currentValue = accValTemp;
 8010604:	4a37      	ldr	r2, [pc, #220]	; (80106e4 <mc2StateTmr+0x204>)
 8010606:	68bb      	ldr	r3, [r7, #8]
 8010608:	6013      	str	r3, [r2, #0]
		if(outputVal < 0){
 801060a:	4b38      	ldr	r3, [pc, #224]	; (80106ec <mc2StateTmr+0x20c>)
 801060c:	681b      	ldr	r3, [r3, #0]
 801060e:	2b00      	cmp	r3, #0
 8010610:	da03      	bge.n	801061a <mc2StateTmr+0x13a>
			outputVal = 0;
 8010612:	4b36      	ldr	r3, [pc, #216]	; (80106ec <mc2StateTmr+0x20c>)
 8010614:	2200      	movs	r2, #0
 8010616:	601a      	str	r2, [r3, #0]
 8010618:	e006      	b.n	8010628 <mc2StateTmr+0x148>
		} else if (outputVal > 0xff){
 801061a:	4b34      	ldr	r3, [pc, #208]	; (80106ec <mc2StateTmr+0x20c>)
 801061c:	681b      	ldr	r3, [r3, #0]
 801061e:	2bff      	cmp	r3, #255	; 0xff
 8010620:	dd02      	ble.n	8010628 <mc2StateTmr+0x148>
			outputVal = 0xff;
 8010622:	4b32      	ldr	r3, [pc, #200]	; (80106ec <mc2StateTmr+0x20c>)
 8010624:	22ff      	movs	r2, #255	; 0xff
 8010626:	601a      	str	r2, [r3, #0]
		if(brakeStatus){
 8010628:	4b31      	ldr	r3, [pc, #196]	; (80106f0 <mc2StateTmr+0x210>)
 801062a:	781b      	ldrb	r3, [r3, #0]
 801062c:	2b00      	cmp	r3, #0
 801062e:	d002      	beq.n	8010636 <mc2StateTmr+0x156>
			outputVal = 0;
 8010630:	4b2e      	ldr	r3, [pc, #184]	; (80106ec <mc2StateTmr+0x20c>)
 8010632:	2200      	movs	r2, #0
 8010634:	601a      	str	r2, [r3, #0]
		if(!motorState){
 8010636:	4b2f      	ldr	r3, [pc, #188]	; (80106f4 <mc2StateTmr+0x214>)
 8010638:	781b      	ldrb	r3, [r3, #0]
 801063a:	2b00      	cmp	r3, #0
 801063c:	d102      	bne.n	8010644 <mc2StateTmr+0x164>
			outputVal = 0;
 801063e:	4b2b      	ldr	r3, [pc, #172]	; (80106ec <mc2StateTmr+0x20c>)
 8010640:	2200      	movs	r2, #0
 8010642:	601a      	str	r2, [r3, #0]
		buf[1] = motorState << 4;
 8010644:	4b2b      	ldr	r3, [pc, #172]	; (80106f4 <mc2StateTmr+0x214>)
 8010646:	781b      	ldrb	r3, [r3, #0]
 8010648:	011b      	lsls	r3, r3, #4
 801064a:	b2da      	uxtb	r2, r3
 801064c:	4b2a      	ldr	r3, [pc, #168]	; (80106f8 <mc2StateTmr+0x218>)
 801064e:	705a      	strb	r2, [r3, #1]
		buf[1] |= fwdRevState << 3;
 8010650:	4b29      	ldr	r3, [pc, #164]	; (80106f8 <mc2StateTmr+0x218>)
 8010652:	785b      	ldrb	r3, [r3, #1]
 8010654:	b25a      	sxtb	r2, r3
 8010656:	4b29      	ldr	r3, [pc, #164]	; (80106fc <mc2StateTmr+0x21c>)
 8010658:	781b      	ldrb	r3, [r3, #0]
 801065a:	00db      	lsls	r3, r3, #3
 801065c:	b25b      	sxtb	r3, r3
 801065e:	4313      	orrs	r3, r2
 8010660:	b25b      	sxtb	r3, r3
 8010662:	b2da      	uxtb	r2, r3
 8010664:	4b24      	ldr	r3, [pc, #144]	; (80106f8 <mc2StateTmr+0x218>)
 8010666:	705a      	strb	r2, [r3, #1]
		buf[1] |= vfmUpState << 2;
 8010668:	4b23      	ldr	r3, [pc, #140]	; (80106f8 <mc2StateTmr+0x218>)
 801066a:	785b      	ldrb	r3, [r3, #1]
 801066c:	b25a      	sxtb	r2, r3
 801066e:	4b24      	ldr	r3, [pc, #144]	; (8010700 <mc2StateTmr+0x220>)
 8010670:	781b      	ldrb	r3, [r3, #0]
 8010672:	009b      	lsls	r3, r3, #2
 8010674:	b25b      	sxtb	r3, r3
 8010676:	4313      	orrs	r3, r2
 8010678:	b25b      	sxtb	r3, r3
 801067a:	b2da      	uxtb	r2, r3
 801067c:	4b1e      	ldr	r3, [pc, #120]	; (80106f8 <mc2StateTmr+0x218>)
 801067e:	705a      	strb	r2, [r3, #1]
		buf[1] |= vfmDownState << 1;
 8010680:	4b1d      	ldr	r3, [pc, #116]	; (80106f8 <mc2StateTmr+0x218>)
 8010682:	785b      	ldrb	r3, [r3, #1]
 8010684:	b25a      	sxtb	r2, r3
 8010686:	4b1f      	ldr	r3, [pc, #124]	; (8010704 <mc2StateTmr+0x224>)
 8010688:	781b      	ldrb	r3, [r3, #0]
 801068a:	005b      	lsls	r3, r3, #1
 801068c:	b25b      	sxtb	r3, r3
 801068e:	4313      	orrs	r3, r2
 8010690:	b25b      	sxtb	r3, r3
 8010692:	b2da      	uxtb	r2, r3
 8010694:	4b18      	ldr	r3, [pc, #96]	; (80106f8 <mc2StateTmr+0x218>)
 8010696:	705a      	strb	r2, [r3, #1]
		if(vfmUpState == 1){
 8010698:	4b19      	ldr	r3, [pc, #100]	; (8010700 <mc2StateTmr+0x220>)
 801069a:	781b      	ldrb	r3, [r3, #0]
 801069c:	2b01      	cmp	r3, #1
 801069e:	d102      	bne.n	80106a6 <mc2StateTmr+0x1c6>
			vfmUpState = 0;
 80106a0:	4b17      	ldr	r3, [pc, #92]	; (8010700 <mc2StateTmr+0x220>)
 80106a2:	2200      	movs	r2, #0
 80106a4:	701a      	strb	r2, [r3, #0]
		if(vfmDownState == 1){
 80106a6:	4b17      	ldr	r3, [pc, #92]	; (8010704 <mc2StateTmr+0x224>)
 80106a8:	781b      	ldrb	r3, [r3, #0]
 80106aa:	2b01      	cmp	r3, #1
 80106ac:	d102      	bne.n	80106b4 <mc2StateTmr+0x1d4>
			vfmDownState = 0;
 80106ae:	4b15      	ldr	r3, [pc, #84]	; (8010704 <mc2StateTmr+0x224>)
 80106b0:	2200      	movs	r2, #0
 80106b2:	701a      	strb	r2, [r3, #0]
		buf[2] = outputVal;
 80106b4:	4b0d      	ldr	r3, [pc, #52]	; (80106ec <mc2StateTmr+0x20c>)
 80106b6:	681b      	ldr	r3, [r3, #0]
 80106b8:	b2da      	uxtb	r2, r3
 80106ba:	4b0f      	ldr	r3, [pc, #60]	; (80106f8 <mc2StateTmr+0x218>)
 80106bc:	709a      	strb	r2, [r3, #2]
		disp_setDCMBAccPotPosition(outputVal);
 80106be:	4b0b      	ldr	r3, [pc, #44]	; (80106ec <mc2StateTmr+0x20c>)
 80106c0:	681b      	ldr	r3, [r3, #0]
 80106c2:	b2db      	uxtb	r3, r3
 80106c4:	4618      	mov	r0, r3
 80106c6:	f7fe fc7f 	bl	800efc8 <disp_setDCMBAccPotPosition>
		B_tcpSend(btcp, buf, 8);
 80106ca:	4b0f      	ldr	r3, [pc, #60]	; (8010708 <mc2StateTmr+0x228>)
 80106cc:	681b      	ldr	r3, [r3, #0]
 80106ce:	2208      	movs	r2, #8
 80106d0:	4909      	ldr	r1, [pc, #36]	; (80106f8 <mc2StateTmr+0x218>)
 80106d2:	4618      	mov	r0, r3
 80106d4:	f010 fdb4 	bl	8021240 <B_tcpSend>
}
 80106d8:	bf00      	nop
 80106da:	3718      	adds	r7, #24
 80106dc:	46bd      	mov	sp, r7
 80106de:	bd80      	pop	{r7, pc}
 80106e0:	2406236d 	.word	0x2406236d
 80106e4:	24062380 	.word	0x24062380
 80106e8:	24062384 	.word	0x24062384
 80106ec:	24062388 	.word	0x24062388
 80106f0:	2406236e 	.word	0x2406236e
 80106f4:	2406236f 	.word	0x2406236f
 80106f8:	2406238c 	.word	0x2406238c
 80106fc:	24062370 	.word	0x24062370
 8010700:	24062371 	.word	0x24062371
 8010704:	24062372 	.word	0x24062372
 8010708:	24062c68 	.word	0x24062c68

0801070c <ignition_check>:

void ignition_check(uint8_t data){
 801070c:	b590      	push	{r4, r7, lr}
 801070e:	b085      	sub	sp, #20
 8010710:	af00      	add	r7, sp, #0
 8010712:	4603      	mov	r3, r0
 8010714:	71fb      	strb	r3, [r7, #7]
	static long ignition_press_time =  0;
	//static uint8_t ignition_state_inner = 0;
	static uint8_t button_pressed = 0;

	if(!(data&IGNITION)){
 8010716:	79fb      	ldrb	r3, [r7, #7]
 8010718:	f003 0308 	and.w	r3, r3, #8
 801071c:	2b00      	cmp	r3, #0
 801071e:	d14b      	bne.n	80107b8 <ignition_check+0xac>
		if(ignition_press_time == 0){
 8010720:	4b2a      	ldr	r3, [pc, #168]	; (80107cc <ignition_check+0xc0>)
 8010722:	681b      	ldr	r3, [r3, #0]
 8010724:	2b00      	cmp	r3, #0
 8010726:	d106      	bne.n	8010736 <ignition_check+0x2a>
			ignition_press_time = xTaskGetTickCount();
 8010728:	f7fb f8f8 	bl	800b91c <xTaskGetTickCount>
 801072c:	4603      	mov	r3, r0
 801072e:	461a      	mov	r2, r3
 8010730:	4b26      	ldr	r3, [pc, #152]	; (80107cc <ignition_check+0xc0>)
 8010732:	601a      	str	r2, [r3, #0]
		}
	} else {
		ignition_press_time = 0;
		button_pressed = 0;
	}
}
 8010734:	e046      	b.n	80107c4 <ignition_check+0xb8>
		} else if ((ignition_press_time + 1000 < xTaskGetTickCount()) && button_pressed == 0){
 8010736:	4b25      	ldr	r3, [pc, #148]	; (80107cc <ignition_check+0xc0>)
 8010738:	681b      	ldr	r3, [r3, #0]
 801073a:	f503 737a 	add.w	r3, r3, #1000	; 0x3e8
 801073e:	461c      	mov	r4, r3
 8010740:	f7fb f8ec 	bl	800b91c <xTaskGetTickCount>
 8010744:	4603      	mov	r3, r0
 8010746:	429c      	cmp	r4, r3
 8010748:	d23c      	bcs.n	80107c4 <ignition_check+0xb8>
 801074a:	4b21      	ldr	r3, [pc, #132]	; (80107d0 <ignition_check+0xc4>)
 801074c:	781b      	ldrb	r3, [r3, #0]
 801074e:	2b00      	cmp	r3, #0
 8010750:	d138      	bne.n	80107c4 <ignition_check+0xb8>
			if(array_state == 1){ // PEKAC Mitigation
 8010752:	4b20      	ldr	r3, [pc, #128]	; (80107d4 <ignition_check+0xc8>)
 8010754:	781b      	ldrb	r3, [r3, #0]
 8010756:	2b01      	cmp	r3, #1
 8010758:	d113      	bne.n	8010782 <ignition_check+0x76>
				array_state = 0;
 801075a:	4b1e      	ldr	r3, [pc, #120]	; (80107d4 <ignition_check+0xc8>)
 801075c:	2200      	movs	r2, #0
 801075e:	701a      	strb	r2, [r3, #0]
				uint8_t array_buf[2] = {0x02, array_state};
 8010760:	2302      	movs	r3, #2
 8010762:	723b      	strb	r3, [r7, #8]
 8010764:	4b1b      	ldr	r3, [pc, #108]	; (80107d4 <ignition_check+0xc8>)
 8010766:	781b      	ldrb	r3, [r3, #0]
 8010768:	727b      	strb	r3, [r7, #9]
				B_tcpSend(btcp, array_buf, 2);
 801076a:	4b1b      	ldr	r3, [pc, #108]	; (80107d8 <ignition_check+0xcc>)
 801076c:	681b      	ldr	r3, [r3, #0]
 801076e:	f107 0108 	add.w	r1, r7, #8
 8010772:	2202      	movs	r2, #2
 8010774:	4618      	mov	r0, r3
 8010776:	f010 fd63 	bl	8021240 <B_tcpSend>
				vTaskDelay(500);
 801077a:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 801077e:	f7fa ff97 	bl	800b6b0 <vTaskDelay>
			ignition_press_time = 0;
 8010782:	4b12      	ldr	r3, [pc, #72]	; (80107cc <ignition_check+0xc0>)
 8010784:	2200      	movs	r2, #0
 8010786:	601a      	str	r2, [r3, #0]
			ignition_state ^= 1;
 8010788:	4b14      	ldr	r3, [pc, #80]	; (80107dc <ignition_check+0xd0>)
 801078a:	781b      	ldrb	r3, [r3, #0]
 801078c:	f083 0301 	eor.w	r3, r3, #1
 8010790:	b2da      	uxtb	r2, r3
 8010792:	4b12      	ldr	r3, [pc, #72]	; (80107dc <ignition_check+0xd0>)
 8010794:	701a      	strb	r2, [r3, #0]
			uint8_t buf[2] = {0x01, ignition_state};
 8010796:	2301      	movs	r3, #1
 8010798:	733b      	strb	r3, [r7, #12]
 801079a:	4b10      	ldr	r3, [pc, #64]	; (80107dc <ignition_check+0xd0>)
 801079c:	781b      	ldrb	r3, [r3, #0]
 801079e:	737b      	strb	r3, [r7, #13]
			B_tcpSend(btcp, buf, 2);
 80107a0:	4b0d      	ldr	r3, [pc, #52]	; (80107d8 <ignition_check+0xcc>)
 80107a2:	681b      	ldr	r3, [r3, #0]
 80107a4:	f107 010c 	add.w	r1, r7, #12
 80107a8:	2202      	movs	r2, #2
 80107aa:	4618      	mov	r0, r3
 80107ac:	f010 fd48 	bl	8021240 <B_tcpSend>
			button_pressed = 1;
 80107b0:	4b07      	ldr	r3, [pc, #28]	; (80107d0 <ignition_check+0xc4>)
 80107b2:	2201      	movs	r2, #1
 80107b4:	701a      	strb	r2, [r3, #0]
}
 80107b6:	e005      	b.n	80107c4 <ignition_check+0xb8>
		ignition_press_time = 0;
 80107b8:	4b04      	ldr	r3, [pc, #16]	; (80107cc <ignition_check+0xc0>)
 80107ba:	2200      	movs	r2, #0
 80107bc:	601a      	str	r2, [r3, #0]
		button_pressed = 0;
 80107be:	4b04      	ldr	r3, [pc, #16]	; (80107d0 <ignition_check+0xc4>)
 80107c0:	2200      	movs	r2, #0
 80107c2:	701a      	strb	r2, [r3, #0]
}
 80107c4:	bf00      	nop
 80107c6:	3714      	adds	r7, #20
 80107c8:	46bd      	mov	sp, r7
 80107ca:	bd90      	pop	{r4, r7, pc}
 80107cc:	24062394 	.word	0x24062394
 80107d0:	24062398 	.word	0x24062398
 80107d4:	2406236c 	.word	0x2406236c
 80107d8:	24062c68 	.word	0x24062c68
 80107dc:	2406236b 	.word	0x2406236b

080107e0 <array_check>:

void array_check(uint8_t data){
 80107e0:	b590      	push	{r4, r7, lr}
 80107e2:	b087      	sub	sp, #28
 80107e4:	af00      	add	r7, sp, #0
 80107e6:	4603      	mov	r3, r0
 80107e8:	71fb      	strb	r3, [r7, #7]
	static uint8_t button_pressed = 0;
	static uint8_t hornON = 0;
	uint8_t buf[10];
	static long fwdRevPressTime = 0;
	static uint8_t fwdRevPressed = 0;
	if(!(data&ARRAY)){
 80107ea:	79fb      	ldrb	r3, [r7, #7]
 80107ec:	f003 0310 	and.w	r3, r3, #16
 80107f0:	2b00      	cmp	r3, #0
 80107f2:	d13e      	bne.n	8010872 <array_check+0x92>
		if(array_press_time == 0){
 80107f4:	4b41      	ldr	r3, [pc, #260]	; (80108fc <array_check+0x11c>)
 80107f6:	681b      	ldr	r3, [r3, #0]
 80107f8:	2b00      	cmp	r3, #0
 80107fa:	d106      	bne.n	801080a <array_check+0x2a>
			array_press_time = xTaskGetTickCount();
 80107fc:	f7fb f88e 	bl	800b91c <xTaskGetTickCount>
 8010800:	4603      	mov	r3, r0
 8010802:	461a      	mov	r2, r3
 8010804:	4b3d      	ldr	r3, [pc, #244]	; (80108fc <array_check+0x11c>)
 8010806:	601a      	str	r2, [r3, #0]
 8010808:	e039      	b.n	801087e <array_check+0x9e>
		} else if ((array_press_time + 1000 < xTaskGetTickCount()) && button_pressed == 0){
 801080a:	4b3c      	ldr	r3, [pc, #240]	; (80108fc <array_check+0x11c>)
 801080c:	681b      	ldr	r3, [r3, #0]
 801080e:	f503 737a 	add.w	r3, r3, #1000	; 0x3e8
 8010812:	461c      	mov	r4, r3
 8010814:	f7fb f882 	bl	800b91c <xTaskGetTickCount>
 8010818:	4603      	mov	r3, r0
 801081a:	429c      	cmp	r4, r3
 801081c:	d22f      	bcs.n	801087e <array_check+0x9e>
 801081e:	4b38      	ldr	r3, [pc, #224]	; (8010900 <array_check+0x120>)
 8010820:	781b      	ldrb	r3, [r3, #0]
 8010822:	2b00      	cmp	r3, #0
 8010824:	d12b      	bne.n	801087e <array_check+0x9e>
			if(ignition_state != (uint8_t) 1){
 8010826:	4b37      	ldr	r3, [pc, #220]	; (8010904 <array_check+0x124>)
 8010828:	781b      	ldrb	r3, [r3, #0]
 801082a:	2b01      	cmp	r3, #1
 801082c:	d006      	beq.n	801083c <array_check+0x5c>
				button_pressed = 0;
 801082e:	4b34      	ldr	r3, [pc, #208]	; (8010900 <array_check+0x120>)
 8010830:	2200      	movs	r2, #0
 8010832:	701a      	strb	r2, [r3, #0]
				array_press_time = 0;
 8010834:	4b31      	ldr	r3, [pc, #196]	; (80108fc <array_check+0x11c>)
 8010836:	2200      	movs	r2, #0
 8010838:	601a      	str	r2, [r3, #0]
 801083a:	e05c      	b.n	80108f6 <array_check+0x116>
				// Change led to show invalid
				return;
			}
			array_press_time = 0;
 801083c:	4b2f      	ldr	r3, [pc, #188]	; (80108fc <array_check+0x11c>)
 801083e:	2200      	movs	r2, #0
 8010840:	601a      	str	r2, [r3, #0]
			array_state ^=1;
 8010842:	4b31      	ldr	r3, [pc, #196]	; (8010908 <array_check+0x128>)
 8010844:	781b      	ldrb	r3, [r3, #0]
 8010846:	f083 0301 	eor.w	r3, r3, #1
 801084a:	b2da      	uxtb	r2, r3
 801084c:	4b2e      	ldr	r3, [pc, #184]	; (8010908 <array_check+0x128>)
 801084e:	701a      	strb	r2, [r3, #0]
			uint8_t buf[2] = {0x02, array_state};
 8010850:	2302      	movs	r3, #2
 8010852:	723b      	strb	r3, [r7, #8]
 8010854:	4b2c      	ldr	r3, [pc, #176]	; (8010908 <array_check+0x128>)
 8010856:	781b      	ldrb	r3, [r3, #0]
 8010858:	727b      	strb	r3, [r7, #9]
			B_tcpSend(btcp, buf, 2);
 801085a:	4b2c      	ldr	r3, [pc, #176]	; (801090c <array_check+0x12c>)
 801085c:	681b      	ldr	r3, [r3, #0]
 801085e:	f107 0108 	add.w	r1, r7, #8
 8010862:	2202      	movs	r2, #2
 8010864:	4618      	mov	r0, r3
 8010866:	f010 fceb 	bl	8021240 <B_tcpSend>
			button_pressed = 1;
 801086a:	4b25      	ldr	r3, [pc, #148]	; (8010900 <array_check+0x120>)
 801086c:	2201      	movs	r2, #1
 801086e:	701a      	strb	r2, [r3, #0]
 8010870:	e005      	b.n	801087e <array_check+0x9e>
		}
	} else {
		array_press_time = 0;
 8010872:	4b22      	ldr	r3, [pc, #136]	; (80108fc <array_check+0x11c>)
 8010874:	2200      	movs	r2, #0
 8010876:	601a      	str	r2, [r3, #0]
		button_pressed = 0;
 8010878:	4b21      	ldr	r3, [pc, #132]	; (8010900 <array_check+0x120>)
 801087a:	2200      	movs	r2, #0
 801087c:	701a      	strb	r2, [r3, #0]
	}
	if(!(data&FWD_REV)){
 801087e:	79fb      	ldrb	r3, [r7, #7]
 8010880:	f003 0302 	and.w	r3, r3, #2
 8010884:	2b00      	cmp	r3, #0
 8010886:	d130      	bne.n	80108ea <array_check+0x10a>
		if(fwdRevPressTime == 0){
 8010888:	4b21      	ldr	r3, [pc, #132]	; (8010910 <array_check+0x130>)
 801088a:	681b      	ldr	r3, [r3, #0]
 801088c:	2b00      	cmp	r3, #0
 801088e:	d106      	bne.n	801089e <array_check+0xbe>
			fwdRevPressTime = xTaskGetTickCount();
 8010890:	f7fb f844 	bl	800b91c <xTaskGetTickCount>
 8010894:	4603      	mov	r3, r0
 8010896:	461a      	mov	r2, r3
 8010898:	4b1d      	ldr	r3, [pc, #116]	; (8010910 <array_check+0x130>)
 801089a:	601a      	str	r2, [r3, #0]
 801089c:	e02b      	b.n	80108f6 <array_check+0x116>
		} else if ((fwdRevPressTime + 1000 < xTaskGetTickCount()) && fwdRevPressed == 0){
 801089e:	4b1c      	ldr	r3, [pc, #112]	; (8010910 <array_check+0x130>)
 80108a0:	681b      	ldr	r3, [r3, #0]
 80108a2:	f503 737a 	add.w	r3, r3, #1000	; 0x3e8
 80108a6:	461c      	mov	r4, r3
 80108a8:	f7fb f838 	bl	800b91c <xTaskGetTickCount>
 80108ac:	4603      	mov	r3, r0
 80108ae:	429c      	cmp	r4, r3
 80108b0:	d221      	bcs.n	80108f6 <array_check+0x116>
 80108b2:	4b18      	ldr	r3, [pc, #96]	; (8010914 <array_check+0x134>)
 80108b4:	781b      	ldrb	r3, [r3, #0]
 80108b6:	2b00      	cmp	r3, #0
 80108b8:	d11d      	bne.n	80108f6 <array_check+0x116>
			fwdRevPressTime = 0;
 80108ba:	4b15      	ldr	r3, [pc, #84]	; (8010910 <array_check+0x130>)
 80108bc:	2200      	movs	r2, #0
 80108be:	601a      	str	r2, [r3, #0]
			fwdRevPressed = 0;
 80108c0:	4b14      	ldr	r3, [pc, #80]	; (8010914 <array_check+0x134>)
 80108c2:	2200      	movs	r2, #0
 80108c4:	701a      	strb	r2, [r3, #0]
			fwdRevState ^= 1;
 80108c6:	4b14      	ldr	r3, [pc, #80]	; (8010918 <array_check+0x138>)
 80108c8:	781b      	ldrb	r3, [r3, #0]
 80108ca:	f083 0301 	eor.w	r3, r3, #1
 80108ce:	b2da      	uxtb	r2, r3
 80108d0:	4b11      	ldr	r3, [pc, #68]	; (8010918 <array_check+0x138>)
 80108d2:	701a      	strb	r2, [r3, #0]
			disp_setMCMBFwdRev(!fwdRevState);
 80108d4:	4b10      	ldr	r3, [pc, #64]	; (8010918 <array_check+0x138>)
 80108d6:	781b      	ldrb	r3, [r3, #0]
 80108d8:	2b00      	cmp	r3, #0
 80108da:	bf0c      	ite	eq
 80108dc:	2301      	moveq	r3, #1
 80108de:	2300      	movne	r3, #0
 80108e0:	b2db      	uxtb	r3, r3
 80108e2:	4618      	mov	r0, r3
 80108e4:	f7fe fa40 	bl	800ed68 <disp_setMCMBFwdRev>
 80108e8:	e005      	b.n	80108f6 <array_check+0x116>
		}
	} else {
		fwdRevPressTime = 0;
 80108ea:	4b09      	ldr	r3, [pc, #36]	; (8010910 <array_check+0x130>)
 80108ec:	2200      	movs	r2, #0
 80108ee:	601a      	str	r2, [r3, #0]
		fwdRevPressed = 0;
 80108f0:	4b08      	ldr	r3, [pc, #32]	; (8010914 <array_check+0x134>)
 80108f2:	2200      	movs	r2, #0
 80108f4:	701a      	strb	r2, [r3, #0]
	}

}
 80108f6:	371c      	adds	r7, #28
 80108f8:	46bd      	mov	sp, r7
 80108fa:	bd90      	pop	{r4, r7, pc}
 80108fc:	2406239c 	.word	0x2406239c
 8010900:	240623a0 	.word	0x240623a0
 8010904:	2406236b 	.word	0x2406236b
 8010908:	2406236c 	.word	0x2406236c
 801090c:	24062c68 	.word	0x24062c68
 8010910:	240623a4 	.word	0x240623a4
 8010914:	240623a8 	.word	0x240623a8
 8010918:	24062370 	.word	0x24062370

0801091c <buttonCheck>:

static void buttonCheck(uint8_t state){
 801091c:	b580      	push	{r7, lr}
 801091e:	b084      	sub	sp, #16
 8010920:	af00      	add	r7, sp, #0
 8010922:	4603      	mov	r3, r0
 8010924:	71fb      	strb	r3, [r7, #7]
  ignition_check(state);
 8010926:	79fb      	ldrb	r3, [r7, #7]
 8010928:	4618      	mov	r0, r3
 801092a:	f7ff feef 	bl	801070c <ignition_check>
  array_check(state);
 801092e:	79fb      	ldrb	r3, [r7, #7]
 8010930:	4618      	mov	r0, r3
 8010932:	f7ff ff55 	bl	80107e0 <array_check>
  static uint8_t consistent_count;
  static uint8_t prev_data = 0;
  static uint8_t horn_on = 0;
  uint8_t data = state;
 8010936:	79fb      	ldrb	r3, [r7, #7]
 8010938:	73fb      	strb	r3, [r7, #15]
  if(data != 255){
 801093a:	7bfb      	ldrb	r3, [r7, #15]
 801093c:	2bff      	cmp	r3, #255	; 0xff
 801093e:	d067      	beq.n	8010a10 <buttonCheck+0xf4>
	  if(!(data&FAN) && !horn_on){
 8010940:	7bfb      	ldrb	r3, [r7, #15]
 8010942:	f003 0304 	and.w	r3, r3, #4
 8010946:	2b00      	cmp	r3, #0
 8010948:	d111      	bne.n	801096e <buttonCheck+0x52>
 801094a:	4b3d      	ldr	r3, [pc, #244]	; (8010a40 <buttonCheck+0x124>)
 801094c:	781b      	ldrb	r3, [r3, #0]
 801094e:	2b00      	cmp	r3, #0
 8010950:	d10d      	bne.n	801096e <buttonCheck+0x52>
		  uint8_t buf[2] = {0x04, 0x01};
 8010952:	f44f 7382 	mov.w	r3, #260	; 0x104
 8010956:	81bb      	strh	r3, [r7, #12]
		  B_tcpSend(btcp, buf, 2);
 8010958:	4b3a      	ldr	r3, [pc, #232]	; (8010a44 <buttonCheck+0x128>)
 801095a:	681b      	ldr	r3, [r3, #0]
 801095c:	f107 010c 	add.w	r1, r7, #12
 8010960:	2202      	movs	r2, #2
 8010962:	4618      	mov	r0, r3
 8010964:	f010 fc6c 	bl	8021240 <B_tcpSend>
		  horn_on = 1;
 8010968:	4b35      	ldr	r3, [pc, #212]	; (8010a40 <buttonCheck+0x124>)
 801096a:	2201      	movs	r2, #1
 801096c:	701a      	strb	r2, [r3, #0]
	  }
	  if(prev_data == data){
 801096e:	4b36      	ldr	r3, [pc, #216]	; (8010a48 <buttonCheck+0x12c>)
 8010970:	781b      	ldrb	r3, [r3, #0]
 8010972:	7bfa      	ldrb	r2, [r7, #15]
 8010974:	429a      	cmp	r2, r3
 8010976:	d106      	bne.n	8010986 <buttonCheck+0x6a>
		  consistent_count++;
 8010978:	4b34      	ldr	r3, [pc, #208]	; (8010a4c <buttonCheck+0x130>)
 801097a:	781b      	ldrb	r3, [r3, #0]
 801097c:	3301      	adds	r3, #1
 801097e:	b2da      	uxtb	r2, r3
 8010980:	4b32      	ldr	r3, [pc, #200]	; (8010a4c <buttonCheck+0x130>)
 8010982:	701a      	strb	r2, [r3, #0]
 8010984:	e002      	b.n	801098c <buttonCheck+0x70>
	  } else {
		  consistent_count = 0;
 8010986:	4b31      	ldr	r3, [pc, #196]	; (8010a4c <buttonCheck+0x130>)
 8010988:	2200      	movs	r2, #0
 801098a:	701a      	strb	r2, [r3, #0]
	  }
	  if(consistent_count ==  2){
 801098c:	4b2f      	ldr	r3, [pc, #188]	; (8010a4c <buttonCheck+0x130>)
 801098e:	781b      	ldrb	r3, [r3, #0]
 8010990:	2b02      	cmp	r3, #2
 8010992:	d14e      	bne.n	8010a32 <buttonCheck+0x116>
		  if(!(data&AUX0)){
 8010994:	7bfb      	ldrb	r3, [r7, #15]
 8010996:	f003 0320 	and.w	r3, r3, #32
 801099a:	2b00      	cmp	r3, #0
 801099c:	d106      	bne.n	80109ac <buttonCheck+0x90>
			  LEFT_ENABLED ^=1;
 801099e:	4b2c      	ldr	r3, [pc, #176]	; (8010a50 <buttonCheck+0x134>)
 80109a0:	781b      	ldrb	r3, [r3, #0]
 80109a2:	f083 0301 	eor.w	r3, r3, #1
 80109a6:	b2da      	uxtb	r2, r3
 80109a8:	4b29      	ldr	r3, [pc, #164]	; (8010a50 <buttonCheck+0x134>)
 80109aa:	701a      	strb	r2, [r3, #0]
		  }
		  if(!(data&AUX2)){
 80109ac:	f997 300f 	ldrsb.w	r3, [r7, #15]
 80109b0:	2b00      	cmp	r3, #0
 80109b2:	db06      	blt.n	80109c2 <buttonCheck+0xa6>
			  RIGHT_ENABLED ^=1;
 80109b4:	4b27      	ldr	r3, [pc, #156]	; (8010a54 <buttonCheck+0x138>)
 80109b6:	781b      	ldrb	r3, [r3, #0]
 80109b8:	f083 0301 	eor.w	r3, r3, #1
 80109bc:	b2da      	uxtb	r2, r3
 80109be:	4b25      	ldr	r3, [pc, #148]	; (8010a54 <buttonCheck+0x138>)
 80109c0:	701a      	strb	r2, [r3, #0]
		  }
		  if(!(data&AUX1)){
 80109c2:	7bfb      	ldrb	r3, [r7, #15]
 80109c4:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80109c8:	2b00      	cmp	r3, #0
 80109ca:	d114      	bne.n	80109f6 <buttonCheck+0xda>
			  if(RIGHT_ENABLED && LEFT_ENABLED){
 80109cc:	4b21      	ldr	r3, [pc, #132]	; (8010a54 <buttonCheck+0x138>)
 80109ce:	781b      	ldrb	r3, [r3, #0]
 80109d0:	2b00      	cmp	r3, #0
 80109d2:	d00a      	beq.n	80109ea <buttonCheck+0xce>
 80109d4:	4b1e      	ldr	r3, [pc, #120]	; (8010a50 <buttonCheck+0x134>)
 80109d6:	781b      	ldrb	r3, [r3, #0]
 80109d8:	2b00      	cmp	r3, #0
 80109da:	d006      	beq.n	80109ea <buttonCheck+0xce>
				  RIGHT_ENABLED = 0;
 80109dc:	4b1d      	ldr	r3, [pc, #116]	; (8010a54 <buttonCheck+0x138>)
 80109de:	2200      	movs	r2, #0
 80109e0:	701a      	strb	r2, [r3, #0]
				  LEFT_ENABLED = 0;
 80109e2:	4b1b      	ldr	r3, [pc, #108]	; (8010a50 <buttonCheck+0x134>)
 80109e4:	2200      	movs	r2, #0
 80109e6:	701a      	strb	r2, [r3, #0]
 80109e8:	e005      	b.n	80109f6 <buttonCheck+0xda>
			  } else {
				  RIGHT_ENABLED = 1;
 80109ea:	4b1a      	ldr	r3, [pc, #104]	; (8010a54 <buttonCheck+0x138>)
 80109ec:	2201      	movs	r2, #1
 80109ee:	701a      	strb	r2, [r3, #0]
				  LEFT_ENABLED = 1;
 80109f0:	4b17      	ldr	r3, [pc, #92]	; (8010a50 <buttonCheck+0x134>)
 80109f2:	2201      	movs	r2, #1
 80109f4:	701a      	strb	r2, [r3, #0]
			  }
		  }
		  if(!(data&CAMERA)){
 80109f6:	7bfb      	ldrb	r3, [r7, #15]
 80109f8:	f003 0301 	and.w	r3, r3, #1
 80109fc:	2b00      	cmp	r3, #0
 80109fe:	d118      	bne.n	8010a32 <buttonCheck+0x116>
			  CAMERA_ENABLED ^=1;
 8010a00:	4b15      	ldr	r3, [pc, #84]	; (8010a58 <buttonCheck+0x13c>)
 8010a02:	781b      	ldrb	r3, [r3, #0]
 8010a04:	f083 0301 	eor.w	r3, r3, #1
 8010a08:	b2da      	uxtb	r2, r3
 8010a0a:	4b13      	ldr	r3, [pc, #76]	; (8010a58 <buttonCheck+0x13c>)
 8010a0c:	701a      	strb	r2, [r3, #0]
 8010a0e:	e010      	b.n	8010a32 <buttonCheck+0x116>
		  }
	  }
  } else if (horn_on){
 8010a10:	4b0b      	ldr	r3, [pc, #44]	; (8010a40 <buttonCheck+0x124>)
 8010a12:	781b      	ldrb	r3, [r3, #0]
 8010a14:	2b00      	cmp	r3, #0
 8010a16:	d00c      	beq.n	8010a32 <buttonCheck+0x116>
	  uint8_t bufh2[2] = {0x04, 0x00};
 8010a18:	2304      	movs	r3, #4
 8010a1a:	813b      	strh	r3, [r7, #8]
	  B_tcpSend(btcp, bufh2, 2);
 8010a1c:	4b09      	ldr	r3, [pc, #36]	; (8010a44 <buttonCheck+0x128>)
 8010a1e:	681b      	ldr	r3, [r3, #0]
 8010a20:	f107 0108 	add.w	r1, r7, #8
 8010a24:	2202      	movs	r2, #2
 8010a26:	4618      	mov	r0, r3
 8010a28:	f010 fc0a 	bl	8021240 <B_tcpSend>
	  horn_on = 0;
 8010a2c:	4b04      	ldr	r3, [pc, #16]	; (8010a40 <buttonCheck+0x124>)
 8010a2e:	2200      	movs	r2, #0
 8010a30:	701a      	strb	r2, [r3, #0]
  }
  prev_data = data;
 8010a32:	4a05      	ldr	r2, [pc, #20]	; (8010a48 <buttonCheck+0x12c>)
 8010a34:	7bfb      	ldrb	r3, [r7, #15]
 8010a36:	7013      	strb	r3, [r2, #0]
}
 8010a38:	bf00      	nop
 8010a3a:	3710      	adds	r7, #16
 8010a3c:	46bd      	mov	sp, r7
 8010a3e:	bd80      	pop	{r7, pc}
 8010a40:	240623a9 	.word	0x240623a9
 8010a44:	24062c68 	.word	0x24062c68
 8010a48:	240623aa 	.word	0x240623aa
 8010a4c:	240623ab 	.word	0x240623ab
 8010a50:	24062368 	.word	0x24062368
 8010a54:	24062369 	.word	0x24062369
 8010a58:	2406236a 	.word	0x2406236a

08010a5c <steeringButtonCheck>:

static void steeringButtonCheck(uint8_t *state){
 8010a5c:	b5b0      	push	{r4, r5, r7, lr}
 8010a5e:	b086      	sub	sp, #24
 8010a60:	af02      	add	r7, sp, #8
 8010a62:	6078      	str	r0, [r7, #4]
//
//	} else {
//		motor_press_time = 0;
//		motor_pressed = 0;
//	}
	if(!(state[0]&HORN)){
 8010a64:	687b      	ldr	r3, [r7, #4]
 8010a66:	781b      	ldrb	r3, [r3, #0]
 8010a68:	b25b      	sxtb	r3, r3
 8010a6a:	2b00      	cmp	r3, #0
 8010a6c:	db12      	blt.n	8010a94 <steeringButtonCheck+0x38>
	  if(!horn_on){
 8010a6e:	4b31      	ldr	r3, [pc, #196]	; (8010b34 <steeringButtonCheck+0xd8>)
 8010a70:	781b      	ldrb	r3, [r3, #0]
 8010a72:	2b00      	cmp	r3, #0
 8010a74:	d11f      	bne.n	8010ab6 <steeringButtonCheck+0x5a>
        uint8_t bufh[2] = {0x04, 0x01};
 8010a76:	f44f 7382 	mov.w	r3, #260	; 0x104
 8010a7a:	81bb      	strh	r3, [r7, #12]
	    B_tcpSend(btcp, bufh, 2);
 8010a7c:	4b2e      	ldr	r3, [pc, #184]	; (8010b38 <steeringButtonCheck+0xdc>)
 8010a7e:	681b      	ldr	r3, [r3, #0]
 8010a80:	f107 010c 	add.w	r1, r7, #12
 8010a84:	2202      	movs	r2, #2
 8010a86:	4618      	mov	r0, r3
 8010a88:	f010 fbda 	bl	8021240 <B_tcpSend>
	    horn_on = 1;
 8010a8c:	4b29      	ldr	r3, [pc, #164]	; (8010b34 <steeringButtonCheck+0xd8>)
 8010a8e:	2201      	movs	r2, #1
 8010a90:	701a      	strb	r2, [r3, #0]
 8010a92:	e010      	b.n	8010ab6 <steeringButtonCheck+0x5a>
	  }
	} else if (horn_on){
 8010a94:	4b27      	ldr	r3, [pc, #156]	; (8010b34 <steeringButtonCheck+0xd8>)
 8010a96:	781b      	ldrb	r3, [r3, #0]
 8010a98:	2b00      	cmp	r3, #0
 8010a9a:	d00c      	beq.n	8010ab6 <steeringButtonCheck+0x5a>
      uint8_t bufh2[2] = {0x04, 0x00};
 8010a9c:	2304      	movs	r3, #4
 8010a9e:	813b      	strh	r3, [r7, #8]
	  B_tcpSend(btcp, bufh2, 2);
 8010aa0:	4b25      	ldr	r3, [pc, #148]	; (8010b38 <steeringButtonCheck+0xdc>)
 8010aa2:	681b      	ldr	r3, [r3, #0]
 8010aa4:	f107 0108 	add.w	r1, r7, #8
 8010aa8:	2202      	movs	r2, #2
 8010aaa:	4618      	mov	r0, r3
 8010aac:	f010 fbc8 	bl	8021240 <B_tcpSend>
	  horn_on = 0;
 8010ab0:	4b20      	ldr	r3, [pc, #128]	; (8010b34 <steeringButtonCheck+0xd8>)
 8010ab2:	2200      	movs	r2, #0
 8010ab4:	701a      	strb	r2, [r3, #0]
//		}
//	} else {
//		vfm_down_press_time = 0;
//		vfm_down_pressed = 0;
//	}
	disp_updateNavState(!(state[0]&DPAD_UP), !(state[0]&DPAD_DOWN), !(state[0]&DPAD_RIGHT), !(state[0]&DPAD_LEFT), !(state[1]), state[2]);
 8010ab6:	687b      	ldr	r3, [r7, #4]
 8010ab8:	781b      	ldrb	r3, [r3, #0]
 8010aba:	f003 0304 	and.w	r3, r3, #4
 8010abe:	2b00      	cmp	r3, #0
 8010ac0:	bf0c      	ite	eq
 8010ac2:	2301      	moveq	r3, #1
 8010ac4:	2300      	movne	r3, #0
 8010ac6:	b2db      	uxtb	r3, r3
 8010ac8:	4618      	mov	r0, r3
 8010aca:	687b      	ldr	r3, [r7, #4]
 8010acc:	781b      	ldrb	r3, [r3, #0]
 8010ace:	f003 0301 	and.w	r3, r3, #1
 8010ad2:	2b00      	cmp	r3, #0
 8010ad4:	bf0c      	ite	eq
 8010ad6:	2301      	moveq	r3, #1
 8010ad8:	2300      	movne	r3, #0
 8010ada:	b2db      	uxtb	r3, r3
 8010adc:	4619      	mov	r1, r3
 8010ade:	687b      	ldr	r3, [r7, #4]
 8010ae0:	781b      	ldrb	r3, [r3, #0]
 8010ae2:	f003 0308 	and.w	r3, r3, #8
 8010ae6:	2b00      	cmp	r3, #0
 8010ae8:	bf0c      	ite	eq
 8010aea:	2301      	moveq	r3, #1
 8010aec:	2300      	movne	r3, #0
 8010aee:	b2db      	uxtb	r3, r3
 8010af0:	461c      	mov	r4, r3
 8010af2:	687b      	ldr	r3, [r7, #4]
 8010af4:	781b      	ldrb	r3, [r3, #0]
 8010af6:	f003 0302 	and.w	r3, r3, #2
 8010afa:	2b00      	cmp	r3, #0
 8010afc:	bf0c      	ite	eq
 8010afe:	2301      	moveq	r3, #1
 8010b00:	2300      	movne	r3, #0
 8010b02:	b2db      	uxtb	r3, r3
 8010b04:	461d      	mov	r5, r3
 8010b06:	687b      	ldr	r3, [r7, #4]
 8010b08:	3301      	adds	r3, #1
 8010b0a:	781b      	ldrb	r3, [r3, #0]
 8010b0c:	2b00      	cmp	r3, #0
 8010b0e:	bf0c      	ite	eq
 8010b10:	2301      	moveq	r3, #1
 8010b12:	2300      	movne	r3, #0
 8010b14:	b2db      	uxtb	r3, r3
 8010b16:	461a      	mov	r2, r3
 8010b18:	687b      	ldr	r3, [r7, #4]
 8010b1a:	3302      	adds	r3, #2
 8010b1c:	781b      	ldrb	r3, [r3, #0]
 8010b1e:	b21b      	sxth	r3, r3
 8010b20:	9301      	str	r3, [sp, #4]
 8010b22:	9200      	str	r2, [sp, #0]
 8010b24:	462b      	mov	r3, r5
 8010b26:	4622      	mov	r2, r4
 8010b28:	f7fe fa9e 	bl	800f068 <disp_updateNavState>

}
 8010b2c:	bf00      	nop
 8010b2e:	3710      	adds	r7, #16
 8010b30:	46bd      	mov	sp, r7
 8010b32:	bdb0      	pop	{r4, r5, r7, pc}
 8010b34:	240623ac 	.word	0x240623ac
 8010b38:	24062c68 	.word	0x24062c68

08010b3c <steeringWheelTask>:
static void steeringWheelTask(const void *pv){
 8010b3c:	b580      	push	{r7, lr}
 8010b3e:	b0ce      	sub	sp, #312	; 0x138
 8010b40:	af00      	add	r7, sp, #0
 8010b42:	1d3b      	adds	r3, r7, #4
 8010b44:	6018      	str	r0, [r3, #0]
  B_uartHandle_t *buart = pv;
 8010b46:	1d3b      	adds	r3, r7, #4
 8010b48:	681b      	ldr	r3, [r3, #0]
 8010b4a:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
  B_bufQEntry_t *e;
  uint8_t input_buffer[MAX_PACKET_SIZE +4];
  uint8_t started = 0;
 8010b4e:	2300      	movs	r3, #0
 8010b50:	f887 3137 	strb.w	r3, [r7, #311]	; 0x137
  uint8_t pos = 0;
 8010b54:	2300      	movs	r3, #0
 8010b56:	f887 3136 	strb.w	r3, [r7, #310]	; 0x136
  uint8_t data[3];
  uint8_t type = 0;
 8010b5a:	2300      	movs	r3, #0
 8010b5c:	f887 3135 	strb.w	r3, [r7, #309]	; 0x135
  uint8_t end_pos = 0;
 8010b60:	2300      	movs	r3, #0
 8010b62:	f887 3134 	strb.w	r3, [r7, #308]	; 0x134
  uint8_t data_pos = 0;
 8010b66:	2300      	movs	r3, #0
 8010b68:	f887 3133 	strb.w	r3, [r7, #307]	; 0x133
  uint32_t crc = 0;
 8010b6c:	2300      	movs	r3, #0
 8010b6e:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
  uint32_t crcExpected = 0;
 8010b72:	2300      	movs	r3, #0
 8010b74:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
  uint8_t crcAcc = 0;
 8010b78:	2300      	movs	r3, #0
 8010b7a:	f887 312b 	strb.w	r3, [r7, #299]	; 0x12b
  uint8_t hornON = 0;
 8010b7e:	2300      	movs	r3, #0
 8010b80:	f887 311b 	strb.w	r3, [r7, #283]	; 0x11b
  uint8_t buf[4];
  for(;;){
    e = B_uartRead(swBuart);
 8010b84:	4b7b      	ldr	r3, [pc, #492]	; (8010d74 <steeringWheelTask+0x238>)
 8010b86:	681b      	ldr	r3, [r3, #0]
 8010b88:	4618      	mov	r0, r3
 8010b8a:	f010 fe60 	bl	802184e <B_uartRead>
 8010b8e:	f8c7 0114 	str.w	r0, [r7, #276]	; 0x114
    for(int i = 0; i < e->len; i++){
 8010b92:	2300      	movs	r3, #0
 8010b94:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
 8010b98:	e0de      	b.n	8010d58 <steeringWheelTask+0x21c>
      if(!started){
 8010b9a:	f897 3137 	ldrb.w	r3, [r7, #311]	; 0x137
 8010b9e:	2b00      	cmp	r3, #0
 8010ba0:	d11e      	bne.n	8010be0 <steeringWheelTask+0xa4>
        if(e->buf[i] == BSSR_SERIAL_START){
 8010ba2:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8010ba6:	681a      	ldr	r2, [r3, #0]
 8010ba8:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 8010bac:	4413      	add	r3, r2
 8010bae:	781b      	ldrb	r3, [r3, #0]
 8010bb0:	2ba5      	cmp	r3, #165	; 0xa5
 8010bb2:	f040 80cc 	bne.w	8010d4e <steeringWheelTask+0x212>
          started = 1;
 8010bb6:	2301      	movs	r3, #1
 8010bb8:	f887 3137 	strb.w	r3, [r7, #311]	; 0x137
          input_buffer[pos] = e->buf[i];
 8010bbc:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8010bc0:	681a      	ldr	r2, [r3, #0]
 8010bc2:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 8010bc6:	441a      	add	r2, r3
 8010bc8:	f897 3136 	ldrb.w	r3, [r7, #310]	; 0x136
 8010bcc:	7811      	ldrb	r1, [r2, #0]
 8010bce:	f107 0210 	add.w	r2, r7, #16
 8010bd2:	54d1      	strb	r1, [r2, r3]
          pos++;
 8010bd4:	f897 3136 	ldrb.w	r3, [r7, #310]	; 0x136
 8010bd8:	3301      	adds	r3, #1
 8010bda:	f887 3136 	strb.w	r3, [r7, #310]	; 0x136
 8010bde:	e0b6      	b.n	8010d4e <steeringWheelTask+0x212>
        }
      } else if(pos == 1){
 8010be0:	f897 3136 	ldrb.w	r3, [r7, #310]	; 0x136
 8010be4:	2b01      	cmp	r3, #1
 8010be6:	d129      	bne.n	8010c3c <steeringWheelTask+0x100>
        input_buffer[pos] = e->buf[i];
 8010be8:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8010bec:	681a      	ldr	r2, [r3, #0]
 8010bee:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 8010bf2:	441a      	add	r2, r3
 8010bf4:	f897 3136 	ldrb.w	r3, [r7, #310]	; 0x136
 8010bf8:	7811      	ldrb	r1, [r2, #0]
 8010bfa:	f107 0210 	add.w	r2, r7, #16
 8010bfe:	54d1      	strb	r1, [r2, r3]
        type = e->buf[i];
 8010c00:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8010c04:	681a      	ldr	r2, [r3, #0]
 8010c06:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 8010c0a:	4413      	add	r3, r2
 8010c0c:	781b      	ldrb	r3, [r3, #0]
 8010c0e:	f887 3135 	strb.w	r3, [r7, #309]	; 0x135
        if(type == 0x02){
 8010c12:	f897 3135 	ldrb.w	r3, [r7, #309]	; 0x135
 8010c16:	2b02      	cmp	r3, #2
 8010c18:	d103      	bne.n	8010c22 <steeringWheelTask+0xe6>
          end_pos = 2;
 8010c1a:	2302      	movs	r3, #2
 8010c1c:	f887 3134 	strb.w	r3, [r7, #308]	; 0x134
 8010c20:	e006      	b.n	8010c30 <steeringWheelTask+0xf4>
        } else if (type == 0x03){
 8010c22:	f897 3135 	ldrb.w	r3, [r7, #309]	; 0x135
 8010c26:	2b03      	cmp	r3, #3
 8010c28:	d102      	bne.n	8010c30 <steeringWheelTask+0xf4>
          end_pos = 4;
 8010c2a:	2304      	movs	r3, #4
 8010c2c:	f887 3134 	strb.w	r3, [r7, #308]	; 0x134
        } 
        pos++;
 8010c30:	f897 3136 	ldrb.w	r3, [r7, #310]	; 0x136
 8010c34:	3301      	adds	r3, #1
 8010c36:	f887 3136 	strb.w	r3, [r7, #310]	; 0x136
 8010c3a:	e088      	b.n	8010d4e <steeringWheelTask+0x212>
      } else if(pos > end_pos){
 8010c3c:	f897 2136 	ldrb.w	r2, [r7, #310]	; 0x136
 8010c40:	f897 3134 	ldrb.w	r3, [r7, #308]	; 0x134
 8010c44:	429a      	cmp	r2, r3
 8010c46:	d960      	bls.n	8010d0a <steeringWheelTask+0x1ce>
        crc |= e->buf[i] << (crcAcc*8);
 8010c48:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8010c4c:	681a      	ldr	r2, [r3, #0]
 8010c4e:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 8010c52:	4413      	add	r3, r2
 8010c54:	781b      	ldrb	r3, [r3, #0]
 8010c56:	461a      	mov	r2, r3
 8010c58:	f897 312b 	ldrb.w	r3, [r7, #299]	; 0x12b
 8010c5c:	00db      	lsls	r3, r3, #3
 8010c5e:	fa02 f303 	lsl.w	r3, r2, r3
 8010c62:	461a      	mov	r2, r3
 8010c64:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8010c68:	4313      	orrs	r3, r2
 8010c6a:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
        crcAcc++;
 8010c6e:	f897 312b 	ldrb.w	r3, [r7, #299]	; 0x12b
 8010c72:	3301      	adds	r3, #1
 8010c74:	f887 312b 	strb.w	r3, [r7, #299]	; 0x12b
        if(crcAcc == 4){
 8010c78:	f897 312b 	ldrb.w	r3, [r7, #299]	; 0x12b
 8010c7c:	2b04      	cmp	r3, #4
 8010c7e:	d166      	bne.n	8010d4e <steeringWheelTask+0x212>
          crcExpected = ~HAL_CRC_Calculate(&hcrc, input_buffer, pos);
 8010c80:	f897 2136 	ldrb.w	r2, [r7, #310]	; 0x136
 8010c84:	f107 0310 	add.w	r3, r7, #16
 8010c88:	4619      	mov	r1, r3
 8010c8a:	483b      	ldr	r0, [pc, #236]	; (8010d78 <steeringWheelTask+0x23c>)
 8010c8c:	f7ef feb8 	bl	8000a00 <HAL_CRC_Calculate>
 8010c90:	4603      	mov	r3, r0
 8010c92:	43db      	mvns	r3, r3
 8010c94:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
          if(crc == crcExpected){
 8010c98:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
 8010c9c:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8010ca0:	429a      	cmp	r2, r3
 8010ca2:	d112      	bne.n	8010cca <steeringWheelTask+0x18e>
            if(type == 0x02){
 8010ca4:	f897 3135 	ldrb.w	r3, [r7, #309]	; 0x135
 8010ca8:	2b02      	cmp	r3, #2
 8010caa:	d105      	bne.n	8010cb8 <steeringWheelTask+0x17c>
            	accValue = data[0];
 8010cac:	f107 030c 	add.w	r3, r7, #12
 8010cb0:	781a      	ldrb	r2, [r3, #0]
 8010cb2:	4b32      	ldr	r3, [pc, #200]	; (8010d7c <steeringWheelTask+0x240>)
 8010cb4:	701a      	strb	r2, [r3, #0]
 8010cb6:	e008      	b.n	8010cca <steeringWheelTask+0x18e>
            } else if(type == 0x03) {
 8010cb8:	f897 3135 	ldrb.w	r3, [r7, #309]	; 0x135
 8010cbc:	2b03      	cmp	r3, #3
 8010cbe:	d104      	bne.n	8010cca <steeringWheelTask+0x18e>
            	steeringButtonCheck(data);
 8010cc0:	f107 030c 	add.w	r3, r7, #12
 8010cc4:	4618      	mov	r0, r3
 8010cc6:	f7ff fec9 	bl	8010a5c <steeringButtonCheck>
            }
          }
          crcAcc = crcExpected = crc = data_pos = end_pos = type = started = pos = 0;
 8010cca:	2300      	movs	r3, #0
 8010ccc:	f887 3136 	strb.w	r3, [r7, #310]	; 0x136
 8010cd0:	f897 3136 	ldrb.w	r3, [r7, #310]	; 0x136
 8010cd4:	f887 3137 	strb.w	r3, [r7, #311]	; 0x137
 8010cd8:	f897 3137 	ldrb.w	r3, [r7, #311]	; 0x137
 8010cdc:	f887 3135 	strb.w	r3, [r7, #309]	; 0x135
 8010ce0:	f897 3135 	ldrb.w	r3, [r7, #309]	; 0x135
 8010ce4:	f887 3134 	strb.w	r3, [r7, #308]	; 0x134
 8010ce8:	f897 3134 	ldrb.w	r3, [r7, #308]	; 0x134
 8010cec:	f887 3133 	strb.w	r3, [r7, #307]	; 0x133
 8010cf0:	f897 3133 	ldrb.w	r3, [r7, #307]	; 0x133
 8010cf4:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
 8010cf8:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8010cfc:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
 8010d00:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8010d04:	f887 312b 	strb.w	r3, [r7, #299]	; 0x12b
 8010d08:	e021      	b.n	8010d4e <steeringWheelTask+0x212>
        }
      } else {
        input_buffer[pos] = e->buf[i];
 8010d0a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8010d0e:	681a      	ldr	r2, [r3, #0]
 8010d10:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 8010d14:	441a      	add	r2, r3
 8010d16:	f897 3136 	ldrb.w	r3, [r7, #310]	; 0x136
 8010d1a:	7811      	ldrb	r1, [r2, #0]
 8010d1c:	f107 0210 	add.w	r2, r7, #16
 8010d20:	54d1      	strb	r1, [r2, r3]
        pos++;
 8010d22:	f897 3136 	ldrb.w	r3, [r7, #310]	; 0x136
 8010d26:	3301      	adds	r3, #1
 8010d28:	f887 3136 	strb.w	r3, [r7, #310]	; 0x136
        data[data_pos] = e->buf[i];
 8010d2c:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8010d30:	681a      	ldr	r2, [r3, #0]
 8010d32:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 8010d36:	441a      	add	r2, r3
 8010d38:	f897 3133 	ldrb.w	r3, [r7, #307]	; 0x133
 8010d3c:	7811      	ldrb	r1, [r2, #0]
 8010d3e:	f107 020c 	add.w	r2, r7, #12
 8010d42:	54d1      	strb	r1, [r2, r3]
        data_pos++;
 8010d44:	f897 3133 	ldrb.w	r3, [r7, #307]	; 0x133
 8010d48:	3301      	adds	r3, #1
 8010d4a:	f887 3133 	strb.w	r3, [r7, #307]	; 0x133
    for(int i = 0; i < e->len; i++){
 8010d4e:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 8010d52:	3301      	adds	r3, #1
 8010d54:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
 8010d58:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8010d5c:	685a      	ldr	r2, [r3, #4]
 8010d5e:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 8010d62:	429a      	cmp	r2, r3
 8010d64:	f63f af19 	bhi.w	8010b9a <steeringWheelTask+0x5e>
      }
    }
    B_uartDoneRead(e);
 8010d68:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 8010d6c:	f010 fd84 	bl	8021878 <B_uartDoneRead>
    e = B_uartRead(swBuart);
 8010d70:	e708      	b.n	8010b84 <steeringWheelTask+0x48>
 8010d72:	bf00      	nop
 8010d74:	24062b3c 	.word	0x24062b3c
 8010d78:	24062800 	.word	0x24062800
 8010d7c:	2406236d 	.word	0x2406236d

08010d80 <sidePanelTask>:
  }
}
static void sidePanelTask(const void *pv){
 8010d80:	b580      	push	{r7, lr}
 8010d82:	b0ca      	sub	sp, #296	; 0x128
 8010d84:	af00      	add	r7, sp, #0
 8010d86:	1d3b      	adds	r3, r7, #4
 8010d88:	6018      	str	r0, [r3, #0]
  B_tcpHandle_t* btcp = pv;
 8010d8a:	1d3b      	adds	r3, r7, #4
 8010d8c:	681b      	ldr	r3, [r3, #0]
 8010d8e:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
  B_bufQEntry_t *e;
  uint8_t input_buffer[MAX_PACKET_SIZE + 4];
  uint8_t started = 0;
 8010d92:	2300      	movs	r3, #0
 8010d94:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
  uint8_t pos = 0;
 8010d98:	2300      	movs	r3, #0
 8010d9a:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
  uint8_t data = 0;
 8010d9e:	2300      	movs	r3, #0
 8010da0:	f887 3125 	strb.w	r3, [r7, #293]	; 0x125
  uint8_t crcAcc = 0;
 8010da4:	2300      	movs	r3, #0
 8010da6:	f887 3124 	strb.w	r3, [r7, #292]	; 0x124
  uint32_t crc;
  uint32_t crcExpected;
  for(;;){
    e = B_uartRead(spbBuart);
 8010daa:	4b5c      	ldr	r3, [pc, #368]	; (8010f1c <sidePanelTask+0x19c>)
 8010dac:	681b      	ldr	r3, [r3, #0]
 8010dae:	4618      	mov	r0, r3
 8010db0:	f010 fd4d 	bl	802184e <B_uartRead>
 8010db4:	f8c7 0114 	str.w	r0, [r7, #276]	; 0x114
    for(int i = 0; i < e->len; i++){
 8010db8:	2300      	movs	r3, #0
 8010dba:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
 8010dbe:	e0a0      	b.n	8010f02 <sidePanelTask+0x182>
      if(!started){
 8010dc0:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8010dc4:	2b00      	cmp	r3, #0
 8010dc6:	d11e      	bne.n	8010e06 <sidePanelTask+0x86>
	    if(e->buf[i] == BSSR_SERIAL_START){
 8010dc8:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8010dcc:	681a      	ldr	r2, [r3, #0]
 8010dce:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8010dd2:	4413      	add	r3, r2
 8010dd4:	781b      	ldrb	r3, [r3, #0]
 8010dd6:	2ba5      	cmp	r3, #165	; 0xa5
 8010dd8:	f040 808e 	bne.w	8010ef8 <sidePanelTask+0x178>
		  started = 1;
 8010ddc:	2301      	movs	r3, #1
 8010dde:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
	   	  input_buffer[pos] = e->buf[i];
 8010de2:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8010de6:	681a      	ldr	r2, [r3, #0]
 8010de8:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8010dec:	441a      	add	r2, r3
 8010dee:	f897 3126 	ldrb.w	r3, [r7, #294]	; 0x126
 8010df2:	7811      	ldrb	r1, [r2, #0]
 8010df4:	f107 020c 	add.w	r2, r7, #12
 8010df8:	54d1      	strb	r1, [r2, r3]
		  pos++;
 8010dfa:	f897 3126 	ldrb.w	r3, [r7, #294]	; 0x126
 8010dfe:	3301      	adds	r3, #1
 8010e00:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
 8010e04:	e078      	b.n	8010ef8 <sidePanelTask+0x178>
		}
	  }else if(pos == 1){
 8010e06:	f897 3126 	ldrb.w	r3, [r7, #294]	; 0x126
 8010e0a:	2b01      	cmp	r3, #1
 8010e0c:	d111      	bne.n	8010e32 <sidePanelTask+0xb2>
		input_buffer[pos] = e->buf[i];
 8010e0e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8010e12:	681a      	ldr	r2, [r3, #0]
 8010e14:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8010e18:	441a      	add	r2, r3
 8010e1a:	f897 3126 	ldrb.w	r3, [r7, #294]	; 0x126
 8010e1e:	7811      	ldrb	r1, [r2, #0]
 8010e20:	f107 020c 	add.w	r2, r7, #12
 8010e24:	54d1      	strb	r1, [r2, r3]
		pos++;
 8010e26:	f897 3126 	ldrb.w	r3, [r7, #294]	; 0x126
 8010e2a:	3301      	adds	r3, #1
 8010e2c:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
 8010e30:	e062      	b.n	8010ef8 <sidePanelTask+0x178>
	  } else if(pos == 2){
 8010e32:	f897 3126 	ldrb.w	r3, [r7, #294]	; 0x126
 8010e36:	2b02      	cmp	r3, #2
 8010e38:	d11a      	bne.n	8010e70 <sidePanelTask+0xf0>
	    data = e->buf[i];
 8010e3a:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8010e3e:	681a      	ldr	r2, [r3, #0]
 8010e40:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8010e44:	4413      	add	r3, r2
 8010e46:	781b      	ldrb	r3, [r3, #0]
 8010e48:	f887 3125 	strb.w	r3, [r7, #293]	; 0x125
		input_buffer[pos] = e->buf[i];
 8010e4c:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8010e50:	681a      	ldr	r2, [r3, #0]
 8010e52:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8010e56:	441a      	add	r2, r3
 8010e58:	f897 3126 	ldrb.w	r3, [r7, #294]	; 0x126
 8010e5c:	7811      	ldrb	r1, [r2, #0]
 8010e5e:	f107 020c 	add.w	r2, r7, #12
 8010e62:	54d1      	strb	r1, [r2, r3]
		pos++;
 8010e64:	f897 3126 	ldrb.w	r3, [r7, #294]	; 0x126
 8010e68:	3301      	adds	r3, #1
 8010e6a:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
 8010e6e:	e043      	b.n	8010ef8 <sidePanelTask+0x178>
	  } else if(pos > 2){
 8010e70:	f897 3126 	ldrb.w	r3, [r7, #294]	; 0x126
 8010e74:	2b02      	cmp	r3, #2
 8010e76:	d93f      	bls.n	8010ef8 <sidePanelTask+0x178>
		crc |= e->buf[i] << (crcAcc*8);
 8010e78:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8010e7c:	681a      	ldr	r2, [r3, #0]
 8010e7e:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8010e82:	4413      	add	r3, r2
 8010e84:	781b      	ldrb	r3, [r3, #0]
 8010e86:	461a      	mov	r2, r3
 8010e88:	f897 3124 	ldrb.w	r3, [r7, #292]	; 0x124
 8010e8c:	00db      	lsls	r3, r3, #3
 8010e8e:	fa02 f303 	lsl.w	r3, r2, r3
 8010e92:	461a      	mov	r2, r3
 8010e94:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 8010e98:	4313      	orrs	r3, r2
 8010e9a:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
		crcAcc++;
 8010e9e:	f897 3124 	ldrb.w	r3, [r7, #292]	; 0x124
 8010ea2:	3301      	adds	r3, #1
 8010ea4:	f887 3124 	strb.w	r3, [r7, #292]	; 0x124
		if(crcAcc == 4){
 8010ea8:	f897 3124 	ldrb.w	r3, [r7, #292]	; 0x124
 8010eac:	2b04      	cmp	r3, #4
 8010eae:	d123      	bne.n	8010ef8 <sidePanelTask+0x178>
	      crcExpected = ~HAL_CRC_Calculate(&hcrc, input_buffer, 3);
 8010eb0:	f107 030c 	add.w	r3, r7, #12
 8010eb4:	2203      	movs	r2, #3
 8010eb6:	4619      	mov	r1, r3
 8010eb8:	4819      	ldr	r0, [pc, #100]	; (8010f20 <sidePanelTask+0x1a0>)
 8010eba:	f7ef fda1 	bl	8000a00 <HAL_CRC_Calculate>
 8010ebe:	4603      	mov	r3, r0
 8010ec0:	43db      	mvns	r3, r3
 8010ec2:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
		  if(crcExpected == crc){
 8010ec6:	f8d7 2110 	ldr.w	r2, [r7, #272]	; 0x110
 8010eca:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 8010ece:	429a      	cmp	r2, r3
 8010ed0:	d104      	bne.n	8010edc <sidePanelTask+0x15c>
		    buttonCheck(data);
 8010ed2:	f897 3125 	ldrb.w	r3, [r7, #293]	; 0x125
 8010ed6:	4618      	mov	r0, r3
 8010ed8:	f7ff fd20 	bl	801091c <buttonCheck>
		  }
		  pos = crcAcc = started = crc = 0;
 8010edc:	2300      	movs	r3, #0
 8010ede:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
 8010ee2:	2300      	movs	r3, #0
 8010ee4:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
 8010ee8:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 8010eec:	f887 3124 	strb.w	r3, [r7, #292]	; 0x124
 8010ef0:	f897 3124 	ldrb.w	r3, [r7, #292]	; 0x124
 8010ef4:	f887 3126 	strb.w	r3, [r7, #294]	; 0x126
    for(int i = 0; i < e->len; i++){
 8010ef8:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8010efc:	3301      	adds	r3, #1
 8010efe:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
 8010f02:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8010f06:	685a      	ldr	r2, [r3, #4]
 8010f08:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8010f0c:	429a      	cmp	r2, r3
 8010f0e:	f63f af57 	bhi.w	8010dc0 <sidePanelTask+0x40>
		}
	  }
    }
    B_uartDoneRead(e);
 8010f12:	f8d7 0114 	ldr.w	r0, [r7, #276]	; 0x114
 8010f16:	f010 fcaf 	bl	8021878 <B_uartDoneRead>
    e = B_uartRead(spbBuart);
 8010f1a:	e746      	b.n	8010daa <sidePanelTask+0x2a>
 8010f1c:	24062f84 	.word	0x24062f84
 8010f20:	24062800 	.word	0x24062800

08010f24 <serialParse>:
  }
}

void serialParse(B_tcpPacket_t *pkt){
 8010f24:	b580      	push	{r7, lr}
 8010f26:	b084      	sub	sp, #16
 8010f28:	af00      	add	r7, sp, #0
 8010f2a:	6078      	str	r0, [r7, #4]
	switch(pkt->sender){
 8010f2c:	687b      	ldr	r3, [r7, #4]
 8010f2e:	781b      	ldrb	r3, [r3, #0]
 8010f30:	2b01      	cmp	r3, #1
 8010f32:	d002      	beq.n	8010f3a <serialParse+0x16>
 8010f34:	2b03      	cmp	r3, #3
 8010f36:	d026      	beq.n	8010f86 <serialParse+0x62>
	case 0x03:
		if(pkt->payload[4] == 0x03){
			disp_setMCMBPulseFreq(pkt->payload[7]*2);
		}
	}
}
 8010f38:	e035      	b.n	8010fa6 <serialParse+0x82>
		  if(pkt->payload[4] == 0x02){
 8010f3a:	687b      	ldr	r3, [r7, #4]
 8010f3c:	685b      	ldr	r3, [r3, #4]
 8010f3e:	3304      	adds	r3, #4
 8010f40:	781b      	ldrb	r3, [r3, #0]
 8010f42:	2b02      	cmp	r3, #2
 8010f44:	d12e      	bne.n	8010fa4 <serialParse+0x80>
			  uint32_t value = pkt->payload[7];
 8010f46:	687b      	ldr	r3, [r7, #4]
 8010f48:	685b      	ldr	r3, [r3, #4]
 8010f4a:	3307      	adds	r3, #7
 8010f4c:	781b      	ldrb	r3, [r3, #0]
 8010f4e:	60fb      	str	r3, [r7, #12]
			  value |= (pkt->payload[7] << 8);
 8010f50:	687b      	ldr	r3, [r7, #4]
 8010f52:	685b      	ldr	r3, [r3, #4]
 8010f54:	3307      	adds	r3, #7
 8010f56:	781b      	ldrb	r3, [r3, #0]
 8010f58:	021b      	lsls	r3, r3, #8
 8010f5a:	461a      	mov	r2, r3
 8010f5c:	68fb      	ldr	r3, [r7, #12]
 8010f5e:	4313      	orrs	r3, r2
 8010f60:	60fb      	str	r3, [r7, #12]
			  if(pkt->payload[5] == 0x01){
 8010f62:	687b      	ldr	r3, [r7, #4]
 8010f64:	685b      	ldr	r3, [r3, #4]
 8010f66:	3305      	adds	r3, #5
 8010f68:	781b      	ldrb	r3, [r3, #0]
 8010f6a:	2b01      	cmp	r3, #1
 8010f6c:	d01a      	beq.n	8010fa4 <serialParse+0x80>
			  } else if (pkt->payload[5] == 0x02){
 8010f6e:	687b      	ldr	r3, [r7, #4]
 8010f70:	685b      	ldr	r3, [r3, #4]
 8010f72:	3305      	adds	r3, #5
 8010f74:	781b      	ldrb	r3, [r3, #0]
 8010f76:	2b02      	cmp	r3, #2
 8010f78:	d014      	beq.n	8010fa4 <serialParse+0x80>
			  } else if (pkt->payload[6] == 0x03){
 8010f7a:	687b      	ldr	r3, [r7, #4]
 8010f7c:	685b      	ldr	r3, [r3, #4]
 8010f7e:	3306      	adds	r3, #6
 8010f80:	781b      	ldrb	r3, [r3, #0]
 8010f82:	2b03      	cmp	r3, #3
		  break;
 8010f84:	e00e      	b.n	8010fa4 <serialParse+0x80>
		if(pkt->payload[4] == 0x03){
 8010f86:	687b      	ldr	r3, [r7, #4]
 8010f88:	685b      	ldr	r3, [r3, #4]
 8010f8a:	3304      	adds	r3, #4
 8010f8c:	781b      	ldrb	r3, [r3, #0]
 8010f8e:	2b03      	cmp	r3, #3
 8010f90:	d109      	bne.n	8010fa6 <serialParse+0x82>
			disp_setMCMBPulseFreq(pkt->payload[7]*2);
 8010f92:	687b      	ldr	r3, [r7, #4]
 8010f94:	685b      	ldr	r3, [r3, #4]
 8010f96:	3307      	adds	r3, #7
 8010f98:	781b      	ldrb	r3, [r3, #0]
 8010f9a:	005b      	lsls	r3, r3, #1
 8010f9c:	4618      	mov	r0, r3
 8010f9e:	f7fd fed3 	bl	800ed48 <disp_setMCMBPulseFreq>
}
 8010fa2:	e000      	b.n	8010fa6 <serialParse+0x82>
		  break;
 8010fa4:	bf00      	nop
}
 8010fa6:	bf00      	nop
 8010fa8:	3710      	adds	r7, #16
 8010faa:	46bd      	mov	sp, r7
 8010fac:	bd80      	pop	{r7, pc}
	...

08010fb0 <HAL_TIM_PeriodElapsedCallback>:
  * a global variable "uwTick" used as application time base.
  * @param  htim : TIM handle
  * @retval None
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
 8010fb0:	b580      	push	{r7, lr}
 8010fb2:	b082      	sub	sp, #8
 8010fb4:	af00      	add	r7, sp, #0
 8010fb6:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN Callback 0 */

  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM6) {
 8010fb8:	687b      	ldr	r3, [r7, #4]
 8010fba:	681b      	ldr	r3, [r3, #0]
 8010fbc:	4a04      	ldr	r2, [pc, #16]	; (8010fd0 <HAL_TIM_PeriodElapsedCallback+0x20>)
 8010fbe:	4293      	cmp	r3, r2
 8010fc0:	d101      	bne.n	8010fc6 <HAL_TIM_PeriodElapsedCallback+0x16>
    HAL_IncTick();
 8010fc2:	f7ef fbad 	bl	8000720 <HAL_IncTick>
  }
  /* USER CODE BEGIN Callback 1 */

  /* USER CODE END Callback 1 */
}
 8010fc6:	bf00      	nop
 8010fc8:	3708      	adds	r7, #8
 8010fca:	46bd      	mov	sp, r7
 8010fcc:	bd80      	pop	{r7, pc}
 8010fce:	bf00      	nop
 8010fd0:	40001000 	.word	0x40001000

08010fd4 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 8010fd4:	b480      	push	{r7}
 8010fd6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */

  /* USER CODE END Error_Handler_Debug */
}
 8010fd8:	bf00      	nop
 8010fda:	46bd      	mov	sp, r7
 8010fdc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010fe0:	4770      	bx	lr
	...

08010fe4 <HAL_MspInit>:
void HAL_TIM_MspPostInit(TIM_HandleTypeDef *htim);
                                        /**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8010fe4:	b580      	push	{r7, lr}
 8010fe6:	b082      	sub	sp, #8
 8010fe8:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8010fea:	4b0c      	ldr	r3, [pc, #48]	; (801101c <HAL_MspInit+0x38>)
 8010fec:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8010ff0:	4a0a      	ldr	r2, [pc, #40]	; (801101c <HAL_MspInit+0x38>)
 8010ff2:	f043 0302 	orr.w	r3, r3, #2
 8010ff6:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
 8010ffa:	4b08      	ldr	r3, [pc, #32]	; (801101c <HAL_MspInit+0x38>)
 8010ffc:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8011000:	f003 0302 	and.w	r3, r3, #2
 8011004:	607b      	str	r3, [r7, #4]
 8011006:	687b      	ldr	r3, [r7, #4]

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 8011008:	2200      	movs	r2, #0
 801100a:	210f      	movs	r1, #15
 801100c:	f06f 0001 	mvn.w	r0, #1
 8011010:	f7ef fc6a 	bl	80008e8 <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8011014:	bf00      	nop
 8011016:	3708      	adds	r7, #8
 8011018:	46bd      	mov	sp, r7
 801101a:	bd80      	pop	{r7, pc}
 801101c:	58024400 	.word	0x58024400

08011020 <HAL_CRC_MspInit>:
* This function configures the hardware resources used in this example
* @param hcrc: CRC handle pointer
* @retval None
*/
void HAL_CRC_MspInit(CRC_HandleTypeDef* hcrc)
{
 8011020:	b480      	push	{r7}
 8011022:	b085      	sub	sp, #20
 8011024:	af00      	add	r7, sp, #0
 8011026:	6078      	str	r0, [r7, #4]
  if(hcrc->Instance==CRC)
 8011028:	687b      	ldr	r3, [r7, #4]
 801102a:	681b      	ldr	r3, [r3, #0]
 801102c:	4a0b      	ldr	r2, [pc, #44]	; (801105c <HAL_CRC_MspInit+0x3c>)
 801102e:	4293      	cmp	r3, r2
 8011030:	d10e      	bne.n	8011050 <HAL_CRC_MspInit+0x30>
  {
  /* USER CODE BEGIN CRC_MspInit 0 */

  /* USER CODE END CRC_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_CRC_CLK_ENABLE();
 8011032:	4b0b      	ldr	r3, [pc, #44]	; (8011060 <HAL_CRC_MspInit+0x40>)
 8011034:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8011038:	4a09      	ldr	r2, [pc, #36]	; (8011060 <HAL_CRC_MspInit+0x40>)
 801103a:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 801103e:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 8011042:	4b07      	ldr	r3, [pc, #28]	; (8011060 <HAL_CRC_MspInit+0x40>)
 8011044:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8011048:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 801104c:	60fb      	str	r3, [r7, #12]
 801104e:	68fb      	ldr	r3, [r7, #12]
  /* USER CODE BEGIN CRC_MspInit 1 */

  /* USER CODE END CRC_MspInit 1 */
  }

}
 8011050:	bf00      	nop
 8011052:	3714      	adds	r7, #20
 8011054:	46bd      	mov	sp, r7
 8011056:	f85d 7b04 	ldr.w	r7, [sp], #4
 801105a:	4770      	bx	lr
 801105c:	58024c00 	.word	0x58024c00
 8011060:	58024400 	.word	0x58024400

08011064 <HAL_RTC_MspInit>:
* This function configures the hardware resources used in this example
* @param hrtc: RTC handle pointer
* @retval None
*/
void HAL_RTC_MspInit(RTC_HandleTypeDef* hrtc)
{
 8011064:	b580      	push	{r7, lr}
 8011066:	b0b2      	sub	sp, #200	; 0xc8
 8011068:	af00      	add	r7, sp, #0
 801106a:	6078      	str	r0, [r7, #4]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 801106c:	f107 030c 	add.w	r3, r7, #12
 8011070:	22bc      	movs	r2, #188	; 0xbc
 8011072:	2100      	movs	r1, #0
 8011074:	4618      	mov	r0, r3
 8011076:	f010 fdfd 	bl	8021c74 <memset>
  if(hrtc->Instance==RTC)
 801107a:	687b      	ldr	r3, [r7, #4]
 801107c:	681b      	ldr	r3, [r3, #0]
 801107e:	4a0f      	ldr	r2, [pc, #60]	; (80110bc <HAL_RTC_MspInit+0x58>)
 8011080:	4293      	cmp	r3, r2
 8011082:	d116      	bne.n	80110b2 <HAL_RTC_MspInit+0x4e>
  /* USER CODE BEGIN RTC_MspInit 0 */

  /* USER CODE END RTC_MspInit 0 */
  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 8011084:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8011088:	60fb      	str	r3, [r7, #12]
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
 801108a:	f44f 7300 	mov.w	r3, #512	; 0x200
 801108e:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8011092:	f107 030c 	add.w	r3, r7, #12
 8011096:	4618      	mov	r0, r3
 8011098:	f7f3 ff2a 	bl	8004ef0 <HAL_RCCEx_PeriphCLKConfig>
 801109c:	4603      	mov	r3, r0
 801109e:	2b00      	cmp	r3, #0
 80110a0:	d001      	beq.n	80110a6 <HAL_RTC_MspInit+0x42>
    {
      Error_Handler();
 80110a2:	f7ff ff97 	bl	8010fd4 <Error_Handler>
    }

    /* Peripheral clock enable */
    __HAL_RCC_RTC_ENABLE();
 80110a6:	4b06      	ldr	r3, [pc, #24]	; (80110c0 <HAL_RTC_MspInit+0x5c>)
 80110a8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80110aa:	4a05      	ldr	r2, [pc, #20]	; (80110c0 <HAL_RTC_MspInit+0x5c>)
 80110ac:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80110b0:	6713      	str	r3, [r2, #112]	; 0x70
  /* USER CODE BEGIN RTC_MspInit 1 */

  /* USER CODE END RTC_MspInit 1 */
  }

}
 80110b2:	bf00      	nop
 80110b4:	37c8      	adds	r7, #200	; 0xc8
 80110b6:	46bd      	mov	sp, r7
 80110b8:	bd80      	pop	{r7, pc}
 80110ba:	bf00      	nop
 80110bc:	58004000 	.word	0x58004000
 80110c0:	58024400 	.word	0x58024400

080110c4 <HAL_SPI_MspInit>:
* This function configures the hardware resources used in this example
* @param hspi: SPI handle pointer
* @retval None
*/
void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 80110c4:	b580      	push	{r7, lr}
 80110c6:	b0c6      	sub	sp, #280	; 0x118
 80110c8:	af00      	add	r7, sp, #0
 80110ca:	1d3b      	adds	r3, r7, #4
 80110cc:	6018      	str	r0, [r3, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80110ce:	f507 7382 	add.w	r3, r7, #260	; 0x104
 80110d2:	2200      	movs	r2, #0
 80110d4:	601a      	str	r2, [r3, #0]
 80110d6:	605a      	str	r2, [r3, #4]
 80110d8:	609a      	str	r2, [r3, #8]
 80110da:	60da      	str	r2, [r3, #12]
 80110dc:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 80110de:	f107 0348 	add.w	r3, r7, #72	; 0x48
 80110e2:	22bc      	movs	r2, #188	; 0xbc
 80110e4:	2100      	movs	r1, #0
 80110e6:	4618      	mov	r0, r3
 80110e8:	f010 fdc4 	bl	8021c74 <memset>
  if(hspi->Instance==SPI1)
 80110ec:	1d3b      	adds	r3, r7, #4
 80110ee:	681b      	ldr	r3, [r3, #0]
 80110f0:	681b      	ldr	r3, [r3, #0]
 80110f2:	4ab7      	ldr	r2, [pc, #732]	; (80113d0 <HAL_SPI_MspInit+0x30c>)
 80110f4:	4293      	cmp	r3, r2
 80110f6:	d168      	bne.n	80111ca <HAL_SPI_MspInit+0x106>
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SPI1;
 80110f8:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80110fc:	64bb      	str	r3, [r7, #72]	; 0x48
    PeriphClkInitStruct.Spi123ClockSelection = RCC_SPI123CLKSOURCE_PLL;
 80110fe:	2300      	movs	r3, #0
 8011100:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8011104:	f107 0348 	add.w	r3, r7, #72	; 0x48
 8011108:	4618      	mov	r0, r3
 801110a:	f7f3 fef1 	bl	8004ef0 <HAL_RCCEx_PeriphCLKConfig>
 801110e:	4603      	mov	r3, r0
 8011110:	2b00      	cmp	r3, #0
 8011112:	d001      	beq.n	8011118 <HAL_SPI_MspInit+0x54>
    {
      Error_Handler();
 8011114:	f7ff ff5e 	bl	8010fd4 <Error_Handler>
    }

    /* Peripheral clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 8011118:	4bae      	ldr	r3, [pc, #696]	; (80113d4 <HAL_SPI_MspInit+0x310>)
 801111a:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 801111e:	4aad      	ldr	r2, [pc, #692]	; (80113d4 <HAL_SPI_MspInit+0x310>)
 8011120:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8011124:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
 8011128:	4baa      	ldr	r3, [pc, #680]	; (80113d4 <HAL_SPI_MspInit+0x310>)
 801112a:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 801112e:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8011132:	647b      	str	r3, [r7, #68]	; 0x44
 8011134:	6c7b      	ldr	r3, [r7, #68]	; 0x44

    __HAL_RCC_GPIOD_CLK_ENABLE();
 8011136:	4ba7      	ldr	r3, [pc, #668]	; (80113d4 <HAL_SPI_MspInit+0x310>)
 8011138:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 801113c:	4aa5      	ldr	r2, [pc, #660]	; (80113d4 <HAL_SPI_MspInit+0x310>)
 801113e:	f043 0308 	orr.w	r3, r3, #8
 8011142:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 8011146:	4ba3      	ldr	r3, [pc, #652]	; (80113d4 <HAL_SPI_MspInit+0x310>)
 8011148:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 801114c:	f003 0308 	and.w	r3, r3, #8
 8011150:	643b      	str	r3, [r7, #64]	; 0x40
 8011152:	6c3b      	ldr	r3, [r7, #64]	; 0x40
    __HAL_RCC_GPIOG_CLK_ENABLE();
 8011154:	4b9f      	ldr	r3, [pc, #636]	; (80113d4 <HAL_SPI_MspInit+0x310>)
 8011156:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 801115a:	4a9e      	ldr	r2, [pc, #632]	; (80113d4 <HAL_SPI_MspInit+0x310>)
 801115c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8011160:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 8011164:	4b9b      	ldr	r3, [pc, #620]	; (80113d4 <HAL_SPI_MspInit+0x310>)
 8011166:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 801116a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801116e:	63fb      	str	r3, [r7, #60]	; 0x3c
 8011170:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
    PD7     ------> SPI1_MOSI
    PG9     ------> SPI1_MISO
    PG10     ------> SPI1_NSS
    PG11     ------> SPI1_SCK
    */
    GPIO_InitStruct.Pin = GPIO_PIN_7;
 8011172:	2380      	movs	r3, #128	; 0x80
 8011174:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8011178:	2302      	movs	r3, #2
 801117a:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 801117e:	2300      	movs	r3, #0
 8011180:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8011184:	2300      	movs	r3, #0
 8011186:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 801118a:	2305      	movs	r3, #5
 801118c:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8011190:	f507 7382 	add.w	r3, r7, #260	; 0x104
 8011194:	4619      	mov	r1, r3
 8011196:	4890      	ldr	r0, [pc, #576]	; (80113d8 <HAL_SPI_MspInit+0x314>)
 8011198:	f7f2 fc06 	bl	80039a8 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11;
 801119c:	f44f 6360 	mov.w	r3, #3584	; 0xe00
 80111a0:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80111a4:	2302      	movs	r3, #2
 80111a6:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80111aa:	2300      	movs	r3, #0
 80111ac:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80111b0:	2300      	movs	r3, #0
 80111b2:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
 80111b6:	2305      	movs	r3, #5
 80111b8:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
    HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 80111bc:	f507 7382 	add.w	r3, r7, #260	; 0x104
 80111c0:	4619      	mov	r1, r3
 80111c2:	4886      	ldr	r0, [pc, #536]	; (80113dc <HAL_SPI_MspInit+0x318>)
 80111c4:	f7f2 fbf0 	bl	80039a8 <HAL_GPIO_Init>
  /* USER CODE BEGIN SPI6_MspInit 1 */

  /* USER CODE END SPI6_MspInit 1 */
  }

}
 80111c8:	e254      	b.n	8011674 <HAL_SPI_MspInit+0x5b0>
  else if(hspi->Instance==SPI2)
 80111ca:	1d3b      	adds	r3, r7, #4
 80111cc:	681b      	ldr	r3, [r3, #0]
 80111ce:	681b      	ldr	r3, [r3, #0]
 80111d0:	4a83      	ldr	r2, [pc, #524]	; (80113e0 <HAL_SPI_MspInit+0x31c>)
 80111d2:	4293      	cmp	r3, r2
 80111d4:	f040 80aa 	bne.w	801132c <HAL_SPI_MspInit+0x268>
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SPI2;
 80111d8:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80111dc:	64bb      	str	r3, [r7, #72]	; 0x48
    PeriphClkInitStruct.Spi123ClockSelection = RCC_SPI123CLKSOURCE_PLL;
 80111de:	2300      	movs	r3, #0
 80111e0:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 80111e4:	f107 0348 	add.w	r3, r7, #72	; 0x48
 80111e8:	4618      	mov	r0, r3
 80111ea:	f7f3 fe81 	bl	8004ef0 <HAL_RCCEx_PeriphCLKConfig>
 80111ee:	4603      	mov	r3, r0
 80111f0:	2b00      	cmp	r3, #0
 80111f2:	d001      	beq.n	80111f8 <HAL_SPI_MspInit+0x134>
      Error_Handler();
 80111f4:	f7ff feee 	bl	8010fd4 <Error_Handler>
    __HAL_RCC_SPI2_CLK_ENABLE();
 80111f8:	4b76      	ldr	r3, [pc, #472]	; (80113d4 <HAL_SPI_MspInit+0x310>)
 80111fa:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 80111fe:	4a75      	ldr	r2, [pc, #468]	; (80113d4 <HAL_SPI_MspInit+0x310>)
 8011200:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8011204:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
 8011208:	4b72      	ldr	r3, [pc, #456]	; (80113d4 <HAL_SPI_MspInit+0x310>)
 801120a:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 801120e:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8011212:	63bb      	str	r3, [r7, #56]	; 0x38
 8011214:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    __HAL_RCC_GPIOI_CLK_ENABLE();
 8011216:	4b6f      	ldr	r3, [pc, #444]	; (80113d4 <HAL_SPI_MspInit+0x310>)
 8011218:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 801121c:	4a6d      	ldr	r2, [pc, #436]	; (80113d4 <HAL_SPI_MspInit+0x310>)
 801121e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8011222:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 8011226:	4b6b      	ldr	r3, [pc, #428]	; (80113d4 <HAL_SPI_MspInit+0x310>)
 8011228:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 801122c:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8011230:	637b      	str	r3, [r7, #52]	; 0x34
 8011232:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3;
 8011234:	230e      	movs	r3, #14
 8011236:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801123a:	2302      	movs	r3, #2
 801123c:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011240:	2300      	movs	r3, #0
 8011242:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8011246:	2300      	movs	r3, #0
 8011248:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 801124c:	2305      	movs	r3, #5
 801124e:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
    HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 8011252:	f507 7382 	add.w	r3, r7, #260	; 0x104
 8011256:	4619      	mov	r1, r3
 8011258:	4862      	ldr	r0, [pc, #392]	; (80113e4 <HAL_SPI_MspInit+0x320>)
 801125a:	f7f2 fba5 	bl	80039a8 <HAL_GPIO_Init>
    hdma_spi2_rx.Instance = DMA1_Stream4;
 801125e:	4b62      	ldr	r3, [pc, #392]	; (80113e8 <HAL_SPI_MspInit+0x324>)
 8011260:	4a62      	ldr	r2, [pc, #392]	; (80113ec <HAL_SPI_MspInit+0x328>)
 8011262:	601a      	str	r2, [r3, #0]
    hdma_spi2_rx.Init.Request = DMA_REQUEST_SPI2_RX;
 8011264:	4b60      	ldr	r3, [pc, #384]	; (80113e8 <HAL_SPI_MspInit+0x324>)
 8011266:	2227      	movs	r2, #39	; 0x27
 8011268:	605a      	str	r2, [r3, #4]
    hdma_spi2_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 801126a:	4b5f      	ldr	r3, [pc, #380]	; (80113e8 <HAL_SPI_MspInit+0x324>)
 801126c:	2200      	movs	r2, #0
 801126e:	609a      	str	r2, [r3, #8]
    hdma_spi2_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 8011270:	4b5d      	ldr	r3, [pc, #372]	; (80113e8 <HAL_SPI_MspInit+0x324>)
 8011272:	2200      	movs	r2, #0
 8011274:	60da      	str	r2, [r3, #12]
    hdma_spi2_rx.Init.MemInc = DMA_MINC_ENABLE;
 8011276:	4b5c      	ldr	r3, [pc, #368]	; (80113e8 <HAL_SPI_MspInit+0x324>)
 8011278:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801127c:	611a      	str	r2, [r3, #16]
    hdma_spi2_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 801127e:	4b5a      	ldr	r3, [pc, #360]	; (80113e8 <HAL_SPI_MspInit+0x324>)
 8011280:	2200      	movs	r2, #0
 8011282:	615a      	str	r2, [r3, #20]
    hdma_spi2_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8011284:	4b58      	ldr	r3, [pc, #352]	; (80113e8 <HAL_SPI_MspInit+0x324>)
 8011286:	2200      	movs	r2, #0
 8011288:	619a      	str	r2, [r3, #24]
    hdma_spi2_rx.Init.Mode = DMA_NORMAL;
 801128a:	4b57      	ldr	r3, [pc, #348]	; (80113e8 <HAL_SPI_MspInit+0x324>)
 801128c:	2200      	movs	r2, #0
 801128e:	61da      	str	r2, [r3, #28]
    hdma_spi2_rx.Init.Priority = DMA_PRIORITY_LOW;
 8011290:	4b55      	ldr	r3, [pc, #340]	; (80113e8 <HAL_SPI_MspInit+0x324>)
 8011292:	2200      	movs	r2, #0
 8011294:	621a      	str	r2, [r3, #32]
    hdma_spi2_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 8011296:	4b54      	ldr	r3, [pc, #336]	; (80113e8 <HAL_SPI_MspInit+0x324>)
 8011298:	2200      	movs	r2, #0
 801129a:	625a      	str	r2, [r3, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_spi2_rx) != HAL_OK)
 801129c:	4852      	ldr	r0, [pc, #328]	; (80113e8 <HAL_SPI_MspInit+0x324>)
 801129e:	f7ef fd49 	bl	8000d34 <HAL_DMA_Init>
 80112a2:	4603      	mov	r3, r0
 80112a4:	2b00      	cmp	r3, #0
 80112a6:	d001      	beq.n	80112ac <HAL_SPI_MspInit+0x1e8>
      Error_Handler();
 80112a8:	f7ff fe94 	bl	8010fd4 <Error_Handler>
    __HAL_LINKDMA(hspi,hdmarx,hdma_spi2_rx);
 80112ac:	1d3b      	adds	r3, r7, #4
 80112ae:	681b      	ldr	r3, [r3, #0]
 80112b0:	4a4d      	ldr	r2, [pc, #308]	; (80113e8 <HAL_SPI_MspInit+0x324>)
 80112b2:	67da      	str	r2, [r3, #124]	; 0x7c
 80112b4:	4a4c      	ldr	r2, [pc, #304]	; (80113e8 <HAL_SPI_MspInit+0x324>)
 80112b6:	1d3b      	adds	r3, r7, #4
 80112b8:	681b      	ldr	r3, [r3, #0]
 80112ba:	6393      	str	r3, [r2, #56]	; 0x38
    hdma_spi2_tx.Instance = DMA1_Stream5;
 80112bc:	4b4c      	ldr	r3, [pc, #304]	; (80113f0 <HAL_SPI_MspInit+0x32c>)
 80112be:	4a4d      	ldr	r2, [pc, #308]	; (80113f4 <HAL_SPI_MspInit+0x330>)
 80112c0:	601a      	str	r2, [r3, #0]
    hdma_spi2_tx.Init.Request = DMA_REQUEST_SPI2_TX;
 80112c2:	4b4b      	ldr	r3, [pc, #300]	; (80113f0 <HAL_SPI_MspInit+0x32c>)
 80112c4:	2228      	movs	r2, #40	; 0x28
 80112c6:	605a      	str	r2, [r3, #4]
    hdma_spi2_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 80112c8:	4b49      	ldr	r3, [pc, #292]	; (80113f0 <HAL_SPI_MspInit+0x32c>)
 80112ca:	2240      	movs	r2, #64	; 0x40
 80112cc:	609a      	str	r2, [r3, #8]
    hdma_spi2_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 80112ce:	4b48      	ldr	r3, [pc, #288]	; (80113f0 <HAL_SPI_MspInit+0x32c>)
 80112d0:	2200      	movs	r2, #0
 80112d2:	60da      	str	r2, [r3, #12]
    hdma_spi2_tx.Init.MemInc = DMA_MINC_ENABLE;
 80112d4:	4b46      	ldr	r3, [pc, #280]	; (80113f0 <HAL_SPI_MspInit+0x32c>)
 80112d6:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80112da:	611a      	str	r2, [r3, #16]
    hdma_spi2_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 80112dc:	4b44      	ldr	r3, [pc, #272]	; (80113f0 <HAL_SPI_MspInit+0x32c>)
 80112de:	2200      	movs	r2, #0
 80112e0:	615a      	str	r2, [r3, #20]
    hdma_spi2_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 80112e2:	4b43      	ldr	r3, [pc, #268]	; (80113f0 <HAL_SPI_MspInit+0x32c>)
 80112e4:	2200      	movs	r2, #0
 80112e6:	619a      	str	r2, [r3, #24]
    hdma_spi2_tx.Init.Mode = DMA_NORMAL;
 80112e8:	4b41      	ldr	r3, [pc, #260]	; (80113f0 <HAL_SPI_MspInit+0x32c>)
 80112ea:	2200      	movs	r2, #0
 80112ec:	61da      	str	r2, [r3, #28]
    hdma_spi2_tx.Init.Priority = DMA_PRIORITY_LOW;
 80112ee:	4b40      	ldr	r3, [pc, #256]	; (80113f0 <HAL_SPI_MspInit+0x32c>)
 80112f0:	2200      	movs	r2, #0
 80112f2:	621a      	str	r2, [r3, #32]
    hdma_spi2_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 80112f4:	4b3e      	ldr	r3, [pc, #248]	; (80113f0 <HAL_SPI_MspInit+0x32c>)
 80112f6:	2200      	movs	r2, #0
 80112f8:	625a      	str	r2, [r3, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_spi2_tx) != HAL_OK)
 80112fa:	483d      	ldr	r0, [pc, #244]	; (80113f0 <HAL_SPI_MspInit+0x32c>)
 80112fc:	f7ef fd1a 	bl	8000d34 <HAL_DMA_Init>
 8011300:	4603      	mov	r3, r0
 8011302:	2b00      	cmp	r3, #0
 8011304:	d001      	beq.n	801130a <HAL_SPI_MspInit+0x246>
      Error_Handler();
 8011306:	f7ff fe65 	bl	8010fd4 <Error_Handler>
    __HAL_LINKDMA(hspi,hdmatx,hdma_spi2_tx);
 801130a:	1d3b      	adds	r3, r7, #4
 801130c:	681b      	ldr	r3, [r3, #0]
 801130e:	4a38      	ldr	r2, [pc, #224]	; (80113f0 <HAL_SPI_MspInit+0x32c>)
 8011310:	679a      	str	r2, [r3, #120]	; 0x78
 8011312:	4a37      	ldr	r2, [pc, #220]	; (80113f0 <HAL_SPI_MspInit+0x32c>)
 8011314:	1d3b      	adds	r3, r7, #4
 8011316:	681b      	ldr	r3, [r3, #0]
 8011318:	6393      	str	r3, [r2, #56]	; 0x38
    HAL_NVIC_SetPriority(SPI2_IRQn, 5, 0);
 801131a:	2200      	movs	r2, #0
 801131c:	2105      	movs	r1, #5
 801131e:	2024      	movs	r0, #36	; 0x24
 8011320:	f7ef fae2 	bl	80008e8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SPI2_IRQn);
 8011324:	2024      	movs	r0, #36	; 0x24
 8011326:	f7ef faf9 	bl	800091c <HAL_NVIC_EnableIRQ>
}
 801132a:	e1a3      	b.n	8011674 <HAL_SPI_MspInit+0x5b0>
  else if(hspi->Instance==SPI3)
 801132c:	1d3b      	adds	r3, r7, #4
 801132e:	681b      	ldr	r3, [r3, #0]
 8011330:	681b      	ldr	r3, [r3, #0]
 8011332:	4a31      	ldr	r2, [pc, #196]	; (80113f8 <HAL_SPI_MspInit+0x334>)
 8011334:	4293      	cmp	r3, r2
 8011336:	d163      	bne.n	8011400 <HAL_SPI_MspInit+0x33c>
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SPI3;
 8011338:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 801133c:	64bb      	str	r3, [r7, #72]	; 0x48
    PeriphClkInitStruct.Spi123ClockSelection = RCC_SPI123CLKSOURCE_PLL;
 801133e:	2300      	movs	r3, #0
 8011340:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8011344:	f107 0348 	add.w	r3, r7, #72	; 0x48
 8011348:	4618      	mov	r0, r3
 801134a:	f7f3 fdd1 	bl	8004ef0 <HAL_RCCEx_PeriphCLKConfig>
 801134e:	4603      	mov	r3, r0
 8011350:	2b00      	cmp	r3, #0
 8011352:	d001      	beq.n	8011358 <HAL_SPI_MspInit+0x294>
      Error_Handler();
 8011354:	f7ff fe3e 	bl	8010fd4 <Error_Handler>
    __HAL_RCC_SPI3_CLK_ENABLE();
 8011358:	4b1e      	ldr	r3, [pc, #120]	; (80113d4 <HAL_SPI_MspInit+0x310>)
 801135a:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 801135e:	4a1d      	ldr	r2, [pc, #116]	; (80113d4 <HAL_SPI_MspInit+0x310>)
 8011360:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8011364:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
 8011368:	4b1a      	ldr	r3, [pc, #104]	; (80113d4 <HAL_SPI_MspInit+0x310>)
 801136a:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 801136e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8011372:	633b      	str	r3, [r7, #48]	; 0x30
 8011374:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8011376:	4b17      	ldr	r3, [pc, #92]	; (80113d4 <HAL_SPI_MspInit+0x310>)
 8011378:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 801137c:	4a15      	ldr	r2, [pc, #84]	; (80113d4 <HAL_SPI_MspInit+0x310>)
 801137e:	f043 0302 	orr.w	r3, r3, #2
 8011382:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 8011386:	4b13      	ldr	r3, [pc, #76]	; (80113d4 <HAL_SPI_MspInit+0x310>)
 8011388:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 801138c:	f003 0302 	and.w	r3, r3, #2
 8011390:	62fb      	str	r3, [r7, #44]	; 0x2c
 8011392:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_4;
 8011394:	2318      	movs	r3, #24
 8011396:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801139a:	2302      	movs	r3, #2
 801139c:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80113a0:	2300      	movs	r3, #0
 80113a2:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80113a6:	2300      	movs	r3, #0
 80113a8:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
    GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
 80113ac:	2306      	movs	r3, #6
 80113ae:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80113b2:	f507 7382 	add.w	r3, r7, #260	; 0x104
 80113b6:	4619      	mov	r1, r3
 80113b8:	4810      	ldr	r0, [pc, #64]	; (80113fc <HAL_SPI_MspInit+0x338>)
 80113ba:	f7f2 faf5 	bl	80039a8 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(SPI3_IRQn, 5, 0);
 80113be:	2200      	movs	r2, #0
 80113c0:	2105      	movs	r1, #5
 80113c2:	2033      	movs	r0, #51	; 0x33
 80113c4:	f7ef fa90 	bl	80008e8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SPI3_IRQn);
 80113c8:	2033      	movs	r0, #51	; 0x33
 80113ca:	f7ef faa7 	bl	800091c <HAL_NVIC_EnableIRQ>
}
 80113ce:	e151      	b.n	8011674 <HAL_SPI_MspInit+0x5b0>
 80113d0:	40013000 	.word	0x40013000
 80113d4:	58024400 	.word	0x58024400
 80113d8:	58020c00 	.word	0x58020c00
 80113dc:	58021800 	.word	0x58021800
 80113e0:	40003800 	.word	0x40003800
 80113e4:	58022000 	.word	0x58022000
 80113e8:	24062824 	.word	0x24062824
 80113ec:	40020070 	.word	0x40020070
 80113f0:	240631dc 	.word	0x240631dc
 80113f4:	40020088 	.word	0x40020088
 80113f8:	40003c00 	.word	0x40003c00
 80113fc:	58020400 	.word	0x58020400
  else if(hspi->Instance==SPI4)
 8011400:	1d3b      	adds	r3, r7, #4
 8011402:	681b      	ldr	r3, [r3, #0]
 8011404:	681b      	ldr	r3, [r3, #0]
 8011406:	4a9e      	ldr	r2, [pc, #632]	; (8011680 <HAL_SPI_MspInit+0x5bc>)
 8011408:	4293      	cmp	r3, r2
 801140a:	d144      	bne.n	8011496 <HAL_SPI_MspInit+0x3d2>
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SPI4;
 801140c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8011410:	64bb      	str	r3, [r7, #72]	; 0x48
    PeriphClkInitStruct.Spi45ClockSelection = RCC_SPI45CLKSOURCE_HSI;
 8011412:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 8011416:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 801141a:	f107 0348 	add.w	r3, r7, #72	; 0x48
 801141e:	4618      	mov	r0, r3
 8011420:	f7f3 fd66 	bl	8004ef0 <HAL_RCCEx_PeriphCLKConfig>
 8011424:	4603      	mov	r3, r0
 8011426:	2b00      	cmp	r3, #0
 8011428:	d001      	beq.n	801142e <HAL_SPI_MspInit+0x36a>
      Error_Handler();
 801142a:	f7ff fdd3 	bl	8010fd4 <Error_Handler>
    __HAL_RCC_SPI4_CLK_ENABLE();
 801142e:	4b95      	ldr	r3, [pc, #596]	; (8011684 <HAL_SPI_MspInit+0x5c0>)
 8011430:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8011434:	4a93      	ldr	r2, [pc, #588]	; (8011684 <HAL_SPI_MspInit+0x5c0>)
 8011436:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 801143a:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
 801143e:	4b91      	ldr	r3, [pc, #580]	; (8011684 <HAL_SPI_MspInit+0x5c0>)
 8011440:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 8011444:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8011448:	62bb      	str	r3, [r7, #40]	; 0x28
 801144a:	6abb      	ldr	r3, [r7, #40]	; 0x28
    __HAL_RCC_GPIOE_CLK_ENABLE();
 801144c:	4b8d      	ldr	r3, [pc, #564]	; (8011684 <HAL_SPI_MspInit+0x5c0>)
 801144e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8011452:	4a8c      	ldr	r2, [pc, #560]	; (8011684 <HAL_SPI_MspInit+0x5c0>)
 8011454:	f043 0310 	orr.w	r3, r3, #16
 8011458:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 801145c:	4b89      	ldr	r3, [pc, #548]	; (8011684 <HAL_SPI_MspInit+0x5c0>)
 801145e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8011462:	f003 0310 	and.w	r3, r3, #16
 8011466:	627b      	str	r3, [r7, #36]	; 0x24
 8011468:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6;
 801146a:	2374      	movs	r3, #116	; 0x74
 801146c:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8011470:	2302      	movs	r3, #2
 8011472:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011476:	2300      	movs	r3, #0
 8011478:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 801147c:	2300      	movs	r3, #0
 801147e:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI4;
 8011482:	2305      	movs	r3, #5
 8011484:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8011488:	f507 7382 	add.w	r3, r7, #260	; 0x104
 801148c:	4619      	mov	r1, r3
 801148e:	487e      	ldr	r0, [pc, #504]	; (8011688 <HAL_SPI_MspInit+0x5c4>)
 8011490:	f7f2 fa8a 	bl	80039a8 <HAL_GPIO_Init>
}
 8011494:	e0ee      	b.n	8011674 <HAL_SPI_MspInit+0x5b0>
  else if(hspi->Instance==SPI5)
 8011496:	1d3b      	adds	r3, r7, #4
 8011498:	681b      	ldr	r3, [r3, #0]
 801149a:	681b      	ldr	r3, [r3, #0]
 801149c:	4a7b      	ldr	r2, [pc, #492]	; (801168c <HAL_SPI_MspInit+0x5c8>)
 801149e:	4293      	cmp	r3, r2
 80114a0:	d16d      	bne.n	801157e <HAL_SPI_MspInit+0x4ba>
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SPI5;
 80114a2:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80114a6:	64bb      	str	r3, [r7, #72]	; 0x48
    PeriphClkInitStruct.Spi45ClockSelection = RCC_SPI45CLKSOURCE_HSI;
 80114a8:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 80114ac:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 80114b0:	f107 0348 	add.w	r3, r7, #72	; 0x48
 80114b4:	4618      	mov	r0, r3
 80114b6:	f7f3 fd1b 	bl	8004ef0 <HAL_RCCEx_PeriphCLKConfig>
 80114ba:	4603      	mov	r3, r0
 80114bc:	2b00      	cmp	r3, #0
 80114be:	d001      	beq.n	80114c4 <HAL_SPI_MspInit+0x400>
      Error_Handler();
 80114c0:	f7ff fd88 	bl	8010fd4 <Error_Handler>
    __HAL_RCC_SPI5_CLK_ENABLE();
 80114c4:	4b6f      	ldr	r3, [pc, #444]	; (8011684 <HAL_SPI_MspInit+0x5c0>)
 80114c6:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 80114ca:	4a6e      	ldr	r2, [pc, #440]	; (8011684 <HAL_SPI_MspInit+0x5c0>)
 80114cc:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80114d0:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
 80114d4:	4b6b      	ldr	r3, [pc, #428]	; (8011684 <HAL_SPI_MspInit+0x5c0>)
 80114d6:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 80114da:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 80114de:	623b      	str	r3, [r7, #32]
 80114e0:	6a3b      	ldr	r3, [r7, #32]
    __HAL_RCC_GPIOJ_CLK_ENABLE();
 80114e2:	4b68      	ldr	r3, [pc, #416]	; (8011684 <HAL_SPI_MspInit+0x5c0>)
 80114e4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 80114e8:	4a66      	ldr	r2, [pc, #408]	; (8011684 <HAL_SPI_MspInit+0x5c0>)
 80114ea:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80114ee:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 80114f2:	4b64      	ldr	r3, [pc, #400]	; (8011684 <HAL_SPI_MspInit+0x5c0>)
 80114f4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 80114f8:	f403 7300 	and.w	r3, r3, #512	; 0x200
 80114fc:	61fb      	str	r3, [r7, #28]
 80114fe:	69fb      	ldr	r3, [r7, #28]
    __HAL_RCC_GPIOK_CLK_ENABLE();
 8011500:	4b60      	ldr	r3, [pc, #384]	; (8011684 <HAL_SPI_MspInit+0x5c0>)
 8011502:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8011506:	4a5f      	ldr	r2, [pc, #380]	; (8011684 <HAL_SPI_MspInit+0x5c0>)
 8011508:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 801150c:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 8011510:	4b5c      	ldr	r3, [pc, #368]	; (8011684 <HAL_SPI_MspInit+0x5c0>)
 8011512:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8011516:	f403 6280 	and.w	r2, r3, #1024	; 0x400
 801151a:	f107 0318 	add.w	r3, r7, #24
 801151e:	601a      	str	r2, [r3, #0]
 8011520:	f107 0318 	add.w	r3, r7, #24
 8011524:	681b      	ldr	r3, [r3, #0]
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
 8011526:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 801152a:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801152e:	2302      	movs	r3, #2
 8011530:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011534:	2300      	movs	r3, #0
 8011536:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 801153a:	2300      	movs	r3, #0
 801153c:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI5;
 8011540:	2305      	movs	r3, #5
 8011542:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
    HAL_GPIO_Init(GPIOJ, &GPIO_InitStruct);
 8011546:	f507 7382 	add.w	r3, r7, #260	; 0x104
 801154a:	4619      	mov	r1, r3
 801154c:	4850      	ldr	r0, [pc, #320]	; (8011690 <HAL_SPI_MspInit+0x5cc>)
 801154e:	f7f2 fa2b 	bl	80039a8 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;
 8011552:	2303      	movs	r3, #3
 8011554:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8011558:	2302      	movs	r3, #2
 801155a:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 801155e:	2300      	movs	r3, #0
 8011560:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8011564:	2300      	movs	r3, #0
 8011566:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI5;
 801156a:	2305      	movs	r3, #5
 801156c:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
    HAL_GPIO_Init(GPIOK, &GPIO_InitStruct);
 8011570:	f507 7382 	add.w	r3, r7, #260	; 0x104
 8011574:	4619      	mov	r1, r3
 8011576:	4847      	ldr	r0, [pc, #284]	; (8011694 <HAL_SPI_MspInit+0x5d0>)
 8011578:	f7f2 fa16 	bl	80039a8 <HAL_GPIO_Init>
}
 801157c:	e07a      	b.n	8011674 <HAL_SPI_MspInit+0x5b0>
  else if(hspi->Instance==SPI6)
 801157e:	1d3b      	adds	r3, r7, #4
 8011580:	681b      	ldr	r3, [r3, #0]
 8011582:	681b      	ldr	r3, [r3, #0]
 8011584:	4a44      	ldr	r2, [pc, #272]	; (8011698 <HAL_SPI_MspInit+0x5d4>)
 8011586:	4293      	cmp	r3, r2
 8011588:	d174      	bne.n	8011674 <HAL_SPI_MspInit+0x5b0>
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SPI6;
 801158a:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 801158e:	64bb      	str	r3, [r7, #72]	; 0x48
    PeriphClkInitStruct.Spi6ClockSelection = RCC_SPI6CLKSOURCE_D3PCLK1;
 8011590:	2300      	movs	r3, #0
 8011592:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8011596:	f107 0348 	add.w	r3, r7, #72	; 0x48
 801159a:	4618      	mov	r0, r3
 801159c:	f7f3 fca8 	bl	8004ef0 <HAL_RCCEx_PeriphCLKConfig>
 80115a0:	4603      	mov	r3, r0
 80115a2:	2b00      	cmp	r3, #0
 80115a4:	d001      	beq.n	80115aa <HAL_SPI_MspInit+0x4e6>
      Error_Handler();
 80115a6:	f7ff fd15 	bl	8010fd4 <Error_Handler>
    __HAL_RCC_SPI6_CLK_ENABLE();
 80115aa:	4b36      	ldr	r3, [pc, #216]	; (8011684 <HAL_SPI_MspInit+0x5c0>)
 80115ac:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 80115b0:	4a34      	ldr	r2, [pc, #208]	; (8011684 <HAL_SPI_MspInit+0x5c0>)
 80115b2:	f043 0320 	orr.w	r3, r3, #32
 80115b6:	f8c2 30f4 	str.w	r3, [r2, #244]	; 0xf4
 80115ba:	4b32      	ldr	r3, [pc, #200]	; (8011684 <HAL_SPI_MspInit+0x5c0>)
 80115bc:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 80115c0:	f003 0220 	and.w	r2, r3, #32
 80115c4:	f107 0314 	add.w	r3, r7, #20
 80115c8:	601a      	str	r2, [r3, #0]
 80115ca:	f107 0314 	add.w	r3, r7, #20
 80115ce:	681b      	ldr	r3, [r3, #0]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80115d0:	4b2c      	ldr	r3, [pc, #176]	; (8011684 <HAL_SPI_MspInit+0x5c0>)
 80115d2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 80115d6:	4a2b      	ldr	r2, [pc, #172]	; (8011684 <HAL_SPI_MspInit+0x5c0>)
 80115d8:	f043 0301 	orr.w	r3, r3, #1
 80115dc:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 80115e0:	4b28      	ldr	r3, [pc, #160]	; (8011684 <HAL_SPI_MspInit+0x5c0>)
 80115e2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 80115e6:	f003 0201 	and.w	r2, r3, #1
 80115ea:	f107 0310 	add.w	r3, r7, #16
 80115ee:	601a      	str	r2, [r3, #0]
 80115f0:	f107 0310 	add.w	r3, r7, #16
 80115f4:	681b      	ldr	r3, [r3, #0]
    __HAL_RCC_GPIOG_CLK_ENABLE();
 80115f6:	4b23      	ldr	r3, [pc, #140]	; (8011684 <HAL_SPI_MspInit+0x5c0>)
 80115f8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 80115fc:	4a21      	ldr	r2, [pc, #132]	; (8011684 <HAL_SPI_MspInit+0x5c0>)
 80115fe:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8011602:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 8011606:	4b1f      	ldr	r3, [pc, #124]	; (8011684 <HAL_SPI_MspInit+0x5c0>)
 8011608:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 801160c:	f003 0240 	and.w	r2, r3, #64	; 0x40
 8011610:	f107 030c 	add.w	r3, r7, #12
 8011614:	601a      	str	r2, [r3, #0]
 8011616:	f107 030c 	add.w	r3, r7, #12
 801161a:	681b      	ldr	r3, [r3, #0]
    GPIO_InitStruct.Pin = GPIO_PIN_15;
 801161c:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8011620:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8011624:	2302      	movs	r3, #2
 8011626:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 801162a:	2300      	movs	r3, #0
 801162c:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8011630:	2300      	movs	r3, #0
 8011632:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
    GPIO_InitStruct.Alternate = GPIO_AF7_SPI6;
 8011636:	2307      	movs	r3, #7
 8011638:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 801163c:	f507 7382 	add.w	r3, r7, #260	; 0x104
 8011640:	4619      	mov	r1, r3
 8011642:	4816      	ldr	r0, [pc, #88]	; (801169c <HAL_SPI_MspInit+0x5d8>)
 8011644:	f7f2 f9b0 	bl	80039a8 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14;
 8011648:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 801164c:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8011650:	2302      	movs	r3, #2
 8011652:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011656:	2300      	movs	r3, #0
 8011658:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 801165c:	2300      	movs	r3, #0
 801165e:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI6;
 8011662:	2305      	movs	r3, #5
 8011664:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
    HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8011668:	f507 7382 	add.w	r3, r7, #260	; 0x104
 801166c:	4619      	mov	r1, r3
 801166e:	480c      	ldr	r0, [pc, #48]	; (80116a0 <HAL_SPI_MspInit+0x5dc>)
 8011670:	f7f2 f99a 	bl	80039a8 <HAL_GPIO_Init>
}
 8011674:	bf00      	nop
 8011676:	f507 778c 	add.w	r7, r7, #280	; 0x118
 801167a:	46bd      	mov	sp, r7
 801167c:	bd80      	pop	{r7, pc}
 801167e:	bf00      	nop
 8011680:	40013400 	.word	0x40013400
 8011684:	58024400 	.word	0x58024400
 8011688:	58021000 	.word	0x58021000
 801168c:	40015000 	.word	0x40015000
 8011690:	58022400 	.word	0x58022400
 8011694:	58022800 	.word	0x58022800
 8011698:	58001400 	.word	0x58001400
 801169c:	58020000 	.word	0x58020000
 80116a0:	58021800 	.word	0x58021800

080116a4 <HAL_TIM_Base_MspInit>:
* This function configures the hardware resources used in this example
* @param htim_base: TIM_Base handle pointer
* @retval None
*/
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{
 80116a4:	b480      	push	{r7}
 80116a6:	b085      	sub	sp, #20
 80116a8:	af00      	add	r7, sp, #0
 80116aa:	6078      	str	r0, [r7, #4]
  if(htim_base->Instance==TIM1)
 80116ac:	687b      	ldr	r3, [r7, #4]
 80116ae:	681b      	ldr	r3, [r3, #0]
 80116b0:	4a16      	ldr	r2, [pc, #88]	; (801170c <HAL_TIM_Base_MspInit+0x68>)
 80116b2:	4293      	cmp	r3, r2
 80116b4:	d10f      	bne.n	80116d6 <HAL_TIM_Base_MspInit+0x32>
  {
  /* USER CODE BEGIN TIM1_MspInit 0 */

  /* USER CODE END TIM1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM1_CLK_ENABLE();
 80116b6:	4b16      	ldr	r3, [pc, #88]	; (8011710 <HAL_TIM_Base_MspInit+0x6c>)
 80116b8:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 80116bc:	4a14      	ldr	r2, [pc, #80]	; (8011710 <HAL_TIM_Base_MspInit+0x6c>)
 80116be:	f043 0301 	orr.w	r3, r3, #1
 80116c2:	f8c2 30f0 	str.w	r3, [r2, #240]	; 0xf0
 80116c6:	4b12      	ldr	r3, [pc, #72]	; (8011710 <HAL_TIM_Base_MspInit+0x6c>)
 80116c8:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 80116cc:	f003 0301 	and.w	r3, r3, #1
 80116d0:	60fb      	str	r3, [r7, #12]
 80116d2:	68fb      	ldr	r3, [r7, #12]
  /* USER CODE BEGIN TIM12_MspInit 1 */

  /* USER CODE END TIM12_MspInit 1 */
  }

}
 80116d4:	e013      	b.n	80116fe <HAL_TIM_Base_MspInit+0x5a>
  else if(htim_base->Instance==TIM12)
 80116d6:	687b      	ldr	r3, [r7, #4]
 80116d8:	681b      	ldr	r3, [r3, #0]
 80116da:	4a0e      	ldr	r2, [pc, #56]	; (8011714 <HAL_TIM_Base_MspInit+0x70>)
 80116dc:	4293      	cmp	r3, r2
 80116de:	d10e      	bne.n	80116fe <HAL_TIM_Base_MspInit+0x5a>
    __HAL_RCC_TIM12_CLK_ENABLE();
 80116e0:	4b0b      	ldr	r3, [pc, #44]	; (8011710 <HAL_TIM_Base_MspInit+0x6c>)
 80116e2:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 80116e6:	4a0a      	ldr	r2, [pc, #40]	; (8011710 <HAL_TIM_Base_MspInit+0x6c>)
 80116e8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80116ec:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
 80116f0:	4b07      	ldr	r3, [pc, #28]	; (8011710 <HAL_TIM_Base_MspInit+0x6c>)
 80116f2:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 80116f6:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80116fa:	60bb      	str	r3, [r7, #8]
 80116fc:	68bb      	ldr	r3, [r7, #8]
}
 80116fe:	bf00      	nop
 8011700:	3714      	adds	r7, #20
 8011702:	46bd      	mov	sp, r7
 8011704:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011708:	4770      	bx	lr
 801170a:	bf00      	nop
 801170c:	40010000 	.word	0x40010000
 8011710:	58024400 	.word	0x58024400
 8011714:	40001800 	.word	0x40001800

08011718 <HAL_TIM_PWM_MspInit>:
* This function configures the hardware resources used in this example
* @param htim_pwm: TIM_PWM handle pointer
* @retval None
*/
void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef* htim_pwm)
{
 8011718:	b480      	push	{r7}
 801171a:	b085      	sub	sp, #20
 801171c:	af00      	add	r7, sp, #0
 801171e:	6078      	str	r0, [r7, #4]
  if(htim_pwm->Instance==TIM2)
 8011720:	687b      	ldr	r3, [r7, #4]
 8011722:	681b      	ldr	r3, [r3, #0]
 8011724:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8011728:	d10e      	bne.n	8011748 <HAL_TIM_PWM_MspInit+0x30>
  {
  /* USER CODE BEGIN TIM2_MspInit 0 */

  /* USER CODE END TIM2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM2_CLK_ENABLE();
 801172a:	4b0a      	ldr	r3, [pc, #40]	; (8011754 <HAL_TIM_PWM_MspInit+0x3c>)
 801172c:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 8011730:	4a08      	ldr	r2, [pc, #32]	; (8011754 <HAL_TIM_PWM_MspInit+0x3c>)
 8011732:	f043 0301 	orr.w	r3, r3, #1
 8011736:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
 801173a:	4b06      	ldr	r3, [pc, #24]	; (8011754 <HAL_TIM_PWM_MspInit+0x3c>)
 801173c:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 8011740:	f003 0301 	and.w	r3, r3, #1
 8011744:	60fb      	str	r3, [r7, #12]
 8011746:	68fb      	ldr	r3, [r7, #12]
  /* USER CODE BEGIN TIM2_MspInit 1 */

  /* USER CODE END TIM2_MspInit 1 */
  }

}
 8011748:	bf00      	nop
 801174a:	3714      	adds	r7, #20
 801174c:	46bd      	mov	sp, r7
 801174e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011752:	4770      	bx	lr
 8011754:	58024400 	.word	0x58024400

08011758 <HAL_TIM_MspPostInit>:
  }

}

void HAL_TIM_MspPostInit(TIM_HandleTypeDef* htim)
{
 8011758:	b580      	push	{r7, lr}
 801175a:	b08a      	sub	sp, #40	; 0x28
 801175c:	af00      	add	r7, sp, #0
 801175e:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8011760:	f107 0314 	add.w	r3, r7, #20
 8011764:	2200      	movs	r2, #0
 8011766:	601a      	str	r2, [r3, #0]
 8011768:	605a      	str	r2, [r3, #4]
 801176a:	609a      	str	r2, [r3, #8]
 801176c:	60da      	str	r2, [r3, #12]
 801176e:	611a      	str	r2, [r3, #16]
  if(htim->Instance==TIM2)
 8011770:	687b      	ldr	r3, [r7, #4]
 8011772:	681b      	ldr	r3, [r3, #0]
 8011774:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8011778:	d11f      	bne.n	80117ba <HAL_TIM_MspPostInit+0x62>
  {
  /* USER CODE BEGIN TIM2_MspPostInit 0 */

  /* USER CODE END TIM2_MspPostInit 0 */
    __HAL_RCC_GPIOA_CLK_ENABLE();
 801177a:	4b24      	ldr	r3, [pc, #144]	; (801180c <HAL_TIM_MspPostInit+0xb4>)
 801177c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8011780:	4a22      	ldr	r2, [pc, #136]	; (801180c <HAL_TIM_MspPostInit+0xb4>)
 8011782:	f043 0301 	orr.w	r3, r3, #1
 8011786:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 801178a:	4b20      	ldr	r3, [pc, #128]	; (801180c <HAL_TIM_MspPostInit+0xb4>)
 801178c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8011790:	f003 0301 	and.w	r3, r3, #1
 8011794:	613b      	str	r3, [r7, #16]
 8011796:	693b      	ldr	r3, [r7, #16]
    /**TIM2 GPIO Configuration
    PA0     ------> TIM2_CH1
    */
    GPIO_InitStruct.Pin = GPIO_PIN_0;
 8011798:	2301      	movs	r3, #1
 801179a:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801179c:	2302      	movs	r3, #2
 801179e:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80117a0:	2300      	movs	r3, #0
 80117a2:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80117a4:	2300      	movs	r3, #0
 80117a6:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 80117a8:	2301      	movs	r3, #1
 80117aa:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80117ac:	f107 0314 	add.w	r3, r7, #20
 80117b0:	4619      	mov	r1, r3
 80117b2:	4817      	ldr	r0, [pc, #92]	; (8011810 <HAL_TIM_MspPostInit+0xb8>)
 80117b4:	f7f2 f8f8 	bl	80039a8 <HAL_GPIO_Init>
  /* USER CODE BEGIN TIM12_MspPostInit 1 */

  /* USER CODE END TIM12_MspPostInit 1 */
  }

}
 80117b8:	e024      	b.n	8011804 <HAL_TIM_MspPostInit+0xac>
  else if(htim->Instance==TIM12)
 80117ba:	687b      	ldr	r3, [r7, #4]
 80117bc:	681b      	ldr	r3, [r3, #0]
 80117be:	4a15      	ldr	r2, [pc, #84]	; (8011814 <HAL_TIM_MspPostInit+0xbc>)
 80117c0:	4293      	cmp	r3, r2
 80117c2:	d11f      	bne.n	8011804 <HAL_TIM_MspPostInit+0xac>
    __HAL_RCC_GPIOH_CLK_ENABLE();
 80117c4:	4b11      	ldr	r3, [pc, #68]	; (801180c <HAL_TIM_MspPostInit+0xb4>)
 80117c6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 80117ca:	4a10      	ldr	r2, [pc, #64]	; (801180c <HAL_TIM_MspPostInit+0xb4>)
 80117cc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80117d0:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 80117d4:	4b0d      	ldr	r3, [pc, #52]	; (801180c <HAL_TIM_MspPostInit+0xb4>)
 80117d6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 80117da:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80117de:	60fb      	str	r3, [r7, #12]
 80117e0:	68fb      	ldr	r3, [r7, #12]
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_9;
 80117e2:	f44f 7310 	mov.w	r3, #576	; 0x240
 80117e6:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80117e8:	2302      	movs	r3, #2
 80117ea:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80117ec:	2300      	movs	r3, #0
 80117ee:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80117f0:	2300      	movs	r3, #0
 80117f2:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM12;
 80117f4:	2302      	movs	r3, #2
 80117f6:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 80117f8:	f107 0314 	add.w	r3, r7, #20
 80117fc:	4619      	mov	r1, r3
 80117fe:	4806      	ldr	r0, [pc, #24]	; (8011818 <HAL_TIM_MspPostInit+0xc0>)
 8011800:	f7f2 f8d2 	bl	80039a8 <HAL_GPIO_Init>
}
 8011804:	bf00      	nop
 8011806:	3728      	adds	r7, #40	; 0x28
 8011808:	46bd      	mov	sp, r7
 801180a:	bd80      	pop	{r7, pc}
 801180c:	58024400 	.word	0x58024400
 8011810:	58020000 	.word	0x58020000
 8011814:	40001800 	.word	0x40001800
 8011818:	58021c00 	.word	0x58021c00

0801181c <HAL_UART_MspInit>:
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 801181c:	b580      	push	{r7, lr}
 801181e:	b0be      	sub	sp, #248	; 0xf8
 8011820:	af00      	add	r7, sp, #0
 8011822:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8011824:	f107 03e4 	add.w	r3, r7, #228	; 0xe4
 8011828:	2200      	movs	r2, #0
 801182a:	601a      	str	r2, [r3, #0]
 801182c:	605a      	str	r2, [r3, #4]
 801182e:	609a      	str	r2, [r3, #8]
 8011830:	60da      	str	r2, [r3, #12]
 8011832:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8011834:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8011838:	22bc      	movs	r2, #188	; 0xbc
 801183a:	2100      	movs	r1, #0
 801183c:	4618      	mov	r0, r3
 801183e:	f010 fa19 	bl	8021c74 <memset>
  if(huart->Instance==UART4)
 8011842:	687b      	ldr	r3, [r7, #4]
 8011844:	681b      	ldr	r3, [r3, #0]
 8011846:	4aad      	ldr	r2, [pc, #692]	; (8011afc <HAL_UART_MspInit+0x2e0>)
 8011848:	4293      	cmp	r3, r2
 801184a:	f040 80a9 	bne.w	80119a0 <HAL_UART_MspInit+0x184>
  /* USER CODE BEGIN UART4_MspInit 0 */

  /* USER CODE END UART4_MspInit 0 */
  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_UART4;
 801184e:	2302      	movs	r3, #2
 8011850:	62bb      	str	r3, [r7, #40]	; 0x28
    PeriphClkInitStruct.Usart234578ClockSelection = RCC_USART234578CLKSOURCE_D2PCLK1;
 8011852:	2300      	movs	r3, #0
 8011854:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8011858:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801185c:	4618      	mov	r0, r3
 801185e:	f7f3 fb47 	bl	8004ef0 <HAL_RCCEx_PeriphCLKConfig>
 8011862:	4603      	mov	r3, r0
 8011864:	2b00      	cmp	r3, #0
 8011866:	d001      	beq.n	801186c <HAL_UART_MspInit+0x50>
    {
      Error_Handler();
 8011868:	f7ff fbb4 	bl	8010fd4 <Error_Handler>
    }

    /* Peripheral clock enable */
    __HAL_RCC_UART4_CLK_ENABLE();
 801186c:	4ba4      	ldr	r3, [pc, #656]	; (8011b00 <HAL_UART_MspInit+0x2e4>)
 801186e:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 8011872:	4aa3      	ldr	r2, [pc, #652]	; (8011b00 <HAL_UART_MspInit+0x2e4>)
 8011874:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8011878:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
 801187c:	4ba0      	ldr	r3, [pc, #640]	; (8011b00 <HAL_UART_MspInit+0x2e4>)
 801187e:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 8011882:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8011886:	627b      	str	r3, [r7, #36]	; 0x24
 8011888:	6a7b      	ldr	r3, [r7, #36]	; 0x24

    __HAL_RCC_GPIOA_CLK_ENABLE();
 801188a:	4b9d      	ldr	r3, [pc, #628]	; (8011b00 <HAL_UART_MspInit+0x2e4>)
 801188c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8011890:	4a9b      	ldr	r2, [pc, #620]	; (8011b00 <HAL_UART_MspInit+0x2e4>)
 8011892:	f043 0301 	orr.w	r3, r3, #1
 8011896:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 801189a:	4b99      	ldr	r3, [pc, #612]	; (8011b00 <HAL_UART_MspInit+0x2e4>)
 801189c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 80118a0:	f003 0301 	and.w	r3, r3, #1
 80118a4:	623b      	str	r3, [r7, #32]
 80118a6:	6a3b      	ldr	r3, [r7, #32]
    /**UART4 GPIO Configuration
    PA11     ------> UART4_RX
    PA12     ------> UART4_TX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
 80118a8:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 80118ac:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80118b0:	2302      	movs	r3, #2
 80118b2:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80118b6:	2300      	movs	r3, #0
 80118b8:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80118bc:	2300      	movs	r3, #0
 80118be:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
    GPIO_InitStruct.Alternate = GPIO_AF6_UART4;
 80118c2:	2306      	movs	r3, #6
 80118c4:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80118c8:	f107 03e4 	add.w	r3, r7, #228	; 0xe4
 80118cc:	4619      	mov	r1, r3
 80118ce:	488d      	ldr	r0, [pc, #564]	; (8011b04 <HAL_UART_MspInit+0x2e8>)
 80118d0:	f7f2 f86a 	bl	80039a8 <HAL_GPIO_Init>

    /* UART4 DMA Init */
    /* UART4_TX Init */
    hdma_uart4_tx.Instance = DMA1_Stream0;
 80118d4:	4b8c      	ldr	r3, [pc, #560]	; (8011b08 <HAL_UART_MspInit+0x2ec>)
 80118d6:	4a8d      	ldr	r2, [pc, #564]	; (8011b0c <HAL_UART_MspInit+0x2f0>)
 80118d8:	601a      	str	r2, [r3, #0]
    hdma_uart4_tx.Init.Request = DMA_REQUEST_UART4_TX;
 80118da:	4b8b      	ldr	r3, [pc, #556]	; (8011b08 <HAL_UART_MspInit+0x2ec>)
 80118dc:	2240      	movs	r2, #64	; 0x40
 80118de:	605a      	str	r2, [r3, #4]
    hdma_uart4_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 80118e0:	4b89      	ldr	r3, [pc, #548]	; (8011b08 <HAL_UART_MspInit+0x2ec>)
 80118e2:	2240      	movs	r2, #64	; 0x40
 80118e4:	609a      	str	r2, [r3, #8]
    hdma_uart4_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 80118e6:	4b88      	ldr	r3, [pc, #544]	; (8011b08 <HAL_UART_MspInit+0x2ec>)
 80118e8:	2200      	movs	r2, #0
 80118ea:	60da      	str	r2, [r3, #12]
    hdma_uart4_tx.Init.MemInc = DMA_MINC_ENABLE;
 80118ec:	4b86      	ldr	r3, [pc, #536]	; (8011b08 <HAL_UART_MspInit+0x2ec>)
 80118ee:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80118f2:	611a      	str	r2, [r3, #16]
    hdma_uart4_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 80118f4:	4b84      	ldr	r3, [pc, #528]	; (8011b08 <HAL_UART_MspInit+0x2ec>)
 80118f6:	2200      	movs	r2, #0
 80118f8:	615a      	str	r2, [r3, #20]
    hdma_uart4_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 80118fa:	4b83      	ldr	r3, [pc, #524]	; (8011b08 <HAL_UART_MspInit+0x2ec>)
 80118fc:	2200      	movs	r2, #0
 80118fe:	619a      	str	r2, [r3, #24]
    hdma_uart4_tx.Init.Mode = DMA_NORMAL;
 8011900:	4b81      	ldr	r3, [pc, #516]	; (8011b08 <HAL_UART_MspInit+0x2ec>)
 8011902:	2200      	movs	r2, #0
 8011904:	61da      	str	r2, [r3, #28]
    hdma_uart4_tx.Init.Priority = DMA_PRIORITY_HIGH;
 8011906:	4b80      	ldr	r3, [pc, #512]	; (8011b08 <HAL_UART_MspInit+0x2ec>)
 8011908:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 801190c:	621a      	str	r2, [r3, #32]
    hdma_uart4_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 801190e:	4b7e      	ldr	r3, [pc, #504]	; (8011b08 <HAL_UART_MspInit+0x2ec>)
 8011910:	2200      	movs	r2, #0
 8011912:	625a      	str	r2, [r3, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_uart4_tx) != HAL_OK)
 8011914:	487c      	ldr	r0, [pc, #496]	; (8011b08 <HAL_UART_MspInit+0x2ec>)
 8011916:	f7ef fa0d 	bl	8000d34 <HAL_DMA_Init>
 801191a:	4603      	mov	r3, r0
 801191c:	2b00      	cmp	r3, #0
 801191e:	d001      	beq.n	8011924 <HAL_UART_MspInit+0x108>
    {
      Error_Handler();
 8011920:	f7ff fb58 	bl	8010fd4 <Error_Handler>
    }

    __HAL_LINKDMA(huart,hdmatx,hdma_uart4_tx);
 8011924:	687b      	ldr	r3, [r7, #4]
 8011926:	4a78      	ldr	r2, [pc, #480]	; (8011b08 <HAL_UART_MspInit+0x2ec>)
 8011928:	679a      	str	r2, [r3, #120]	; 0x78
 801192a:	4a77      	ldr	r2, [pc, #476]	; (8011b08 <HAL_UART_MspInit+0x2ec>)
 801192c:	687b      	ldr	r3, [r7, #4]
 801192e:	6393      	str	r3, [r2, #56]	; 0x38

    /* UART4_RX Init */
    hdma_uart4_rx.Instance = DMA1_Stream1;
 8011930:	4b77      	ldr	r3, [pc, #476]	; (8011b10 <HAL_UART_MspInit+0x2f4>)
 8011932:	4a78      	ldr	r2, [pc, #480]	; (8011b14 <HAL_UART_MspInit+0x2f8>)
 8011934:	601a      	str	r2, [r3, #0]
    hdma_uart4_rx.Init.Request = DMA_REQUEST_UART4_RX;
 8011936:	4b76      	ldr	r3, [pc, #472]	; (8011b10 <HAL_UART_MspInit+0x2f4>)
 8011938:	223f      	movs	r2, #63	; 0x3f
 801193a:	605a      	str	r2, [r3, #4]
    hdma_uart4_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 801193c:	4b74      	ldr	r3, [pc, #464]	; (8011b10 <HAL_UART_MspInit+0x2f4>)
 801193e:	2200      	movs	r2, #0
 8011940:	609a      	str	r2, [r3, #8]
    hdma_uart4_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 8011942:	4b73      	ldr	r3, [pc, #460]	; (8011b10 <HAL_UART_MspInit+0x2f4>)
 8011944:	2200      	movs	r2, #0
 8011946:	60da      	str	r2, [r3, #12]
    hdma_uart4_rx.Init.MemInc = DMA_MINC_ENABLE;
 8011948:	4b71      	ldr	r3, [pc, #452]	; (8011b10 <HAL_UART_MspInit+0x2f4>)
 801194a:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801194e:	611a      	str	r2, [r3, #16]
    hdma_uart4_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8011950:	4b6f      	ldr	r3, [pc, #444]	; (8011b10 <HAL_UART_MspInit+0x2f4>)
 8011952:	2200      	movs	r2, #0
 8011954:	615a      	str	r2, [r3, #20]
    hdma_uart4_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8011956:	4b6e      	ldr	r3, [pc, #440]	; (8011b10 <HAL_UART_MspInit+0x2f4>)
 8011958:	2200      	movs	r2, #0
 801195a:	619a      	str	r2, [r3, #24]
    hdma_uart4_rx.Init.Mode = DMA_CIRCULAR;
 801195c:	4b6c      	ldr	r3, [pc, #432]	; (8011b10 <HAL_UART_MspInit+0x2f4>)
 801195e:	f44f 7280 	mov.w	r2, #256	; 0x100
 8011962:	61da      	str	r2, [r3, #28]
    hdma_uart4_rx.Init.Priority = DMA_PRIORITY_MEDIUM;
 8011964:	4b6a      	ldr	r3, [pc, #424]	; (8011b10 <HAL_UART_MspInit+0x2f4>)
 8011966:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 801196a:	621a      	str	r2, [r3, #32]
    hdma_uart4_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 801196c:	4b68      	ldr	r3, [pc, #416]	; (8011b10 <HAL_UART_MspInit+0x2f4>)
 801196e:	2200      	movs	r2, #0
 8011970:	625a      	str	r2, [r3, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_uart4_rx) != HAL_OK)
 8011972:	4867      	ldr	r0, [pc, #412]	; (8011b10 <HAL_UART_MspInit+0x2f4>)
 8011974:	f7ef f9de 	bl	8000d34 <HAL_DMA_Init>
 8011978:	4603      	mov	r3, r0
 801197a:	2b00      	cmp	r3, #0
 801197c:	d001      	beq.n	8011982 <HAL_UART_MspInit+0x166>
    {
      Error_Handler();
 801197e:	f7ff fb29 	bl	8010fd4 <Error_Handler>
    }

    __HAL_LINKDMA(huart,hdmarx,hdma_uart4_rx);
 8011982:	687b      	ldr	r3, [r7, #4]
 8011984:	4a62      	ldr	r2, [pc, #392]	; (8011b10 <HAL_UART_MspInit+0x2f4>)
 8011986:	67da      	str	r2, [r3, #124]	; 0x7c
 8011988:	4a61      	ldr	r2, [pc, #388]	; (8011b10 <HAL_UART_MspInit+0x2f4>)
 801198a:	687b      	ldr	r3, [r7, #4]
 801198c:	6393      	str	r3, [r2, #56]	; 0x38

    /* UART4 interrupt Init */
    HAL_NVIC_SetPriority(UART4_IRQn, 5, 0);
 801198e:	2200      	movs	r2, #0
 8011990:	2105      	movs	r1, #5
 8011992:	2034      	movs	r0, #52	; 0x34
 8011994:	f7ee ffa8 	bl	80008e8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(UART4_IRQn);
 8011998:	2034      	movs	r0, #52	; 0x34
 801199a:	f7ee ffbf 	bl	800091c <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USART3_MspInit 1 */

  /* USER CODE END USART3_MspInit 1 */
  }

}
 801199e:	e221      	b.n	8011de4 <HAL_UART_MspInit+0x5c8>
  else if(huart->Instance==UART8)
 80119a0:	687b      	ldr	r3, [r7, #4]
 80119a2:	681b      	ldr	r3, [r3, #0]
 80119a4:	4a5c      	ldr	r2, [pc, #368]	; (8011b18 <HAL_UART_MspInit+0x2fc>)
 80119a6:	4293      	cmp	r3, r2
 80119a8:	f040 80c2 	bne.w	8011b30 <HAL_UART_MspInit+0x314>
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_UART8;
 80119ac:	2302      	movs	r3, #2
 80119ae:	62bb      	str	r3, [r7, #40]	; 0x28
    PeriphClkInitStruct.Usart234578ClockSelection = RCC_USART234578CLKSOURCE_D2PCLK1;
 80119b0:	2300      	movs	r3, #0
 80119b2:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 80119b6:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80119ba:	4618      	mov	r0, r3
 80119bc:	f7f3 fa98 	bl	8004ef0 <HAL_RCCEx_PeriphCLKConfig>
 80119c0:	4603      	mov	r3, r0
 80119c2:	2b00      	cmp	r3, #0
 80119c4:	d001      	beq.n	80119ca <HAL_UART_MspInit+0x1ae>
      Error_Handler();
 80119c6:	f7ff fb05 	bl	8010fd4 <Error_Handler>
    __HAL_RCC_UART8_CLK_ENABLE();
 80119ca:	4b4d      	ldr	r3, [pc, #308]	; (8011b00 <HAL_UART_MspInit+0x2e4>)
 80119cc:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 80119d0:	4a4b      	ldr	r2, [pc, #300]	; (8011b00 <HAL_UART_MspInit+0x2e4>)
 80119d2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80119d6:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
 80119da:	4b49      	ldr	r3, [pc, #292]	; (8011b00 <HAL_UART_MspInit+0x2e4>)
 80119dc:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 80119e0:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 80119e4:	61fb      	str	r3, [r7, #28]
 80119e6:	69fb      	ldr	r3, [r7, #28]
    __HAL_RCC_GPIOJ_CLK_ENABLE();
 80119e8:	4b45      	ldr	r3, [pc, #276]	; (8011b00 <HAL_UART_MspInit+0x2e4>)
 80119ea:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 80119ee:	4a44      	ldr	r2, [pc, #272]	; (8011b00 <HAL_UART_MspInit+0x2e4>)
 80119f0:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80119f4:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 80119f8:	4b41      	ldr	r3, [pc, #260]	; (8011b00 <HAL_UART_MspInit+0x2e4>)
 80119fa:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 80119fe:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8011a02:	61bb      	str	r3, [r7, #24]
 8011a04:	69bb      	ldr	r3, [r7, #24]
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;
 8011a06:	f44f 7340 	mov.w	r3, #768	; 0x300
 8011a0a:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8011a0e:	2302      	movs	r3, #2
 8011a10:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011a14:	2300      	movs	r3, #0
 8011a16:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8011a1a:	2300      	movs	r3, #0
 8011a1c:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
    GPIO_InitStruct.Alternate = GPIO_AF8_UART8;
 8011a20:	2308      	movs	r3, #8
 8011a22:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
    HAL_GPIO_Init(GPIOJ, &GPIO_InitStruct);
 8011a26:	f107 03e4 	add.w	r3, r7, #228	; 0xe4
 8011a2a:	4619      	mov	r1, r3
 8011a2c:	483b      	ldr	r0, [pc, #236]	; (8011b1c <HAL_UART_MspInit+0x300>)
 8011a2e:	f7f1 ffbb 	bl	80039a8 <HAL_GPIO_Init>
    hdma_uart8_rx.Instance = DMA1_Stream7;
 8011a32:	4b3b      	ldr	r3, [pc, #236]	; (8011b20 <HAL_UART_MspInit+0x304>)
 8011a34:	4a3b      	ldr	r2, [pc, #236]	; (8011b24 <HAL_UART_MspInit+0x308>)
 8011a36:	601a      	str	r2, [r3, #0]
    hdma_uart8_rx.Init.Request = DMA_REQUEST_UART8_RX;
 8011a38:	4b39      	ldr	r3, [pc, #228]	; (8011b20 <HAL_UART_MspInit+0x304>)
 8011a3a:	2251      	movs	r2, #81	; 0x51
 8011a3c:	605a      	str	r2, [r3, #4]
    hdma_uart8_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8011a3e:	4b38      	ldr	r3, [pc, #224]	; (8011b20 <HAL_UART_MspInit+0x304>)
 8011a40:	2200      	movs	r2, #0
 8011a42:	609a      	str	r2, [r3, #8]
    hdma_uart8_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 8011a44:	4b36      	ldr	r3, [pc, #216]	; (8011b20 <HAL_UART_MspInit+0x304>)
 8011a46:	2200      	movs	r2, #0
 8011a48:	60da      	str	r2, [r3, #12]
    hdma_uart8_rx.Init.MemInc = DMA_MINC_ENABLE;
 8011a4a:	4b35      	ldr	r3, [pc, #212]	; (8011b20 <HAL_UART_MspInit+0x304>)
 8011a4c:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8011a50:	611a      	str	r2, [r3, #16]
    hdma_uart8_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8011a52:	4b33      	ldr	r3, [pc, #204]	; (8011b20 <HAL_UART_MspInit+0x304>)
 8011a54:	2200      	movs	r2, #0
 8011a56:	615a      	str	r2, [r3, #20]
    hdma_uart8_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8011a58:	4b31      	ldr	r3, [pc, #196]	; (8011b20 <HAL_UART_MspInit+0x304>)
 8011a5a:	2200      	movs	r2, #0
 8011a5c:	619a      	str	r2, [r3, #24]
    hdma_uart8_rx.Init.Mode = DMA_CIRCULAR;
 8011a5e:	4b30      	ldr	r3, [pc, #192]	; (8011b20 <HAL_UART_MspInit+0x304>)
 8011a60:	f44f 7280 	mov.w	r2, #256	; 0x100
 8011a64:	61da      	str	r2, [r3, #28]
    hdma_uart8_rx.Init.Priority = DMA_PRIORITY_HIGH;
 8011a66:	4b2e      	ldr	r3, [pc, #184]	; (8011b20 <HAL_UART_MspInit+0x304>)
 8011a68:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 8011a6c:	621a      	str	r2, [r3, #32]
    hdma_uart8_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 8011a6e:	4b2c      	ldr	r3, [pc, #176]	; (8011b20 <HAL_UART_MspInit+0x304>)
 8011a70:	2200      	movs	r2, #0
 8011a72:	625a      	str	r2, [r3, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_uart8_rx) != HAL_OK)
 8011a74:	482a      	ldr	r0, [pc, #168]	; (8011b20 <HAL_UART_MspInit+0x304>)
 8011a76:	f7ef f95d 	bl	8000d34 <HAL_DMA_Init>
 8011a7a:	4603      	mov	r3, r0
 8011a7c:	2b00      	cmp	r3, #0
 8011a7e:	d001      	beq.n	8011a84 <HAL_UART_MspInit+0x268>
      Error_Handler();
 8011a80:	f7ff faa8 	bl	8010fd4 <Error_Handler>
    __HAL_LINKDMA(huart,hdmarx,hdma_uart8_rx);
 8011a84:	687b      	ldr	r3, [r7, #4]
 8011a86:	4a26      	ldr	r2, [pc, #152]	; (8011b20 <HAL_UART_MspInit+0x304>)
 8011a88:	67da      	str	r2, [r3, #124]	; 0x7c
 8011a8a:	4a25      	ldr	r2, [pc, #148]	; (8011b20 <HAL_UART_MspInit+0x304>)
 8011a8c:	687b      	ldr	r3, [r7, #4]
 8011a8e:	6393      	str	r3, [r2, #56]	; 0x38
    hdma_uart8_tx.Instance = DMA2_Stream0;
 8011a90:	4b25      	ldr	r3, [pc, #148]	; (8011b28 <HAL_UART_MspInit+0x30c>)
 8011a92:	4a26      	ldr	r2, [pc, #152]	; (8011b2c <HAL_UART_MspInit+0x310>)
 8011a94:	601a      	str	r2, [r3, #0]
    hdma_uart8_tx.Init.Request = DMA_REQUEST_UART8_TX;
 8011a96:	4b24      	ldr	r3, [pc, #144]	; (8011b28 <HAL_UART_MspInit+0x30c>)
 8011a98:	2252      	movs	r2, #82	; 0x52
 8011a9a:	605a      	str	r2, [r3, #4]
    hdma_uart8_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8011a9c:	4b22      	ldr	r3, [pc, #136]	; (8011b28 <HAL_UART_MspInit+0x30c>)
 8011a9e:	2240      	movs	r2, #64	; 0x40
 8011aa0:	609a      	str	r2, [r3, #8]
    hdma_uart8_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8011aa2:	4b21      	ldr	r3, [pc, #132]	; (8011b28 <HAL_UART_MspInit+0x30c>)
 8011aa4:	2200      	movs	r2, #0
 8011aa6:	60da      	str	r2, [r3, #12]
    hdma_uart8_tx.Init.MemInc = DMA_MINC_ENABLE;
 8011aa8:	4b1f      	ldr	r3, [pc, #124]	; (8011b28 <HAL_UART_MspInit+0x30c>)
 8011aaa:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8011aae:	611a      	str	r2, [r3, #16]
    hdma_uart8_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8011ab0:	4b1d      	ldr	r3, [pc, #116]	; (8011b28 <HAL_UART_MspInit+0x30c>)
 8011ab2:	2200      	movs	r2, #0
 8011ab4:	615a      	str	r2, [r3, #20]
    hdma_uart8_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8011ab6:	4b1c      	ldr	r3, [pc, #112]	; (8011b28 <HAL_UART_MspInit+0x30c>)
 8011ab8:	2200      	movs	r2, #0
 8011aba:	619a      	str	r2, [r3, #24]
    hdma_uart8_tx.Init.Mode = DMA_NORMAL;
 8011abc:	4b1a      	ldr	r3, [pc, #104]	; (8011b28 <HAL_UART_MspInit+0x30c>)
 8011abe:	2200      	movs	r2, #0
 8011ac0:	61da      	str	r2, [r3, #28]
    hdma_uart8_tx.Init.Priority = DMA_PRIORITY_LOW;
 8011ac2:	4b19      	ldr	r3, [pc, #100]	; (8011b28 <HAL_UART_MspInit+0x30c>)
 8011ac4:	2200      	movs	r2, #0
 8011ac6:	621a      	str	r2, [r3, #32]
    hdma_uart8_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 8011ac8:	4b17      	ldr	r3, [pc, #92]	; (8011b28 <HAL_UART_MspInit+0x30c>)
 8011aca:	2200      	movs	r2, #0
 8011acc:	625a      	str	r2, [r3, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_uart8_tx) != HAL_OK)
 8011ace:	4816      	ldr	r0, [pc, #88]	; (8011b28 <HAL_UART_MspInit+0x30c>)
 8011ad0:	f7ef f930 	bl	8000d34 <HAL_DMA_Init>
 8011ad4:	4603      	mov	r3, r0
 8011ad6:	2b00      	cmp	r3, #0
 8011ad8:	d001      	beq.n	8011ade <HAL_UART_MspInit+0x2c2>
      Error_Handler();
 8011ada:	f7ff fa7b 	bl	8010fd4 <Error_Handler>
    __HAL_LINKDMA(huart,hdmatx,hdma_uart8_tx);
 8011ade:	687b      	ldr	r3, [r7, #4]
 8011ae0:	4a11      	ldr	r2, [pc, #68]	; (8011b28 <HAL_UART_MspInit+0x30c>)
 8011ae2:	679a      	str	r2, [r3, #120]	; 0x78
 8011ae4:	4a10      	ldr	r2, [pc, #64]	; (8011b28 <HAL_UART_MspInit+0x30c>)
 8011ae6:	687b      	ldr	r3, [r7, #4]
 8011ae8:	6393      	str	r3, [r2, #56]	; 0x38
    HAL_NVIC_SetPriority(UART8_IRQn, 5, 0);
 8011aea:	2200      	movs	r2, #0
 8011aec:	2105      	movs	r1, #5
 8011aee:	2053      	movs	r0, #83	; 0x53
 8011af0:	f7ee fefa 	bl	80008e8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(UART8_IRQn);
 8011af4:	2053      	movs	r0, #83	; 0x53
 8011af6:	f7ee ff11 	bl	800091c <HAL_NVIC_EnableIRQ>
}
 8011afa:	e173      	b.n	8011de4 <HAL_UART_MspInit+0x5c8>
 8011afc:	40004c00 	.word	0x40004c00
 8011b00:	58024400 	.word	0x58024400
 8011b04:	58020000 	.word	0x58020000
 8011b08:	24063254 	.word	0x24063254
 8011b0c:	40020010 	.word	0x40020010
 8011b10:	240624a4 	.word	0x240624a4
 8011b14:	40020028 	.word	0x40020028
 8011b18:	40007c00 	.word	0x40007c00
 8011b1c:	58022400 	.word	0x58022400
 8011b20:	24062bb8 	.word	0x24062bb8
 8011b24:	400200b8 	.word	0x400200b8
 8011b28:	24062cf4 	.word	0x24062cf4
 8011b2c:	40020410 	.word	0x40020410
  else if(huart->Instance==USART2)
 8011b30:	687b      	ldr	r3, [r7, #4]
 8011b32:	681b      	ldr	r3, [r3, #0]
 8011b34:	4aad      	ldr	r2, [pc, #692]	; (8011dec <HAL_UART_MspInit+0x5d0>)
 8011b36:	4293      	cmp	r3, r2
 8011b38:	f040 80a7 	bne.w	8011c8a <HAL_UART_MspInit+0x46e>
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART2;
 8011b3c:	2302      	movs	r3, #2
 8011b3e:	62bb      	str	r3, [r7, #40]	; 0x28
    PeriphClkInitStruct.Usart234578ClockSelection = RCC_USART234578CLKSOURCE_D2PCLK1;
 8011b40:	2300      	movs	r3, #0
 8011b42:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8011b46:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8011b4a:	4618      	mov	r0, r3
 8011b4c:	f7f3 f9d0 	bl	8004ef0 <HAL_RCCEx_PeriphCLKConfig>
 8011b50:	4603      	mov	r3, r0
 8011b52:	2b00      	cmp	r3, #0
 8011b54:	d001      	beq.n	8011b5a <HAL_UART_MspInit+0x33e>
      Error_Handler();
 8011b56:	f7ff fa3d 	bl	8010fd4 <Error_Handler>
    __HAL_RCC_USART2_CLK_ENABLE();
 8011b5a:	4ba5      	ldr	r3, [pc, #660]	; (8011df0 <HAL_UART_MspInit+0x5d4>)
 8011b5c:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 8011b60:	4aa3      	ldr	r2, [pc, #652]	; (8011df0 <HAL_UART_MspInit+0x5d4>)
 8011b62:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8011b66:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
 8011b6a:	4ba1      	ldr	r3, [pc, #644]	; (8011df0 <HAL_UART_MspInit+0x5d4>)
 8011b6c:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 8011b70:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8011b74:	617b      	str	r3, [r7, #20]
 8011b76:	697b      	ldr	r3, [r7, #20]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8011b78:	4b9d      	ldr	r3, [pc, #628]	; (8011df0 <HAL_UART_MspInit+0x5d4>)
 8011b7a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8011b7e:	4a9c      	ldr	r2, [pc, #624]	; (8011df0 <HAL_UART_MspInit+0x5d4>)
 8011b80:	f043 0301 	orr.w	r3, r3, #1
 8011b84:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 8011b88:	4b99      	ldr	r3, [pc, #612]	; (8011df0 <HAL_UART_MspInit+0x5d4>)
 8011b8a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8011b8e:	f003 0301 	and.w	r3, r3, #1
 8011b92:	613b      	str	r3, [r7, #16]
 8011b94:	693b      	ldr	r3, [r7, #16]
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
 8011b96:	230c      	movs	r3, #12
 8011b98:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8011b9c:	2302      	movs	r3, #2
 8011b9e:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011ba2:	2300      	movs	r3, #0
 8011ba4:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8011ba8:	2300      	movs	r3, #0
 8011baa:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
 8011bae:	2307      	movs	r3, #7
 8011bb0:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8011bb4:	f107 03e4 	add.w	r3, r7, #228	; 0xe4
 8011bb8:	4619      	mov	r1, r3
 8011bba:	488e      	ldr	r0, [pc, #568]	; (8011df4 <HAL_UART_MspInit+0x5d8>)
 8011bbc:	f7f1 fef4 	bl	80039a8 <HAL_GPIO_Init>
    hdma_usart2_tx.Instance = DMA1_Stream3;
 8011bc0:	4b8d      	ldr	r3, [pc, #564]	; (8011df8 <HAL_UART_MspInit+0x5dc>)
 8011bc2:	4a8e      	ldr	r2, [pc, #568]	; (8011dfc <HAL_UART_MspInit+0x5e0>)
 8011bc4:	601a      	str	r2, [r3, #0]
    hdma_usart2_tx.Init.Request = DMA_REQUEST_USART2_TX;
 8011bc6:	4b8c      	ldr	r3, [pc, #560]	; (8011df8 <HAL_UART_MspInit+0x5dc>)
 8011bc8:	222c      	movs	r2, #44	; 0x2c
 8011bca:	605a      	str	r2, [r3, #4]
    hdma_usart2_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8011bcc:	4b8a      	ldr	r3, [pc, #552]	; (8011df8 <HAL_UART_MspInit+0x5dc>)
 8011bce:	2240      	movs	r2, #64	; 0x40
 8011bd0:	609a      	str	r2, [r3, #8]
    hdma_usart2_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8011bd2:	4b89      	ldr	r3, [pc, #548]	; (8011df8 <HAL_UART_MspInit+0x5dc>)
 8011bd4:	2200      	movs	r2, #0
 8011bd6:	60da      	str	r2, [r3, #12]
    hdma_usart2_tx.Init.MemInc = DMA_MINC_ENABLE;
 8011bd8:	4b87      	ldr	r3, [pc, #540]	; (8011df8 <HAL_UART_MspInit+0x5dc>)
 8011bda:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8011bde:	611a      	str	r2, [r3, #16]
    hdma_usart2_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8011be0:	4b85      	ldr	r3, [pc, #532]	; (8011df8 <HAL_UART_MspInit+0x5dc>)
 8011be2:	2200      	movs	r2, #0
 8011be4:	615a      	str	r2, [r3, #20]
    hdma_usart2_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8011be6:	4b84      	ldr	r3, [pc, #528]	; (8011df8 <HAL_UART_MspInit+0x5dc>)
 8011be8:	2200      	movs	r2, #0
 8011bea:	619a      	str	r2, [r3, #24]
    hdma_usart2_tx.Init.Mode = DMA_NORMAL;
 8011bec:	4b82      	ldr	r3, [pc, #520]	; (8011df8 <HAL_UART_MspInit+0x5dc>)
 8011bee:	2200      	movs	r2, #0
 8011bf0:	61da      	str	r2, [r3, #28]
    hdma_usart2_tx.Init.Priority = DMA_PRIORITY_MEDIUM;
 8011bf2:	4b81      	ldr	r3, [pc, #516]	; (8011df8 <HAL_UART_MspInit+0x5dc>)
 8011bf4:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8011bf8:	621a      	str	r2, [r3, #32]
    hdma_usart2_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 8011bfa:	4b7f      	ldr	r3, [pc, #508]	; (8011df8 <HAL_UART_MspInit+0x5dc>)
 8011bfc:	2200      	movs	r2, #0
 8011bfe:	625a      	str	r2, [r3, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_usart2_tx) != HAL_OK)
 8011c00:	487d      	ldr	r0, [pc, #500]	; (8011df8 <HAL_UART_MspInit+0x5dc>)
 8011c02:	f7ef f897 	bl	8000d34 <HAL_DMA_Init>
 8011c06:	4603      	mov	r3, r0
 8011c08:	2b00      	cmp	r3, #0
 8011c0a:	d001      	beq.n	8011c10 <HAL_UART_MspInit+0x3f4>
      Error_Handler();
 8011c0c:	f7ff f9e2 	bl	8010fd4 <Error_Handler>
    __HAL_LINKDMA(huart,hdmatx,hdma_usart2_tx);
 8011c10:	687b      	ldr	r3, [r7, #4]
 8011c12:	4a79      	ldr	r2, [pc, #484]	; (8011df8 <HAL_UART_MspInit+0x5dc>)
 8011c14:	679a      	str	r2, [r3, #120]	; 0x78
 8011c16:	4a78      	ldr	r2, [pc, #480]	; (8011df8 <HAL_UART_MspInit+0x5dc>)
 8011c18:	687b      	ldr	r3, [r7, #4]
 8011c1a:	6393      	str	r3, [r2, #56]	; 0x38
    hdma_usart2_rx.Instance = DMA2_Stream1;
 8011c1c:	4b78      	ldr	r3, [pc, #480]	; (8011e00 <HAL_UART_MspInit+0x5e4>)
 8011c1e:	4a79      	ldr	r2, [pc, #484]	; (8011e04 <HAL_UART_MspInit+0x5e8>)
 8011c20:	601a      	str	r2, [r3, #0]
    hdma_usart2_rx.Init.Request = DMA_REQUEST_USART2_RX;
 8011c22:	4b77      	ldr	r3, [pc, #476]	; (8011e00 <HAL_UART_MspInit+0x5e4>)
 8011c24:	222b      	movs	r2, #43	; 0x2b
 8011c26:	605a      	str	r2, [r3, #4]
    hdma_usart2_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8011c28:	4b75      	ldr	r3, [pc, #468]	; (8011e00 <HAL_UART_MspInit+0x5e4>)
 8011c2a:	2200      	movs	r2, #0
 8011c2c:	609a      	str	r2, [r3, #8]
    hdma_usart2_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 8011c2e:	4b74      	ldr	r3, [pc, #464]	; (8011e00 <HAL_UART_MspInit+0x5e4>)
 8011c30:	2200      	movs	r2, #0
 8011c32:	60da      	str	r2, [r3, #12]
    hdma_usart2_rx.Init.MemInc = DMA_MINC_ENABLE;
 8011c34:	4b72      	ldr	r3, [pc, #456]	; (8011e00 <HAL_UART_MspInit+0x5e4>)
 8011c36:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8011c3a:	611a      	str	r2, [r3, #16]
    hdma_usart2_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8011c3c:	4b70      	ldr	r3, [pc, #448]	; (8011e00 <HAL_UART_MspInit+0x5e4>)
 8011c3e:	2200      	movs	r2, #0
 8011c40:	615a      	str	r2, [r3, #20]
    hdma_usart2_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8011c42:	4b6f      	ldr	r3, [pc, #444]	; (8011e00 <HAL_UART_MspInit+0x5e4>)
 8011c44:	2200      	movs	r2, #0
 8011c46:	619a      	str	r2, [r3, #24]
    hdma_usart2_rx.Init.Mode = DMA_CIRCULAR;
 8011c48:	4b6d      	ldr	r3, [pc, #436]	; (8011e00 <HAL_UART_MspInit+0x5e4>)
 8011c4a:	f44f 7280 	mov.w	r2, #256	; 0x100
 8011c4e:	61da      	str	r2, [r3, #28]
    hdma_usart2_rx.Init.Priority = DMA_PRIORITY_LOW;
 8011c50:	4b6b      	ldr	r3, [pc, #428]	; (8011e00 <HAL_UART_MspInit+0x5e4>)
 8011c52:	2200      	movs	r2, #0
 8011c54:	621a      	str	r2, [r3, #32]
    hdma_usart2_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 8011c56:	4b6a      	ldr	r3, [pc, #424]	; (8011e00 <HAL_UART_MspInit+0x5e4>)
 8011c58:	2200      	movs	r2, #0
 8011c5a:	625a      	str	r2, [r3, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_usart2_rx) != HAL_OK)
 8011c5c:	4868      	ldr	r0, [pc, #416]	; (8011e00 <HAL_UART_MspInit+0x5e4>)
 8011c5e:	f7ef f869 	bl	8000d34 <HAL_DMA_Init>
 8011c62:	4603      	mov	r3, r0
 8011c64:	2b00      	cmp	r3, #0
 8011c66:	d001      	beq.n	8011c6c <HAL_UART_MspInit+0x450>
      Error_Handler();
 8011c68:	f7ff f9b4 	bl	8010fd4 <Error_Handler>
    __HAL_LINKDMA(huart,hdmarx,hdma_usart2_rx);
 8011c6c:	687b      	ldr	r3, [r7, #4]
 8011c6e:	4a64      	ldr	r2, [pc, #400]	; (8011e00 <HAL_UART_MspInit+0x5e4>)
 8011c70:	67da      	str	r2, [r3, #124]	; 0x7c
 8011c72:	4a63      	ldr	r2, [pc, #396]	; (8011e00 <HAL_UART_MspInit+0x5e4>)
 8011c74:	687b      	ldr	r3, [r7, #4]
 8011c76:	6393      	str	r3, [r2, #56]	; 0x38
    HAL_NVIC_SetPriority(USART2_IRQn, 5, 0);
 8011c78:	2200      	movs	r2, #0
 8011c7a:	2105      	movs	r1, #5
 8011c7c:	2026      	movs	r0, #38	; 0x26
 8011c7e:	f7ee fe33 	bl	80008e8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART2_IRQn);
 8011c82:	2026      	movs	r0, #38	; 0x26
 8011c84:	f7ee fe4a 	bl	800091c <HAL_NVIC_EnableIRQ>
}
 8011c88:	e0ac      	b.n	8011de4 <HAL_UART_MspInit+0x5c8>
  else if(huart->Instance==USART3)
 8011c8a:	687b      	ldr	r3, [r7, #4]
 8011c8c:	681b      	ldr	r3, [r3, #0]
 8011c8e:	4a5e      	ldr	r2, [pc, #376]	; (8011e08 <HAL_UART_MspInit+0x5ec>)
 8011c90:	4293      	cmp	r3, r2
 8011c92:	f040 80a7 	bne.w	8011de4 <HAL_UART_MspInit+0x5c8>
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART3;
 8011c96:	2302      	movs	r3, #2
 8011c98:	62bb      	str	r3, [r7, #40]	; 0x28
    PeriphClkInitStruct.Usart234578ClockSelection = RCC_USART234578CLKSOURCE_D2PCLK1;
 8011c9a:	2300      	movs	r3, #0
 8011c9c:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8011ca0:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8011ca4:	4618      	mov	r0, r3
 8011ca6:	f7f3 f923 	bl	8004ef0 <HAL_RCCEx_PeriphCLKConfig>
 8011caa:	4603      	mov	r3, r0
 8011cac:	2b00      	cmp	r3, #0
 8011cae:	d001      	beq.n	8011cb4 <HAL_UART_MspInit+0x498>
      Error_Handler();
 8011cb0:	f7ff f990 	bl	8010fd4 <Error_Handler>
    __HAL_RCC_USART3_CLK_ENABLE();
 8011cb4:	4b4e      	ldr	r3, [pc, #312]	; (8011df0 <HAL_UART_MspInit+0x5d4>)
 8011cb6:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 8011cba:	4a4d      	ldr	r2, [pc, #308]	; (8011df0 <HAL_UART_MspInit+0x5d4>)
 8011cbc:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8011cc0:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
 8011cc4:	4b4a      	ldr	r3, [pc, #296]	; (8011df0 <HAL_UART_MspInit+0x5d4>)
 8011cc6:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 8011cca:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8011cce:	60fb      	str	r3, [r7, #12]
 8011cd0:	68fb      	ldr	r3, [r7, #12]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8011cd2:	4b47      	ldr	r3, [pc, #284]	; (8011df0 <HAL_UART_MspInit+0x5d4>)
 8011cd4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8011cd8:	4a45      	ldr	r2, [pc, #276]	; (8011df0 <HAL_UART_MspInit+0x5d4>)
 8011cda:	f043 0308 	orr.w	r3, r3, #8
 8011cde:	f8c2 30e0 	str.w	r3, [r2, #224]	; 0xe0
 8011ce2:	4b43      	ldr	r3, [pc, #268]	; (8011df0 <HAL_UART_MspInit+0x5d4>)
 8011ce4:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8011ce8:	f003 0308 	and.w	r3, r3, #8
 8011cec:	60bb      	str	r3, [r7, #8]
 8011cee:	68bb      	ldr	r3, [r7, #8]
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;
 8011cf0:	f44f 7340 	mov.w	r3, #768	; 0x300
 8011cf4:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8011cf8:	2302      	movs	r3, #2
 8011cfa:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8011cfe:	2300      	movs	r3, #0
 8011d00:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8011d04:	2300      	movs	r3, #0
 8011d06:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
 8011d0a:	2307      	movs	r3, #7
 8011d0c:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8011d10:	f107 03e4 	add.w	r3, r7, #228	; 0xe4
 8011d14:	4619      	mov	r1, r3
 8011d16:	483d      	ldr	r0, [pc, #244]	; (8011e0c <HAL_UART_MspInit+0x5f0>)
 8011d18:	f7f1 fe46 	bl	80039a8 <HAL_GPIO_Init>
    hdma_usart3_rx.Instance = DMA1_Stream2;
 8011d1c:	4b3c      	ldr	r3, [pc, #240]	; (8011e10 <HAL_UART_MspInit+0x5f4>)
 8011d1e:	4a3d      	ldr	r2, [pc, #244]	; (8011e14 <HAL_UART_MspInit+0x5f8>)
 8011d20:	601a      	str	r2, [r3, #0]
    hdma_usart3_rx.Init.Request = DMA_REQUEST_USART3_RX;
 8011d22:	4b3b      	ldr	r3, [pc, #236]	; (8011e10 <HAL_UART_MspInit+0x5f4>)
 8011d24:	222d      	movs	r2, #45	; 0x2d
 8011d26:	605a      	str	r2, [r3, #4]
    hdma_usart3_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 8011d28:	4b39      	ldr	r3, [pc, #228]	; (8011e10 <HAL_UART_MspInit+0x5f4>)
 8011d2a:	2200      	movs	r2, #0
 8011d2c:	609a      	str	r2, [r3, #8]
    hdma_usart3_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 8011d2e:	4b38      	ldr	r3, [pc, #224]	; (8011e10 <HAL_UART_MspInit+0x5f4>)
 8011d30:	2200      	movs	r2, #0
 8011d32:	60da      	str	r2, [r3, #12]
    hdma_usart3_rx.Init.MemInc = DMA_MINC_ENABLE;
 8011d34:	4b36      	ldr	r3, [pc, #216]	; (8011e10 <HAL_UART_MspInit+0x5f4>)
 8011d36:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8011d3a:	611a      	str	r2, [r3, #16]
    hdma_usart3_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8011d3c:	4b34      	ldr	r3, [pc, #208]	; (8011e10 <HAL_UART_MspInit+0x5f4>)
 8011d3e:	2200      	movs	r2, #0
 8011d40:	615a      	str	r2, [r3, #20]
    hdma_usart3_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8011d42:	4b33      	ldr	r3, [pc, #204]	; (8011e10 <HAL_UART_MspInit+0x5f4>)
 8011d44:	2200      	movs	r2, #0
 8011d46:	619a      	str	r2, [r3, #24]
    hdma_usart3_rx.Init.Mode = DMA_CIRCULAR;
 8011d48:	4b31      	ldr	r3, [pc, #196]	; (8011e10 <HAL_UART_MspInit+0x5f4>)
 8011d4a:	f44f 7280 	mov.w	r2, #256	; 0x100
 8011d4e:	61da      	str	r2, [r3, #28]
    hdma_usart3_rx.Init.Priority = DMA_PRIORITY_MEDIUM;
 8011d50:	4b2f      	ldr	r3, [pc, #188]	; (8011e10 <HAL_UART_MspInit+0x5f4>)
 8011d52:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8011d56:	621a      	str	r2, [r3, #32]
    hdma_usart3_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 8011d58:	4b2d      	ldr	r3, [pc, #180]	; (8011e10 <HAL_UART_MspInit+0x5f4>)
 8011d5a:	2200      	movs	r2, #0
 8011d5c:	625a      	str	r2, [r3, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_usart3_rx) != HAL_OK)
 8011d5e:	482c      	ldr	r0, [pc, #176]	; (8011e10 <HAL_UART_MspInit+0x5f4>)
 8011d60:	f7ee ffe8 	bl	8000d34 <HAL_DMA_Init>
 8011d64:	4603      	mov	r3, r0
 8011d66:	2b00      	cmp	r3, #0
 8011d68:	d001      	beq.n	8011d6e <HAL_UART_MspInit+0x552>
      Error_Handler();
 8011d6a:	f7ff f933 	bl	8010fd4 <Error_Handler>
    __HAL_LINKDMA(huart,hdmarx,hdma_usart3_rx);
 8011d6e:	687b      	ldr	r3, [r7, #4]
 8011d70:	4a27      	ldr	r2, [pc, #156]	; (8011e10 <HAL_UART_MspInit+0x5f4>)
 8011d72:	67da      	str	r2, [r3, #124]	; 0x7c
 8011d74:	4a26      	ldr	r2, [pc, #152]	; (8011e10 <HAL_UART_MspInit+0x5f4>)
 8011d76:	687b      	ldr	r3, [r7, #4]
 8011d78:	6393      	str	r3, [r2, #56]	; 0x38
    hdma_usart3_tx.Instance = DMA1_Stream6;
 8011d7a:	4b27      	ldr	r3, [pc, #156]	; (8011e18 <HAL_UART_MspInit+0x5fc>)
 8011d7c:	4a27      	ldr	r2, [pc, #156]	; (8011e1c <HAL_UART_MspInit+0x600>)
 8011d7e:	601a      	str	r2, [r3, #0]
    hdma_usart3_tx.Init.Request = DMA_REQUEST_USART3_TX;
 8011d80:	4b25      	ldr	r3, [pc, #148]	; (8011e18 <HAL_UART_MspInit+0x5fc>)
 8011d82:	222e      	movs	r2, #46	; 0x2e
 8011d84:	605a      	str	r2, [r3, #4]
    hdma_usart3_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8011d86:	4b24      	ldr	r3, [pc, #144]	; (8011e18 <HAL_UART_MspInit+0x5fc>)
 8011d88:	2240      	movs	r2, #64	; 0x40
 8011d8a:	609a      	str	r2, [r3, #8]
    hdma_usart3_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8011d8c:	4b22      	ldr	r3, [pc, #136]	; (8011e18 <HAL_UART_MspInit+0x5fc>)
 8011d8e:	2200      	movs	r2, #0
 8011d90:	60da      	str	r2, [r3, #12]
    hdma_usart3_tx.Init.MemInc = DMA_MINC_ENABLE;
 8011d92:	4b21      	ldr	r3, [pc, #132]	; (8011e18 <HAL_UART_MspInit+0x5fc>)
 8011d94:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8011d98:	611a      	str	r2, [r3, #16]
    hdma_usart3_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8011d9a:	4b1f      	ldr	r3, [pc, #124]	; (8011e18 <HAL_UART_MspInit+0x5fc>)
 8011d9c:	2200      	movs	r2, #0
 8011d9e:	615a      	str	r2, [r3, #20]
    hdma_usart3_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8011da0:	4b1d      	ldr	r3, [pc, #116]	; (8011e18 <HAL_UART_MspInit+0x5fc>)
 8011da2:	2200      	movs	r2, #0
 8011da4:	619a      	str	r2, [r3, #24]
    hdma_usart3_tx.Init.Mode = DMA_NORMAL;
 8011da6:	4b1c      	ldr	r3, [pc, #112]	; (8011e18 <HAL_UART_MspInit+0x5fc>)
 8011da8:	2200      	movs	r2, #0
 8011daa:	61da      	str	r2, [r3, #28]
    hdma_usart3_tx.Init.Priority = DMA_PRIORITY_LOW;
 8011dac:	4b1a      	ldr	r3, [pc, #104]	; (8011e18 <HAL_UART_MspInit+0x5fc>)
 8011dae:	2200      	movs	r2, #0
 8011db0:	621a      	str	r2, [r3, #32]
    hdma_usart3_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 8011db2:	4b19      	ldr	r3, [pc, #100]	; (8011e18 <HAL_UART_MspInit+0x5fc>)
 8011db4:	2200      	movs	r2, #0
 8011db6:	625a      	str	r2, [r3, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_usart3_tx) != HAL_OK)
 8011db8:	4817      	ldr	r0, [pc, #92]	; (8011e18 <HAL_UART_MspInit+0x5fc>)
 8011dba:	f7ee ffbb 	bl	8000d34 <HAL_DMA_Init>
 8011dbe:	4603      	mov	r3, r0
 8011dc0:	2b00      	cmp	r3, #0
 8011dc2:	d001      	beq.n	8011dc8 <HAL_UART_MspInit+0x5ac>
      Error_Handler();
 8011dc4:	f7ff f906 	bl	8010fd4 <Error_Handler>
    __HAL_LINKDMA(huart,hdmatx,hdma_usart3_tx);
 8011dc8:	687b      	ldr	r3, [r7, #4]
 8011dca:	4a13      	ldr	r2, [pc, #76]	; (8011e18 <HAL_UART_MspInit+0x5fc>)
 8011dcc:	679a      	str	r2, [r3, #120]	; 0x78
 8011dce:	4a12      	ldr	r2, [pc, #72]	; (8011e18 <HAL_UART_MspInit+0x5fc>)
 8011dd0:	687b      	ldr	r3, [r7, #4]
 8011dd2:	6393      	str	r3, [r2, #56]	; 0x38
    HAL_NVIC_SetPriority(USART3_IRQn, 5, 0);
 8011dd4:	2200      	movs	r2, #0
 8011dd6:	2105      	movs	r1, #5
 8011dd8:	2027      	movs	r0, #39	; 0x27
 8011dda:	f7ee fd85 	bl	80008e8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART3_IRQn);
 8011dde:	2027      	movs	r0, #39	; 0x27
 8011de0:	f7ee fd9c 	bl	800091c <HAL_NVIC_EnableIRQ>
}
 8011de4:	bf00      	nop
 8011de6:	37f8      	adds	r7, #248	; 0xf8
 8011de8:	46bd      	mov	sp, r7
 8011dea:	bd80      	pop	{r7, pc}
 8011dec:	40004400 	.word	0x40004400
 8011df0:	58024400 	.word	0x58024400
 8011df4:	58020000 	.word	0x58020000
 8011df8:	24062b40 	.word	0x24062b40
 8011dfc:	40020058 	.word	0x40020058
 8011e00:	24062520 	.word	0x24062520
 8011e04:	40020428 	.word	0x40020428
 8011e08:	40004800 	.word	0x40004800
 8011e0c:	58020c00 	.word	0x58020c00
 8011e10:	240626f8 	.word	0x240626f8
 8011e14:	40020040 	.word	0x40020040
 8011e18:	240629a4 	.word	0x240629a4
 8011e1c:	400200a0 	.word	0x400200a0

08011e20 <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig().
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8011e20:	b580      	push	{r7, lr}
 8011e22:	b090      	sub	sp, #64	; 0x40
 8011e24:	af00      	add	r7, sp, #0
 8011e26:	6078      	str	r0, [r7, #4]
  uint32_t              uwTimclock, uwAPB1Prescaler;

  uint32_t              uwPrescalerValue;
  uint32_t              pFLatency;
/*Configure the TIM6 IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8011e28:	687b      	ldr	r3, [r7, #4]
 8011e2a:	2b0f      	cmp	r3, #15
 8011e2c:	d827      	bhi.n	8011e7e <HAL_InitTick+0x5e>
  {
  HAL_NVIC_SetPriority(TIM6_DAC_IRQn, TickPriority ,0U);
 8011e2e:	2200      	movs	r2, #0
 8011e30:	6879      	ldr	r1, [r7, #4]
 8011e32:	2036      	movs	r0, #54	; 0x36
 8011e34:	f7ee fd58 	bl	80008e8 <HAL_NVIC_SetPriority>

  /* Enable the TIM6 global Interrupt */
  HAL_NVIC_EnableIRQ(TIM6_DAC_IRQn);
 8011e38:	2036      	movs	r0, #54	; 0x36
 8011e3a:	f7ee fd6f 	bl	800091c <HAL_NVIC_EnableIRQ>
    uwTickPrio = TickPriority;
 8011e3e:	4a29      	ldr	r2, [pc, #164]	; (8011ee4 <HAL_InitTick+0xc4>)
 8011e40:	687b      	ldr	r3, [r7, #4]
 8011e42:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Enable TIM6 clock */
  __HAL_RCC_TIM6_CLK_ENABLE();
 8011e44:	4b28      	ldr	r3, [pc, #160]	; (8011ee8 <HAL_InitTick+0xc8>)
 8011e46:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 8011e4a:	4a27      	ldr	r2, [pc, #156]	; (8011ee8 <HAL_InitTick+0xc8>)
 8011e4c:	f043 0310 	orr.w	r3, r3, #16
 8011e50:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
 8011e54:	4b24      	ldr	r3, [pc, #144]	; (8011ee8 <HAL_InitTick+0xc8>)
 8011e56:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 8011e5a:	f003 0310 	and.w	r3, r3, #16
 8011e5e:	60fb      	str	r3, [r7, #12]
 8011e60:	68fb      	ldr	r3, [r7, #12]

  /* Get clock configuration */
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8011e62:	f107 0210 	add.w	r2, r7, #16
 8011e66:	f107 0314 	add.w	r3, r7, #20
 8011e6a:	4611      	mov	r1, r2
 8011e6c:	4618      	mov	r0, r3
 8011e6e:	f7f2 fffd 	bl	8004e6c <HAL_RCC_GetClockConfig>

  /* Get APB1 prescaler */
  uwAPB1Prescaler = clkconfig.APB1CLKDivider;
 8011e72:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011e74:	63bb      	str	r3, [r7, #56]	; 0x38
  /* Compute TIM6 clock */
  if (uwAPB1Prescaler == RCC_HCLK_DIV1)
 8011e76:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8011e78:	2b00      	cmp	r3, #0
 8011e7a:	d106      	bne.n	8011e8a <HAL_InitTick+0x6a>
 8011e7c:	e001      	b.n	8011e82 <HAL_InitTick+0x62>
    return HAL_ERROR;
 8011e7e:	2301      	movs	r3, #1
 8011e80:	e02b      	b.n	8011eda <HAL_InitTick+0xba>
  {
    uwTimclock = HAL_RCC_GetPCLK1Freq();
 8011e82:	f7f2 ffc7 	bl	8004e14 <HAL_RCC_GetPCLK1Freq>
 8011e86:	63f8      	str	r0, [r7, #60]	; 0x3c
 8011e88:	e004      	b.n	8011e94 <HAL_InitTick+0x74>
  }
  else
  {
    uwTimclock = 2UL * HAL_RCC_GetPCLK1Freq();
 8011e8a:	f7f2 ffc3 	bl	8004e14 <HAL_RCC_GetPCLK1Freq>
 8011e8e:	4603      	mov	r3, r0
 8011e90:	005b      	lsls	r3, r3, #1
 8011e92:	63fb      	str	r3, [r7, #60]	; 0x3c
  }

  /* Compute the prescaler value to have TIM6 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 8011e94:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8011e96:	4a15      	ldr	r2, [pc, #84]	; (8011eec <HAL_InitTick+0xcc>)
 8011e98:	fba2 2303 	umull	r2, r3, r2, r3
 8011e9c:	0c9b      	lsrs	r3, r3, #18
 8011e9e:	3b01      	subs	r3, #1
 8011ea0:	637b      	str	r3, [r7, #52]	; 0x34

  /* Initialize TIM6 */
  htim6.Instance = TIM6;
 8011ea2:	4b13      	ldr	r3, [pc, #76]	; (8011ef0 <HAL_InitTick+0xd0>)
 8011ea4:	4a13      	ldr	r2, [pc, #76]	; (8011ef4 <HAL_InitTick+0xd4>)
 8011ea6:	601a      	str	r2, [r3, #0]
  + Period = [(TIM6CLK/1000) - 1]. to have a (1/1000) s time base.
  + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim6.Init.Period = (1000000U / 1000U) - 1U;
 8011ea8:	4b11      	ldr	r3, [pc, #68]	; (8011ef0 <HAL_InitTick+0xd0>)
 8011eaa:	f240 32e7 	movw	r2, #999	; 0x3e7
 8011eae:	60da      	str	r2, [r3, #12]
  htim6.Init.Prescaler = uwPrescalerValue;
 8011eb0:	4a0f      	ldr	r2, [pc, #60]	; (8011ef0 <HAL_InitTick+0xd0>)
 8011eb2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011eb4:	6053      	str	r3, [r2, #4]
  htim6.Init.ClockDivision = 0;
 8011eb6:	4b0e      	ldr	r3, [pc, #56]	; (8011ef0 <HAL_InitTick+0xd0>)
 8011eb8:	2200      	movs	r2, #0
 8011eba:	611a      	str	r2, [r3, #16]
  htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
 8011ebc:	4b0c      	ldr	r3, [pc, #48]	; (8011ef0 <HAL_InitTick+0xd0>)
 8011ebe:	2200      	movs	r2, #0
 8011ec0:	609a      	str	r2, [r3, #8]

  if(HAL_TIM_Base_Init(&htim6) == HAL_OK)
 8011ec2:	480b      	ldr	r0, [pc, #44]	; (8011ef0 <HAL_InitTick+0xd0>)
 8011ec4:	f7f5 f855 	bl	8006f72 <HAL_TIM_Base_Init>
 8011ec8:	4603      	mov	r3, r0
 8011eca:	2b00      	cmp	r3, #0
 8011ecc:	d104      	bne.n	8011ed8 <HAL_InitTick+0xb8>
  {
    /* Start the TIM time Base generation in interrupt mode */
    return HAL_TIM_Base_Start_IT(&htim6);
 8011ece:	4808      	ldr	r0, [pc, #32]	; (8011ef0 <HAL_InitTick+0xd0>)
 8011ed0:	f7f5 f8a6 	bl	8007020 <HAL_TIM_Base_Start_IT>
 8011ed4:	4603      	mov	r3, r0
 8011ed6:	e000      	b.n	8011eda <HAL_InitTick+0xba>
  }

  /* Return function status */
  return HAL_ERROR;
 8011ed8:	2301      	movs	r3, #1
}
 8011eda:	4618      	mov	r0, r3
 8011edc:	3740      	adds	r7, #64	; 0x40
 8011ede:	46bd      	mov	sp, r7
 8011ee0:	bd80      	pop	{r7, pc}
 8011ee2:	bf00      	nop
 8011ee4:	24000000 	.word	0x24000000
 8011ee8:	58024400 	.word	0x58024400
 8011eec:	431bde83 	.word	0x431bde83
 8011ef0:	240632cc 	.word	0x240632cc
 8011ef4:	40001000 	.word	0x40001000

08011ef8 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 8011ef8:	b480      	push	{r7}
 8011efa:	af00      	add	r7, sp, #0

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 8011efc:	bf00      	nop
 8011efe:	46bd      	mov	sp, r7
 8011f00:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011f04:	4770      	bx	lr

08011f06 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8011f06:	b480      	push	{r7}
 8011f08:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8011f0a:	e7fe      	b.n	8011f0a <HardFault_Handler+0x4>

08011f0c <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8011f0c:	b480      	push	{r7}
 8011f0e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8011f10:	e7fe      	b.n	8011f10 <MemManage_Handler+0x4>

08011f12 <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 8011f12:	b480      	push	{r7}
 8011f14:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8011f16:	e7fe      	b.n	8011f16 <BusFault_Handler+0x4>

08011f18 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8011f18:	b480      	push	{r7}
 8011f1a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8011f1c:	e7fe      	b.n	8011f1c <UsageFault_Handler+0x4>

08011f1e <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 8011f1e:	b480      	push	{r7}
 8011f20:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 8011f22:	bf00      	nop
 8011f24:	46bd      	mov	sp, r7
 8011f26:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011f2a:	4770      	bx	lr

08011f2c <EXTI0_IRQHandler>:

/**
  * @brief This function handles EXTI line0 interrupt.
  */
void EXTI0_IRQHandler(void)
{
 8011f2c:	b580      	push	{r7, lr}
 8011f2e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI0_IRQn 0 */

  /* USER CODE END EXTI0_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_0);
 8011f30:	2001      	movs	r0, #1
 8011f32:	f7f1 ff1a 	bl	8003d6a <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI0_IRQn 1 */

  /* USER CODE END EXTI0_IRQn 1 */
}
 8011f36:	bf00      	nop
 8011f38:	bd80      	pop	{r7, pc}
	...

08011f3c <DMA1_Stream0_IRQHandler>:

/**
  * @brief This function handles DMA1 stream0 global interrupt.
  */
void DMA1_Stream0_IRQHandler(void)
{
 8011f3c:	b580      	push	{r7, lr}
 8011f3e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA1_Stream0_IRQn 0 */

  /* USER CODE END DMA1_Stream0_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_uart4_tx);
 8011f40:	4802      	ldr	r0, [pc, #8]	; (8011f4c <DMA1_Stream0_IRQHandler+0x10>)
 8011f42:	f7f0 fa1f 	bl	8002384 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Stream0_IRQn 1 */

  /* USER CODE END DMA1_Stream0_IRQn 1 */
}
 8011f46:	bf00      	nop
 8011f48:	bd80      	pop	{r7, pc}
 8011f4a:	bf00      	nop
 8011f4c:	24063254 	.word	0x24063254

08011f50 <DMA1_Stream1_IRQHandler>:

/**
  * @brief This function handles DMA1 stream1 global interrupt.
  */
void DMA1_Stream1_IRQHandler(void)
{
 8011f50:	b580      	push	{r7, lr}
 8011f52:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA1_Stream1_IRQn 0 */

  /* USER CODE END DMA1_Stream1_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_uart4_rx);
 8011f54:	4802      	ldr	r0, [pc, #8]	; (8011f60 <DMA1_Stream1_IRQHandler+0x10>)
 8011f56:	f7f0 fa15 	bl	8002384 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Stream1_IRQn 1 */

  /* USER CODE END DMA1_Stream1_IRQn 1 */
}
 8011f5a:	bf00      	nop
 8011f5c:	bd80      	pop	{r7, pc}
 8011f5e:	bf00      	nop
 8011f60:	240624a4 	.word	0x240624a4

08011f64 <DMA1_Stream2_IRQHandler>:

/**
  * @brief This function handles DMA1 stream2 global interrupt.
  */
void DMA1_Stream2_IRQHandler(void)
{
 8011f64:	b580      	push	{r7, lr}
 8011f66:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA1_Stream2_IRQn 0 */

  /* USER CODE END DMA1_Stream2_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_usart3_rx);
 8011f68:	4802      	ldr	r0, [pc, #8]	; (8011f74 <DMA1_Stream2_IRQHandler+0x10>)
 8011f6a:	f7f0 fa0b 	bl	8002384 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Stream2_IRQn 1 */

  /* USER CODE END DMA1_Stream2_IRQn 1 */
}
 8011f6e:	bf00      	nop
 8011f70:	bd80      	pop	{r7, pc}
 8011f72:	bf00      	nop
 8011f74:	240626f8 	.word	0x240626f8

08011f78 <DMA1_Stream3_IRQHandler>:

/**
  * @brief This function handles DMA1 stream3 global interrupt.
  */
void DMA1_Stream3_IRQHandler(void)
{
 8011f78:	b580      	push	{r7, lr}
 8011f7a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA1_Stream3_IRQn 0 */

  /* USER CODE END DMA1_Stream3_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_usart2_tx);
 8011f7c:	4802      	ldr	r0, [pc, #8]	; (8011f88 <DMA1_Stream3_IRQHandler+0x10>)
 8011f7e:	f7f0 fa01 	bl	8002384 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Stream3_IRQn 1 */

  /* USER CODE END DMA1_Stream3_IRQn 1 */
}
 8011f82:	bf00      	nop
 8011f84:	bd80      	pop	{r7, pc}
 8011f86:	bf00      	nop
 8011f88:	24062b40 	.word	0x24062b40

08011f8c <DMA1_Stream4_IRQHandler>:

/**
  * @brief This function handles DMA1 stream4 global interrupt.
  */
void DMA1_Stream4_IRQHandler(void)
{
 8011f8c:	b580      	push	{r7, lr}
 8011f8e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA1_Stream4_IRQn 0 */

  /* USER CODE END DMA1_Stream4_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_spi2_rx);
 8011f90:	4802      	ldr	r0, [pc, #8]	; (8011f9c <DMA1_Stream4_IRQHandler+0x10>)
 8011f92:	f7f0 f9f7 	bl	8002384 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Stream4_IRQn 1 */

  /* USER CODE END DMA1_Stream4_IRQn 1 */
}
 8011f96:	bf00      	nop
 8011f98:	bd80      	pop	{r7, pc}
 8011f9a:	bf00      	nop
 8011f9c:	24062824 	.word	0x24062824

08011fa0 <DMA1_Stream5_IRQHandler>:

/**
  * @brief This function handles DMA1 stream5 global interrupt.
  */
void DMA1_Stream5_IRQHandler(void)
{
 8011fa0:	b580      	push	{r7, lr}
 8011fa2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA1_Stream5_IRQn 0 */

  /* USER CODE END DMA1_Stream5_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_spi2_tx);
 8011fa4:	4802      	ldr	r0, [pc, #8]	; (8011fb0 <DMA1_Stream5_IRQHandler+0x10>)
 8011fa6:	f7f0 f9ed 	bl	8002384 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Stream5_IRQn 1 */

  /* USER CODE END DMA1_Stream5_IRQn 1 */
}
 8011faa:	bf00      	nop
 8011fac:	bd80      	pop	{r7, pc}
 8011fae:	bf00      	nop
 8011fb0:	240631dc 	.word	0x240631dc

08011fb4 <DMA1_Stream6_IRQHandler>:

/**
  * @brief This function handles DMA1 stream6 global interrupt.
  */
void DMA1_Stream6_IRQHandler(void)
{
 8011fb4:	b580      	push	{r7, lr}
 8011fb6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA1_Stream6_IRQn 0 */

  /* USER CODE END DMA1_Stream6_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_usart3_tx);
 8011fb8:	4802      	ldr	r0, [pc, #8]	; (8011fc4 <DMA1_Stream6_IRQHandler+0x10>)
 8011fba:	f7f0 f9e3 	bl	8002384 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Stream6_IRQn 1 */

  /* USER CODE END DMA1_Stream6_IRQn 1 */
}
 8011fbe:	bf00      	nop
 8011fc0:	bd80      	pop	{r7, pc}
 8011fc2:	bf00      	nop
 8011fc4:	240629a4 	.word	0x240629a4

08011fc8 <SPI2_IRQHandler>:

/**
  * @brief This function handles SPI2 global interrupt.
  */
void SPI2_IRQHandler(void)
{
 8011fc8:	b580      	push	{r7, lr}
 8011fca:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SPI2_IRQn 0 */

  /* USER CODE END SPI2_IRQn 0 */
  HAL_SPI_IRQHandler(&hspi2);
 8011fcc:	4802      	ldr	r0, [pc, #8]	; (8011fd8 <SPI2_IRQHandler+0x10>)
 8011fce:	f7f4 fd07 	bl	80069e0 <HAL_SPI_IRQHandler>
  /* USER CODE BEGIN SPI2_IRQn 1 */

  /* USER CODE END SPI2_IRQn 1 */
}
 8011fd2:	bf00      	nop
 8011fd4:	bd80      	pop	{r7, pc}
 8011fd6:	bf00      	nop
 8011fd8:	2406259c 	.word	0x2406259c

08011fdc <USART2_IRQHandler>:

/**
  * @brief This function handles USART2 global interrupt.
  */
void USART2_IRQHandler(void)
{
 8011fdc:	b580      	push	{r7, lr}
 8011fde:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN USART2_IRQn 0 */

  /* USER CODE END USART2_IRQn 0 */
  HAL_UART_IRQHandler(&huart2);
 8011fe0:	4802      	ldr	r0, [pc, #8]	; (8011fec <USART2_IRQHandler+0x10>)
 8011fe2:	f7f6 fbfd 	bl	80087e0 <HAL_UART_IRQHandler>
  /* USER CODE BEGIN USART2_IRQn 1 */

  /* USER CODE END USART2_IRQn 1 */
}
 8011fe6:	bf00      	nop
 8011fe8:	bd80      	pop	{r7, pc}
 8011fea:	bf00      	nop
 8011fec:	24063020 	.word	0x24063020

08011ff0 <USART3_IRQHandler>:

/**
  * @brief This function handles USART3 global interrupt.
  */
void USART3_IRQHandler(void)
{
 8011ff0:	b580      	push	{r7, lr}
 8011ff2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN USART3_IRQn 0 */

  /* USER CODE END USART3_IRQn 0 */
  HAL_UART_IRQHandler(&huart3);
 8011ff4:	4802      	ldr	r0, [pc, #8]	; (8012000 <USART3_IRQHandler+0x10>)
 8011ff6:	f7f6 fbf3 	bl	80087e0 <HAL_UART_IRQHandler>
  /* USER CODE BEGIN USART3_IRQn 1 */

  /* USER CODE END USART3_IRQn 1 */
}
 8011ffa:	bf00      	nop
 8011ffc:	bd80      	pop	{r7, pc}
 8011ffe:	bf00      	nop
 8012000:	24062770 	.word	0x24062770

08012004 <EXTI15_10_IRQHandler>:

/**
  * @brief This function handles EXTI line[15:10] interrupts.
  */
void EXTI15_10_IRQHandler(void)
{
 8012004:	b580      	push	{r7, lr}
 8012006:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI15_10_IRQn 0 */

  /* USER CODE END EXTI15_10_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_10);
 8012008:	f44f 6080 	mov.w	r0, #1024	; 0x400
 801200c:	f7f1 fead 	bl	8003d6a <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_11);
 8012010:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8012014:	f7f1 fea9 	bl	8003d6a <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_12);
 8012018:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 801201c:	f7f1 fea5 	bl	8003d6a <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_13);
 8012020:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8012024:	f7f1 fea1 	bl	8003d6a <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_14);
 8012028:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 801202c:	f7f1 fe9d 	bl	8003d6a <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_15);
 8012030:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8012034:	f7f1 fe99 	bl	8003d6a <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI15_10_IRQn 1 */

  /* USER CODE END EXTI15_10_IRQn 1 */
}
 8012038:	bf00      	nop
 801203a:	bd80      	pop	{r7, pc}

0801203c <DMA1_Stream7_IRQHandler>:

/**
  * @brief This function handles DMA1 stream7 global interrupt.
  */
void DMA1_Stream7_IRQHandler(void)
{
 801203c:	b580      	push	{r7, lr}
 801203e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA1_Stream7_IRQn 0 */

  /* USER CODE END DMA1_Stream7_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_uart8_rx);
 8012040:	4802      	ldr	r0, [pc, #8]	; (801204c <DMA1_Stream7_IRQHandler+0x10>)
 8012042:	f7f0 f99f 	bl	8002384 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Stream7_IRQn 1 */

  /* USER CODE END DMA1_Stream7_IRQn 1 */
}
 8012046:	bf00      	nop
 8012048:	bd80      	pop	{r7, pc}
 801204a:	bf00      	nop
 801204c:	24062bb8 	.word	0x24062bb8

08012050 <SPI3_IRQHandler>:

/**
  * @brief This function handles SPI3 global interrupt.
  */
void SPI3_IRQHandler(void)
{
 8012050:	b580      	push	{r7, lr}
 8012052:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SPI3_IRQn 0 */

  /* USER CODE END SPI3_IRQn 0 */
  HAL_SPI_IRQHandler(&hspi3);
 8012054:	4802      	ldr	r0, [pc, #8]	; (8012060 <SPI3_IRQHandler+0x10>)
 8012056:	f7f4 fcc3 	bl	80069e0 <HAL_SPI_IRQHandler>
  /* USER CODE BEGIN SPI3_IRQn 1 */

  /* USER CODE END SPI3_IRQn 1 */
}
 801205a:	bf00      	nop
 801205c:	bd80      	pop	{r7, pc}
 801205e:	bf00      	nop
 8012060:	24062ab4 	.word	0x24062ab4

08012064 <UART4_IRQHandler>:

/**
  * @brief This function handles UART4 global interrupt.
  */
void UART4_IRQHandler(void)
{
 8012064:	b580      	push	{r7, lr}
 8012066:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UART4_IRQn 0 */

  /* USER CODE END UART4_IRQn 0 */
  HAL_UART_IRQHandler(&huart4);
 8012068:	4802      	ldr	r0, [pc, #8]	; (8012074 <UART4_IRQHandler+0x10>)
 801206a:	f7f6 fbb9 	bl	80087e0 <HAL_UART_IRQHandler>
  /* USER CODE BEGIN UART4_IRQn 1 */

  /* USER CODE END UART4_IRQn 1 */
}
 801206e:	bf00      	nop
 8012070:	bd80      	pop	{r7, pc}
 8012072:	bf00      	nop
 8012074:	24062e6c 	.word	0x24062e6c

08012078 <TIM6_DAC_IRQHandler>:

/**
  * @brief This function handles TIM6 global interrupt, DAC1_CH1 and DAC1_CH2 underrun error interrupts.
  */
void TIM6_DAC_IRQHandler(void)
{
 8012078:	b580      	push	{r7, lr}
 801207a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN TIM6_DAC_IRQn 0 */

  /* USER CODE END TIM6_DAC_IRQn 0 */
  HAL_TIM_IRQHandler(&htim6);
 801207c:	4802      	ldr	r0, [pc, #8]	; (8012088 <TIM6_DAC_IRQHandler+0x10>)
 801207e:	f7f5 f9ad 	bl	80073dc <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM6_DAC_IRQn 1 */

  /* USER CODE END TIM6_DAC_IRQn 1 */
}
 8012082:	bf00      	nop
 8012084:	bd80      	pop	{r7, pc}
 8012086:	bf00      	nop
 8012088:	240632cc 	.word	0x240632cc

0801208c <DMA2_Stream0_IRQHandler>:

/**
  * @brief This function handles DMA2 stream0 global interrupt.
  */
void DMA2_Stream0_IRQHandler(void)
{
 801208c:	b580      	push	{r7, lr}
 801208e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA2_Stream0_IRQn 0 */

  /* USER CODE END DMA2_Stream0_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_uart8_tx);
 8012090:	4802      	ldr	r0, [pc, #8]	; (801209c <DMA2_Stream0_IRQHandler+0x10>)
 8012092:	f7f0 f977 	bl	8002384 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA2_Stream0_IRQn 1 */

  /* USER CODE END DMA2_Stream0_IRQn 1 */
}
 8012096:	bf00      	nop
 8012098:	bd80      	pop	{r7, pc}
 801209a:	bf00      	nop
 801209c:	24062cf4 	.word	0x24062cf4

080120a0 <DMA2_Stream1_IRQHandler>:

/**
  * @brief This function handles DMA2 stream1 global interrupt.
  */
void DMA2_Stream1_IRQHandler(void)
{
 80120a0:	b580      	push	{r7, lr}
 80120a2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA2_Stream1_IRQn 0 */

  /* USER CODE END DMA2_Stream1_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_usart2_rx);
 80120a4:	4802      	ldr	r0, [pc, #8]	; (80120b0 <DMA2_Stream1_IRQHandler+0x10>)
 80120a6:	f7f0 f96d 	bl	8002384 <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA2_Stream1_IRQn 1 */

  /* USER CODE END DMA2_Stream1_IRQn 1 */
}
 80120aa:	bf00      	nop
 80120ac:	bd80      	pop	{r7, pc}
 80120ae:	bf00      	nop
 80120b0:	24062520 	.word	0x24062520

080120b4 <UART8_IRQHandler>:

/**
  * @brief This function handles UART8 global interrupt.
  */
void UART8_IRQHandler(void)
{
 80120b4:	b580      	push	{r7, lr}
 80120b6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UART8_IRQn 0 */

  /* USER CODE END UART8_IRQn 0 */
  HAL_UART_IRQHandler(&huart8);
 80120b8:	4802      	ldr	r0, [pc, #8]	; (80120c4 <UART8_IRQHandler+0x10>)
 80120ba:	f7f6 fb91 	bl	80087e0 <HAL_UART_IRQHandler>
  /* USER CODE BEGIN UART8_IRQn 1 */

  /* USER CODE END UART8_IRQn 1 */
}
 80120be:	bf00      	nop
 80120c0:	bd80      	pop	{r7, pc}
 80120c2:	bf00      	nop
 80120c4:	24062ddc 	.word	0x24062ddc

080120c8 <_sbrk>:
/**
 _sbrk
 Increase program data space. Malloc and related functions depend on this
**/
caddr_t _sbrk(int incr)
{
 80120c8:	b580      	push	{r7, lr}
 80120ca:	b084      	sub	sp, #16
 80120cc:	af00      	add	r7, sp, #0
 80120ce:	6078      	str	r0, [r7, #4]
	extern char end asm("end");
	static char *heap_end;
	char *prev_heap_end;

	if (heap_end == 0)
 80120d0:	4b11      	ldr	r3, [pc, #68]	; (8012118 <_sbrk+0x50>)
 80120d2:	681b      	ldr	r3, [r3, #0]
 80120d4:	2b00      	cmp	r3, #0
 80120d6:	d102      	bne.n	80120de <_sbrk+0x16>
		heap_end = &end;
 80120d8:	4b0f      	ldr	r3, [pc, #60]	; (8012118 <_sbrk+0x50>)
 80120da:	4a10      	ldr	r2, [pc, #64]	; (801211c <_sbrk+0x54>)
 80120dc:	601a      	str	r2, [r3, #0]

	prev_heap_end = heap_end;
 80120de:	4b0e      	ldr	r3, [pc, #56]	; (8012118 <_sbrk+0x50>)
 80120e0:	681b      	ldr	r3, [r3, #0]
 80120e2:	60fb      	str	r3, [r7, #12]
	if (heap_end + incr > stack_ptr)
 80120e4:	4b0c      	ldr	r3, [pc, #48]	; (8012118 <_sbrk+0x50>)
 80120e6:	681a      	ldr	r2, [r3, #0]
 80120e8:	687b      	ldr	r3, [r7, #4]
 80120ea:	4413      	add	r3, r2
 80120ec:	466a      	mov	r2, sp
 80120ee:	4293      	cmp	r3, r2
 80120f0:	d907      	bls.n	8012102 <_sbrk+0x3a>
	{
		errno = ENOMEM;
 80120f2:	f00f fd85 	bl	8021c00 <__errno>
 80120f6:	4603      	mov	r3, r0
 80120f8:	220c      	movs	r2, #12
 80120fa:	601a      	str	r2, [r3, #0]
		return (caddr_t) -1;
 80120fc:	f04f 33ff 	mov.w	r3, #4294967295
 8012100:	e006      	b.n	8012110 <_sbrk+0x48>
	}

	heap_end += incr;
 8012102:	4b05      	ldr	r3, [pc, #20]	; (8012118 <_sbrk+0x50>)
 8012104:	681a      	ldr	r2, [r3, #0]
 8012106:	687b      	ldr	r3, [r7, #4]
 8012108:	4413      	add	r3, r2
 801210a:	4a03      	ldr	r2, [pc, #12]	; (8012118 <_sbrk+0x50>)
 801210c:	6013      	str	r3, [r2, #0]

	return (caddr_t) prev_heap_end;
 801210e:	68fb      	ldr	r3, [r7, #12]
}
 8012110:	4618      	mov	r0, r3
 8012112:	3710      	adds	r7, #16
 8012114:	46bd      	mov	sp, r7
 8012116:	bd80      	pop	{r7, pc}
 8012118:	240623b0 	.word	0x240623b0
 801211c:	240636a0 	.word	0x240636a0

08012120 <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 8012120:	b480      	push	{r7}
 8012122:	af00      	add	r7, sp, #0
 __IO uint32_t tmpreg;
#endif /* DATA_IN_D2_SRAM */

  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 8012124:	4b29      	ldr	r3, [pc, #164]	; (80121cc <SystemInit+0xac>)
 8012126:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 801212a:	4a28      	ldr	r2, [pc, #160]	; (80121cc <SystemInit+0xac>)
 801212c:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8012130:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= RCC_CR_HSION;
 8012134:	4b26      	ldr	r3, [pc, #152]	; (80121d0 <SystemInit+0xb0>)
 8012136:	681b      	ldr	r3, [r3, #0]
 8012138:	4a25      	ldr	r2, [pc, #148]	; (80121d0 <SystemInit+0xb0>)
 801213a:	f043 0301 	orr.w	r3, r3, #1
 801213e:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8012140:	4b23      	ldr	r3, [pc, #140]	; (80121d0 <SystemInit+0xb0>)
 8012142:	2200      	movs	r2, #0
 8012144:	611a      	str	r2, [r3, #16]

  /* Reset HSEON, CSSON , CSION,RC48ON, CSIKERON PLL1ON, PLL2ON and PLL3ON bits */
  RCC->CR &= 0xEAF6ED7FU;
 8012146:	4b22      	ldr	r3, [pc, #136]	; (80121d0 <SystemInit+0xb0>)
 8012148:	681a      	ldr	r2, [r3, #0]
 801214a:	4921      	ldr	r1, [pc, #132]	; (80121d0 <SystemInit+0xb0>)
 801214c:	4b21      	ldr	r3, [pc, #132]	; (80121d4 <SystemInit+0xb4>)
 801214e:	4013      	ands	r3, r2
 8012150:	600b      	str	r3, [r1, #0]

  /* Reset D1CFGR register */
  RCC->D1CFGR = 0x00000000;
 8012152:	4b1f      	ldr	r3, [pc, #124]	; (80121d0 <SystemInit+0xb0>)
 8012154:	2200      	movs	r2, #0
 8012156:	619a      	str	r2, [r3, #24]

  /* Reset D2CFGR register */
  RCC->D2CFGR = 0x00000000;
 8012158:	4b1d      	ldr	r3, [pc, #116]	; (80121d0 <SystemInit+0xb0>)
 801215a:	2200      	movs	r2, #0
 801215c:	61da      	str	r2, [r3, #28]

  /* Reset D3CFGR register */
  RCC->D3CFGR = 0x00000000;
 801215e:	4b1c      	ldr	r3, [pc, #112]	; (80121d0 <SystemInit+0xb0>)
 8012160:	2200      	movs	r2, #0
 8012162:	621a      	str	r2, [r3, #32]

  /* Reset PLLCKSELR register */
  RCC->PLLCKSELR = 0x00000000;
 8012164:	4b1a      	ldr	r3, [pc, #104]	; (80121d0 <SystemInit+0xb0>)
 8012166:	2200      	movs	r2, #0
 8012168:	629a      	str	r2, [r3, #40]	; 0x28

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00000000;
 801216a:	4b19      	ldr	r3, [pc, #100]	; (80121d0 <SystemInit+0xb0>)
 801216c:	2200      	movs	r2, #0
 801216e:	62da      	str	r2, [r3, #44]	; 0x2c
  /* Reset PLL1DIVR register */
  RCC->PLL1DIVR = 0x00000000;
 8012170:	4b17      	ldr	r3, [pc, #92]	; (80121d0 <SystemInit+0xb0>)
 8012172:	2200      	movs	r2, #0
 8012174:	631a      	str	r2, [r3, #48]	; 0x30
  /* Reset PLL1FRACR register */
  RCC->PLL1FRACR = 0x00000000;
 8012176:	4b16      	ldr	r3, [pc, #88]	; (80121d0 <SystemInit+0xb0>)
 8012178:	2200      	movs	r2, #0
 801217a:	635a      	str	r2, [r3, #52]	; 0x34

  /* Reset PLL2DIVR register */
  RCC->PLL2DIVR = 0x00000000;
 801217c:	4b14      	ldr	r3, [pc, #80]	; (80121d0 <SystemInit+0xb0>)
 801217e:	2200      	movs	r2, #0
 8012180:	639a      	str	r2, [r3, #56]	; 0x38

  /* Reset PLL2FRACR register */

  RCC->PLL2FRACR = 0x00000000;
 8012182:	4b13      	ldr	r3, [pc, #76]	; (80121d0 <SystemInit+0xb0>)
 8012184:	2200      	movs	r2, #0
 8012186:	63da      	str	r2, [r3, #60]	; 0x3c
  /* Reset PLL3DIVR register */
  RCC->PLL3DIVR = 0x00000000;
 8012188:	4b11      	ldr	r3, [pc, #68]	; (80121d0 <SystemInit+0xb0>)
 801218a:	2200      	movs	r2, #0
 801218c:	641a      	str	r2, [r3, #64]	; 0x40

  /* Reset PLL3FRACR register */
  RCC->PLL3FRACR = 0x00000000;
 801218e:	4b10      	ldr	r3, [pc, #64]	; (80121d0 <SystemInit+0xb0>)
 8012190:	2200      	movs	r2, #0
 8012192:	645a      	str	r2, [r3, #68]	; 0x44

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 8012194:	4b0e      	ldr	r3, [pc, #56]	; (80121d0 <SystemInit+0xb0>)
 8012196:	681b      	ldr	r3, [r3, #0]
 8012198:	4a0d      	ldr	r2, [pc, #52]	; (80121d0 <SystemInit+0xb0>)
 801219a:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 801219e:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000;
 80121a0:	4b0b      	ldr	r3, [pc, #44]	; (80121d0 <SystemInit+0xb0>)
 80121a2:	2200      	movs	r2, #0
 80121a4:	661a      	str	r2, [r3, #96]	; 0x60
  SCB->VTOR = FLASH_BANK2_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
#endif /* VECT_TAB_SRAM */

#else
  /* dual core CM7 or single core line */
  if((DBGMCU->IDCODE & 0xFFFF0000U) < 0x20000000U)
 80121a6:	4b0c      	ldr	r3, [pc, #48]	; (80121d8 <SystemInit+0xb8>)
 80121a8:	681a      	ldr	r2, [r3, #0]
 80121aa:	4b0c      	ldr	r3, [pc, #48]	; (80121dc <SystemInit+0xbc>)
 80121ac:	4013      	ands	r3, r2
 80121ae:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 80121b2:	d202      	bcs.n	80121ba <SystemInit+0x9a>
  {
    /* if stm32h7 revY*/
    /* Change  the switch matrix read issuing capability to 1 for the AXI SRAM target (Target 7) */
    *((__IO uint32_t*)0x51008108) = 0x000000001U;
 80121b4:	4b0a      	ldr	r3, [pc, #40]	; (80121e0 <SystemInit+0xc0>)
 80121b6:	2201      	movs	r2, #1
 80121b8:	601a      	str	r2, [r3, #0]

  /* Configure the Vector Table location add offset address for cortex-M7 ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = D1_AXISRAM_BASE  | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal D1 AXI-RAM */
#else
  SCB->VTOR = FLASH_BANK1_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 80121ba:	4b04      	ldr	r3, [pc, #16]	; (80121cc <SystemInit+0xac>)
 80121bc:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 80121c0:	609a      	str	r2, [r3, #8]
#endif

#endif /*DUAL_CORE && CORE_CM4*/

}
 80121c2:	bf00      	nop
 80121c4:	46bd      	mov	sp, r7
 80121c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80121ca:	4770      	bx	lr
 80121cc:	e000ed00 	.word	0xe000ed00
 80121d0:	58024400 	.word	0x58024400
 80121d4:	eaf6ed7f 	.word	0xeaf6ed7f
 80121d8:	5c001000 	.word	0x5c001000
 80121dc:	ffff0000 	.word	0xffff0000
 80121e0:	51008108 	.word	0x51008108

080121e4 <lv_disp_get_scr_act>:
 * @param disp pointer to display which active screen should be get. (NULL to use the default
 * screen)
 * @return pointer to the active screen object (loaded by 'lv_scr_load()')
 */
lv_obj_t * lv_disp_get_scr_act(lv_disp_t * disp)
{
 80121e4:	b580      	push	{r7, lr}
 80121e6:	b082      	sub	sp, #8
 80121e8:	af00      	add	r7, sp, #0
 80121ea:	6078      	str	r0, [r7, #4]
    if(!disp) disp = lv_disp_get_default();
 80121ec:	687b      	ldr	r3, [r7, #4]
 80121ee:	2b00      	cmp	r3, #0
 80121f0:	d102      	bne.n	80121f8 <lv_disp_get_scr_act+0x14>
 80121f2:	f00a ff83 	bl	801d0fc <lv_disp_get_default>
 80121f6:	6078      	str	r0, [r7, #4]
    if(!disp) {
 80121f8:	687b      	ldr	r3, [r7, #4]
 80121fa:	2b00      	cmp	r3, #0
 80121fc:	d101      	bne.n	8012202 <lv_disp_get_scr_act+0x1e>
        LV_LOG_WARN("lv_scr_act: no display registered to get its top layer");
        return NULL;
 80121fe:	2300      	movs	r3, #0
 8012200:	e001      	b.n	8012206 <lv_disp_get_scr_act+0x22>
    }

    return disp->act_scr;
 8012202:	687b      	ldr	r3, [r7, #4]
 8012204:	6b1b      	ldr	r3, [r3, #48]	; 0x30
}
 8012206:	4618      	mov	r0, r3
 8012208:	3708      	adds	r7, #8
 801220a:	46bd      	mov	sp, r7
 801220c:	bd80      	pop	{r7, pc}

0801220e <lv_disp_get_layer_top>:
 * Return with the top layer. (Same on every screen and it is above the normal screen layer)
 * @param disp pointer to display which top layer should be get. (NULL to use the default screen)
 * @return pointer to the top layer object  (transparent screen sized lv_obj)
 */
lv_obj_t * lv_disp_get_layer_top(lv_disp_t * disp)
{
 801220e:	b580      	push	{r7, lr}
 8012210:	b082      	sub	sp, #8
 8012212:	af00      	add	r7, sp, #0
 8012214:	6078      	str	r0, [r7, #4]
    if(!disp) disp = lv_disp_get_default();
 8012216:	687b      	ldr	r3, [r7, #4]
 8012218:	2b00      	cmp	r3, #0
 801221a:	d102      	bne.n	8012222 <lv_disp_get_layer_top+0x14>
 801221c:	f00a ff6e 	bl	801d0fc <lv_disp_get_default>
 8012220:	6078      	str	r0, [r7, #4]
    if(!disp) {
 8012222:	687b      	ldr	r3, [r7, #4]
 8012224:	2b00      	cmp	r3, #0
 8012226:	d101      	bne.n	801222c <lv_disp_get_layer_top+0x1e>
        LV_LOG_WARN("lv_layer_top: no display registered to get its top layer");
        return NULL;
 8012228:	2300      	movs	r3, #0
 801222a:	e001      	b.n	8012230 <lv_disp_get_layer_top+0x22>
    }

    return disp->top_layer;
 801222c:	687b      	ldr	r3, [r7, #4]
 801222e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
}
 8012230:	4618      	mov	r0, r3
 8012232:	3708      	adds	r7, #8
 8012234:	46bd      	mov	sp, r7
 8012236:	bd80      	pop	{r7, pc}

08012238 <lv_disp_get_layer_sys>:
 * layer)
 * @param disp pointer to display which sys. layer  should be get. (NULL to use the default screen)
 * @return pointer to the sys layer object  (transparent screen sized lv_obj)
 */
lv_obj_t * lv_disp_get_layer_sys(lv_disp_t * disp)
{
 8012238:	b580      	push	{r7, lr}
 801223a:	b082      	sub	sp, #8
 801223c:	af00      	add	r7, sp, #0
 801223e:	6078      	str	r0, [r7, #4]
    if(!disp) disp = lv_disp_get_default();
 8012240:	687b      	ldr	r3, [r7, #4]
 8012242:	2b00      	cmp	r3, #0
 8012244:	d102      	bne.n	801224c <lv_disp_get_layer_sys+0x14>
 8012246:	f00a ff59 	bl	801d0fc <lv_disp_get_default>
 801224a:	6078      	str	r0, [r7, #4]
    if(!disp) {
 801224c:	687b      	ldr	r3, [r7, #4]
 801224e:	2b00      	cmp	r3, #0
 8012250:	d101      	bne.n	8012256 <lv_disp_get_layer_sys+0x1e>
        LV_LOG_WARN("lv_layer_sys: no display registered to get its top layer");
        return NULL;
 8012252:	2300      	movs	r3, #0
 8012254:	e001      	b.n	801225a <lv_disp_get_layer_sys+0x22>
    }

    return disp->sys_layer;
 8012256:	687b      	ldr	r3, [r7, #4]
 8012258:	6b9b      	ldr	r3, [r3, #56]	; 0x38
}
 801225a:	4618      	mov	r0, r3
 801225c:	3708      	adds	r7, #8
 801225e:	46bd      	mov	sp, r7
 8012260:	bd80      	pop	{r7, pc}
	...

08012264 <lv_group_init>:

/**
 * Init. the group module
 */
void lv_group_init(void)
{
 8012264:	b580      	push	{r7, lr}
 8012266:	af00      	add	r7, sp, #0
    lv_ll_init(&LV_GC_ROOT(_lv_group_ll), sizeof(lv_group_t));
 8012268:	215c      	movs	r1, #92	; 0x5c
 801226a:	4802      	ldr	r0, [pc, #8]	; (8012274 <lv_group_init+0x10>)
 801226c:	f00b fc38 	bl	801dae0 <lv_ll_init>
}
 8012270:	bf00      	nop
 8012272:	bd80      	pop	{r7, pc}
 8012274:	24063678 	.word	0x24063678

08012278 <lv_group_add_obj>:
 * Add an object to a group
 * @param group pointer to a group
 * @param obj pointer to an object to add
 */
void lv_group_add_obj(lv_group_t * group, lv_obj_t * obj)
{
 8012278:	b580      	push	{r7, lr}
 801227a:	b084      	sub	sp, #16
 801227c:	af00      	add	r7, sp, #0
 801227e:	6078      	str	r0, [r7, #4]
 8012280:	6039      	str	r1, [r7, #0]
    if(group == NULL) return;
 8012282:	687b      	ldr	r3, [r7, #4]
 8012284:	2b00      	cmp	r3, #0
 8012286:	d040      	beq.n	801230a <lv_group_add_obj+0x92>

    /*Do not add the object twice*/
    lv_obj_t ** obj_i;
    LV_LL_READ(group->obj_ll, obj_i)
 8012288:	687b      	ldr	r3, [r7, #4]
 801228a:	4618      	mov	r0, r3
 801228c:	f00b fdaa 	bl	801dde4 <lv_ll_get_head>
 8012290:	60f8      	str	r0, [r7, #12]
 8012292:	e00a      	b.n	80122aa <lv_group_add_obj+0x32>
    {
        if((*obj_i) == obj) {
 8012294:	68fb      	ldr	r3, [r7, #12]
 8012296:	681b      	ldr	r3, [r3, #0]
 8012298:	683a      	ldr	r2, [r7, #0]
 801229a:	429a      	cmp	r2, r3
 801229c:	d037      	beq.n	801230e <lv_group_add_obj+0x96>
    LV_LL_READ(group->obj_ll, obj_i)
 801229e:	687b      	ldr	r3, [r7, #4]
 80122a0:	68f9      	ldr	r1, [r7, #12]
 80122a2:	4618      	mov	r0, r3
 80122a4:	f00b fdc4 	bl	801de30 <lv_ll_get_next>
 80122a8:	60f8      	str	r0, [r7, #12]
 80122aa:	68fb      	ldr	r3, [r7, #12]
 80122ac:	2b00      	cmp	r3, #0
 80122ae:	d1f1      	bne.n	8012294 <lv_group_add_obj+0x1c>
            return;
        }
    }

    /*If the object is already in a group and focused then defocus it*/
    if(obj->group_p) {
 80122b0:	683b      	ldr	r3, [r7, #0]
 80122b2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80122b4:	2b00      	cmp	r3, #0
 80122b6:	d00a      	beq.n	80122ce <lv_group_add_obj+0x56>
        if(lv_obj_is_focused(obj)) {
 80122b8:	6838      	ldr	r0, [r7, #0]
 80122ba:	f001 fe94 	bl	8013fe6 <lv_obj_is_focused>
 80122be:	4603      	mov	r3, r0
 80122c0:	2b00      	cmp	r3, #0
 80122c2:	d004      	beq.n	80122ce <lv_group_add_obj+0x56>
            lv_group_refocus(obj->group_p);
 80122c4:	683b      	ldr	r3, [r7, #0]
 80122c6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80122c8:	4618      	mov	r0, r3
 80122ca:	f000 f893 	bl	80123f4 <lv_group_refocus>

            LV_LOG_INFO("lv_group_add_obj: assign object to an other group");
        }
    }

    obj->group_p     = group;
 80122ce:	683b      	ldr	r3, [r7, #0]
 80122d0:	687a      	ldr	r2, [r7, #4]
 80122d2:	62da      	str	r2, [r3, #44]	; 0x2c
    lv_obj_t ** next = lv_ll_ins_tail(&group->obj_ll);
 80122d4:	687b      	ldr	r3, [r7, #4]
 80122d6:	4618      	mov	r0, r3
 80122d8:	f00b fc9d 	bl	801dc16 <lv_ll_ins_tail>
 80122dc:	60b8      	str	r0, [r7, #8]
    lv_mem_assert(next);
 80122de:	68bb      	ldr	r3, [r7, #8]
 80122e0:	2b00      	cmp	r3, #0
 80122e2:	d100      	bne.n	80122e6 <lv_group_add_obj+0x6e>
 80122e4:	e7fe      	b.n	80122e4 <lv_group_add_obj+0x6c>
    if(next == NULL) return;
 80122e6:	68bb      	ldr	r3, [r7, #8]
 80122e8:	2b00      	cmp	r3, #0
 80122ea:	d012      	beq.n	8012312 <lv_group_add_obj+0x9a>
    *next = obj;
 80122ec:	68bb      	ldr	r3, [r7, #8]
 80122ee:	683a      	ldr	r2, [r7, #0]
 80122f0:	601a      	str	r2, [r3, #0]

    /* If the head and the tail is equal then there is only one object in the linked list.
     * In this case automatically activate it*/
    if(lv_ll_get_head(&group->obj_ll) == next) {
 80122f2:	687b      	ldr	r3, [r7, #4]
 80122f4:	4618      	mov	r0, r3
 80122f6:	f00b fd75 	bl	801dde4 <lv_ll_get_head>
 80122fa:	4602      	mov	r2, r0
 80122fc:	68bb      	ldr	r3, [r7, #8]
 80122fe:	4293      	cmp	r3, r2
 8012300:	d108      	bne.n	8012314 <lv_group_add_obj+0x9c>
        lv_group_refocus(group);
 8012302:	6878      	ldr	r0, [r7, #4]
 8012304:	f000 f876 	bl	80123f4 <lv_group_refocus>
 8012308:	e004      	b.n	8012314 <lv_group_add_obj+0x9c>
    if(group == NULL) return;
 801230a:	bf00      	nop
 801230c:	e002      	b.n	8012314 <lv_group_add_obj+0x9c>
            return;
 801230e:	bf00      	nop
 8012310:	e000      	b.n	8012314 <lv_group_add_obj+0x9c>
    if(next == NULL) return;
 8012312:	bf00      	nop
    }
}
 8012314:	3710      	adds	r7, #16
 8012316:	46bd      	mov	sp, r7
 8012318:	bd80      	pop	{r7, pc}
	...

0801231c <lv_group_focus_next>:
/**
 * Focus the next object in a group (defocus the current)
 * @param group pointer to a group
 */
void lv_group_focus_next(lv_group_t * group)
{
 801231c:	b580      	push	{r7, lr}
 801231e:	b082      	sub	sp, #8
 8012320:	af00      	add	r7, sp, #0
 8012322:	6078      	str	r0, [r7, #4]
    focus_next_core(group, lv_ll_get_head, lv_ll_get_next);
 8012324:	4a04      	ldr	r2, [pc, #16]	; (8012338 <lv_group_focus_next+0x1c>)
 8012326:	4905      	ldr	r1, [pc, #20]	; (801233c <lv_group_focus_next+0x20>)
 8012328:	6878      	ldr	r0, [r7, #4]
 801232a:	f000 f89b 	bl	8012464 <focus_next_core>
}
 801232e:	bf00      	nop
 8012330:	3708      	adds	r7, #8
 8012332:	46bd      	mov	sp, r7
 8012334:	bd80      	pop	{r7, pc}
 8012336:	bf00      	nop
 8012338:	0801de31 	.word	0x0801de31
 801233c:	0801dde5 	.word	0x0801dde5

08012340 <lv_group_focus_prev>:
/**
 * Focus the previous object in a group (defocus the current)
 * @param group pointer to a group
 */
void lv_group_focus_prev(lv_group_t * group)
{
 8012340:	b580      	push	{r7, lr}
 8012342:	b082      	sub	sp, #8
 8012344:	af00      	add	r7, sp, #0
 8012346:	6078      	str	r0, [r7, #4]
    focus_next_core(group, lv_ll_get_tail, lv_ll_get_prev);
 8012348:	4a04      	ldr	r2, [pc, #16]	; (801235c <lv_group_focus_prev+0x1c>)
 801234a:	4905      	ldr	r1, [pc, #20]	; (8012360 <lv_group_focus_prev+0x20>)
 801234c:	6878      	ldr	r0, [r7, #4]
 801234e:	f000 f889 	bl	8012464 <focus_next_core>
}
 8012352:	bf00      	nop
 8012354:	3708      	adds	r7, #8
 8012356:	46bd      	mov	sp, r7
 8012358:	bd80      	pop	{r7, pc}
 801235a:	bf00      	nop
 801235c:	0801de65 	.word	0x0801de65
 8012360:	0801de0b 	.word	0x0801de0b

08012364 <lv_group_mod_style>:
 * @param group pointer to group
 * @param style pointer to a style to modify
 * @return a copy of the input style but modified with the 'style_mod' function
 */
lv_style_t * lv_group_mod_style(lv_group_t * group, const lv_style_t * style)
{
 8012364:	b580      	push	{r7, lr}
 8012366:	b082      	sub	sp, #8
 8012368:	af00      	add	r7, sp, #0
 801236a:	6078      	str	r0, [r7, #4]
 801236c:	6039      	str	r1, [r7, #0]
    /*Load the current style. It will be modified by the callback*/
    lv_style_copy(&group->style_tmp, style);
 801236e:	687b      	ldr	r3, [r7, #4]
 8012370:	331c      	adds	r3, #28
 8012372:	6839      	ldr	r1, [r7, #0]
 8012374:	4618      	mov	r0, r3
 8012376:	f003 f801 	bl	801537c <lv_style_copy>

    if(group->editing) {
 801237a:	687b      	ldr	r3, [r7, #4]
 801237c:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
 8012380:	f003 0302 	and.w	r3, r3, #2
 8012384:	b2db      	uxtb	r3, r3
 8012386:	2b00      	cmp	r3, #0
 8012388:	d00b      	beq.n	80123a2 <lv_group_mod_style+0x3e>
        if(group->style_mod_edit_cb) group->style_mod_edit_cb(group, &group->style_tmp);
 801238a:	687b      	ldr	r3, [r7, #4]
 801238c:	695b      	ldr	r3, [r3, #20]
 801238e:	2b00      	cmp	r3, #0
 8012390:	d012      	beq.n	80123b8 <lv_group_mod_style+0x54>
 8012392:	687b      	ldr	r3, [r7, #4]
 8012394:	695b      	ldr	r3, [r3, #20]
 8012396:	687a      	ldr	r2, [r7, #4]
 8012398:	321c      	adds	r2, #28
 801239a:	4611      	mov	r1, r2
 801239c:	6878      	ldr	r0, [r7, #4]
 801239e:	4798      	blx	r3
 80123a0:	e00a      	b.n	80123b8 <lv_group_mod_style+0x54>
    } else {
        if(group->style_mod_cb) group->style_mod_cb(group, &group->style_tmp);
 80123a2:	687b      	ldr	r3, [r7, #4]
 80123a4:	691b      	ldr	r3, [r3, #16]
 80123a6:	2b00      	cmp	r3, #0
 80123a8:	d006      	beq.n	80123b8 <lv_group_mod_style+0x54>
 80123aa:	687b      	ldr	r3, [r7, #4]
 80123ac:	691b      	ldr	r3, [r3, #16]
 80123ae:	687a      	ldr	r2, [r7, #4]
 80123b0:	321c      	adds	r2, #28
 80123b2:	4611      	mov	r1, r2
 80123b4:	6878      	ldr	r0, [r7, #4]
 80123b6:	4798      	blx	r3
    }
    return &group->style_tmp;
 80123b8:	687b      	ldr	r3, [r7, #4]
 80123ba:	331c      	adds	r3, #28
}
 80123bc:	4618      	mov	r0, r3
 80123be:	3708      	adds	r7, #8
 80123c0:	46bd      	mov	sp, r7
 80123c2:	bd80      	pop	{r7, pc}

080123c4 <lv_group_get_focused>:
 * Get the focused object or NULL if there isn't one
 * @param group pointer to a group
 * @return pointer to the focused object
 */
lv_obj_t * lv_group_get_focused(const lv_group_t * group)
{
 80123c4:	b480      	push	{r7}
 80123c6:	b083      	sub	sp, #12
 80123c8:	af00      	add	r7, sp, #0
 80123ca:	6078      	str	r0, [r7, #4]
    if(!group) return NULL;
 80123cc:	687b      	ldr	r3, [r7, #4]
 80123ce:	2b00      	cmp	r3, #0
 80123d0:	d101      	bne.n	80123d6 <lv_group_get_focused+0x12>
 80123d2:	2300      	movs	r3, #0
 80123d4:	e008      	b.n	80123e8 <lv_group_get_focused+0x24>
    if(group->obj_focus == NULL) return NULL;
 80123d6:	687b      	ldr	r3, [r7, #4]
 80123d8:	68db      	ldr	r3, [r3, #12]
 80123da:	2b00      	cmp	r3, #0
 80123dc:	d101      	bne.n	80123e2 <lv_group_get_focused+0x1e>
 80123de:	2300      	movs	r3, #0
 80123e0:	e002      	b.n	80123e8 <lv_group_get_focused+0x24>

    return *group->obj_focus;
 80123e2:	687b      	ldr	r3, [r7, #4]
 80123e4:	68db      	ldr	r3, [r3, #12]
 80123e6:	681b      	ldr	r3, [r3, #0]
}
 80123e8:	4618      	mov	r0, r3
 80123ea:	370c      	adds	r7, #12
 80123ec:	46bd      	mov	sp, r7
 80123ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80123f2:	4770      	bx	lr

080123f4 <lv_group_refocus>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static void lv_group_refocus(lv_group_t * g)
{
 80123f4:	b580      	push	{r7, lr}
 80123f6:	b084      	sub	sp, #16
 80123f8:	af00      	add	r7, sp, #0
 80123fa:	6078      	str	r0, [r7, #4]
    /*Refocus must temporarily allow wrapping to work correctly*/
    uint8_t temp_wrap = g->wrap;
 80123fc:	687b      	ldr	r3, [r7, #4]
 80123fe:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
 8012402:	f3c3 1300 	ubfx	r3, r3, #4, #1
 8012406:	b2db      	uxtb	r3, r3
 8012408:	73fb      	strb	r3, [r7, #15]
    g->wrap           = 1;
 801240a:	687a      	ldr	r2, [r7, #4]
 801240c:	f892 3058 	ldrb.w	r3, [r2, #88]	; 0x58
 8012410:	f043 0310 	orr.w	r3, r3, #16
 8012414:	f882 3058 	strb.w	r3, [r2, #88]	; 0x58

    if(g->refocus_policy == LV_GROUP_REFOCUS_POLICY_NEXT)
 8012418:	687b      	ldr	r3, [r7, #4]
 801241a:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
 801241e:	f003 0308 	and.w	r3, r3, #8
 8012422:	b2db      	uxtb	r3, r3
 8012424:	2b00      	cmp	r3, #0
 8012426:	d103      	bne.n	8012430 <lv_group_refocus+0x3c>
        lv_group_focus_next(g);
 8012428:	6878      	ldr	r0, [r7, #4]
 801242a:	f7ff ff77 	bl	801231c <lv_group_focus_next>
 801242e:	e00a      	b.n	8012446 <lv_group_refocus+0x52>
    else if(g->refocus_policy == LV_GROUP_REFOCUS_POLICY_PREV)
 8012430:	687b      	ldr	r3, [r7, #4]
 8012432:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
 8012436:	f003 0308 	and.w	r3, r3, #8
 801243a:	b2db      	uxtb	r3, r3
 801243c:	2b00      	cmp	r3, #0
 801243e:	d002      	beq.n	8012446 <lv_group_refocus+0x52>
        lv_group_focus_prev(g);
 8012440:	6878      	ldr	r0, [r7, #4]
 8012442:	f7ff ff7d 	bl	8012340 <lv_group_focus_prev>
    /*Restore wrap property*/
    g->wrap = temp_wrap;
 8012446:	7bfb      	ldrb	r3, [r7, #15]
 8012448:	f003 0301 	and.w	r3, r3, #1
 801244c:	b2d9      	uxtb	r1, r3
 801244e:	687a      	ldr	r2, [r7, #4]
 8012450:	f892 3058 	ldrb.w	r3, [r2, #88]	; 0x58
 8012454:	f361 1304 	bfi	r3, r1, #4, #1
 8012458:	f882 3058 	strb.w	r3, [r2, #88]	; 0x58
}
 801245c:	bf00      	nop
 801245e:	3710      	adds	r7, #16
 8012460:	46bd      	mov	sp, r7
 8012462:	bd80      	pop	{r7, pc}

08012464 <focus_next_core>:
    }
}

static void focus_next_core(lv_group_t * group, void * (*begin)(const lv_ll_t *),
                            void * (*move)(const lv_ll_t *, const void *))
{
 8012464:	b580      	push	{r7, lr}
 8012466:	b088      	sub	sp, #32
 8012468:	af00      	add	r7, sp, #0
 801246a:	60f8      	str	r0, [r7, #12]
 801246c:	60b9      	str	r1, [r7, #8]
 801246e:	607a      	str	r2, [r7, #4]
    if(group->frozen) return;
 8012470:	68fb      	ldr	r3, [r7, #12]
 8012472:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
 8012476:	f003 0301 	and.w	r3, r3, #1
 801247a:	b2db      	uxtb	r3, r3
 801247c:	2b00      	cmp	r3, #0
 801247e:	f040 80a6 	bne.w	80125ce <focus_next_core+0x16a>

    lv_obj_t ** obj_next     = group->obj_focus;
 8012482:	68fb      	ldr	r3, [r7, #12]
 8012484:	68db      	ldr	r3, [r3, #12]
 8012486:	61fb      	str	r3, [r7, #28]
    lv_obj_t ** obj_sentinel = NULL;
 8012488:	2300      	movs	r3, #0
 801248a:	61bb      	str	r3, [r7, #24]
    bool can_move            = true;
 801248c:	2301      	movs	r3, #1
 801248e:	75fb      	strb	r3, [r7, #23]
    bool can_begin           = true;
 8012490:	2301      	movs	r3, #1
 8012492:	75bb      	strb	r3, [r7, #22]

    for(;;) {
        if(obj_next == NULL) {
 8012494:	69fb      	ldr	r3, [r7, #28]
 8012496:	2b00      	cmp	r3, #0
 8012498:	d11b      	bne.n	80124d2 <focus_next_core+0x6e>
            if(group->wrap || obj_sentinel == NULL) {
 801249a:	68fb      	ldr	r3, [r7, #12]
 801249c:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
 80124a0:	f003 0310 	and.w	r3, r3, #16
 80124a4:	b2db      	uxtb	r3, r3
 80124a6:	2b00      	cmp	r3, #0
 80124a8:	d103      	bne.n	80124b2 <focus_next_core+0x4e>
 80124aa:	69bb      	ldr	r3, [r7, #24]
 80124ac:	2b00      	cmp	r3, #0
 80124ae:	f040 8090 	bne.w	80125d2 <focus_next_core+0x16e>
                if(!can_begin) return;
 80124b2:	7dbb      	ldrb	r3, [r7, #22]
 80124b4:	f083 0301 	eor.w	r3, r3, #1
 80124b8:	b2db      	uxtb	r3, r3
 80124ba:	2b00      	cmp	r3, #0
 80124bc:	f040 808b 	bne.w	80125d6 <focus_next_core+0x172>
                obj_next  = begin(&group->obj_ll);
 80124c0:	68fa      	ldr	r2, [r7, #12]
 80124c2:	68bb      	ldr	r3, [r7, #8]
 80124c4:	4610      	mov	r0, r2
 80124c6:	4798      	blx	r3
 80124c8:	61f8      	str	r0, [r7, #28]
                can_move  = false;
 80124ca:	2300      	movs	r3, #0
 80124cc:	75fb      	strb	r3, [r7, #23]
                can_begin = false;
 80124ce:	2300      	movs	r3, #0
 80124d0:	75bb      	strb	r3, [r7, #22]
                /*Currently focused object is the last/first in the group, keep it that way*/
                return;
            }
        }

        if(obj_sentinel == NULL) {
 80124d2:	69bb      	ldr	r3, [r7, #24]
 80124d4:	2b00      	cmp	r3, #0
 80124d6:	d104      	bne.n	80124e2 <focus_next_core+0x7e>
            obj_sentinel = obj_next;
 80124d8:	69fb      	ldr	r3, [r7, #28]
 80124da:	61bb      	str	r3, [r7, #24]
            if(obj_sentinel == NULL) return; /*Group is empty*/
 80124dc:	69bb      	ldr	r3, [r7, #24]
 80124de:	2b00      	cmp	r3, #0
 80124e0:	d07b      	beq.n	80125da <focus_next_core+0x176>
        }

        if(can_move) {
 80124e2:	7dfb      	ldrb	r3, [r7, #23]
 80124e4:	2b00      	cmp	r3, #0
 80124e6:	d009      	beq.n	80124fc <focus_next_core+0x98>
            obj_next = move(&group->obj_ll, obj_next);
 80124e8:	68fa      	ldr	r2, [r7, #12]
 80124ea:	687b      	ldr	r3, [r7, #4]
 80124ec:	69f9      	ldr	r1, [r7, #28]
 80124ee:	4610      	mov	r0, r2
 80124f0:	4798      	blx	r3
 80124f2:	61f8      	str	r0, [r7, #28]

            /*Give up if we walked the entire list and haven't found another visible object*/
            if(obj_next == obj_sentinel) return;
 80124f4:	69fa      	ldr	r2, [r7, #28]
 80124f6:	69bb      	ldr	r3, [r7, #24]
 80124f8:	429a      	cmp	r2, r3
 80124fa:	d070      	beq.n	80125de <focus_next_core+0x17a>
        }

        can_move = true;
 80124fc:	2301      	movs	r3, #1
 80124fe:	75fb      	strb	r3, [r7, #23]

        if(obj_next == NULL) continue;
 8012500:	69fb      	ldr	r3, [r7, #28]
 8012502:	2b00      	cmp	r3, #0
 8012504:	d00b      	beq.n	801251e <focus_next_core+0xba>

        /*Hidden objects don't receive focus*/
        if(!lv_obj_get_hidden(*obj_next)) break;
 8012506:	69fb      	ldr	r3, [r7, #28]
 8012508:	681b      	ldr	r3, [r3, #0]
 801250a:	4618      	mov	r0, r3
 801250c:	f001 fcf0 	bl	8013ef0 <lv_obj_get_hidden>
 8012510:	4603      	mov	r3, r0
 8012512:	f083 0301 	eor.w	r3, r3, #1
 8012516:	b2db      	uxtb	r3, r3
 8012518:	2b00      	cmp	r3, #0
 801251a:	d102      	bne.n	8012522 <focus_next_core+0xbe>
 801251c:	e7ba      	b.n	8012494 <focus_next_core+0x30>
        if(obj_next == NULL) continue;
 801251e:	bf00      	nop
        if(obj_next == NULL) {
 8012520:	e7b8      	b.n	8012494 <focus_next_core+0x30>
        if(!lv_obj_get_hidden(*obj_next)) break;
 8012522:	bf00      	nop
    }

    if(obj_next == group->obj_focus) return; /*There's only one visible object and it's already focused*/
 8012524:	68fb      	ldr	r3, [r7, #12]
 8012526:	68db      	ldr	r3, [r3, #12]
 8012528:	69fa      	ldr	r2, [r7, #28]
 801252a:	429a      	cmp	r2, r3
 801252c:	d059      	beq.n	80125e2 <focus_next_core+0x17e>

    if(group->obj_focus) {
 801252e:	68fb      	ldr	r3, [r7, #12]
 8012530:	68db      	ldr	r3, [r3, #12]
 8012532:	2b00      	cmp	r3, #0
 8012534:	d01c      	beq.n	8012570 <focus_next_core+0x10c>
        (*group->obj_focus)->signal_cb(*group->obj_focus, LV_SIGNAL_DEFOCUS, NULL);
 8012536:	68fb      	ldr	r3, [r7, #12]
 8012538:	68db      	ldr	r3, [r3, #12]
 801253a:	681b      	ldr	r3, [r3, #0]
 801253c:	69db      	ldr	r3, [r3, #28]
 801253e:	68fa      	ldr	r2, [r7, #12]
 8012540:	68d2      	ldr	r2, [r2, #12]
 8012542:	6810      	ldr	r0, [r2, #0]
 8012544:	2200      	movs	r2, #0
 8012546:	2110      	movs	r1, #16
 8012548:	4798      	blx	r3
        lv_res_t res = lv_event_send(*group->obj_focus, LV_EVENT_DEFOCUSED, NULL);
 801254a:	68fb      	ldr	r3, [r7, #12]
 801254c:	68db      	ldr	r3, [r3, #12]
 801254e:	681b      	ldr	r3, [r3, #0]
 8012550:	2200      	movs	r2, #0
 8012552:	210d      	movs	r1, #13
 8012554:	4618      	mov	r0, r3
 8012556:	f001 fad4 	bl	8013b02 <lv_event_send>
 801255a:	4603      	mov	r3, r0
 801255c:	757b      	strb	r3, [r7, #21]
        if(res != LV_RES_OK) return;
 801255e:	7d7b      	ldrb	r3, [r7, #21]
 8012560:	2b01      	cmp	r3, #1
 8012562:	d140      	bne.n	80125e6 <focus_next_core+0x182>
        lv_obj_invalidate(*group->obj_focus);
 8012564:	68fb      	ldr	r3, [r7, #12]
 8012566:	68db      	ldr	r3, [r3, #12]
 8012568:	681b      	ldr	r3, [r3, #0]
 801256a:	4618      	mov	r0, r3
 801256c:	f000 fb7e 	bl	8012c6c <lv_obj_invalidate>
    }

    group->obj_focus = obj_next;
 8012570:	68fb      	ldr	r3, [r7, #12]
 8012572:	69fa      	ldr	r2, [r7, #28]
 8012574:	60da      	str	r2, [r3, #12]

    (*group->obj_focus)->signal_cb(*group->obj_focus, LV_SIGNAL_FOCUS, NULL);
 8012576:	68fb      	ldr	r3, [r7, #12]
 8012578:	68db      	ldr	r3, [r3, #12]
 801257a:	681b      	ldr	r3, [r3, #0]
 801257c:	69db      	ldr	r3, [r3, #28]
 801257e:	68fa      	ldr	r2, [r7, #12]
 8012580:	68d2      	ldr	r2, [r2, #12]
 8012582:	6810      	ldr	r0, [r2, #0]
 8012584:	2200      	movs	r2, #0
 8012586:	210f      	movs	r1, #15
 8012588:	4798      	blx	r3
    lv_res_t res = lv_event_send(*group->obj_focus, LV_EVENT_FOCUSED, NULL);
 801258a:	68fb      	ldr	r3, [r7, #12]
 801258c:	68db      	ldr	r3, [r3, #12]
 801258e:	681b      	ldr	r3, [r3, #0]
 8012590:	2200      	movs	r2, #0
 8012592:	210c      	movs	r1, #12
 8012594:	4618      	mov	r0, r3
 8012596:	f001 fab4 	bl	8013b02 <lv_event_send>
 801259a:	4603      	mov	r3, r0
 801259c:	753b      	strb	r3, [r7, #20]
    if(res != LV_RES_OK) return;
 801259e:	7d3b      	ldrb	r3, [r7, #20]
 80125a0:	2b01      	cmp	r3, #1
 80125a2:	d122      	bne.n	80125ea <focus_next_core+0x186>

    /*If the object or its parent has `top == true` bring it to the foregorund*/
    obj_to_foreground(*group->obj_focus);
 80125a4:	68fb      	ldr	r3, [r7, #12]
 80125a6:	68db      	ldr	r3, [r3, #12]
 80125a8:	681b      	ldr	r3, [r3, #0]
 80125aa:	4618      	mov	r0, r3
 80125ac:	f000 f821 	bl	80125f2 <obj_to_foreground>

    lv_obj_invalidate(*group->obj_focus);
 80125b0:	68fb      	ldr	r3, [r7, #12]
 80125b2:	68db      	ldr	r3, [r3, #12]
 80125b4:	681b      	ldr	r3, [r3, #0]
 80125b6:	4618      	mov	r0, r3
 80125b8:	f000 fb58 	bl	8012c6c <lv_obj_invalidate>

    if(group->focus_cb) group->focus_cb(group);
 80125bc:	68fb      	ldr	r3, [r7, #12]
 80125be:	699b      	ldr	r3, [r3, #24]
 80125c0:	2b00      	cmp	r3, #0
 80125c2:	d013      	beq.n	80125ec <focus_next_core+0x188>
 80125c4:	68fb      	ldr	r3, [r7, #12]
 80125c6:	699b      	ldr	r3, [r3, #24]
 80125c8:	68f8      	ldr	r0, [r7, #12]
 80125ca:	4798      	blx	r3
 80125cc:	e00e      	b.n	80125ec <focus_next_core+0x188>
    if(group->frozen) return;
 80125ce:	bf00      	nop
 80125d0:	e00c      	b.n	80125ec <focus_next_core+0x188>
                return;
 80125d2:	bf00      	nop
 80125d4:	e00a      	b.n	80125ec <focus_next_core+0x188>
                if(!can_begin) return;
 80125d6:	bf00      	nop
 80125d8:	e008      	b.n	80125ec <focus_next_core+0x188>
            if(obj_sentinel == NULL) return; /*Group is empty*/
 80125da:	bf00      	nop
 80125dc:	e006      	b.n	80125ec <focus_next_core+0x188>
            if(obj_next == obj_sentinel) return;
 80125de:	bf00      	nop
 80125e0:	e004      	b.n	80125ec <focus_next_core+0x188>
    if(obj_next == group->obj_focus) return; /*There's only one visible object and it's already focused*/
 80125e2:	bf00      	nop
 80125e4:	e002      	b.n	80125ec <focus_next_core+0x188>
        if(res != LV_RES_OK) return;
 80125e6:	bf00      	nop
 80125e8:	e000      	b.n	80125ec <focus_next_core+0x188>
    if(res != LV_RES_OK) return;
 80125ea:	bf00      	nop
}
 80125ec:	3720      	adds	r7, #32
 80125ee:	46bd      	mov	sp, r7
 80125f0:	bd80      	pop	{r7, pc}

080125f2 <obj_to_foreground>:

static void obj_to_foreground(lv_obj_t * obj)
{
 80125f2:	b580      	push	{r7, lr}
 80125f4:	b084      	sub	sp, #16
 80125f6:	af00      	add	r7, sp, #0
 80125f8:	6078      	str	r0, [r7, #4]
    /*Search for 'top' attribute*/
    lv_obj_t * i        = obj;
 80125fa:	687b      	ldr	r3, [r7, #4]
 80125fc:	60fb      	str	r3, [r7, #12]
    lv_obj_t * last_top = NULL;
 80125fe:	2300      	movs	r3, #0
 8012600:	60bb      	str	r3, [r7, #8]
    while(i != NULL) {
 8012602:	e00d      	b.n	8012620 <obj_to_foreground+0x2e>
        if(i->top != 0) last_top = i;
 8012604:	68fb      	ldr	r3, [r7, #12]
 8012606:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 801260a:	f003 0320 	and.w	r3, r3, #32
 801260e:	b2db      	uxtb	r3, r3
 8012610:	2b00      	cmp	r3, #0
 8012612:	d001      	beq.n	8012618 <obj_to_foreground+0x26>
 8012614:	68fb      	ldr	r3, [r7, #12]
 8012616:	60bb      	str	r3, [r7, #8]
        i = lv_obj_get_parent(i);
 8012618:	68f8      	ldr	r0, [r7, #12]
 801261a:	f001 fb8b 	bl	8013d34 <lv_obj_get_parent>
 801261e:	60f8      	str	r0, [r7, #12]
    while(i != NULL) {
 8012620:	68fb      	ldr	r3, [r7, #12]
 8012622:	2b00      	cmp	r3, #0
 8012624:	d1ee      	bne.n	8012604 <obj_to_foreground+0x12>
    }

    if(last_top != NULL) {
 8012626:	68bb      	ldr	r3, [r7, #8]
 8012628:	2b00      	cmp	r3, #0
 801262a:	d002      	beq.n	8012632 <obj_to_foreground+0x40>
        /*Move the last_top object to the foreground*/
        lv_obj_move_foreground(last_top);
 801262c:	68b8      	ldr	r0, [r7, #8]
 801262e:	f000 fbac 	bl	8012d8a <lv_obj_move_foreground>
    }
}
 8012632:	bf00      	nop
 8012634:	3710      	adds	r7, #16
 8012636:	46bd      	mov	sp, r7
 8012638:	bd80      	pop	{r7, pc}

0801263a <lv_indev_init>:

/**
 * Initialize the display input device subsystem
 */
void lv_indev_init(void)
{
 801263a:	b580      	push	{r7, lr}
 801263c:	af00      	add	r7, sp, #0
    lv_indev_reset(NULL); /*Reset all input devices*/
 801263e:	2000      	movs	r0, #0
 8012640:	f000 f80e 	bl	8012660 <lv_indev_reset>
}
 8012644:	bf00      	nop
 8012646:	bd80      	pop	{r7, pc}

08012648 <lv_indev_get_act>:
 * Get the currently processed input device. Can be used in action functions too.
 * @return pointer to the currently processed input device or NULL if no input device processing
 * right now
 */
lv_indev_t * lv_indev_get_act(void)
{
 8012648:	b480      	push	{r7}
 801264a:	af00      	add	r7, sp, #0
    return indev_act;
 801264c:	4b03      	ldr	r3, [pc, #12]	; (801265c <lv_indev_get_act+0x14>)
 801264e:	681b      	ldr	r3, [r3, #0]
}
 8012650:	4618      	mov	r0, r3
 8012652:	46bd      	mov	sp, r7
 8012654:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012658:	4770      	bx	lr
 801265a:	bf00      	nop
 801265c:	240623b4 	.word	0x240623b4

08012660 <lv_indev_reset>:
/**
 * Reset one or all input devices
 * @param indev pointer to an input device to reset or NULL to reset all of them
 */
void lv_indev_reset(lv_indev_t * indev)
{
 8012660:	b580      	push	{r7, lr}
 8012662:	b084      	sub	sp, #16
 8012664:	af00      	add	r7, sp, #0
 8012666:	6078      	str	r0, [r7, #4]
    if(indev)
 8012668:	687b      	ldr	r3, [r7, #4]
 801266a:	2b00      	cmp	r3, #0
 801266c:	d007      	beq.n	801267e <lv_indev_reset+0x1e>
        indev->proc.reset_query = 1;
 801266e:	687a      	ldr	r2, [r7, #4]
 8012670:	f892 304c 	ldrb.w	r3, [r2, #76]	; 0x4c
 8012674:	f043 0302 	orr.w	r3, r3, #2
 8012678:	f882 304c 	strb.w	r3, [r2, #76]	; 0x4c
            i->proc.reset_query = 1;

            i = lv_indev_get_next(i);
        }
    }
}
 801267c:	e012      	b.n	80126a4 <lv_indev_reset+0x44>
        lv_indev_t * i = lv_indev_get_next(NULL);
 801267e:	2000      	movs	r0, #0
 8012680:	f00a fdfc 	bl	801d27c <lv_indev_get_next>
 8012684:	60f8      	str	r0, [r7, #12]
        while(i) {
 8012686:	e00a      	b.n	801269e <lv_indev_reset+0x3e>
            i->proc.reset_query = 1;
 8012688:	68fa      	ldr	r2, [r7, #12]
 801268a:	f892 304c 	ldrb.w	r3, [r2, #76]	; 0x4c
 801268e:	f043 0302 	orr.w	r3, r3, #2
 8012692:	f882 304c 	strb.w	r3, [r2, #76]	; 0x4c
            i = lv_indev_get_next(i);
 8012696:	68f8      	ldr	r0, [r7, #12]
 8012698:	f00a fdf0 	bl	801d27c <lv_indev_get_next>
 801269c:	60f8      	str	r0, [r7, #12]
        while(i) {
 801269e:	68fb      	ldr	r3, [r7, #12]
 80126a0:	2b00      	cmp	r3, #0
 80126a2:	d1f1      	bne.n	8012688 <lv_indev_reset+0x28>
}
 80126a4:	bf00      	nop
 80126a6:	3710      	adds	r7, #16
 80126a8:	46bd      	mov	sp, r7
 80126aa:	bd80      	pop	{r7, pc}

080126ac <lv_area_copy>:
 * Copy an area
 * @param dest pointer to the destination area
 * @param src pointer to the source area
 */
inline static void lv_area_copy(lv_area_t * dest, const lv_area_t * src)
{
 80126ac:	b580      	push	{r7, lr}
 80126ae:	b082      	sub	sp, #8
 80126b0:	af00      	add	r7, sp, #0
 80126b2:	6078      	str	r0, [r7, #4]
 80126b4:	6039      	str	r1, [r7, #0]
    memcpy(dest, src, sizeof(lv_area_t));
 80126b6:	2208      	movs	r2, #8
 80126b8:	6839      	ldr	r1, [r7, #0]
 80126ba:	6878      	ldr	r0, [r7, #4]
 80126bc:	f00f facc 	bl	8021c58 <memcpy>
}
 80126c0:	bf00      	nop
 80126c2:	3708      	adds	r7, #8
 80126c4:	46bd      	mov	sp, r7
 80126c6:	bd80      	pop	{r7, pc}

080126c8 <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
 80126c8:	b480      	push	{r7}
 80126ca:	b083      	sub	sp, #12
 80126cc:	af00      	add	r7, sp, #0
 80126ce:	6078      	str	r0, [r7, #4]
    return area_p->x2 - area_p->x1 + 1;
 80126d0:	687b      	ldr	r3, [r7, #4]
 80126d2:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80126d6:	b29a      	uxth	r2, r3
 80126d8:	687b      	ldr	r3, [r7, #4]
 80126da:	f9b3 3000 	ldrsh.w	r3, [r3]
 80126de:	b29b      	uxth	r3, r3
 80126e0:	1ad3      	subs	r3, r2, r3
 80126e2:	b29b      	uxth	r3, r3
 80126e4:	3301      	adds	r3, #1
 80126e6:	b29b      	uxth	r3, r3
 80126e8:	b21b      	sxth	r3, r3
}
 80126ea:	4618      	mov	r0, r3
 80126ec:	370c      	adds	r7, #12
 80126ee:	46bd      	mov	sp, r7
 80126f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80126f4:	4770      	bx	lr

080126f6 <lv_area_get_height>:
 * Get the height of an area
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
 80126f6:	b480      	push	{r7}
 80126f8:	b083      	sub	sp, #12
 80126fa:	af00      	add	r7, sp, #0
 80126fc:	6078      	str	r0, [r7, #4]
    return area_p->y2 - area_p->y1 + 1;
 80126fe:	687b      	ldr	r3, [r7, #4]
 8012700:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8012704:	b29a      	uxth	r2, r3
 8012706:	687b      	ldr	r3, [r7, #4]
 8012708:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801270c:	b29b      	uxth	r3, r3
 801270e:	1ad3      	subs	r3, r2, r3
 8012710:	b29b      	uxth	r3, r3
 8012712:	3301      	adds	r3, #1
 8012714:	b29b      	uxth	r3, r3
 8012716:	b21b      	sxth	r3, r3
}
 8012718:	4618      	mov	r0, r3
 801271a:	370c      	adds	r7, #12
 801271c:	46bd      	mov	sp, r7
 801271e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012722:	4770      	bx	lr

08012724 <lv_init>:

/**
 * Init. the 'lv' library.
 */
void lv_init(void)
{
 8012724:	b580      	push	{r7, lr}
 8012726:	af00      	add	r7, sp, #0
    /* Do nothing if already initialized */
    if(lv_initialized) {
 8012728:	4b12      	ldr	r3, [pc, #72]	; (8012774 <lv_init+0x50>)
 801272a:	781b      	ldrb	r3, [r3, #0]
 801272c:	2b00      	cmp	r3, #0
 801272e:	d11f      	bne.n	8012770 <lv_init+0x4c>
    }

    LV_LOG_TRACE("lv_init started");

    /*Initialize the lv_misc modules*/
    lv_mem_init();
 8012730:	f00b fcb6 	bl	801e0a0 <lv_mem_init>
    lv_task_core_init();
 8012734:	f00b fd80 	bl	801e238 <lv_task_core_init>
#if LV_USE_FILESYSTEM
    lv_fs_init();
#endif

#if LV_USE_ANIMATION
    lv_anim_core_init();
 8012738:	f00a fe06 	bl	801d348 <lv_anim_core_init>
#endif

#if LV_USE_GROUP
    lv_group_init();
 801273c:	f7ff fd92 	bl	8012264 <lv_group_init>
#endif

    /*Init. the sstyles*/
    lv_style_init();
 8012740:	f002 fbc4 	bl	8014ecc <lv_style_init>

    /*Initialize the screen refresh system*/
    lv_refr_init();
 8012744:	f001 fded 	bl	8014322 <lv_refr_init>

    lv_ll_init(&LV_GC_ROOT(_lv_disp_ll), sizeof(lv_disp_t));
 8012748:	f44f 71b2 	mov.w	r1, #356	; 0x164
 801274c:	480a      	ldr	r0, [pc, #40]	; (8012778 <lv_init+0x54>)
 801274e:	f00b f9c7 	bl	801dae0 <lv_ll_init>
    lv_ll_init(&LV_GC_ROOT(_lv_indev_ll), sizeof(lv_indev_t));
 8012752:	215c      	movs	r1, #92	; 0x5c
 8012754:	4809      	ldr	r0, [pc, #36]	; (801277c <lv_init+0x58>)
 8012756:	f00b f9c3 	bl	801dae0 <lv_ll_init>

    /*Init the input device handling*/
    lv_indev_init();
 801275a:	f7ff ff6e 	bl	801263a <lv_indev_init>

    lv_img_decoder_init();
 801275e:	f009 faa3 	bl	801bca8 <lv_img_decoder_init>
    lv_img_cache_set_size(LV_IMG_CACHE_DEF_SIZE);
 8012762:	2001      	movs	r0, #1
 8012764:	f009 f9c0 	bl	801bae8 <lv_img_cache_set_size>

    lv_initialized = true;
 8012768:	4b02      	ldr	r3, [pc, #8]	; (8012774 <lv_init+0x50>)
 801276a:	2201      	movs	r2, #1
 801276c:	701a      	strb	r2, [r3, #0]
 801276e:	e000      	b.n	8012772 <lv_init+0x4e>
        return;
 8012770:	bf00      	nop
    LV_LOG_INFO("lv_init ready");
}
 8012772:	bd80      	pop	{r7, pc}
 8012774:	240623b8 	.word	0x240623b8
 8012778:	24063640 	.word	0x24063640
 801277c:	24063630 	.word	0x24063630

08012780 <lv_obj_create>:
 *                  If NULL then a screen will be created
 * @param copy pointer to a base object, if not NULL then the new object will be copied from it
 * @return pointer to the new object
 */
lv_obj_t * lv_obj_create(lv_obj_t * parent, const lv_obj_t * copy)
{
 8012780:	b590      	push	{r4, r7, lr}
 8012782:	b087      	sub	sp, #28
 8012784:	af00      	add	r7, sp, #0
 8012786:	6078      	str	r0, [r7, #4]
 8012788:	6039      	str	r1, [r7, #0]

    lv_obj_t * new_obj = NULL;
 801278a:	2300      	movs	r3, #0
 801278c:	617b      	str	r3, [r7, #20]
    /*Create a screen if the parent is NULL*/
    if(parent == NULL) {
 801278e:	687b      	ldr	r3, [r7, #4]
 8012790:	2b00      	cmp	r3, #0
 8012792:	f040 80b8 	bne.w	8012906 <lv_obj_create+0x186>
        LV_LOG_TRACE("Screen create started");
        lv_disp_t * disp = lv_disp_get_default();
 8012796:	f00a fcb1 	bl	801d0fc <lv_disp_get_default>
 801279a:	60f8      	str	r0, [r7, #12]
        if(!disp) {
 801279c:	68fb      	ldr	r3, [r7, #12]
 801279e:	2b00      	cmp	r3, #0
 80127a0:	d101      	bne.n	80127a6 <lv_obj_create+0x26>
            LV_LOG_WARN("lv_obj_create: not display created to so far. No place to assign the new screen");
            return NULL;
 80127a2:	2300      	movs	r3, #0
 80127a4:	e257      	b.n	8012c56 <lv_obj_create+0x4d6>
        }

        new_obj = lv_ll_ins_head(&disp->scr_ll);
 80127a6:	68fb      	ldr	r3, [r7, #12]
 80127a8:	3324      	adds	r3, #36	; 0x24
 80127aa:	4618      	mov	r0, r3
 80127ac:	f00b f9b8 	bl	801db20 <lv_ll_ins_head>
 80127b0:	6178      	str	r0, [r7, #20]
        lv_mem_assert(new_obj);
 80127b2:	697b      	ldr	r3, [r7, #20]
 80127b4:	2b00      	cmp	r3, #0
 80127b6:	d100      	bne.n	80127ba <lv_obj_create+0x3a>
 80127b8:	e7fe      	b.n	80127b8 <lv_obj_create+0x38>
        if(new_obj == NULL) return NULL;
 80127ba:	697b      	ldr	r3, [r7, #20]
 80127bc:	2b00      	cmp	r3, #0
 80127be:	d101      	bne.n	80127c4 <lv_obj_create+0x44>
 80127c0:	2300      	movs	r3, #0
 80127c2:	e248      	b.n	8012c56 <lv_obj_create+0x4d6>

        new_obj->par = NULL; /*Screens has no a parent*/
 80127c4:	697b      	ldr	r3, [r7, #20]
 80127c6:	2200      	movs	r2, #0
 80127c8:	601a      	str	r2, [r3, #0]
        lv_ll_init(&(new_obj->child_ll), sizeof(lv_obj_t));
 80127ca:	697b      	ldr	r3, [r7, #20]
 80127cc:	3304      	adds	r3, #4
 80127ce:	2144      	movs	r1, #68	; 0x44
 80127d0:	4618      	mov	r0, r3
 80127d2:	f00b f985 	bl	801dae0 <lv_ll_init>

        /*Set coordinates to full screen size*/
        new_obj->coords.x1    = 0;
 80127d6:	697b      	ldr	r3, [r7, #20]
 80127d8:	2200      	movs	r2, #0
 80127da:	821a      	strh	r2, [r3, #16]
        new_obj->coords.y1    = 0;
 80127dc:	697b      	ldr	r3, [r7, #20]
 80127de:	2200      	movs	r2, #0
 80127e0:	825a      	strh	r2, [r3, #18]
        new_obj->coords.x2    = lv_disp_get_hor_res(NULL) - 1;
 80127e2:	2000      	movs	r0, #0
 80127e4:	f00a fc96 	bl	801d114 <lv_disp_get_hor_res>
 80127e8:	4603      	mov	r3, r0
 80127ea:	b29b      	uxth	r3, r3
 80127ec:	3b01      	subs	r3, #1
 80127ee:	b29b      	uxth	r3, r3
 80127f0:	b21a      	sxth	r2, r3
 80127f2:	697b      	ldr	r3, [r7, #20]
 80127f4:	829a      	strh	r2, [r3, #20]
        new_obj->coords.y2    = lv_disp_get_ver_res(NULL) - 1;
 80127f6:	2000      	movs	r0, #0
 80127f8:	f00a fcae 	bl	801d158 <lv_disp_get_ver_res>
 80127fc:	4603      	mov	r3, r0
 80127fe:	b29b      	uxth	r3, r3
 8012800:	3b01      	subs	r3, #1
 8012802:	b29b      	uxth	r3, r3
 8012804:	b21a      	sxth	r2, r3
 8012806:	697b      	ldr	r3, [r7, #20]
 8012808:	82da      	strh	r2, [r3, #22]
        new_obj->ext_draw_pad = 0;
 801280a:	697b      	ldr	r3, [r7, #20]
 801280c:	2200      	movs	r2, #0
 801280e:	869a      	strh	r2, [r3, #52]	; 0x34
        new_obj->ext_click_pad_ver = 0;
#endif

        /*Init realign*/
#if LV_USE_OBJ_REALIGN
        new_obj->realign.align        = LV_ALIGN_CENTER;
 8012810:	697b      	ldr	r3, [r7, #20]
 8012812:	2200      	movs	r2, #0
 8012814:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        new_obj->realign.xofs         = 0;
 8012818:	697b      	ldr	r3, [r7, #20]
 801281a:	2200      	movs	r2, #0
 801281c:	879a      	strh	r2, [r3, #60]	; 0x3c
        new_obj->realign.yofs         = 0;
 801281e:	697b      	ldr	r3, [r7, #20]
 8012820:	2200      	movs	r2, #0
 8012822:	87da      	strh	r2, [r3, #62]	; 0x3e
        new_obj->realign.base         = NULL;
 8012824:	697b      	ldr	r3, [r7, #20]
 8012826:	2200      	movs	r2, #0
 8012828:	639a      	str	r2, [r3, #56]	; 0x38
        new_obj->realign.auto_realign = 0;
 801282a:	697a      	ldr	r2, [r7, #20]
 801282c:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 8012830:	f36f 0300 	bfc	r3, #0, #1
 8012834:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
#endif

        /*Set the default styles*/
        lv_theme_t * th = lv_theme_get_current();
 8012838:	f00e fc74 	bl	8021124 <lv_theme_get_current>
 801283c:	60b8      	str	r0, [r7, #8]
        if(th) {
 801283e:	68bb      	ldr	r3, [r7, #8]
 8012840:	2b00      	cmp	r3, #0
 8012842:	d004      	beq.n	801284e <lv_obj_create+0xce>
            new_obj->style_p = th->style.scr;
 8012844:	68bb      	ldr	r3, [r7, #8]
 8012846:	681a      	ldr	r2, [r3, #0]
 8012848:	697b      	ldr	r3, [r7, #20]
 801284a:	629a      	str	r2, [r3, #40]	; 0x28
 801284c:	e002      	b.n	8012854 <lv_obj_create+0xd4>
        } else {
            new_obj->style_p = &lv_style_scr;
 801284e:	697b      	ldr	r3, [r7, #20]
 8012850:	4a58      	ldr	r2, [pc, #352]	; (80129b4 <lv_obj_create+0x234>)
 8012852:	629a      	str	r2, [r3, #40]	; 0x28
        }
        /*Set the callbacks*/
        lv_obj_set_signal_cb(new_obj, lv_obj_signal);
 8012854:	4958      	ldr	r1, [pc, #352]	; (80129b8 <lv_obj_create+0x238>)
 8012856:	6978      	ldr	r0, [r7, #20]
 8012858:	f001 f9d8 	bl	8013c0c <lv_obj_set_signal_cb>
        lv_obj_set_design_cb(new_obj, lv_obj_design);
 801285c:	4957      	ldr	r1, [pc, #348]	; (80129bc <lv_obj_create+0x23c>)
 801285e:	6978      	ldr	r0, [r7, #20]
 8012860:	f001 f9e2 	bl	8013c28 <lv_obj_set_design_cb>
        new_obj->event_cb = NULL;
 8012864:	697b      	ldr	r3, [r7, #20]
 8012866:	2200      	movs	r2, #0
 8012868:	619a      	str	r2, [r3, #24]
#if LV_USE_USER_DATA
        memset(&new_obj->user_data, 0, sizeof(lv_obj_user_data_t));
#endif

#if LV_USE_GROUP
        new_obj->group_p = NULL;
 801286a:	697b      	ldr	r3, [r7, #20]
 801286c:	2200      	movs	r2, #0
 801286e:	62da      	str	r2, [r3, #44]	; 0x2c
#endif
        /*Set attributes*/
        new_obj->click        = 0;
 8012870:	697a      	ldr	r2, [r7, #20]
 8012872:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8012876:	f36f 0300 	bfc	r3, #0, #1
 801287a:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->drag         = 0;
 801287e:	697a      	ldr	r2, [r7, #20]
 8012880:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8012884:	f36f 0341 	bfc	r3, #1, #1
 8012888:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->drag_throw   = 0;
 801288c:	697a      	ldr	r2, [r7, #20]
 801288e:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8012892:	f36f 0382 	bfc	r3, #2, #1
 8012896:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->drag_parent  = 0;
 801289a:	697a      	ldr	r2, [r7, #20]
 801289c:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 80128a0:	f36f 03c3 	bfc	r3, #3, #1
 80128a4:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->hidden       = 0;
 80128a8:	697a      	ldr	r2, [r7, #20]
 80128aa:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 80128ae:	f36f 1304 	bfc	r3, #4, #1
 80128b2:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->top          = 0;
 80128b6:	697a      	ldr	r2, [r7, #20]
 80128b8:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 80128bc:	f36f 1345 	bfc	r3, #5, #1
 80128c0:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->protect      = LV_PROTECT_NONE;
 80128c4:	697b      	ldr	r3, [r7, #20]
 80128c6:	2200      	movs	r2, #0
 80128c8:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
        new_obj->opa_scale_en = 0;
 80128cc:	697a      	ldr	r2, [r7, #20]
 80128ce:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 80128d2:	f36f 1386 	bfc	r3, #6, #1
 80128d6:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->opa_scale    = LV_OPA_COVER;
 80128da:	697b      	ldr	r3, [r7, #20]
 80128dc:	22ff      	movs	r2, #255	; 0xff
 80128de:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33
        new_obj->parent_event = 0;
 80128e2:	697a      	ldr	r2, [r7, #20]
 80128e4:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 80128e8:	f36f 13c7 	bfc	r3, #7, #1
 80128ec:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->reserved     = 0;
 80128f0:	697a      	ldr	r2, [r7, #20]
 80128f2:	f892 3031 	ldrb.w	r3, [r2, #49]	; 0x31
 80128f6:	f36f 0387 	bfc	r3, #2, #6
 80128fa:	f882 3031 	strb.w	r3, [r2, #49]	; 0x31

        new_obj->ext_attr = NULL;
 80128fe:	697b      	ldr	r3, [r7, #20]
 8012900:	2200      	movs	r2, #0
 8012902:	625a      	str	r2, [r3, #36]	; 0x24
 8012904:	e0b7      	b.n	8012a76 <lv_obj_create+0x2f6>
    }
    /*parent != NULL create normal obj. on a parent*/
    else {
        LV_LOG_TRACE("Object create started");

        new_obj = lv_ll_ins_head(&parent->child_ll);
 8012906:	687b      	ldr	r3, [r7, #4]
 8012908:	3304      	adds	r3, #4
 801290a:	4618      	mov	r0, r3
 801290c:	f00b f908 	bl	801db20 <lv_ll_ins_head>
 8012910:	6178      	str	r0, [r7, #20]
        lv_mem_assert(new_obj);
 8012912:	697b      	ldr	r3, [r7, #20]
 8012914:	2b00      	cmp	r3, #0
 8012916:	d100      	bne.n	801291a <lv_obj_create+0x19a>
 8012918:	e7fe      	b.n	8012918 <lv_obj_create+0x198>
        if(new_obj == NULL) return NULL;
 801291a:	697b      	ldr	r3, [r7, #20]
 801291c:	2b00      	cmp	r3, #0
 801291e:	d101      	bne.n	8012924 <lv_obj_create+0x1a4>
 8012920:	2300      	movs	r3, #0
 8012922:	e198      	b.n	8012c56 <lv_obj_create+0x4d6>

        new_obj->par = parent; /*Set the parent*/
 8012924:	697b      	ldr	r3, [r7, #20]
 8012926:	687a      	ldr	r2, [r7, #4]
 8012928:	601a      	str	r2, [r3, #0]
        lv_ll_init(&(new_obj->child_ll), sizeof(lv_obj_t));
 801292a:	697b      	ldr	r3, [r7, #20]
 801292c:	3304      	adds	r3, #4
 801292e:	2144      	movs	r1, #68	; 0x44
 8012930:	4618      	mov	r0, r3
 8012932:	f00b f8d5 	bl	801dae0 <lv_ll_init>

        /*Set coordinates left top corner of parent*/
        new_obj->coords.x1    = parent->coords.x1;
 8012936:	687b      	ldr	r3, [r7, #4]
 8012938:	f9b3 2010 	ldrsh.w	r2, [r3, #16]
 801293c:	697b      	ldr	r3, [r7, #20]
 801293e:	821a      	strh	r2, [r3, #16]
        new_obj->coords.y1    = parent->coords.y1;
 8012940:	687b      	ldr	r3, [r7, #4]
 8012942:	f9b3 2012 	ldrsh.w	r2, [r3, #18]
 8012946:	697b      	ldr	r3, [r7, #20]
 8012948:	825a      	strh	r2, [r3, #18]
        new_obj->coords.x2    = parent->coords.x1 + LV_OBJ_DEF_WIDTH;
 801294a:	687b      	ldr	r3, [r7, #4]
 801294c:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8012950:	b29b      	uxth	r3, r3
 8012952:	3355      	adds	r3, #85	; 0x55
 8012954:	b29b      	uxth	r3, r3
 8012956:	b21a      	sxth	r2, r3
 8012958:	697b      	ldr	r3, [r7, #20]
 801295a:	829a      	strh	r2, [r3, #20]
        new_obj->coords.y2    = parent->coords.y1 + LV_OBJ_DEF_HEIGHT;
 801295c:	687b      	ldr	r3, [r7, #4]
 801295e:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8012962:	b29b      	uxth	r3, r3
 8012964:	3338      	adds	r3, #56	; 0x38
 8012966:	b29b      	uxth	r3, r3
 8012968:	b21a      	sxth	r2, r3
 801296a:	697b      	ldr	r3, [r7, #20]
 801296c:	82da      	strh	r2, [r3, #22]
        new_obj->ext_draw_pad = 0;
 801296e:	697b      	ldr	r3, [r7, #20]
 8012970:	2200      	movs	r2, #0
 8012972:	869a      	strh	r2, [r3, #52]	; 0x34
        new_obj->ext_click_pad_ver = 0;
#endif

        /*Init realign*/
#if LV_USE_OBJ_REALIGN
        new_obj->realign.align        = LV_ALIGN_CENTER;
 8012974:	697b      	ldr	r3, [r7, #20]
 8012976:	2200      	movs	r2, #0
 8012978:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        new_obj->realign.xofs         = 0;
 801297c:	697b      	ldr	r3, [r7, #20]
 801297e:	2200      	movs	r2, #0
 8012980:	879a      	strh	r2, [r3, #60]	; 0x3c
        new_obj->realign.yofs         = 0;
 8012982:	697b      	ldr	r3, [r7, #20]
 8012984:	2200      	movs	r2, #0
 8012986:	87da      	strh	r2, [r3, #62]	; 0x3e
        new_obj->realign.base         = NULL;
 8012988:	697b      	ldr	r3, [r7, #20]
 801298a:	2200      	movs	r2, #0
 801298c:	639a      	str	r2, [r3, #56]	; 0x38
        new_obj->realign.auto_realign = 0;
 801298e:	697a      	ldr	r2, [r7, #20]
 8012990:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 8012994:	f36f 0300 	bfc	r3, #0, #1
 8012998:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
#endif
        /*Set appearance*/
        lv_theme_t * th = lv_theme_get_current();
 801299c:	f00e fbc2 	bl	8021124 <lv_theme_get_current>
 80129a0:	6138      	str	r0, [r7, #16]
        if(th) {
 80129a2:	693b      	ldr	r3, [r7, #16]
 80129a4:	2b00      	cmp	r3, #0
 80129a6:	d00b      	beq.n	80129c0 <lv_obj_create+0x240>
            new_obj->style_p = th->style.panel;
 80129a8:	693b      	ldr	r3, [r7, #16]
 80129aa:	689a      	ldr	r2, [r3, #8]
 80129ac:	697b      	ldr	r3, [r7, #20]
 80129ae:	629a      	str	r2, [r3, #40]	; 0x28
 80129b0:	e009      	b.n	80129c6 <lv_obj_create+0x246>
 80129b2:	bf00      	nop
 80129b4:	24063570 	.word	0x24063570
 80129b8:	08014131 	.word	0x08014131
 80129bc:	08014017 	.word	0x08014017
        } else {
            new_obj->style_p = &lv_style_plain_color;
 80129c0:	697b      	ldr	r3, [r7, #20]
 80129c2:	4aa7      	ldr	r2, [pc, #668]	; (8012c60 <lv_obj_create+0x4e0>)
 80129c4:	629a      	str	r2, [r3, #40]	; 0x28
        }

        /*Set the callbacks*/
        lv_obj_set_signal_cb(new_obj, lv_obj_signal);
 80129c6:	49a7      	ldr	r1, [pc, #668]	; (8012c64 <lv_obj_create+0x4e4>)
 80129c8:	6978      	ldr	r0, [r7, #20]
 80129ca:	f001 f91f 	bl	8013c0c <lv_obj_set_signal_cb>
        lv_obj_set_design_cb(new_obj, lv_obj_design);
 80129ce:	49a6      	ldr	r1, [pc, #664]	; (8012c68 <lv_obj_create+0x4e8>)
 80129d0:	6978      	ldr	r0, [r7, #20]
 80129d2:	f001 f929 	bl	8013c28 <lv_obj_set_design_cb>
        new_obj->event_cb = NULL;
 80129d6:	697b      	ldr	r3, [r7, #20]
 80129d8:	2200      	movs	r2, #0
 80129da:	619a      	str	r2, [r3, #24]
#if LV_USE_USER_DATA
        memset(&new_obj->user_data, 0, sizeof(lv_obj_user_data_t));
#endif

#if LV_USE_GROUP
        new_obj->group_p = NULL;
 80129dc:	697b      	ldr	r3, [r7, #20]
 80129de:	2200      	movs	r2, #0
 80129e0:	62da      	str	r2, [r3, #44]	; 0x2c
#endif

        /*Set attributes*/
        new_obj->click        = 1;
 80129e2:	697a      	ldr	r2, [r7, #20]
 80129e4:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 80129e8:	f043 0301 	orr.w	r3, r3, #1
 80129ec:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->drag         = 0;
 80129f0:	697a      	ldr	r2, [r7, #20]
 80129f2:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 80129f6:	f36f 0341 	bfc	r3, #1, #1
 80129fa:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->drag_dir     = LV_DRAG_DIR_ALL;
 80129fe:	697a      	ldr	r2, [r7, #20]
 8012a00:	f892 3031 	ldrb.w	r3, [r2, #49]	; 0x31
 8012a04:	f043 0303 	orr.w	r3, r3, #3
 8012a08:	f882 3031 	strb.w	r3, [r2, #49]	; 0x31
        new_obj->drag_throw   = 0;
 8012a0c:	697a      	ldr	r2, [r7, #20]
 8012a0e:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8012a12:	f36f 0382 	bfc	r3, #2, #1
 8012a16:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->drag_parent  = 0;
 8012a1a:	697a      	ldr	r2, [r7, #20]
 8012a1c:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8012a20:	f36f 03c3 	bfc	r3, #3, #1
 8012a24:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->hidden       = 0;
 8012a28:	697a      	ldr	r2, [r7, #20]
 8012a2a:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8012a2e:	f36f 1304 	bfc	r3, #4, #1
 8012a32:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->top          = 0;
 8012a36:	697a      	ldr	r2, [r7, #20]
 8012a38:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8012a3c:	f36f 1345 	bfc	r3, #5, #1
 8012a40:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->protect      = LV_PROTECT_NONE;
 8012a44:	697b      	ldr	r3, [r7, #20]
 8012a46:	2200      	movs	r2, #0
 8012a48:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
        new_obj->opa_scale    = LV_OPA_COVER;
 8012a4c:	697b      	ldr	r3, [r7, #20]
 8012a4e:	22ff      	movs	r2, #255	; 0xff
 8012a50:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33
        new_obj->opa_scale_en = 0;
 8012a54:	697a      	ldr	r2, [r7, #20]
 8012a56:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8012a5a:	f36f 1386 	bfc	r3, #6, #1
 8012a5e:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->parent_event = 0;
 8012a62:	697a      	ldr	r2, [r7, #20]
 8012a64:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8012a68:	f36f 13c7 	bfc	r3, #7, #1
 8012a6c:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30

        new_obj->ext_attr = NULL;
 8012a70:	697b      	ldr	r3, [r7, #20]
 8012a72:	2200      	movs	r2, #0
 8012a74:	625a      	str	r2, [r3, #36]	; 0x24
    }

    /*Copy the attributes if required*/
    if(copy != NULL) {
 8012a76:	683b      	ldr	r3, [r7, #0]
 8012a78:	2b00      	cmp	r3, #0
 8012a7a:	f000 80df 	beq.w	8012c3c <lv_obj_create+0x4bc>
        lv_area_copy(&new_obj->coords, &copy->coords);
 8012a7e:	697b      	ldr	r3, [r7, #20]
 8012a80:	f103 0210 	add.w	r2, r3, #16
 8012a84:	683b      	ldr	r3, [r7, #0]
 8012a86:	3310      	adds	r3, #16
 8012a88:	4619      	mov	r1, r3
 8012a8a:	4610      	mov	r0, r2
 8012a8c:	f7ff fe0e 	bl	80126ac <lv_area_copy>
        new_obj->ext_draw_pad = copy->ext_draw_pad;
 8012a90:	683b      	ldr	r3, [r7, #0]
 8012a92:	f9b3 2034 	ldrsh.w	r2, [r3, #52]	; 0x34
 8012a96:	697b      	ldr	r3, [r7, #20]
 8012a98:	869a      	strh	r2, [r3, #52]	; 0x34
#if LV_USE_USER_DATA
        memcpy(&new_obj->user_data, &copy->user_data, sizeof(lv_obj_user_data_t));
#endif
        /*Copy realign*/
#if LV_USE_OBJ_REALIGN
        new_obj->realign.align        = copy->realign.align;
 8012a9a:	683b      	ldr	r3, [r7, #0]
 8012a9c:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
 8012aa0:	697b      	ldr	r3, [r7, #20]
 8012aa2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        new_obj->realign.xofs         = copy->realign.xofs;
 8012aa6:	683b      	ldr	r3, [r7, #0]
 8012aa8:	f9b3 203c 	ldrsh.w	r2, [r3, #60]	; 0x3c
 8012aac:	697b      	ldr	r3, [r7, #20]
 8012aae:	879a      	strh	r2, [r3, #60]	; 0x3c
        new_obj->realign.yofs         = copy->realign.yofs;
 8012ab0:	683b      	ldr	r3, [r7, #0]
 8012ab2:	f9b3 203e 	ldrsh.w	r2, [r3, #62]	; 0x3e
 8012ab6:	697b      	ldr	r3, [r7, #20]
 8012ab8:	87da      	strh	r2, [r3, #62]	; 0x3e
        new_obj->realign.base         = copy->realign.base;
 8012aba:	683b      	ldr	r3, [r7, #0]
 8012abc:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8012abe:	697b      	ldr	r3, [r7, #20]
 8012ac0:	639a      	str	r2, [r3, #56]	; 0x38
        new_obj->realign.auto_realign = copy->realign.auto_realign;
 8012ac2:	683b      	ldr	r3, [r7, #0]
 8012ac4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8012ac8:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8012acc:	b2d9      	uxtb	r1, r3
 8012ace:	697a      	ldr	r2, [r7, #20]
 8012ad0:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 8012ad4:	f361 0300 	bfi	r3, r1, #0, #1
 8012ad8:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
#endif

        /*Only copy the `event_cb`. `signal_cb` and `design_cb` will be copied the the derived
         * object type (e.g. `lv_btn`)*/
        new_obj->event_cb = copy->event_cb;
 8012adc:	683b      	ldr	r3, [r7, #0]
 8012ade:	699a      	ldr	r2, [r3, #24]
 8012ae0:	697b      	ldr	r3, [r7, #20]
 8012ae2:	619a      	str	r2, [r3, #24]

        /*Copy attributes*/
        new_obj->click        = copy->click;
 8012ae4:	683b      	ldr	r3, [r7, #0]
 8012ae6:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8012aea:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8012aee:	b2d9      	uxtb	r1, r3
 8012af0:	697a      	ldr	r2, [r7, #20]
 8012af2:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8012af6:	f361 0300 	bfi	r3, r1, #0, #1
 8012afa:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->drag         = copy->drag;
 8012afe:	683b      	ldr	r3, [r7, #0]
 8012b00:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8012b04:	f3c3 0340 	ubfx	r3, r3, #1, #1
 8012b08:	b2d9      	uxtb	r1, r3
 8012b0a:	697a      	ldr	r2, [r7, #20]
 8012b0c:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8012b10:	f361 0341 	bfi	r3, r1, #1, #1
 8012b14:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->drag_dir     = copy->drag_dir;
 8012b18:	683b      	ldr	r3, [r7, #0]
 8012b1a:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 8012b1e:	f3c3 0301 	ubfx	r3, r3, #0, #2
 8012b22:	b2d9      	uxtb	r1, r3
 8012b24:	697a      	ldr	r2, [r7, #20]
 8012b26:	f892 3031 	ldrb.w	r3, [r2, #49]	; 0x31
 8012b2a:	f361 0301 	bfi	r3, r1, #0, #2
 8012b2e:	f882 3031 	strb.w	r3, [r2, #49]	; 0x31
        new_obj->drag_throw   = copy->drag_throw;
 8012b32:	683b      	ldr	r3, [r7, #0]
 8012b34:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8012b38:	f3c3 0380 	ubfx	r3, r3, #2, #1
 8012b3c:	b2d9      	uxtb	r1, r3
 8012b3e:	697a      	ldr	r2, [r7, #20]
 8012b40:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8012b44:	f361 0382 	bfi	r3, r1, #2, #1
 8012b48:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->drag_parent  = copy->drag_parent;
 8012b4c:	683b      	ldr	r3, [r7, #0]
 8012b4e:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8012b52:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 8012b56:	b2d9      	uxtb	r1, r3
 8012b58:	697a      	ldr	r2, [r7, #20]
 8012b5a:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8012b5e:	f361 03c3 	bfi	r3, r1, #3, #1
 8012b62:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->hidden       = copy->hidden;
 8012b66:	683b      	ldr	r3, [r7, #0]
 8012b68:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8012b6c:	f3c3 1300 	ubfx	r3, r3, #4, #1
 8012b70:	b2d9      	uxtb	r1, r3
 8012b72:	697a      	ldr	r2, [r7, #20]
 8012b74:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8012b78:	f361 1304 	bfi	r3, r1, #4, #1
 8012b7c:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->top          = copy->top;
 8012b80:	683b      	ldr	r3, [r7, #0]
 8012b82:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8012b86:	f3c3 1340 	ubfx	r3, r3, #5, #1
 8012b8a:	b2d9      	uxtb	r1, r3
 8012b8c:	697a      	ldr	r2, [r7, #20]
 8012b8e:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8012b92:	f361 1345 	bfi	r3, r1, #5, #1
 8012b96:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->parent_event = copy->parent_event;
 8012b9a:	683b      	ldr	r3, [r7, #0]
 8012b9c:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8012ba0:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 8012ba4:	b2d9      	uxtb	r1, r3
 8012ba6:	697a      	ldr	r2, [r7, #20]
 8012ba8:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8012bac:	f361 13c7 	bfi	r3, r1, #7, #1
 8012bb0:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30

        new_obj->opa_scale_en = copy->opa_scale_en;
 8012bb4:	683b      	ldr	r3, [r7, #0]
 8012bb6:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8012bba:	f3c3 1380 	ubfx	r3, r3, #6, #1
 8012bbe:	b2d9      	uxtb	r1, r3
 8012bc0:	697a      	ldr	r2, [r7, #20]
 8012bc2:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8012bc6:	f361 1386 	bfi	r3, r1, #6, #1
 8012bca:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->protect      = copy->protect;
 8012bce:	683b      	ldr	r3, [r7, #0]
 8012bd0:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
 8012bd4:	697b      	ldr	r3, [r7, #20]
 8012bd6:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
        new_obj->opa_scale    = copy->opa_scale;
 8012bda:	683b      	ldr	r3, [r7, #0]
 8012bdc:	f893 2033 	ldrb.w	r2, [r3, #51]	; 0x33
 8012be0:	697b      	ldr	r3, [r7, #20]
 8012be2:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33

        new_obj->style_p = copy->style_p;
 8012be6:	683b      	ldr	r3, [r7, #0]
 8012be8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8012bea:	697b      	ldr	r3, [r7, #20]
 8012bec:	629a      	str	r2, [r3, #40]	; 0x28

#if LV_USE_GROUP
        /*Add to the same group*/
        if(copy->group_p != NULL) {
 8012bee:	683b      	ldr	r3, [r7, #0]
 8012bf0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8012bf2:	2b00      	cmp	r3, #0
 8012bf4:	d005      	beq.n	8012c02 <lv_obj_create+0x482>
            lv_group_add_obj(copy->group_p, new_obj);
 8012bf6:	683b      	ldr	r3, [r7, #0]
 8012bf8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8012bfa:	6979      	ldr	r1, [r7, #20]
 8012bfc:	4618      	mov	r0, r3
 8012bfe:	f7ff fb3b 	bl	8012278 <lv_group_add_obj>
        }
#endif

        /*Set the same coordinates for non screen objects*/
        if(lv_obj_get_parent(copy) != NULL && parent != NULL) {
 8012c02:	6838      	ldr	r0, [r7, #0]
 8012c04:	f001 f896 	bl	8013d34 <lv_obj_get_parent>
 8012c08:	4603      	mov	r3, r0
 8012c0a:	2b00      	cmp	r3, #0
 8012c0c:	d011      	beq.n	8012c32 <lv_obj_create+0x4b2>
 8012c0e:	687b      	ldr	r3, [r7, #4]
 8012c10:	2b00      	cmp	r3, #0
 8012c12:	d00e      	beq.n	8012c32 <lv_obj_create+0x4b2>
            lv_obj_set_pos(new_obj, lv_obj_get_x(copy), lv_obj_get_y(copy));
 8012c14:	6838      	ldr	r0, [r7, #0]
 8012c16:	f001 f8c5 	bl	8013da4 <lv_obj_get_x>
 8012c1a:	4603      	mov	r3, r0
 8012c1c:	461c      	mov	r4, r3
 8012c1e:	6838      	ldr	r0, [r7, #0]
 8012c20:	f001 f8d9 	bl	8013dd6 <lv_obj_get_y>
 8012c24:	4603      	mov	r3, r0
 8012c26:	461a      	mov	r2, r3
 8012c28:	4621      	mov	r1, r4
 8012c2a:	6978      	ldr	r0, [r7, #20]
 8012c2c:	f000 f8d7 	bl	8012dde <lv_obj_set_pos>
 8012c30:	e004      	b.n	8012c3c <lv_obj_create+0x4bc>
        } else {
            lv_obj_set_pos(new_obj, 0, 0);
 8012c32:	2200      	movs	r2, #0
 8012c34:	2100      	movs	r1, #0
 8012c36:	6978      	ldr	r0, [r7, #20]
 8012c38:	f000 f8d1 	bl	8012dde <lv_obj_set_pos>

        LV_LOG_INFO("Object create ready");
    }

    /*Send a signal to the parent to notify it about the new child*/
    if(parent != NULL) {
 8012c3c:	687b      	ldr	r3, [r7, #4]
 8012c3e:	2b00      	cmp	r3, #0
 8012c40:	d008      	beq.n	8012c54 <lv_obj_create+0x4d4>
        parent->signal_cb(parent, LV_SIGNAL_CHILD_CHG, new_obj);
 8012c42:	687b      	ldr	r3, [r7, #4]
 8012c44:	69db      	ldr	r3, [r3, #28]
 8012c46:	697a      	ldr	r2, [r7, #20]
 8012c48:	2101      	movs	r1, #1
 8012c4a:	6878      	ldr	r0, [r7, #4]
 8012c4c:	4798      	blx	r3

        /*Invalidate the area if not screen created*/
        lv_obj_invalidate(new_obj);
 8012c4e:	6978      	ldr	r0, [r7, #20]
 8012c50:	f000 f80c 	bl	8012c6c <lv_obj_invalidate>
    }

    return new_obj;
 8012c54:	697b      	ldr	r3, [r7, #20]
}
 8012c56:	4618      	mov	r0, r3
 8012c58:	371c      	adds	r7, #28
 8012c5a:	46bd      	mov	sp, r7
 8012c5c:	bd90      	pop	{r4, r7, pc}
 8012c5e:	bf00      	nop
 8012c60:	240635e8 	.word	0x240635e8
 8012c64:	08014131 	.word	0x08014131
 8012c68:	08014017 	.word	0x08014017

08012c6c <lv_obj_invalidate>:
/**
 * Mark the object as invalid therefore its current position will be redrawn by 'lv_refr_task'
 * @param obj pointer to an object
 */
void lv_obj_invalidate(const lv_obj_t * obj)
{
 8012c6c:	b580      	push	{r7, lr}
 8012c6e:	b08a      	sub	sp, #40	; 0x28
 8012c70:	af00      	add	r7, sp, #0
 8012c72:	6078      	str	r0, [r7, #4]
    if(lv_obj_get_hidden(obj)) return;
 8012c74:	6878      	ldr	r0, [r7, #4]
 8012c76:	f001 f93b 	bl	8013ef0 <lv_obj_get_hidden>
 8012c7a:	4603      	mov	r3, r0
 8012c7c:	2b00      	cmp	r3, #0
 8012c7e:	d17e      	bne.n	8012d7e <lv_obj_invalidate+0x112>

    /*Invalidate the object only if it belongs to the 'LV_GC_ROOT(_lv_act_scr)'*/
    lv_obj_t * obj_scr = lv_obj_get_screen(obj);
 8012c80:	6878      	ldr	r0, [r7, #4]
 8012c82:	f001 f809 	bl	8013c98 <lv_obj_get_screen>
 8012c86:	61f8      	str	r0, [r7, #28]
    lv_disp_t * disp   = lv_obj_get_disp(obj_scr);
 8012c88:	69f8      	ldr	r0, [r7, #28]
 8012c8a:	f001 f819 	bl	8013cc0 <lv_obj_get_disp>
 8012c8e:	61b8      	str	r0, [r7, #24]
    if(obj_scr == lv_disp_get_scr_act(disp) || obj_scr == lv_disp_get_layer_top(disp) ||
 8012c90:	69b8      	ldr	r0, [r7, #24]
 8012c92:	f7ff faa7 	bl	80121e4 <lv_disp_get_scr_act>
 8012c96:	4602      	mov	r2, r0
 8012c98:	69fb      	ldr	r3, [r7, #28]
 8012c9a:	4293      	cmp	r3, r2
 8012c9c:	d00d      	beq.n	8012cba <lv_obj_invalidate+0x4e>
 8012c9e:	69b8      	ldr	r0, [r7, #24]
 8012ca0:	f7ff fab5 	bl	801220e <lv_disp_get_layer_top>
 8012ca4:	4602      	mov	r2, r0
 8012ca6:	69fb      	ldr	r3, [r7, #28]
 8012ca8:	4293      	cmp	r3, r2
 8012caa:	d006      	beq.n	8012cba <lv_obj_invalidate+0x4e>
       obj_scr == lv_disp_get_layer_sys(disp)) {
 8012cac:	69b8      	ldr	r0, [r7, #24]
 8012cae:	f7ff fac3 	bl	8012238 <lv_disp_get_layer_sys>
 8012cb2:	4602      	mov	r2, r0
    if(obj_scr == lv_disp_get_scr_act(disp) || obj_scr == lv_disp_get_layer_top(disp) ||
 8012cb4:	69fb      	ldr	r3, [r7, #28]
 8012cb6:	4293      	cmp	r3, r2
 8012cb8:	d164      	bne.n	8012d84 <lv_obj_invalidate+0x118>
        /*Truncate recursively to the parents*/
        lv_area_t area_trunc;
        lv_obj_t * par = lv_obj_get_parent(obj);
 8012cba:	6878      	ldr	r0, [r7, #4]
 8012cbc:	f001 f83a 	bl	8013d34 <lv_obj_get_parent>
 8012cc0:	6278      	str	r0, [r7, #36]	; 0x24
        bool union_ok  = true;
 8012cc2:	2301      	movs	r3, #1
 8012cc4:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
        /*Start with the original coordinates*/
        lv_coord_t ext_size = obj->ext_draw_pad;
 8012cc8:	687b      	ldr	r3, [r7, #4]
 8012cca:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 8012ccc:	82fb      	strh	r3, [r7, #22]
        lv_area_copy(&area_trunc, &obj->coords);
 8012cce:	687b      	ldr	r3, [r7, #4]
 8012cd0:	f103 0210 	add.w	r2, r3, #16
 8012cd4:	f107 030c 	add.w	r3, r7, #12
 8012cd8:	4611      	mov	r1, r2
 8012cda:	4618      	mov	r0, r3
 8012cdc:	f7ff fce6 	bl	80126ac <lv_area_copy>
        area_trunc.x1 -= ext_size;
 8012ce0:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8012ce4:	b29a      	uxth	r2, r3
 8012ce6:	8afb      	ldrh	r3, [r7, #22]
 8012ce8:	1ad3      	subs	r3, r2, r3
 8012cea:	b29b      	uxth	r3, r3
 8012cec:	b21b      	sxth	r3, r3
 8012cee:	81bb      	strh	r3, [r7, #12]
        area_trunc.y1 -= ext_size;
 8012cf0:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8012cf4:	b29a      	uxth	r2, r3
 8012cf6:	8afb      	ldrh	r3, [r7, #22]
 8012cf8:	1ad3      	subs	r3, r2, r3
 8012cfa:	b29b      	uxth	r3, r3
 8012cfc:	b21b      	sxth	r3, r3
 8012cfe:	81fb      	strh	r3, [r7, #14]
        area_trunc.x2 += ext_size;
 8012d00:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8012d04:	b29a      	uxth	r2, r3
 8012d06:	8afb      	ldrh	r3, [r7, #22]
 8012d08:	4413      	add	r3, r2
 8012d0a:	b29b      	uxth	r3, r3
 8012d0c:	b21b      	sxth	r3, r3
 8012d0e:	823b      	strh	r3, [r7, #16]
        area_trunc.y2 += ext_size;
 8012d10:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8012d14:	b29a      	uxth	r2, r3
 8012d16:	8afb      	ldrh	r3, [r7, #22]
 8012d18:	4413      	add	r3, r2
 8012d1a:	b29b      	uxth	r3, r3
 8012d1c:	b21b      	sxth	r3, r3
 8012d1e:	827b      	strh	r3, [r7, #18]

        /*Check through all parents*/
        while(par != NULL) {
 8012d20:	e01d      	b.n	8012d5e <lv_obj_invalidate+0xf2>
            union_ok = lv_area_intersect(&area_trunc, &area_trunc, &par->coords);
 8012d22:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012d24:	f103 0210 	add.w	r2, r3, #16
 8012d28:	f107 010c 	add.w	r1, r7, #12
 8012d2c:	f107 030c 	add.w	r3, r7, #12
 8012d30:	4618      	mov	r0, r3
 8012d32:	f00a fd71 	bl	801d818 <lv_area_intersect>
 8012d36:	4603      	mov	r3, r0
 8012d38:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
            if(union_ok == false) break;       /*If no common parts with parent break;*/
 8012d3c:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8012d40:	f083 0301 	eor.w	r3, r3, #1
 8012d44:	b2db      	uxtb	r3, r3
 8012d46:	2b00      	cmp	r3, #0
 8012d48:	d10d      	bne.n	8012d66 <lv_obj_invalidate+0xfa>
            if(lv_obj_get_hidden(par)) return; /*If the parent is hidden then the child is hidden and won't be drawn*/
 8012d4a:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8012d4c:	f001 f8d0 	bl	8013ef0 <lv_obj_get_hidden>
 8012d50:	4603      	mov	r3, r0
 8012d52:	2b00      	cmp	r3, #0
 8012d54:	d115      	bne.n	8012d82 <lv_obj_invalidate+0x116>

            par = lv_obj_get_parent(par);
 8012d56:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8012d58:	f000 ffec 	bl	8013d34 <lv_obj_get_parent>
 8012d5c:	6278      	str	r0, [r7, #36]	; 0x24
        while(par != NULL) {
 8012d5e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8012d60:	2b00      	cmp	r3, #0
 8012d62:	d1de      	bne.n	8012d22 <lv_obj_invalidate+0xb6>
 8012d64:	e000      	b.n	8012d68 <lv_obj_invalidate+0xfc>
            if(union_ok == false) break;       /*If no common parts with parent break;*/
 8012d66:	bf00      	nop
        }

        if(union_ok) lv_inv_area(disp, &area_trunc);
 8012d68:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8012d6c:	2b00      	cmp	r3, #0
 8012d6e:	d009      	beq.n	8012d84 <lv_obj_invalidate+0x118>
 8012d70:	f107 030c 	add.w	r3, r7, #12
 8012d74:	4619      	mov	r1, r3
 8012d76:	69b8      	ldr	r0, [r7, #24]
 8012d78:	f001 fada 	bl	8014330 <lv_inv_area>
 8012d7c:	e002      	b.n	8012d84 <lv_obj_invalidate+0x118>
    if(lv_obj_get_hidden(obj)) return;
 8012d7e:	bf00      	nop
 8012d80:	e000      	b.n	8012d84 <lv_obj_invalidate+0x118>
            if(lv_obj_get_hidden(par)) return; /*If the parent is hidden then the child is hidden and won't be drawn*/
 8012d82:	bf00      	nop
    }
}
 8012d84:	3728      	adds	r7, #40	; 0x28
 8012d86:	46bd      	mov	sp, r7
 8012d88:	bd80      	pop	{r7, pc}

08012d8a <lv_obj_move_foreground>:
/**
 * Move and object to the foreground
 * @param obj pointer to an object
 */
void lv_obj_move_foreground(lv_obj_t * obj)
{
 8012d8a:	b580      	push	{r7, lr}
 8012d8c:	b084      	sub	sp, #16
 8012d8e:	af00      	add	r7, sp, #0
 8012d90:	6078      	str	r0, [r7, #4]
    lv_obj_t * parent = lv_obj_get_parent(obj);
 8012d92:	6878      	ldr	r0, [r7, #4]
 8012d94:	f000 ffce 	bl	8013d34 <lv_obj_get_parent>
 8012d98:	60f8      	str	r0, [r7, #12]

    /*Do nothing of already in the foreground*/
    if(lv_ll_get_head(&parent->child_ll) == obj) return;
 8012d9a:	68fb      	ldr	r3, [r7, #12]
 8012d9c:	3304      	adds	r3, #4
 8012d9e:	4618      	mov	r0, r3
 8012da0:	f00b f820 	bl	801dde4 <lv_ll_get_head>
 8012da4:	4602      	mov	r2, r0
 8012da6:	687b      	ldr	r3, [r7, #4]
 8012da8:	4293      	cmp	r3, r2
 8012daa:	d014      	beq.n	8012dd6 <lv_obj_move_foreground+0x4c>

    lv_obj_invalidate(parent);
 8012dac:	68f8      	ldr	r0, [r7, #12]
 8012dae:	f7ff ff5d 	bl	8012c6c <lv_obj_invalidate>

    lv_ll_chg_list(&parent->child_ll, &parent->child_ll, obj, true);
 8012db2:	68fb      	ldr	r3, [r7, #12]
 8012db4:	1d18      	adds	r0, r3, #4
 8012db6:	68fb      	ldr	r3, [r7, #12]
 8012db8:	1d19      	adds	r1, r3, #4
 8012dba:	2301      	movs	r3, #1
 8012dbc:	687a      	ldr	r2, [r7, #4]
 8012dbe:	f00a ffbc 	bl	801dd3a <lv_ll_chg_list>

    /*Notify the new parent about the child*/
    parent->signal_cb(parent, LV_SIGNAL_CHILD_CHG, obj);
 8012dc2:	68fb      	ldr	r3, [r7, #12]
 8012dc4:	69db      	ldr	r3, [r3, #28]
 8012dc6:	687a      	ldr	r2, [r7, #4]
 8012dc8:	2101      	movs	r1, #1
 8012dca:	68f8      	ldr	r0, [r7, #12]
 8012dcc:	4798      	blx	r3

    lv_obj_invalidate(parent);
 8012dce:	68f8      	ldr	r0, [r7, #12]
 8012dd0:	f7ff ff4c 	bl	8012c6c <lv_obj_invalidate>
 8012dd4:	e000      	b.n	8012dd8 <lv_obj_move_foreground+0x4e>
    if(lv_ll_get_head(&parent->child_ll) == obj) return;
 8012dd6:	bf00      	nop
}
 8012dd8:	3710      	adds	r7, #16
 8012dda:	46bd      	mov	sp, r7
 8012ddc:	bd80      	pop	{r7, pc}

08012dde <lv_obj_set_pos>:
 * @param obj pointer to an object
 * @param x new distance from the left side of the parent
 * @param y new distance from the top of the parent
 */
void lv_obj_set_pos(lv_obj_t * obj, lv_coord_t x, lv_coord_t y)
{
 8012dde:	b580      	push	{r7, lr}
 8012de0:	b086      	sub	sp, #24
 8012de2:	af00      	add	r7, sp, #0
 8012de4:	6078      	str	r0, [r7, #4]
 8012de6:	460b      	mov	r3, r1
 8012de8:	807b      	strh	r3, [r7, #2]
 8012dea:	4613      	mov	r3, r2
 8012dec:	803b      	strh	r3, [r7, #0]
    /*Convert x and y to absolute coordinates*/
    lv_obj_t * par = obj->par;
 8012dee:	687b      	ldr	r3, [r7, #4]
 8012df0:	681b      	ldr	r3, [r3, #0]
 8012df2:	617b      	str	r3, [r7, #20]

    x = x + par->coords.x1;
 8012df4:	697b      	ldr	r3, [r7, #20]
 8012df6:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8012dfa:	b29a      	uxth	r2, r3
 8012dfc:	887b      	ldrh	r3, [r7, #2]
 8012dfe:	4413      	add	r3, r2
 8012e00:	b29b      	uxth	r3, r3
 8012e02:	807b      	strh	r3, [r7, #2]
    y = y + par->coords.y1;
 8012e04:	697b      	ldr	r3, [r7, #20]
 8012e06:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8012e0a:	b29a      	uxth	r2, r3
 8012e0c:	883b      	ldrh	r3, [r7, #0]
 8012e0e:	4413      	add	r3, r2
 8012e10:	b29b      	uxth	r3, r3
 8012e12:	803b      	strh	r3, [r7, #0]

    /*Calculate and set the movement*/
    lv_point_t diff;
    diff.x = x - obj->coords.x1;
 8012e14:	887a      	ldrh	r2, [r7, #2]
 8012e16:	687b      	ldr	r3, [r7, #4]
 8012e18:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8012e1c:	b29b      	uxth	r3, r3
 8012e1e:	1ad3      	subs	r3, r2, r3
 8012e20:	b29b      	uxth	r3, r3
 8012e22:	b21b      	sxth	r3, r3
 8012e24:	823b      	strh	r3, [r7, #16]
    diff.y = y - obj->coords.y1;
 8012e26:	883a      	ldrh	r2, [r7, #0]
 8012e28:	687b      	ldr	r3, [r7, #4]
 8012e2a:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8012e2e:	b29b      	uxth	r3, r3
 8012e30:	1ad3      	subs	r3, r2, r3
 8012e32:	b29b      	uxth	r3, r3
 8012e34:	b21b      	sxth	r3, r3
 8012e36:	827b      	strh	r3, [r7, #18]

    /* Do nothing if the position is not changed */
    /* It is very important else recursive positioning can
     * occur without position change*/
    if(diff.x == 0 && diff.y == 0) return;
 8012e38:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8012e3c:	2b00      	cmp	r3, #0
 8012e3e:	d103      	bne.n	8012e48 <lv_obj_set_pos+0x6a>
 8012e40:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8012e44:	2b00      	cmp	r3, #0
 8012e46:	d051      	beq.n	8012eec <lv_obj_set_pos+0x10e>

    /*Invalidate the original area*/
    lv_obj_invalidate(obj);
 8012e48:	6878      	ldr	r0, [r7, #4]
 8012e4a:	f7ff ff0f 	bl	8012c6c <lv_obj_invalidate>

    /*Save the original coordinates*/
    lv_area_t ori;
    lv_obj_get_coords(obj, &ori);
 8012e4e:	f107 0308 	add.w	r3, r7, #8
 8012e52:	4619      	mov	r1, r3
 8012e54:	6878      	ldr	r0, [r7, #4]
 8012e56:	f000 ff96 	bl	8013d86 <lv_obj_get_coords>

    obj->coords.x1 += diff.x;
 8012e5a:	687b      	ldr	r3, [r7, #4]
 8012e5c:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8012e60:	b29a      	uxth	r2, r3
 8012e62:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8012e66:	b29b      	uxth	r3, r3
 8012e68:	4413      	add	r3, r2
 8012e6a:	b29b      	uxth	r3, r3
 8012e6c:	b21a      	sxth	r2, r3
 8012e6e:	687b      	ldr	r3, [r7, #4]
 8012e70:	821a      	strh	r2, [r3, #16]
    obj->coords.y1 += diff.y;
 8012e72:	687b      	ldr	r3, [r7, #4]
 8012e74:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8012e78:	b29a      	uxth	r2, r3
 8012e7a:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8012e7e:	b29b      	uxth	r3, r3
 8012e80:	4413      	add	r3, r2
 8012e82:	b29b      	uxth	r3, r3
 8012e84:	b21a      	sxth	r2, r3
 8012e86:	687b      	ldr	r3, [r7, #4]
 8012e88:	825a      	strh	r2, [r3, #18]
    obj->coords.x2 += diff.x;
 8012e8a:	687b      	ldr	r3, [r7, #4]
 8012e8c:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 8012e90:	b29a      	uxth	r2, r3
 8012e92:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8012e96:	b29b      	uxth	r3, r3
 8012e98:	4413      	add	r3, r2
 8012e9a:	b29b      	uxth	r3, r3
 8012e9c:	b21a      	sxth	r2, r3
 8012e9e:	687b      	ldr	r3, [r7, #4]
 8012ea0:	829a      	strh	r2, [r3, #20]
    obj->coords.y2 += diff.y;
 8012ea2:	687b      	ldr	r3, [r7, #4]
 8012ea4:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 8012ea8:	b29a      	uxth	r2, r3
 8012eaa:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8012eae:	b29b      	uxth	r3, r3
 8012eb0:	4413      	add	r3, r2
 8012eb2:	b29b      	uxth	r3, r3
 8012eb4:	b21a      	sxth	r2, r3
 8012eb6:	687b      	ldr	r3, [r7, #4]
 8012eb8:	82da      	strh	r2, [r3, #22]

    refresh_children_position(obj, diff.x, diff.y);
 8012eba:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8012ebe:	f9b7 2012 	ldrsh.w	r2, [r7, #18]
 8012ec2:	4619      	mov	r1, r3
 8012ec4:	6878      	ldr	r0, [r7, #4]
 8012ec6:	f001 f975 	bl	80141b4 <refresh_children_position>

    /*Inform the object about its new coordinates*/
    obj->signal_cb(obj, LV_SIGNAL_CORD_CHG, &ori);
 8012eca:	687b      	ldr	r3, [r7, #4]
 8012ecc:	69db      	ldr	r3, [r3, #28]
 8012ece:	f107 0208 	add.w	r2, r7, #8
 8012ed2:	2102      	movs	r1, #2
 8012ed4:	6878      	ldr	r0, [r7, #4]
 8012ed6:	4798      	blx	r3

    /*Send a signal to the parent too*/
    par->signal_cb(par, LV_SIGNAL_CHILD_CHG, obj);
 8012ed8:	697b      	ldr	r3, [r7, #20]
 8012eda:	69db      	ldr	r3, [r3, #28]
 8012edc:	687a      	ldr	r2, [r7, #4]
 8012ede:	2101      	movs	r1, #1
 8012ee0:	6978      	ldr	r0, [r7, #20]
 8012ee2:	4798      	blx	r3

    /*Invalidate the new area*/
    lv_obj_invalidate(obj);
 8012ee4:	6878      	ldr	r0, [r7, #4]
 8012ee6:	f7ff fec1 	bl	8012c6c <lv_obj_invalidate>
 8012eea:	e000      	b.n	8012eee <lv_obj_set_pos+0x110>
    if(diff.x == 0 && diff.y == 0) return;
 8012eec:	bf00      	nop
}
 8012eee:	3718      	adds	r7, #24
 8012ef0:	46bd      	mov	sp, r7
 8012ef2:	bd80      	pop	{r7, pc}

08012ef4 <lv_obj_set_x>:
 * Set the x coordinate of a object
 * @param obj pointer to an object
 * @param x new distance from the left side from the parent
 */
void lv_obj_set_x(lv_obj_t * obj, lv_coord_t x)
{
 8012ef4:	b580      	push	{r7, lr}
 8012ef6:	b082      	sub	sp, #8
 8012ef8:	af00      	add	r7, sp, #0
 8012efa:	6078      	str	r0, [r7, #4]
 8012efc:	460b      	mov	r3, r1
 8012efe:	807b      	strh	r3, [r7, #2]
    lv_obj_set_pos(obj, x, lv_obj_get_y(obj));
 8012f00:	6878      	ldr	r0, [r7, #4]
 8012f02:	f000 ff68 	bl	8013dd6 <lv_obj_get_y>
 8012f06:	4603      	mov	r3, r0
 8012f08:	461a      	mov	r2, r3
 8012f0a:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8012f0e:	4619      	mov	r1, r3
 8012f10:	6878      	ldr	r0, [r7, #4]
 8012f12:	f7ff ff64 	bl	8012dde <lv_obj_set_pos>
}
 8012f16:	bf00      	nop
 8012f18:	3708      	adds	r7, #8
 8012f1a:	46bd      	mov	sp, r7
 8012f1c:	bd80      	pop	{r7, pc}

08012f1e <lv_obj_set_y>:
 * Set the y coordinate of a object
 * @param obj pointer to an object
 * @param y new distance from the top of the parent
 */
void lv_obj_set_y(lv_obj_t * obj, lv_coord_t y)
{
 8012f1e:	b580      	push	{r7, lr}
 8012f20:	b082      	sub	sp, #8
 8012f22:	af00      	add	r7, sp, #0
 8012f24:	6078      	str	r0, [r7, #4]
 8012f26:	460b      	mov	r3, r1
 8012f28:	807b      	strh	r3, [r7, #2]
    lv_obj_set_pos(obj, lv_obj_get_x(obj), y);
 8012f2a:	6878      	ldr	r0, [r7, #4]
 8012f2c:	f000 ff3a 	bl	8013da4 <lv_obj_get_x>
 8012f30:	4603      	mov	r3, r0
 8012f32:	4619      	mov	r1, r3
 8012f34:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8012f38:	461a      	mov	r2, r3
 8012f3a:	6878      	ldr	r0, [r7, #4]
 8012f3c:	f7ff ff4f 	bl	8012dde <lv_obj_set_pos>
}
 8012f40:	bf00      	nop
 8012f42:	3708      	adds	r7, #8
 8012f44:	46bd      	mov	sp, r7
 8012f46:	bd80      	pop	{r7, pc}

08012f48 <lv_obj_set_size>:
 * @param obj pointer to an object
 * @param w new width
 * @param h new height
 */
void lv_obj_set_size(lv_obj_t * obj, lv_coord_t w, lv_coord_t h)
{
 8012f48:	b580      	push	{r7, lr}
 8012f4a:	b086      	sub	sp, #24
 8012f4c:	af00      	add	r7, sp, #0
 8012f4e:	6078      	str	r0, [r7, #4]
 8012f50:	460b      	mov	r3, r1
 8012f52:	807b      	strh	r3, [r7, #2]
 8012f54:	4613      	mov	r3, r2
 8012f56:	803b      	strh	r3, [r7, #0]

    /* Do nothing if the size is not changed */
    /* It is very important else recursive resizing can
     * occur without size change*/
    if(lv_obj_get_width(obj) == w && lv_obj_get_height(obj) == h) {
 8012f58:	6878      	ldr	r0, [r7, #4]
 8012f5a:	f000 ff55 	bl	8013e08 <lv_obj_get_width>
 8012f5e:	4603      	mov	r3, r0
 8012f60:	461a      	mov	r2, r3
 8012f62:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8012f66:	4293      	cmp	r3, r2
 8012f68:	d108      	bne.n	8012f7c <lv_obj_set_size+0x34>
 8012f6a:	6878      	ldr	r0, [r7, #4]
 8012f6c:	f000 ff5a 	bl	8013e24 <lv_obj_get_height>
 8012f70:	4603      	mov	r3, r0
 8012f72:	461a      	mov	r2, r3
 8012f74:	f9b7 3000 	ldrsh.w	r3, [r7]
 8012f78:	4293      	cmp	r3, r2
 8012f7a:	d05a      	beq.n	8013032 <lv_obj_set_size+0xea>
        return;
    }

    /*Invalidate the original area*/
    lv_obj_invalidate(obj);
 8012f7c:	6878      	ldr	r0, [r7, #4]
 8012f7e:	f7ff fe75 	bl	8012c6c <lv_obj_invalidate>

    /*Save the original coordinates*/
    lv_area_t ori;
    lv_obj_get_coords(obj, &ori);
 8012f82:	f107 0308 	add.w	r3, r7, #8
 8012f86:	4619      	mov	r1, r3
 8012f88:	6878      	ldr	r0, [r7, #4]
 8012f8a:	f000 fefc 	bl	8013d86 <lv_obj_get_coords>

    /*Set the length and height*/
    obj->coords.x2 = obj->coords.x1 + w - 1;
 8012f8e:	687b      	ldr	r3, [r7, #4]
 8012f90:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8012f94:	b29a      	uxth	r2, r3
 8012f96:	887b      	ldrh	r3, [r7, #2]
 8012f98:	4413      	add	r3, r2
 8012f9a:	b29b      	uxth	r3, r3
 8012f9c:	3b01      	subs	r3, #1
 8012f9e:	b29b      	uxth	r3, r3
 8012fa0:	b21a      	sxth	r2, r3
 8012fa2:	687b      	ldr	r3, [r7, #4]
 8012fa4:	829a      	strh	r2, [r3, #20]
    obj->coords.y2 = obj->coords.y1 + h - 1;
 8012fa6:	687b      	ldr	r3, [r7, #4]
 8012fa8:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8012fac:	b29a      	uxth	r2, r3
 8012fae:	883b      	ldrh	r3, [r7, #0]
 8012fb0:	4413      	add	r3, r2
 8012fb2:	b29b      	uxth	r3, r3
 8012fb4:	3b01      	subs	r3, #1
 8012fb6:	b29b      	uxth	r3, r3
 8012fb8:	b21a      	sxth	r2, r3
 8012fba:	687b      	ldr	r3, [r7, #4]
 8012fbc:	82da      	strh	r2, [r3, #22]

    /*Send a signal to the object with its new coordinates*/
    obj->signal_cb(obj, LV_SIGNAL_CORD_CHG, &ori);
 8012fbe:	687b      	ldr	r3, [r7, #4]
 8012fc0:	69db      	ldr	r3, [r3, #28]
 8012fc2:	f107 0208 	add.w	r2, r7, #8
 8012fc6:	2102      	movs	r1, #2
 8012fc8:	6878      	ldr	r0, [r7, #4]
 8012fca:	4798      	blx	r3

    /*Send a signal to the parent too*/
    lv_obj_t * par = lv_obj_get_parent(obj);
 8012fcc:	6878      	ldr	r0, [r7, #4]
 8012fce:	f000 feb1 	bl	8013d34 <lv_obj_get_parent>
 8012fd2:	6138      	str	r0, [r7, #16]
    if(par != NULL) par->signal_cb(par, LV_SIGNAL_CHILD_CHG, obj);
 8012fd4:	693b      	ldr	r3, [r7, #16]
 8012fd6:	2b00      	cmp	r3, #0
 8012fd8:	d005      	beq.n	8012fe6 <lv_obj_set_size+0x9e>
 8012fda:	693b      	ldr	r3, [r7, #16]
 8012fdc:	69db      	ldr	r3, [r3, #28]
 8012fde:	687a      	ldr	r2, [r7, #4]
 8012fe0:	2101      	movs	r1, #1
 8012fe2:	6938      	ldr	r0, [r7, #16]
 8012fe4:	4798      	blx	r3

    /*Tell the children the parent's size has changed*/
    lv_obj_t * i;
    LV_LL_READ(obj->child_ll, i)
 8012fe6:	687b      	ldr	r3, [r7, #4]
 8012fe8:	3304      	adds	r3, #4
 8012fea:	4618      	mov	r0, r3
 8012fec:	f00a fefa 	bl	801dde4 <lv_ll_get_head>
 8012ff0:	6178      	str	r0, [r7, #20]
 8012ff2:	e00c      	b.n	801300e <lv_obj_set_size+0xc6>
    {
        i->signal_cb(i, LV_SIGNAL_PARENT_SIZE_CHG, NULL);
 8012ff4:	697b      	ldr	r3, [r7, #20]
 8012ff6:	69db      	ldr	r3, [r3, #28]
 8012ff8:	2200      	movs	r2, #0
 8012ffa:	2103      	movs	r1, #3
 8012ffc:	6978      	ldr	r0, [r7, #20]
 8012ffe:	4798      	blx	r3
    LV_LL_READ(obj->child_ll, i)
 8013000:	687b      	ldr	r3, [r7, #4]
 8013002:	3304      	adds	r3, #4
 8013004:	6979      	ldr	r1, [r7, #20]
 8013006:	4618      	mov	r0, r3
 8013008:	f00a ff12 	bl	801de30 <lv_ll_get_next>
 801300c:	6178      	str	r0, [r7, #20]
 801300e:	697b      	ldr	r3, [r7, #20]
 8013010:	2b00      	cmp	r3, #0
 8013012:	d1ef      	bne.n	8012ff4 <lv_obj_set_size+0xac>
    }

    /*Invalidate the new area*/
    lv_obj_invalidate(obj);
 8013014:	6878      	ldr	r0, [r7, #4]
 8013016:	f7ff fe29 	bl	8012c6c <lv_obj_invalidate>

    /*Automatically realign the object if required*/
#if LV_USE_OBJ_REALIGN
    if(obj->realign.auto_realign) lv_obj_realign(obj);
 801301a:	687b      	ldr	r3, [r7, #4]
 801301c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8013020:	f003 0301 	and.w	r3, r3, #1
 8013024:	b2db      	uxtb	r3, r3
 8013026:	2b00      	cmp	r3, #0
 8013028:	d004      	beq.n	8013034 <lv_obj_set_size+0xec>
 801302a:	6878      	ldr	r0, [r7, #4]
 801302c:	f000 fcc4 	bl	80139b8 <lv_obj_realign>
 8013030:	e000      	b.n	8013034 <lv_obj_set_size+0xec>
        return;
 8013032:	bf00      	nop
#endif
}
 8013034:	3718      	adds	r7, #24
 8013036:	46bd      	mov	sp, r7
 8013038:	bd80      	pop	{r7, pc}

0801303a <lv_obj_set_width>:
 * Set the width of an object
 * @param obj pointer to an object
 * @param w new width
 */
void lv_obj_set_width(lv_obj_t * obj, lv_coord_t w)
{
 801303a:	b580      	push	{r7, lr}
 801303c:	b082      	sub	sp, #8
 801303e:	af00      	add	r7, sp, #0
 8013040:	6078      	str	r0, [r7, #4]
 8013042:	460b      	mov	r3, r1
 8013044:	807b      	strh	r3, [r7, #2]
    lv_obj_set_size(obj, w, lv_obj_get_height(obj));
 8013046:	6878      	ldr	r0, [r7, #4]
 8013048:	f000 feec 	bl	8013e24 <lv_obj_get_height>
 801304c:	4603      	mov	r3, r0
 801304e:	461a      	mov	r2, r3
 8013050:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8013054:	4619      	mov	r1, r3
 8013056:	6878      	ldr	r0, [r7, #4]
 8013058:	f7ff ff76 	bl	8012f48 <lv_obj_set_size>
}
 801305c:	bf00      	nop
 801305e:	3708      	adds	r7, #8
 8013060:	46bd      	mov	sp, r7
 8013062:	bd80      	pop	{r7, pc}

08013064 <lv_obj_set_height>:
 * Set the height of an object
 * @param obj pointer to an object
 * @param h new height
 */
void lv_obj_set_height(lv_obj_t * obj, lv_coord_t h)
{
 8013064:	b580      	push	{r7, lr}
 8013066:	b082      	sub	sp, #8
 8013068:	af00      	add	r7, sp, #0
 801306a:	6078      	str	r0, [r7, #4]
 801306c:	460b      	mov	r3, r1
 801306e:	807b      	strh	r3, [r7, #2]
    lv_obj_set_size(obj, lv_obj_get_width(obj), h);
 8013070:	6878      	ldr	r0, [r7, #4]
 8013072:	f000 fec9 	bl	8013e08 <lv_obj_get_width>
 8013076:	4603      	mov	r3, r0
 8013078:	4619      	mov	r1, r3
 801307a:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 801307e:	461a      	mov	r2, r3
 8013080:	6878      	ldr	r0, [r7, #4]
 8013082:	f7ff ff61 	bl	8012f48 <lv_obj_set_size>
}
 8013086:	bf00      	nop
 8013088:	3708      	adds	r7, #8
 801308a:	46bd      	mov	sp, r7
 801308c:	bd80      	pop	{r7, pc}
	...

08013090 <lv_obj_align>:
 * @param align type of alignment (see 'lv_align_t' enum)
 * @param x_mod x coordinate shift after alignment
 * @param y_mod y coordinate shift after alignment
 */
void lv_obj_align(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t x_mod, lv_coord_t y_mod)
{
 8013090:	b590      	push	{r4, r7, lr}
 8013092:	b089      	sub	sp, #36	; 0x24
 8013094:	af00      	add	r7, sp, #0
 8013096:	60f8      	str	r0, [r7, #12]
 8013098:	60b9      	str	r1, [r7, #8]
 801309a:	4611      	mov	r1, r2
 801309c:	461a      	mov	r2, r3
 801309e:	460b      	mov	r3, r1
 80130a0:	71fb      	strb	r3, [r7, #7]
 80130a2:	4613      	mov	r3, r2
 80130a4:	80bb      	strh	r3, [r7, #4]
    lv_coord_t new_x = lv_obj_get_x(obj);
 80130a6:	68f8      	ldr	r0, [r7, #12]
 80130a8:	f000 fe7c 	bl	8013da4 <lv_obj_get_x>
 80130ac:	4603      	mov	r3, r0
 80130ae:	83fb      	strh	r3, [r7, #30]
    lv_coord_t new_y = lv_obj_get_y(obj);
 80130b0:	68f8      	ldr	r0, [r7, #12]
 80130b2:	f000 fe90 	bl	8013dd6 <lv_obj_get_y>
 80130b6:	4603      	mov	r3, r0
 80130b8:	83bb      	strh	r3, [r7, #28]

    if(base == NULL) {
 80130ba:	68bb      	ldr	r3, [r7, #8]
 80130bc:	2b00      	cmp	r3, #0
 80130be:	d103      	bne.n	80130c8 <lv_obj_align+0x38>
        base = lv_obj_get_parent(obj);
 80130c0:	68f8      	ldr	r0, [r7, #12]
 80130c2:	f000 fe37 	bl	8013d34 <lv_obj_get_parent>
 80130c6:	60b8      	str	r0, [r7, #8]
    }

    switch(align) {
 80130c8:	79fb      	ldrb	r3, [r7, #7]
 80130ca:	2b14      	cmp	r3, #20
 80130cc:	f200 820d 	bhi.w	80134ea <lv_obj_align+0x45a>
 80130d0:	a201      	add	r2, pc, #4	; (adr r2, 80130d8 <lv_obj_align+0x48>)
 80130d2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80130d6:	bf00      	nop
 80130d8:	0801312d 	.word	0x0801312d
 80130dc:	0801318b 	.word	0x0801318b
 80130e0:	08013195 	.word	0x08013195
 80130e4:	080131c9 	.word	0x080131c9
 80130e8:	080131e9 	.word	0x080131e9
 80130ec:	08013209 	.word	0x08013209
 80130f0:	08013253 	.word	0x08013253
 80130f4:	08013289 	.word	0x08013289
 80130f8:	080132bd 	.word	0x080132bd
 80130fc:	08013307 	.word	0x08013307
 8013100:	0801331d 	.word	0x0801331d
 8013104:	0801335d 	.word	0x0801335d
 8013108:	08013389 	.word	0x08013389
 801310c:	08013399 	.word	0x08013399
 8013110:	080133d3 	.word	0x080133d3
 8013114:	080133f9 	.word	0x080133f9
 8013118:	0801340f 	.word	0x0801340f
 801311c:	0801344f 	.word	0x0801344f
 8013120:	0801347b 	.word	0x0801347b
 8013124:	0801348b 	.word	0x0801348b
 8013128:	080134c5 	.word	0x080134c5
        case LV_ALIGN_CENTER:
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
 801312c:	68b8      	ldr	r0, [r7, #8]
 801312e:	f000 fe6b 	bl	8013e08 <lv_obj_get_width>
 8013132:	4603      	mov	r3, r0
 8013134:	2b00      	cmp	r3, #0
 8013136:	da00      	bge.n	801313a <lv_obj_align+0xaa>
 8013138:	3301      	adds	r3, #1
 801313a:	105b      	asrs	r3, r3, #1
 801313c:	b21b      	sxth	r3, r3
 801313e:	b29c      	uxth	r4, r3
 8013140:	68f8      	ldr	r0, [r7, #12]
 8013142:	f000 fe61 	bl	8013e08 <lv_obj_get_width>
 8013146:	4603      	mov	r3, r0
 8013148:	2b00      	cmp	r3, #0
 801314a:	da00      	bge.n	801314e <lv_obj_align+0xbe>
 801314c:	3301      	adds	r3, #1
 801314e:	105b      	asrs	r3, r3, #1
 8013150:	b21b      	sxth	r3, r3
 8013152:	b29b      	uxth	r3, r3
 8013154:	1ae3      	subs	r3, r4, r3
 8013156:	b29b      	uxth	r3, r3
 8013158:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base) / 2 - lv_obj_get_height(obj) / 2;
 801315a:	68b8      	ldr	r0, [r7, #8]
 801315c:	f000 fe62 	bl	8013e24 <lv_obj_get_height>
 8013160:	4603      	mov	r3, r0
 8013162:	2b00      	cmp	r3, #0
 8013164:	da00      	bge.n	8013168 <lv_obj_align+0xd8>
 8013166:	3301      	adds	r3, #1
 8013168:	105b      	asrs	r3, r3, #1
 801316a:	b21b      	sxth	r3, r3
 801316c:	b29c      	uxth	r4, r3
 801316e:	68f8      	ldr	r0, [r7, #12]
 8013170:	f000 fe58 	bl	8013e24 <lv_obj_get_height>
 8013174:	4603      	mov	r3, r0
 8013176:	2b00      	cmp	r3, #0
 8013178:	da00      	bge.n	801317c <lv_obj_align+0xec>
 801317a:	3301      	adds	r3, #1
 801317c:	105b      	asrs	r3, r3, #1
 801317e:	b21b      	sxth	r3, r3
 8013180:	b29b      	uxth	r3, r3
 8013182:	1ae3      	subs	r3, r4, r3
 8013184:	b29b      	uxth	r3, r3
 8013186:	83bb      	strh	r3, [r7, #28]
            break;
 8013188:	e1af      	b.n	80134ea <lv_obj_align+0x45a>

        case LV_ALIGN_IN_TOP_LEFT:
            new_x = 0;
 801318a:	2300      	movs	r3, #0
 801318c:	83fb      	strh	r3, [r7, #30]
            new_y = 0;
 801318e:	2300      	movs	r3, #0
 8013190:	83bb      	strh	r3, [r7, #28]
            break;
 8013192:	e1aa      	b.n	80134ea <lv_obj_align+0x45a>
        case LV_ALIGN_IN_TOP_MID:
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
 8013194:	68b8      	ldr	r0, [r7, #8]
 8013196:	f000 fe37 	bl	8013e08 <lv_obj_get_width>
 801319a:	4603      	mov	r3, r0
 801319c:	2b00      	cmp	r3, #0
 801319e:	da00      	bge.n	80131a2 <lv_obj_align+0x112>
 80131a0:	3301      	adds	r3, #1
 80131a2:	105b      	asrs	r3, r3, #1
 80131a4:	b21b      	sxth	r3, r3
 80131a6:	b29c      	uxth	r4, r3
 80131a8:	68f8      	ldr	r0, [r7, #12]
 80131aa:	f000 fe2d 	bl	8013e08 <lv_obj_get_width>
 80131ae:	4603      	mov	r3, r0
 80131b0:	2b00      	cmp	r3, #0
 80131b2:	da00      	bge.n	80131b6 <lv_obj_align+0x126>
 80131b4:	3301      	adds	r3, #1
 80131b6:	105b      	asrs	r3, r3, #1
 80131b8:	b21b      	sxth	r3, r3
 80131ba:	b29b      	uxth	r3, r3
 80131bc:	1ae3      	subs	r3, r4, r3
 80131be:	b29b      	uxth	r3, r3
 80131c0:	83fb      	strh	r3, [r7, #30]
            new_y = 0;
 80131c2:	2300      	movs	r3, #0
 80131c4:	83bb      	strh	r3, [r7, #28]
            break;
 80131c6:	e190      	b.n	80134ea <lv_obj_align+0x45a>

        case LV_ALIGN_IN_TOP_RIGHT:
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
 80131c8:	68b8      	ldr	r0, [r7, #8]
 80131ca:	f000 fe1d 	bl	8013e08 <lv_obj_get_width>
 80131ce:	4603      	mov	r3, r0
 80131d0:	b29c      	uxth	r4, r3
 80131d2:	68f8      	ldr	r0, [r7, #12]
 80131d4:	f000 fe18 	bl	8013e08 <lv_obj_get_width>
 80131d8:	4603      	mov	r3, r0
 80131da:	b29b      	uxth	r3, r3
 80131dc:	1ae3      	subs	r3, r4, r3
 80131de:	b29b      	uxth	r3, r3
 80131e0:	83fb      	strh	r3, [r7, #30]
            new_y = 0;
 80131e2:	2300      	movs	r3, #0
 80131e4:	83bb      	strh	r3, [r7, #28]
            break;
 80131e6:	e180      	b.n	80134ea <lv_obj_align+0x45a>

        case LV_ALIGN_IN_BOTTOM_LEFT:
            new_x = 0;
 80131e8:	2300      	movs	r3, #0
 80131ea:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base) - lv_obj_get_height(obj);
 80131ec:	68b8      	ldr	r0, [r7, #8]
 80131ee:	f000 fe19 	bl	8013e24 <lv_obj_get_height>
 80131f2:	4603      	mov	r3, r0
 80131f4:	b29c      	uxth	r4, r3
 80131f6:	68f8      	ldr	r0, [r7, #12]
 80131f8:	f000 fe14 	bl	8013e24 <lv_obj_get_height>
 80131fc:	4603      	mov	r3, r0
 80131fe:	b29b      	uxth	r3, r3
 8013200:	1ae3      	subs	r3, r4, r3
 8013202:	b29b      	uxth	r3, r3
 8013204:	83bb      	strh	r3, [r7, #28]
            break;
 8013206:	e170      	b.n	80134ea <lv_obj_align+0x45a>
        case LV_ALIGN_IN_BOTTOM_MID:
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
 8013208:	68b8      	ldr	r0, [r7, #8]
 801320a:	f000 fdfd 	bl	8013e08 <lv_obj_get_width>
 801320e:	4603      	mov	r3, r0
 8013210:	2b00      	cmp	r3, #0
 8013212:	da00      	bge.n	8013216 <lv_obj_align+0x186>
 8013214:	3301      	adds	r3, #1
 8013216:	105b      	asrs	r3, r3, #1
 8013218:	b21b      	sxth	r3, r3
 801321a:	b29c      	uxth	r4, r3
 801321c:	68f8      	ldr	r0, [r7, #12]
 801321e:	f000 fdf3 	bl	8013e08 <lv_obj_get_width>
 8013222:	4603      	mov	r3, r0
 8013224:	2b00      	cmp	r3, #0
 8013226:	da00      	bge.n	801322a <lv_obj_align+0x19a>
 8013228:	3301      	adds	r3, #1
 801322a:	105b      	asrs	r3, r3, #1
 801322c:	b21b      	sxth	r3, r3
 801322e:	b29b      	uxth	r3, r3
 8013230:	1ae3      	subs	r3, r4, r3
 8013232:	b29b      	uxth	r3, r3
 8013234:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base) - lv_obj_get_height(obj);
 8013236:	68b8      	ldr	r0, [r7, #8]
 8013238:	f000 fdf4 	bl	8013e24 <lv_obj_get_height>
 801323c:	4603      	mov	r3, r0
 801323e:	b29c      	uxth	r4, r3
 8013240:	68f8      	ldr	r0, [r7, #12]
 8013242:	f000 fdef 	bl	8013e24 <lv_obj_get_height>
 8013246:	4603      	mov	r3, r0
 8013248:	b29b      	uxth	r3, r3
 801324a:	1ae3      	subs	r3, r4, r3
 801324c:	b29b      	uxth	r3, r3
 801324e:	83bb      	strh	r3, [r7, #28]
            break;
 8013250:	e14b      	b.n	80134ea <lv_obj_align+0x45a>

        case LV_ALIGN_IN_BOTTOM_RIGHT:
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
 8013252:	68b8      	ldr	r0, [r7, #8]
 8013254:	f000 fdd8 	bl	8013e08 <lv_obj_get_width>
 8013258:	4603      	mov	r3, r0
 801325a:	b29c      	uxth	r4, r3
 801325c:	68f8      	ldr	r0, [r7, #12]
 801325e:	f000 fdd3 	bl	8013e08 <lv_obj_get_width>
 8013262:	4603      	mov	r3, r0
 8013264:	b29b      	uxth	r3, r3
 8013266:	1ae3      	subs	r3, r4, r3
 8013268:	b29b      	uxth	r3, r3
 801326a:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base) - lv_obj_get_height(obj);
 801326c:	68b8      	ldr	r0, [r7, #8]
 801326e:	f000 fdd9 	bl	8013e24 <lv_obj_get_height>
 8013272:	4603      	mov	r3, r0
 8013274:	b29c      	uxth	r4, r3
 8013276:	68f8      	ldr	r0, [r7, #12]
 8013278:	f000 fdd4 	bl	8013e24 <lv_obj_get_height>
 801327c:	4603      	mov	r3, r0
 801327e:	b29b      	uxth	r3, r3
 8013280:	1ae3      	subs	r3, r4, r3
 8013282:	b29b      	uxth	r3, r3
 8013284:	83bb      	strh	r3, [r7, #28]
            break;
 8013286:	e130      	b.n	80134ea <lv_obj_align+0x45a>

        case LV_ALIGN_IN_LEFT_MID:
            new_x = 0;
 8013288:	2300      	movs	r3, #0
 801328a:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base) / 2 - lv_obj_get_height(obj) / 2;
 801328c:	68b8      	ldr	r0, [r7, #8]
 801328e:	f000 fdc9 	bl	8013e24 <lv_obj_get_height>
 8013292:	4603      	mov	r3, r0
 8013294:	2b00      	cmp	r3, #0
 8013296:	da00      	bge.n	801329a <lv_obj_align+0x20a>
 8013298:	3301      	adds	r3, #1
 801329a:	105b      	asrs	r3, r3, #1
 801329c:	b21b      	sxth	r3, r3
 801329e:	b29c      	uxth	r4, r3
 80132a0:	68f8      	ldr	r0, [r7, #12]
 80132a2:	f000 fdbf 	bl	8013e24 <lv_obj_get_height>
 80132a6:	4603      	mov	r3, r0
 80132a8:	2b00      	cmp	r3, #0
 80132aa:	da00      	bge.n	80132ae <lv_obj_align+0x21e>
 80132ac:	3301      	adds	r3, #1
 80132ae:	105b      	asrs	r3, r3, #1
 80132b0:	b21b      	sxth	r3, r3
 80132b2:	b29b      	uxth	r3, r3
 80132b4:	1ae3      	subs	r3, r4, r3
 80132b6:	b29b      	uxth	r3, r3
 80132b8:	83bb      	strh	r3, [r7, #28]
            break;
 80132ba:	e116      	b.n	80134ea <lv_obj_align+0x45a>

        case LV_ALIGN_IN_RIGHT_MID:
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
 80132bc:	68b8      	ldr	r0, [r7, #8]
 80132be:	f000 fda3 	bl	8013e08 <lv_obj_get_width>
 80132c2:	4603      	mov	r3, r0
 80132c4:	b29c      	uxth	r4, r3
 80132c6:	68f8      	ldr	r0, [r7, #12]
 80132c8:	f000 fd9e 	bl	8013e08 <lv_obj_get_width>
 80132cc:	4603      	mov	r3, r0
 80132ce:	b29b      	uxth	r3, r3
 80132d0:	1ae3      	subs	r3, r4, r3
 80132d2:	b29b      	uxth	r3, r3
 80132d4:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base) / 2 - lv_obj_get_height(obj) / 2;
 80132d6:	68b8      	ldr	r0, [r7, #8]
 80132d8:	f000 fda4 	bl	8013e24 <lv_obj_get_height>
 80132dc:	4603      	mov	r3, r0
 80132de:	2b00      	cmp	r3, #0
 80132e0:	da00      	bge.n	80132e4 <lv_obj_align+0x254>
 80132e2:	3301      	adds	r3, #1
 80132e4:	105b      	asrs	r3, r3, #1
 80132e6:	b21b      	sxth	r3, r3
 80132e8:	b29c      	uxth	r4, r3
 80132ea:	68f8      	ldr	r0, [r7, #12]
 80132ec:	f000 fd9a 	bl	8013e24 <lv_obj_get_height>
 80132f0:	4603      	mov	r3, r0
 80132f2:	2b00      	cmp	r3, #0
 80132f4:	da00      	bge.n	80132f8 <lv_obj_align+0x268>
 80132f6:	3301      	adds	r3, #1
 80132f8:	105b      	asrs	r3, r3, #1
 80132fa:	b21b      	sxth	r3, r3
 80132fc:	b29b      	uxth	r3, r3
 80132fe:	1ae3      	subs	r3, r4, r3
 8013300:	b29b      	uxth	r3, r3
 8013302:	83bb      	strh	r3, [r7, #28]
            break;
 8013304:	e0f1      	b.n	80134ea <lv_obj_align+0x45a>

        case LV_ALIGN_OUT_TOP_LEFT:
            new_x = 0;
 8013306:	2300      	movs	r3, #0
 8013308:	83fb      	strh	r3, [r7, #30]
            new_y = -lv_obj_get_height(obj);
 801330a:	68f8      	ldr	r0, [r7, #12]
 801330c:	f000 fd8a 	bl	8013e24 <lv_obj_get_height>
 8013310:	4603      	mov	r3, r0
 8013312:	b29b      	uxth	r3, r3
 8013314:	425b      	negs	r3, r3
 8013316:	b29b      	uxth	r3, r3
 8013318:	83bb      	strh	r3, [r7, #28]
            break;
 801331a:	e0e6      	b.n	80134ea <lv_obj_align+0x45a>

        case LV_ALIGN_OUT_TOP_MID:
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
 801331c:	68b8      	ldr	r0, [r7, #8]
 801331e:	f000 fd73 	bl	8013e08 <lv_obj_get_width>
 8013322:	4603      	mov	r3, r0
 8013324:	2b00      	cmp	r3, #0
 8013326:	da00      	bge.n	801332a <lv_obj_align+0x29a>
 8013328:	3301      	adds	r3, #1
 801332a:	105b      	asrs	r3, r3, #1
 801332c:	b21b      	sxth	r3, r3
 801332e:	b29c      	uxth	r4, r3
 8013330:	68f8      	ldr	r0, [r7, #12]
 8013332:	f000 fd69 	bl	8013e08 <lv_obj_get_width>
 8013336:	4603      	mov	r3, r0
 8013338:	2b00      	cmp	r3, #0
 801333a:	da00      	bge.n	801333e <lv_obj_align+0x2ae>
 801333c:	3301      	adds	r3, #1
 801333e:	105b      	asrs	r3, r3, #1
 8013340:	b21b      	sxth	r3, r3
 8013342:	b29b      	uxth	r3, r3
 8013344:	1ae3      	subs	r3, r4, r3
 8013346:	b29b      	uxth	r3, r3
 8013348:	83fb      	strh	r3, [r7, #30]
            new_y = -lv_obj_get_height(obj);
 801334a:	68f8      	ldr	r0, [r7, #12]
 801334c:	f000 fd6a 	bl	8013e24 <lv_obj_get_height>
 8013350:	4603      	mov	r3, r0
 8013352:	b29b      	uxth	r3, r3
 8013354:	425b      	negs	r3, r3
 8013356:	b29b      	uxth	r3, r3
 8013358:	83bb      	strh	r3, [r7, #28]
            break;
 801335a:	e0c6      	b.n	80134ea <lv_obj_align+0x45a>

        case LV_ALIGN_OUT_TOP_RIGHT:
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
 801335c:	68b8      	ldr	r0, [r7, #8]
 801335e:	f000 fd53 	bl	8013e08 <lv_obj_get_width>
 8013362:	4603      	mov	r3, r0
 8013364:	b29c      	uxth	r4, r3
 8013366:	68f8      	ldr	r0, [r7, #12]
 8013368:	f000 fd4e 	bl	8013e08 <lv_obj_get_width>
 801336c:	4603      	mov	r3, r0
 801336e:	b29b      	uxth	r3, r3
 8013370:	1ae3      	subs	r3, r4, r3
 8013372:	b29b      	uxth	r3, r3
 8013374:	83fb      	strh	r3, [r7, #30]
            new_y = -lv_obj_get_height(obj);
 8013376:	68f8      	ldr	r0, [r7, #12]
 8013378:	f000 fd54 	bl	8013e24 <lv_obj_get_height>
 801337c:	4603      	mov	r3, r0
 801337e:	b29b      	uxth	r3, r3
 8013380:	425b      	negs	r3, r3
 8013382:	b29b      	uxth	r3, r3
 8013384:	83bb      	strh	r3, [r7, #28]
            break;
 8013386:	e0b0      	b.n	80134ea <lv_obj_align+0x45a>

        case LV_ALIGN_OUT_BOTTOM_LEFT:
            new_x = 0;
 8013388:	2300      	movs	r3, #0
 801338a:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base);
 801338c:	68b8      	ldr	r0, [r7, #8]
 801338e:	f000 fd49 	bl	8013e24 <lv_obj_get_height>
 8013392:	4603      	mov	r3, r0
 8013394:	83bb      	strh	r3, [r7, #28]
            break;
 8013396:	e0a8      	b.n	80134ea <lv_obj_align+0x45a>

        case LV_ALIGN_OUT_BOTTOM_MID:
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
 8013398:	68b8      	ldr	r0, [r7, #8]
 801339a:	f000 fd35 	bl	8013e08 <lv_obj_get_width>
 801339e:	4603      	mov	r3, r0
 80133a0:	2b00      	cmp	r3, #0
 80133a2:	da00      	bge.n	80133a6 <lv_obj_align+0x316>
 80133a4:	3301      	adds	r3, #1
 80133a6:	105b      	asrs	r3, r3, #1
 80133a8:	b21b      	sxth	r3, r3
 80133aa:	b29c      	uxth	r4, r3
 80133ac:	68f8      	ldr	r0, [r7, #12]
 80133ae:	f000 fd2b 	bl	8013e08 <lv_obj_get_width>
 80133b2:	4603      	mov	r3, r0
 80133b4:	2b00      	cmp	r3, #0
 80133b6:	da00      	bge.n	80133ba <lv_obj_align+0x32a>
 80133b8:	3301      	adds	r3, #1
 80133ba:	105b      	asrs	r3, r3, #1
 80133bc:	b21b      	sxth	r3, r3
 80133be:	b29b      	uxth	r3, r3
 80133c0:	1ae3      	subs	r3, r4, r3
 80133c2:	b29b      	uxth	r3, r3
 80133c4:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base);
 80133c6:	68b8      	ldr	r0, [r7, #8]
 80133c8:	f000 fd2c 	bl	8013e24 <lv_obj_get_height>
 80133cc:	4603      	mov	r3, r0
 80133ce:	83bb      	strh	r3, [r7, #28]
            break;
 80133d0:	e08b      	b.n	80134ea <lv_obj_align+0x45a>

        case LV_ALIGN_OUT_BOTTOM_RIGHT:
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
 80133d2:	68b8      	ldr	r0, [r7, #8]
 80133d4:	f000 fd18 	bl	8013e08 <lv_obj_get_width>
 80133d8:	4603      	mov	r3, r0
 80133da:	b29c      	uxth	r4, r3
 80133dc:	68f8      	ldr	r0, [r7, #12]
 80133de:	f000 fd13 	bl	8013e08 <lv_obj_get_width>
 80133e2:	4603      	mov	r3, r0
 80133e4:	b29b      	uxth	r3, r3
 80133e6:	1ae3      	subs	r3, r4, r3
 80133e8:	b29b      	uxth	r3, r3
 80133ea:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base);
 80133ec:	68b8      	ldr	r0, [r7, #8]
 80133ee:	f000 fd19 	bl	8013e24 <lv_obj_get_height>
 80133f2:	4603      	mov	r3, r0
 80133f4:	83bb      	strh	r3, [r7, #28]
            break;
 80133f6:	e078      	b.n	80134ea <lv_obj_align+0x45a>

        case LV_ALIGN_OUT_LEFT_TOP:
            new_x = -lv_obj_get_width(obj);
 80133f8:	68f8      	ldr	r0, [r7, #12]
 80133fa:	f000 fd05 	bl	8013e08 <lv_obj_get_width>
 80133fe:	4603      	mov	r3, r0
 8013400:	b29b      	uxth	r3, r3
 8013402:	425b      	negs	r3, r3
 8013404:	b29b      	uxth	r3, r3
 8013406:	83fb      	strh	r3, [r7, #30]
            new_y = 0;
 8013408:	2300      	movs	r3, #0
 801340a:	83bb      	strh	r3, [r7, #28]
            break;
 801340c:	e06d      	b.n	80134ea <lv_obj_align+0x45a>

        case LV_ALIGN_OUT_LEFT_MID:
            new_x = -lv_obj_get_width(obj);
 801340e:	68f8      	ldr	r0, [r7, #12]
 8013410:	f000 fcfa 	bl	8013e08 <lv_obj_get_width>
 8013414:	4603      	mov	r3, r0
 8013416:	b29b      	uxth	r3, r3
 8013418:	425b      	negs	r3, r3
 801341a:	b29b      	uxth	r3, r3
 801341c:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base) / 2 - lv_obj_get_height(obj) / 2;
 801341e:	68b8      	ldr	r0, [r7, #8]
 8013420:	f000 fd00 	bl	8013e24 <lv_obj_get_height>
 8013424:	4603      	mov	r3, r0
 8013426:	2b00      	cmp	r3, #0
 8013428:	da00      	bge.n	801342c <lv_obj_align+0x39c>
 801342a:	3301      	adds	r3, #1
 801342c:	105b      	asrs	r3, r3, #1
 801342e:	b21b      	sxth	r3, r3
 8013430:	b29c      	uxth	r4, r3
 8013432:	68f8      	ldr	r0, [r7, #12]
 8013434:	f000 fcf6 	bl	8013e24 <lv_obj_get_height>
 8013438:	4603      	mov	r3, r0
 801343a:	2b00      	cmp	r3, #0
 801343c:	da00      	bge.n	8013440 <lv_obj_align+0x3b0>
 801343e:	3301      	adds	r3, #1
 8013440:	105b      	asrs	r3, r3, #1
 8013442:	b21b      	sxth	r3, r3
 8013444:	b29b      	uxth	r3, r3
 8013446:	1ae3      	subs	r3, r4, r3
 8013448:	b29b      	uxth	r3, r3
 801344a:	83bb      	strh	r3, [r7, #28]
            break;
 801344c:	e04d      	b.n	80134ea <lv_obj_align+0x45a>

        case LV_ALIGN_OUT_LEFT_BOTTOM:
            new_x = -lv_obj_get_width(obj);
 801344e:	68f8      	ldr	r0, [r7, #12]
 8013450:	f000 fcda 	bl	8013e08 <lv_obj_get_width>
 8013454:	4603      	mov	r3, r0
 8013456:	b29b      	uxth	r3, r3
 8013458:	425b      	negs	r3, r3
 801345a:	b29b      	uxth	r3, r3
 801345c:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base) - lv_obj_get_height(obj);
 801345e:	68b8      	ldr	r0, [r7, #8]
 8013460:	f000 fce0 	bl	8013e24 <lv_obj_get_height>
 8013464:	4603      	mov	r3, r0
 8013466:	b29c      	uxth	r4, r3
 8013468:	68f8      	ldr	r0, [r7, #12]
 801346a:	f000 fcdb 	bl	8013e24 <lv_obj_get_height>
 801346e:	4603      	mov	r3, r0
 8013470:	b29b      	uxth	r3, r3
 8013472:	1ae3      	subs	r3, r4, r3
 8013474:	b29b      	uxth	r3, r3
 8013476:	83bb      	strh	r3, [r7, #28]
            break;
 8013478:	e037      	b.n	80134ea <lv_obj_align+0x45a>

        case LV_ALIGN_OUT_RIGHT_TOP:
            new_x = lv_obj_get_width(base);
 801347a:	68b8      	ldr	r0, [r7, #8]
 801347c:	f000 fcc4 	bl	8013e08 <lv_obj_get_width>
 8013480:	4603      	mov	r3, r0
 8013482:	83fb      	strh	r3, [r7, #30]
            new_y = 0;
 8013484:	2300      	movs	r3, #0
 8013486:	83bb      	strh	r3, [r7, #28]
            break;
 8013488:	e02f      	b.n	80134ea <lv_obj_align+0x45a>

        case LV_ALIGN_OUT_RIGHT_MID:
            new_x = lv_obj_get_width(base);
 801348a:	68b8      	ldr	r0, [r7, #8]
 801348c:	f000 fcbc 	bl	8013e08 <lv_obj_get_width>
 8013490:	4603      	mov	r3, r0
 8013492:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base) / 2 - lv_obj_get_height(obj) / 2;
 8013494:	68b8      	ldr	r0, [r7, #8]
 8013496:	f000 fcc5 	bl	8013e24 <lv_obj_get_height>
 801349a:	4603      	mov	r3, r0
 801349c:	2b00      	cmp	r3, #0
 801349e:	da00      	bge.n	80134a2 <lv_obj_align+0x412>
 80134a0:	3301      	adds	r3, #1
 80134a2:	105b      	asrs	r3, r3, #1
 80134a4:	b21b      	sxth	r3, r3
 80134a6:	b29c      	uxth	r4, r3
 80134a8:	68f8      	ldr	r0, [r7, #12]
 80134aa:	f000 fcbb 	bl	8013e24 <lv_obj_get_height>
 80134ae:	4603      	mov	r3, r0
 80134b0:	2b00      	cmp	r3, #0
 80134b2:	da00      	bge.n	80134b6 <lv_obj_align+0x426>
 80134b4:	3301      	adds	r3, #1
 80134b6:	105b      	asrs	r3, r3, #1
 80134b8:	b21b      	sxth	r3, r3
 80134ba:	b29b      	uxth	r3, r3
 80134bc:	1ae3      	subs	r3, r4, r3
 80134be:	b29b      	uxth	r3, r3
 80134c0:	83bb      	strh	r3, [r7, #28]
            break;
 80134c2:	e012      	b.n	80134ea <lv_obj_align+0x45a>

        case LV_ALIGN_OUT_RIGHT_BOTTOM:
            new_x = lv_obj_get_width(base);
 80134c4:	68b8      	ldr	r0, [r7, #8]
 80134c6:	f000 fc9f 	bl	8013e08 <lv_obj_get_width>
 80134ca:	4603      	mov	r3, r0
 80134cc:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base) - lv_obj_get_height(obj);
 80134ce:	68b8      	ldr	r0, [r7, #8]
 80134d0:	f000 fca8 	bl	8013e24 <lv_obj_get_height>
 80134d4:	4603      	mov	r3, r0
 80134d6:	b29c      	uxth	r4, r3
 80134d8:	68f8      	ldr	r0, [r7, #12]
 80134da:	f000 fca3 	bl	8013e24 <lv_obj_get_height>
 80134de:	4603      	mov	r3, r0
 80134e0:	b29b      	uxth	r3, r3
 80134e2:	1ae3      	subs	r3, r4, r3
 80134e4:	b29b      	uxth	r3, r3
 80134e6:	83bb      	strh	r3, [r7, #28]
            break;
 80134e8:	bf00      	nop
    }

    /*Bring together the coordination system of base and obj*/
    lv_obj_t * par        = lv_obj_get_parent(obj);
 80134ea:	68f8      	ldr	r0, [r7, #12]
 80134ec:	f000 fc22 	bl	8013d34 <lv_obj_get_parent>
 80134f0:	61b8      	str	r0, [r7, #24]
    lv_coord_t base_abs_x = base->coords.x1;
 80134f2:	68bb      	ldr	r3, [r7, #8]
 80134f4:	8a1b      	ldrh	r3, [r3, #16]
 80134f6:	82fb      	strh	r3, [r7, #22]
    lv_coord_t base_abs_y = base->coords.y1;
 80134f8:	68bb      	ldr	r3, [r7, #8]
 80134fa:	8a5b      	ldrh	r3, [r3, #18]
 80134fc:	82bb      	strh	r3, [r7, #20]
    lv_coord_t par_abs_x  = par->coords.x1;
 80134fe:	69bb      	ldr	r3, [r7, #24]
 8013500:	8a1b      	ldrh	r3, [r3, #16]
 8013502:	827b      	strh	r3, [r7, #18]
    lv_coord_t par_abs_y  = par->coords.y1;
 8013504:	69bb      	ldr	r3, [r7, #24]
 8013506:	8a5b      	ldrh	r3, [r3, #18]
 8013508:	823b      	strh	r3, [r7, #16]
    new_x += x_mod + base_abs_x;
 801350a:	88ba      	ldrh	r2, [r7, #4]
 801350c:	8afb      	ldrh	r3, [r7, #22]
 801350e:	4413      	add	r3, r2
 8013510:	b29a      	uxth	r2, r3
 8013512:	8bfb      	ldrh	r3, [r7, #30]
 8013514:	4413      	add	r3, r2
 8013516:	b29b      	uxth	r3, r3
 8013518:	83fb      	strh	r3, [r7, #30]
    new_y += y_mod + base_abs_y;
 801351a:	8e3a      	ldrh	r2, [r7, #48]	; 0x30
 801351c:	8abb      	ldrh	r3, [r7, #20]
 801351e:	4413      	add	r3, r2
 8013520:	b29a      	uxth	r2, r3
 8013522:	8bbb      	ldrh	r3, [r7, #28]
 8013524:	4413      	add	r3, r2
 8013526:	b29b      	uxth	r3, r3
 8013528:	83bb      	strh	r3, [r7, #28]
    new_x -= par_abs_x;
 801352a:	8bfa      	ldrh	r2, [r7, #30]
 801352c:	8a7b      	ldrh	r3, [r7, #18]
 801352e:	1ad3      	subs	r3, r2, r3
 8013530:	b29b      	uxth	r3, r3
 8013532:	83fb      	strh	r3, [r7, #30]
    new_y -= par_abs_y;
 8013534:	8bba      	ldrh	r2, [r7, #28]
 8013536:	8a3b      	ldrh	r3, [r7, #16]
 8013538:	1ad3      	subs	r3, r2, r3
 801353a:	b29b      	uxth	r3, r3
 801353c:	83bb      	strh	r3, [r7, #28]

    lv_obj_set_pos(obj, new_x, new_y);
 801353e:	f9b7 201c 	ldrsh.w	r2, [r7, #28]
 8013542:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8013546:	4619      	mov	r1, r3
 8013548:	68f8      	ldr	r0, [r7, #12]
 801354a:	f7ff fc48 	bl	8012dde <lv_obj_set_pos>

#if LV_USE_OBJ_REALIGN
    /*Save the last align parameters to use them in `lv_obj_realign`*/
    obj->realign.align       = align;
 801354e:	68fb      	ldr	r3, [r7, #12]
 8013550:	79fa      	ldrb	r2, [r7, #7]
 8013552:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    obj->realign.xofs        = x_mod;
 8013556:	68fb      	ldr	r3, [r7, #12]
 8013558:	88ba      	ldrh	r2, [r7, #4]
 801355a:	879a      	strh	r2, [r3, #60]	; 0x3c
    obj->realign.yofs        = y_mod;
 801355c:	68fb      	ldr	r3, [r7, #12]
 801355e:	8e3a      	ldrh	r2, [r7, #48]	; 0x30
 8013560:	87da      	strh	r2, [r3, #62]	; 0x3e
    obj->realign.base        = base;
 8013562:	68fb      	ldr	r3, [r7, #12]
 8013564:	68ba      	ldr	r2, [r7, #8]
 8013566:	639a      	str	r2, [r3, #56]	; 0x38
    obj->realign.origo_align = 0;
 8013568:	68fa      	ldr	r2, [r7, #12]
 801356a:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 801356e:	f36f 0341 	bfc	r3, #1, #1
 8013572:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
#endif
}
 8013576:	bf00      	nop
 8013578:	3724      	adds	r7, #36	; 0x24
 801357a:	46bd      	mov	sp, r7
 801357c:	bd90      	pop	{r4, r7, pc}
 801357e:	bf00      	nop

08013580 <lv_obj_align_origo>:
 * @param align type of alignment (see 'lv_align_t' enum)
 * @param x_mod x coordinate shift after alignment
 * @param y_mod y coordinate shift after alignment
 */
void lv_obj_align_origo(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t x_mod, lv_coord_t y_mod)
{
 8013580:	b580      	push	{r7, lr}
 8013582:	b08a      	sub	sp, #40	; 0x28
 8013584:	af00      	add	r7, sp, #0
 8013586:	60f8      	str	r0, [r7, #12]
 8013588:	60b9      	str	r1, [r7, #8]
 801358a:	4611      	mov	r1, r2
 801358c:	461a      	mov	r2, r3
 801358e:	460b      	mov	r3, r1
 8013590:	71fb      	strb	r3, [r7, #7]
 8013592:	4613      	mov	r3, r2
 8013594:	80bb      	strh	r3, [r7, #4]
    lv_coord_t new_x = lv_obj_get_x(obj);
 8013596:	68f8      	ldr	r0, [r7, #12]
 8013598:	f000 fc04 	bl	8013da4 <lv_obj_get_x>
 801359c:	4603      	mov	r3, r0
 801359e:	84fb      	strh	r3, [r7, #38]	; 0x26
    lv_coord_t new_y = lv_obj_get_y(obj);
 80135a0:	68f8      	ldr	r0, [r7, #12]
 80135a2:	f000 fc18 	bl	8013dd6 <lv_obj_get_y>
 80135a6:	4603      	mov	r3, r0
 80135a8:	84bb      	strh	r3, [r7, #36]	; 0x24

    lv_coord_t obj_w_half = lv_obj_get_width(obj) / 2;
 80135aa:	68f8      	ldr	r0, [r7, #12]
 80135ac:	f000 fc2c 	bl	8013e08 <lv_obj_get_width>
 80135b0:	4603      	mov	r3, r0
 80135b2:	2b00      	cmp	r3, #0
 80135b4:	da00      	bge.n	80135b8 <lv_obj_align_origo+0x38>
 80135b6:	3301      	adds	r3, #1
 80135b8:	105b      	asrs	r3, r3, #1
 80135ba:	847b      	strh	r3, [r7, #34]	; 0x22
    lv_coord_t obj_h_half = lv_obj_get_height(obj) / 2;
 80135bc:	68f8      	ldr	r0, [r7, #12]
 80135be:	f000 fc31 	bl	8013e24 <lv_obj_get_height>
 80135c2:	4603      	mov	r3, r0
 80135c4:	2b00      	cmp	r3, #0
 80135c6:	da00      	bge.n	80135ca <lv_obj_align_origo+0x4a>
 80135c8:	3301      	adds	r3, #1
 80135ca:	105b      	asrs	r3, r3, #1
 80135cc:	843b      	strh	r3, [r7, #32]

    if(base == NULL) {
 80135ce:	68bb      	ldr	r3, [r7, #8]
 80135d0:	2b00      	cmp	r3, #0
 80135d2:	d103      	bne.n	80135dc <lv_obj_align_origo+0x5c>
        base = lv_obj_get_parent(obj);
 80135d4:	68f8      	ldr	r0, [r7, #12]
 80135d6:	f000 fbad 	bl	8013d34 <lv_obj_get_parent>
 80135da:	60b8      	str	r0, [r7, #8]
    }

    switch(align) {
 80135dc:	79fb      	ldrb	r3, [r7, #7]
 80135de:	2b14      	cmp	r3, #20
 80135e0:	f200 819f 	bhi.w	8013922 <lv_obj_align_origo+0x3a2>
 80135e4:	a201      	add	r2, pc, #4	; (adr r2, 80135ec <lv_obj_align_origo+0x6c>)
 80135e6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80135ea:	bf00      	nop
 80135ec:	08013641 	.word	0x08013641
 80135f0:	0801367b 	.word	0x0801367b
 80135f4:	0801368d 	.word	0x0801368d
 80135f8:	080136b3 	.word	0x080136b3
 80135fc:	080136cf 	.word	0x080136cf
 8013600:	080136eb 	.word	0x080136eb
 8013604:	0801371b 	.word	0x0801371b
 8013608:	08013741 	.word	0x08013741
 801360c:	08013767 	.word	0x08013767
 8013610:	08013797 	.word	0x08013797
 8013614:	080137a9 	.word	0x080137a9
 8013618:	080137cf 	.word	0x080137cf
 801361c:	080137eb 	.word	0x080137eb
 8013620:	08013807 	.word	0x08013807
 8013624:	08013837 	.word	0x08013837
 8013628:	0801385d 	.word	0x0801385d
 801362c:	0801386f 	.word	0x0801386f
 8013630:	08013895 	.word	0x08013895
 8013634:	080138b1 	.word	0x080138b1
 8013638:	080138cd 	.word	0x080138cd
 801363c:	080138fd 	.word	0x080138fd
        case LV_ALIGN_CENTER:
            new_x = lv_obj_get_width(base) / 2 - obj_w_half;
 8013640:	68b8      	ldr	r0, [r7, #8]
 8013642:	f000 fbe1 	bl	8013e08 <lv_obj_get_width>
 8013646:	4603      	mov	r3, r0
 8013648:	2b00      	cmp	r3, #0
 801364a:	da00      	bge.n	801364e <lv_obj_align_origo+0xce>
 801364c:	3301      	adds	r3, #1
 801364e:	105b      	asrs	r3, r3, #1
 8013650:	b21b      	sxth	r3, r3
 8013652:	b29a      	uxth	r2, r3
 8013654:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8013656:	1ad3      	subs	r3, r2, r3
 8013658:	b29b      	uxth	r3, r3
 801365a:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) / 2 - obj_h_half;
 801365c:	68b8      	ldr	r0, [r7, #8]
 801365e:	f000 fbe1 	bl	8013e24 <lv_obj_get_height>
 8013662:	4603      	mov	r3, r0
 8013664:	2b00      	cmp	r3, #0
 8013666:	da00      	bge.n	801366a <lv_obj_align_origo+0xea>
 8013668:	3301      	adds	r3, #1
 801366a:	105b      	asrs	r3, r3, #1
 801366c:	b21b      	sxth	r3, r3
 801366e:	b29a      	uxth	r2, r3
 8013670:	8c3b      	ldrh	r3, [r7, #32]
 8013672:	1ad3      	subs	r3, r2, r3
 8013674:	b29b      	uxth	r3, r3
 8013676:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8013678:	e153      	b.n	8013922 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_IN_TOP_LEFT:
            new_x = -obj_w_half;
 801367a:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 801367c:	425b      	negs	r3, r3
 801367e:	b29b      	uxth	r3, r3
 8013680:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = -obj_h_half;
 8013682:	8c3b      	ldrh	r3, [r7, #32]
 8013684:	425b      	negs	r3, r3
 8013686:	b29b      	uxth	r3, r3
 8013688:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 801368a:	e14a      	b.n	8013922 <lv_obj_align_origo+0x3a2>
        case LV_ALIGN_IN_TOP_MID:
            new_x = lv_obj_get_width(base) / 2 - obj_w_half;
 801368c:	68b8      	ldr	r0, [r7, #8]
 801368e:	f000 fbbb 	bl	8013e08 <lv_obj_get_width>
 8013692:	4603      	mov	r3, r0
 8013694:	2b00      	cmp	r3, #0
 8013696:	da00      	bge.n	801369a <lv_obj_align_origo+0x11a>
 8013698:	3301      	adds	r3, #1
 801369a:	105b      	asrs	r3, r3, #1
 801369c:	b21b      	sxth	r3, r3
 801369e:	b29a      	uxth	r2, r3
 80136a0:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 80136a2:	1ad3      	subs	r3, r2, r3
 80136a4:	b29b      	uxth	r3, r3
 80136a6:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = -obj_h_half;
 80136a8:	8c3b      	ldrh	r3, [r7, #32]
 80136aa:	425b      	negs	r3, r3
 80136ac:	b29b      	uxth	r3, r3
 80136ae:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 80136b0:	e137      	b.n	8013922 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_IN_TOP_RIGHT:
            new_x = lv_obj_get_width(base) - obj_w_half;
 80136b2:	68b8      	ldr	r0, [r7, #8]
 80136b4:	f000 fba8 	bl	8013e08 <lv_obj_get_width>
 80136b8:	4603      	mov	r3, r0
 80136ba:	b29a      	uxth	r2, r3
 80136bc:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 80136be:	1ad3      	subs	r3, r2, r3
 80136c0:	b29b      	uxth	r3, r3
 80136c2:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = -obj_h_half;
 80136c4:	8c3b      	ldrh	r3, [r7, #32]
 80136c6:	425b      	negs	r3, r3
 80136c8:	b29b      	uxth	r3, r3
 80136ca:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 80136cc:	e129      	b.n	8013922 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_IN_BOTTOM_LEFT:
            new_x = -obj_w_half;
 80136ce:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 80136d0:	425b      	negs	r3, r3
 80136d2:	b29b      	uxth	r3, r3
 80136d4:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) - obj_h_half;
 80136d6:	68b8      	ldr	r0, [r7, #8]
 80136d8:	f000 fba4 	bl	8013e24 <lv_obj_get_height>
 80136dc:	4603      	mov	r3, r0
 80136de:	b29a      	uxth	r2, r3
 80136e0:	8c3b      	ldrh	r3, [r7, #32]
 80136e2:	1ad3      	subs	r3, r2, r3
 80136e4:	b29b      	uxth	r3, r3
 80136e6:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 80136e8:	e11b      	b.n	8013922 <lv_obj_align_origo+0x3a2>
        case LV_ALIGN_IN_BOTTOM_MID:
            new_x = lv_obj_get_width(base) / 2 - obj_w_half;
 80136ea:	68b8      	ldr	r0, [r7, #8]
 80136ec:	f000 fb8c 	bl	8013e08 <lv_obj_get_width>
 80136f0:	4603      	mov	r3, r0
 80136f2:	2b00      	cmp	r3, #0
 80136f4:	da00      	bge.n	80136f8 <lv_obj_align_origo+0x178>
 80136f6:	3301      	adds	r3, #1
 80136f8:	105b      	asrs	r3, r3, #1
 80136fa:	b21b      	sxth	r3, r3
 80136fc:	b29a      	uxth	r2, r3
 80136fe:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8013700:	1ad3      	subs	r3, r2, r3
 8013702:	b29b      	uxth	r3, r3
 8013704:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) - obj_h_half;
 8013706:	68b8      	ldr	r0, [r7, #8]
 8013708:	f000 fb8c 	bl	8013e24 <lv_obj_get_height>
 801370c:	4603      	mov	r3, r0
 801370e:	b29a      	uxth	r2, r3
 8013710:	8c3b      	ldrh	r3, [r7, #32]
 8013712:	1ad3      	subs	r3, r2, r3
 8013714:	b29b      	uxth	r3, r3
 8013716:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8013718:	e103      	b.n	8013922 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_IN_BOTTOM_RIGHT:
            new_x = lv_obj_get_width(base) - obj_w_half;
 801371a:	68b8      	ldr	r0, [r7, #8]
 801371c:	f000 fb74 	bl	8013e08 <lv_obj_get_width>
 8013720:	4603      	mov	r3, r0
 8013722:	b29a      	uxth	r2, r3
 8013724:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8013726:	1ad3      	subs	r3, r2, r3
 8013728:	b29b      	uxth	r3, r3
 801372a:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) - obj_h_half;
 801372c:	68b8      	ldr	r0, [r7, #8]
 801372e:	f000 fb79 	bl	8013e24 <lv_obj_get_height>
 8013732:	4603      	mov	r3, r0
 8013734:	b29a      	uxth	r2, r3
 8013736:	8c3b      	ldrh	r3, [r7, #32]
 8013738:	1ad3      	subs	r3, r2, r3
 801373a:	b29b      	uxth	r3, r3
 801373c:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 801373e:	e0f0      	b.n	8013922 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_IN_LEFT_MID:
            new_x = -obj_w_half;
 8013740:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8013742:	425b      	negs	r3, r3
 8013744:	b29b      	uxth	r3, r3
 8013746:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) / 2 - obj_h_half;
 8013748:	68b8      	ldr	r0, [r7, #8]
 801374a:	f000 fb6b 	bl	8013e24 <lv_obj_get_height>
 801374e:	4603      	mov	r3, r0
 8013750:	2b00      	cmp	r3, #0
 8013752:	da00      	bge.n	8013756 <lv_obj_align_origo+0x1d6>
 8013754:	3301      	adds	r3, #1
 8013756:	105b      	asrs	r3, r3, #1
 8013758:	b21b      	sxth	r3, r3
 801375a:	b29a      	uxth	r2, r3
 801375c:	8c3b      	ldrh	r3, [r7, #32]
 801375e:	1ad3      	subs	r3, r2, r3
 8013760:	b29b      	uxth	r3, r3
 8013762:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8013764:	e0dd      	b.n	8013922 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_IN_RIGHT_MID:
            new_x = lv_obj_get_width(base) - obj_w_half;
 8013766:	68b8      	ldr	r0, [r7, #8]
 8013768:	f000 fb4e 	bl	8013e08 <lv_obj_get_width>
 801376c:	4603      	mov	r3, r0
 801376e:	b29a      	uxth	r2, r3
 8013770:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8013772:	1ad3      	subs	r3, r2, r3
 8013774:	b29b      	uxth	r3, r3
 8013776:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) / 2 - obj_h_half;
 8013778:	68b8      	ldr	r0, [r7, #8]
 801377a:	f000 fb53 	bl	8013e24 <lv_obj_get_height>
 801377e:	4603      	mov	r3, r0
 8013780:	2b00      	cmp	r3, #0
 8013782:	da00      	bge.n	8013786 <lv_obj_align_origo+0x206>
 8013784:	3301      	adds	r3, #1
 8013786:	105b      	asrs	r3, r3, #1
 8013788:	b21b      	sxth	r3, r3
 801378a:	b29a      	uxth	r2, r3
 801378c:	8c3b      	ldrh	r3, [r7, #32]
 801378e:	1ad3      	subs	r3, r2, r3
 8013790:	b29b      	uxth	r3, r3
 8013792:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8013794:	e0c5      	b.n	8013922 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_OUT_TOP_LEFT:
            new_x = -obj_w_half;
 8013796:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8013798:	425b      	negs	r3, r3
 801379a:	b29b      	uxth	r3, r3
 801379c:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = -obj_h_half;
 801379e:	8c3b      	ldrh	r3, [r7, #32]
 80137a0:	425b      	negs	r3, r3
 80137a2:	b29b      	uxth	r3, r3
 80137a4:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 80137a6:	e0bc      	b.n	8013922 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_OUT_TOP_MID:
            new_x = lv_obj_get_width(base) / 2 - obj_w_half;
 80137a8:	68b8      	ldr	r0, [r7, #8]
 80137aa:	f000 fb2d 	bl	8013e08 <lv_obj_get_width>
 80137ae:	4603      	mov	r3, r0
 80137b0:	2b00      	cmp	r3, #0
 80137b2:	da00      	bge.n	80137b6 <lv_obj_align_origo+0x236>
 80137b4:	3301      	adds	r3, #1
 80137b6:	105b      	asrs	r3, r3, #1
 80137b8:	b21b      	sxth	r3, r3
 80137ba:	b29a      	uxth	r2, r3
 80137bc:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 80137be:	1ad3      	subs	r3, r2, r3
 80137c0:	b29b      	uxth	r3, r3
 80137c2:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = -obj_h_half;
 80137c4:	8c3b      	ldrh	r3, [r7, #32]
 80137c6:	425b      	negs	r3, r3
 80137c8:	b29b      	uxth	r3, r3
 80137ca:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 80137cc:	e0a9      	b.n	8013922 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_OUT_TOP_RIGHT:
            new_x = lv_obj_get_width(base) - obj_w_half;
 80137ce:	68b8      	ldr	r0, [r7, #8]
 80137d0:	f000 fb1a 	bl	8013e08 <lv_obj_get_width>
 80137d4:	4603      	mov	r3, r0
 80137d6:	b29a      	uxth	r2, r3
 80137d8:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 80137da:	1ad3      	subs	r3, r2, r3
 80137dc:	b29b      	uxth	r3, r3
 80137de:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = -obj_h_half;
 80137e0:	8c3b      	ldrh	r3, [r7, #32]
 80137e2:	425b      	negs	r3, r3
 80137e4:	b29b      	uxth	r3, r3
 80137e6:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 80137e8:	e09b      	b.n	8013922 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_OUT_BOTTOM_LEFT:
            new_x = -obj_w_half;
 80137ea:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 80137ec:	425b      	negs	r3, r3
 80137ee:	b29b      	uxth	r3, r3
 80137f0:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) - obj_h_half;
 80137f2:	68b8      	ldr	r0, [r7, #8]
 80137f4:	f000 fb16 	bl	8013e24 <lv_obj_get_height>
 80137f8:	4603      	mov	r3, r0
 80137fa:	b29a      	uxth	r2, r3
 80137fc:	8c3b      	ldrh	r3, [r7, #32]
 80137fe:	1ad3      	subs	r3, r2, r3
 8013800:	b29b      	uxth	r3, r3
 8013802:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8013804:	e08d      	b.n	8013922 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_OUT_BOTTOM_MID:
            new_x = lv_obj_get_width(base) / 2 - obj_w_half;
 8013806:	68b8      	ldr	r0, [r7, #8]
 8013808:	f000 fafe 	bl	8013e08 <lv_obj_get_width>
 801380c:	4603      	mov	r3, r0
 801380e:	2b00      	cmp	r3, #0
 8013810:	da00      	bge.n	8013814 <lv_obj_align_origo+0x294>
 8013812:	3301      	adds	r3, #1
 8013814:	105b      	asrs	r3, r3, #1
 8013816:	b21b      	sxth	r3, r3
 8013818:	b29a      	uxth	r2, r3
 801381a:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 801381c:	1ad3      	subs	r3, r2, r3
 801381e:	b29b      	uxth	r3, r3
 8013820:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) - obj_h_half;
 8013822:	68b8      	ldr	r0, [r7, #8]
 8013824:	f000 fafe 	bl	8013e24 <lv_obj_get_height>
 8013828:	4603      	mov	r3, r0
 801382a:	b29a      	uxth	r2, r3
 801382c:	8c3b      	ldrh	r3, [r7, #32]
 801382e:	1ad3      	subs	r3, r2, r3
 8013830:	b29b      	uxth	r3, r3
 8013832:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8013834:	e075      	b.n	8013922 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_OUT_BOTTOM_RIGHT:
            new_x = lv_obj_get_width(base) - obj_w_half;
 8013836:	68b8      	ldr	r0, [r7, #8]
 8013838:	f000 fae6 	bl	8013e08 <lv_obj_get_width>
 801383c:	4603      	mov	r3, r0
 801383e:	b29a      	uxth	r2, r3
 8013840:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8013842:	1ad3      	subs	r3, r2, r3
 8013844:	b29b      	uxth	r3, r3
 8013846:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) - obj_h_half;
 8013848:	68b8      	ldr	r0, [r7, #8]
 801384a:	f000 faeb 	bl	8013e24 <lv_obj_get_height>
 801384e:	4603      	mov	r3, r0
 8013850:	b29a      	uxth	r2, r3
 8013852:	8c3b      	ldrh	r3, [r7, #32]
 8013854:	1ad3      	subs	r3, r2, r3
 8013856:	b29b      	uxth	r3, r3
 8013858:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 801385a:	e062      	b.n	8013922 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_OUT_LEFT_TOP:
            new_x = -obj_w_half;
 801385c:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 801385e:	425b      	negs	r3, r3
 8013860:	b29b      	uxth	r3, r3
 8013862:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = -obj_h_half;
 8013864:	8c3b      	ldrh	r3, [r7, #32]
 8013866:	425b      	negs	r3, r3
 8013868:	b29b      	uxth	r3, r3
 801386a:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 801386c:	e059      	b.n	8013922 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_OUT_LEFT_MID:
            new_x = -obj_w_half;
 801386e:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8013870:	425b      	negs	r3, r3
 8013872:	b29b      	uxth	r3, r3
 8013874:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) / 2 - obj_h_half;
 8013876:	68b8      	ldr	r0, [r7, #8]
 8013878:	f000 fad4 	bl	8013e24 <lv_obj_get_height>
 801387c:	4603      	mov	r3, r0
 801387e:	2b00      	cmp	r3, #0
 8013880:	da00      	bge.n	8013884 <lv_obj_align_origo+0x304>
 8013882:	3301      	adds	r3, #1
 8013884:	105b      	asrs	r3, r3, #1
 8013886:	b21b      	sxth	r3, r3
 8013888:	b29a      	uxth	r2, r3
 801388a:	8c3b      	ldrh	r3, [r7, #32]
 801388c:	1ad3      	subs	r3, r2, r3
 801388e:	b29b      	uxth	r3, r3
 8013890:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8013892:	e046      	b.n	8013922 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_OUT_LEFT_BOTTOM:
            new_x = -obj_w_half;
 8013894:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8013896:	425b      	negs	r3, r3
 8013898:	b29b      	uxth	r3, r3
 801389a:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) - obj_h_half;
 801389c:	68b8      	ldr	r0, [r7, #8]
 801389e:	f000 fac1 	bl	8013e24 <lv_obj_get_height>
 80138a2:	4603      	mov	r3, r0
 80138a4:	b29a      	uxth	r2, r3
 80138a6:	8c3b      	ldrh	r3, [r7, #32]
 80138a8:	1ad3      	subs	r3, r2, r3
 80138aa:	b29b      	uxth	r3, r3
 80138ac:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 80138ae:	e038      	b.n	8013922 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_OUT_RIGHT_TOP:
            new_x = lv_obj_get_width(base) - obj_w_half;
 80138b0:	68b8      	ldr	r0, [r7, #8]
 80138b2:	f000 faa9 	bl	8013e08 <lv_obj_get_width>
 80138b6:	4603      	mov	r3, r0
 80138b8:	b29a      	uxth	r2, r3
 80138ba:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 80138bc:	1ad3      	subs	r3, r2, r3
 80138be:	b29b      	uxth	r3, r3
 80138c0:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = -obj_h_half;
 80138c2:	8c3b      	ldrh	r3, [r7, #32]
 80138c4:	425b      	negs	r3, r3
 80138c6:	b29b      	uxth	r3, r3
 80138c8:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 80138ca:	e02a      	b.n	8013922 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_OUT_RIGHT_MID:
            new_x = lv_obj_get_width(base) - obj_w_half;
 80138cc:	68b8      	ldr	r0, [r7, #8]
 80138ce:	f000 fa9b 	bl	8013e08 <lv_obj_get_width>
 80138d2:	4603      	mov	r3, r0
 80138d4:	b29a      	uxth	r2, r3
 80138d6:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 80138d8:	1ad3      	subs	r3, r2, r3
 80138da:	b29b      	uxth	r3, r3
 80138dc:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) / 2 - obj_h_half;
 80138de:	68b8      	ldr	r0, [r7, #8]
 80138e0:	f000 faa0 	bl	8013e24 <lv_obj_get_height>
 80138e4:	4603      	mov	r3, r0
 80138e6:	2b00      	cmp	r3, #0
 80138e8:	da00      	bge.n	80138ec <lv_obj_align_origo+0x36c>
 80138ea:	3301      	adds	r3, #1
 80138ec:	105b      	asrs	r3, r3, #1
 80138ee:	b21b      	sxth	r3, r3
 80138f0:	b29a      	uxth	r2, r3
 80138f2:	8c3b      	ldrh	r3, [r7, #32]
 80138f4:	1ad3      	subs	r3, r2, r3
 80138f6:	b29b      	uxth	r3, r3
 80138f8:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 80138fa:	e012      	b.n	8013922 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_OUT_RIGHT_BOTTOM:
            new_x = lv_obj_get_width(base) - obj_w_half;
 80138fc:	68b8      	ldr	r0, [r7, #8]
 80138fe:	f000 fa83 	bl	8013e08 <lv_obj_get_width>
 8013902:	4603      	mov	r3, r0
 8013904:	b29a      	uxth	r2, r3
 8013906:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8013908:	1ad3      	subs	r3, r2, r3
 801390a:	b29b      	uxth	r3, r3
 801390c:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) - obj_h_half;
 801390e:	68b8      	ldr	r0, [r7, #8]
 8013910:	f000 fa88 	bl	8013e24 <lv_obj_get_height>
 8013914:	4603      	mov	r3, r0
 8013916:	b29a      	uxth	r2, r3
 8013918:	8c3b      	ldrh	r3, [r7, #32]
 801391a:	1ad3      	subs	r3, r2, r3
 801391c:	b29b      	uxth	r3, r3
 801391e:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8013920:	bf00      	nop
    }

    /*Bring together the coordination system of base and obj*/
    lv_obj_t * par        = lv_obj_get_parent(obj);
 8013922:	68f8      	ldr	r0, [r7, #12]
 8013924:	f000 fa06 	bl	8013d34 <lv_obj_get_parent>
 8013928:	61f8      	str	r0, [r7, #28]
    lv_coord_t base_abs_x = base->coords.x1;
 801392a:	68bb      	ldr	r3, [r7, #8]
 801392c:	8a1b      	ldrh	r3, [r3, #16]
 801392e:	837b      	strh	r3, [r7, #26]
    lv_coord_t base_abs_y = base->coords.y1;
 8013930:	68bb      	ldr	r3, [r7, #8]
 8013932:	8a5b      	ldrh	r3, [r3, #18]
 8013934:	833b      	strh	r3, [r7, #24]
    lv_coord_t par_abs_x  = par->coords.x1;
 8013936:	69fb      	ldr	r3, [r7, #28]
 8013938:	8a1b      	ldrh	r3, [r3, #16]
 801393a:	82fb      	strh	r3, [r7, #22]
    lv_coord_t par_abs_y  = par->coords.y1;
 801393c:	69fb      	ldr	r3, [r7, #28]
 801393e:	8a5b      	ldrh	r3, [r3, #18]
 8013940:	82bb      	strh	r3, [r7, #20]
    new_x += x_mod + base_abs_x;
 8013942:	88ba      	ldrh	r2, [r7, #4]
 8013944:	8b7b      	ldrh	r3, [r7, #26]
 8013946:	4413      	add	r3, r2
 8013948:	b29a      	uxth	r2, r3
 801394a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801394c:	4413      	add	r3, r2
 801394e:	b29b      	uxth	r3, r3
 8013950:	84fb      	strh	r3, [r7, #38]	; 0x26
    new_y += y_mod + base_abs_y;
 8013952:	8e3a      	ldrh	r2, [r7, #48]	; 0x30
 8013954:	8b3b      	ldrh	r3, [r7, #24]
 8013956:	4413      	add	r3, r2
 8013958:	b29a      	uxth	r2, r3
 801395a:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 801395c:	4413      	add	r3, r2
 801395e:	b29b      	uxth	r3, r3
 8013960:	84bb      	strh	r3, [r7, #36]	; 0x24
    new_x -= par_abs_x;
 8013962:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8013964:	8afb      	ldrh	r3, [r7, #22]
 8013966:	1ad3      	subs	r3, r2, r3
 8013968:	b29b      	uxth	r3, r3
 801396a:	84fb      	strh	r3, [r7, #38]	; 0x26
    new_y -= par_abs_y;
 801396c:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 801396e:	8abb      	ldrh	r3, [r7, #20]
 8013970:	1ad3      	subs	r3, r2, r3
 8013972:	b29b      	uxth	r3, r3
 8013974:	84bb      	strh	r3, [r7, #36]	; 0x24

    lv_obj_set_pos(obj, new_x, new_y);
 8013976:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
 801397a:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 801397e:	4619      	mov	r1, r3
 8013980:	68f8      	ldr	r0, [r7, #12]
 8013982:	f7ff fa2c 	bl	8012dde <lv_obj_set_pos>

#if LV_USE_OBJ_REALIGN
    /*Save the last align parameters to use them in `lv_obj_realign`*/
    obj->realign.align       = align;
 8013986:	68fb      	ldr	r3, [r7, #12]
 8013988:	79fa      	ldrb	r2, [r7, #7]
 801398a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    obj->realign.xofs        = x_mod;
 801398e:	68fb      	ldr	r3, [r7, #12]
 8013990:	88ba      	ldrh	r2, [r7, #4]
 8013992:	879a      	strh	r2, [r3, #60]	; 0x3c
    obj->realign.yofs        = y_mod;
 8013994:	68fb      	ldr	r3, [r7, #12]
 8013996:	8e3a      	ldrh	r2, [r7, #48]	; 0x30
 8013998:	87da      	strh	r2, [r3, #62]	; 0x3e
    obj->realign.base        = base;
 801399a:	68fb      	ldr	r3, [r7, #12]
 801399c:	68ba      	ldr	r2, [r7, #8]
 801399e:	639a      	str	r2, [r3, #56]	; 0x38
    obj->realign.origo_align = 1;
 80139a0:	68fa      	ldr	r2, [r7, #12]
 80139a2:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 80139a6:	f043 0302 	orr.w	r3, r3, #2
 80139aa:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
#endif
}
 80139ae:	bf00      	nop
 80139b0:	3728      	adds	r7, #40	; 0x28
 80139b2:	46bd      	mov	sp, r7
 80139b4:	bd80      	pop	{r7, pc}
 80139b6:	bf00      	nop

080139b8 <lv_obj_realign>:
/**
 * Realign the object based on the last `lv_obj_align` parameters.
 * @param obj pointer to an object
 */
void lv_obj_realign(lv_obj_t * obj)
{
 80139b8:	b580      	push	{r7, lr}
 80139ba:	b084      	sub	sp, #16
 80139bc:	af02      	add	r7, sp, #8
 80139be:	6078      	str	r0, [r7, #4]
#if LV_USE_OBJ_REALIGN
    if(obj->realign.origo_align)
 80139c0:	687b      	ldr	r3, [r7, #4]
 80139c2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 80139c6:	f003 0302 	and.w	r3, r3, #2
 80139ca:	b2db      	uxtb	r3, r3
 80139cc:	2b00      	cmp	r3, #0
 80139ce:	d010      	beq.n	80139f2 <lv_obj_realign+0x3a>
        lv_obj_align_origo(obj, obj->realign.base, obj->realign.align, obj->realign.xofs, obj->realign.yofs);
 80139d0:	687b      	ldr	r3, [r7, #4]
 80139d2:	6b99      	ldr	r1, [r3, #56]	; 0x38
 80139d4:	687b      	ldr	r3, [r7, #4]
 80139d6:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
 80139da:	687b      	ldr	r3, [r7, #4]
 80139dc:	f9b3 003c 	ldrsh.w	r0, [r3, #60]	; 0x3c
 80139e0:	687b      	ldr	r3, [r7, #4]
 80139e2:	f9b3 303e 	ldrsh.w	r3, [r3, #62]	; 0x3e
 80139e6:	9300      	str	r3, [sp, #0]
 80139e8:	4603      	mov	r3, r0
 80139ea:	6878      	ldr	r0, [r7, #4]
 80139ec:	f7ff fdc8 	bl	8013580 <lv_obj_align_origo>
        lv_obj_align(obj, obj->realign.base, obj->realign.align, obj->realign.xofs, obj->realign.yofs);
#else
    (void)obj;
    LV_LOG_WARN("lv_obj_realaign: no effect because LV_USE_OBJ_REALIGN = 0");
#endif
}
 80139f0:	e00f      	b.n	8013a12 <lv_obj_realign+0x5a>
        lv_obj_align(obj, obj->realign.base, obj->realign.align, obj->realign.xofs, obj->realign.yofs);
 80139f2:	687b      	ldr	r3, [r7, #4]
 80139f4:	6b99      	ldr	r1, [r3, #56]	; 0x38
 80139f6:	687b      	ldr	r3, [r7, #4]
 80139f8:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
 80139fc:	687b      	ldr	r3, [r7, #4]
 80139fe:	f9b3 003c 	ldrsh.w	r0, [r3, #60]	; 0x3c
 8013a02:	687b      	ldr	r3, [r7, #4]
 8013a04:	f9b3 303e 	ldrsh.w	r3, [r3, #62]	; 0x3e
 8013a08:	9300      	str	r3, [sp, #0]
 8013a0a:	4603      	mov	r3, r0
 8013a0c:	6878      	ldr	r0, [r7, #4]
 8013a0e:	f7ff fb3f 	bl	8013090 <lv_obj_align>
}
 8013a12:	bf00      	nop
 8013a14:	3708      	adds	r7, #8
 8013a16:	46bd      	mov	sp, r7
 8013a18:	bd80      	pop	{r7, pc}

08013a1a <lv_obj_set_style>:
 * Set a new style for an object
 * @param obj pointer to an object
 * @param style_p pointer to the new style
 */
void lv_obj_set_style(lv_obj_t * obj, const lv_style_t * style)
{
 8013a1a:	b580      	push	{r7, lr}
 8013a1c:	b082      	sub	sp, #8
 8013a1e:	af00      	add	r7, sp, #0
 8013a20:	6078      	str	r0, [r7, #4]
 8013a22:	6039      	str	r1, [r7, #0]
    obj->style_p = style;
 8013a24:	687b      	ldr	r3, [r7, #4]
 8013a26:	683a      	ldr	r2, [r7, #0]
 8013a28:	629a      	str	r2, [r3, #40]	; 0x28

    /*Send a signal about style change to every children with NULL style*/
    refresh_children_style(obj);
 8013a2a:	6878      	ldr	r0, [r7, #4]
 8013a2c:	f000 fc10 	bl	8014250 <refresh_children_style>

    /*Notify the object about the style change too*/
    lv_obj_refresh_style(obj);
 8013a30:	6878      	ldr	r0, [r7, #4]
 8013a32:	f000 f804 	bl	8013a3e <lv_obj_refresh_style>
}
 8013a36:	bf00      	nop
 8013a38:	3708      	adds	r7, #8
 8013a3a:	46bd      	mov	sp, r7
 8013a3c:	bd80      	pop	{r7, pc}

08013a3e <lv_obj_refresh_style>:
/**
 * Notify an object about its style is modified
 * @param obj pointer to an object
 */
void lv_obj_refresh_style(lv_obj_t * obj)
{
 8013a3e:	b580      	push	{r7, lr}
 8013a40:	b082      	sub	sp, #8
 8013a42:	af00      	add	r7, sp, #0
 8013a44:	6078      	str	r0, [r7, #4]
    lv_obj_invalidate(obj);
 8013a46:	6878      	ldr	r0, [r7, #4]
 8013a48:	f7ff f910 	bl	8012c6c <lv_obj_invalidate>
    obj->signal_cb(obj, LV_SIGNAL_STYLE_CHG, NULL);
 8013a4c:	687b      	ldr	r3, [r7, #4]
 8013a4e:	69db      	ldr	r3, [r3, #28]
 8013a50:	2200      	movs	r2, #0
 8013a52:	2104      	movs	r1, #4
 8013a54:	6878      	ldr	r0, [r7, #4]
 8013a56:	4798      	blx	r3
    lv_obj_invalidate(obj);
 8013a58:	6878      	ldr	r0, [r7, #4]
 8013a5a:	f7ff f907 	bl	8012c6c <lv_obj_invalidate>
}
 8013a5e:	bf00      	nop
 8013a60:	3708      	adds	r7, #8
 8013a62:	46bd      	mov	sp, r7
 8013a64:	bd80      	pop	{r7, pc}

08013a66 <lv_obj_set_hidden>:
 * Hide an object. It won't be visible and clickable.
 * @param obj pointer to an object
 * @param en true: hide the object
 */
void lv_obj_set_hidden(lv_obj_t * obj, bool en)
{
 8013a66:	b580      	push	{r7, lr}
 8013a68:	b084      	sub	sp, #16
 8013a6a:	af00      	add	r7, sp, #0
 8013a6c:	6078      	str	r0, [r7, #4]
 8013a6e:	460b      	mov	r3, r1
 8013a70:	70fb      	strb	r3, [r7, #3]
    if(!obj->hidden) lv_obj_invalidate(obj); /*Invalidate when not hidden (hidden objects are ignored) */
 8013a72:	687b      	ldr	r3, [r7, #4]
 8013a74:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8013a78:	f003 0310 	and.w	r3, r3, #16
 8013a7c:	b2db      	uxtb	r3, r3
 8013a7e:	2b00      	cmp	r3, #0
 8013a80:	d102      	bne.n	8013a88 <lv_obj_set_hidden+0x22>
 8013a82:	6878      	ldr	r0, [r7, #4]
 8013a84:	f7ff f8f2 	bl	8012c6c <lv_obj_invalidate>

    obj->hidden = en == false ? 0 : 1;
 8013a88:	78fb      	ldrb	r3, [r7, #3]
 8013a8a:	f083 0301 	eor.w	r3, r3, #1
 8013a8e:	b2db      	uxtb	r3, r3
 8013a90:	2b00      	cmp	r3, #0
 8013a92:	d001      	beq.n	8013a98 <lv_obj_set_hidden+0x32>
 8013a94:	2100      	movs	r1, #0
 8013a96:	e000      	b.n	8013a9a <lv_obj_set_hidden+0x34>
 8013a98:	2101      	movs	r1, #1
 8013a9a:	687a      	ldr	r2, [r7, #4]
 8013a9c:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8013aa0:	f361 1304 	bfi	r3, r1, #4, #1
 8013aa4:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30

    if(!obj->hidden) lv_obj_invalidate(obj); /*Invalidate when not hidden (hidden objects are ignored) */
 8013aa8:	687b      	ldr	r3, [r7, #4]
 8013aaa:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8013aae:	f003 0310 	and.w	r3, r3, #16
 8013ab2:	b2db      	uxtb	r3, r3
 8013ab4:	2b00      	cmp	r3, #0
 8013ab6:	d102      	bne.n	8013abe <lv_obj_set_hidden+0x58>
 8013ab8:	6878      	ldr	r0, [r7, #4]
 8013aba:	f7ff f8d7 	bl	8012c6c <lv_obj_invalidate>

    lv_obj_t * par = lv_obj_get_parent(obj);
 8013abe:	6878      	ldr	r0, [r7, #4]
 8013ac0:	f000 f938 	bl	8013d34 <lv_obj_get_parent>
 8013ac4:	60f8      	str	r0, [r7, #12]
    par->signal_cb(par, LV_SIGNAL_CHILD_CHG, obj);
 8013ac6:	68fb      	ldr	r3, [r7, #12]
 8013ac8:	69db      	ldr	r3, [r3, #28]
 8013aca:	687a      	ldr	r2, [r7, #4]
 8013acc:	2101      	movs	r1, #1
 8013ace:	68f8      	ldr	r0, [r7, #12]
 8013ad0:	4798      	blx	r3
}
 8013ad2:	bf00      	nop
 8013ad4:	3710      	adds	r7, #16
 8013ad6:	46bd      	mov	sp, r7
 8013ad8:	bd80      	pop	{r7, pc}

08013ada <lv_obj_set_click>:
 * Enable or disable the clicking of an object
 * @param obj pointer to an object
 * @param en true: make the object clickable
 */
void lv_obj_set_click(lv_obj_t * obj, bool en)
{
 8013ada:	b480      	push	{r7}
 8013adc:	b083      	sub	sp, #12
 8013ade:	af00      	add	r7, sp, #0
 8013ae0:	6078      	str	r0, [r7, #4]
 8013ae2:	460b      	mov	r3, r1
 8013ae4:	70fb      	strb	r3, [r7, #3]
    obj->click = (en == true ? 1 : 0);
 8013ae6:	78f9      	ldrb	r1, [r7, #3]
 8013ae8:	687a      	ldr	r2, [r7, #4]
 8013aea:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8013aee:	f361 0300 	bfi	r3, r1, #0, #1
 8013af2:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
}
 8013af6:	bf00      	nop
 8013af8:	370c      	adds	r7, #12
 8013afa:	46bd      	mov	sp, r7
 8013afc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013b00:	4770      	bx	lr

08013b02 <lv_event_send>:
 * @param event the type of the event from `lv_event_t`
 * @param data arbitrary data depending on the object type and the event. (Usually `NULL`)
 * @return LV_RES_OK: `obj` was not deleted in the event; LV_RES_INV: `obj` was deleted in the event
 */
lv_res_t lv_event_send(lv_obj_t * obj, lv_event_t event, const void * data)
{
 8013b02:	b580      	push	{r7, lr}
 8013b04:	b086      	sub	sp, #24
 8013b06:	af00      	add	r7, sp, #0
 8013b08:	60f8      	str	r0, [r7, #12]
 8013b0a:	460b      	mov	r3, r1
 8013b0c:	607a      	str	r2, [r7, #4]
 8013b0e:	72fb      	strb	r3, [r7, #11]
    if(obj == NULL) return LV_RES_OK;
 8013b10:	68fb      	ldr	r3, [r7, #12]
 8013b12:	2b00      	cmp	r3, #0
 8013b14:	d101      	bne.n	8013b1a <lv_event_send+0x18>
 8013b16:	2301      	movs	r3, #1
 8013b18:	e009      	b.n	8013b2e <lv_event_send+0x2c>

    lv_res_t res;
    res = lv_event_send_func(obj->event_cb, obj, event, data);
 8013b1a:	68fb      	ldr	r3, [r7, #12]
 8013b1c:	6998      	ldr	r0, [r3, #24]
 8013b1e:	7afa      	ldrb	r2, [r7, #11]
 8013b20:	687b      	ldr	r3, [r7, #4]
 8013b22:	68f9      	ldr	r1, [r7, #12]
 8013b24:	f000 f808 	bl	8013b38 <lv_event_send_func>
 8013b28:	4603      	mov	r3, r0
 8013b2a:	75fb      	strb	r3, [r7, #23]
    return res;
 8013b2c:	7dfb      	ldrb	r3, [r7, #23]
}
 8013b2e:	4618      	mov	r0, r3
 8013b30:	3718      	adds	r7, #24
 8013b32:	46bd      	mov	sp, r7
 8013b34:	bd80      	pop	{r7, pc}
	...

08013b38 <lv_event_send_func>:
 * @param event an event
 * @param data pointer to a custom data
 * @return LV_RES_OK: `obj` was not deleted in the event; LV_RES_INV: `obj` was deleted in the event
 */
lv_res_t lv_event_send_func(lv_event_cb_t event_xcb, lv_obj_t * obj, lv_event_t event, const void * data)
{
 8013b38:	b580      	push	{r7, lr}
 8013b3a:	b08a      	sub	sp, #40	; 0x28
 8013b3c:	af00      	add	r7, sp, #0
 8013b3e:	60f8      	str	r0, [r7, #12]
 8013b40:	60b9      	str	r1, [r7, #8]
 8013b42:	603b      	str	r3, [r7, #0]
 8013b44:	4613      	mov	r3, r2
 8013b46:	71fb      	strb	r3, [r7, #7]
    /* Build a simple linked list from the objects used in the events
     * It's important to know if an this object was deleted by a nested event
     * called from this `even_cb`. */
    lv_event_temp_data_t event_temp_data;
    event_temp_data.obj     = obj;
 8013b48:	68bb      	ldr	r3, [r7, #8]
 8013b4a:	613b      	str	r3, [r7, #16]
    event_temp_data.deleted = false;
 8013b4c:	2300      	movs	r3, #0
 8013b4e:	753b      	strb	r3, [r7, #20]
    event_temp_data.prev    = NULL;
 8013b50:	2300      	movs	r3, #0
 8013b52:	61bb      	str	r3, [r7, #24]

    if(event_temp_data_head) {
 8013b54:	4b2b      	ldr	r3, [pc, #172]	; (8013c04 <lv_event_send_func+0xcc>)
 8013b56:	681b      	ldr	r3, [r3, #0]
 8013b58:	2b00      	cmp	r3, #0
 8013b5a:	d002      	beq.n	8013b62 <lv_event_send_func+0x2a>
        event_temp_data.prev = event_temp_data_head;
 8013b5c:	4b29      	ldr	r3, [pc, #164]	; (8013c04 <lv_event_send_func+0xcc>)
 8013b5e:	681b      	ldr	r3, [r3, #0]
 8013b60:	61bb      	str	r3, [r7, #24]
    }
    event_temp_data_head = &event_temp_data;
 8013b62:	4a28      	ldr	r2, [pc, #160]	; (8013c04 <lv_event_send_func+0xcc>)
 8013b64:	f107 0310 	add.w	r3, r7, #16
 8013b68:	6013      	str	r3, [r2, #0]

    const void * event_act_data_save = event_act_data;
 8013b6a:	4b27      	ldr	r3, [pc, #156]	; (8013c08 <lv_event_send_func+0xd0>)
 8013b6c:	681b      	ldr	r3, [r3, #0]
 8013b6e:	627b      	str	r3, [r7, #36]	; 0x24
    event_act_data                   = data;
 8013b70:	4a25      	ldr	r2, [pc, #148]	; (8013c08 <lv_event_send_func+0xd0>)
 8013b72:	683b      	ldr	r3, [r7, #0]
 8013b74:	6013      	str	r3, [r2, #0]

    /*Call the input device's feedback callback if set*/
    lv_indev_t * indev_act = lv_indev_get_act();
 8013b76:	f7fe fd67 	bl	8012648 <lv_indev_get_act>
 8013b7a:	6238      	str	r0, [r7, #32]
    if(indev_act) {
 8013b7c:	6a3b      	ldr	r3, [r7, #32]
 8013b7e:	2b00      	cmp	r3, #0
 8013b80:	d009      	beq.n	8013b96 <lv_event_send_func+0x5e>
        if(indev_act->driver.feedback_cb) indev_act->driver.feedback_cb(&indev_act->driver, event);
 8013b82:	6a3b      	ldr	r3, [r7, #32]
 8013b84:	689b      	ldr	r3, [r3, #8]
 8013b86:	2b00      	cmp	r3, #0
 8013b88:	d005      	beq.n	8013b96 <lv_event_send_func+0x5e>
 8013b8a:	6a3b      	ldr	r3, [r7, #32]
 8013b8c:	689b      	ldr	r3, [r3, #8]
 8013b8e:	6a3a      	ldr	r2, [r7, #32]
 8013b90:	79f9      	ldrb	r1, [r7, #7]
 8013b92:	4610      	mov	r0, r2
 8013b94:	4798      	blx	r3
    }

    /*Call the event callback itself*/
    if(event_xcb) event_xcb(obj, event);
 8013b96:	68fb      	ldr	r3, [r7, #12]
 8013b98:	2b00      	cmp	r3, #0
 8013b9a:	d004      	beq.n	8013ba6 <lv_event_send_func+0x6e>
 8013b9c:	79fa      	ldrb	r2, [r7, #7]
 8013b9e:	68fb      	ldr	r3, [r7, #12]
 8013ba0:	4611      	mov	r1, r2
 8013ba2:	68b8      	ldr	r0, [r7, #8]
 8013ba4:	4798      	blx	r3

    /*Restore the event data*/
    event_act_data = event_act_data_save;
 8013ba6:	4a18      	ldr	r2, [pc, #96]	; (8013c08 <lv_event_send_func+0xd0>)
 8013ba8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8013baa:	6013      	str	r3, [r2, #0]

    /*Remove this element from the list*/
    event_temp_data_head = event_temp_data_head->prev;
 8013bac:	4b15      	ldr	r3, [pc, #84]	; (8013c04 <lv_event_send_func+0xcc>)
 8013bae:	681b      	ldr	r3, [r3, #0]
 8013bb0:	689b      	ldr	r3, [r3, #8]
 8013bb2:	4a14      	ldr	r2, [pc, #80]	; (8013c04 <lv_event_send_func+0xcc>)
 8013bb4:	6013      	str	r3, [r2, #0]

    if(event_temp_data.deleted) {
 8013bb6:	7d3b      	ldrb	r3, [r7, #20]
 8013bb8:	2b00      	cmp	r3, #0
 8013bba:	d001      	beq.n	8013bc0 <lv_event_send_func+0x88>
        return LV_RES_INV;
 8013bbc:	2300      	movs	r3, #0
 8013bbe:	e01d      	b.n	8013bfc <lv_event_send_func+0xc4>
    }

    if(obj) {
 8013bc0:	68bb      	ldr	r3, [r7, #8]
 8013bc2:	2b00      	cmp	r3, #0
 8013bc4:	d019      	beq.n	8013bfa <lv_event_send_func+0xc2>
        if(obj->parent_event && obj->par) {
 8013bc6:	68bb      	ldr	r3, [r7, #8]
 8013bc8:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8013bcc:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8013bd0:	b2db      	uxtb	r3, r3
 8013bd2:	2b00      	cmp	r3, #0
 8013bd4:	d011      	beq.n	8013bfa <lv_event_send_func+0xc2>
 8013bd6:	68bb      	ldr	r3, [r7, #8]
 8013bd8:	681b      	ldr	r3, [r3, #0]
 8013bda:	2b00      	cmp	r3, #0
 8013bdc:	d00d      	beq.n	8013bfa <lv_event_send_func+0xc2>
            lv_res_t res = lv_event_send(obj->par, event, data);
 8013bde:	68bb      	ldr	r3, [r7, #8]
 8013be0:	681b      	ldr	r3, [r3, #0]
 8013be2:	79f9      	ldrb	r1, [r7, #7]
 8013be4:	683a      	ldr	r2, [r7, #0]
 8013be6:	4618      	mov	r0, r3
 8013be8:	f7ff ff8b 	bl	8013b02 <lv_event_send>
 8013bec:	4603      	mov	r3, r0
 8013bee:	77fb      	strb	r3, [r7, #31]
            if(res != LV_RES_OK) {
 8013bf0:	7ffb      	ldrb	r3, [r7, #31]
 8013bf2:	2b01      	cmp	r3, #1
 8013bf4:	d001      	beq.n	8013bfa <lv_event_send_func+0xc2>
                return LV_RES_INV;
 8013bf6:	2300      	movs	r3, #0
 8013bf8:	e000      	b.n	8013bfc <lv_event_send_func+0xc4>
            }
        }
    }

    return LV_RES_OK;
 8013bfa:	2301      	movs	r3, #1
}
 8013bfc:	4618      	mov	r0, r3
 8013bfe:	3728      	adds	r7, #40	; 0x28
 8013c00:	46bd      	mov	sp, r7
 8013c02:	bd80      	pop	{r7, pc}
 8013c04:	240623bc 	.word	0x240623bc
 8013c08:	240623c0 	.word	0x240623c0

08013c0c <lv_obj_set_signal_cb>:
 * Always call the previous signal function in the new.
 * @param obj pointer to an object
 * @param cb the new signal function
 */
void lv_obj_set_signal_cb(lv_obj_t * obj, lv_signal_cb_t signal_cb)
{
 8013c0c:	b480      	push	{r7}
 8013c0e:	b083      	sub	sp, #12
 8013c10:	af00      	add	r7, sp, #0
 8013c12:	6078      	str	r0, [r7, #4]
 8013c14:	6039      	str	r1, [r7, #0]
    obj->signal_cb = signal_cb;
 8013c16:	687b      	ldr	r3, [r7, #4]
 8013c18:	683a      	ldr	r2, [r7, #0]
 8013c1a:	61da      	str	r2, [r3, #28]
}
 8013c1c:	bf00      	nop
 8013c1e:	370c      	adds	r7, #12
 8013c20:	46bd      	mov	sp, r7
 8013c22:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013c26:	4770      	bx	lr

08013c28 <lv_obj_set_design_cb>:
 * Set a new design function for an object
 * @param obj pointer to an object
 * @param design_cb the new design function
 */
void lv_obj_set_design_cb(lv_obj_t * obj, lv_design_cb_t design_cb)
{
 8013c28:	b480      	push	{r7}
 8013c2a:	b083      	sub	sp, #12
 8013c2c:	af00      	add	r7, sp, #0
 8013c2e:	6078      	str	r0, [r7, #4]
 8013c30:	6039      	str	r1, [r7, #0]
    obj->design_cb = design_cb;
 8013c32:	687b      	ldr	r3, [r7, #4]
 8013c34:	683a      	ldr	r2, [r7, #0]
 8013c36:	621a      	str	r2, [r3, #32]
}
 8013c38:	bf00      	nop
 8013c3a:	370c      	adds	r7, #12
 8013c3c:	46bd      	mov	sp, r7
 8013c3e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013c42:	4770      	bx	lr

08013c44 <lv_obj_allocate_ext_attr>:
 * @param obj pointer to an object
 * @param ext_size the size of the new ext. data
 * @return Normal pointer to the allocated ext
 */
void * lv_obj_allocate_ext_attr(lv_obj_t * obj, uint16_t ext_size)
{
 8013c44:	b580      	push	{r7, lr}
 8013c46:	b082      	sub	sp, #8
 8013c48:	af00      	add	r7, sp, #0
 8013c4a:	6078      	str	r0, [r7, #4]
 8013c4c:	460b      	mov	r3, r1
 8013c4e:	807b      	strh	r3, [r7, #2]
    obj->ext_attr = lv_mem_realloc(obj->ext_attr, ext_size);
 8013c50:	687b      	ldr	r3, [r7, #4]
 8013c52:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8013c54:	887a      	ldrh	r2, [r7, #2]
 8013c56:	4611      	mov	r1, r2
 8013c58:	4618      	mov	r0, r3
 8013c5a:	f00a fa91 	bl	801e180 <lv_mem_realloc>
 8013c5e:	4602      	mov	r2, r0
 8013c60:	687b      	ldr	r3, [r7, #4]
 8013c62:	625a      	str	r2, [r3, #36]	; 0x24

    return (void *)obj->ext_attr;
 8013c64:	687b      	ldr	r3, [r7, #4]
 8013c66:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8013c68:	4618      	mov	r0, r3
 8013c6a:	3708      	adds	r7, #8
 8013c6c:	46bd      	mov	sp, r7
 8013c6e:	bd80      	pop	{r7, pc}

08013c70 <lv_obj_refresh_ext_draw_pad>:
/**
 * Send a 'LV_SIGNAL_REFR_EXT_SIZE' signal to the object
 * @param obj pointer to an object
 */
void lv_obj_refresh_ext_draw_pad(lv_obj_t * obj)
{
 8013c70:	b580      	push	{r7, lr}
 8013c72:	b082      	sub	sp, #8
 8013c74:	af00      	add	r7, sp, #0
 8013c76:	6078      	str	r0, [r7, #4]
    obj->ext_draw_pad = 0;
 8013c78:	687b      	ldr	r3, [r7, #4]
 8013c7a:	2200      	movs	r2, #0
 8013c7c:	869a      	strh	r2, [r3, #52]	; 0x34
    obj->signal_cb(obj, LV_SIGNAL_REFR_EXT_DRAW_PAD, NULL);
 8013c7e:	687b      	ldr	r3, [r7, #4]
 8013c80:	69db      	ldr	r3, [r3, #28]
 8013c82:	2200      	movs	r2, #0
 8013c84:	2105      	movs	r1, #5
 8013c86:	6878      	ldr	r0, [r7, #4]
 8013c88:	4798      	blx	r3

    lv_obj_invalidate(obj);
 8013c8a:	6878      	ldr	r0, [r7, #4]
 8013c8c:	f7fe ffee 	bl	8012c6c <lv_obj_invalidate>
}
 8013c90:	bf00      	nop
 8013c92:	3708      	adds	r7, #8
 8013c94:	46bd      	mov	sp, r7
 8013c96:	bd80      	pop	{r7, pc}

08013c98 <lv_obj_get_screen>:
 * Return with the screen of an object
 * @param obj pointer to an object
 * @return pointer to a screen
 */
lv_obj_t * lv_obj_get_screen(const lv_obj_t * obj)
{
 8013c98:	b580      	push	{r7, lr}
 8013c9a:	b084      	sub	sp, #16
 8013c9c:	af00      	add	r7, sp, #0
 8013c9e:	6078      	str	r0, [r7, #4]
    const lv_obj_t * par = obj;
 8013ca0:	687b      	ldr	r3, [r7, #4]
 8013ca2:	60fb      	str	r3, [r7, #12]
    const lv_obj_t * act_p;

    do {
        act_p = par;
 8013ca4:	68fb      	ldr	r3, [r7, #12]
 8013ca6:	60bb      	str	r3, [r7, #8]
        par   = lv_obj_get_parent(act_p);
 8013ca8:	68b8      	ldr	r0, [r7, #8]
 8013caa:	f000 f843 	bl	8013d34 <lv_obj_get_parent>
 8013cae:	60f8      	str	r0, [r7, #12]
    } while(par != NULL);
 8013cb0:	68fb      	ldr	r3, [r7, #12]
 8013cb2:	2b00      	cmp	r3, #0
 8013cb4:	d1f6      	bne.n	8013ca4 <lv_obj_get_screen+0xc>

    return (lv_obj_t *)act_p;
 8013cb6:	68bb      	ldr	r3, [r7, #8]
}
 8013cb8:	4618      	mov	r0, r3
 8013cba:	3710      	adds	r7, #16
 8013cbc:	46bd      	mov	sp, r7
 8013cbe:	bd80      	pop	{r7, pc}

08013cc0 <lv_obj_get_disp>:
 * Get the display of an object
 * @param scr pointer to an object
 * @return pointer the object's display
 */
lv_disp_t * lv_obj_get_disp(const lv_obj_t * obj)
{
 8013cc0:	b580      	push	{r7, lr}
 8013cc2:	b086      	sub	sp, #24
 8013cc4:	af00      	add	r7, sp, #0
 8013cc6:	6078      	str	r0, [r7, #4]
    const lv_obj_t * scr;

    if(obj->par == NULL)
 8013cc8:	687b      	ldr	r3, [r7, #4]
 8013cca:	681b      	ldr	r3, [r3, #0]
 8013ccc:	2b00      	cmp	r3, #0
 8013cce:	d102      	bne.n	8013cd6 <lv_obj_get_disp+0x16>
        scr = obj; /*`obj` is a screen*/
 8013cd0:	687b      	ldr	r3, [r7, #4]
 8013cd2:	617b      	str	r3, [r7, #20]
 8013cd4:	e003      	b.n	8013cde <lv_obj_get_disp+0x1e>
    else
        scr = lv_obj_get_screen(obj); /*get the screen of `obj`*/
 8013cd6:	6878      	ldr	r0, [r7, #4]
 8013cd8:	f7ff ffde 	bl	8013c98 <lv_obj_get_screen>
 8013cdc:	6178      	str	r0, [r7, #20]

    lv_disp_t * d;
    LV_LL_READ(LV_GC_ROOT(_lv_disp_ll), d)
 8013cde:	4814      	ldr	r0, [pc, #80]	; (8013d30 <lv_obj_get_disp+0x70>)
 8013ce0:	f00a f880 	bl	801dde4 <lv_ll_get_head>
 8013ce4:	6138      	str	r0, [r7, #16]
 8013ce6:	e01b      	b.n	8013d20 <lv_obj_get_disp+0x60>
    {
        lv_obj_t * s;
        LV_LL_READ(d->scr_ll, s)
 8013ce8:	693b      	ldr	r3, [r7, #16]
 8013cea:	3324      	adds	r3, #36	; 0x24
 8013cec:	4618      	mov	r0, r3
 8013cee:	f00a f879 	bl	801dde4 <lv_ll_get_head>
 8013cf2:	60f8      	str	r0, [r7, #12]
 8013cf4:	e00c      	b.n	8013d10 <lv_obj_get_disp+0x50>
        {
            if(s == scr) return d;
 8013cf6:	68fa      	ldr	r2, [r7, #12]
 8013cf8:	697b      	ldr	r3, [r7, #20]
 8013cfa:	429a      	cmp	r2, r3
 8013cfc:	d101      	bne.n	8013d02 <lv_obj_get_disp+0x42>
 8013cfe:	693b      	ldr	r3, [r7, #16]
 8013d00:	e012      	b.n	8013d28 <lv_obj_get_disp+0x68>
        LV_LL_READ(d->scr_ll, s)
 8013d02:	693b      	ldr	r3, [r7, #16]
 8013d04:	3324      	adds	r3, #36	; 0x24
 8013d06:	68f9      	ldr	r1, [r7, #12]
 8013d08:	4618      	mov	r0, r3
 8013d0a:	f00a f891 	bl	801de30 <lv_ll_get_next>
 8013d0e:	60f8      	str	r0, [r7, #12]
 8013d10:	68fb      	ldr	r3, [r7, #12]
 8013d12:	2b00      	cmp	r3, #0
 8013d14:	d1ef      	bne.n	8013cf6 <lv_obj_get_disp+0x36>
    LV_LL_READ(LV_GC_ROOT(_lv_disp_ll), d)
 8013d16:	6939      	ldr	r1, [r7, #16]
 8013d18:	4805      	ldr	r0, [pc, #20]	; (8013d30 <lv_obj_get_disp+0x70>)
 8013d1a:	f00a f889 	bl	801de30 <lv_ll_get_next>
 8013d1e:	6138      	str	r0, [r7, #16]
 8013d20:	693b      	ldr	r3, [r7, #16]
 8013d22:	2b00      	cmp	r3, #0
 8013d24:	d1e0      	bne.n	8013ce8 <lv_obj_get_disp+0x28>
        }
    }

    LV_LOG_WARN("lv_scr_get_disp: screen not found")
    return NULL;
 8013d26:	2300      	movs	r3, #0
}
 8013d28:	4618      	mov	r0, r3
 8013d2a:	3718      	adds	r7, #24
 8013d2c:	46bd      	mov	sp, r7
 8013d2e:	bd80      	pop	{r7, pc}
 8013d30:	24063640 	.word	0x24063640

08013d34 <lv_obj_get_parent>:
 * Returns with the parent of an object
 * @param obj pointer to an object
 * @return pointer to the parent of  'obj'
 */
lv_obj_t * lv_obj_get_parent(const lv_obj_t * obj)
{
 8013d34:	b480      	push	{r7}
 8013d36:	b083      	sub	sp, #12
 8013d38:	af00      	add	r7, sp, #0
 8013d3a:	6078      	str	r0, [r7, #4]
    return obj->par;
 8013d3c:	687b      	ldr	r3, [r7, #4]
 8013d3e:	681b      	ldr	r3, [r3, #0]
}
 8013d40:	4618      	mov	r0, r3
 8013d42:	370c      	adds	r7, #12
 8013d44:	46bd      	mov	sp, r7
 8013d46:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013d4a:	4770      	bx	lr

08013d4c <lv_obj_get_child>:
 * @param child NULL at first call to get the next children
 *                  and the previous return value later
 * @return the child after 'act_child' or NULL if no more child
 */
lv_obj_t * lv_obj_get_child(const lv_obj_t * obj, const lv_obj_t * child)
{
 8013d4c:	b580      	push	{r7, lr}
 8013d4e:	b084      	sub	sp, #16
 8013d50:	af00      	add	r7, sp, #0
 8013d52:	6078      	str	r0, [r7, #4]
 8013d54:	6039      	str	r1, [r7, #0]
    lv_obj_t * result = NULL;
 8013d56:	2300      	movs	r3, #0
 8013d58:	60fb      	str	r3, [r7, #12]

    if(child == NULL) {
 8013d5a:	683b      	ldr	r3, [r7, #0]
 8013d5c:	2b00      	cmp	r3, #0
 8013d5e:	d106      	bne.n	8013d6e <lv_obj_get_child+0x22>
        result = lv_ll_get_head(&obj->child_ll);
 8013d60:	687b      	ldr	r3, [r7, #4]
 8013d62:	3304      	adds	r3, #4
 8013d64:	4618      	mov	r0, r3
 8013d66:	f00a f83d 	bl	801dde4 <lv_ll_get_head>
 8013d6a:	60f8      	str	r0, [r7, #12]
 8013d6c:	e006      	b.n	8013d7c <lv_obj_get_child+0x30>
    } else {
        result = lv_ll_get_next(&obj->child_ll, child);
 8013d6e:	687b      	ldr	r3, [r7, #4]
 8013d70:	3304      	adds	r3, #4
 8013d72:	6839      	ldr	r1, [r7, #0]
 8013d74:	4618      	mov	r0, r3
 8013d76:	f00a f85b 	bl	801de30 <lv_ll_get_next>
 8013d7a:	60f8      	str	r0, [r7, #12]
    }

    return result;
 8013d7c:	68fb      	ldr	r3, [r7, #12]
}
 8013d7e:	4618      	mov	r0, r3
 8013d80:	3710      	adds	r7, #16
 8013d82:	46bd      	mov	sp, r7
 8013d84:	bd80      	pop	{r7, pc}

08013d86 <lv_obj_get_coords>:
 * Copy the coordinates of an object to an area
 * @param obj pointer to an object
 * @param cords_p pointer to an area to store the coordinates
 */
void lv_obj_get_coords(const lv_obj_t * obj, lv_area_t * cords_p)
{
 8013d86:	b580      	push	{r7, lr}
 8013d88:	b082      	sub	sp, #8
 8013d8a:	af00      	add	r7, sp, #0
 8013d8c:	6078      	str	r0, [r7, #4]
 8013d8e:	6039      	str	r1, [r7, #0]
    lv_area_copy(cords_p, &obj->coords);
 8013d90:	687b      	ldr	r3, [r7, #4]
 8013d92:	3310      	adds	r3, #16
 8013d94:	4619      	mov	r1, r3
 8013d96:	6838      	ldr	r0, [r7, #0]
 8013d98:	f7fe fc88 	bl	80126ac <lv_area_copy>
}
 8013d9c:	bf00      	nop
 8013d9e:	3708      	adds	r7, #8
 8013da0:	46bd      	mov	sp, r7
 8013da2:	bd80      	pop	{r7, pc}

08013da4 <lv_obj_get_x>:
 * Get the x coordinate of object
 * @param obj pointer to an object
 * @return distance of 'obj' from the left side of its parent
 */
lv_coord_t lv_obj_get_x(const lv_obj_t * obj)
{
 8013da4:	b580      	push	{r7, lr}
 8013da6:	b084      	sub	sp, #16
 8013da8:	af00      	add	r7, sp, #0
 8013daa:	6078      	str	r0, [r7, #4]
    lv_coord_t rel_x;
    lv_obj_t * parent = lv_obj_get_parent(obj);
 8013dac:	6878      	ldr	r0, [r7, #4]
 8013dae:	f7ff ffc1 	bl	8013d34 <lv_obj_get_parent>
 8013db2:	60f8      	str	r0, [r7, #12]
    rel_x             = obj->coords.x1 - parent->coords.x1;
 8013db4:	687b      	ldr	r3, [r7, #4]
 8013db6:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8013dba:	b29a      	uxth	r2, r3
 8013dbc:	68fb      	ldr	r3, [r7, #12]
 8013dbe:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8013dc2:	b29b      	uxth	r3, r3
 8013dc4:	1ad3      	subs	r3, r2, r3
 8013dc6:	b29b      	uxth	r3, r3
 8013dc8:	817b      	strh	r3, [r7, #10]

    return rel_x;
 8013dca:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
}
 8013dce:	4618      	mov	r0, r3
 8013dd0:	3710      	adds	r7, #16
 8013dd2:	46bd      	mov	sp, r7
 8013dd4:	bd80      	pop	{r7, pc}

08013dd6 <lv_obj_get_y>:
 * Get the y coordinate of object
 * @param obj pointer to an object
 * @return distance of 'obj' from the top of its parent
 */
lv_coord_t lv_obj_get_y(const lv_obj_t * obj)
{
 8013dd6:	b580      	push	{r7, lr}
 8013dd8:	b084      	sub	sp, #16
 8013dda:	af00      	add	r7, sp, #0
 8013ddc:	6078      	str	r0, [r7, #4]
    lv_coord_t rel_y;
    lv_obj_t * parent = lv_obj_get_parent(obj);
 8013dde:	6878      	ldr	r0, [r7, #4]
 8013de0:	f7ff ffa8 	bl	8013d34 <lv_obj_get_parent>
 8013de4:	60f8      	str	r0, [r7, #12]
    rel_y             = obj->coords.y1 - parent->coords.y1;
 8013de6:	687b      	ldr	r3, [r7, #4]
 8013de8:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8013dec:	b29a      	uxth	r2, r3
 8013dee:	68fb      	ldr	r3, [r7, #12]
 8013df0:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8013df4:	b29b      	uxth	r3, r3
 8013df6:	1ad3      	subs	r3, r2, r3
 8013df8:	b29b      	uxth	r3, r3
 8013dfa:	817b      	strh	r3, [r7, #10]

    return rel_y;
 8013dfc:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
}
 8013e00:	4618      	mov	r0, r3
 8013e02:	3710      	adds	r7, #16
 8013e04:	46bd      	mov	sp, r7
 8013e06:	bd80      	pop	{r7, pc}

08013e08 <lv_obj_get_width>:
 * Get the width of an object
 * @param obj pointer to an object
 * @return the width
 */
lv_coord_t lv_obj_get_width(const lv_obj_t * obj)
{
 8013e08:	b580      	push	{r7, lr}
 8013e0a:	b082      	sub	sp, #8
 8013e0c:	af00      	add	r7, sp, #0
 8013e0e:	6078      	str	r0, [r7, #4]
    return lv_area_get_width(&obj->coords);
 8013e10:	687b      	ldr	r3, [r7, #4]
 8013e12:	3310      	adds	r3, #16
 8013e14:	4618      	mov	r0, r3
 8013e16:	f7fe fc57 	bl	80126c8 <lv_area_get_width>
 8013e1a:	4603      	mov	r3, r0
}
 8013e1c:	4618      	mov	r0, r3
 8013e1e:	3708      	adds	r7, #8
 8013e20:	46bd      	mov	sp, r7
 8013e22:	bd80      	pop	{r7, pc}

08013e24 <lv_obj_get_height>:
 * Get the height of an object
 * @param obj pointer to an object
 * @return the height
 */
lv_coord_t lv_obj_get_height(const lv_obj_t * obj)
{
 8013e24:	b580      	push	{r7, lr}
 8013e26:	b082      	sub	sp, #8
 8013e28:	af00      	add	r7, sp, #0
 8013e2a:	6078      	str	r0, [r7, #4]
    return lv_area_get_height(&obj->coords);
 8013e2c:	687b      	ldr	r3, [r7, #4]
 8013e2e:	3310      	adds	r3, #16
 8013e30:	4618      	mov	r0, r3
 8013e32:	f7fe fc60 	bl	80126f6 <lv_area_get_height>
 8013e36:	4603      	mov	r3, r0
}
 8013e38:	4618      	mov	r0, r3
 8013e3a:	3708      	adds	r7, #8
 8013e3c:	46bd      	mov	sp, r7
 8013e3e:	bd80      	pop	{r7, pc}

08013e40 <lv_obj_get_style>:
 * Get the style pointer of an object (if NULL get style of the parent)
 * @param obj pointer to an object
 * @return pointer to a style
 */
const lv_style_t * lv_obj_get_style(const lv_obj_t * obj)
{
 8013e40:	b580      	push	{r7, lr}
 8013e42:	b086      	sub	sp, #24
 8013e44:	af00      	add	r7, sp, #0
 8013e46:	6078      	str	r0, [r7, #4]
    const lv_style_t * style_act = obj->style_p;
 8013e48:	687b      	ldr	r3, [r7, #4]
 8013e4a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8013e4c:	617b      	str	r3, [r7, #20]
    if(style_act == NULL) {
 8013e4e:	697b      	ldr	r3, [r7, #20]
 8013e50:	2b00      	cmp	r3, #0
 8013e52:	d12c      	bne.n	8013eae <lv_obj_get_style+0x6e>
        lv_obj_t * par = obj->par;
 8013e54:	687b      	ldr	r3, [r7, #4]
 8013e56:	681b      	ldr	r3, [r3, #0]
 8013e58:	613b      	str	r3, [r7, #16]

        while(par) {
 8013e5a:	e025      	b.n	8013ea8 <lv_obj_get_style+0x68>
            if(par->style_p) {
 8013e5c:	693b      	ldr	r3, [r7, #16]
 8013e5e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8013e60:	2b00      	cmp	r3, #0
 8013e62:	d01e      	beq.n	8013ea2 <lv_obj_get_style+0x62>
                if(par->style_p->glass == 0) {
 8013e64:	693b      	ldr	r3, [r7, #16]
 8013e66:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8013e68:	781b      	ldrb	r3, [r3, #0]
 8013e6a:	f003 0301 	and.w	r3, r3, #1
 8013e6e:	b2db      	uxtb	r3, r3
 8013e70:	2b00      	cmp	r3, #0
 8013e72:	d116      	bne.n	8013ea2 <lv_obj_get_style+0x62>
#if LV_USE_GROUP == 0
                    style_act = par->style_p;
#else
                    /*If a parent is focused then use then focused style*/
                    lv_group_t * g = lv_obj_get_group(par);
 8013e74:	6938      	ldr	r0, [r7, #16]
 8013e76:	f000 f8aa 	bl	8013fce <lv_obj_get_group>
 8013e7a:	60f8      	str	r0, [r7, #12]
                    if(lv_group_get_focused(g) == par) {
 8013e7c:	68f8      	ldr	r0, [r7, #12]
 8013e7e:	f7fe faa1 	bl	80123c4 <lv_group_get_focused>
 8013e82:	4602      	mov	r2, r0
 8013e84:	693b      	ldr	r3, [r7, #16]
 8013e86:	4293      	cmp	r3, r2
 8013e88:	d107      	bne.n	8013e9a <lv_obj_get_style+0x5a>
                        style_act = lv_group_mod_style(g, par->style_p);
 8013e8a:	693b      	ldr	r3, [r7, #16]
 8013e8c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8013e8e:	4619      	mov	r1, r3
 8013e90:	68f8      	ldr	r0, [r7, #12]
 8013e92:	f7fe fa67 	bl	8012364 <lv_group_mod_style>
 8013e96:	6178      	str	r0, [r7, #20]
                    } else {
                        style_act = par->style_p;
                    }
#endif
                    break;
 8013e98:	e009      	b.n	8013eae <lv_obj_get_style+0x6e>
                        style_act = par->style_p;
 8013e9a:	693b      	ldr	r3, [r7, #16]
 8013e9c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8013e9e:	617b      	str	r3, [r7, #20]
                    break;
 8013ea0:	e005      	b.n	8013eae <lv_obj_get_style+0x6e>
                }
            }
            par = par->par;
 8013ea2:	693b      	ldr	r3, [r7, #16]
 8013ea4:	681b      	ldr	r3, [r3, #0]
 8013ea6:	613b      	str	r3, [r7, #16]
        while(par) {
 8013ea8:	693b      	ldr	r3, [r7, #16]
 8013eaa:	2b00      	cmp	r3, #0
 8013eac:	d1d6      	bne.n	8013e5c <lv_obj_get_style+0x1c>
        }
    }
#if LV_USE_GROUP
    if(obj->group_p) {
 8013eae:	687b      	ldr	r3, [r7, #4]
 8013eb0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8013eb2:	2b00      	cmp	r3, #0
 8013eb4:	d00f      	beq.n	8013ed6 <lv_obj_get_style+0x96>
        if(lv_group_get_focused(obj->group_p) == obj) {
 8013eb6:	687b      	ldr	r3, [r7, #4]
 8013eb8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8013eba:	4618      	mov	r0, r3
 8013ebc:	f7fe fa82 	bl	80123c4 <lv_group_get_focused>
 8013ec0:	4602      	mov	r2, r0
 8013ec2:	687b      	ldr	r3, [r7, #4]
 8013ec4:	4293      	cmp	r3, r2
 8013ec6:	d106      	bne.n	8013ed6 <lv_obj_get_style+0x96>
            style_act = lv_group_mod_style(obj->group_p, style_act);
 8013ec8:	687b      	ldr	r3, [r7, #4]
 8013eca:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8013ecc:	6979      	ldr	r1, [r7, #20]
 8013ece:	4618      	mov	r0, r3
 8013ed0:	f7fe fa48 	bl	8012364 <lv_group_mod_style>
 8013ed4:	6178      	str	r0, [r7, #20]
        }
    }
#endif

    if(style_act == NULL) style_act = &lv_style_plain;
 8013ed6:	697b      	ldr	r3, [r7, #20]
 8013ed8:	2b00      	cmp	r3, #0
 8013eda:	d101      	bne.n	8013ee0 <lv_obj_get_style+0xa0>
 8013edc:	4b03      	ldr	r3, [pc, #12]	; (8013eec <lv_obj_get_style+0xac>)
 8013ede:	617b      	str	r3, [r7, #20]

    return style_act;
 8013ee0:	697b      	ldr	r3, [r7, #20]
}
 8013ee2:	4618      	mov	r0, r3
 8013ee4:	3718      	adds	r7, #24
 8013ee6:	46bd      	mov	sp, r7
 8013ee8:	bd80      	pop	{r7, pc}
 8013eea:	bf00      	nop
 8013eec:	240634f8 	.word	0x240634f8

08013ef0 <lv_obj_get_hidden>:
 * Get the hidden attribute of an object
 * @param obj pointer to an object
 * @return true: the object is hidden
 */
bool lv_obj_get_hidden(const lv_obj_t * obj)
{
 8013ef0:	b480      	push	{r7}
 8013ef2:	b083      	sub	sp, #12
 8013ef4:	af00      	add	r7, sp, #0
 8013ef6:	6078      	str	r0, [r7, #4]
    return obj->hidden == 0 ? false : true;
 8013ef8:	687b      	ldr	r3, [r7, #4]
 8013efa:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8013efe:	f003 0310 	and.w	r3, r3, #16
 8013f02:	b2db      	uxtb	r3, r3
 8013f04:	2b00      	cmp	r3, #0
 8013f06:	bf14      	ite	ne
 8013f08:	2301      	movne	r3, #1
 8013f0a:	2300      	moveq	r3, #0
 8013f0c:	b2db      	uxtb	r3, r3
}
 8013f0e:	4618      	mov	r0, r3
 8013f10:	370c      	adds	r7, #12
 8013f12:	46bd      	mov	sp, r7
 8013f14:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013f18:	4770      	bx	lr

08013f1a <lv_obj_get_opa_scale>:
 * Get the opa scale parameter of an object
 * @param obj pointer to an object
 * @return opa scale [0..255]
 */
lv_opa_t lv_obj_get_opa_scale(const lv_obj_t * obj)
{
 8013f1a:	b580      	push	{r7, lr}
 8013f1c:	b084      	sub	sp, #16
 8013f1e:	af00      	add	r7, sp, #0
 8013f20:	6078      	str	r0, [r7, #4]
    const lv_obj_t * parent = obj;
 8013f22:	687b      	ldr	r3, [r7, #4]
 8013f24:	60fb      	str	r3, [r7, #12]

    while(parent) {
 8013f26:	e00f      	b.n	8013f48 <lv_obj_get_opa_scale+0x2e>
        if(parent->opa_scale_en) return parent->opa_scale;
 8013f28:	68fb      	ldr	r3, [r7, #12]
 8013f2a:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8013f2e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8013f32:	b2db      	uxtb	r3, r3
 8013f34:	2b00      	cmp	r3, #0
 8013f36:	d003      	beq.n	8013f40 <lv_obj_get_opa_scale+0x26>
 8013f38:	68fb      	ldr	r3, [r7, #12]
 8013f3a:	f893 3033 	ldrb.w	r3, [r3, #51]	; 0x33
 8013f3e:	e007      	b.n	8013f50 <lv_obj_get_opa_scale+0x36>
        parent = lv_obj_get_parent(parent);
 8013f40:	68f8      	ldr	r0, [r7, #12]
 8013f42:	f7ff fef7 	bl	8013d34 <lv_obj_get_parent>
 8013f46:	60f8      	str	r0, [r7, #12]
    while(parent) {
 8013f48:	68fb      	ldr	r3, [r7, #12]
 8013f4a:	2b00      	cmp	r3, #0
 8013f4c:	d1ec      	bne.n	8013f28 <lv_obj_get_opa_scale+0xe>
    }

    return LV_OPA_COVER;
 8013f4e:	23ff      	movs	r3, #255	; 0xff
}
 8013f50:	4618      	mov	r0, r3
 8013f52:	3710      	adds	r7, #16
 8013f54:	46bd      	mov	sp, r7
 8013f56:	bd80      	pop	{r7, pc}

08013f58 <lv_obj_is_protected>:
 * @param obj pointer to an object
 * @param prot protect bits to test ('OR'ed values of `lv_protect_t`)
 * @return false: none of the given bits are set, true: at least one bit is set
 */
bool lv_obj_is_protected(const lv_obj_t * obj, uint8_t prot)
{
 8013f58:	b480      	push	{r7}
 8013f5a:	b083      	sub	sp, #12
 8013f5c:	af00      	add	r7, sp, #0
 8013f5e:	6078      	str	r0, [r7, #4]
 8013f60:	460b      	mov	r3, r1
 8013f62:	70fb      	strb	r3, [r7, #3]
    return (obj->protect & prot) == 0 ? false : true;
 8013f64:	687b      	ldr	r3, [r7, #4]
 8013f66:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
 8013f6a:	78fb      	ldrb	r3, [r7, #3]
 8013f6c:	4013      	ands	r3, r2
 8013f6e:	b2db      	uxtb	r3, r3
 8013f70:	2b00      	cmp	r3, #0
 8013f72:	bf14      	ite	ne
 8013f74:	2301      	movne	r3, #1
 8013f76:	2300      	moveq	r3, #0
 8013f78:	b2db      	uxtb	r3, r3
}
 8013f7a:	4618      	mov	r0, r3
 8013f7c:	370c      	adds	r7, #12
 8013f7e:	46bd      	mov	sp, r7
 8013f80:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013f84:	4770      	bx	lr

08013f86 <lv_obj_get_signal_cb>:
 * Get the signal function of an object
 * @param obj pointer to an object
 * @return the signal function
 */
lv_signal_cb_t lv_obj_get_signal_cb(const lv_obj_t * obj)
{
 8013f86:	b480      	push	{r7}
 8013f88:	b083      	sub	sp, #12
 8013f8a:	af00      	add	r7, sp, #0
 8013f8c:	6078      	str	r0, [r7, #4]
    return obj->signal_cb;
 8013f8e:	687b      	ldr	r3, [r7, #4]
 8013f90:	69db      	ldr	r3, [r3, #28]
}
 8013f92:	4618      	mov	r0, r3
 8013f94:	370c      	adds	r7, #12
 8013f96:	46bd      	mov	sp, r7
 8013f98:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013f9c:	4770      	bx	lr

08013f9e <lv_obj_get_design_cb>:
 * Get the design function of an object
 * @param obj pointer to an object
 * @return the design function
 */
lv_design_cb_t lv_obj_get_design_cb(const lv_obj_t * obj)
{
 8013f9e:	b480      	push	{r7}
 8013fa0:	b083      	sub	sp, #12
 8013fa2:	af00      	add	r7, sp, #0
 8013fa4:	6078      	str	r0, [r7, #4]
    return obj->design_cb;
 8013fa6:	687b      	ldr	r3, [r7, #4]
 8013fa8:	6a1b      	ldr	r3, [r3, #32]
}
 8013faa:	4618      	mov	r0, r3
 8013fac:	370c      	adds	r7, #12
 8013fae:	46bd      	mov	sp, r7
 8013fb0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013fb4:	4770      	bx	lr

08013fb6 <lv_obj_get_ext_attr>:
 * @param obj pointer to an object
 * @return the ext pointer but not the dynamic version
 *         Use it as ext->data1, and NOT da(ext)->data1
 */
void * lv_obj_get_ext_attr(const lv_obj_t * obj)
{
 8013fb6:	b480      	push	{r7}
 8013fb8:	b083      	sub	sp, #12
 8013fba:	af00      	add	r7, sp, #0
 8013fbc:	6078      	str	r0, [r7, #4]
    return obj->ext_attr;
 8013fbe:	687b      	ldr	r3, [r7, #4]
 8013fc0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8013fc2:	4618      	mov	r0, r3
 8013fc4:	370c      	adds	r7, #12
 8013fc6:	46bd      	mov	sp, r7
 8013fc8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013fcc:	4770      	bx	lr

08013fce <lv_obj_get_group>:
 * Get the group of the object
 * @param obj pointer to an object
 * @return the pointer to group of the object
 */
void * lv_obj_get_group(const lv_obj_t * obj)
{
 8013fce:	b480      	push	{r7}
 8013fd0:	b083      	sub	sp, #12
 8013fd2:	af00      	add	r7, sp, #0
 8013fd4:	6078      	str	r0, [r7, #4]
    return obj->group_p;
 8013fd6:	687b      	ldr	r3, [r7, #4]
 8013fd8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
}
 8013fda:	4618      	mov	r0, r3
 8013fdc:	370c      	adds	r7, #12
 8013fde:	46bd      	mov	sp, r7
 8013fe0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013fe4:	4770      	bx	lr

08013fe6 <lv_obj_is_focused>:
 * Tell whether the object is the focused object of a group or not.
 * @param obj pointer to an object
 * @return true: the object is focused, false: the object is not focused or not in a group
 */
bool lv_obj_is_focused(const lv_obj_t * obj)
{
 8013fe6:	b580      	push	{r7, lr}
 8013fe8:	b082      	sub	sp, #8
 8013fea:	af00      	add	r7, sp, #0
 8013fec:	6078      	str	r0, [r7, #4]
    if(obj->group_p) {
 8013fee:	687b      	ldr	r3, [r7, #4]
 8013ff0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8013ff2:	2b00      	cmp	r3, #0
 8013ff4:	d00a      	beq.n	801400c <lv_obj_is_focused+0x26>
        if(lv_group_get_focused(obj->group_p) == obj) return true;
 8013ff6:	687b      	ldr	r3, [r7, #4]
 8013ff8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8013ffa:	4618      	mov	r0, r3
 8013ffc:	f7fe f9e2 	bl	80123c4 <lv_group_get_focused>
 8014000:	4602      	mov	r2, r0
 8014002:	687b      	ldr	r3, [r7, #4]
 8014004:	4293      	cmp	r3, r2
 8014006:	d101      	bne.n	801400c <lv_obj_is_focused+0x26>
 8014008:	2301      	movs	r3, #1
 801400a:	e000      	b.n	801400e <lv_obj_is_focused+0x28>
    }

    return false;
 801400c:	2300      	movs	r3, #0
}
 801400e:	4618      	mov	r0, r3
 8014010:	3708      	adds	r7, #8
 8014012:	46bd      	mov	sp, r7
 8014014:	bd80      	pop	{r7, pc}

08014016 <lv_obj_design>:
 *                                  (return 'true' if yes)
 *             LV_DESIGN_DRAW: draw the object (always return 'true')
 * @param return true/false, depends on 'mode'
 */
static bool lv_obj_design(lv_obj_t * obj, const lv_area_t * mask_p, lv_design_mode_t mode)
{
 8014016:	b590      	push	{r4, r7, lr}
 8014018:	b08b      	sub	sp, #44	; 0x2c
 801401a:	af00      	add	r7, sp, #0
 801401c:	60f8      	str	r0, [r7, #12]
 801401e:	60b9      	str	r1, [r7, #8]
 8014020:	4613      	mov	r3, r2
 8014022:	71fb      	strb	r3, [r7, #7]
    if(mode == LV_DESIGN_COVER_CHK) {
 8014024:	79fb      	ldrb	r3, [r7, #7]
 8014026:	2b02      	cmp	r3, #2
 8014028:	d16a      	bne.n	8014100 <lv_obj_design+0xea>

        /*Most trivial test. Is the mask fully IN the object? If no it surely doesn't cover it*/
        if(lv_area_is_in(mask_p, &obj->coords) == false) return false;
 801402a:	68fb      	ldr	r3, [r7, #12]
 801402c:	3310      	adds	r3, #16
 801402e:	4619      	mov	r1, r3
 8014030:	68b8      	ldr	r0, [r7, #8]
 8014032:	f009 fcac 	bl	801d98e <lv_area_is_in>
 8014036:	4603      	mov	r3, r0
 8014038:	f083 0301 	eor.w	r3, r3, #1
 801403c:	b2db      	uxtb	r3, r3
 801403e:	2b00      	cmp	r3, #0
 8014040:	d001      	beq.n	8014046 <lv_obj_design+0x30>
 8014042:	2300      	movs	r3, #0
 8014044:	e070      	b.n	8014128 <lv_obj_design+0x112>

        /*Can cover the area only if fully solid (no opacity)*/
        const lv_style_t * style = lv_obj_get_style(obj);
 8014046:	68f8      	ldr	r0, [r7, #12]
 8014048:	f7ff fefa 	bl	8013e40 <lv_obj_get_style>
 801404c:	6238      	str	r0, [r7, #32]
        if(style->body.opa < LV_OPA_MAX) return false;
 801404e:	6a3b      	ldr	r3, [r7, #32]
 8014050:	7a1b      	ldrb	r3, [r3, #8]
 8014052:	2bfa      	cmp	r3, #250	; 0xfa
 8014054:	d801      	bhi.n	801405a <lv_obj_design+0x44>
 8014056:	2300      	movs	r3, #0
 8014058:	e066      	b.n	8014128 <lv_obj_design+0x112>

        /* Because of the radius it is not sure the area is covered
         * Check the areas where there is no radius*/
        lv_coord_t r = style->body.radius;
 801405a:	6a3b      	ldr	r3, [r7, #32]
 801405c:	88db      	ldrh	r3, [r3, #6]
 801405e:	83fb      	strh	r3, [r7, #30]

        if(r == LV_RADIUS_CIRCLE) return false;
 8014060:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8014064:	f647 4218 	movw	r2, #31768	; 0x7c18
 8014068:	4293      	cmp	r3, r2
 801406a:	d101      	bne.n	8014070 <lv_obj_design+0x5a>
 801406c:	2300      	movs	r3, #0
 801406e:	e05b      	b.n	8014128 <lv_obj_design+0x112>

        lv_area_t area_tmp;

        /*Check horizontally without radius*/
        lv_obj_get_coords(obj, &area_tmp);
 8014070:	f107 0314 	add.w	r3, r7, #20
 8014074:	4619      	mov	r1, r3
 8014076:	68f8      	ldr	r0, [r7, #12]
 8014078:	f7ff fe85 	bl	8013d86 <lv_obj_get_coords>
        area_tmp.x1 += r;
 801407c:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8014080:	b29a      	uxth	r2, r3
 8014082:	8bfb      	ldrh	r3, [r7, #30]
 8014084:	4413      	add	r3, r2
 8014086:	b29b      	uxth	r3, r3
 8014088:	b21b      	sxth	r3, r3
 801408a:	82bb      	strh	r3, [r7, #20]
        area_tmp.x2 -= r;
 801408c:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8014090:	b29a      	uxth	r2, r3
 8014092:	8bfb      	ldrh	r3, [r7, #30]
 8014094:	1ad3      	subs	r3, r2, r3
 8014096:	b29b      	uxth	r3, r3
 8014098:	b21b      	sxth	r3, r3
 801409a:	833b      	strh	r3, [r7, #24]
        if(lv_area_is_in(mask_p, &area_tmp) == false) return false;
 801409c:	f107 0314 	add.w	r3, r7, #20
 80140a0:	4619      	mov	r1, r3
 80140a2:	68b8      	ldr	r0, [r7, #8]
 80140a4:	f009 fc73 	bl	801d98e <lv_area_is_in>
 80140a8:	4603      	mov	r3, r0
 80140aa:	f083 0301 	eor.w	r3, r3, #1
 80140ae:	b2db      	uxtb	r3, r3
 80140b0:	2b00      	cmp	r3, #0
 80140b2:	d001      	beq.n	80140b8 <lv_obj_design+0xa2>
 80140b4:	2300      	movs	r3, #0
 80140b6:	e037      	b.n	8014128 <lv_obj_design+0x112>

        /*Check vertically without radius*/
        lv_obj_get_coords(obj, &area_tmp);
 80140b8:	f107 0314 	add.w	r3, r7, #20
 80140bc:	4619      	mov	r1, r3
 80140be:	68f8      	ldr	r0, [r7, #12]
 80140c0:	f7ff fe61 	bl	8013d86 <lv_obj_get_coords>
        area_tmp.y1 += r;
 80140c4:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 80140c8:	b29a      	uxth	r2, r3
 80140ca:	8bfb      	ldrh	r3, [r7, #30]
 80140cc:	4413      	add	r3, r2
 80140ce:	b29b      	uxth	r3, r3
 80140d0:	b21b      	sxth	r3, r3
 80140d2:	82fb      	strh	r3, [r7, #22]
        area_tmp.y2 -= r;
 80140d4:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80140d8:	b29a      	uxth	r2, r3
 80140da:	8bfb      	ldrh	r3, [r7, #30]
 80140dc:	1ad3      	subs	r3, r2, r3
 80140de:	b29b      	uxth	r3, r3
 80140e0:	b21b      	sxth	r3, r3
 80140e2:	837b      	strh	r3, [r7, #26]
        if(lv_area_is_in(mask_p, &area_tmp) == false) return false;
 80140e4:	f107 0314 	add.w	r3, r7, #20
 80140e8:	4619      	mov	r1, r3
 80140ea:	68b8      	ldr	r0, [r7, #8]
 80140ec:	f009 fc4f 	bl	801d98e <lv_area_is_in>
 80140f0:	4603      	mov	r3, r0
 80140f2:	f083 0301 	eor.w	r3, r3, #1
 80140f6:	b2db      	uxtb	r3, r3
 80140f8:	2b00      	cmp	r3, #0
 80140fa:	d014      	beq.n	8014126 <lv_obj_design+0x110>
 80140fc:	2300      	movs	r3, #0
 80140fe:	e013      	b.n	8014128 <lv_obj_design+0x112>

    } else if(mode == LV_DESIGN_DRAW_MAIN) {
 8014100:	79fb      	ldrb	r3, [r7, #7]
 8014102:	2b00      	cmp	r3, #0
 8014104:	d10f      	bne.n	8014126 <lv_obj_design+0x110>
        const lv_style_t * style = lv_obj_get_style(obj);
 8014106:	68f8      	ldr	r0, [r7, #12]
 8014108:	f7ff fe9a 	bl	8013e40 <lv_obj_get_style>
 801410c:	6278      	str	r0, [r7, #36]	; 0x24
        lv_draw_rect(&obj->coords, mask_p, style, lv_obj_get_opa_scale(obj));
 801410e:	68fb      	ldr	r3, [r7, #12]
 8014110:	f103 0410 	add.w	r4, r3, #16
 8014114:	68f8      	ldr	r0, [r7, #12]
 8014116:	f7ff ff00 	bl	8013f1a <lv_obj_get_opa_scale>
 801411a:	4603      	mov	r3, r0
 801411c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801411e:	68b9      	ldr	r1, [r7, #8]
 8014120:	4620      	mov	r0, r4
 8014122:	f003 fcba 	bl	8017a9a <lv_draw_rect>
    }

    return true;
 8014126:	2301      	movs	r3, #1
}
 8014128:	4618      	mov	r0, r3
 801412a:	372c      	adds	r7, #44	; 0x2c
 801412c:	46bd      	mov	sp, r7
 801412e:	bd90      	pop	{r4, r7, pc}

08014130 <lv_obj_signal>:
 * @param sign signal type
 * @param param parameter for the signal (depends on signal type)
 * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted
 */
static lv_res_t lv_obj_signal(lv_obj_t * obj, lv_signal_t sign, void * param)
{
 8014130:	b580      	push	{r7, lr}
 8014132:	b088      	sub	sp, #32
 8014134:	af00      	add	r7, sp, #0
 8014136:	60f8      	str	r0, [r7, #12]
 8014138:	460b      	mov	r3, r1
 801413a:	607a      	str	r2, [r7, #4]
 801413c:	72fb      	strb	r3, [r7, #11]
    (void)param;

    lv_res_t res = LV_RES_OK;
 801413e:	2301      	movs	r3, #1
 8014140:	77fb      	strb	r3, [r7, #31]

    const lv_style_t * style = lv_obj_get_style(obj);
 8014142:	68f8      	ldr	r0, [r7, #12]
 8014144:	f7ff fe7c 	bl	8013e40 <lv_obj_get_style>
 8014148:	61b8      	str	r0, [r7, #24]

    if(sign == LV_SIGNAL_CHILD_CHG) {
 801414a:	7afb      	ldrb	r3, [r7, #11]
 801414c:	2b01      	cmp	r3, #1
 801414e:	d109      	bne.n	8014164 <lv_obj_signal+0x34>
        /*Return 'invalid' if the child change signal is not enabled*/
        if(lv_obj_is_protected(obj, LV_PROTECT_CHILD_CHG) != false) res = LV_RES_INV;
 8014150:	2101      	movs	r1, #1
 8014152:	68f8      	ldr	r0, [r7, #12]
 8014154:	f7ff ff00 	bl	8013f58 <lv_obj_is_protected>
 8014158:	4603      	mov	r3, r0
 801415a:	2b00      	cmp	r3, #0
 801415c:	d022      	beq.n	80141a4 <lv_obj_signal+0x74>
 801415e:	2300      	movs	r3, #0
 8014160:	77fb      	strb	r3, [r7, #31]
 8014162:	e01f      	b.n	80141a4 <lv_obj_signal+0x74>
    } else if(sign == LV_SIGNAL_REFR_EXT_DRAW_PAD) {
 8014164:	7afb      	ldrb	r3, [r7, #11]
 8014166:	2b05      	cmp	r3, #5
 8014168:	d10d      	bne.n	8014186 <lv_obj_signal+0x56>
        if(style->body.shadow.width > obj->ext_draw_pad) obj->ext_draw_pad = style->body.shadow.width;
 801416a:	69bb      	ldr	r3, [r7, #24]
 801416c:	f9b3 2012 	ldrsh.w	r2, [r3, #18]
 8014170:	68fb      	ldr	r3, [r7, #12]
 8014172:	f9b3 3034 	ldrsh.w	r3, [r3, #52]	; 0x34
 8014176:	429a      	cmp	r2, r3
 8014178:	dd14      	ble.n	80141a4 <lv_obj_signal+0x74>
 801417a:	69bb      	ldr	r3, [r7, #24]
 801417c:	f9b3 2012 	ldrsh.w	r2, [r3, #18]
 8014180:	68fb      	ldr	r3, [r7, #12]
 8014182:	869a      	strh	r2, [r3, #52]	; 0x34
 8014184:	e00e      	b.n	80141a4 <lv_obj_signal+0x74>
    } else if(sign == LV_SIGNAL_STYLE_CHG) {
 8014186:	7afb      	ldrb	r3, [r7, #11]
 8014188:	2b04      	cmp	r3, #4
 801418a:	d103      	bne.n	8014194 <lv_obj_signal+0x64>
        lv_obj_refresh_ext_draw_pad(obj);
 801418c:	68f8      	ldr	r0, [r7, #12]
 801418e:	f7ff fd6f 	bl	8013c70 <lv_obj_refresh_ext_draw_pad>
 8014192:	e007      	b.n	80141a4 <lv_obj_signal+0x74>
    } else if(sign == LV_SIGNAL_GET_TYPE) {
 8014194:	7afb      	ldrb	r3, [r7, #11]
 8014196:	2b06      	cmp	r3, #6
 8014198:	d104      	bne.n	80141a4 <lv_obj_signal+0x74>
        lv_obj_type_t * buf = param;
 801419a:	687b      	ldr	r3, [r7, #4]
 801419c:	617b      	str	r3, [r7, #20]
        buf->type[0]        = "lv_obj";
 801419e:	697b      	ldr	r3, [r7, #20]
 80141a0:	4a03      	ldr	r2, [pc, #12]	; (80141b0 <lv_obj_signal+0x80>)
 80141a2:	601a      	str	r2, [r3, #0]
    }

    return res;
 80141a4:	7ffb      	ldrb	r3, [r7, #31]
}
 80141a6:	4618      	mov	r0, r3
 80141a8:	3720      	adds	r7, #32
 80141aa:	46bd      	mov	sp, r7
 80141ac:	bd80      	pop	{r7, pc}
 80141ae:	bf00      	nop
 80141b0:	080228b0 	.word	0x080228b0

080141b4 <refresh_children_position>:
 * @param obj pointer to an object which children will be repositioned
 * @param x_diff x coordinate shift
 * @param y_diff y coordinate shift
 */
static void refresh_children_position(lv_obj_t * obj, lv_coord_t x_diff, lv_coord_t y_diff)
{
 80141b4:	b580      	push	{r7, lr}
 80141b6:	b084      	sub	sp, #16
 80141b8:	af00      	add	r7, sp, #0
 80141ba:	6078      	str	r0, [r7, #4]
 80141bc:	460b      	mov	r3, r1
 80141be:	807b      	strh	r3, [r7, #2]
 80141c0:	4613      	mov	r3, r2
 80141c2:	803b      	strh	r3, [r7, #0]
    lv_obj_t * i;
    LV_LL_READ(obj->child_ll, i)
 80141c4:	687b      	ldr	r3, [r7, #4]
 80141c6:	3304      	adds	r3, #4
 80141c8:	4618      	mov	r0, r3
 80141ca:	f009 fe0b 	bl	801dde4 <lv_ll_get_head>
 80141ce:	60f8      	str	r0, [r7, #12]
 80141d0:	e036      	b.n	8014240 <refresh_children_position+0x8c>
    {
        i->coords.x1 += x_diff;
 80141d2:	68fb      	ldr	r3, [r7, #12]
 80141d4:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 80141d8:	b29a      	uxth	r2, r3
 80141da:	887b      	ldrh	r3, [r7, #2]
 80141dc:	4413      	add	r3, r2
 80141de:	b29b      	uxth	r3, r3
 80141e0:	b21a      	sxth	r2, r3
 80141e2:	68fb      	ldr	r3, [r7, #12]
 80141e4:	821a      	strh	r2, [r3, #16]
        i->coords.y1 += y_diff;
 80141e6:	68fb      	ldr	r3, [r7, #12]
 80141e8:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 80141ec:	b29a      	uxth	r2, r3
 80141ee:	883b      	ldrh	r3, [r7, #0]
 80141f0:	4413      	add	r3, r2
 80141f2:	b29b      	uxth	r3, r3
 80141f4:	b21a      	sxth	r2, r3
 80141f6:	68fb      	ldr	r3, [r7, #12]
 80141f8:	825a      	strh	r2, [r3, #18]
        i->coords.x2 += x_diff;
 80141fa:	68fb      	ldr	r3, [r7, #12]
 80141fc:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 8014200:	b29a      	uxth	r2, r3
 8014202:	887b      	ldrh	r3, [r7, #2]
 8014204:	4413      	add	r3, r2
 8014206:	b29b      	uxth	r3, r3
 8014208:	b21a      	sxth	r2, r3
 801420a:	68fb      	ldr	r3, [r7, #12]
 801420c:	829a      	strh	r2, [r3, #20]
        i->coords.y2 += y_diff;
 801420e:	68fb      	ldr	r3, [r7, #12]
 8014210:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 8014214:	b29a      	uxth	r2, r3
 8014216:	883b      	ldrh	r3, [r7, #0]
 8014218:	4413      	add	r3, r2
 801421a:	b29b      	uxth	r3, r3
 801421c:	b21a      	sxth	r2, r3
 801421e:	68fb      	ldr	r3, [r7, #12]
 8014220:	82da      	strh	r2, [r3, #22]

        refresh_children_position(i, x_diff, y_diff);
 8014222:	f9b7 2000 	ldrsh.w	r2, [r7]
 8014226:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 801422a:	4619      	mov	r1, r3
 801422c:	68f8      	ldr	r0, [r7, #12]
 801422e:	f7ff ffc1 	bl	80141b4 <refresh_children_position>
    LV_LL_READ(obj->child_ll, i)
 8014232:	687b      	ldr	r3, [r7, #4]
 8014234:	3304      	adds	r3, #4
 8014236:	68f9      	ldr	r1, [r7, #12]
 8014238:	4618      	mov	r0, r3
 801423a:	f009 fdf9 	bl	801de30 <lv_ll_get_next>
 801423e:	60f8      	str	r0, [r7, #12]
 8014240:	68fb      	ldr	r3, [r7, #12]
 8014242:	2b00      	cmp	r3, #0
 8014244:	d1c5      	bne.n	80141d2 <refresh_children_position+0x1e>
    }
}
 8014246:	bf00      	nop
 8014248:	bf00      	nop
 801424a:	3710      	adds	r7, #16
 801424c:	46bd      	mov	sp, r7
 801424e:	bd80      	pop	{r7, pc}

08014250 <refresh_children_style>:
 * Recursively refresh the style of the children. Go deeper until a not NULL style is found
 * because the NULL styles are inherited from the parent
 * @param obj pointer to an object
 */
static void refresh_children_style(lv_obj_t * obj)
{
 8014250:	b580      	push	{r7, lr}
 8014252:	b084      	sub	sp, #16
 8014254:	af00      	add	r7, sp, #0
 8014256:	6078      	str	r0, [r7, #4]
    lv_obj_t * child = lv_obj_get_child(obj, NULL);
 8014258:	2100      	movs	r1, #0
 801425a:	6878      	ldr	r0, [r7, #4]
 801425c:	f7ff fd76 	bl	8013d4c <lv_obj_get_child>
 8014260:	60f8      	str	r0, [r7, #12]
    while(child != NULL) {
 8014262:	e01a      	b.n	801429a <refresh_children_style+0x4a>
        if(child->style_p == NULL) {
 8014264:	68fb      	ldr	r3, [r7, #12]
 8014266:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8014268:	2b00      	cmp	r3, #0
 801426a:	d106      	bne.n	801427a <refresh_children_style+0x2a>
            refresh_children_style(child); /*Check children too*/
 801426c:	68f8      	ldr	r0, [r7, #12]
 801426e:	f7ff ffef 	bl	8014250 <refresh_children_style>
            lv_obj_refresh_style(child);   /*Notify the child about the style change*/
 8014272:	68f8      	ldr	r0, [r7, #12]
 8014274:	f7ff fbe3 	bl	8013a3e <lv_obj_refresh_style>
 8014278:	e00a      	b.n	8014290 <refresh_children_style+0x40>
        } else if(child->style_p->glass) {
 801427a:	68fb      	ldr	r3, [r7, #12]
 801427c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801427e:	781b      	ldrb	r3, [r3, #0]
 8014280:	f003 0301 	and.w	r3, r3, #1
 8014284:	b2db      	uxtb	r3, r3
 8014286:	2b00      	cmp	r3, #0
 8014288:	d002      	beq.n	8014290 <refresh_children_style+0x40>
            /*Children with 'glass' parent might be effected if their style == NULL*/
            refresh_children_style(child);
 801428a:	68f8      	ldr	r0, [r7, #12]
 801428c:	f7ff ffe0 	bl	8014250 <refresh_children_style>
        }
        child = lv_obj_get_child(obj, child);
 8014290:	68f9      	ldr	r1, [r7, #12]
 8014292:	6878      	ldr	r0, [r7, #4]
 8014294:	f7ff fd5a 	bl	8013d4c <lv_obj_get_child>
 8014298:	60f8      	str	r0, [r7, #12]
    while(child != NULL) {
 801429a:	68fb      	ldr	r3, [r7, #12]
 801429c:	2b00      	cmp	r3, #0
 801429e:	d1e1      	bne.n	8014264 <refresh_children_style+0x14>
    }
}
 80142a0:	bf00      	nop
 80142a2:	bf00      	nop
 80142a4:	3710      	adds	r7, #16
 80142a6:	46bd      	mov	sp, r7
 80142a8:	bd80      	pop	{r7, pc}

080142aa <lv_area_copy>:
{
 80142aa:	b580      	push	{r7, lr}
 80142ac:	b082      	sub	sp, #8
 80142ae:	af00      	add	r7, sp, #0
 80142b0:	6078      	str	r0, [r7, #4]
 80142b2:	6039      	str	r1, [r7, #0]
    memcpy(dest, src, sizeof(lv_area_t));
 80142b4:	2208      	movs	r2, #8
 80142b6:	6839      	ldr	r1, [r7, #0]
 80142b8:	6878      	ldr	r0, [r7, #4]
 80142ba:	f00d fccd 	bl	8021c58 <memcpy>
}
 80142be:	bf00      	nop
 80142c0:	3708      	adds	r7, #8
 80142c2:	46bd      	mov	sp, r7
 80142c4:	bd80      	pop	{r7, pc}

080142c6 <lv_area_get_width>:
{
 80142c6:	b480      	push	{r7}
 80142c8:	b083      	sub	sp, #12
 80142ca:	af00      	add	r7, sp, #0
 80142cc:	6078      	str	r0, [r7, #4]
    return area_p->x2 - area_p->x1 + 1;
 80142ce:	687b      	ldr	r3, [r7, #4]
 80142d0:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80142d4:	b29a      	uxth	r2, r3
 80142d6:	687b      	ldr	r3, [r7, #4]
 80142d8:	f9b3 3000 	ldrsh.w	r3, [r3]
 80142dc:	b29b      	uxth	r3, r3
 80142de:	1ad3      	subs	r3, r2, r3
 80142e0:	b29b      	uxth	r3, r3
 80142e2:	3301      	adds	r3, #1
 80142e4:	b29b      	uxth	r3, r3
 80142e6:	b21b      	sxth	r3, r3
}
 80142e8:	4618      	mov	r0, r3
 80142ea:	370c      	adds	r7, #12
 80142ec:	46bd      	mov	sp, r7
 80142ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80142f2:	4770      	bx	lr

080142f4 <lv_area_get_height>:
{
 80142f4:	b480      	push	{r7}
 80142f6:	b083      	sub	sp, #12
 80142f8:	af00      	add	r7, sp, #0
 80142fa:	6078      	str	r0, [r7, #4]
    return area_p->y2 - area_p->y1 + 1;
 80142fc:	687b      	ldr	r3, [r7, #4]
 80142fe:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8014302:	b29a      	uxth	r2, r3
 8014304:	687b      	ldr	r3, [r7, #4]
 8014306:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801430a:	b29b      	uxth	r3, r3
 801430c:	1ad3      	subs	r3, r2, r3
 801430e:	b29b      	uxth	r3, r3
 8014310:	3301      	adds	r3, #1
 8014312:	b29b      	uxth	r3, r3
 8014314:	b21b      	sxth	r3, r3
}
 8014316:	4618      	mov	r0, r3
 8014318:	370c      	adds	r7, #12
 801431a:	46bd      	mov	sp, r7
 801431c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014320:	4770      	bx	lr

08014322 <lv_refr_init>:

/**
 * Initialize the screen refresh subsystem
 */
void lv_refr_init(void)
{
 8014322:	b480      	push	{r7}
 8014324:	af00      	add	r7, sp, #0
    /*Nothing to do*/
}
 8014326:	bf00      	nop
 8014328:	46bd      	mov	sp, r7
 801432a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801432e:	4770      	bx	lr

08014330 <lv_inv_area>:
 * @param area_p pointer to area which should be invalidated (NULL: delete the invalidated areas)
 * @param disp pointer to display where the area should be invalidated (NULL can be used if there is
 * only one display)
 */
void lv_inv_area(lv_disp_t * disp, const lv_area_t * area_p)
{
 8014330:	b580      	push	{r7, lr}
 8014332:	b088      	sub	sp, #32
 8014334:	af00      	add	r7, sp, #0
 8014336:	6078      	str	r0, [r7, #4]
 8014338:	6039      	str	r1, [r7, #0]
    if(!disp) disp = lv_disp_get_default();
 801433a:	687b      	ldr	r3, [r7, #4]
 801433c:	2b00      	cmp	r3, #0
 801433e:	d102      	bne.n	8014346 <lv_inv_area+0x16>
 8014340:	f008 fedc 	bl	801d0fc <lv_disp_get_default>
 8014344:	6078      	str	r0, [r7, #4]
    if(!disp) return;
 8014346:	687b      	ldr	r3, [r7, #4]
 8014348:	2b00      	cmp	r3, #0
 801434a:	f000 809c 	beq.w	8014486 <lv_inv_area+0x156>

    /*Clear the invalidate buffer if the parameter is NULL*/
    if(area_p == NULL) {
 801434e:	683b      	ldr	r3, [r7, #0]
 8014350:	2b00      	cmp	r3, #0
 8014352:	d107      	bne.n	8014364 <lv_inv_area+0x34>
        disp->inv_p = 0;
 8014354:	687a      	ldr	r2, [r7, #4]
 8014356:	f8b2 315c 	ldrh.w	r3, [r2, #348]	; 0x15c
 801435a:	f36f 0309 	bfc	r3, #0, #10
 801435e:	f8a2 315c 	strh.w	r3, [r2, #348]	; 0x15c
        return;
 8014362:	e093      	b.n	801448c <lv_inv_area+0x15c>
    }

    lv_area_t scr_area;
    scr_area.x1 = 0;
 8014364:	2300      	movs	r3, #0
 8014366:	82bb      	strh	r3, [r7, #20]
    scr_area.y1 = 0;
 8014368:	2300      	movs	r3, #0
 801436a:	82fb      	strh	r3, [r7, #22]
    scr_area.x2 = lv_disp_get_hor_res(disp) - 1;
 801436c:	6878      	ldr	r0, [r7, #4]
 801436e:	f008 fed1 	bl	801d114 <lv_disp_get_hor_res>
 8014372:	4603      	mov	r3, r0
 8014374:	b29b      	uxth	r3, r3
 8014376:	3b01      	subs	r3, #1
 8014378:	b29b      	uxth	r3, r3
 801437a:	b21b      	sxth	r3, r3
 801437c:	833b      	strh	r3, [r7, #24]
    scr_area.y2 = lv_disp_get_ver_res(disp) - 1;
 801437e:	6878      	ldr	r0, [r7, #4]
 8014380:	f008 feea 	bl	801d158 <lv_disp_get_ver_res>
 8014384:	4603      	mov	r3, r0
 8014386:	b29b      	uxth	r3, r3
 8014388:	3b01      	subs	r3, #1
 801438a:	b29b      	uxth	r3, r3
 801438c:	b21b      	sxth	r3, r3
 801438e:	837b      	strh	r3, [r7, #26]

    lv_area_t com_area;
    bool suc;

    suc = lv_area_intersect(&com_area, area_p, &scr_area);
 8014390:	f107 0214 	add.w	r2, r7, #20
 8014394:	f107 030c 	add.w	r3, r7, #12
 8014398:	6839      	ldr	r1, [r7, #0]
 801439a:	4618      	mov	r0, r3
 801439c:	f009 fa3c 	bl	801d818 <lv_area_intersect>
 80143a0:	4603      	mov	r3, r0
 80143a2:	777b      	strb	r3, [r7, #29]

    /*The area is truncated to the screen*/
    if(suc != false) {
 80143a4:	7f7b      	ldrb	r3, [r7, #29]
 80143a6:	2b00      	cmp	r3, #0
 80143a8:	d070      	beq.n	801448c <lv_inv_area+0x15c>
        if(disp->driver.rounder_cb) disp->driver.rounder_cb(&disp->driver, &com_area);
 80143aa:	687b      	ldr	r3, [r7, #4]
 80143ac:	691b      	ldr	r3, [r3, #16]
 80143ae:	2b00      	cmp	r3, #0
 80143b0:	d006      	beq.n	80143c0 <lv_inv_area+0x90>
 80143b2:	687b      	ldr	r3, [r7, #4]
 80143b4:	691b      	ldr	r3, [r3, #16]
 80143b6:	687a      	ldr	r2, [r7, #4]
 80143b8:	f107 010c 	add.w	r1, r7, #12
 80143bc:	4610      	mov	r0, r2
 80143be:	4798      	blx	r3

        /*Save only if this area is not in one of the saved areas*/
        uint16_t i;
        for(i = 0; i < disp->inv_p; i++) {
 80143c0:	2300      	movs	r3, #0
 80143c2:	83fb      	strh	r3, [r7, #30]
 80143c4:	e011      	b.n	80143ea <lv_inv_area+0xba>
            if(lv_area_is_in(&com_area, &disp->inv_areas[i]) != false) return;
 80143c6:	8bfb      	ldrh	r3, [r7, #30]
 80143c8:	3307      	adds	r3, #7
 80143ca:	00db      	lsls	r3, r3, #3
 80143cc:	687a      	ldr	r2, [r7, #4]
 80143ce:	4413      	add	r3, r2
 80143d0:	1d1a      	adds	r2, r3, #4
 80143d2:	f107 030c 	add.w	r3, r7, #12
 80143d6:	4611      	mov	r1, r2
 80143d8:	4618      	mov	r0, r3
 80143da:	f009 fad8 	bl	801d98e <lv_area_is_in>
 80143de:	4603      	mov	r3, r0
 80143e0:	2b00      	cmp	r3, #0
 80143e2:	d152      	bne.n	801448a <lv_inv_area+0x15a>
        for(i = 0; i < disp->inv_p; i++) {
 80143e4:	8bfb      	ldrh	r3, [r7, #30]
 80143e6:	3301      	adds	r3, #1
 80143e8:	83fb      	strh	r3, [r7, #30]
 80143ea:	687b      	ldr	r3, [r7, #4]
 80143ec:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
 80143f0:	f3c3 0309 	ubfx	r3, r3, #0, #10
 80143f4:	b29b      	uxth	r3, r3
 80143f6:	461a      	mov	r2, r3
 80143f8:	8bfb      	ldrh	r3, [r7, #30]
 80143fa:	4293      	cmp	r3, r2
 80143fc:	d3e3      	bcc.n	80143c6 <lv_inv_area+0x96>
        }

        /*Save the area*/
        if(disp->inv_p < LV_INV_BUF_SIZE) {
 80143fe:	687b      	ldr	r3, [r7, #4]
 8014400:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
 8014404:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8014408:	b29b      	uxth	r3, r3
 801440a:	2b1f      	cmp	r3, #31
 801440c:	d811      	bhi.n	8014432 <lv_inv_area+0x102>
            lv_area_copy(&disp->inv_areas[disp->inv_p], &com_area);
 801440e:	687b      	ldr	r3, [r7, #4]
 8014410:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
 8014414:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8014418:	b29b      	uxth	r3, r3
 801441a:	3307      	adds	r3, #7
 801441c:	00db      	lsls	r3, r3, #3
 801441e:	687a      	ldr	r2, [r7, #4]
 8014420:	4413      	add	r3, r2
 8014422:	3304      	adds	r3, #4
 8014424:	f107 020c 	add.w	r2, r7, #12
 8014428:	4611      	mov	r1, r2
 801442a:	4618      	mov	r0, r3
 801442c:	f7ff ff3d 	bl	80142aa <lv_area_copy>
 8014430:	e017      	b.n	8014462 <lv_inv_area+0x132>
        } else { /*If no place for the area add the screen*/
            disp->inv_p = 0;
 8014432:	687a      	ldr	r2, [r7, #4]
 8014434:	f8b2 315c 	ldrh.w	r3, [r2, #348]	; 0x15c
 8014438:	f36f 0309 	bfc	r3, #0, #10
 801443c:	f8a2 315c 	strh.w	r3, [r2, #348]	; 0x15c
            lv_area_copy(&disp->inv_areas[disp->inv_p], &scr_area);
 8014440:	687b      	ldr	r3, [r7, #4]
 8014442:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
 8014446:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801444a:	b29b      	uxth	r3, r3
 801444c:	3307      	adds	r3, #7
 801444e:	00db      	lsls	r3, r3, #3
 8014450:	687a      	ldr	r2, [r7, #4]
 8014452:	4413      	add	r3, r2
 8014454:	3304      	adds	r3, #4
 8014456:	f107 0214 	add.w	r2, r7, #20
 801445a:	4611      	mov	r1, r2
 801445c:	4618      	mov	r0, r3
 801445e:	f7ff ff24 	bl	80142aa <lv_area_copy>
        }
        disp->inv_p++;
 8014462:	687b      	ldr	r3, [r7, #4]
 8014464:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
 8014468:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801446c:	b29b      	uxth	r3, r3
 801446e:	3301      	adds	r3, #1
 8014470:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8014474:	b299      	uxth	r1, r3
 8014476:	687a      	ldr	r2, [r7, #4]
 8014478:	f8b2 315c 	ldrh.w	r3, [r2, #348]	; 0x15c
 801447c:	f361 0309 	bfi	r3, r1, #0, #10
 8014480:	f8a2 315c 	strh.w	r3, [r2, #348]	; 0x15c
 8014484:	e002      	b.n	801448c <lv_inv_area+0x15c>
    if(!disp) return;
 8014486:	bf00      	nop
 8014488:	e000      	b.n	801448c <lv_inv_area+0x15c>
            if(lv_area_is_in(&com_area, &disp->inv_areas[i]) != false) return;
 801448a:	bf00      	nop
    }
}
 801448c:	3720      	adds	r7, #32
 801448e:	46bd      	mov	sp, r7
 8014490:	bd80      	pop	{r7, pc}
	...

08014494 <lv_refr_get_disp_refreshing>:
/**
 * Get the display which is being refreshed
 * @return the display being refreshed
 */
lv_disp_t * lv_refr_get_disp_refreshing(void)
{
 8014494:	b480      	push	{r7}
 8014496:	af00      	add	r7, sp, #0
    return disp_refr;
 8014498:	4b03      	ldr	r3, [pc, #12]	; (80144a8 <lv_refr_get_disp_refreshing+0x14>)
 801449a:	681b      	ldr	r3, [r3, #0]
}
 801449c:	4618      	mov	r0, r3
 801449e:	46bd      	mov	sp, r7
 80144a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80144a4:	4770      	bx	lr
 80144a6:	bf00      	nop
 80144a8:	240623c8 	.word	0x240623c8

080144ac <lv_disp_refr_task>:
/**
 * Called periodically to handle the refreshing
 * @param task pointer to the task itself
 */
void lv_disp_refr_task(lv_task_t * task)
{
 80144ac:	b5b0      	push	{r4, r5, r7, lr}
 80144ae:	b08a      	sub	sp, #40	; 0x28
 80144b0:	af00      	add	r7, sp, #0
 80144b2:	6078      	str	r0, [r7, #4]
    LV_LOG_TRACE("lv_refr_task: started");

    uint32_t start = lv_tick_get();
 80144b4:	f008 ff12 	bl	801d2dc <lv_tick_get>
 80144b8:	61f8      	str	r0, [r7, #28]

    disp_refr = task->user_data;
 80144ba:	687b      	ldr	r3, [r7, #4]
 80144bc:	68db      	ldr	r3, [r3, #12]
 80144be:	4a6d      	ldr	r2, [pc, #436]	; (8014674 <lv_disp_refr_task+0x1c8>)
 80144c0:	6013      	str	r3, [r2, #0]

    lv_refr_join_area();
 80144c2:	f000 f8db 	bl	801467c <lv_refr_join_area>

    lv_refr_areas();
 80144c6:	f000 f97d 	bl	80147c4 <lv_refr_areas>

    /*If refresh happened ...*/
    if(disp_refr->inv_p != 0) {
 80144ca:	4b6a      	ldr	r3, [pc, #424]	; (8014674 <lv_disp_refr_task+0x1c8>)
 80144cc:	681b      	ldr	r3, [r3, #0]
 80144ce:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
 80144d2:	f3c3 0309 	ubfx	r3, r3, #0, #10
 80144d6:	b29b      	uxth	r3, r3
 80144d8:	2b00      	cmp	r3, #0
 80144da:	f000 80c5 	beq.w	8014668 <lv_disp_refr_task+0x1bc>
        /*In true double buffered mode copy the refreshed areas to the new VDB to keep it up to
         * date*/
        if(lv_disp_is_true_double_buf(disp_refr)) {
 80144de:	4b65      	ldr	r3, [pc, #404]	; (8014674 <lv_disp_refr_task+0x1c8>)
 80144e0:	681b      	ldr	r3, [r3, #0]
 80144e2:	4618      	mov	r0, r3
 80144e4:	f008 fea8 	bl	801d238 <lv_disp_is_true_double_buf>
 80144e8:	4603      	mov	r3, r0
 80144ea:	2b00      	cmp	r3, #0
 80144ec:	f000 808e 	beq.w	801460c <lv_disp_refr_task+0x160>
            lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
 80144f0:	4b60      	ldr	r3, [pc, #384]	; (8014674 <lv_disp_refr_task+0x1c8>)
 80144f2:	681b      	ldr	r3, [r3, #0]
 80144f4:	4618      	mov	r0, r3
 80144f6:	f008 fe7c 	bl	801d1f2 <lv_disp_get_buf>
 80144fa:	61b8      	str	r0, [r7, #24]

            /*Flush the content of the VDB*/
            lv_refr_vdb_flush();
 80144fc:	f000 fc6c 	bl	8014dd8 <lv_refr_vdb_flush>

            /* With true double buffering the flushing should be only the address change of the
             * current frame buffer. Wait until the address change is ready and copy the changed
             * content to the other frame buffer (new active VDB) to keep the buffers synchronized*/
            while(vdb->flushing)
 8014500:	bf00      	nop
 8014502:	69bb      	ldr	r3, [r7, #24]
 8014504:	699b      	ldr	r3, [r3, #24]
 8014506:	f3c3 0300 	ubfx	r3, r3, #0, #1
 801450a:	b2db      	uxtb	r3, r3
 801450c:	2b00      	cmp	r3, #0
 801450e:	d1f8      	bne.n	8014502 <lv_disp_refr_task+0x56>
                ;

            uint8_t * buf_act = (uint8_t *)vdb->buf_act;
 8014510:	69bb      	ldr	r3, [r7, #24]
 8014512:	689b      	ldr	r3, [r3, #8]
 8014514:	617b      	str	r3, [r7, #20]
            uint8_t * buf_ina = (uint8_t *)vdb->buf_act == vdb->buf1 ? vdb->buf2 : vdb->buf1;
 8014516:	69bb      	ldr	r3, [r7, #24]
 8014518:	689a      	ldr	r2, [r3, #8]
 801451a:	69bb      	ldr	r3, [r7, #24]
 801451c:	681b      	ldr	r3, [r3, #0]
 801451e:	429a      	cmp	r2, r3
 8014520:	d102      	bne.n	8014528 <lv_disp_refr_task+0x7c>
 8014522:	69bb      	ldr	r3, [r7, #24]
 8014524:	685b      	ldr	r3, [r3, #4]
 8014526:	e001      	b.n	801452c <lv_disp_refr_task+0x80>
 8014528:	69bb      	ldr	r3, [r7, #24]
 801452a:	681b      	ldr	r3, [r3, #0]
 801452c:	613b      	str	r3, [r7, #16]

            lv_coord_t hres = lv_disp_get_hor_res(disp_refr);
 801452e:	4b51      	ldr	r3, [pc, #324]	; (8014674 <lv_disp_refr_task+0x1c8>)
 8014530:	681b      	ldr	r3, [r3, #0]
 8014532:	4618      	mov	r0, r3
 8014534:	f008 fdee 	bl	801d114 <lv_disp_get_hor_res>
 8014538:	4603      	mov	r3, r0
 801453a:	81fb      	strh	r3, [r7, #14]
            uint16_t a;
            for(a = 0; a < disp_refr->inv_p; a++) {
 801453c:	2300      	movs	r3, #0
 801453e:	84fb      	strh	r3, [r7, #38]	; 0x26
 8014540:	e059      	b.n	80145f6 <lv_disp_refr_task+0x14a>
                if(disp_refr->inv_area_joined[a] == 0) {
 8014542:	4b4c      	ldr	r3, [pc, #304]	; (8014674 <lv_disp_refr_task+0x1c8>)
 8014544:	681a      	ldr	r2, [r3, #0]
 8014546:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8014548:	4413      	add	r3, r2
 801454a:	f893 313c 	ldrb.w	r3, [r3, #316]	; 0x13c
 801454e:	2b00      	cmp	r3, #0
 8014550:	d14e      	bne.n	80145f0 <lv_disp_refr_task+0x144>
                    lv_coord_t y;
                    uint32_t start_offs =
                        (hres * disp_refr->inv_areas[a].y1 + disp_refr->inv_areas[a].x1) * sizeof(lv_color_t);
 8014552:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 8014556:	4b47      	ldr	r3, [pc, #284]	; (8014674 <lv_disp_refr_task+0x1c8>)
 8014558:	6819      	ldr	r1, [r3, #0]
 801455a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801455c:	3307      	adds	r3, #7
 801455e:	00db      	lsls	r3, r3, #3
 8014560:	440b      	add	r3, r1
 8014562:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8014566:	fb03 f202 	mul.w	r2, r3, r2
 801456a:	4b42      	ldr	r3, [pc, #264]	; (8014674 <lv_disp_refr_task+0x1c8>)
 801456c:	6819      	ldr	r1, [r3, #0]
 801456e:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8014570:	3307      	adds	r3, #7
 8014572:	00db      	lsls	r3, r3, #3
 8014574:	440b      	add	r3, r1
 8014576:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801457a:	4413      	add	r3, r2
                    uint32_t start_offs =
 801457c:	005b      	lsls	r3, r3, #1
 801457e:	623b      	str	r3, [r7, #32]
                    uint32_t line_length = lv_area_get_width(&disp_refr->inv_areas[a]) * sizeof(lv_color_t);
 8014580:	4b3c      	ldr	r3, [pc, #240]	; (8014674 <lv_disp_refr_task+0x1c8>)
 8014582:	681a      	ldr	r2, [r3, #0]
 8014584:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8014586:	3307      	adds	r3, #7
 8014588:	00db      	lsls	r3, r3, #3
 801458a:	4413      	add	r3, r2
 801458c:	3304      	adds	r3, #4
 801458e:	4618      	mov	r0, r3
 8014590:	f7ff fe99 	bl	80142c6 <lv_area_get_width>
 8014594:	4603      	mov	r3, r0
 8014596:	005b      	lsls	r3, r3, #1
 8014598:	60bb      	str	r3, [r7, #8]

                    for(y = disp_refr->inv_areas[a].y1; y <= disp_refr->inv_areas[a].y2; y++) {
 801459a:	4b36      	ldr	r3, [pc, #216]	; (8014674 <lv_disp_refr_task+0x1c8>)
 801459c:	681a      	ldr	r2, [r3, #0]
 801459e:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80145a0:	3307      	adds	r3, #7
 80145a2:	00db      	lsls	r3, r3, #3
 80145a4:	4413      	add	r3, r2
 80145a6:	88db      	ldrh	r3, [r3, #6]
 80145a8:	84bb      	strh	r3, [r7, #36]	; 0x24
 80145aa:	e015      	b.n	80145d8 <lv_disp_refr_task+0x12c>
                        memcpy(buf_act + start_offs, buf_ina + start_offs, line_length);
 80145ac:	697a      	ldr	r2, [r7, #20]
 80145ae:	6a3b      	ldr	r3, [r7, #32]
 80145b0:	18d0      	adds	r0, r2, r3
 80145b2:	693a      	ldr	r2, [r7, #16]
 80145b4:	6a3b      	ldr	r3, [r7, #32]
 80145b6:	4413      	add	r3, r2
 80145b8:	68ba      	ldr	r2, [r7, #8]
 80145ba:	4619      	mov	r1, r3
 80145bc:	f00d fb4c 	bl	8021c58 <memcpy>
                        start_offs += hres * sizeof(lv_color_t);
 80145c0:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 80145c4:	005b      	lsls	r3, r3, #1
 80145c6:	6a3a      	ldr	r2, [r7, #32]
 80145c8:	4413      	add	r3, r2
 80145ca:	623b      	str	r3, [r7, #32]
                    for(y = disp_refr->inv_areas[a].y1; y <= disp_refr->inv_areas[a].y2; y++) {
 80145cc:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 80145d0:	b29b      	uxth	r3, r3
 80145d2:	3301      	adds	r3, #1
 80145d4:	b29b      	uxth	r3, r3
 80145d6:	84bb      	strh	r3, [r7, #36]	; 0x24
 80145d8:	4b26      	ldr	r3, [pc, #152]	; (8014674 <lv_disp_refr_task+0x1c8>)
 80145da:	681a      	ldr	r2, [r3, #0]
 80145dc:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80145de:	3307      	adds	r3, #7
 80145e0:	00db      	lsls	r3, r3, #3
 80145e2:	4413      	add	r3, r2
 80145e4:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 80145e8:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
 80145ec:	429a      	cmp	r2, r3
 80145ee:	dddd      	ble.n	80145ac <lv_disp_refr_task+0x100>
            for(a = 0; a < disp_refr->inv_p; a++) {
 80145f0:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80145f2:	3301      	adds	r3, #1
 80145f4:	84fb      	strh	r3, [r7, #38]	; 0x26
 80145f6:	4b1f      	ldr	r3, [pc, #124]	; (8014674 <lv_disp_refr_task+0x1c8>)
 80145f8:	681b      	ldr	r3, [r3, #0]
 80145fa:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
 80145fe:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8014602:	b29b      	uxth	r3, r3
 8014604:	461a      	mov	r2, r3
 8014606:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8014608:	4293      	cmp	r3, r2
 801460a:	d39a      	bcc.n	8014542 <lv_disp_refr_task+0x96>
                }
            }
        } /*End of true double buffer handling*/

        /*Clean up*/
        memset(disp_refr->inv_areas, 0, sizeof(disp_refr->inv_areas));
 801460c:	4b19      	ldr	r3, [pc, #100]	; (8014674 <lv_disp_refr_task+0x1c8>)
 801460e:	681b      	ldr	r3, [r3, #0]
 8014610:	333c      	adds	r3, #60	; 0x3c
 8014612:	f44f 7280 	mov.w	r2, #256	; 0x100
 8014616:	2100      	movs	r1, #0
 8014618:	4618      	mov	r0, r3
 801461a:	f00d fb2b 	bl	8021c74 <memset>
        memset(disp_refr->inv_area_joined, 0, sizeof(disp_refr->inv_area_joined));
 801461e:	4b15      	ldr	r3, [pc, #84]	; (8014674 <lv_disp_refr_task+0x1c8>)
 8014620:	681b      	ldr	r3, [r3, #0]
 8014622:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 8014626:	2220      	movs	r2, #32
 8014628:	2100      	movs	r1, #0
 801462a:	4618      	mov	r0, r3
 801462c:	f00d fb22 	bl	8021c74 <memset>
        disp_refr->inv_p = 0;
 8014630:	4b10      	ldr	r3, [pc, #64]	; (8014674 <lv_disp_refr_task+0x1c8>)
 8014632:	681a      	ldr	r2, [r3, #0]
 8014634:	f8b2 315c 	ldrh.w	r3, [r2, #348]	; 0x15c
 8014638:	f36f 0309 	bfc	r3, #0, #10
 801463c:	f8a2 315c 	strh.w	r3, [r2, #348]	; 0x15c

        /*Call monitor cb if present*/
        if(disp_refr->driver.monitor_cb) {
 8014640:	4b0c      	ldr	r3, [pc, #48]	; (8014674 <lv_disp_refr_task+0x1c8>)
 8014642:	681b      	ldr	r3, [r3, #0]
 8014644:	699b      	ldr	r3, [r3, #24]
 8014646:	2b00      	cmp	r3, #0
 8014648:	d00e      	beq.n	8014668 <lv_disp_refr_task+0x1bc>
            disp_refr->driver.monitor_cb(&disp_refr->driver, lv_tick_elaps(start), px_num);
 801464a:	4b0a      	ldr	r3, [pc, #40]	; (8014674 <lv_disp_refr_task+0x1c8>)
 801464c:	681b      	ldr	r3, [r3, #0]
 801464e:	699c      	ldr	r4, [r3, #24]
 8014650:	4b08      	ldr	r3, [pc, #32]	; (8014674 <lv_disp_refr_task+0x1c8>)
 8014652:	681b      	ldr	r3, [r3, #0]
 8014654:	461d      	mov	r5, r3
 8014656:	69f8      	ldr	r0, [r7, #28]
 8014658:	f008 fe5a 	bl	801d310 <lv_tick_elaps>
 801465c:	4601      	mov	r1, r0
 801465e:	4b06      	ldr	r3, [pc, #24]	; (8014678 <lv_disp_refr_task+0x1cc>)
 8014660:	681b      	ldr	r3, [r3, #0]
 8014662:	461a      	mov	r2, r3
 8014664:	4628      	mov	r0, r5
 8014666:	47a0      	blx	r4
        }
    }

    lv_draw_free_buf();
 8014668:	f000 fed0 	bl	801540c <lv_draw_free_buf>

    LV_LOG_TRACE("lv_refr_task: ready");
}
 801466c:	bf00      	nop
 801466e:	3728      	adds	r7, #40	; 0x28
 8014670:	46bd      	mov	sp, r7
 8014672:	bdb0      	pop	{r4, r5, r7, pc}
 8014674:	240623c8 	.word	0x240623c8
 8014678:	240623c4 	.word	0x240623c4

0801467c <lv_refr_join_area>:

/**
 * Join the areas which has got common parts
 */
static void lv_refr_join_area(void)
{
 801467c:	b5b0      	push	{r4, r5, r7, lr}
 801467e:	b084      	sub	sp, #16
 8014680:	af00      	add	r7, sp, #0
    uint32_t join_from;
    uint32_t join_in;
    lv_area_t joined_area;
    for(join_in = 0; join_in < disp_refr->inv_p; join_in++) {
 8014682:	2300      	movs	r3, #0
 8014684:	60bb      	str	r3, [r7, #8]
 8014686:	e08a      	b.n	801479e <lv_refr_join_area+0x122>
        if(disp_refr->inv_area_joined[join_in] != 0) continue;
 8014688:	4b4d      	ldr	r3, [pc, #308]	; (80147c0 <lv_refr_join_area+0x144>)
 801468a:	681a      	ldr	r2, [r3, #0]
 801468c:	68bb      	ldr	r3, [r7, #8]
 801468e:	4413      	add	r3, r2
 8014690:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 8014694:	781b      	ldrb	r3, [r3, #0]
 8014696:	2b00      	cmp	r3, #0
 8014698:	d17d      	bne.n	8014796 <lv_refr_join_area+0x11a>

        /*Check all areas to join them in 'join_in'*/
        for(join_from = 0; join_from < disp_refr->inv_p; join_from++) {
 801469a:	2300      	movs	r3, #0
 801469c:	60fb      	str	r3, [r7, #12]
 801469e:	e06e      	b.n	801477e <lv_refr_join_area+0x102>
            /*Handle only unjoined areas and ignore itself*/
            if(disp_refr->inv_area_joined[join_from] != 0 || join_in == join_from) {
 80146a0:	4b47      	ldr	r3, [pc, #284]	; (80147c0 <lv_refr_join_area+0x144>)
 80146a2:	681a      	ldr	r2, [r3, #0]
 80146a4:	68fb      	ldr	r3, [r7, #12]
 80146a6:	4413      	add	r3, r2
 80146a8:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 80146ac:	781b      	ldrb	r3, [r3, #0]
 80146ae:	2b00      	cmp	r3, #0
 80146b0:	d15f      	bne.n	8014772 <lv_refr_join_area+0xf6>
 80146b2:	68ba      	ldr	r2, [r7, #8]
 80146b4:	68fb      	ldr	r3, [r7, #12]
 80146b6:	429a      	cmp	r2, r3
 80146b8:	d05b      	beq.n	8014772 <lv_refr_join_area+0xf6>
                continue;
            }

            /*Check if the areas are on each other*/
            if(lv_area_is_on(&disp_refr->inv_areas[join_in], &disp_refr->inv_areas[join_from]) == false) {
 80146ba:	4b41      	ldr	r3, [pc, #260]	; (80147c0 <lv_refr_join_area+0x144>)
 80146bc:	681a      	ldr	r2, [r3, #0]
 80146be:	68bb      	ldr	r3, [r7, #8]
 80146c0:	3307      	adds	r3, #7
 80146c2:	00db      	lsls	r3, r3, #3
 80146c4:	4413      	add	r3, r2
 80146c6:	1d18      	adds	r0, r3, #4
 80146c8:	4b3d      	ldr	r3, [pc, #244]	; (80147c0 <lv_refr_join_area+0x144>)
 80146ca:	681a      	ldr	r2, [r3, #0]
 80146cc:	68fb      	ldr	r3, [r7, #12]
 80146ce:	3307      	adds	r3, #7
 80146d0:	00db      	lsls	r3, r3, #3
 80146d2:	4413      	add	r3, r2
 80146d4:	3304      	adds	r3, #4
 80146d6:	4619      	mov	r1, r3
 80146d8:	f009 f92b 	bl	801d932 <lv_area_is_on>
 80146dc:	4603      	mov	r3, r0
 80146de:	f083 0301 	eor.w	r3, r3, #1
 80146e2:	b2db      	uxtb	r3, r3
 80146e4:	2b00      	cmp	r3, #0
 80146e6:	d146      	bne.n	8014776 <lv_refr_join_area+0xfa>
                continue;
            }

            lv_area_join(&joined_area, &disp_refr->inv_areas[join_in], &disp_refr->inv_areas[join_from]);
 80146e8:	4b35      	ldr	r3, [pc, #212]	; (80147c0 <lv_refr_join_area+0x144>)
 80146ea:	681a      	ldr	r2, [r3, #0]
 80146ec:	68bb      	ldr	r3, [r7, #8]
 80146ee:	3307      	adds	r3, #7
 80146f0:	00db      	lsls	r3, r3, #3
 80146f2:	4413      	add	r3, r2
 80146f4:	1d19      	adds	r1, r3, #4
 80146f6:	4b32      	ldr	r3, [pc, #200]	; (80147c0 <lv_refr_join_area+0x144>)
 80146f8:	681a      	ldr	r2, [r3, #0]
 80146fa:	68fb      	ldr	r3, [r7, #12]
 80146fc:	3307      	adds	r3, #7
 80146fe:	00db      	lsls	r3, r3, #3
 8014700:	4413      	add	r3, r2
 8014702:	1d1a      	adds	r2, r3, #4
 8014704:	463b      	mov	r3, r7
 8014706:	4618      	mov	r0, r3
 8014708:	f009 f8d7 	bl	801d8ba <lv_area_join>

            /*Join two area only if the joined area size is smaller*/
            if(lv_area_get_size(&joined_area) < (lv_area_get_size(&disp_refr->inv_areas[join_in]) +
 801470c:	463b      	mov	r3, r7
 801470e:	4618      	mov	r0, r3
 8014710:	f009 f861 	bl	801d7d6 <lv_area_get_size>
 8014714:	4604      	mov	r4, r0
 8014716:	4b2a      	ldr	r3, [pc, #168]	; (80147c0 <lv_refr_join_area+0x144>)
 8014718:	681a      	ldr	r2, [r3, #0]
 801471a:	68bb      	ldr	r3, [r7, #8]
 801471c:	3307      	adds	r3, #7
 801471e:	00db      	lsls	r3, r3, #3
 8014720:	4413      	add	r3, r2
 8014722:	3304      	adds	r3, #4
 8014724:	4618      	mov	r0, r3
 8014726:	f009 f856 	bl	801d7d6 <lv_area_get_size>
 801472a:	4605      	mov	r5, r0
                                                 lv_area_get_size(&disp_refr->inv_areas[join_from]))) {
 801472c:	4b24      	ldr	r3, [pc, #144]	; (80147c0 <lv_refr_join_area+0x144>)
 801472e:	681a      	ldr	r2, [r3, #0]
 8014730:	68fb      	ldr	r3, [r7, #12]
 8014732:	3307      	adds	r3, #7
 8014734:	00db      	lsls	r3, r3, #3
 8014736:	4413      	add	r3, r2
 8014738:	3304      	adds	r3, #4
 801473a:	4618      	mov	r0, r3
 801473c:	f009 f84b 	bl	801d7d6 <lv_area_get_size>
 8014740:	4603      	mov	r3, r0
            if(lv_area_get_size(&joined_area) < (lv_area_get_size(&disp_refr->inv_areas[join_in]) +
 8014742:	442b      	add	r3, r5
 8014744:	429c      	cmp	r4, r3
 8014746:	d217      	bcs.n	8014778 <lv_refr_join_area+0xfc>
                lv_area_copy(&disp_refr->inv_areas[join_in], &joined_area);
 8014748:	4b1d      	ldr	r3, [pc, #116]	; (80147c0 <lv_refr_join_area+0x144>)
 801474a:	681a      	ldr	r2, [r3, #0]
 801474c:	68bb      	ldr	r3, [r7, #8]
 801474e:	3307      	adds	r3, #7
 8014750:	00db      	lsls	r3, r3, #3
 8014752:	4413      	add	r3, r2
 8014754:	3304      	adds	r3, #4
 8014756:	463a      	mov	r2, r7
 8014758:	4611      	mov	r1, r2
 801475a:	4618      	mov	r0, r3
 801475c:	f7ff fda5 	bl	80142aa <lv_area_copy>

                /*Mark 'join_form' is joined into 'join_in'*/
                disp_refr->inv_area_joined[join_from] = 1;
 8014760:	4b17      	ldr	r3, [pc, #92]	; (80147c0 <lv_refr_join_area+0x144>)
 8014762:	681a      	ldr	r2, [r3, #0]
 8014764:	68fb      	ldr	r3, [r7, #12]
 8014766:	4413      	add	r3, r2
 8014768:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 801476c:	2201      	movs	r2, #1
 801476e:	701a      	strb	r2, [r3, #0]
 8014770:	e002      	b.n	8014778 <lv_refr_join_area+0xfc>
                continue;
 8014772:	bf00      	nop
 8014774:	e000      	b.n	8014778 <lv_refr_join_area+0xfc>
                continue;
 8014776:	bf00      	nop
        for(join_from = 0; join_from < disp_refr->inv_p; join_from++) {
 8014778:	68fb      	ldr	r3, [r7, #12]
 801477a:	3301      	adds	r3, #1
 801477c:	60fb      	str	r3, [r7, #12]
 801477e:	4b10      	ldr	r3, [pc, #64]	; (80147c0 <lv_refr_join_area+0x144>)
 8014780:	681b      	ldr	r3, [r3, #0]
 8014782:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
 8014786:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801478a:	b29b      	uxth	r3, r3
 801478c:	461a      	mov	r2, r3
 801478e:	68fb      	ldr	r3, [r7, #12]
 8014790:	4293      	cmp	r3, r2
 8014792:	d385      	bcc.n	80146a0 <lv_refr_join_area+0x24>
 8014794:	e000      	b.n	8014798 <lv_refr_join_area+0x11c>
        if(disp_refr->inv_area_joined[join_in] != 0) continue;
 8014796:	bf00      	nop
    for(join_in = 0; join_in < disp_refr->inv_p; join_in++) {
 8014798:	68bb      	ldr	r3, [r7, #8]
 801479a:	3301      	adds	r3, #1
 801479c:	60bb      	str	r3, [r7, #8]
 801479e:	4b08      	ldr	r3, [pc, #32]	; (80147c0 <lv_refr_join_area+0x144>)
 80147a0:	681b      	ldr	r3, [r3, #0]
 80147a2:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
 80147a6:	f3c3 0309 	ubfx	r3, r3, #0, #10
 80147aa:	b29b      	uxth	r3, r3
 80147ac:	461a      	mov	r2, r3
 80147ae:	68bb      	ldr	r3, [r7, #8]
 80147b0:	4293      	cmp	r3, r2
 80147b2:	f4ff af69 	bcc.w	8014688 <lv_refr_join_area+0xc>
            }
        }
    }
}
 80147b6:	bf00      	nop
 80147b8:	bf00      	nop
 80147ba:	3710      	adds	r7, #16
 80147bc:	46bd      	mov	sp, r7
 80147be:	bdb0      	pop	{r4, r5, r7, pc}
 80147c0:	240623c8 	.word	0x240623c8

080147c4 <lv_refr_areas>:

/**
 * Refresh the joined areas
 */
static void lv_refr_areas(void)
{
 80147c4:	b580      	push	{r7, lr}
 80147c6:	b082      	sub	sp, #8
 80147c8:	af00      	add	r7, sp, #0
    px_num = 0;
 80147ca:	4b20      	ldr	r3, [pc, #128]	; (801484c <lv_refr_areas+0x88>)
 80147cc:	2200      	movs	r2, #0
 80147ce:	601a      	str	r2, [r3, #0]
    uint32_t i;

    for(i = 0; i < disp_refr->inv_p; i++) {
 80147d0:	2300      	movs	r3, #0
 80147d2:	607b      	str	r3, [r7, #4]
 80147d4:	e02a      	b.n	801482c <lv_refr_areas+0x68>
        /*Refresh the unjoined areas*/
        if(disp_refr->inv_area_joined[i] == 0) {
 80147d6:	4b1e      	ldr	r3, [pc, #120]	; (8014850 <lv_refr_areas+0x8c>)
 80147d8:	681a      	ldr	r2, [r3, #0]
 80147da:	687b      	ldr	r3, [r7, #4]
 80147dc:	4413      	add	r3, r2
 80147de:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 80147e2:	781b      	ldrb	r3, [r3, #0]
 80147e4:	2b00      	cmp	r3, #0
 80147e6:	d11e      	bne.n	8014826 <lv_refr_areas+0x62>

            lv_refr_area(&disp_refr->inv_areas[i]);
 80147e8:	4b19      	ldr	r3, [pc, #100]	; (8014850 <lv_refr_areas+0x8c>)
 80147ea:	681a      	ldr	r2, [r3, #0]
 80147ec:	687b      	ldr	r3, [r7, #4]
 80147ee:	3307      	adds	r3, #7
 80147f0:	00db      	lsls	r3, r3, #3
 80147f2:	4413      	add	r3, r2
 80147f4:	3304      	adds	r3, #4
 80147f6:	4618      	mov	r0, r3
 80147f8:	f000 f82c 	bl	8014854 <lv_refr_area>

            if(disp_refr->driver.monitor_cb) px_num += lv_area_get_size(&disp_refr->inv_areas[i]);
 80147fc:	4b14      	ldr	r3, [pc, #80]	; (8014850 <lv_refr_areas+0x8c>)
 80147fe:	681b      	ldr	r3, [r3, #0]
 8014800:	699b      	ldr	r3, [r3, #24]
 8014802:	2b00      	cmp	r3, #0
 8014804:	d00f      	beq.n	8014826 <lv_refr_areas+0x62>
 8014806:	4b12      	ldr	r3, [pc, #72]	; (8014850 <lv_refr_areas+0x8c>)
 8014808:	681a      	ldr	r2, [r3, #0]
 801480a:	687b      	ldr	r3, [r7, #4]
 801480c:	3307      	adds	r3, #7
 801480e:	00db      	lsls	r3, r3, #3
 8014810:	4413      	add	r3, r2
 8014812:	3304      	adds	r3, #4
 8014814:	4618      	mov	r0, r3
 8014816:	f008 ffde 	bl	801d7d6 <lv_area_get_size>
 801481a:	4602      	mov	r2, r0
 801481c:	4b0b      	ldr	r3, [pc, #44]	; (801484c <lv_refr_areas+0x88>)
 801481e:	681b      	ldr	r3, [r3, #0]
 8014820:	4413      	add	r3, r2
 8014822:	4a0a      	ldr	r2, [pc, #40]	; (801484c <lv_refr_areas+0x88>)
 8014824:	6013      	str	r3, [r2, #0]
    for(i = 0; i < disp_refr->inv_p; i++) {
 8014826:	687b      	ldr	r3, [r7, #4]
 8014828:	3301      	adds	r3, #1
 801482a:	607b      	str	r3, [r7, #4]
 801482c:	4b08      	ldr	r3, [pc, #32]	; (8014850 <lv_refr_areas+0x8c>)
 801482e:	681b      	ldr	r3, [r3, #0]
 8014830:	f8b3 315c 	ldrh.w	r3, [r3, #348]	; 0x15c
 8014834:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8014838:	b29b      	uxth	r3, r3
 801483a:	461a      	mov	r2, r3
 801483c:	687b      	ldr	r3, [r7, #4]
 801483e:	4293      	cmp	r3, r2
 8014840:	d3c9      	bcc.n	80147d6 <lv_refr_areas+0x12>
        }
    }
}
 8014842:	bf00      	nop
 8014844:	bf00      	nop
 8014846:	3708      	adds	r7, #8
 8014848:	46bd      	mov	sp, r7
 801484a:	bd80      	pop	{r7, pc}
 801484c:	240623c4 	.word	0x240623c4
 8014850:	240623c8 	.word	0x240623c8

08014854 <lv_refr_area>:
/**
 * Refresh an area if there is Virtual Display Buffer
 * @param area_p  pointer to an area to refresh
 */
static void lv_refr_area(const lv_area_t * area_p)
{
 8014854:	b590      	push	{r4, r7, lr}
 8014856:	b08d      	sub	sp, #52	; 0x34
 8014858:	af00      	add	r7, sp, #0
 801485a:	6078      	str	r0, [r7, #4]
    /*True double buffering: there are two screen sized buffers. Just redraw directly into a
     * buffer*/
    if(lv_disp_is_true_double_buf(disp_refr)) {
 801485c:	4b7f      	ldr	r3, [pc, #508]	; (8014a5c <lv_refr_area+0x208>)
 801485e:	681b      	ldr	r3, [r3, #0]
 8014860:	4618      	mov	r0, r3
 8014862:	f008 fce9 	bl	801d238 <lv_disp_is_true_double_buf>
 8014866:	4603      	mov	r3, r0
 8014868:	2b00      	cmp	r3, #0
 801486a:	d027      	beq.n	80148bc <lv_refr_area+0x68>
        lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
 801486c:	4b7b      	ldr	r3, [pc, #492]	; (8014a5c <lv_refr_area+0x208>)
 801486e:	681b      	ldr	r3, [r3, #0]
 8014870:	4618      	mov	r0, r3
 8014872:	f008 fcbe 	bl	801d1f2 <lv_disp_get_buf>
 8014876:	6178      	str	r0, [r7, #20]
        vdb->area.x1        = 0;
 8014878:	697b      	ldr	r3, [r7, #20]
 801487a:	2200      	movs	r2, #0
 801487c:	821a      	strh	r2, [r3, #16]
        vdb->area.x2        = lv_disp_get_hor_res(disp_refr) - 1;
 801487e:	4b77      	ldr	r3, [pc, #476]	; (8014a5c <lv_refr_area+0x208>)
 8014880:	681b      	ldr	r3, [r3, #0]
 8014882:	4618      	mov	r0, r3
 8014884:	f008 fc46 	bl	801d114 <lv_disp_get_hor_res>
 8014888:	4603      	mov	r3, r0
 801488a:	b29b      	uxth	r3, r3
 801488c:	3b01      	subs	r3, #1
 801488e:	b29b      	uxth	r3, r3
 8014890:	b21a      	sxth	r2, r3
 8014892:	697b      	ldr	r3, [r7, #20]
 8014894:	829a      	strh	r2, [r3, #20]
        vdb->area.y1        = 0;
 8014896:	697b      	ldr	r3, [r7, #20]
 8014898:	2200      	movs	r2, #0
 801489a:	825a      	strh	r2, [r3, #18]
        vdb->area.y2        = lv_disp_get_ver_res(disp_refr) - 1;
 801489c:	4b6f      	ldr	r3, [pc, #444]	; (8014a5c <lv_refr_area+0x208>)
 801489e:	681b      	ldr	r3, [r3, #0]
 80148a0:	4618      	mov	r0, r3
 80148a2:	f008 fc59 	bl	801d158 <lv_disp_get_ver_res>
 80148a6:	4603      	mov	r3, r0
 80148a8:	b29b      	uxth	r3, r3
 80148aa:	3b01      	subs	r3, #1
 80148ac:	b29b      	uxth	r3, r3
 80148ae:	b21a      	sxth	r2, r3
 80148b0:	697b      	ldr	r3, [r7, #20]
 80148b2:	82da      	strh	r2, [r3, #22]
        lv_refr_area_part(area_p);
 80148b4:	6878      	ldr	r0, [r7, #4]
 80148b6:	f000 f8d3 	bl	8014a60 <lv_refr_area_part>
 80148ba:	e0cb      	b.n	8014a54 <lv_refr_area+0x200>
    }
    /*The buffer is smaller: refresh the area in parts*/
    else {
        lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
 80148bc:	4b67      	ldr	r3, [pc, #412]	; (8014a5c <lv_refr_area+0x208>)
 80148be:	681b      	ldr	r3, [r3, #0]
 80148c0:	4618      	mov	r0, r3
 80148c2:	f008 fc96 	bl	801d1f2 <lv_disp_get_buf>
 80148c6:	6238      	str	r0, [r7, #32]
        /*Calculate the max row num*/
        lv_coord_t w = lv_area_get_width(area_p);
 80148c8:	6878      	ldr	r0, [r7, #4]
 80148ca:	f7ff fcfc 	bl	80142c6 <lv_area_get_width>
 80148ce:	4603      	mov	r3, r0
 80148d0:	83fb      	strh	r3, [r7, #30]
        lv_coord_t h = lv_area_get_height(area_p);
 80148d2:	6878      	ldr	r0, [r7, #4]
 80148d4:	f7ff fd0e 	bl	80142f4 <lv_area_get_height>
 80148d8:	4603      	mov	r3, r0
 80148da:	83bb      	strh	r3, [r7, #28]
        lv_coord_t y2 =
            area_p->y2 >= lv_disp_get_ver_res(disp_refr) ? y2 = lv_disp_get_ver_res(disp_refr) - 1 : area_p->y2;
 80148dc:	687b      	ldr	r3, [r7, #4]
 80148de:	f9b3 4006 	ldrsh.w	r4, [r3, #6]
 80148e2:	4b5e      	ldr	r3, [pc, #376]	; (8014a5c <lv_refr_area+0x208>)
 80148e4:	681b      	ldr	r3, [r3, #0]
 80148e6:	4618      	mov	r0, r3
 80148e8:	f008 fc36 	bl	801d158 <lv_disp_get_ver_res>
 80148ec:	4603      	mov	r3, r0
        lv_coord_t y2 =
 80148ee:	429c      	cmp	r4, r3
 80148f0:	db0c      	blt.n	801490c <lv_refr_area+0xb8>
            area_p->y2 >= lv_disp_get_ver_res(disp_refr) ? y2 = lv_disp_get_ver_res(disp_refr) - 1 : area_p->y2;
 80148f2:	4b5a      	ldr	r3, [pc, #360]	; (8014a5c <lv_refr_area+0x208>)
 80148f4:	681b      	ldr	r3, [r3, #0]
 80148f6:	4618      	mov	r0, r3
 80148f8:	f008 fc2e 	bl	801d158 <lv_disp_get_ver_res>
 80148fc:	4603      	mov	r3, r0
 80148fe:	b29b      	uxth	r3, r3
 8014900:	3b01      	subs	r3, #1
 8014902:	b29b      	uxth	r3, r3
 8014904:	837b      	strh	r3, [r7, #26]
        lv_coord_t y2 =
 8014906:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 801490a:	e002      	b.n	8014912 <lv_refr_area+0xbe>
 801490c:	687b      	ldr	r3, [r7, #4]
 801490e:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8014912:	837b      	strh	r3, [r7, #26]

        int32_t max_row = (uint32_t)vdb->size / w;
 8014914:	6a3b      	ldr	r3, [r7, #32]
 8014916:	68da      	ldr	r2, [r3, #12]
 8014918:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 801491c:	fbb2 f3f3 	udiv	r3, r2, r3
 8014920:	62fb      	str	r3, [r7, #44]	; 0x2c

        if(max_row > h) max_row = h;
 8014922:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 8014926:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8014928:	429a      	cmp	r2, r3
 801492a:	dd02      	ble.n	8014932 <lv_refr_area+0xde>
 801492c:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 8014930:	62fb      	str	r3, [r7, #44]	; 0x2c

        /*Round down the lines of VDB if rounding is added*/
        if(disp_refr->driver.rounder_cb) {
 8014932:	4b4a      	ldr	r3, [pc, #296]	; (8014a5c <lv_refr_area+0x208>)
 8014934:	681b      	ldr	r3, [r3, #0]
 8014936:	691b      	ldr	r3, [r3, #16]
 8014938:	2b00      	cmp	r3, #0
 801493a:	d034      	beq.n	80149a6 <lv_refr_area+0x152>
            lv_area_t tmp;
            tmp.x1 = 0;
 801493c:	2300      	movs	r3, #0
 801493e:	81bb      	strh	r3, [r7, #12]
            tmp.x2 = 0;
 8014940:	2300      	movs	r3, #0
 8014942:	823b      	strh	r3, [r7, #16]
            tmp.y1 = 0;
 8014944:	2300      	movs	r3, #0
 8014946:	81fb      	strh	r3, [r7, #14]

            lv_coord_t y_tmp = max_row - 1;
 8014948:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801494a:	b29b      	uxth	r3, r3
 801494c:	3b01      	subs	r3, #1
 801494e:	b29b      	uxth	r3, r3
 8014950:	857b      	strh	r3, [r7, #42]	; 0x2a
            do {
                tmp.y2 = y_tmp;
 8014952:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8014954:	827b      	strh	r3, [r7, #18]
                disp_refr->driver.rounder_cb(&disp_refr->driver, &tmp);
 8014956:	4b41      	ldr	r3, [pc, #260]	; (8014a5c <lv_refr_area+0x208>)
 8014958:	681b      	ldr	r3, [r3, #0]
 801495a:	691b      	ldr	r3, [r3, #16]
 801495c:	4a3f      	ldr	r2, [pc, #252]	; (8014a5c <lv_refr_area+0x208>)
 801495e:	6812      	ldr	r2, [r2, #0]
 8014960:	4610      	mov	r0, r2
 8014962:	f107 020c 	add.w	r2, r7, #12
 8014966:	4611      	mov	r1, r2
 8014968:	4798      	blx	r3

                /*If this height fits into `max_row` then fine*/
                if(lv_area_get_height(&tmp) <= max_row) break;
 801496a:	f107 030c 	add.w	r3, r7, #12
 801496e:	4618      	mov	r0, r3
 8014970:	f7ff fcc0 	bl	80142f4 <lv_area_get_height>
 8014974:	4603      	mov	r3, r0
 8014976:	461a      	mov	r2, r3
 8014978:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801497a:	4293      	cmp	r3, r2
 801497c:	da0a      	bge.n	8014994 <lv_refr_area+0x140>

                /*Decrement the height of the area until it fits into `max_row` after rounding*/
                y_tmp--;
 801497e:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8014982:	b29b      	uxth	r3, r3
 8014984:	3b01      	subs	r3, #1
 8014986:	b29b      	uxth	r3, r3
 8014988:	857b      	strh	r3, [r7, #42]	; 0x2a
            } while(y_tmp != 0);
 801498a:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 801498e:	2b00      	cmp	r3, #0
 8014990:	d1df      	bne.n	8014952 <lv_refr_area+0xfe>
 8014992:	e000      	b.n	8014996 <lv_refr_area+0x142>
                if(lv_area_get_height(&tmp) <= max_row) break;
 8014994:	bf00      	nop

            if(y_tmp == 0) {
 8014996:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 801499a:	2b00      	cmp	r3, #0
 801499c:	d059      	beq.n	8014a52 <lv_refr_area+0x1fe>
                LV_LOG_WARN("Can't set VDB height using the round function. (Wrong round_cb or to "
                            "small VDB)");
                return;
            } else {
                max_row = tmp.y2 + 1;
 801499e:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 80149a2:	3301      	adds	r3, #1
 80149a4:	62fb      	str	r3, [r7, #44]	; 0x2c
            }
        }

        /*Always use the full row*/
        lv_coord_t row;
        lv_coord_t row_last = 0;
 80149a6:	2300      	movs	r3, #0
 80149a8:	84fb      	strh	r3, [r7, #38]	; 0x26
        for(row = area_p->y1; row + max_row - 1 <= y2; row += max_row) {
 80149aa:	687b      	ldr	r3, [r7, #4]
 80149ac:	885b      	ldrh	r3, [r3, #2]
 80149ae:	853b      	strh	r3, [r7, #40]	; 0x28
 80149b0:	e02c      	b.n	8014a0c <lv_refr_area+0x1b8>
            /*Calc. the next y coordinates of VDB*/
            vdb->area.x1 = area_p->x1;
 80149b2:	687b      	ldr	r3, [r7, #4]
 80149b4:	f9b3 2000 	ldrsh.w	r2, [r3]
 80149b8:	6a3b      	ldr	r3, [r7, #32]
 80149ba:	821a      	strh	r2, [r3, #16]
            vdb->area.x2 = area_p->x2;
 80149bc:	687b      	ldr	r3, [r7, #4]
 80149be:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
 80149c2:	6a3b      	ldr	r3, [r7, #32]
 80149c4:	829a      	strh	r2, [r3, #20]
            vdb->area.y1 = row;
 80149c6:	6a3b      	ldr	r3, [r7, #32]
 80149c8:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
 80149ca:	825a      	strh	r2, [r3, #18]
            vdb->area.y2 = row + max_row - 1;
 80149cc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80149ce:	b29a      	uxth	r2, r3
 80149d0:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 80149d2:	4413      	add	r3, r2
 80149d4:	b29b      	uxth	r3, r3
 80149d6:	3b01      	subs	r3, #1
 80149d8:	b29b      	uxth	r3, r3
 80149da:	b21a      	sxth	r2, r3
 80149dc:	6a3b      	ldr	r3, [r7, #32]
 80149de:	82da      	strh	r2, [r3, #22]
            if(vdb->area.y2 > y2) vdb->area.y2 = y2;
 80149e0:	6a3b      	ldr	r3, [r7, #32]
 80149e2:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 80149e6:	f9b7 201a 	ldrsh.w	r2, [r7, #26]
 80149ea:	429a      	cmp	r2, r3
 80149ec:	da02      	bge.n	80149f4 <lv_refr_area+0x1a0>
 80149ee:	6a3b      	ldr	r3, [r7, #32]
 80149f0:	8b7a      	ldrh	r2, [r7, #26]
 80149f2:	82da      	strh	r2, [r3, #22]
            row_last = vdb->area.y2;
 80149f4:	6a3b      	ldr	r3, [r7, #32]
 80149f6:	8adb      	ldrh	r3, [r3, #22]
 80149f8:	84fb      	strh	r3, [r7, #38]	; 0x26
            lv_refr_area_part(area_p);
 80149fa:	6878      	ldr	r0, [r7, #4]
 80149fc:	f000 f830 	bl	8014a60 <lv_refr_area_part>
        for(row = area_p->y1; row + max_row - 1 <= y2; row += max_row) {
 8014a00:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014a02:	b29a      	uxth	r2, r3
 8014a04:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8014a06:	4413      	add	r3, r2
 8014a08:	b29b      	uxth	r3, r3
 8014a0a:	853b      	strh	r3, [r7, #40]	; 0x28
 8014a0c:	f9b7 2028 	ldrsh.w	r2, [r7, #40]	; 0x28
 8014a10:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014a12:	4413      	add	r3, r2
 8014a14:	1e5a      	subs	r2, r3, #1
 8014a16:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8014a1a:	429a      	cmp	r2, r3
 8014a1c:	ddc9      	ble.n	80149b2 <lv_refr_area+0x15e>
        }

        /*If the last y coordinates are not handled yet ...*/
        if(y2 != row_last) {
 8014a1e:	f9b7 201a 	ldrsh.w	r2, [r7, #26]
 8014a22:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8014a26:	429a      	cmp	r2, r3
 8014a28:	d014      	beq.n	8014a54 <lv_refr_area+0x200>
            /*Calc. the next y coordinates of VDB*/
            vdb->area.x1 = area_p->x1;
 8014a2a:	687b      	ldr	r3, [r7, #4]
 8014a2c:	f9b3 2000 	ldrsh.w	r2, [r3]
 8014a30:	6a3b      	ldr	r3, [r7, #32]
 8014a32:	821a      	strh	r2, [r3, #16]
            vdb->area.x2 = area_p->x2;
 8014a34:	687b      	ldr	r3, [r7, #4]
 8014a36:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
 8014a3a:	6a3b      	ldr	r3, [r7, #32]
 8014a3c:	829a      	strh	r2, [r3, #20]
            vdb->area.y1 = row;
 8014a3e:	6a3b      	ldr	r3, [r7, #32]
 8014a40:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
 8014a42:	825a      	strh	r2, [r3, #18]
            vdb->area.y2 = y2;
 8014a44:	6a3b      	ldr	r3, [r7, #32]
 8014a46:	8b7a      	ldrh	r2, [r7, #26]
 8014a48:	82da      	strh	r2, [r3, #22]

            /*Refresh this part too*/
            lv_refr_area_part(area_p);
 8014a4a:	6878      	ldr	r0, [r7, #4]
 8014a4c:	f000 f808 	bl	8014a60 <lv_refr_area_part>
 8014a50:	e000      	b.n	8014a54 <lv_refr_area+0x200>
                return;
 8014a52:	bf00      	nop
        }
    }
}
 8014a54:	3734      	adds	r7, #52	; 0x34
 8014a56:	46bd      	mov	sp, r7
 8014a58:	bd90      	pop	{r4, r7, pc}
 8014a5a:	bf00      	nop
 8014a5c:	240623c8 	.word	0x240623c8

08014a60 <lv_refr_area_part>:
/**
 * Refresh a part of an area which is on the actual Virtual Display Buffer
 * @param area_p pointer to an area to refresh
 */
static void lv_refr_area_part(const lv_area_t * area_p)
{
 8014a60:	b580      	push	{r7, lr}
 8014a62:	b086      	sub	sp, #24
 8014a64:	af00      	add	r7, sp, #0
 8014a66:	6078      	str	r0, [r7, #4]

    lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
 8014a68:	4b2e      	ldr	r3, [pc, #184]	; (8014b24 <lv_refr_area_part+0xc4>)
 8014a6a:	681b      	ldr	r3, [r3, #0]
 8014a6c:	4618      	mov	r0, r3
 8014a6e:	f008 fbc0 	bl	801d1f2 <lv_disp_get_buf>
 8014a72:	6178      	str	r0, [r7, #20]

    /*In non double buffered mode, before rendering the next part wait until the previous image is
     * flushed*/
    if(lv_disp_is_double_buf(disp_refr) == false) {
 8014a74:	4b2b      	ldr	r3, [pc, #172]	; (8014b24 <lv_refr_area_part+0xc4>)
 8014a76:	681b      	ldr	r3, [r3, #0]
 8014a78:	4618      	mov	r0, r3
 8014a7a:	f008 fbc6 	bl	801d20a <lv_disp_is_double_buf>
 8014a7e:	4603      	mov	r3, r0
 8014a80:	f083 0301 	eor.w	r3, r3, #1
 8014a84:	b2db      	uxtb	r3, r3
 8014a86:	2b00      	cmp	r3, #0
 8014a88:	d007      	beq.n	8014a9a <lv_refr_area_part+0x3a>
        while(vdb->flushing)
 8014a8a:	bf00      	nop
 8014a8c:	697b      	ldr	r3, [r7, #20]
 8014a8e:	699b      	ldr	r3, [r3, #24]
 8014a90:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8014a94:	b2db      	uxtb	r3, r3
 8014a96:	2b00      	cmp	r3, #0
 8014a98:	d1f8      	bne.n	8014a8c <lv_refr_area_part+0x2c>
    lv_obj_t * top_p;

    /*Get the new mask from the original area and the act. VDB
     It will be a part of 'area_p'*/
    lv_area_t start_mask;
    lv_area_intersect(&start_mask, area_p, &vdb->area);
 8014a9a:	697b      	ldr	r3, [r7, #20]
 8014a9c:	f103 0210 	add.w	r2, r3, #16
 8014aa0:	f107 0308 	add.w	r3, r7, #8
 8014aa4:	6879      	ldr	r1, [r7, #4]
 8014aa6:	4618      	mov	r0, r3
 8014aa8:	f008 feb6 	bl	801d818 <lv_area_intersect>

    /*Get the most top object which is not covered by others*/
    top_p = lv_refr_get_top_obj(&start_mask, lv_disp_get_scr_act(disp_refr));
 8014aac:	4b1d      	ldr	r3, [pc, #116]	; (8014b24 <lv_refr_area_part+0xc4>)
 8014aae:	681b      	ldr	r3, [r3, #0]
 8014ab0:	4618      	mov	r0, r3
 8014ab2:	f7fd fb97 	bl	80121e4 <lv_disp_get_scr_act>
 8014ab6:	4602      	mov	r2, r0
 8014ab8:	f107 0308 	add.w	r3, r7, #8
 8014abc:	4611      	mov	r1, r2
 8014abe:	4618      	mov	r0, r3
 8014ac0:	f000 f832 	bl	8014b28 <lv_refr_get_top_obj>
 8014ac4:	6138      	str	r0, [r7, #16]

    /*Do the refreshing from the top object*/
    lv_refr_obj_and_children(top_p, &start_mask);
 8014ac6:	f107 0308 	add.w	r3, r7, #8
 8014aca:	4619      	mov	r1, r3
 8014acc:	6938      	ldr	r0, [r7, #16]
 8014ace:	f000 f87f 	bl	8014bd0 <lv_refr_obj_and_children>

    /*Also refresh top and sys layer unconditionally*/
    lv_refr_obj_and_children(lv_disp_get_layer_top(disp_refr), &start_mask);
 8014ad2:	4b14      	ldr	r3, [pc, #80]	; (8014b24 <lv_refr_area_part+0xc4>)
 8014ad4:	681b      	ldr	r3, [r3, #0]
 8014ad6:	4618      	mov	r0, r3
 8014ad8:	f7fd fb99 	bl	801220e <lv_disp_get_layer_top>
 8014adc:	4602      	mov	r2, r0
 8014ade:	f107 0308 	add.w	r3, r7, #8
 8014ae2:	4619      	mov	r1, r3
 8014ae4:	4610      	mov	r0, r2
 8014ae6:	f000 f873 	bl	8014bd0 <lv_refr_obj_and_children>
    lv_refr_obj_and_children(lv_disp_get_layer_sys(disp_refr), &start_mask);
 8014aea:	4b0e      	ldr	r3, [pc, #56]	; (8014b24 <lv_refr_area_part+0xc4>)
 8014aec:	681b      	ldr	r3, [r3, #0]
 8014aee:	4618      	mov	r0, r3
 8014af0:	f7fd fba2 	bl	8012238 <lv_disp_get_layer_sys>
 8014af4:	4602      	mov	r2, r0
 8014af6:	f107 0308 	add.w	r3, r7, #8
 8014afa:	4619      	mov	r1, r3
 8014afc:	4610      	mov	r0, r2
 8014afe:	f000 f867 	bl	8014bd0 <lv_refr_obj_and_children>

    /* In true double buffered mode flush only once when all areas were rendered.
     * In normal mode flush after every area */
    if(lv_disp_is_true_double_buf(disp_refr) == false) {
 8014b02:	4b08      	ldr	r3, [pc, #32]	; (8014b24 <lv_refr_area_part+0xc4>)
 8014b04:	681b      	ldr	r3, [r3, #0]
 8014b06:	4618      	mov	r0, r3
 8014b08:	f008 fb96 	bl	801d238 <lv_disp_is_true_double_buf>
 8014b0c:	4603      	mov	r3, r0
 8014b0e:	f083 0301 	eor.w	r3, r3, #1
 8014b12:	b2db      	uxtb	r3, r3
 8014b14:	2b00      	cmp	r3, #0
 8014b16:	d001      	beq.n	8014b1c <lv_refr_area_part+0xbc>
        lv_refr_vdb_flush();
 8014b18:	f000 f95e 	bl	8014dd8 <lv_refr_vdb_flush>
    }
}
 8014b1c:	bf00      	nop
 8014b1e:	3718      	adds	r7, #24
 8014b20:	46bd      	mov	sp, r7
 8014b22:	bd80      	pop	{r7, pc}
 8014b24:	240623c8 	.word	0x240623c8

08014b28 <lv_refr_get_top_obj>:
 * @param area_p pointer to an area
 * @param obj the first object to start the searching (typically a screen)
 * @return
 */
static lv_obj_t * lv_refr_get_top_obj(const lv_area_t * area_p, lv_obj_t * obj)
{
 8014b28:	b580      	push	{r7, lr}
 8014b2a:	b086      	sub	sp, #24
 8014b2c:	af00      	add	r7, sp, #0
 8014b2e:	6078      	str	r0, [r7, #4]
 8014b30:	6039      	str	r1, [r7, #0]
    lv_obj_t * found_p = NULL;
 8014b32:	2300      	movs	r3, #0
 8014b34:	617b      	str	r3, [r7, #20]

    /*If this object is fully cover the draw area check the children too */
    if(lv_area_is_in(area_p, &obj->coords) && obj->hidden == 0) {
 8014b36:	683b      	ldr	r3, [r7, #0]
 8014b38:	3310      	adds	r3, #16
 8014b3a:	4619      	mov	r1, r3
 8014b3c:	6878      	ldr	r0, [r7, #4]
 8014b3e:	f008 ff26 	bl	801d98e <lv_area_is_in>
 8014b42:	4603      	mov	r3, r0
 8014b44:	2b00      	cmp	r3, #0
 8014b46:	d03e      	beq.n	8014bc6 <lv_refr_get_top_obj+0x9e>
 8014b48:	683b      	ldr	r3, [r7, #0]
 8014b4a:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8014b4e:	f003 0310 	and.w	r3, r3, #16
 8014b52:	b2db      	uxtb	r3, r3
 8014b54:	2b00      	cmp	r3, #0
 8014b56:	d136      	bne.n	8014bc6 <lv_refr_get_top_obj+0x9e>
        lv_obj_t * i;
        LV_LL_READ(obj->child_ll, i)
 8014b58:	683b      	ldr	r3, [r7, #0]
 8014b5a:	3304      	adds	r3, #4
 8014b5c:	4618      	mov	r0, r3
 8014b5e:	f009 f941 	bl	801dde4 <lv_ll_get_head>
 8014b62:	6138      	str	r0, [r7, #16]
 8014b64:	e00e      	b.n	8014b84 <lv_refr_get_top_obj+0x5c>
        {
            found_p = lv_refr_get_top_obj(area_p, i);
 8014b66:	6939      	ldr	r1, [r7, #16]
 8014b68:	6878      	ldr	r0, [r7, #4]
 8014b6a:	f7ff ffdd 	bl	8014b28 <lv_refr_get_top_obj>
 8014b6e:	6178      	str	r0, [r7, #20]

            /*If a children is ok then break*/
            if(found_p != NULL) {
 8014b70:	697b      	ldr	r3, [r7, #20]
 8014b72:	2b00      	cmp	r3, #0
 8014b74:	d10a      	bne.n	8014b8c <lv_refr_get_top_obj+0x64>
        LV_LL_READ(obj->child_ll, i)
 8014b76:	683b      	ldr	r3, [r7, #0]
 8014b78:	3304      	adds	r3, #4
 8014b7a:	6939      	ldr	r1, [r7, #16]
 8014b7c:	4618      	mov	r0, r3
 8014b7e:	f009 f957 	bl	801de30 <lv_ll_get_next>
 8014b82:	6138      	str	r0, [r7, #16]
 8014b84:	693b      	ldr	r3, [r7, #16]
 8014b86:	2b00      	cmp	r3, #0
 8014b88:	d1ed      	bne.n	8014b66 <lv_refr_get_top_obj+0x3e>
 8014b8a:	e000      	b.n	8014b8e <lv_refr_get_top_obj+0x66>
                break;
 8014b8c:	bf00      	nop
            }
        }

        /*If no better children check this object*/
        if(found_p == NULL) {
 8014b8e:	697b      	ldr	r3, [r7, #20]
 8014b90:	2b00      	cmp	r3, #0
 8014b92:	d118      	bne.n	8014bc6 <lv_refr_get_top_obj+0x9e>
            const lv_style_t * style = lv_obj_get_style(obj);
 8014b94:	6838      	ldr	r0, [r7, #0]
 8014b96:	f7ff f953 	bl	8013e40 <lv_obj_get_style>
 8014b9a:	60f8      	str	r0, [r7, #12]
            if(style->body.opa == LV_OPA_COVER && obj->design_cb(obj, area_p, LV_DESIGN_COVER_CHK) != false &&
 8014b9c:	68fb      	ldr	r3, [r7, #12]
 8014b9e:	7a1b      	ldrb	r3, [r3, #8]
 8014ba0:	2bff      	cmp	r3, #255	; 0xff
 8014ba2:	d110      	bne.n	8014bc6 <lv_refr_get_top_obj+0x9e>
 8014ba4:	683b      	ldr	r3, [r7, #0]
 8014ba6:	6a1b      	ldr	r3, [r3, #32]
 8014ba8:	2202      	movs	r2, #2
 8014baa:	6879      	ldr	r1, [r7, #4]
 8014bac:	6838      	ldr	r0, [r7, #0]
 8014bae:	4798      	blx	r3
 8014bb0:	4603      	mov	r3, r0
 8014bb2:	2b00      	cmp	r3, #0
 8014bb4:	d007      	beq.n	8014bc6 <lv_refr_get_top_obj+0x9e>
               lv_obj_get_opa_scale(obj) == LV_OPA_COVER) {
 8014bb6:	6838      	ldr	r0, [r7, #0]
 8014bb8:	f7ff f9af 	bl	8013f1a <lv_obj_get_opa_scale>
 8014bbc:	4603      	mov	r3, r0
            if(style->body.opa == LV_OPA_COVER && obj->design_cb(obj, area_p, LV_DESIGN_COVER_CHK) != false &&
 8014bbe:	2bff      	cmp	r3, #255	; 0xff
 8014bc0:	d101      	bne.n	8014bc6 <lv_refr_get_top_obj+0x9e>
                found_p = obj;
 8014bc2:	683b      	ldr	r3, [r7, #0]
 8014bc4:	617b      	str	r3, [r7, #20]
            }
        }
    }

    return found_p;
 8014bc6:	697b      	ldr	r3, [r7, #20]
}
 8014bc8:	4618      	mov	r0, r3
 8014bca:	3718      	adds	r7, #24
 8014bcc:	46bd      	mov	sp, r7
 8014bce:	bd80      	pop	{r7, pc}

08014bd0 <lv_refr_obj_and_children>:
 * Make the refreshing from an object. Draw all its children and the youngers too.
 * @param top_p pointer to an objects. Start the drawing from it.
 * @param mask_p pointer to an area, the objects will be drawn only here
 */
static void lv_refr_obj_and_children(lv_obj_t * top_p, const lv_area_t * mask_p)
{
 8014bd0:	b580      	push	{r7, lr}
 8014bd2:	b086      	sub	sp, #24
 8014bd4:	af00      	add	r7, sp, #0
 8014bd6:	6078      	str	r0, [r7, #4]
 8014bd8:	6039      	str	r1, [r7, #0]
    /* Normally always will be a top_obj (at least the screen)
     * but in special cases (e.g. if the screen has alpha) it won't.
     * In this case use the screen directly */
    if(top_p == NULL) top_p = lv_disp_get_scr_act(disp_refr);
 8014bda:	687b      	ldr	r3, [r7, #4]
 8014bdc:	2b00      	cmp	r3, #0
 8014bde:	d105      	bne.n	8014bec <lv_refr_obj_and_children+0x1c>
 8014be0:	4b1d      	ldr	r3, [pc, #116]	; (8014c58 <lv_refr_obj_and_children+0x88>)
 8014be2:	681b      	ldr	r3, [r3, #0]
 8014be4:	4618      	mov	r0, r3
 8014be6:	f7fd fafd 	bl	80121e4 <lv_disp_get_scr_act>
 8014bea:	6078      	str	r0, [r7, #4]

    /*Refresh the top object and its children*/
    lv_refr_obj(top_p, mask_p);
 8014bec:	6839      	ldr	r1, [r7, #0]
 8014bee:	6878      	ldr	r0, [r7, #4]
 8014bf0:	f000 f834 	bl	8014c5c <lv_refr_obj>

    /*Draw the 'younger' sibling objects because they can be on top_obj */
    lv_obj_t * par;
    lv_obj_t * border_p = top_p;
 8014bf4:	687b      	ldr	r3, [r7, #4]
 8014bf6:	613b      	str	r3, [r7, #16]

    par = lv_obj_get_parent(top_p);
 8014bf8:	6878      	ldr	r0, [r7, #4]
 8014bfa:	f7ff f89b 	bl	8013d34 <lv_obj_get_parent>
 8014bfe:	6178      	str	r0, [r7, #20]

    /*Do until not reach the screen*/
    while(par != NULL) {
 8014c00:	e021      	b.n	8014c46 <lv_refr_obj_and_children+0x76>
        /*object before border_p has to be redrawn*/
        lv_obj_t * i = lv_ll_get_prev(&(par->child_ll), border_p);
 8014c02:	697b      	ldr	r3, [r7, #20]
 8014c04:	3304      	adds	r3, #4
 8014c06:	6939      	ldr	r1, [r7, #16]
 8014c08:	4618      	mov	r0, r3
 8014c0a:	f009 f92b 	bl	801de64 <lv_ll_get_prev>
 8014c0e:	60f8      	str	r0, [r7, #12]

        while(i != NULL) {
 8014c10:	e00a      	b.n	8014c28 <lv_refr_obj_and_children+0x58>
            /*Refresh the objects*/
            lv_refr_obj(i, mask_p);
 8014c12:	6839      	ldr	r1, [r7, #0]
 8014c14:	68f8      	ldr	r0, [r7, #12]
 8014c16:	f000 f821 	bl	8014c5c <lv_refr_obj>
            i = lv_ll_get_prev(&(par->child_ll), i);
 8014c1a:	697b      	ldr	r3, [r7, #20]
 8014c1c:	3304      	adds	r3, #4
 8014c1e:	68f9      	ldr	r1, [r7, #12]
 8014c20:	4618      	mov	r0, r3
 8014c22:	f009 f91f 	bl	801de64 <lv_ll_get_prev>
 8014c26:	60f8      	str	r0, [r7, #12]
        while(i != NULL) {
 8014c28:	68fb      	ldr	r3, [r7, #12]
 8014c2a:	2b00      	cmp	r3, #0
 8014c2c:	d1f1      	bne.n	8014c12 <lv_refr_obj_and_children+0x42>
        }

        /*Call the post draw design function of the parents of the to object*/
        par->design_cb(par, mask_p, LV_DESIGN_DRAW_POST);
 8014c2e:	697b      	ldr	r3, [r7, #20]
 8014c30:	6a1b      	ldr	r3, [r3, #32]
 8014c32:	2201      	movs	r2, #1
 8014c34:	6839      	ldr	r1, [r7, #0]
 8014c36:	6978      	ldr	r0, [r7, #20]
 8014c38:	4798      	blx	r3

        /*The new border will be there last parents,
         *so the 'younger' brothers of parent will be refreshed*/
        border_p = par;
 8014c3a:	697b      	ldr	r3, [r7, #20]
 8014c3c:	613b      	str	r3, [r7, #16]
        /*Go a level deeper*/
        par = lv_obj_get_parent(par);
 8014c3e:	6978      	ldr	r0, [r7, #20]
 8014c40:	f7ff f878 	bl	8013d34 <lv_obj_get_parent>
 8014c44:	6178      	str	r0, [r7, #20]
    while(par != NULL) {
 8014c46:	697b      	ldr	r3, [r7, #20]
 8014c48:	2b00      	cmp	r3, #0
 8014c4a:	d1da      	bne.n	8014c02 <lv_refr_obj_and_children+0x32>
    }
}
 8014c4c:	bf00      	nop
 8014c4e:	bf00      	nop
 8014c50:	3718      	adds	r7, #24
 8014c52:	46bd      	mov	sp, r7
 8014c54:	bd80      	pop	{r7, pc}
 8014c56:	bf00      	nop
 8014c58:	240623c8 	.word	0x240623c8

08014c5c <lv_refr_obj>:
 * Refresh an object an all of its children. (Called recursively)
 * @param obj pointer to an object to refresh
 * @param mask_ori_p pointer to an area, the objects will be drawn only here
 */
static void lv_refr_obj(lv_obj_t * obj, const lv_area_t * mask_ori_p)
{
 8014c5c:	b580      	push	{r7, lr}
 8014c5e:	b08e      	sub	sp, #56	; 0x38
 8014c60:	af00      	add	r7, sp, #0
 8014c62:	6078      	str	r0, [r7, #4]
 8014c64:	6039      	str	r1, [r7, #0]
    /*Do not refresh hidden objects*/
    if(obj->hidden != 0) return;
 8014c66:	687b      	ldr	r3, [r7, #4]
 8014c68:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8014c6c:	f003 0310 	and.w	r3, r3, #16
 8014c70:	b2db      	uxtb	r3, r3
 8014c72:	2b00      	cmp	r3, #0
 8014c74:	f040 80ac 	bne.w	8014dd0 <lv_refr_obj+0x174>
    /* Truncate the original mask to the coordinates of the parent
     * because the parent and its children are visible only here */
    lv_area_t obj_mask;
    lv_area_t obj_ext_mask;
    lv_area_t obj_area;
    lv_coord_t ext_size = obj->ext_draw_pad;
 8014c78:	687b      	ldr	r3, [r7, #4]
 8014c7a:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 8014c7c:	867b      	strh	r3, [r7, #50]	; 0x32
    lv_obj_get_coords(obj, &obj_area);
 8014c7e:	f107 0318 	add.w	r3, r7, #24
 8014c82:	4619      	mov	r1, r3
 8014c84:	6878      	ldr	r0, [r7, #4]
 8014c86:	f7ff f87e 	bl	8013d86 <lv_obj_get_coords>
    obj_area.x1 -= ext_size;
 8014c8a:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8014c8e:	b29a      	uxth	r2, r3
 8014c90:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 8014c92:	1ad3      	subs	r3, r2, r3
 8014c94:	b29b      	uxth	r3, r3
 8014c96:	b21b      	sxth	r3, r3
 8014c98:	833b      	strh	r3, [r7, #24]
    obj_area.y1 -= ext_size;
 8014c9a:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8014c9e:	b29a      	uxth	r2, r3
 8014ca0:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 8014ca2:	1ad3      	subs	r3, r2, r3
 8014ca4:	b29b      	uxth	r3, r3
 8014ca6:	b21b      	sxth	r3, r3
 8014ca8:	837b      	strh	r3, [r7, #26]
    obj_area.x2 += ext_size;
 8014caa:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 8014cae:	b29a      	uxth	r2, r3
 8014cb0:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 8014cb2:	4413      	add	r3, r2
 8014cb4:	b29b      	uxth	r3, r3
 8014cb6:	b21b      	sxth	r3, r3
 8014cb8:	83bb      	strh	r3, [r7, #28]
    obj_area.y2 += ext_size;
 8014cba:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8014cbe:	b29a      	uxth	r2, r3
 8014cc0:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 8014cc2:	4413      	add	r3, r2
 8014cc4:	b29b      	uxth	r3, r3
 8014cc6:	b21b      	sxth	r3, r3
 8014cc8:	83fb      	strh	r3, [r7, #30]
    union_ok = lv_area_intersect(&obj_ext_mask, mask_ori_p, &obj_area);
 8014cca:	f107 0218 	add.w	r2, r7, #24
 8014cce:	f107 0320 	add.w	r3, r7, #32
 8014cd2:	6839      	ldr	r1, [r7, #0]
 8014cd4:	4618      	mov	r0, r3
 8014cd6:	f008 fd9f 	bl	801d818 <lv_area_intersect>
 8014cda:	4603      	mov	r3, r0
 8014cdc:	f887 3031 	strb.w	r3, [r7, #49]	; 0x31

    /*Draw the parent and its children only if they ore on 'mask_parent'*/
    if(union_ok != false) {
 8014ce0:	f897 3031 	ldrb.w	r3, [r7, #49]	; 0x31
 8014ce4:	2b00      	cmp	r3, #0
 8014ce6:	d074      	beq.n	8014dd2 <lv_refr_obj+0x176>

        /* Redraw the object */
        obj->design_cb(obj, &obj_ext_mask, LV_DESIGN_DRAW_MAIN);
 8014ce8:	687b      	ldr	r3, [r7, #4]
 8014cea:	6a1b      	ldr	r3, [r3, #32]
 8014cec:	f107 0120 	add.w	r1, r7, #32
 8014cf0:	2200      	movs	r2, #0
 8014cf2:	6878      	ldr	r0, [r7, #4]
 8014cf4:	4798      	blx	r3
        lv_draw_fill(&obj_ext_mask, &obj_ext_mask, debug_color, LV_OPA_50);
        debug_color.full *= 17;
        debug_color.full += 0xA1;
#endif
        /*Create a new 'obj_mask' without 'ext_size' because the children can't be visible there*/
        lv_obj_get_coords(obj, &obj_area);
 8014cf6:	f107 0318 	add.w	r3, r7, #24
 8014cfa:	4619      	mov	r1, r3
 8014cfc:	6878      	ldr	r0, [r7, #4]
 8014cfe:	f7ff f842 	bl	8013d86 <lv_obj_get_coords>
        union_ok = lv_area_intersect(&obj_mask, mask_ori_p, &obj_area);
 8014d02:	f107 0218 	add.w	r2, r7, #24
 8014d06:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8014d0a:	6839      	ldr	r1, [r7, #0]
 8014d0c:	4618      	mov	r0, r3
 8014d0e:	f008 fd83 	bl	801d818 <lv_area_intersect>
 8014d12:	4603      	mov	r3, r0
 8014d14:	f887 3031 	strb.w	r3, [r7, #49]	; 0x31
        if(union_ok != false) {
 8014d18:	f897 3031 	ldrb.w	r3, [r7, #49]	; 0x31
 8014d1c:	2b00      	cmp	r3, #0
 8014d1e:	d04f      	beq.n	8014dc0 <lv_refr_obj+0x164>
            lv_area_t mask_child; /*Mask from obj and its child*/
            lv_obj_t * child_p;
            lv_area_t child_area;
            LV_LL_READ_BACK(obj->child_ll, child_p)
 8014d20:	687b      	ldr	r3, [r7, #4]
 8014d22:	3304      	adds	r3, #4
 8014d24:	4618      	mov	r0, r3
 8014d26:	f009 f870 	bl	801de0a <lv_ll_get_tail>
 8014d2a:	6378      	str	r0, [r7, #52]	; 0x34
 8014d2c:	e045      	b.n	8014dba <lv_refr_obj+0x15e>
            {
                lv_obj_get_coords(child_p, &child_area);
 8014d2e:	f107 0308 	add.w	r3, r7, #8
 8014d32:	4619      	mov	r1, r3
 8014d34:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8014d36:	f7ff f826 	bl	8013d86 <lv_obj_get_coords>
                ext_size = child_p->ext_draw_pad;
 8014d3a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8014d3c:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 8014d3e:	867b      	strh	r3, [r7, #50]	; 0x32
                child_area.x1 -= ext_size;
 8014d40:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 8014d44:	b29a      	uxth	r2, r3
 8014d46:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 8014d48:	1ad3      	subs	r3, r2, r3
 8014d4a:	b29b      	uxth	r3, r3
 8014d4c:	b21b      	sxth	r3, r3
 8014d4e:	813b      	strh	r3, [r7, #8]
                child_area.y1 -= ext_size;
 8014d50:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8014d54:	b29a      	uxth	r2, r3
 8014d56:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 8014d58:	1ad3      	subs	r3, r2, r3
 8014d5a:	b29b      	uxth	r3, r3
 8014d5c:	b21b      	sxth	r3, r3
 8014d5e:	817b      	strh	r3, [r7, #10]
                child_area.x2 += ext_size;
 8014d60:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8014d64:	b29a      	uxth	r2, r3
 8014d66:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 8014d68:	4413      	add	r3, r2
 8014d6a:	b29b      	uxth	r3, r3
 8014d6c:	b21b      	sxth	r3, r3
 8014d6e:	81bb      	strh	r3, [r7, #12]
                child_area.y2 += ext_size;
 8014d70:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8014d74:	b29a      	uxth	r2, r3
 8014d76:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 8014d78:	4413      	add	r3, r2
 8014d7a:	b29b      	uxth	r3, r3
 8014d7c:	b21b      	sxth	r3, r3
 8014d7e:	81fb      	strh	r3, [r7, #14]
                /* Get the union (common parts) of original mask (from obj)
                 * and its child */
                union_ok = lv_area_intersect(&mask_child, &obj_mask, &child_area);
 8014d80:	f107 0208 	add.w	r2, r7, #8
 8014d84:	f107 0128 	add.w	r1, r7, #40	; 0x28
 8014d88:	f107 0310 	add.w	r3, r7, #16
 8014d8c:	4618      	mov	r0, r3
 8014d8e:	f008 fd43 	bl	801d818 <lv_area_intersect>
 8014d92:	4603      	mov	r3, r0
 8014d94:	f887 3031 	strb.w	r3, [r7, #49]	; 0x31

                /*If the parent and the child has common area then refresh the child */
                if(union_ok) {
 8014d98:	f897 3031 	ldrb.w	r3, [r7, #49]	; 0x31
 8014d9c:	2b00      	cmp	r3, #0
 8014d9e:	d005      	beq.n	8014dac <lv_refr_obj+0x150>
                    /*Refresh the next children*/
                    lv_refr_obj(child_p, &mask_child);
 8014da0:	f107 0310 	add.w	r3, r7, #16
 8014da4:	4619      	mov	r1, r3
 8014da6:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8014da8:	f7ff ff58 	bl	8014c5c <lv_refr_obj>
            LV_LL_READ_BACK(obj->child_ll, child_p)
 8014dac:	687b      	ldr	r3, [r7, #4]
 8014dae:	3304      	adds	r3, #4
 8014db0:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8014db2:	4618      	mov	r0, r3
 8014db4:	f009 f856 	bl	801de64 <lv_ll_get_prev>
 8014db8:	6378      	str	r0, [r7, #52]	; 0x34
 8014dba:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8014dbc:	2b00      	cmp	r3, #0
 8014dbe:	d1b6      	bne.n	8014d2e <lv_refr_obj+0xd2>
                }
            }
        }

        /* If all the children are redrawn make 'post draw' design */
        obj->design_cb(obj, &obj_ext_mask, LV_DESIGN_DRAW_POST);
 8014dc0:	687b      	ldr	r3, [r7, #4]
 8014dc2:	6a1b      	ldr	r3, [r3, #32]
 8014dc4:	f107 0120 	add.w	r1, r7, #32
 8014dc8:	2201      	movs	r2, #1
 8014dca:	6878      	ldr	r0, [r7, #4]
 8014dcc:	4798      	blx	r3
 8014dce:	e000      	b.n	8014dd2 <lv_refr_obj+0x176>
    if(obj->hidden != 0) return;
 8014dd0:	bf00      	nop
    }
}
 8014dd2:	3738      	adds	r7, #56	; 0x38
 8014dd4:	46bd      	mov	sp, r7
 8014dd6:	bd80      	pop	{r7, pc}

08014dd8 <lv_refr_vdb_flush>:

/**
 * Flush the content of the VDB
 */
static void lv_refr_vdb_flush(void)
{
 8014dd8:	b580      	push	{r7, lr}
 8014dda:	b082      	sub	sp, #8
 8014ddc:	af00      	add	r7, sp, #0
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
 8014dde:	4b23      	ldr	r3, [pc, #140]	; (8014e6c <lv_refr_vdb_flush+0x94>)
 8014de0:	681b      	ldr	r3, [r3, #0]
 8014de2:	4618      	mov	r0, r3
 8014de4:	f008 fa05 	bl	801d1f2 <lv_disp_get_buf>
 8014de8:	6078      	str	r0, [r7, #4]

    /*In double buffered mode wait until the other buffer is flushed before flushing the current
     * one*/
    if(lv_disp_is_double_buf(disp_refr)) {
 8014dea:	4b20      	ldr	r3, [pc, #128]	; (8014e6c <lv_refr_vdb_flush+0x94>)
 8014dec:	681b      	ldr	r3, [r3, #0]
 8014dee:	4618      	mov	r0, r3
 8014df0:	f008 fa0b 	bl	801d20a <lv_disp_is_double_buf>
 8014df4:	4603      	mov	r3, r0
 8014df6:	2b00      	cmp	r3, #0
 8014df8:	d007      	beq.n	8014e0a <lv_refr_vdb_flush+0x32>
        while(vdb->flushing)
 8014dfa:	bf00      	nop
 8014dfc:	687b      	ldr	r3, [r7, #4]
 8014dfe:	699b      	ldr	r3, [r3, #24]
 8014e00:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8014e04:	b2db      	uxtb	r3, r3
 8014e06:	2b00      	cmp	r3, #0
 8014e08:	d1f8      	bne.n	8014dfc <lv_refr_vdb_flush+0x24>
            ;
    }

    vdb->flushing = 1;
 8014e0a:	687a      	ldr	r2, [r7, #4]
 8014e0c:	7e13      	ldrb	r3, [r2, #24]
 8014e0e:	f043 0301 	orr.w	r3, r3, #1
 8014e12:	7613      	strb	r3, [r2, #24]

    /*Flush the rendered content to the display*/
    lv_disp_t * disp = lv_refr_get_disp_refreshing();
 8014e14:	f7ff fb3e 	bl	8014494 <lv_refr_get_disp_refreshing>
 8014e18:	6038      	str	r0, [r7, #0]
    if(disp->driver.flush_cb) disp->driver.flush_cb(&disp->driver, &vdb->area, vdb->buf_act);
 8014e1a:	683b      	ldr	r3, [r7, #0]
 8014e1c:	68db      	ldr	r3, [r3, #12]
 8014e1e:	2b00      	cmp	r3, #0
 8014e20:	d008      	beq.n	8014e34 <lv_refr_vdb_flush+0x5c>
 8014e22:	683b      	ldr	r3, [r7, #0]
 8014e24:	68db      	ldr	r3, [r3, #12]
 8014e26:	6838      	ldr	r0, [r7, #0]
 8014e28:	687a      	ldr	r2, [r7, #4]
 8014e2a:	f102 0110 	add.w	r1, r2, #16
 8014e2e:	687a      	ldr	r2, [r7, #4]
 8014e30:	6892      	ldr	r2, [r2, #8]
 8014e32:	4798      	blx	r3

    if(vdb->buf1 && vdb->buf2) {
 8014e34:	687b      	ldr	r3, [r7, #4]
 8014e36:	681b      	ldr	r3, [r3, #0]
 8014e38:	2b00      	cmp	r3, #0
 8014e3a:	d012      	beq.n	8014e62 <lv_refr_vdb_flush+0x8a>
 8014e3c:	687b      	ldr	r3, [r7, #4]
 8014e3e:	685b      	ldr	r3, [r3, #4]
 8014e40:	2b00      	cmp	r3, #0
 8014e42:	d00e      	beq.n	8014e62 <lv_refr_vdb_flush+0x8a>
        if(vdb->buf_act == vdb->buf1)
 8014e44:	687b      	ldr	r3, [r7, #4]
 8014e46:	689a      	ldr	r2, [r3, #8]
 8014e48:	687b      	ldr	r3, [r7, #4]
 8014e4a:	681b      	ldr	r3, [r3, #0]
 8014e4c:	429a      	cmp	r2, r3
 8014e4e:	d104      	bne.n	8014e5a <lv_refr_vdb_flush+0x82>
            vdb->buf_act = vdb->buf2;
 8014e50:	687b      	ldr	r3, [r7, #4]
 8014e52:	685a      	ldr	r2, [r3, #4]
 8014e54:	687b      	ldr	r3, [r7, #4]
 8014e56:	609a      	str	r2, [r3, #8]
        else
            vdb->buf_act = vdb->buf1;
    }
}
 8014e58:	e003      	b.n	8014e62 <lv_refr_vdb_flush+0x8a>
            vdb->buf_act = vdb->buf1;
 8014e5a:	687b      	ldr	r3, [r7, #4]
 8014e5c:	681a      	ldr	r2, [r3, #0]
 8014e5e:	687b      	ldr	r3, [r7, #4]
 8014e60:	609a      	str	r2, [r3, #8]
}
 8014e62:	bf00      	nop
 8014e64:	3708      	adds	r7, #8
 8014e66:	46bd      	mov	sp, r7
 8014e68:	bd80      	pop	{r7, pc}
 8014e6a:	bf00      	nop
 8014e6c:	240623c8 	.word	0x240623c8

08014e70 <lv_color_make>:
}
#elif LV_COLOR_DEPTH == 16
#if LV_COLOR_16_SWAP == 0
#define LV_COLOR_MAKE(r8, g8, b8) ((lv_color_t){{b8 >> 3, g8 >> 2, r8 >> 3}})
static inline lv_color_t lv_color_make(uint8_t r8, uint8_t g8, uint8_t b8)
{
 8014e70:	b480      	push	{r7}
 8014e72:	b085      	sub	sp, #20
 8014e74:	af00      	add	r7, sp, #0
 8014e76:	4603      	mov	r3, r0
 8014e78:	71fb      	strb	r3, [r7, #7]
 8014e7a:	460b      	mov	r3, r1
 8014e7c:	71bb      	strb	r3, [r7, #6]
 8014e7e:	4613      	mov	r3, r2
 8014e80:	717b      	strb	r3, [r7, #5]
    lv_color_t color;
    color.ch.blue  = (uint16_t)(b8 >> 3);
 8014e82:	797b      	ldrb	r3, [r7, #5]
 8014e84:	08db      	lsrs	r3, r3, #3
 8014e86:	b2db      	uxtb	r3, r3
 8014e88:	f003 031f 	and.w	r3, r3, #31
 8014e8c:	b2da      	uxtb	r2, r3
 8014e8e:	7b3b      	ldrb	r3, [r7, #12]
 8014e90:	f362 0304 	bfi	r3, r2, #0, #5
 8014e94:	733b      	strb	r3, [r7, #12]
    color.ch.green = (uint16_t)(g8 >> 2);
 8014e96:	79bb      	ldrb	r3, [r7, #6]
 8014e98:	089b      	lsrs	r3, r3, #2
 8014e9a:	b2db      	uxtb	r3, r3
 8014e9c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8014ea0:	b2da      	uxtb	r2, r3
 8014ea2:	89bb      	ldrh	r3, [r7, #12]
 8014ea4:	f362 134a 	bfi	r3, r2, #5, #6
 8014ea8:	81bb      	strh	r3, [r7, #12]
    color.ch.red   = (uint16_t)(r8 >> 3);
 8014eaa:	79fb      	ldrb	r3, [r7, #7]
 8014eac:	08db      	lsrs	r3, r3, #3
 8014eae:	b2db      	uxtb	r3, r3
 8014eb0:	f003 031f 	and.w	r3, r3, #31
 8014eb4:	b2da      	uxtb	r2, r3
 8014eb6:	7b7b      	ldrb	r3, [r7, #13]
 8014eb8:	f362 03c7 	bfi	r3, r2, #3, #5
 8014ebc:	737b      	strb	r3, [r7, #13]
    return color;
 8014ebe:	89bb      	ldrh	r3, [r7, #12]
}
 8014ec0:	4618      	mov	r0, r3
 8014ec2:	3714      	adds	r7, #20
 8014ec4:	46bd      	mov	sp, r7
 8014ec6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014eca:	4770      	bx	lr

08014ecc <lv_style_init>:

/**
 *  Init the basic styles
 */
void lv_style_init(void)
{
 8014ecc:	b598      	push	{r3, r4, r7, lr}
 8014ece:	af00      	add	r7, sp, #0
    /* Not White/Black/Gray colors are created by HSV model with
     * HUE = 210*/

    /*Screen style*/
    lv_style_scr.glass               = 0;
 8014ed0:	4aae      	ldr	r2, [pc, #696]	; (801518c <lv_style_init+0x2c0>)
 8014ed2:	7813      	ldrb	r3, [r2, #0]
 8014ed4:	f36f 0300 	bfc	r3, #0, #1
 8014ed8:	7013      	strb	r3, [r2, #0]
    lv_style_scr.body.opa            = LV_OPA_COVER;
 8014eda:	4bac      	ldr	r3, [pc, #688]	; (801518c <lv_style_init+0x2c0>)
 8014edc:	22ff      	movs	r2, #255	; 0xff
 8014ede:	721a      	strb	r2, [r3, #8]
    lv_style_scr.body.main_color     = LV_COLOR_WHITE;
 8014ee0:	4aaa      	ldr	r2, [pc, #680]	; (801518c <lv_style_init+0x2c0>)
 8014ee2:	4bab      	ldr	r3, [pc, #684]	; (8015190 <lv_style_init+0x2c4>)
 8014ee4:	881b      	ldrh	r3, [r3, #0]
 8014ee6:	8053      	strh	r3, [r2, #2]
    lv_style_scr.body.grad_color     = LV_COLOR_WHITE;
 8014ee8:	4aa8      	ldr	r2, [pc, #672]	; (801518c <lv_style_init+0x2c0>)
 8014eea:	4ba9      	ldr	r3, [pc, #676]	; (8015190 <lv_style_init+0x2c4>)
 8014eec:	881b      	ldrh	r3, [r3, #0]
 8014eee:	8093      	strh	r3, [r2, #4]
    lv_style_scr.body.radius         = 0;
 8014ef0:	4ba6      	ldr	r3, [pc, #664]	; (801518c <lv_style_init+0x2c0>)
 8014ef2:	2200      	movs	r2, #0
 8014ef4:	80da      	strh	r2, [r3, #6]
    lv_style_scr.body.padding.left   = 0;
 8014ef6:	4ba5      	ldr	r3, [pc, #660]	; (801518c <lv_style_init+0x2c0>)
 8014ef8:	2200      	movs	r2, #0
 8014efa:	835a      	strh	r2, [r3, #26]
    lv_style_scr.body.padding.right  = 0;
 8014efc:	4ba3      	ldr	r3, [pc, #652]	; (801518c <lv_style_init+0x2c0>)
 8014efe:	2200      	movs	r2, #0
 8014f00:	839a      	strh	r2, [r3, #28]
    lv_style_scr.body.padding.top    = 0;
 8014f02:	4ba2      	ldr	r3, [pc, #648]	; (801518c <lv_style_init+0x2c0>)
 8014f04:	2200      	movs	r2, #0
 8014f06:	82da      	strh	r2, [r3, #22]
    lv_style_scr.body.padding.bottom = 0;
 8014f08:	4ba0      	ldr	r3, [pc, #640]	; (801518c <lv_style_init+0x2c0>)
 8014f0a:	2200      	movs	r2, #0
 8014f0c:	831a      	strh	r2, [r3, #24]
    lv_style_scr.body.padding.inner  = LV_DPI / 20;
 8014f0e:	4b9f      	ldr	r3, [pc, #636]	; (801518c <lv_style_init+0x2c0>)
 8014f10:	2204      	movs	r2, #4
 8014f12:	83da      	strh	r2, [r3, #30]

    lv_style_scr.body.border.color = LV_COLOR_BLACK;
 8014f14:	4a9d      	ldr	r2, [pc, #628]	; (801518c <lv_style_init+0x2c0>)
 8014f16:	7a93      	ldrb	r3, [r2, #10]
 8014f18:	f36f 0304 	bfc	r3, #0, #5
 8014f1c:	7293      	strb	r3, [r2, #10]
 8014f1e:	4a9b      	ldr	r2, [pc, #620]	; (801518c <lv_style_init+0x2c0>)
 8014f20:	8953      	ldrh	r3, [r2, #10]
 8014f22:	f36f 134a 	bfc	r3, #5, #6
 8014f26:	8153      	strh	r3, [r2, #10]
 8014f28:	4a98      	ldr	r2, [pc, #608]	; (801518c <lv_style_init+0x2c0>)
 8014f2a:	7ad3      	ldrb	r3, [r2, #11]
 8014f2c:	f36f 03c7 	bfc	r3, #3, #5
 8014f30:	72d3      	strb	r3, [r2, #11]
    lv_style_scr.body.border.opa   = LV_OPA_COVER;
 8014f32:	4b96      	ldr	r3, [pc, #600]	; (801518c <lv_style_init+0x2c0>)
 8014f34:	22ff      	movs	r2, #255	; 0xff
 8014f36:	73da      	strb	r2, [r3, #15]
    lv_style_scr.body.border.width = 0;
 8014f38:	4b94      	ldr	r3, [pc, #592]	; (801518c <lv_style_init+0x2c0>)
 8014f3a:	2200      	movs	r2, #0
 8014f3c:	819a      	strh	r2, [r3, #12]
    lv_style_scr.body.border.part  = LV_BORDER_FULL;
 8014f3e:	4b93      	ldr	r3, [pc, #588]	; (801518c <lv_style_init+0x2c0>)
 8014f40:	220f      	movs	r2, #15
 8014f42:	739a      	strb	r2, [r3, #14]

    lv_style_scr.body.shadow.color = LV_COLOR_GRAY;
 8014f44:	4a91      	ldr	r2, [pc, #580]	; (801518c <lv_style_init+0x2c0>)
 8014f46:	4b93      	ldr	r3, [pc, #588]	; (8015194 <lv_style_init+0x2c8>)
 8014f48:	881b      	ldrh	r3, [r3, #0]
 8014f4a:	8213      	strh	r3, [r2, #16]
    lv_style_scr.body.shadow.type  = LV_SHADOW_FULL;
 8014f4c:	4b8f      	ldr	r3, [pc, #572]	; (801518c <lv_style_init+0x2c0>)
 8014f4e:	2201      	movs	r2, #1
 8014f50:	751a      	strb	r2, [r3, #20]
    lv_style_scr.body.shadow.width = 0;
 8014f52:	4b8e      	ldr	r3, [pc, #568]	; (801518c <lv_style_init+0x2c0>)
 8014f54:	2200      	movs	r2, #0
 8014f56:	825a      	strh	r2, [r3, #18]

    lv_style_scr.text.opa          = LV_OPA_COVER;
 8014f58:	4b8c      	ldr	r3, [pc, #560]	; (801518c <lv_style_init+0x2c0>)
 8014f5a:	22ff      	movs	r2, #255	; 0xff
 8014f5c:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
    lv_style_scr.text.color        = lv_color_make(0x30, 0x30, 0x30);
 8014f60:	4c8a      	ldr	r4, [pc, #552]	; (801518c <lv_style_init+0x2c0>)
 8014f62:	2230      	movs	r2, #48	; 0x30
 8014f64:	2130      	movs	r1, #48	; 0x30
 8014f66:	2030      	movs	r0, #48	; 0x30
 8014f68:	f7ff ff82 	bl	8014e70 <lv_color_make>
 8014f6c:	8420      	strh	r0, [r4, #32]
    lv_style_scr.text.sel_color    = lv_color_make(0x55, 0x96, 0xd8);
 8014f6e:	4c87      	ldr	r4, [pc, #540]	; (801518c <lv_style_init+0x2c0>)
 8014f70:	22d8      	movs	r2, #216	; 0xd8
 8014f72:	2196      	movs	r1, #150	; 0x96
 8014f74:	2055      	movs	r0, #85	; 0x55
 8014f76:	f7ff ff7b 	bl	8014e70 <lv_color_make>
 8014f7a:	8460      	strh	r0, [r4, #34]	; 0x22
    lv_style_scr.text.font         = LV_FONT_DEFAULT;
 8014f7c:	4b83      	ldr	r3, [pc, #524]	; (801518c <lv_style_init+0x2c0>)
 8014f7e:	4a86      	ldr	r2, [pc, #536]	; (8015198 <lv_style_init+0x2cc>)
 8014f80:	625a      	str	r2, [r3, #36]	; 0x24
    lv_style_scr.text.letter_space = 0;
 8014f82:	4b82      	ldr	r3, [pc, #520]	; (801518c <lv_style_init+0x2c0>)
 8014f84:	2200      	movs	r2, #0
 8014f86:	851a      	strh	r2, [r3, #40]	; 0x28
    lv_style_scr.text.line_space   = 2;
 8014f88:	4b80      	ldr	r3, [pc, #512]	; (801518c <lv_style_init+0x2c0>)
 8014f8a:	2202      	movs	r2, #2
 8014f8c:	855a      	strh	r2, [r3, #42]	; 0x2a

    lv_style_scr.image.opa     = LV_OPA_COVER;
 8014f8e:	4b7f      	ldr	r3, [pc, #508]	; (801518c <lv_style_init+0x2c0>)
 8014f90:	22ff      	movs	r2, #255	; 0xff
 8014f92:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33
    lv_style_scr.image.color   = lv_color_make(0x20, 0x20, 0x20);
 8014f96:	4c7d      	ldr	r4, [pc, #500]	; (801518c <lv_style_init+0x2c0>)
 8014f98:	2220      	movs	r2, #32
 8014f9a:	2120      	movs	r1, #32
 8014f9c:	2020      	movs	r0, #32
 8014f9e:	f7ff ff67 	bl	8014e70 <lv_color_make>
 8014fa2:	8620      	strh	r0, [r4, #48]	; 0x30
    lv_style_scr.image.intense = LV_OPA_TRANSP;
 8014fa4:	4b79      	ldr	r3, [pc, #484]	; (801518c <lv_style_init+0x2c0>)
 8014fa6:	2200      	movs	r2, #0
 8014fa8:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32

    lv_style_scr.line.opa     = LV_OPA_COVER;
 8014fac:	4b77      	ldr	r3, [pc, #476]	; (801518c <lv_style_init+0x2c0>)
 8014fae:	22ff      	movs	r2, #255	; 0xff
 8014fb0:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
    lv_style_scr.line.color   = lv_color_make(0x20, 0x20, 0x20);
 8014fb4:	4c75      	ldr	r4, [pc, #468]	; (801518c <lv_style_init+0x2c0>)
 8014fb6:	2220      	movs	r2, #32
 8014fb8:	2120      	movs	r1, #32
 8014fba:	2020      	movs	r0, #32
 8014fbc:	f7ff ff58 	bl	8014e70 <lv_color_make>
 8014fc0:	86a0      	strh	r0, [r4, #52]	; 0x34
    lv_style_scr.line.width   = 2;
 8014fc2:	4b72      	ldr	r3, [pc, #456]	; (801518c <lv_style_init+0x2c0>)
 8014fc4:	2202      	movs	r2, #2
 8014fc6:	86da      	strh	r2, [r3, #54]	; 0x36
    lv_style_scr.line.rounded = 0;
 8014fc8:	4a70      	ldr	r2, [pc, #448]	; (801518c <lv_style_init+0x2c0>)
 8014fca:	f892 3039 	ldrb.w	r3, [r2, #57]	; 0x39
 8014fce:	f36f 0300 	bfc	r3, #0, #1
 8014fd2:	f882 3039 	strb.w	r3, [r2, #57]	; 0x39

    /*Plain style (by default near the same as the screen style)*/
    lv_style_copy(&lv_style_plain, &lv_style_scr);
 8014fd6:	496d      	ldr	r1, [pc, #436]	; (801518c <lv_style_init+0x2c0>)
 8014fd8:	4870      	ldr	r0, [pc, #448]	; (801519c <lv_style_init+0x2d0>)
 8014fda:	f000 f9cf 	bl	801537c <lv_style_copy>
    lv_style_plain.body.padding.left   = LV_DPI / 20;
 8014fde:	4b6f      	ldr	r3, [pc, #444]	; (801519c <lv_style_init+0x2d0>)
 8014fe0:	2204      	movs	r2, #4
 8014fe2:	835a      	strh	r2, [r3, #26]
    lv_style_plain.body.padding.right  = LV_DPI / 20;
 8014fe4:	4b6d      	ldr	r3, [pc, #436]	; (801519c <lv_style_init+0x2d0>)
 8014fe6:	2204      	movs	r2, #4
 8014fe8:	839a      	strh	r2, [r3, #28]
    lv_style_plain.body.padding.top    = LV_DPI / 20;
 8014fea:	4b6c      	ldr	r3, [pc, #432]	; (801519c <lv_style_init+0x2d0>)
 8014fec:	2204      	movs	r2, #4
 8014fee:	82da      	strh	r2, [r3, #22]
    lv_style_plain.body.padding.bottom = LV_DPI / 20;
 8014ff0:	4b6a      	ldr	r3, [pc, #424]	; (801519c <lv_style_init+0x2d0>)
 8014ff2:	2204      	movs	r2, #4
 8014ff4:	831a      	strh	r2, [r3, #24]

    /*Plain color style*/
    lv_style_copy(&lv_style_plain_color, &lv_style_plain);
 8014ff6:	4969      	ldr	r1, [pc, #420]	; (801519c <lv_style_init+0x2d0>)
 8014ff8:	4869      	ldr	r0, [pc, #420]	; (80151a0 <lv_style_init+0x2d4>)
 8014ffa:	f000 f9bf 	bl	801537c <lv_style_copy>
    lv_style_plain_color.text.color      = lv_color_make(0xf0, 0xf0, 0xf0);
 8014ffe:	4c68      	ldr	r4, [pc, #416]	; (80151a0 <lv_style_init+0x2d4>)
 8015000:	22f0      	movs	r2, #240	; 0xf0
 8015002:	21f0      	movs	r1, #240	; 0xf0
 8015004:	20f0      	movs	r0, #240	; 0xf0
 8015006:	f7ff ff33 	bl	8014e70 <lv_color_make>
 801500a:	8420      	strh	r0, [r4, #32]
    lv_style_plain_color.image.color     = lv_color_make(0xf0, 0xf0, 0xf0);
 801500c:	4c64      	ldr	r4, [pc, #400]	; (80151a0 <lv_style_init+0x2d4>)
 801500e:	22f0      	movs	r2, #240	; 0xf0
 8015010:	21f0      	movs	r1, #240	; 0xf0
 8015012:	20f0      	movs	r0, #240	; 0xf0
 8015014:	f7ff ff2c 	bl	8014e70 <lv_color_make>
 8015018:	8620      	strh	r0, [r4, #48]	; 0x30
    lv_style_plain_color.line.color      = lv_color_make(0xf0, 0xf0, 0xf0);
 801501a:	4c61      	ldr	r4, [pc, #388]	; (80151a0 <lv_style_init+0x2d4>)
 801501c:	22f0      	movs	r2, #240	; 0xf0
 801501e:	21f0      	movs	r1, #240	; 0xf0
 8015020:	20f0      	movs	r0, #240	; 0xf0
 8015022:	f7ff ff25 	bl	8014e70 <lv_color_make>
 8015026:	86a0      	strh	r0, [r4, #52]	; 0x34
    lv_style_plain_color.body.main_color = lv_color_make(0x55, 0x96, 0xd8);
 8015028:	4c5d      	ldr	r4, [pc, #372]	; (80151a0 <lv_style_init+0x2d4>)
 801502a:	22d8      	movs	r2, #216	; 0xd8
 801502c:	2196      	movs	r1, #150	; 0x96
 801502e:	2055      	movs	r0, #85	; 0x55
 8015030:	f7ff ff1e 	bl	8014e70 <lv_color_make>
 8015034:	8060      	strh	r0, [r4, #2]
    lv_style_plain_color.body.grad_color = lv_style_plain_color.body.main_color;
 8015036:	4a5a      	ldr	r2, [pc, #360]	; (80151a0 <lv_style_init+0x2d4>)
 8015038:	4b59      	ldr	r3, [pc, #356]	; (80151a0 <lv_style_init+0x2d4>)
 801503a:	885b      	ldrh	r3, [r3, #2]
 801503c:	8093      	strh	r3, [r2, #4]

    /*Pretty style */
    lv_style_copy(&lv_style_pretty, &lv_style_plain);
 801503e:	4957      	ldr	r1, [pc, #348]	; (801519c <lv_style_init+0x2d0>)
 8015040:	4858      	ldr	r0, [pc, #352]	; (80151a4 <lv_style_init+0x2d8>)
 8015042:	f000 f99b 	bl	801537c <lv_style_copy>
    lv_style_pretty.text.color        = lv_color_make(0x20, 0x20, 0x20);
 8015046:	4c57      	ldr	r4, [pc, #348]	; (80151a4 <lv_style_init+0x2d8>)
 8015048:	2220      	movs	r2, #32
 801504a:	2120      	movs	r1, #32
 801504c:	2020      	movs	r0, #32
 801504e:	f7ff ff0f 	bl	8014e70 <lv_color_make>
 8015052:	8420      	strh	r0, [r4, #32]
    lv_style_pretty.image.color       = lv_color_make(0x20, 0x20, 0x20);
 8015054:	4c53      	ldr	r4, [pc, #332]	; (80151a4 <lv_style_init+0x2d8>)
 8015056:	2220      	movs	r2, #32
 8015058:	2120      	movs	r1, #32
 801505a:	2020      	movs	r0, #32
 801505c:	f7ff ff08 	bl	8014e70 <lv_color_make>
 8015060:	8620      	strh	r0, [r4, #48]	; 0x30
    lv_style_pretty.line.color        = lv_color_make(0x20, 0x20, 0x20);
 8015062:	4c50      	ldr	r4, [pc, #320]	; (80151a4 <lv_style_init+0x2d8>)
 8015064:	2220      	movs	r2, #32
 8015066:	2120      	movs	r1, #32
 8015068:	2020      	movs	r0, #32
 801506a:	f7ff ff01 	bl	8014e70 <lv_color_make>
 801506e:	86a0      	strh	r0, [r4, #52]	; 0x34
    lv_style_pretty.body.main_color   = LV_COLOR_WHITE;
 8015070:	4a4c      	ldr	r2, [pc, #304]	; (80151a4 <lv_style_init+0x2d8>)
 8015072:	4b47      	ldr	r3, [pc, #284]	; (8015190 <lv_style_init+0x2c4>)
 8015074:	881b      	ldrh	r3, [r3, #0]
 8015076:	8053      	strh	r3, [r2, #2]
    lv_style_pretty.body.grad_color   = LV_COLOR_SILVER;
 8015078:	4a4a      	ldr	r2, [pc, #296]	; (80151a4 <lv_style_init+0x2d8>)
 801507a:	4b4b      	ldr	r3, [pc, #300]	; (80151a8 <lv_style_init+0x2dc>)
 801507c:	881b      	ldrh	r3, [r3, #0]
 801507e:	8093      	strh	r3, [r2, #4]
    lv_style_pretty.body.radius       = LV_DPI / 15;
 8015080:	4b48      	ldr	r3, [pc, #288]	; (80151a4 <lv_style_init+0x2d8>)
 8015082:	2205      	movs	r2, #5
 8015084:	80da      	strh	r2, [r3, #6]
    lv_style_pretty.body.border.color = lv_color_make(0x40, 0x40, 0x40);
 8015086:	4c47      	ldr	r4, [pc, #284]	; (80151a4 <lv_style_init+0x2d8>)
 8015088:	2240      	movs	r2, #64	; 0x40
 801508a:	2140      	movs	r1, #64	; 0x40
 801508c:	2040      	movs	r0, #64	; 0x40
 801508e:	f7ff feef 	bl	8014e70 <lv_color_make>
 8015092:	8160      	strh	r0, [r4, #10]
    lv_style_pretty.body.border.width = LV_DPI / 50 >= 1 ? LV_DPI / 50 : 1;
 8015094:	4b43      	ldr	r3, [pc, #268]	; (80151a4 <lv_style_init+0x2d8>)
 8015096:	2201      	movs	r2, #1
 8015098:	819a      	strh	r2, [r3, #12]
    lv_style_pretty.body.border.opa   = LV_OPA_30;
 801509a:	4b42      	ldr	r3, [pc, #264]	; (80151a4 <lv_style_init+0x2d8>)
 801509c:	224c      	movs	r2, #76	; 0x4c
 801509e:	73da      	strb	r2, [r3, #15]

    /*Pretty color style*/
    lv_style_copy(&lv_style_pretty_color, &lv_style_pretty);
 80150a0:	4940      	ldr	r1, [pc, #256]	; (80151a4 <lv_style_init+0x2d8>)
 80150a2:	4842      	ldr	r0, [pc, #264]	; (80151ac <lv_style_init+0x2e0>)
 80150a4:	f000 f96a 	bl	801537c <lv_style_copy>
    lv_style_pretty_color.text.color        = lv_color_make(0xe0, 0xe0, 0xe0);
 80150a8:	4c40      	ldr	r4, [pc, #256]	; (80151ac <lv_style_init+0x2e0>)
 80150aa:	22e0      	movs	r2, #224	; 0xe0
 80150ac:	21e0      	movs	r1, #224	; 0xe0
 80150ae:	20e0      	movs	r0, #224	; 0xe0
 80150b0:	f7ff fede 	bl	8014e70 <lv_color_make>
 80150b4:	8420      	strh	r0, [r4, #32]
    lv_style_pretty_color.image.color       = lv_color_make(0xe0, 0xe0, 0xe0);
 80150b6:	4c3d      	ldr	r4, [pc, #244]	; (80151ac <lv_style_init+0x2e0>)
 80150b8:	22e0      	movs	r2, #224	; 0xe0
 80150ba:	21e0      	movs	r1, #224	; 0xe0
 80150bc:	20e0      	movs	r0, #224	; 0xe0
 80150be:	f7ff fed7 	bl	8014e70 <lv_color_make>
 80150c2:	8620      	strh	r0, [r4, #48]	; 0x30
    lv_style_pretty_color.line.color        = lv_color_make(0xc0, 0xc0, 0xc0);
 80150c4:	4c39      	ldr	r4, [pc, #228]	; (80151ac <lv_style_init+0x2e0>)
 80150c6:	22c0      	movs	r2, #192	; 0xc0
 80150c8:	21c0      	movs	r1, #192	; 0xc0
 80150ca:	20c0      	movs	r0, #192	; 0xc0
 80150cc:	f7ff fed0 	bl	8014e70 <lv_color_make>
 80150d0:	86a0      	strh	r0, [r4, #52]	; 0x34
    lv_style_pretty_color.body.main_color   = lv_color_make(0x6b, 0x9a, 0xc7);
 80150d2:	4c36      	ldr	r4, [pc, #216]	; (80151ac <lv_style_init+0x2e0>)
 80150d4:	22c7      	movs	r2, #199	; 0xc7
 80150d6:	219a      	movs	r1, #154	; 0x9a
 80150d8:	206b      	movs	r0, #107	; 0x6b
 80150da:	f7ff fec9 	bl	8014e70 <lv_color_make>
 80150de:	8060      	strh	r0, [r4, #2]
    lv_style_pretty_color.body.grad_color   = lv_color_make(0x2b, 0x59, 0x8b);
 80150e0:	4c32      	ldr	r4, [pc, #200]	; (80151ac <lv_style_init+0x2e0>)
 80150e2:	228b      	movs	r2, #139	; 0x8b
 80150e4:	2159      	movs	r1, #89	; 0x59
 80150e6:	202b      	movs	r0, #43	; 0x2b
 80150e8:	f7ff fec2 	bl	8014e70 <lv_color_make>
 80150ec:	80a0      	strh	r0, [r4, #4]
    lv_style_pretty_color.body.border.color = lv_color_make(0x15, 0x2c, 0x42);
 80150ee:	4c2f      	ldr	r4, [pc, #188]	; (80151ac <lv_style_init+0x2e0>)
 80150f0:	2242      	movs	r2, #66	; 0x42
 80150f2:	212c      	movs	r1, #44	; 0x2c
 80150f4:	2015      	movs	r0, #21
 80150f6:	f7ff febb 	bl	8014e70 <lv_color_make>
 80150fa:	8160      	strh	r0, [r4, #10]

    /*Transparent style*/
    lv_style_copy(&lv_style_transp, &lv_style_plain);
 80150fc:	4927      	ldr	r1, [pc, #156]	; (801519c <lv_style_init+0x2d0>)
 80150fe:	482c      	ldr	r0, [pc, #176]	; (80151b0 <lv_style_init+0x2e4>)
 8015100:	f000 f93c 	bl	801537c <lv_style_copy>
    lv_style_transp.glass             = 1;
 8015104:	4a2a      	ldr	r2, [pc, #168]	; (80151b0 <lv_style_init+0x2e4>)
 8015106:	7813      	ldrb	r3, [r2, #0]
 8015108:	f043 0301 	orr.w	r3, r3, #1
 801510c:	7013      	strb	r3, [r2, #0]
    lv_style_transp.body.border.width = 0;
 801510e:	4b28      	ldr	r3, [pc, #160]	; (80151b0 <lv_style_init+0x2e4>)
 8015110:	2200      	movs	r2, #0
 8015112:	819a      	strh	r2, [r3, #12]
    lv_style_transp.body.opa          = LV_OPA_TRANSP;
 8015114:	4b26      	ldr	r3, [pc, #152]	; (80151b0 <lv_style_init+0x2e4>)
 8015116:	2200      	movs	r2, #0
 8015118:	721a      	strb	r2, [r3, #8]

    /*Transparent fitting size*/
    lv_style_copy(&lv_style_transp_fit, &lv_style_transp);
 801511a:	4925      	ldr	r1, [pc, #148]	; (80151b0 <lv_style_init+0x2e4>)
 801511c:	4825      	ldr	r0, [pc, #148]	; (80151b4 <lv_style_init+0x2e8>)
 801511e:	f000 f92d 	bl	801537c <lv_style_copy>
    lv_style_transp_fit.body.padding.left   = 0;
 8015122:	4b24      	ldr	r3, [pc, #144]	; (80151b4 <lv_style_init+0x2e8>)
 8015124:	2200      	movs	r2, #0
 8015126:	835a      	strh	r2, [r3, #26]
    lv_style_transp_fit.body.padding.right  = 0;
 8015128:	4b22      	ldr	r3, [pc, #136]	; (80151b4 <lv_style_init+0x2e8>)
 801512a:	2200      	movs	r2, #0
 801512c:	839a      	strh	r2, [r3, #28]
    lv_style_transp_fit.body.padding.top    = 0;
 801512e:	4b21      	ldr	r3, [pc, #132]	; (80151b4 <lv_style_init+0x2e8>)
 8015130:	2200      	movs	r2, #0
 8015132:	82da      	strh	r2, [r3, #22]
    lv_style_transp_fit.body.padding.bottom = 0;
 8015134:	4b1f      	ldr	r3, [pc, #124]	; (80151b4 <lv_style_init+0x2e8>)
 8015136:	2200      	movs	r2, #0
 8015138:	831a      	strh	r2, [r3, #24]

    /*Transparent tight style*/
    lv_style_copy(&lv_style_transp_tight, &lv_style_transp_fit);
 801513a:	491e      	ldr	r1, [pc, #120]	; (80151b4 <lv_style_init+0x2e8>)
 801513c:	481e      	ldr	r0, [pc, #120]	; (80151b8 <lv_style_init+0x2ec>)
 801513e:	f000 f91d 	bl	801537c <lv_style_copy>
    lv_style_transp_tight.body.padding.inner = 0;
 8015142:	4b1d      	ldr	r3, [pc, #116]	; (80151b8 <lv_style_init+0x2ec>)
 8015144:	2200      	movs	r2, #0
 8015146:	83da      	strh	r2, [r3, #30]

    /*Button released style*/
    lv_style_copy(&lv_style_btn_rel, &lv_style_plain);
 8015148:	4914      	ldr	r1, [pc, #80]	; (801519c <lv_style_init+0x2d0>)
 801514a:	481c      	ldr	r0, [pc, #112]	; (80151bc <lv_style_init+0x2f0>)
 801514c:	f000 f916 	bl	801537c <lv_style_copy>
    lv_style_btn_rel.body.main_color     = lv_color_make(0x76, 0xa2, 0xd0);
 8015150:	4c1a      	ldr	r4, [pc, #104]	; (80151bc <lv_style_init+0x2f0>)
 8015152:	22d0      	movs	r2, #208	; 0xd0
 8015154:	21a2      	movs	r1, #162	; 0xa2
 8015156:	2076      	movs	r0, #118	; 0x76
 8015158:	f7ff fe8a 	bl	8014e70 <lv_color_make>
 801515c:	8060      	strh	r0, [r4, #2]
    lv_style_btn_rel.body.grad_color     = lv_color_make(0x19, 0x3a, 0x5d);
 801515e:	4c17      	ldr	r4, [pc, #92]	; (80151bc <lv_style_init+0x2f0>)
 8015160:	225d      	movs	r2, #93	; 0x5d
 8015162:	213a      	movs	r1, #58	; 0x3a
 8015164:	2019      	movs	r0, #25
 8015166:	f7ff fe83 	bl	8014e70 <lv_color_make>
 801516a:	80a0      	strh	r0, [r4, #4]
    lv_style_btn_rel.body.radius         = LV_DPI / 15;
 801516c:	4b13      	ldr	r3, [pc, #76]	; (80151bc <lv_style_init+0x2f0>)
 801516e:	2205      	movs	r2, #5
 8015170:	80da      	strh	r2, [r3, #6]
    lv_style_btn_rel.body.padding.left   = LV_DPI / 4;
 8015172:	4b12      	ldr	r3, [pc, #72]	; (80151bc <lv_style_init+0x2f0>)
 8015174:	2215      	movs	r2, #21
 8015176:	835a      	strh	r2, [r3, #26]
    lv_style_btn_rel.body.padding.right  = LV_DPI / 4;
 8015178:	4b10      	ldr	r3, [pc, #64]	; (80151bc <lv_style_init+0x2f0>)
 801517a:	2215      	movs	r2, #21
 801517c:	839a      	strh	r2, [r3, #28]
    lv_style_btn_rel.body.padding.top    = LV_DPI / 6;
 801517e:	4b0f      	ldr	r3, [pc, #60]	; (80151bc <lv_style_init+0x2f0>)
 8015180:	220e      	movs	r2, #14
 8015182:	82da      	strh	r2, [r3, #22]
    lv_style_btn_rel.body.padding.bottom = LV_DPI / 6;
 8015184:	4b0d      	ldr	r3, [pc, #52]	; (80151bc <lv_style_init+0x2f0>)
 8015186:	220e      	movs	r2, #14
 8015188:	831a      	strh	r2, [r3, #24]
 801518a:	e019      	b.n	80151c0 <lv_style_init+0x2f4>
 801518c:	24063570 	.word	0x24063570
 8015190:	080228b8 	.word	0x080228b8
 8015194:	080228bc 	.word	0x080228bc
 8015198:	240000dc 	.word	0x240000dc
 801519c:	240634f8 	.word	0x240634f8
 80151a0:	240635e8 	.word	0x240635e8
 80151a4:	24063408 	.word	0x24063408
 80151a8:	080228c0 	.word	0x080228c0
 80151ac:	24063318 	.word	0x24063318
 80151b0:	24063354 	.word	0x24063354
 80151b4:	240634bc 	.word	0x240634bc
 80151b8:	24063444 	.word	0x24063444
 80151bc:	24063390 	.word	0x24063390
    lv_style_btn_rel.body.padding.inner  = LV_DPI / 10;
 80151c0:	4b68      	ldr	r3, [pc, #416]	; (8015364 <lv_style_init+0x498>)
 80151c2:	2208      	movs	r2, #8
 80151c4:	83da      	strh	r2, [r3, #30]
    lv_style_btn_rel.body.border.color   = lv_color_make(0x0b, 0x19, 0x28);
 80151c6:	4c67      	ldr	r4, [pc, #412]	; (8015364 <lv_style_init+0x498>)
 80151c8:	2228      	movs	r2, #40	; 0x28
 80151ca:	2119      	movs	r1, #25
 80151cc:	200b      	movs	r0, #11
 80151ce:	f7ff fe4f 	bl	8014e70 <lv_color_make>
 80151d2:	8160      	strh	r0, [r4, #10]
    lv_style_btn_rel.body.border.width   = LV_DPI / 50 >= 1 ? LV_DPI / 50 : 1;
 80151d4:	4b63      	ldr	r3, [pc, #396]	; (8015364 <lv_style_init+0x498>)
 80151d6:	2201      	movs	r2, #1
 80151d8:	819a      	strh	r2, [r3, #12]
    lv_style_btn_rel.body.border.opa     = LV_OPA_70;
 80151da:	4b62      	ldr	r3, [pc, #392]	; (8015364 <lv_style_init+0x498>)
 80151dc:	22b2      	movs	r2, #178	; 0xb2
 80151de:	73da      	strb	r2, [r3, #15]
    lv_style_btn_rel.body.shadow.color   = LV_COLOR_GRAY;
 80151e0:	4a60      	ldr	r2, [pc, #384]	; (8015364 <lv_style_init+0x498>)
 80151e2:	4b61      	ldr	r3, [pc, #388]	; (8015368 <lv_style_init+0x49c>)
 80151e4:	881b      	ldrh	r3, [r3, #0]
 80151e6:	8213      	strh	r3, [r2, #16]
    lv_style_btn_rel.body.shadow.width   = 0;
 80151e8:	4b5e      	ldr	r3, [pc, #376]	; (8015364 <lv_style_init+0x498>)
 80151ea:	2200      	movs	r2, #0
 80151ec:	825a      	strh	r2, [r3, #18]
    lv_style_btn_rel.text.color          = lv_color_make(0xff, 0xff, 0xff);
 80151ee:	4c5d      	ldr	r4, [pc, #372]	; (8015364 <lv_style_init+0x498>)
 80151f0:	22ff      	movs	r2, #255	; 0xff
 80151f2:	21ff      	movs	r1, #255	; 0xff
 80151f4:	20ff      	movs	r0, #255	; 0xff
 80151f6:	f7ff fe3b 	bl	8014e70 <lv_color_make>
 80151fa:	8420      	strh	r0, [r4, #32]
    lv_style_btn_rel.image.color         = lv_color_make(0xff, 0xff, 0xff);
 80151fc:	4c59      	ldr	r4, [pc, #356]	; (8015364 <lv_style_init+0x498>)
 80151fe:	22ff      	movs	r2, #255	; 0xff
 8015200:	21ff      	movs	r1, #255	; 0xff
 8015202:	20ff      	movs	r0, #255	; 0xff
 8015204:	f7ff fe34 	bl	8014e70 <lv_color_make>
 8015208:	8620      	strh	r0, [r4, #48]	; 0x30

    /*Button pressed style*/
    lv_style_copy(&lv_style_btn_pr, &lv_style_btn_rel);
 801520a:	4956      	ldr	r1, [pc, #344]	; (8015364 <lv_style_init+0x498>)
 801520c:	4857      	ldr	r0, [pc, #348]	; (801536c <lv_style_init+0x4a0>)
 801520e:	f000 f8b5 	bl	801537c <lv_style_copy>
    lv_style_btn_pr.body.main_color = lv_color_make(0x33, 0x62, 0x94);
 8015212:	4c56      	ldr	r4, [pc, #344]	; (801536c <lv_style_init+0x4a0>)
 8015214:	2294      	movs	r2, #148	; 0x94
 8015216:	2162      	movs	r1, #98	; 0x62
 8015218:	2033      	movs	r0, #51	; 0x33
 801521a:	f7ff fe29 	bl	8014e70 <lv_color_make>
 801521e:	8060      	strh	r0, [r4, #2]
    lv_style_btn_pr.body.grad_color = lv_color_make(0x10, 0x26, 0x3c);
 8015220:	4c52      	ldr	r4, [pc, #328]	; (801536c <lv_style_init+0x4a0>)
 8015222:	223c      	movs	r2, #60	; 0x3c
 8015224:	2126      	movs	r1, #38	; 0x26
 8015226:	2010      	movs	r0, #16
 8015228:	f7ff fe22 	bl	8014e70 <lv_color_make>
 801522c:	80a0      	strh	r0, [r4, #4]
    lv_style_btn_pr.text.color      = lv_color_make(0xa4, 0xb5, 0xc6);
 801522e:	4c4f      	ldr	r4, [pc, #316]	; (801536c <lv_style_init+0x4a0>)
 8015230:	22c6      	movs	r2, #198	; 0xc6
 8015232:	21b5      	movs	r1, #181	; 0xb5
 8015234:	20a4      	movs	r0, #164	; 0xa4
 8015236:	f7ff fe1b 	bl	8014e70 <lv_color_make>
 801523a:	8420      	strh	r0, [r4, #32]
    lv_style_btn_pr.image.color     = lv_color_make(0xa4, 0xb5, 0xc6);
 801523c:	4c4b      	ldr	r4, [pc, #300]	; (801536c <lv_style_init+0x4a0>)
 801523e:	22c6      	movs	r2, #198	; 0xc6
 8015240:	21b5      	movs	r1, #181	; 0xb5
 8015242:	20a4      	movs	r0, #164	; 0xa4
 8015244:	f7ff fe14 	bl	8014e70 <lv_color_make>
 8015248:	8620      	strh	r0, [r4, #48]	; 0x30
    lv_style_btn_pr.line.color      = lv_color_make(0xa4, 0xb5, 0xc6);
 801524a:	4c48      	ldr	r4, [pc, #288]	; (801536c <lv_style_init+0x4a0>)
 801524c:	22c6      	movs	r2, #198	; 0xc6
 801524e:	21b5      	movs	r1, #181	; 0xb5
 8015250:	20a4      	movs	r0, #164	; 0xa4
 8015252:	f7ff fe0d 	bl	8014e70 <lv_color_make>
 8015256:	86a0      	strh	r0, [r4, #52]	; 0x34

    /*Button toggle released style*/
    lv_style_copy(&lv_style_btn_tgl_rel, &lv_style_btn_rel);
 8015258:	4942      	ldr	r1, [pc, #264]	; (8015364 <lv_style_init+0x498>)
 801525a:	4845      	ldr	r0, [pc, #276]	; (8015370 <lv_style_init+0x4a4>)
 801525c:	f000 f88e 	bl	801537c <lv_style_copy>
    lv_style_btn_tgl_rel.body.main_color   = lv_color_make(0x0a, 0x11, 0x22);
 8015260:	4c43      	ldr	r4, [pc, #268]	; (8015370 <lv_style_init+0x4a4>)
 8015262:	2222      	movs	r2, #34	; 0x22
 8015264:	2111      	movs	r1, #17
 8015266:	200a      	movs	r0, #10
 8015268:	f7ff fe02 	bl	8014e70 <lv_color_make>
 801526c:	8060      	strh	r0, [r4, #2]
    lv_style_btn_tgl_rel.body.grad_color   = lv_color_make(0x37, 0x62, 0x90);
 801526e:	4c40      	ldr	r4, [pc, #256]	; (8015370 <lv_style_init+0x4a4>)
 8015270:	2290      	movs	r2, #144	; 0x90
 8015272:	2162      	movs	r1, #98	; 0x62
 8015274:	2037      	movs	r0, #55	; 0x37
 8015276:	f7ff fdfb 	bl	8014e70 <lv_color_make>
 801527a:	80a0      	strh	r0, [r4, #4]
    lv_style_btn_tgl_rel.body.border.color = lv_color_make(0x01, 0x07, 0x0d);
 801527c:	4c3c      	ldr	r4, [pc, #240]	; (8015370 <lv_style_init+0x4a4>)
 801527e:	220d      	movs	r2, #13
 8015280:	2107      	movs	r1, #7
 8015282:	2001      	movs	r0, #1
 8015284:	f7ff fdf4 	bl	8014e70 <lv_color_make>
 8015288:	8160      	strh	r0, [r4, #10]
    lv_style_btn_tgl_rel.text.color        = lv_color_make(0xc8, 0xdd, 0xf4);
 801528a:	4c39      	ldr	r4, [pc, #228]	; (8015370 <lv_style_init+0x4a4>)
 801528c:	22f4      	movs	r2, #244	; 0xf4
 801528e:	21dd      	movs	r1, #221	; 0xdd
 8015290:	20c8      	movs	r0, #200	; 0xc8
 8015292:	f7ff fded 	bl	8014e70 <lv_color_make>
 8015296:	8420      	strh	r0, [r4, #32]
    lv_style_btn_tgl_rel.image.color       = lv_color_make(0xc8, 0xdd, 0xf4);
 8015298:	4c35      	ldr	r4, [pc, #212]	; (8015370 <lv_style_init+0x4a4>)
 801529a:	22f4      	movs	r2, #244	; 0xf4
 801529c:	21dd      	movs	r1, #221	; 0xdd
 801529e:	20c8      	movs	r0, #200	; 0xc8
 80152a0:	f7ff fde6 	bl	8014e70 <lv_color_make>
 80152a4:	8620      	strh	r0, [r4, #48]	; 0x30
    lv_style_btn_tgl_rel.line.color        = lv_color_make(0xc8, 0xdd, 0xf4);
 80152a6:	4c32      	ldr	r4, [pc, #200]	; (8015370 <lv_style_init+0x4a4>)
 80152a8:	22f4      	movs	r2, #244	; 0xf4
 80152aa:	21dd      	movs	r1, #221	; 0xdd
 80152ac:	20c8      	movs	r0, #200	; 0xc8
 80152ae:	f7ff fddf 	bl	8014e70 <lv_color_make>
 80152b2:	86a0      	strh	r0, [r4, #52]	; 0x34

    /*Button toggle pressed style*/
    lv_style_copy(&lv_style_btn_tgl_pr, &lv_style_btn_tgl_rel);
 80152b4:	492e      	ldr	r1, [pc, #184]	; (8015370 <lv_style_init+0x4a4>)
 80152b6:	482f      	ldr	r0, [pc, #188]	; (8015374 <lv_style_init+0x4a8>)
 80152b8:	f000 f860 	bl	801537c <lv_style_copy>
    lv_style_btn_tgl_pr.body.main_color = lv_color_make(0x02, 0x14, 0x27);
 80152bc:	4c2d      	ldr	r4, [pc, #180]	; (8015374 <lv_style_init+0x4a8>)
 80152be:	2227      	movs	r2, #39	; 0x27
 80152c0:	2114      	movs	r1, #20
 80152c2:	2002      	movs	r0, #2
 80152c4:	f7ff fdd4 	bl	8014e70 <lv_color_make>
 80152c8:	8060      	strh	r0, [r4, #2]
    lv_style_btn_tgl_pr.body.grad_color = lv_color_make(0x2b, 0x4c, 0x70);
 80152ca:	4c2a      	ldr	r4, [pc, #168]	; (8015374 <lv_style_init+0x4a8>)
 80152cc:	2270      	movs	r2, #112	; 0x70
 80152ce:	214c      	movs	r1, #76	; 0x4c
 80152d0:	202b      	movs	r0, #43	; 0x2b
 80152d2:	f7ff fdcd 	bl	8014e70 <lv_color_make>
 80152d6:	80a0      	strh	r0, [r4, #4]
    lv_style_btn_tgl_pr.text.color      = lv_color_make(0xa4, 0xb5, 0xc6);
 80152d8:	4c26      	ldr	r4, [pc, #152]	; (8015374 <lv_style_init+0x4a8>)
 80152da:	22c6      	movs	r2, #198	; 0xc6
 80152dc:	21b5      	movs	r1, #181	; 0xb5
 80152de:	20a4      	movs	r0, #164	; 0xa4
 80152e0:	f7ff fdc6 	bl	8014e70 <lv_color_make>
 80152e4:	8420      	strh	r0, [r4, #32]
    lv_style_btn_tgl_pr.image.color     = lv_color_make(0xa4, 0xb5, 0xc6);
 80152e6:	4c23      	ldr	r4, [pc, #140]	; (8015374 <lv_style_init+0x4a8>)
 80152e8:	22c6      	movs	r2, #198	; 0xc6
 80152ea:	21b5      	movs	r1, #181	; 0xb5
 80152ec:	20a4      	movs	r0, #164	; 0xa4
 80152ee:	f7ff fdbf 	bl	8014e70 <lv_color_make>
 80152f2:	8620      	strh	r0, [r4, #48]	; 0x30
    lv_style_btn_tgl_pr.line.color      = lv_color_make(0xa4, 0xb5, 0xc6);
 80152f4:	4c1f      	ldr	r4, [pc, #124]	; (8015374 <lv_style_init+0x4a8>)
 80152f6:	22c6      	movs	r2, #198	; 0xc6
 80152f8:	21b5      	movs	r1, #181	; 0xb5
 80152fa:	20a4      	movs	r0, #164	; 0xa4
 80152fc:	f7ff fdb8 	bl	8014e70 <lv_color_make>
 8015300:	86a0      	strh	r0, [r4, #52]	; 0x34

    /*Button inactive style*/
    lv_style_copy(&lv_style_btn_ina, &lv_style_btn_rel);
 8015302:	4918      	ldr	r1, [pc, #96]	; (8015364 <lv_style_init+0x498>)
 8015304:	481c      	ldr	r0, [pc, #112]	; (8015378 <lv_style_init+0x4ac>)
 8015306:	f000 f839 	bl	801537c <lv_style_copy>
    lv_style_btn_ina.body.main_color   = lv_color_make(0xd8, 0xd8, 0xd8);
 801530a:	4c1b      	ldr	r4, [pc, #108]	; (8015378 <lv_style_init+0x4ac>)
 801530c:	22d8      	movs	r2, #216	; 0xd8
 801530e:	21d8      	movs	r1, #216	; 0xd8
 8015310:	20d8      	movs	r0, #216	; 0xd8
 8015312:	f7ff fdad 	bl	8014e70 <lv_color_make>
 8015316:	8060      	strh	r0, [r4, #2]
    lv_style_btn_ina.body.grad_color   = lv_color_make(0xd8, 0xd8, 0xd8);
 8015318:	4c17      	ldr	r4, [pc, #92]	; (8015378 <lv_style_init+0x4ac>)
 801531a:	22d8      	movs	r2, #216	; 0xd8
 801531c:	21d8      	movs	r1, #216	; 0xd8
 801531e:	20d8      	movs	r0, #216	; 0xd8
 8015320:	f7ff fda6 	bl	8014e70 <lv_color_make>
 8015324:	80a0      	strh	r0, [r4, #4]
    lv_style_btn_ina.body.border.color = lv_color_make(0x90, 0x90, 0x90);
 8015326:	4c14      	ldr	r4, [pc, #80]	; (8015378 <lv_style_init+0x4ac>)
 8015328:	2290      	movs	r2, #144	; 0x90
 801532a:	2190      	movs	r1, #144	; 0x90
 801532c:	2090      	movs	r0, #144	; 0x90
 801532e:	f7ff fd9f 	bl	8014e70 <lv_color_make>
 8015332:	8160      	strh	r0, [r4, #10]
    lv_style_btn_ina.text.color        = lv_color_make(0x70, 0x70, 0x70);
 8015334:	4c10      	ldr	r4, [pc, #64]	; (8015378 <lv_style_init+0x4ac>)
 8015336:	2270      	movs	r2, #112	; 0x70
 8015338:	2170      	movs	r1, #112	; 0x70
 801533a:	2070      	movs	r0, #112	; 0x70
 801533c:	f7ff fd98 	bl	8014e70 <lv_color_make>
 8015340:	8420      	strh	r0, [r4, #32]
    lv_style_btn_ina.image.color       = lv_color_make(0x70, 0x70, 0x70);
 8015342:	4c0d      	ldr	r4, [pc, #52]	; (8015378 <lv_style_init+0x4ac>)
 8015344:	2270      	movs	r2, #112	; 0x70
 8015346:	2170      	movs	r1, #112	; 0x70
 8015348:	2070      	movs	r0, #112	; 0x70
 801534a:	f7ff fd91 	bl	8014e70 <lv_color_make>
 801534e:	8620      	strh	r0, [r4, #48]	; 0x30
    lv_style_btn_ina.line.color        = lv_color_make(0x70, 0x70, 0x70);
 8015350:	4c09      	ldr	r4, [pc, #36]	; (8015378 <lv_style_init+0x4ac>)
 8015352:	2270      	movs	r2, #112	; 0x70
 8015354:	2170      	movs	r1, #112	; 0x70
 8015356:	2070      	movs	r0, #112	; 0x70
 8015358:	f7ff fd8a 	bl	8014e70 <lv_color_make>
 801535c:	86a0      	strh	r0, [r4, #52]	; 0x34
}
 801535e:	bf00      	nop
 8015360:	bd98      	pop	{r3, r4, r7, pc}
 8015362:	bf00      	nop
 8015364:	24063390 	.word	0x24063390
 8015368:	080228bc 	.word	0x080228bc
 801536c:	240633cc 	.word	0x240633cc
 8015370:	24063534 	.word	0x24063534
 8015374:	240635ac 	.word	0x240635ac
 8015378:	24063480 	.word	0x24063480

0801537c <lv_style_copy>:
 * Copy a style to an other
 * @param dest pointer to the destination style
 * @param src pointer to the source style
 */
void lv_style_copy(lv_style_t * dest, const lv_style_t * src)
{
 801537c:	b580      	push	{r7, lr}
 801537e:	b082      	sub	sp, #8
 8015380:	af00      	add	r7, sp, #0
 8015382:	6078      	str	r0, [r7, #4]
 8015384:	6039      	str	r1, [r7, #0]
    memcpy(dest, src, sizeof(lv_style_t));
 8015386:	223c      	movs	r2, #60	; 0x3c
 8015388:	6839      	ldr	r1, [r7, #0]
 801538a:	6878      	ldr	r0, [r7, #4]
 801538c:	f00c fc64 	bl	8021c58 <memcpy>
}
 8015390:	bf00      	nop
 8015392:	3708      	adds	r7, #8
 8015394:	46bd      	mov	sp, r7
 8015396:	bd80      	pop	{r7, pc}

08015398 <lv_draw_get_buf>:
 * Give a buffer with the given to use during drawing.
 * Be careful to not use the buffer while other processes are using it.
 * @param size the required size
 */
void * lv_draw_get_buf(uint32_t size)
{
 8015398:	b580      	push	{r7, lr}
 801539a:	b082      	sub	sp, #8
 801539c:	af00      	add	r7, sp, #0
 801539e:	6078      	str	r0, [r7, #4]
    if(size <= draw_buf_size) return LV_GC_ROOT(_lv_draw_buf);
 80153a0:	4b18      	ldr	r3, [pc, #96]	; (8015404 <lv_draw_get_buf+0x6c>)
 80153a2:	681b      	ldr	r3, [r3, #0]
 80153a4:	687a      	ldr	r2, [r7, #4]
 80153a6:	429a      	cmp	r2, r3
 80153a8:	d802      	bhi.n	80153b0 <lv_draw_get_buf+0x18>
 80153aa:	4b17      	ldr	r3, [pc, #92]	; (8015408 <lv_draw_get_buf+0x70>)
 80153ac:	681b      	ldr	r3, [r3, #0]
 80153ae:	e024      	b.n	80153fa <lv_draw_get_buf+0x62>

    LV_LOG_TRACE("lv_draw_get_buf: allocate");

    draw_buf_size = size;
 80153b0:	4a14      	ldr	r2, [pc, #80]	; (8015404 <lv_draw_get_buf+0x6c>)
 80153b2:	687b      	ldr	r3, [r7, #4]
 80153b4:	6013      	str	r3, [r2, #0]

    if(LV_GC_ROOT(_lv_draw_buf) == NULL) {
 80153b6:	4b14      	ldr	r3, [pc, #80]	; (8015408 <lv_draw_get_buf+0x70>)
 80153b8:	681b      	ldr	r3, [r3, #0]
 80153ba:	2b00      	cmp	r3, #0
 80153bc:	d10d      	bne.n	80153da <lv_draw_get_buf+0x42>
        LV_GC_ROOT(_lv_draw_buf) = lv_mem_alloc(size);
 80153be:	6878      	ldr	r0, [r7, #4]
 80153c0:	f008 fe76 	bl	801e0b0 <lv_mem_alloc>
 80153c4:	4603      	mov	r3, r0
 80153c6:	4a10      	ldr	r2, [pc, #64]	; (8015408 <lv_draw_get_buf+0x70>)
 80153c8:	6013      	str	r3, [r2, #0]
        lv_mem_assert(LV_GC_ROOT(_lv_draw_buf));
 80153ca:	4b0f      	ldr	r3, [pc, #60]	; (8015408 <lv_draw_get_buf+0x70>)
 80153cc:	681b      	ldr	r3, [r3, #0]
 80153ce:	2b00      	cmp	r3, #0
 80153d0:	d100      	bne.n	80153d4 <lv_draw_get_buf+0x3c>
 80153d2:	e7fe      	b.n	80153d2 <lv_draw_get_buf+0x3a>
        return LV_GC_ROOT(_lv_draw_buf);
 80153d4:	4b0c      	ldr	r3, [pc, #48]	; (8015408 <lv_draw_get_buf+0x70>)
 80153d6:	681b      	ldr	r3, [r3, #0]
 80153d8:	e00f      	b.n	80153fa <lv_draw_get_buf+0x62>
    }

    LV_GC_ROOT(_lv_draw_buf) = lv_mem_realloc(LV_GC_ROOT(_lv_draw_buf), size);
 80153da:	4b0b      	ldr	r3, [pc, #44]	; (8015408 <lv_draw_get_buf+0x70>)
 80153dc:	681b      	ldr	r3, [r3, #0]
 80153de:	6879      	ldr	r1, [r7, #4]
 80153e0:	4618      	mov	r0, r3
 80153e2:	f008 fecd 	bl	801e180 <lv_mem_realloc>
 80153e6:	4603      	mov	r3, r0
 80153e8:	4a07      	ldr	r2, [pc, #28]	; (8015408 <lv_draw_get_buf+0x70>)
 80153ea:	6013      	str	r3, [r2, #0]
    lv_mem_assert(LV_GC_ROOT(_lv_draw_buf));
 80153ec:	4b06      	ldr	r3, [pc, #24]	; (8015408 <lv_draw_get_buf+0x70>)
 80153ee:	681b      	ldr	r3, [r3, #0]
 80153f0:	2b00      	cmp	r3, #0
 80153f2:	d100      	bne.n	80153f6 <lv_draw_get_buf+0x5e>
 80153f4:	e7fe      	b.n	80153f4 <lv_draw_get_buf+0x5c>
    return LV_GC_ROOT(_lv_draw_buf);
 80153f6:	4b04      	ldr	r3, [pc, #16]	; (8015408 <lv_draw_get_buf+0x70>)
 80153f8:	681b      	ldr	r3, [r3, #0]
}
 80153fa:	4618      	mov	r0, r3
 80153fc:	3708      	adds	r7, #8
 80153fe:	46bd      	mov	sp, r7
 8015400:	bd80      	pop	{r7, pc}
 8015402:	bf00      	nop
 8015404:	240623cc 	.word	0x240623cc
 8015408:	2406363c 	.word	0x2406363c

0801540c <lv_draw_free_buf>:

/**
 * Free the draw buffer
 */
void lv_draw_free_buf(void)
{
 801540c:	b580      	push	{r7, lr}
 801540e:	af00      	add	r7, sp, #0
    if(LV_GC_ROOT(_lv_draw_buf)) {
 8015410:	4b08      	ldr	r3, [pc, #32]	; (8015434 <lv_draw_free_buf+0x28>)
 8015412:	681b      	ldr	r3, [r3, #0]
 8015414:	2b00      	cmp	r3, #0
 8015416:	d00a      	beq.n	801542e <lv_draw_free_buf+0x22>
        lv_mem_free(LV_GC_ROOT(_lv_draw_buf));
 8015418:	4b06      	ldr	r3, [pc, #24]	; (8015434 <lv_draw_free_buf+0x28>)
 801541a:	681b      	ldr	r3, [r3, #0]
 801541c:	4618      	mov	r0, r3
 801541e:	f008 fe87 	bl	801e130 <lv_mem_free>
        LV_GC_ROOT(_lv_draw_buf) = NULL;
 8015422:	4b04      	ldr	r3, [pc, #16]	; (8015434 <lv_draw_free_buf+0x28>)
 8015424:	2200      	movs	r2, #0
 8015426:	601a      	str	r2, [r3, #0]
        draw_buf_size = 0;
 8015428:	4b03      	ldr	r3, [pc, #12]	; (8015438 <lv_draw_free_buf+0x2c>)
 801542a:	2200      	movs	r2, #0
 801542c:	601a      	str	r2, [r3, #0]
    }
}
 801542e:	bf00      	nop
 8015430:	bd80      	pop	{r7, pc}
 8015432:	bf00      	nop
 8015434:	2406363c 	.word	0x2406363c
 8015438:	240623cc 	.word	0x240623cc

0801543c <lv_draw_aa_get_opa>:
 * @param px_id position of  of a pixel which opacity should be get [0..seg-1]
 * @param base_opa the base opacity
 * @return the opacity of the given pixel
 */
lv_opa_t lv_draw_aa_get_opa(lv_coord_t seg, lv_coord_t px_id, lv_opa_t base_opa)
{
 801543c:	b480      	push	{r7}
 801543e:	b083      	sub	sp, #12
 8015440:	af00      	add	r7, sp, #0
 8015442:	4603      	mov	r3, r0
 8015444:	80fb      	strh	r3, [r7, #6]
 8015446:	460b      	mov	r3, r1
 8015448:	80bb      	strh	r3, [r7, #4]
 801544a:	4613      	mov	r3, r2
 801544c:	70fb      	strb	r3, [r7, #3]
    static const lv_opa_t seg7[7] = {18, 55, 91, 128, 164, 200, 237};
    static const lv_opa_t seg8[8] = {16, 48, 80, 112, 143, 175, 207, 239};

    static const lv_opa_t * seg_map[] = {seg1, seg2, seg3, seg4, seg5, seg6, seg7, seg8};

    if(seg == 0)
 801544e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8015452:	2b00      	cmp	r3, #0
 8015454:	d101      	bne.n	801545a <lv_draw_aa_get_opa+0x1e>
        return LV_OPA_TRANSP;
 8015456:	2300      	movs	r3, #0
 8015458:	e021      	b.n	801549e <lv_draw_aa_get_opa+0x62>
    else if(seg < 8)
 801545a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801545e:	2b07      	cmp	r3, #7
 8015460:	dc10      	bgt.n	8015484 <lv_draw_aa_get_opa+0x48>
        return (uint32_t)((uint32_t)seg_map[seg - 1][px_id] * base_opa) >> 8;
 8015462:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8015466:	3b01      	subs	r3, #1
 8015468:	4a10      	ldr	r2, [pc, #64]	; (80154ac <lv_draw_aa_get_opa+0x70>)
 801546a:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 801546e:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 8015472:	4413      	add	r3, r2
 8015474:	781b      	ldrb	r3, [r3, #0]
 8015476:	461a      	mov	r2, r3
 8015478:	78fb      	ldrb	r3, [r7, #3]
 801547a:	fb03 f302 	mul.w	r3, r3, r2
 801547e:	0a1b      	lsrs	r3, r3, #8
 8015480:	b2db      	uxtb	r3, r3
 8015482:	e00c      	b.n	801549e <lv_draw_aa_get_opa+0x62>
    else {
        return ((px_id * 2 + 1) * base_opa) / (2 * seg);
 8015484:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 8015488:	005b      	lsls	r3, r3, #1
 801548a:	3301      	adds	r3, #1
 801548c:	78fa      	ldrb	r2, [r7, #3]
 801548e:	fb02 f203 	mul.w	r2, r2, r3
 8015492:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8015496:	005b      	lsls	r3, r3, #1
 8015498:	fb92 f3f3 	sdiv	r3, r2, r3
 801549c:	b2db      	uxtb	r3, r3
    }
}
 801549e:	4618      	mov	r0, r3
 80154a0:	370c      	adds	r7, #12
 80154a2:	46bd      	mov	sp, r7
 80154a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80154a8:	4770      	bx	lr
 80154aa:	bf00      	nop
 80154ac:	240001ac 	.word	0x240001ac

080154b0 <lv_draw_arc>:
 * @param style style of the arc (`body.thickness`, `body.main_color`, `body.opa` is used)
 * @param opa_scale scale down all opacities by the factor
 */
void lv_draw_arc(lv_coord_t center_x, lv_coord_t center_y, uint16_t radius, const lv_area_t * mask,
                 uint16_t start_angle, uint16_t end_angle, const lv_style_t * style, lv_opa_t opa_scale)
{
 80154b0:	b580      	push	{r7, lr}
 80154b2:	b094      	sub	sp, #80	; 0x50
 80154b4:	af02      	add	r7, sp, #8
 80154b6:	607b      	str	r3, [r7, #4]
 80154b8:	4603      	mov	r3, r0
 80154ba:	81fb      	strh	r3, [r7, #14]
 80154bc:	460b      	mov	r3, r1
 80154be:	81bb      	strh	r3, [r7, #12]
 80154c0:	4613      	mov	r3, r2
 80154c2:	817b      	strh	r3, [r7, #10]
    lv_coord_t thickness = style->line.width;
 80154c4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80154c6:	8edb      	ldrh	r3, [r3, #54]	; 0x36
 80154c8:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
    if(thickness > radius) thickness = radius;
 80154cc:	f9b7 2046 	ldrsh.w	r2, [r7, #70]	; 0x46
 80154d0:	897b      	ldrh	r3, [r7, #10]
 80154d2:	429a      	cmp	r2, r3
 80154d4:	dd02      	ble.n	80154dc <lv_draw_arc+0x2c>
 80154d6:	897b      	ldrh	r3, [r7, #10]
 80154d8:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46

    lv_coord_t r_out = radius;
 80154dc:	897b      	ldrh	r3, [r7, #10]
 80154de:	877b      	strh	r3, [r7, #58]	; 0x3a
    lv_coord_t r_in  = r_out - thickness;
 80154e0:	8f7a      	ldrh	r2, [r7, #58]	; 0x3a
 80154e2:	f8b7 3046 	ldrh.w	r3, [r7, #70]	; 0x46
 80154e6:	1ad3      	subs	r3, r2, r3
 80154e8:	b29b      	uxth	r3, r3
 80154ea:	873b      	strh	r3, [r7, #56]	; 0x38
    int16_t deg_base;
    int16_t deg;
    lv_coord_t x_start[4];
    lv_coord_t x_end[4];

    lv_color_t color = style->line.color;
 80154ec:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80154ee:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 80154f0:	823b      	strh	r3, [r7, #16]
    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->body.opa : (uint16_t)((uint16_t)style->body.opa * opa_scale) >> 8;
 80154f2:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 80154f6:	2bff      	cmp	r3, #255	; 0xff
 80154f8:	d102      	bne.n	8015500 <lv_draw_arc+0x50>
 80154fa:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80154fc:	7a1b      	ldrb	r3, [r3, #8]
 80154fe:	e00b      	b.n	8015518 <lv_draw_arc+0x68>
 8015500:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8015502:	7a1b      	ldrb	r3, [r3, #8]
 8015504:	b29a      	uxth	r2, r3
 8015506:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 801550a:	b29b      	uxth	r3, r3
 801550c:	fb12 f303 	smulbb	r3, r2, r3
 8015510:	b29b      	uxth	r3, r3
 8015512:	0a1b      	lsrs	r3, r3, #8
 8015514:	b29b      	uxth	r3, r3
 8015516:	b2db      	uxtb	r3, r3
 8015518:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37

    bool (*deg_test)(uint16_t, uint16_t, uint16_t);
    if(start_angle <= end_angle)
 801551c:	f8b7 2050 	ldrh.w	r2, [r7, #80]	; 0x50
 8015520:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 8015524:	429a      	cmp	r2, r3
 8015526:	d802      	bhi.n	801552e <lv_draw_arc+0x7e>
        deg_test = deg_test_norm;
 8015528:	4bae      	ldr	r3, [pc, #696]	; (80157e4 <lv_draw_arc+0x334>)
 801552a:	643b      	str	r3, [r7, #64]	; 0x40
 801552c:	e001      	b.n	8015532 <lv_draw_arc+0x82>
    else
        deg_test = deg_test_inv;
 801552e:	4bae      	ldr	r3, [pc, #696]	; (80157e8 <lv_draw_arc+0x338>)
 8015530:	643b      	str	r3, [r7, #64]	; 0x40

    if(deg_test(270, start_angle, end_angle))
 8015532:	f8b7 2054 	ldrh.w	r2, [r7, #84]	; 0x54
 8015536:	f8b7 1050 	ldrh.w	r1, [r7, #80]	; 0x50
 801553a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801553c:	f44f 7087 	mov.w	r0, #270	; 0x10e
 8015540:	4798      	blx	r3
 8015542:	4603      	mov	r3, r0
 8015544:	2b00      	cmp	r3, #0
 8015546:	d017      	beq.n	8015578 <lv_draw_arc+0xc8>
        hor_line(center_x - r_out + 1, center_y, mask, thickness - 1, color, opa); /*Left Middle*/
 8015548:	89fa      	ldrh	r2, [r7, #14]
 801554a:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 801554c:	1ad3      	subs	r3, r2, r3
 801554e:	b29b      	uxth	r3, r3
 8015550:	3301      	adds	r3, #1
 8015552:	b29b      	uxth	r3, r3
 8015554:	b218      	sxth	r0, r3
 8015556:	f8b7 3046 	ldrh.w	r3, [r7, #70]	; 0x46
 801555a:	3b01      	subs	r3, #1
 801555c:	b29b      	uxth	r3, r3
 801555e:	b21a      	sxth	r2, r3
 8015560:	f9b7 100c 	ldrsh.w	r1, [r7, #12]
 8015564:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8015568:	9301      	str	r3, [sp, #4]
 801556a:	8a3b      	ldrh	r3, [r7, #16]
 801556c:	f8ad 3000 	strh.w	r3, [sp]
 8015570:	4613      	mov	r3, r2
 8015572:	687a      	ldr	r2, [r7, #4]
 8015574:	f000 faf4 	bl	8015b60 <hor_line>
    if(deg_test(90, start_angle, end_angle))
 8015578:	f8b7 2054 	ldrh.w	r2, [r7, #84]	; 0x54
 801557c:	f8b7 1050 	ldrh.w	r1, [r7, #80]	; 0x50
 8015580:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8015582:	205a      	movs	r0, #90	; 0x5a
 8015584:	4798      	blx	r3
 8015586:	4603      	mov	r3, r0
 8015588:	2b00      	cmp	r3, #0
 801558a:	d015      	beq.n	80155b8 <lv_draw_arc+0x108>
        hor_line(center_x + r_in, center_y, mask, thickness - 1, color, opa); /*Right Middle*/
 801558c:	89fa      	ldrh	r2, [r7, #14]
 801558e:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 8015590:	4413      	add	r3, r2
 8015592:	b29b      	uxth	r3, r3
 8015594:	b218      	sxth	r0, r3
 8015596:	f8b7 3046 	ldrh.w	r3, [r7, #70]	; 0x46
 801559a:	3b01      	subs	r3, #1
 801559c:	b29b      	uxth	r3, r3
 801559e:	b21a      	sxth	r2, r3
 80155a0:	f9b7 100c 	ldrsh.w	r1, [r7, #12]
 80155a4:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80155a8:	9301      	str	r3, [sp, #4]
 80155aa:	8a3b      	ldrh	r3, [r7, #16]
 80155ac:	f8ad 3000 	strh.w	r3, [sp]
 80155b0:	4613      	mov	r3, r2
 80155b2:	687a      	ldr	r2, [r7, #4]
 80155b4:	f000 fad4 	bl	8015b60 <hor_line>
    if(deg_test(180, start_angle, end_angle))
 80155b8:	f8b7 2054 	ldrh.w	r2, [r7, #84]	; 0x54
 80155bc:	f8b7 1050 	ldrh.w	r1, [r7, #80]	; 0x50
 80155c0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80155c2:	20b4      	movs	r0, #180	; 0xb4
 80155c4:	4798      	blx	r3
 80155c6:	4603      	mov	r3, r0
 80155c8:	2b00      	cmp	r3, #0
 80155ca:	d017      	beq.n	80155fc <lv_draw_arc+0x14c>
        ver_line(center_x, center_y - r_out + 1, mask, thickness - 1, color, opa); /*Top Middle*/
 80155cc:	89ba      	ldrh	r2, [r7, #12]
 80155ce:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 80155d0:	1ad3      	subs	r3, r2, r3
 80155d2:	b29b      	uxth	r3, r3
 80155d4:	3301      	adds	r3, #1
 80155d6:	b29b      	uxth	r3, r3
 80155d8:	b219      	sxth	r1, r3
 80155da:	f8b7 3046 	ldrh.w	r3, [r7, #70]	; 0x46
 80155de:	3b01      	subs	r3, #1
 80155e0:	b29b      	uxth	r3, r3
 80155e2:	b21a      	sxth	r2, r3
 80155e4:	f9b7 000e 	ldrsh.w	r0, [r7, #14]
 80155e8:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80155ec:	9301      	str	r3, [sp, #4]
 80155ee:	8a3b      	ldrh	r3, [r7, #16]
 80155f0:	f8ad 3000 	strh.w	r3, [sp]
 80155f4:	4613      	mov	r3, r2
 80155f6:	687a      	ldr	r2, [r7, #4]
 80155f8:	f000 fa8a 	bl	8015b10 <ver_line>
    if(deg_test(0, start_angle, end_angle))
 80155fc:	f8b7 2054 	ldrh.w	r2, [r7, #84]	; 0x54
 8015600:	f8b7 1050 	ldrh.w	r1, [r7, #80]	; 0x50
 8015604:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8015606:	2000      	movs	r0, #0
 8015608:	4798      	blx	r3
 801560a:	4603      	mov	r3, r0
 801560c:	2b00      	cmp	r3, #0
 801560e:	d015      	beq.n	801563c <lv_draw_arc+0x18c>
        ver_line(center_x, center_y + r_in, mask, thickness - 1, color, opa); /*Bottom middle*/
 8015610:	89ba      	ldrh	r2, [r7, #12]
 8015612:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 8015614:	4413      	add	r3, r2
 8015616:	b29b      	uxth	r3, r3
 8015618:	b219      	sxth	r1, r3
 801561a:	f8b7 3046 	ldrh.w	r3, [r7, #70]	; 0x46
 801561e:	3b01      	subs	r3, #1
 8015620:	b29b      	uxth	r3, r3
 8015622:	b21a      	sxth	r2, r3
 8015624:	f9b7 000e 	ldrsh.w	r0, [r7, #14]
 8015628:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801562c:	9301      	str	r3, [sp, #4]
 801562e:	8a3b      	ldrh	r3, [r7, #16]
 8015630:	f8ad 3000 	strh.w	r3, [sp]
 8015634:	4613      	mov	r3, r2
 8015636:	687a      	ldr	r2, [r7, #4]
 8015638:	f000 fa6a 	bl	8015b10 <ver_line>

    uint32_t r_out_sqr = r_out * r_out;
 801563c:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8015640:	f9b7 203a 	ldrsh.w	r2, [r7, #58]	; 0x3a
 8015644:	fb02 f303 	mul.w	r3, r2, r3
 8015648:	633b      	str	r3, [r7, #48]	; 0x30
    uint32_t r_in_sqr  = r_in * r_in;
 801564a:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 801564e:	f9b7 2038 	ldrsh.w	r2, [r7, #56]	; 0x38
 8015652:	fb02 f303 	mul.w	r3, r2, r3
 8015656:	62fb      	str	r3, [r7, #44]	; 0x2c
    int16_t xi;
    int16_t yi;
    for(yi = -r_out; yi < 0; yi++) {
 8015658:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 801565a:	425b      	negs	r3, r3
 801565c:	b29b      	uxth	r3, r3
 801565e:	87bb      	strh	r3, [r7, #60]	; 0x3c
 8015660:	e1a8      	b.n	80159b4 <lv_draw_arc+0x504>
        x_start[0] = LV_COORD_MIN;
 8015662:	f248 33e8 	movw	r3, #33768	; 0x83e8
 8015666:	83bb      	strh	r3, [r7, #28]
        x_start[1] = LV_COORD_MIN;
 8015668:	f248 33e8 	movw	r3, #33768	; 0x83e8
 801566c:	83fb      	strh	r3, [r7, #30]
        x_start[2] = LV_COORD_MIN;
 801566e:	f248 33e8 	movw	r3, #33768	; 0x83e8
 8015672:	843b      	strh	r3, [r7, #32]
        x_start[3] = LV_COORD_MIN;
 8015674:	f248 33e8 	movw	r3, #33768	; 0x83e8
 8015678:	847b      	strh	r3, [r7, #34]	; 0x22
        x_end[0]   = LV_COORD_MIN;
 801567a:	f248 33e8 	movw	r3, #33768	; 0x83e8
 801567e:	82bb      	strh	r3, [r7, #20]
        x_end[1]   = LV_COORD_MIN;
 8015680:	f248 33e8 	movw	r3, #33768	; 0x83e8
 8015684:	82fb      	strh	r3, [r7, #22]
        x_end[2]   = LV_COORD_MIN;
 8015686:	f248 33e8 	movw	r3, #33768	; 0x83e8
 801568a:	833b      	strh	r3, [r7, #24]
        x_end[3]   = LV_COORD_MIN;
 801568c:	f248 33e8 	movw	r3, #33768	; 0x83e8
 8015690:	837b      	strh	r3, [r7, #26]
        for(xi = -r_out; xi < 0; xi++) {
 8015692:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 8015694:	425b      	negs	r3, r3
 8015696:	b29b      	uxth	r3, r3
 8015698:	87fb      	strh	r3, [r7, #62]	; 0x3e
 801569a:	e0c4      	b.n	8015826 <lv_draw_arc+0x376>

            uint32_t r_act_sqr = xi * xi + yi * yi;
 801569c:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 80156a0:	f9b7 203e 	ldrsh.w	r2, [r7, #62]	; 0x3e
 80156a4:	fb02 f203 	mul.w	r2, r2, r3
 80156a8:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 80156ac:	f9b7 103c 	ldrsh.w	r1, [r7, #60]	; 0x3c
 80156b0:	fb01 f303 	mul.w	r3, r1, r3
 80156b4:	4413      	add	r3, r2
 80156b6:	62bb      	str	r3, [r7, #40]	; 0x28
            if(r_act_sqr > r_out_sqr) continue;
 80156b8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80156ba:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80156bc:	429a      	cmp	r2, r3
 80156be:	f200 80ab 	bhi.w	8015818 <lv_draw_arc+0x368>

            deg_base = fast_atan2(xi, yi) - 180;
 80156c2:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 80156c6:	f9b7 203c 	ldrsh.w	r2, [r7, #60]	; 0x3c
 80156ca:	4611      	mov	r1, r2
 80156cc:	4618      	mov	r0, r3
 80156ce:	f000 f97d 	bl	80159cc <fast_atan2>
 80156d2:	4603      	mov	r3, r0
 80156d4:	3bb4      	subs	r3, #180	; 0xb4
 80156d6:	b29b      	uxth	r3, r3
 80156d8:	84fb      	strh	r3, [r7, #38]	; 0x26

            deg = 180 + deg_base;
 80156da:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80156dc:	33b4      	adds	r3, #180	; 0xb4
 80156de:	b29b      	uxth	r3, r3
 80156e0:	84bb      	strh	r3, [r7, #36]	; 0x24
            if(deg_test(deg, start_angle, end_angle)) {
 80156e2:	8cb8      	ldrh	r0, [r7, #36]	; 0x24
 80156e4:	f8b7 2054 	ldrh.w	r2, [r7, #84]	; 0x54
 80156e8:	f8b7 1050 	ldrh.w	r1, [r7, #80]	; 0x50
 80156ec:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80156ee:	4798      	blx	r3
 80156f0:	4603      	mov	r3, r0
 80156f2:	2b00      	cmp	r3, #0
 80156f4:	d007      	beq.n	8015706 <lv_draw_arc+0x256>
                if(x_start[0] == LV_COORD_MIN) x_start[0] = xi;
 80156f6:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 80156fa:	4a3c      	ldr	r2, [pc, #240]	; (80157ec <lv_draw_arc+0x33c>)
 80156fc:	4293      	cmp	r3, r2
 80156fe:	d111      	bne.n	8015724 <lv_draw_arc+0x274>
 8015700:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 8015702:	83bb      	strh	r3, [r7, #28]
 8015704:	e00e      	b.n	8015724 <lv_draw_arc+0x274>
            } else if(x_start[0] != LV_COORD_MIN && x_end[0] == LV_COORD_MIN) {
 8015706:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 801570a:	4a38      	ldr	r2, [pc, #224]	; (80157ec <lv_draw_arc+0x33c>)
 801570c:	4293      	cmp	r3, r2
 801570e:	d009      	beq.n	8015724 <lv_draw_arc+0x274>
 8015710:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8015714:	4a35      	ldr	r2, [pc, #212]	; (80157ec <lv_draw_arc+0x33c>)
 8015716:	4293      	cmp	r3, r2
 8015718:	d104      	bne.n	8015724 <lv_draw_arc+0x274>
                x_end[0] = xi - 1;
 801571a:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 801571c:	3b01      	subs	r3, #1
 801571e:	b29b      	uxth	r3, r3
 8015720:	b21b      	sxth	r3, r3
 8015722:	82bb      	strh	r3, [r7, #20]
            }

            deg = 360 - deg_base;
 8015724:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8015726:	f5c3 73b4 	rsb	r3, r3, #360	; 0x168
 801572a:	b29b      	uxth	r3, r3
 801572c:	84bb      	strh	r3, [r7, #36]	; 0x24
            if(deg_test(deg, start_angle, end_angle)) {
 801572e:	8cb8      	ldrh	r0, [r7, #36]	; 0x24
 8015730:	f8b7 2054 	ldrh.w	r2, [r7, #84]	; 0x54
 8015734:	f8b7 1050 	ldrh.w	r1, [r7, #80]	; 0x50
 8015738:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801573a:	4798      	blx	r3
 801573c:	4603      	mov	r3, r0
 801573e:	2b00      	cmp	r3, #0
 8015740:	d007      	beq.n	8015752 <lv_draw_arc+0x2a2>
                if(x_start[1] == LV_COORD_MIN) x_start[1] = xi;
 8015742:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8015746:	4a29      	ldr	r2, [pc, #164]	; (80157ec <lv_draw_arc+0x33c>)
 8015748:	4293      	cmp	r3, r2
 801574a:	d111      	bne.n	8015770 <lv_draw_arc+0x2c0>
 801574c:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 801574e:	83fb      	strh	r3, [r7, #30]
 8015750:	e00e      	b.n	8015770 <lv_draw_arc+0x2c0>
            } else if(x_start[1] != LV_COORD_MIN && x_end[1] == LV_COORD_MIN) {
 8015752:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8015756:	4a25      	ldr	r2, [pc, #148]	; (80157ec <lv_draw_arc+0x33c>)
 8015758:	4293      	cmp	r3, r2
 801575a:	d009      	beq.n	8015770 <lv_draw_arc+0x2c0>
 801575c:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8015760:	4a22      	ldr	r2, [pc, #136]	; (80157ec <lv_draw_arc+0x33c>)
 8015762:	4293      	cmp	r3, r2
 8015764:	d104      	bne.n	8015770 <lv_draw_arc+0x2c0>
                x_end[1] = xi - 1;
 8015766:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 8015768:	3b01      	subs	r3, #1
 801576a:	b29b      	uxth	r3, r3
 801576c:	b21b      	sxth	r3, r3
 801576e:	82fb      	strh	r3, [r7, #22]
            }

            deg = 180 - deg_base;
 8015770:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8015772:	f1c3 03b4 	rsb	r3, r3, #180	; 0xb4
 8015776:	b29b      	uxth	r3, r3
 8015778:	84bb      	strh	r3, [r7, #36]	; 0x24
            if(deg_test(deg, start_angle, end_angle)) {
 801577a:	8cb8      	ldrh	r0, [r7, #36]	; 0x24
 801577c:	f8b7 2054 	ldrh.w	r2, [r7, #84]	; 0x54
 8015780:	f8b7 1050 	ldrh.w	r1, [r7, #80]	; 0x50
 8015784:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8015786:	4798      	blx	r3
 8015788:	4603      	mov	r3, r0
 801578a:	2b00      	cmp	r3, #0
 801578c:	d007      	beq.n	801579e <lv_draw_arc+0x2ee>
                if(x_start[2] == LV_COORD_MIN) x_start[2] = xi;
 801578e:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 8015792:	4a16      	ldr	r2, [pc, #88]	; (80157ec <lv_draw_arc+0x33c>)
 8015794:	4293      	cmp	r3, r2
 8015796:	d111      	bne.n	80157bc <lv_draw_arc+0x30c>
 8015798:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 801579a:	843b      	strh	r3, [r7, #32]
 801579c:	e00e      	b.n	80157bc <lv_draw_arc+0x30c>
            } else if(x_start[2] != LV_COORD_MIN && x_end[2] == LV_COORD_MIN) {
 801579e:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 80157a2:	4a12      	ldr	r2, [pc, #72]	; (80157ec <lv_draw_arc+0x33c>)
 80157a4:	4293      	cmp	r3, r2
 80157a6:	d009      	beq.n	80157bc <lv_draw_arc+0x30c>
 80157a8:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 80157ac:	4a0f      	ldr	r2, [pc, #60]	; (80157ec <lv_draw_arc+0x33c>)
 80157ae:	4293      	cmp	r3, r2
 80157b0:	d104      	bne.n	80157bc <lv_draw_arc+0x30c>
                x_end[2] = xi - 1;
 80157b2:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 80157b4:	3b01      	subs	r3, #1
 80157b6:	b29b      	uxth	r3, r3
 80157b8:	b21b      	sxth	r3, r3
 80157ba:	833b      	strh	r3, [r7, #24]
            }

            deg = deg_base;
 80157bc:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80157be:	84bb      	strh	r3, [r7, #36]	; 0x24
            if(deg_test(deg, start_angle, end_angle)) {
 80157c0:	8cb8      	ldrh	r0, [r7, #36]	; 0x24
 80157c2:	f8b7 2054 	ldrh.w	r2, [r7, #84]	; 0x54
 80157c6:	f8b7 1050 	ldrh.w	r1, [r7, #80]	; 0x50
 80157ca:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80157cc:	4798      	blx	r3
 80157ce:	4603      	mov	r3, r0
 80157d0:	2b00      	cmp	r3, #0
 80157d2:	d00d      	beq.n	80157f0 <lv_draw_arc+0x340>
                if(x_start[3] == LV_COORD_MIN) x_start[3] = xi;
 80157d4:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 80157d8:	4a04      	ldr	r2, [pc, #16]	; (80157ec <lv_draw_arc+0x33c>)
 80157da:	4293      	cmp	r3, r2
 80157dc:	d117      	bne.n	801580e <lv_draw_arc+0x35e>
 80157de:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 80157e0:	847b      	strh	r3, [r7, #34]	; 0x22
 80157e2:	e014      	b.n	801580e <lv_draw_arc+0x35e>
 80157e4:	08015bb1 	.word	0x08015bb1
 80157e8:	08015be5 	.word	0x08015be5
 80157ec:	ffff83e8 	.word	0xffff83e8
            } else if(x_start[3] != LV_COORD_MIN && x_end[3] == LV_COORD_MIN) {
 80157f0:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 80157f4:	4a74      	ldr	r2, [pc, #464]	; (80159c8 <lv_draw_arc+0x518>)
 80157f6:	4293      	cmp	r3, r2
 80157f8:	d009      	beq.n	801580e <lv_draw_arc+0x35e>
 80157fa:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80157fe:	4a72      	ldr	r2, [pc, #456]	; (80159c8 <lv_draw_arc+0x518>)
 8015800:	4293      	cmp	r3, r2
 8015802:	d104      	bne.n	801580e <lv_draw_arc+0x35e>
                x_end[3] = xi - 1;
 8015804:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 8015806:	3b01      	subs	r3, #1
 8015808:	b29b      	uxth	r3, r3
 801580a:	b21b      	sxth	r3, r3
 801580c:	837b      	strh	r3, [r7, #26]
            }

            if(r_act_sqr < r_in_sqr)
 801580e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8015810:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015812:	429a      	cmp	r2, r3
 8015814:	d30d      	bcc.n	8015832 <lv_draw_arc+0x382>
 8015816:	e000      	b.n	801581a <lv_draw_arc+0x36a>
            if(r_act_sqr > r_out_sqr) continue;
 8015818:	bf00      	nop
        for(xi = -r_out; xi < 0; xi++) {
 801581a:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 801581e:	b29b      	uxth	r3, r3
 8015820:	3301      	adds	r3, #1
 8015822:	b29b      	uxth	r3, r3
 8015824:	87fb      	strh	r3, [r7, #62]	; 0x3e
 8015826:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 801582a:	2b00      	cmp	r3, #0
 801582c:	f6ff af36 	blt.w	801569c <lv_draw_arc+0x1ec>
 8015830:	e000      	b.n	8015834 <lv_draw_arc+0x384>
                break; /*No need to continue the iteration in x once we found the inner edge of the
 8015832:	bf00      	nop
                          arc*/
        }

        if(x_start[0] != LV_COORD_MIN) {
 8015834:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 8015838:	4a63      	ldr	r2, [pc, #396]	; (80159c8 <lv_draw_arc+0x518>)
 801583a:	4293      	cmp	r3, r2
 801583c:	d028      	beq.n	8015890 <lv_draw_arc+0x3e0>
            if(x_end[0] == LV_COORD_MIN) x_end[0] = xi - 1;
 801583e:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8015842:	4a61      	ldr	r2, [pc, #388]	; (80159c8 <lv_draw_arc+0x518>)
 8015844:	4293      	cmp	r3, r2
 8015846:	d104      	bne.n	8015852 <lv_draw_arc+0x3a2>
 8015848:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 801584a:	3b01      	subs	r3, #1
 801584c:	b29b      	uxth	r3, r3
 801584e:	b21b      	sxth	r3, r3
 8015850:	82bb      	strh	r3, [r7, #20]
            hor_line(center_x + x_start[0], center_y + yi, mask, x_end[0] - x_start[0], color, opa);
 8015852:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 8015856:	b29a      	uxth	r2, r3
 8015858:	89fb      	ldrh	r3, [r7, #14]
 801585a:	4413      	add	r3, r2
 801585c:	b29b      	uxth	r3, r3
 801585e:	b218      	sxth	r0, r3
 8015860:	89ba      	ldrh	r2, [r7, #12]
 8015862:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 8015864:	4413      	add	r3, r2
 8015866:	b29b      	uxth	r3, r3
 8015868:	b219      	sxth	r1, r3
 801586a:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 801586e:	b29a      	uxth	r2, r3
 8015870:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 8015874:	b29b      	uxth	r3, r3
 8015876:	1ad3      	subs	r3, r2, r3
 8015878:	b29b      	uxth	r3, r3
 801587a:	b21a      	sxth	r2, r3
 801587c:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8015880:	9301      	str	r3, [sp, #4]
 8015882:	8a3b      	ldrh	r3, [r7, #16]
 8015884:	f8ad 3000 	strh.w	r3, [sp]
 8015888:	4613      	mov	r3, r2
 801588a:	687a      	ldr	r2, [r7, #4]
 801588c:	f000 f968 	bl	8015b60 <hor_line>
        }

        if(x_start[1] != LV_COORD_MIN) {
 8015890:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8015894:	4a4c      	ldr	r2, [pc, #304]	; (80159c8 <lv_draw_arc+0x518>)
 8015896:	4293      	cmp	r3, r2
 8015898:	d028      	beq.n	80158ec <lv_draw_arc+0x43c>
            if(x_end[1] == LV_COORD_MIN) x_end[1] = xi - 1;
 801589a:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 801589e:	4a4a      	ldr	r2, [pc, #296]	; (80159c8 <lv_draw_arc+0x518>)
 80158a0:	4293      	cmp	r3, r2
 80158a2:	d104      	bne.n	80158ae <lv_draw_arc+0x3fe>
 80158a4:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 80158a6:	3b01      	subs	r3, #1
 80158a8:	b29b      	uxth	r3, r3
 80158aa:	b21b      	sxth	r3, r3
 80158ac:	82fb      	strh	r3, [r7, #22]
            hor_line(center_x + x_start[1], center_y - yi, mask, x_end[1] - x_start[1], color, opa);
 80158ae:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 80158b2:	b29a      	uxth	r2, r3
 80158b4:	89fb      	ldrh	r3, [r7, #14]
 80158b6:	4413      	add	r3, r2
 80158b8:	b29b      	uxth	r3, r3
 80158ba:	b218      	sxth	r0, r3
 80158bc:	89ba      	ldrh	r2, [r7, #12]
 80158be:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 80158c0:	1ad3      	subs	r3, r2, r3
 80158c2:	b29b      	uxth	r3, r3
 80158c4:	b219      	sxth	r1, r3
 80158c6:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 80158ca:	b29a      	uxth	r2, r3
 80158cc:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 80158d0:	b29b      	uxth	r3, r3
 80158d2:	1ad3      	subs	r3, r2, r3
 80158d4:	b29b      	uxth	r3, r3
 80158d6:	b21a      	sxth	r2, r3
 80158d8:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80158dc:	9301      	str	r3, [sp, #4]
 80158de:	8a3b      	ldrh	r3, [r7, #16]
 80158e0:	f8ad 3000 	strh.w	r3, [sp]
 80158e4:	4613      	mov	r3, r2
 80158e6:	687a      	ldr	r2, [r7, #4]
 80158e8:	f000 f93a 	bl	8015b60 <hor_line>
        }

        if(x_start[2] != LV_COORD_MIN) {
 80158ec:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 80158f0:	4a35      	ldr	r2, [pc, #212]	; (80159c8 <lv_draw_arc+0x518>)
 80158f2:	4293      	cmp	r3, r2
 80158f4:	d029      	beq.n	801594a <lv_draw_arc+0x49a>
            if(x_end[2] == LV_COORD_MIN) x_end[2] = xi - 1;
 80158f6:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 80158fa:	4a33      	ldr	r2, [pc, #204]	; (80159c8 <lv_draw_arc+0x518>)
 80158fc:	4293      	cmp	r3, r2
 80158fe:	d104      	bne.n	801590a <lv_draw_arc+0x45a>
 8015900:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 8015902:	3b01      	subs	r3, #1
 8015904:	b29b      	uxth	r3, r3
 8015906:	b21b      	sxth	r3, r3
 8015908:	833b      	strh	r3, [r7, #24]
            hor_line(center_x - x_end[2], center_y + yi, mask, LV_MATH_ABS(x_end[2] - x_start[2]), color, opa);
 801590a:	89fa      	ldrh	r2, [r7, #14]
 801590c:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8015910:	b29b      	uxth	r3, r3
 8015912:	1ad3      	subs	r3, r2, r3
 8015914:	b29b      	uxth	r3, r3
 8015916:	b218      	sxth	r0, r3
 8015918:	89ba      	ldrh	r2, [r7, #12]
 801591a:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 801591c:	4413      	add	r3, r2
 801591e:	b29b      	uxth	r3, r3
 8015920:	b219      	sxth	r1, r3
 8015922:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8015926:	461a      	mov	r2, r3
 8015928:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 801592c:	1ad3      	subs	r3, r2, r3
 801592e:	2b00      	cmp	r3, #0
 8015930:	bfb8      	it	lt
 8015932:	425b      	neglt	r3, r3
 8015934:	b21a      	sxth	r2, r3
 8015936:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801593a:	9301      	str	r3, [sp, #4]
 801593c:	8a3b      	ldrh	r3, [r7, #16]
 801593e:	f8ad 3000 	strh.w	r3, [sp]
 8015942:	4613      	mov	r3, r2
 8015944:	687a      	ldr	r2, [r7, #4]
 8015946:	f000 f90b 	bl	8015b60 <hor_line>
        }

        if(x_start[3] != LV_COORD_MIN) {
 801594a:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 801594e:	4a1e      	ldr	r2, [pc, #120]	; (80159c8 <lv_draw_arc+0x518>)
 8015950:	4293      	cmp	r3, r2
 8015952:	d029      	beq.n	80159a8 <lv_draw_arc+0x4f8>
            if(x_end[3] == LV_COORD_MIN) x_end[3] = xi - 1;
 8015954:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8015958:	4a1b      	ldr	r2, [pc, #108]	; (80159c8 <lv_draw_arc+0x518>)
 801595a:	4293      	cmp	r3, r2
 801595c:	d104      	bne.n	8015968 <lv_draw_arc+0x4b8>
 801595e:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 8015960:	3b01      	subs	r3, #1
 8015962:	b29b      	uxth	r3, r3
 8015964:	b21b      	sxth	r3, r3
 8015966:	837b      	strh	r3, [r7, #26]
            hor_line(center_x - x_end[3], center_y - yi, mask, LV_MATH_ABS(x_end[3] - x_start[3]), color, opa);
 8015968:	89fa      	ldrh	r2, [r7, #14]
 801596a:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 801596e:	b29b      	uxth	r3, r3
 8015970:	1ad3      	subs	r3, r2, r3
 8015972:	b29b      	uxth	r3, r3
 8015974:	b218      	sxth	r0, r3
 8015976:	89ba      	ldrh	r2, [r7, #12]
 8015978:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 801597a:	1ad3      	subs	r3, r2, r3
 801597c:	b29b      	uxth	r3, r3
 801597e:	b219      	sxth	r1, r3
 8015980:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8015984:	461a      	mov	r2, r3
 8015986:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 801598a:	1ad3      	subs	r3, r2, r3
 801598c:	2b00      	cmp	r3, #0
 801598e:	bfb8      	it	lt
 8015990:	425b      	neglt	r3, r3
 8015992:	b21a      	sxth	r2, r3
 8015994:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8015998:	9301      	str	r3, [sp, #4]
 801599a:	8a3b      	ldrh	r3, [r7, #16]
 801599c:	f8ad 3000 	strh.w	r3, [sp]
 80159a0:	4613      	mov	r3, r2
 80159a2:	687a      	ldr	r2, [r7, #4]
 80159a4:	f000 f8dc 	bl	8015b60 <hor_line>
    for(yi = -r_out; yi < 0; yi++) {
 80159a8:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 80159ac:	b29b      	uxth	r3, r3
 80159ae:	3301      	adds	r3, #1
 80159b0:	b29b      	uxth	r3, r3
 80159b2:	87bb      	strh	r3, [r7, #60]	; 0x3c
 80159b4:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 80159b8:	2b00      	cmp	r3, #0
 80159ba:	f6ff ae52 	blt.w	8015662 <lv_draw_arc+0x1b2>
#if LV_ANTIALIAS
        /*TODO*/

#endif
    }
}
 80159be:	bf00      	nop
 80159c0:	bf00      	nop
 80159c2:	3748      	adds	r7, #72	; 0x48
 80159c4:	46bd      	mov	sp, r7
 80159c6:	bd80      	pop	{r7, pc}
 80159c8:	ffff83e8 	.word	0xffff83e8

080159cc <fast_atan2>:

static uint16_t fast_atan2(int x, int y)
{
 80159cc:	b480      	push	{r7}
 80159ce:	b089      	sub	sp, #36	; 0x24
 80159d0:	af00      	add	r7, sp, #0
 80159d2:	6078      	str	r0, [r7, #4]
 80159d4:	6039      	str	r1, [r7, #0]
    unsigned int degree; /*this will hold the result*/
    unsigned int ux;
    unsigned int uy;

    /*Save the sign flags then remove signs and get XY as unsigned ints*/
    negflag = 0;
 80159d6:	2300      	movs	r3, #0
 80159d8:	77fb      	strb	r3, [r7, #31]
    if(x < 0) {
 80159da:	687b      	ldr	r3, [r7, #4]
 80159dc:	2b00      	cmp	r3, #0
 80159de:	da05      	bge.n	80159ec <fast_atan2+0x20>
        negflag += 0x01; /*x flag bit*/
 80159e0:	7ffb      	ldrb	r3, [r7, #31]
 80159e2:	3301      	adds	r3, #1
 80159e4:	77fb      	strb	r3, [r7, #31]
        x = (0 - x);     /*is now +*/
 80159e6:	687b      	ldr	r3, [r7, #4]
 80159e8:	425b      	negs	r3, r3
 80159ea:	607b      	str	r3, [r7, #4]
    }
    ux = x; /*copy to unsigned var before multiply*/
 80159ec:	687b      	ldr	r3, [r7, #4]
 80159ee:	617b      	str	r3, [r7, #20]
    if(y < 0) {
 80159f0:	683b      	ldr	r3, [r7, #0]
 80159f2:	2b00      	cmp	r3, #0
 80159f4:	da05      	bge.n	8015a02 <fast_atan2+0x36>
        negflag += 0x02; /*y flag bit*/
 80159f6:	7ffb      	ldrb	r3, [r7, #31]
 80159f8:	3302      	adds	r3, #2
 80159fa:	77fb      	strb	r3, [r7, #31]
        y = (0 - y);     /*is now +*/
 80159fc:	683b      	ldr	r3, [r7, #0]
 80159fe:	425b      	negs	r3, r3
 8015a00:	603b      	str	r3, [r7, #0]
    }
    uy = y; /*copy to unsigned var before multiply*/
 8015a02:	683b      	ldr	r3, [r7, #0]
 8015a04:	613b      	str	r3, [r7, #16]

    /*1. Calc the scaled "degrees"*/
    if(ux > uy) {
 8015a06:	697a      	ldr	r2, [r7, #20]
 8015a08:	693b      	ldr	r3, [r7, #16]
 8015a0a:	429a      	cmp	r2, r3
 8015a0c:	d90d      	bls.n	8015a2a <fast_atan2+0x5e>
        degree = (uy * 45) / ux; /*degree result will be 0-45 range*/
 8015a0e:	693a      	ldr	r2, [r7, #16]
 8015a10:	4613      	mov	r3, r2
 8015a12:	005b      	lsls	r3, r3, #1
 8015a14:	4413      	add	r3, r2
 8015a16:	011a      	lsls	r2, r3, #4
 8015a18:	1ad2      	subs	r2, r2, r3
 8015a1a:	697b      	ldr	r3, [r7, #20]
 8015a1c:	fbb2 f3f3 	udiv	r3, r2, r3
 8015a20:	61bb      	str	r3, [r7, #24]
        negflag += 0x10;         /*octant flag bit*/
 8015a22:	7ffb      	ldrb	r3, [r7, #31]
 8015a24:	3310      	adds	r3, #16
 8015a26:	77fb      	strb	r3, [r7, #31]
 8015a28:	e009      	b.n	8015a3e <fast_atan2+0x72>
    } else {
        degree = (ux * 45) / uy; /*degree result will be 0-45 range*/
 8015a2a:	697a      	ldr	r2, [r7, #20]
 8015a2c:	4613      	mov	r3, r2
 8015a2e:	005b      	lsls	r3, r3, #1
 8015a30:	4413      	add	r3, r2
 8015a32:	011a      	lsls	r2, r3, #4
 8015a34:	1ad2      	subs	r2, r2, r3
 8015a36:	693b      	ldr	r3, [r7, #16]
 8015a38:	fbb2 f3f3 	udiv	r3, r2, r3
 8015a3c:	61bb      	str	r3, [r7, #24]
    }

    /*2. Compensate for the 4 degree error curve*/
    comp       = 0;
 8015a3e:	2300      	movs	r3, #0
 8015a40:	77bb      	strb	r3, [r7, #30]
    tempdegree = degree;  /*use an unsigned char for speed!*/
 8015a42:	69bb      	ldr	r3, [r7, #24]
 8015a44:	73fb      	strb	r3, [r7, #15]
    if(tempdegree > 22) { /*if top half of range*/
 8015a46:	7bfb      	ldrb	r3, [r7, #15]
 8015a48:	2b16      	cmp	r3, #22
 8015a4a:	d918      	bls.n	8015a7e <fast_atan2+0xb2>
        if(tempdegree <= 44) comp++;
 8015a4c:	7bfb      	ldrb	r3, [r7, #15]
 8015a4e:	2b2c      	cmp	r3, #44	; 0x2c
 8015a50:	d802      	bhi.n	8015a58 <fast_atan2+0x8c>
 8015a52:	7fbb      	ldrb	r3, [r7, #30]
 8015a54:	3301      	adds	r3, #1
 8015a56:	77bb      	strb	r3, [r7, #30]
        if(tempdegree <= 41) comp++;
 8015a58:	7bfb      	ldrb	r3, [r7, #15]
 8015a5a:	2b29      	cmp	r3, #41	; 0x29
 8015a5c:	d802      	bhi.n	8015a64 <fast_atan2+0x98>
 8015a5e:	7fbb      	ldrb	r3, [r7, #30]
 8015a60:	3301      	adds	r3, #1
 8015a62:	77bb      	strb	r3, [r7, #30]
        if(tempdegree <= 37) comp++;
 8015a64:	7bfb      	ldrb	r3, [r7, #15]
 8015a66:	2b25      	cmp	r3, #37	; 0x25
 8015a68:	d802      	bhi.n	8015a70 <fast_atan2+0xa4>
 8015a6a:	7fbb      	ldrb	r3, [r7, #30]
 8015a6c:	3301      	adds	r3, #1
 8015a6e:	77bb      	strb	r3, [r7, #30]
        if(tempdegree <= 32) comp++; /*max is 4 degrees compensated*/
 8015a70:	7bfb      	ldrb	r3, [r7, #15]
 8015a72:	2b20      	cmp	r3, #32
 8015a74:	d81b      	bhi.n	8015aae <fast_atan2+0xe2>
 8015a76:	7fbb      	ldrb	r3, [r7, #30]
 8015a78:	3301      	adds	r3, #1
 8015a7a:	77bb      	strb	r3, [r7, #30]
 8015a7c:	e017      	b.n	8015aae <fast_atan2+0xe2>
    } else {                         /*else is lower half of range*/
        if(tempdegree >= 2) comp++;
 8015a7e:	7bfb      	ldrb	r3, [r7, #15]
 8015a80:	2b01      	cmp	r3, #1
 8015a82:	d902      	bls.n	8015a8a <fast_atan2+0xbe>
 8015a84:	7fbb      	ldrb	r3, [r7, #30]
 8015a86:	3301      	adds	r3, #1
 8015a88:	77bb      	strb	r3, [r7, #30]
        if(tempdegree >= 6) comp++;
 8015a8a:	7bfb      	ldrb	r3, [r7, #15]
 8015a8c:	2b05      	cmp	r3, #5
 8015a8e:	d902      	bls.n	8015a96 <fast_atan2+0xca>
 8015a90:	7fbb      	ldrb	r3, [r7, #30]
 8015a92:	3301      	adds	r3, #1
 8015a94:	77bb      	strb	r3, [r7, #30]
        if(tempdegree >= 10) comp++;
 8015a96:	7bfb      	ldrb	r3, [r7, #15]
 8015a98:	2b09      	cmp	r3, #9
 8015a9a:	d902      	bls.n	8015aa2 <fast_atan2+0xd6>
 8015a9c:	7fbb      	ldrb	r3, [r7, #30]
 8015a9e:	3301      	adds	r3, #1
 8015aa0:	77bb      	strb	r3, [r7, #30]
        if(tempdegree >= 15) comp++; /*max is 4 degrees compensated*/
 8015aa2:	7bfb      	ldrb	r3, [r7, #15]
 8015aa4:	2b0e      	cmp	r3, #14
 8015aa6:	d902      	bls.n	8015aae <fast_atan2+0xe2>
 8015aa8:	7fbb      	ldrb	r3, [r7, #30]
 8015aaa:	3301      	adds	r3, #1
 8015aac:	77bb      	strb	r3, [r7, #30]
    }
    degree += comp; /*degree is now accurate to +/- 1 degree!*/
 8015aae:	7fbb      	ldrb	r3, [r7, #30]
 8015ab0:	69ba      	ldr	r2, [r7, #24]
 8015ab2:	4413      	add	r3, r2
 8015ab4:	61bb      	str	r3, [r7, #24]

    /*Invert degree if it was X>Y octant, makes 0-45 into 90-45*/
      if(negflag & 0x10) degree = (90 - degree);
 8015ab6:	7ffb      	ldrb	r3, [r7, #31]
 8015ab8:	f003 0310 	and.w	r3, r3, #16
 8015abc:	2b00      	cmp	r3, #0
 8015abe:	d003      	beq.n	8015ac8 <fast_atan2+0xfc>
 8015ac0:	69bb      	ldr	r3, [r7, #24]
 8015ac2:	f1c3 035a 	rsb	r3, r3, #90	; 0x5a
 8015ac6:	61bb      	str	r3, [r7, #24]

    /*3. Degree is now 0-90 range for this quadrant,*/
    /*need to invert it for whichever quadrant it was in*/
    if(negflag & 0x02) {   /*if -Y*/
 8015ac8:	7ffb      	ldrb	r3, [r7, #31]
 8015aca:	f003 0302 	and.w	r3, r3, #2
 8015ace:	2b00      	cmp	r3, #0
 8015ad0:	d00d      	beq.n	8015aee <fast_atan2+0x122>
        if(negflag & 0x01) /*if -Y -X*/
 8015ad2:	7ffb      	ldrb	r3, [r7, #31]
 8015ad4:	f003 0301 	and.w	r3, r3, #1
 8015ad8:	2b00      	cmp	r3, #0
 8015ada:	d003      	beq.n	8015ae4 <fast_atan2+0x118>
            degree = (180 + degree);
 8015adc:	69bb      	ldr	r3, [r7, #24]
 8015ade:	33b4      	adds	r3, #180	; 0xb4
 8015ae0:	61bb      	str	r3, [r7, #24]
 8015ae2:	e00d      	b.n	8015b00 <fast_atan2+0x134>
        else /*else is -Y +X*/
            degree = (180 - degree);
 8015ae4:	69bb      	ldr	r3, [r7, #24]
 8015ae6:	f1c3 03b4 	rsb	r3, r3, #180	; 0xb4
 8015aea:	61bb      	str	r3, [r7, #24]
 8015aec:	e008      	b.n	8015b00 <fast_atan2+0x134>
    } else {               /*else is +Y*/
        if(negflag & 0x01) /*if +Y -X*/
 8015aee:	7ffb      	ldrb	r3, [r7, #31]
 8015af0:	f003 0301 	and.w	r3, r3, #1
 8015af4:	2b00      	cmp	r3, #0
 8015af6:	d003      	beq.n	8015b00 <fast_atan2+0x134>
            degree = (360 - degree);
 8015af8:	69bb      	ldr	r3, [r7, #24]
 8015afa:	f5c3 73b4 	rsb	r3, r3, #360	; 0x168
 8015afe:	61bb      	str	r3, [r7, #24]
    }
    return degree;
 8015b00:	69bb      	ldr	r3, [r7, #24]
 8015b02:	b29b      	uxth	r3, r3
}
 8015b04:	4618      	mov	r0, r3
 8015b06:	3724      	adds	r7, #36	; 0x24
 8015b08:	46bd      	mov	sp, r7
 8015b0a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015b0e:	4770      	bx	lr

08015b10 <ver_line>:

/**********************
 *   STATIC FUNCTIONS
 **********************/
static void ver_line(lv_coord_t x, lv_coord_t y, const lv_area_t * mask, lv_coord_t len, lv_color_t color, lv_opa_t opa)
{
 8015b10:	b590      	push	{r4, r7, lr}
 8015b12:	b089      	sub	sp, #36	; 0x24
 8015b14:	af02      	add	r7, sp, #8
 8015b16:	60ba      	str	r2, [r7, #8]
 8015b18:	461a      	mov	r2, r3
 8015b1a:	4603      	mov	r3, r0
 8015b1c:	81fb      	strh	r3, [r7, #14]
 8015b1e:	460b      	mov	r3, r1
 8015b20:	81bb      	strh	r3, [r7, #12]
 8015b22:	4613      	mov	r3, r2
 8015b24:	80fb      	strh	r3, [r7, #6]
    lv_area_t area;
    lv_area_set(&area, x, y, x, y + len);
 8015b26:	89ba      	ldrh	r2, [r7, #12]
 8015b28:	88fb      	ldrh	r3, [r7, #6]
 8015b2a:	4413      	add	r3, r2
 8015b2c:	b29b      	uxth	r3, r3
 8015b2e:	b21b      	sxth	r3, r3
 8015b30:	f9b7 400e 	ldrsh.w	r4, [r7, #14]
 8015b34:	f9b7 200c 	ldrsh.w	r2, [r7, #12]
 8015b38:	f9b7 100e 	ldrsh.w	r1, [r7, #14]
 8015b3c:	f107 0010 	add.w	r0, r7, #16
 8015b40:	9300      	str	r3, [sp, #0]
 8015b42:	4623      	mov	r3, r4
 8015b44:	f007 fe10 	bl	801d768 <lv_area_set>

    lv_draw_fill(&area, mask, color, opa);
 8015b48:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 8015b4c:	f107 0010 	add.w	r0, r7, #16
 8015b50:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
 8015b52:	68b9      	ldr	r1, [r7, #8]
 8015b54:	f000 f980 	bl	8015e58 <lv_draw_fill>
}
 8015b58:	bf00      	nop
 8015b5a:	371c      	adds	r7, #28
 8015b5c:	46bd      	mov	sp, r7
 8015b5e:	bd90      	pop	{r4, r7, pc}

08015b60 <hor_line>:

static void hor_line(lv_coord_t x, lv_coord_t y, const lv_area_t * mask, lv_coord_t len, lv_color_t color, lv_opa_t opa)
{
 8015b60:	b590      	push	{r4, r7, lr}
 8015b62:	b089      	sub	sp, #36	; 0x24
 8015b64:	af02      	add	r7, sp, #8
 8015b66:	60ba      	str	r2, [r7, #8]
 8015b68:	461a      	mov	r2, r3
 8015b6a:	4603      	mov	r3, r0
 8015b6c:	81fb      	strh	r3, [r7, #14]
 8015b6e:	460b      	mov	r3, r1
 8015b70:	81bb      	strh	r3, [r7, #12]
 8015b72:	4613      	mov	r3, r2
 8015b74:	80fb      	strh	r3, [r7, #6]
    lv_area_t area;
    lv_area_set(&area, x, y, x + len, y);
 8015b76:	89fa      	ldrh	r2, [r7, #14]
 8015b78:	88fb      	ldrh	r3, [r7, #6]
 8015b7a:	4413      	add	r3, r2
 8015b7c:	b29b      	uxth	r3, r3
 8015b7e:	b21c      	sxth	r4, r3
 8015b80:	f9b7 200c 	ldrsh.w	r2, [r7, #12]
 8015b84:	f9b7 100e 	ldrsh.w	r1, [r7, #14]
 8015b88:	f107 0010 	add.w	r0, r7, #16
 8015b8c:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8015b90:	9300      	str	r3, [sp, #0]
 8015b92:	4623      	mov	r3, r4
 8015b94:	f007 fde8 	bl	801d768 <lv_area_set>

    lv_draw_fill(&area, mask, color, opa);
 8015b98:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 8015b9c:	f107 0010 	add.w	r0, r7, #16
 8015ba0:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
 8015ba2:	68b9      	ldr	r1, [r7, #8]
 8015ba4:	f000 f958 	bl	8015e58 <lv_draw_fill>
}
 8015ba8:	bf00      	nop
 8015baa:	371c      	adds	r7, #28
 8015bac:	46bd      	mov	sp, r7
 8015bae:	bd90      	pop	{r4, r7, pc}

08015bb0 <deg_test_norm>:

static bool deg_test_norm(uint16_t deg, uint16_t start, uint16_t end)
{
 8015bb0:	b480      	push	{r7}
 8015bb2:	b083      	sub	sp, #12
 8015bb4:	af00      	add	r7, sp, #0
 8015bb6:	4603      	mov	r3, r0
 8015bb8:	80fb      	strh	r3, [r7, #6]
 8015bba:	460b      	mov	r3, r1
 8015bbc:	80bb      	strh	r3, [r7, #4]
 8015bbe:	4613      	mov	r3, r2
 8015bc0:	807b      	strh	r3, [r7, #2]
    if(deg >= start && deg <= end)
 8015bc2:	88fa      	ldrh	r2, [r7, #6]
 8015bc4:	88bb      	ldrh	r3, [r7, #4]
 8015bc6:	429a      	cmp	r2, r3
 8015bc8:	d305      	bcc.n	8015bd6 <deg_test_norm+0x26>
 8015bca:	88fa      	ldrh	r2, [r7, #6]
 8015bcc:	887b      	ldrh	r3, [r7, #2]
 8015bce:	429a      	cmp	r2, r3
 8015bd0:	d801      	bhi.n	8015bd6 <deg_test_norm+0x26>
        return true;
 8015bd2:	2301      	movs	r3, #1
 8015bd4:	e000      	b.n	8015bd8 <deg_test_norm+0x28>
    else
        return false;
 8015bd6:	2300      	movs	r3, #0
}
 8015bd8:	4618      	mov	r0, r3
 8015bda:	370c      	adds	r7, #12
 8015bdc:	46bd      	mov	sp, r7
 8015bde:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015be2:	4770      	bx	lr

08015be4 <deg_test_inv>:

static bool deg_test_inv(uint16_t deg, uint16_t start, uint16_t end)
{
 8015be4:	b480      	push	{r7}
 8015be6:	b083      	sub	sp, #12
 8015be8:	af00      	add	r7, sp, #0
 8015bea:	4603      	mov	r3, r0
 8015bec:	80fb      	strh	r3, [r7, #6]
 8015bee:	460b      	mov	r3, r1
 8015bf0:	80bb      	strh	r3, [r7, #4]
 8015bf2:	4613      	mov	r3, r2
 8015bf4:	807b      	strh	r3, [r7, #2]
    if(deg >= start || deg <= end) {
 8015bf6:	88fa      	ldrh	r2, [r7, #6]
 8015bf8:	88bb      	ldrh	r3, [r7, #4]
 8015bfa:	429a      	cmp	r2, r3
 8015bfc:	d203      	bcs.n	8015c06 <deg_test_inv+0x22>
 8015bfe:	88fa      	ldrh	r2, [r7, #6]
 8015c00:	887b      	ldrh	r3, [r7, #2]
 8015c02:	429a      	cmp	r2, r3
 8015c04:	d801      	bhi.n	8015c0a <deg_test_inv+0x26>
        return true;
 8015c06:	2301      	movs	r3, #1
 8015c08:	e000      	b.n	8015c0c <deg_test_inv+0x28>
    } else
        return false;
 8015c0a:	2300      	movs	r3, #0
}
 8015c0c:	4618      	mov	r0, r3
 8015c0e:	370c      	adds	r7, #12
 8015c10:	46bd      	mov	sp, r7
 8015c12:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015c16:	4770      	bx	lr

08015c18 <lv_color_mix>:
    return color.full;
#endif
}

static inline lv_color_t lv_color_mix(lv_color_t c1, lv_color_t c2, uint8_t mix)
{
 8015c18:	b480      	push	{r7}
 8015c1a:	b085      	sub	sp, #20
 8015c1c:	af00      	add	r7, sp, #0
 8015c1e:	80b8      	strh	r0, [r7, #4]
 8015c20:	8039      	strh	r1, [r7, #0]
 8015c22:	4613      	mov	r3, r2
 8015c24:	70fb      	strb	r3, [r7, #3]
    lv_color_t ret;
#if LV_COLOR_DEPTH != 1
    /*LV_COLOR_DEPTH == 8, 16 or 32*/
    ret.ch.red = (uint16_t)((uint16_t)c1.ch.red * mix + (c2.ch.red * (255 - mix))) >> 8;
 8015c26:	797b      	ldrb	r3, [r7, #5]
 8015c28:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8015c2c:	b2db      	uxtb	r3, r3
 8015c2e:	b29a      	uxth	r2, r3
 8015c30:	78fb      	ldrb	r3, [r7, #3]
 8015c32:	b29b      	uxth	r3, r3
 8015c34:	fb12 f303 	smulbb	r3, r2, r3
 8015c38:	b29a      	uxth	r2, r3
 8015c3a:	787b      	ldrb	r3, [r7, #1]
 8015c3c:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8015c40:	b2db      	uxtb	r3, r3
 8015c42:	b299      	uxth	r1, r3
 8015c44:	78fb      	ldrb	r3, [r7, #3]
 8015c46:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8015c4a:	b29b      	uxth	r3, r3
 8015c4c:	fb11 f303 	smulbb	r3, r1, r3
 8015c50:	b29b      	uxth	r3, r3
 8015c52:	4413      	add	r3, r2
 8015c54:	b29b      	uxth	r3, r3
 8015c56:	0a1b      	lsrs	r3, r3, #8
 8015c58:	b29b      	uxth	r3, r3
 8015c5a:	f003 031f 	and.w	r3, r3, #31
 8015c5e:	b2da      	uxtb	r2, r3
 8015c60:	7b7b      	ldrb	r3, [r7, #13]
 8015c62:	f362 03c7 	bfi	r3, r2, #3, #5
 8015c66:	737b      	strb	r3, [r7, #13]
    uint16_t g_2   = (c2.ch.green_h << 3) + c2.ch.green_l;
    uint16_t g_out = (uint16_t)((uint16_t)g_1 * mix + (g_2 * (255 - mix))) >> 8;
    ret.ch.green_h = g_out >> 3;
    ret.ch.green_l = g_out & 0x7;
#else
    ret.ch.green = (uint16_t)((uint16_t)c1.ch.green * mix + (c2.ch.green * (255 - mix))) >> 8;
 8015c68:	88bb      	ldrh	r3, [r7, #4]
 8015c6a:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8015c6e:	b2db      	uxtb	r3, r3
 8015c70:	b29a      	uxth	r2, r3
 8015c72:	78fb      	ldrb	r3, [r7, #3]
 8015c74:	b29b      	uxth	r3, r3
 8015c76:	fb12 f303 	smulbb	r3, r2, r3
 8015c7a:	b29a      	uxth	r2, r3
 8015c7c:	883b      	ldrh	r3, [r7, #0]
 8015c7e:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8015c82:	b2db      	uxtb	r3, r3
 8015c84:	b299      	uxth	r1, r3
 8015c86:	78fb      	ldrb	r3, [r7, #3]
 8015c88:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8015c8c:	b29b      	uxth	r3, r3
 8015c8e:	fb11 f303 	smulbb	r3, r1, r3
 8015c92:	b29b      	uxth	r3, r3
 8015c94:	4413      	add	r3, r2
 8015c96:	b29b      	uxth	r3, r3
 8015c98:	0a1b      	lsrs	r3, r3, #8
 8015c9a:	b29b      	uxth	r3, r3
 8015c9c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8015ca0:	b2da      	uxtb	r2, r3
 8015ca2:	89bb      	ldrh	r3, [r7, #12]
 8015ca4:	f362 134a 	bfi	r3, r2, #5, #6
 8015ca8:	81bb      	strh	r3, [r7, #12]
#endif
    ret.ch.blue = (uint16_t)((uint16_t)c1.ch.blue * mix + (c2.ch.blue * (255 - mix))) >> 8;
 8015caa:	793b      	ldrb	r3, [r7, #4]
 8015cac:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8015cb0:	b2db      	uxtb	r3, r3
 8015cb2:	b29a      	uxth	r2, r3
 8015cb4:	78fb      	ldrb	r3, [r7, #3]
 8015cb6:	b29b      	uxth	r3, r3
 8015cb8:	fb12 f303 	smulbb	r3, r2, r3
 8015cbc:	b29a      	uxth	r2, r3
 8015cbe:	783b      	ldrb	r3, [r7, #0]
 8015cc0:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8015cc4:	b2db      	uxtb	r3, r3
 8015cc6:	b299      	uxth	r1, r3
 8015cc8:	78fb      	ldrb	r3, [r7, #3]
 8015cca:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8015cce:	b29b      	uxth	r3, r3
 8015cd0:	fb11 f303 	smulbb	r3, r1, r3
 8015cd4:	b29b      	uxth	r3, r3
 8015cd6:	4413      	add	r3, r2
 8015cd8:	b29b      	uxth	r3, r3
 8015cda:	0a1b      	lsrs	r3, r3, #8
 8015cdc:	b29b      	uxth	r3, r3
 8015cde:	f003 031f 	and.w	r3, r3, #31
 8015ce2:	b2da      	uxtb	r2, r3
 8015ce4:	7b3b      	ldrb	r3, [r7, #12]
 8015ce6:	f362 0304 	bfi	r3, r2, #0, #5
 8015cea:	733b      	strb	r3, [r7, #12]
#else
    /*LV_COLOR_DEPTH == 1*/
    ret.full = mix > LV_OPA_50 ? c1.full : c2.full;
#endif

    return ret;
 8015cec:	89bb      	ldrh	r3, [r7, #12]
}
 8015cee:	4618      	mov	r0, r3
 8015cf0:	3714      	adds	r7, #20
 8015cf2:	46bd      	mov	sp, r7
 8015cf4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015cf8:	4770      	bx	lr

08015cfa <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
 8015cfa:	b480      	push	{r7}
 8015cfc:	b083      	sub	sp, #12
 8015cfe:	af00      	add	r7, sp, #0
 8015d00:	6078      	str	r0, [r7, #4]
    return area_p->x2 - area_p->x1 + 1;
 8015d02:	687b      	ldr	r3, [r7, #4]
 8015d04:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8015d08:	b29a      	uxth	r2, r3
 8015d0a:	687b      	ldr	r3, [r7, #4]
 8015d0c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8015d10:	b29b      	uxth	r3, r3
 8015d12:	1ad3      	subs	r3, r2, r3
 8015d14:	b29b      	uxth	r3, r3
 8015d16:	3301      	adds	r3, #1
 8015d18:	b29b      	uxth	r3, r3
 8015d1a:	b21b      	sxth	r3, r3
}
 8015d1c:	4618      	mov	r0, r3
 8015d1e:	370c      	adds	r7, #12
 8015d20:	46bd      	mov	sp, r7
 8015d22:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015d26:	4770      	bx	lr

08015d28 <lv_draw_px>:
 * @param mask_p fill only on this mask (truncated to VDB area)
 * @param color pixel color
 * @param opa opacity of the area (0..255)
 */
void lv_draw_px(lv_coord_t x, lv_coord_t y, const lv_area_t * mask_p, lv_color_t color, lv_opa_t opa)
{
 8015d28:	b5b0      	push	{r4, r5, r7, lr}
 8015d2a:	b08e      	sub	sp, #56	; 0x38
 8015d2c:	af04      	add	r7, sp, #16
 8015d2e:	60ba      	str	r2, [r7, #8]
 8015d30:	80bb      	strh	r3, [r7, #4]
 8015d32:	4603      	mov	r3, r0
 8015d34:	81fb      	strh	r3, [r7, #14]
 8015d36:	460b      	mov	r3, r1
 8015d38:	81bb      	strh	r3, [r7, #12]

    if(opa < LV_OPA_MIN) return;
 8015d3a:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 8015d3e:	2b0f      	cmp	r3, #15
 8015d40:	f240 8084 	bls.w	8015e4c <lv_draw_px+0x124>
    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
 8015d44:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 8015d48:	2bfb      	cmp	r3, #251	; 0xfb
 8015d4a:	d902      	bls.n	8015d52 <lv_draw_px+0x2a>
 8015d4c:	23ff      	movs	r3, #255	; 0xff
 8015d4e:	f887 3038 	strb.w	r3, [r7, #56]	; 0x38

    /*Pixel out of the mask*/
    if(x < mask_p->x1 || x > mask_p->x2 || y < mask_p->y1 || y > mask_p->y2) {
 8015d52:	68bb      	ldr	r3, [r7, #8]
 8015d54:	f9b3 3000 	ldrsh.w	r3, [r3]
 8015d58:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 8015d5c:	429a      	cmp	r2, r3
 8015d5e:	db77      	blt.n	8015e50 <lv_draw_px+0x128>
 8015d60:	68bb      	ldr	r3, [r7, #8]
 8015d62:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8015d66:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 8015d6a:	429a      	cmp	r2, r3
 8015d6c:	dc70      	bgt.n	8015e50 <lv_draw_px+0x128>
 8015d6e:	68bb      	ldr	r3, [r7, #8]
 8015d70:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8015d74:	f9b7 200c 	ldrsh.w	r2, [r7, #12]
 8015d78:	429a      	cmp	r2, r3
 8015d7a:	db69      	blt.n	8015e50 <lv_draw_px+0x128>
 8015d7c:	68bb      	ldr	r3, [r7, #8]
 8015d7e:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8015d82:	f9b7 200c 	ldrsh.w	r2, [r7, #12]
 8015d86:	429a      	cmp	r2, r3
 8015d88:	dc62      	bgt.n	8015e50 <lv_draw_px+0x128>
        return;
    }

    lv_disp_t * disp    = lv_refr_get_disp_refreshing();
 8015d8a:	f7fe fb83 	bl	8014494 <lv_refr_get_disp_refreshing>
 8015d8e:	6278      	str	r0, [r7, #36]	; 0x24
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
 8015d90:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8015d92:	f007 fa2e 	bl	801d1f2 <lv_disp_get_buf>
 8015d96:	6238      	str	r0, [r7, #32]
    uint32_t vdb_width  = lv_area_get_width(&vdb->area);
 8015d98:	6a3b      	ldr	r3, [r7, #32]
 8015d9a:	3310      	adds	r3, #16
 8015d9c:	4618      	mov	r0, r3
 8015d9e:	f7ff ffac 	bl	8015cfa <lv_area_get_width>
 8015da2:	4603      	mov	r3, r0
 8015da4:	61fb      	str	r3, [r7, #28]

    /*Make the coordinates relative to VDB*/
    x -= vdb->area.x1;
 8015da6:	89fa      	ldrh	r2, [r7, #14]
 8015da8:	6a3b      	ldr	r3, [r7, #32]
 8015daa:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8015dae:	b29b      	uxth	r3, r3
 8015db0:	1ad3      	subs	r3, r2, r3
 8015db2:	b29b      	uxth	r3, r3
 8015db4:	81fb      	strh	r3, [r7, #14]
    y -= vdb->area.y1;
 8015db6:	89ba      	ldrh	r2, [r7, #12]
 8015db8:	6a3b      	ldr	r3, [r7, #32]
 8015dba:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8015dbe:	b29b      	uxth	r3, r3
 8015dc0:	1ad3      	subs	r3, r2, r3
 8015dc2:	b29b      	uxth	r3, r3
 8015dc4:	81bb      	strh	r3, [r7, #12]

    if(disp->driver.set_px_cb) {
 8015dc6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015dc8:	695b      	ldr	r3, [r3, #20]
 8015dca:	2b00      	cmp	r3, #0
 8015dcc:	d014      	beq.n	8015df8 <lv_draw_px+0xd0>
        disp->driver.set_px_cb(&disp->driver, (uint8_t *)vdb->buf_act, vdb_width, x, y, color, opa);
 8015dce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015dd0:	695c      	ldr	r4, [r3, #20]
 8015dd2:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8015dd4:	6a3b      	ldr	r3, [r7, #32]
 8015dd6:	6899      	ldr	r1, [r3, #8]
 8015dd8:	69fb      	ldr	r3, [r7, #28]
 8015dda:	b21a      	sxth	r2, r3
 8015ddc:	f9b7 500e 	ldrsh.w	r5, [r7, #14]
 8015de0:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 8015de4:	9302      	str	r3, [sp, #8]
 8015de6:	88bb      	ldrh	r3, [r7, #4]
 8015de8:	f8ad 3004 	strh.w	r3, [sp, #4]
 8015dec:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8015df0:	9300      	str	r3, [sp, #0]
 8015df2:	462b      	mov	r3, r5
 8015df4:	47a0      	blx	r4
 8015df6:	e02c      	b.n	8015e52 <lv_draw_px+0x12a>
    } else {
        bool scr_transp = false;
 8015df8:	2300      	movs	r3, #0
 8015dfa:	76fb      	strb	r3, [r7, #27]
#if LV_COLOR_DEPTH == 32 && LV_COLOR_SCREEN_TRANSP
        scr_transp = disp->driver.screen_transp;
#endif

        lv_color_t * vdb_px_p = vdb->buf_act;
 8015dfc:	6a3b      	ldr	r3, [r7, #32]
 8015dfe:	689b      	ldr	r3, [r3, #8]
 8015e00:	617b      	str	r3, [r7, #20]
        vdb_px_p += y * vdb_width + x;
 8015e02:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8015e06:	69fa      	ldr	r2, [r7, #28]
 8015e08:	fb02 f203 	mul.w	r2, r2, r3
 8015e0c:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8015e10:	4413      	add	r3, r2
 8015e12:	005b      	lsls	r3, r3, #1
 8015e14:	697a      	ldr	r2, [r7, #20]
 8015e16:	4413      	add	r3, r2
 8015e18:	617b      	str	r3, [r7, #20]

        if(scr_transp == false) {
 8015e1a:	7efb      	ldrb	r3, [r7, #27]
 8015e1c:	f083 0301 	eor.w	r3, r3, #1
 8015e20:	b2db      	uxtb	r3, r3
 8015e22:	2b00      	cmp	r3, #0
 8015e24:	d015      	beq.n	8015e52 <lv_draw_px+0x12a>
            if(opa == LV_OPA_COVER) {
 8015e26:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 8015e2a:	2bff      	cmp	r3, #255	; 0xff
 8015e2c:	d103      	bne.n	8015e36 <lv_draw_px+0x10e>
                *vdb_px_p = color;
 8015e2e:	697b      	ldr	r3, [r7, #20]
 8015e30:	88ba      	ldrh	r2, [r7, #4]
 8015e32:	801a      	strh	r2, [r3, #0]
 8015e34:	e00d      	b.n	8015e52 <lv_draw_px+0x12a>
            } else {
                *vdb_px_p = lv_color_mix(color, *vdb_px_p, opa);
 8015e36:	f897 2038 	ldrb.w	r2, [r7, #56]	; 0x38
 8015e3a:	697b      	ldr	r3, [r7, #20]
 8015e3c:	8819      	ldrh	r1, [r3, #0]
 8015e3e:	88b8      	ldrh	r0, [r7, #4]
 8015e40:	f7ff feea 	bl	8015c18 <lv_color_mix>
 8015e44:	4602      	mov	r2, r0
 8015e46:	697b      	ldr	r3, [r7, #20]
 8015e48:	801a      	strh	r2, [r3, #0]
 8015e4a:	e002      	b.n	8015e52 <lv_draw_px+0x12a>
    if(opa < LV_OPA_MIN) return;
 8015e4c:	bf00      	nop
 8015e4e:	e000      	b.n	8015e52 <lv_draw_px+0x12a>
        return;
 8015e50:	bf00      	nop
#if LV_COLOR_DEPTH == 32 && LV_COLOR_SCREEN_TRANSP
            *vdb_px_p = color_mix_2_alpha(*vdb_px_p, (*vdb_px_p).ch.alpha, color, opa);
#endif
        }
    }
}
 8015e52:	3728      	adds	r7, #40	; 0x28
 8015e54:	46bd      	mov	sp, r7
 8015e56:	bdb0      	pop	{r4, r5, r7, pc}

08015e58 <lv_draw_fill>:
 * @param mask_p fill only o this mask  (truncated to VDB area)
 * @param color fill color
 * @param opa opacity of the area (0..255)
 */
void lv_draw_fill(const lv_area_t * cords_p, const lv_area_t * mask_p, lv_color_t color, lv_opa_t opa)
{
 8015e58:	b580      	push	{r7, lr}
 8015e5a:	b090      	sub	sp, #64	; 0x40
 8015e5c:	af02      	add	r7, sp, #8
 8015e5e:	60f8      	str	r0, [r7, #12]
 8015e60:	60b9      	str	r1, [r7, #8]
 8015e62:	80ba      	strh	r2, [r7, #4]
 8015e64:	71fb      	strb	r3, [r7, #7]
    if(opa < LV_OPA_MIN) return;
 8015e66:	79fb      	ldrb	r3, [r7, #7]
 8015e68:	2b0f      	cmp	r3, #15
 8015e6a:	d968      	bls.n	8015f3e <lv_draw_fill+0xe6>
    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
 8015e6c:	79fb      	ldrb	r3, [r7, #7]
 8015e6e:	2bfb      	cmp	r3, #251	; 0xfb
 8015e70:	d901      	bls.n	8015e76 <lv_draw_fill+0x1e>
 8015e72:	23ff      	movs	r3, #255	; 0xff
 8015e74:	71fb      	strb	r3, [r7, #7]
    bool union_ok;

    /*Get the union of cord and mask*/
    /* The mask is already truncated to the vdb size
     * in 'lv_refr_area_with_vdb' function */
    union_ok = lv_area_intersect(&res_a, cords_p, mask_p);
 8015e76:	f107 031c 	add.w	r3, r7, #28
 8015e7a:	68ba      	ldr	r2, [r7, #8]
 8015e7c:	68f9      	ldr	r1, [r7, #12]
 8015e7e:	4618      	mov	r0, r3
 8015e80:	f007 fcca 	bl	801d818 <lv_area_intersect>
 8015e84:	4603      	mov	r3, r0
 8015e86:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37

    /*If there are common part of the three area then draw to the vdb*/
    if(union_ok == false) {
 8015e8a:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 8015e8e:	f083 0301 	eor.w	r3, r3, #1
 8015e92:	b2db      	uxtb	r3, r3
 8015e94:	2b00      	cmp	r3, #0
 8015e96:	d154      	bne.n	8015f42 <lv_draw_fill+0xea>
        return;
    }

    lv_disp_t * disp    = lv_refr_get_disp_refreshing();
 8015e98:	f7fe fafc 	bl	8014494 <lv_refr_get_disp_refreshing>
 8015e9c:	6338      	str	r0, [r7, #48]	; 0x30
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
 8015e9e:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8015ea0:	f007 f9a7 	bl	801d1f2 <lv_disp_get_buf>
 8015ea4:	62f8      	str	r0, [r7, #44]	; 0x2c

    lv_area_t vdb_rel_a; /*Stores relative coordinates on vdb*/
    vdb_rel_a.x1 = res_a.x1 - vdb->area.x1;
 8015ea6:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 8015eaa:	b29a      	uxth	r2, r3
 8015eac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015eae:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8015eb2:	b29b      	uxth	r3, r3
 8015eb4:	1ad3      	subs	r3, r2, r3
 8015eb6:	b29b      	uxth	r3, r3
 8015eb8:	b21b      	sxth	r3, r3
 8015eba:	82bb      	strh	r3, [r7, #20]
    vdb_rel_a.y1 = res_a.y1 - vdb->area.y1;
 8015ebc:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8015ec0:	b29a      	uxth	r2, r3
 8015ec2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015ec4:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8015ec8:	b29b      	uxth	r3, r3
 8015eca:	1ad3      	subs	r3, r2, r3
 8015ecc:	b29b      	uxth	r3, r3
 8015ece:	b21b      	sxth	r3, r3
 8015ed0:	82fb      	strh	r3, [r7, #22]
    vdb_rel_a.x2 = res_a.x2 - vdb->area.x1;
 8015ed2:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 8015ed6:	b29a      	uxth	r2, r3
 8015ed8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015eda:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8015ede:	b29b      	uxth	r3, r3
 8015ee0:	1ad3      	subs	r3, r2, r3
 8015ee2:	b29b      	uxth	r3, r3
 8015ee4:	b21b      	sxth	r3, r3
 8015ee6:	833b      	strh	r3, [r7, #24]
    vdb_rel_a.y2 = res_a.y2 - vdb->area.y1;
 8015ee8:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8015eec:	b29a      	uxth	r2, r3
 8015eee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015ef0:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8015ef4:	b29b      	uxth	r3, r3
 8015ef6:	1ad3      	subs	r3, r2, r3
 8015ef8:	b29b      	uxth	r3, r3
 8015efa:	b21b      	sxth	r3, r3
 8015efc:	837b      	strh	r3, [r7, #26]

    lv_color_t * vdb_buf_tmp = vdb->buf_act;
 8015efe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015f00:	689b      	ldr	r3, [r3, #8]
 8015f02:	62bb      	str	r3, [r7, #40]	; 0x28
    uint32_t vdb_width       = lv_area_get_width(&vdb->area);
 8015f04:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015f06:	3310      	adds	r3, #16
 8015f08:	4618      	mov	r0, r3
 8015f0a:	f7ff fef6 	bl	8015cfa <lv_area_get_width>
 8015f0e:	4603      	mov	r3, r0
 8015f10:	627b      	str	r3, [r7, #36]	; 0x24
    /*Move the vdb_tmp to the first row*/
    vdb_buf_tmp += vdb_width * vdb_rel_a.y1;
 8015f12:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8015f16:	461a      	mov	r2, r3
 8015f18:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015f1a:	fb03 f302 	mul.w	r3, r3, r2
 8015f1e:	005b      	lsls	r3, r3, #1
 8015f20:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8015f22:	4413      	add	r3, r2
 8015f24:	62bb      	str	r3, [r7, #40]	; 0x28
        else {
            sw_color_fill(vdb->buf_act, vdb_width, &vdb_rel_a, color, opa);
        }
    }
#else
    sw_color_fill(vdb->buf_act, vdb_width, &vdb_rel_a, color, opa);
 8015f26:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8015f28:	6898      	ldr	r0, [r3, #8]
 8015f2a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8015f2c:	b219      	sxth	r1, r3
 8015f2e:	f107 0214 	add.w	r2, r7, #20
 8015f32:	79fb      	ldrb	r3, [r7, #7]
 8015f34:	9300      	str	r3, [sp, #0]
 8015f36:	88bb      	ldrh	r3, [r7, #4]
 8015f38:	f000 fd56 	bl	80169e8 <sw_color_fill>
 8015f3c:	e002      	b.n	8015f44 <lv_draw_fill+0xec>
    if(opa < LV_OPA_MIN) return;
 8015f3e:	bf00      	nop
 8015f40:	e000      	b.n	8015f44 <lv_draw_fill+0xec>
        return;
 8015f42:	bf00      	nop
#endif
}
 8015f44:	3738      	adds	r7, #56	; 0x38
 8015f46:	46bd      	mov	sp, r7
 8015f48:	bd80      	pop	{r7, pc}
	...

08015f4c <lv_draw_letter>:
 * @param color color of letter
 * @param opa opacity of letter (0..255)
 */
void lv_draw_letter(const lv_point_t * pos_p, const lv_area_t * mask_p, const lv_font_t * font_p, uint32_t letter,
                    lv_color_t color, lv_opa_t opa)
{
 8015f4c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8015f4e:	b0a1      	sub	sp, #132	; 0x84
 8015f50:	af04      	add	r7, sp, #16
 8015f52:	60f8      	str	r0, [r7, #12]
 8015f54:	60b9      	str	r1, [r7, #8]
 8015f56:	607a      	str	r2, [r7, #4]
 8015f58:	603b      	str	r3, [r7, #0]
    /*clang-format off*/
    const uint8_t bpp1_opa_table[2]  = {0, 255};          /*Opacity mapping with bpp = 1 (Just for compatibility)*/
 8015f5a:	f44f 437f 	mov.w	r3, #65280	; 0xff00
 8015f5e:	863b      	strh	r3, [r7, #48]	; 0x30
    const uint8_t bpp2_opa_table[4]  = {0, 85, 170, 255}; /*Opacity mapping with bpp = 2*/
 8015f60:	4bbd      	ldr	r3, [pc, #756]	; (8016258 <lv_draw_letter+0x30c>)
 8015f62:	62fb      	str	r3, [r7, #44]	; 0x2c
    const uint8_t bpp4_opa_table[16] = {0,  17, 34,  51,  /*Opacity mapping with bpp = 4*/
 8015f64:	4bbd      	ldr	r3, [pc, #756]	; (801625c <lv_draw_letter+0x310>)
 8015f66:	f107 041c 	add.w	r4, r7, #28
 8015f6a:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8015f6c:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
                                        68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255};
    /*clang-format on*/

    if(opa < LV_OPA_MIN) return;
 8015f70:	f897 308c 	ldrb.w	r3, [r7, #140]	; 0x8c
 8015f74:	2b0f      	cmp	r3, #15
 8015f76:	f240 827e 	bls.w	8016476 <lv_draw_letter+0x52a>
    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
 8015f7a:	f897 308c 	ldrb.w	r3, [r7, #140]	; 0x8c
 8015f7e:	2bfb      	cmp	r3, #251	; 0xfb
 8015f80:	d902      	bls.n	8015f88 <lv_draw_letter+0x3c>
 8015f82:	23ff      	movs	r3, #255	; 0xff
 8015f84:	f887 308c 	strb.w	r3, [r7, #140]	; 0x8c

    if(font_p == NULL) {
 8015f88:	687b      	ldr	r3, [r7, #4]
 8015f8a:	2b00      	cmp	r3, #0
 8015f8c:	f000 8275 	beq.w	801647a <lv_draw_letter+0x52e>
        LV_LOG_WARN("Font: character's bitmap not found");
        return;
    }

    lv_font_glyph_dsc_t g;
    bool g_ret = lv_font_get_glyph_dsc(font_p, &g, letter, '\0');
 8015f90:	f107 0114 	add.w	r1, r7, #20
 8015f94:	2300      	movs	r3, #0
 8015f96:	683a      	ldr	r2, [r7, #0]
 8015f98:	6878      	ldr	r0, [r7, #4]
 8015f9a:	f006 fcd0 	bl	801c93e <lv_font_get_glyph_dsc>
 8015f9e:	4603      	mov	r3, r0
 8015fa0:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
    if(g_ret == false) return;
 8015fa4:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8015fa8:	f083 0301 	eor.w	r3, r3, #1
 8015fac:	b2db      	uxtb	r3, r3
 8015fae:	2b00      	cmp	r3, #0
 8015fb0:	f040 8265 	bne.w	801647e <lv_draw_letter+0x532>

    lv_coord_t pos_x = pos_p->x + g.ofs_x;
 8015fb4:	68fb      	ldr	r3, [r7, #12]
 8015fb6:	f9b3 3000 	ldrsh.w	r3, [r3]
 8015fba:	b29a      	uxth	r2, r3
 8015fbc:	f997 3018 	ldrsb.w	r3, [r7, #24]
 8015fc0:	b29b      	uxth	r3, r3
 8015fc2:	4413      	add	r3, r2
 8015fc4:	b29b      	uxth	r3, r3
 8015fc6:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
    lv_coord_t pos_y = pos_p->y + (font_p->line_height - font_p->base_line) - g.box_h - g.ofs_y;
 8015fca:	68fb      	ldr	r3, [r7, #12]
 8015fcc:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8015fd0:	b29a      	uxth	r2, r3
 8015fd2:	687b      	ldr	r3, [r7, #4]
 8015fd4:	7a1b      	ldrb	r3, [r3, #8]
 8015fd6:	b299      	uxth	r1, r3
 8015fd8:	687b      	ldr	r3, [r7, #4]
 8015fda:	7a5b      	ldrb	r3, [r3, #9]
 8015fdc:	b29b      	uxth	r3, r3
 8015fde:	1acb      	subs	r3, r1, r3
 8015fe0:	b29b      	uxth	r3, r3
 8015fe2:	4413      	add	r3, r2
 8015fe4:	b29a      	uxth	r2, r3
 8015fe6:	7dfb      	ldrb	r3, [r7, #23]
 8015fe8:	b29b      	uxth	r3, r3
 8015fea:	1ad3      	subs	r3, r2, r3
 8015fec:	b29a      	uxth	r2, r3
 8015fee:	f997 3019 	ldrsb.w	r3, [r7, #25]
 8015ff2:	b29b      	uxth	r3, r3
 8015ff4:	1ad3      	subs	r3, r2, r3
 8015ff6:	b29b      	uxth	r3, r3
 8015ff8:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52

    const uint8_t * bpp_opa_table;
    uint8_t bitmask_init;
    uint8_t bitmask;

    switch(g.bpp) {
 8015ffc:	7ebb      	ldrb	r3, [r7, #26]
 8015ffe:	3b01      	subs	r3, #1
 8016000:	2b07      	cmp	r3, #7
 8016002:	f200 823e 	bhi.w	8016482 <lv_draw_letter+0x536>
 8016006:	a201      	add	r2, pc, #4	; (adr r2, 801600c <lv_draw_letter+0xc0>)
 8016008:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801600c:	0801602d 	.word	0x0801602d
 8016010:	0801603b 	.word	0x0801603b
 8016014:	08016483 	.word	0x08016483
 8016018:	08016049 	.word	0x08016049
 801601c:	08016483 	.word	0x08016483
 8016020:	08016483 	.word	0x08016483
 8016024:	08016483 	.word	0x08016483
 8016028:	08016057 	.word	0x08016057
        case 1:
            bpp_opa_table = bpp1_opa_table;
 801602c:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8016030:	66fb      	str	r3, [r7, #108]	; 0x6c
            bitmask_init  = 0x80;
 8016032:	2380      	movs	r3, #128	; 0x80
 8016034:	f887 306b 	strb.w	r3, [r7, #107]	; 0x6b
            break;
 8016038:	e013      	b.n	8016062 <lv_draw_letter+0x116>
        case 2:
            bpp_opa_table = bpp2_opa_table;
 801603a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801603e:	66fb      	str	r3, [r7, #108]	; 0x6c
            bitmask_init  = 0xC0;
 8016040:	23c0      	movs	r3, #192	; 0xc0
 8016042:	f887 306b 	strb.w	r3, [r7, #107]	; 0x6b
            break;
 8016046:	e00c      	b.n	8016062 <lv_draw_letter+0x116>
        case 4:
            bpp_opa_table = bpp4_opa_table;
 8016048:	f107 031c 	add.w	r3, r7, #28
 801604c:	66fb      	str	r3, [r7, #108]	; 0x6c
            bitmask_init  = 0xF0;
 801604e:	23f0      	movs	r3, #240	; 0xf0
 8016050:	f887 306b 	strb.w	r3, [r7, #107]	; 0x6b
            break;
 8016054:	e005      	b.n	8016062 <lv_draw_letter+0x116>
        case 8:
            bpp_opa_table = NULL;
 8016056:	2300      	movs	r3, #0
 8016058:	66fb      	str	r3, [r7, #108]	; 0x6c
            bitmask_init  = 0xFF;
 801605a:	23ff      	movs	r3, #255	; 0xff
 801605c:	f887 306b 	strb.w	r3, [r7, #107]	; 0x6b
            break;       /*No opa table, pixel value will be used directly*/
 8016060:	bf00      	nop
        default: return; /*Invalid bpp. Can't render the letter*/
    }

    const uint8_t * map_p = lv_font_get_glyph_bitmap(font_p, letter);
 8016062:	6839      	ldr	r1, [r7, #0]
 8016064:	6878      	ldr	r0, [r7, #4]
 8016066:	f006 fc5b 	bl	801c920 <lv_font_get_glyph_bitmap>
 801606a:	6678      	str	r0, [r7, #100]	; 0x64

    if(map_p == NULL) return;
 801606c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801606e:	2b00      	cmp	r3, #0
 8016070:	f000 8209 	beq.w	8016486 <lv_draw_letter+0x53a>

    /*If the letter is completely out of mask don't draw it */
    if(pos_x + g.box_w < mask_p->x1 || pos_x > mask_p->x2 || pos_y + g.box_h < mask_p->y1 || pos_y > mask_p->y2) return;
 8016074:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 8016078:	7dba      	ldrb	r2, [r7, #22]
 801607a:	4413      	add	r3, r2
 801607c:	68ba      	ldr	r2, [r7, #8]
 801607e:	f9b2 2000 	ldrsh.w	r2, [r2]
 8016082:	4293      	cmp	r3, r2
 8016084:	f2c0 8201 	blt.w	801648a <lv_draw_letter+0x53e>
 8016088:	68bb      	ldr	r3, [r7, #8]
 801608a:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801608e:	f9b7 2054 	ldrsh.w	r2, [r7, #84]	; 0x54
 8016092:	429a      	cmp	r2, r3
 8016094:	f300 81f9 	bgt.w	801648a <lv_draw_letter+0x53e>
 8016098:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 801609c:	7dfa      	ldrb	r2, [r7, #23]
 801609e:	4413      	add	r3, r2
 80160a0:	68ba      	ldr	r2, [r7, #8]
 80160a2:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
 80160a6:	4293      	cmp	r3, r2
 80160a8:	f2c0 81ef 	blt.w	801648a <lv_draw_letter+0x53e>
 80160ac:	68bb      	ldr	r3, [r7, #8]
 80160ae:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80160b2:	f9b7 2052 	ldrsh.w	r2, [r7, #82]	; 0x52
 80160b6:	429a      	cmp	r2, r3
 80160b8:	f300 81e7 	bgt.w	801648a <lv_draw_letter+0x53e>

    lv_disp_t * disp    = lv_refr_get_disp_refreshing();
 80160bc:	f7fe f9ea 	bl	8014494 <lv_refr_get_disp_refreshing>
 80160c0:	64f8      	str	r0, [r7, #76]	; 0x4c
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
 80160c2:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 80160c4:	f007 f895 	bl	801d1f2 <lv_disp_get_buf>
 80160c8:	64b8      	str	r0, [r7, #72]	; 0x48

    lv_coord_t vdb_width     = lv_area_get_width(&vdb->area);
 80160ca:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80160cc:	3310      	adds	r3, #16
 80160ce:	4618      	mov	r0, r3
 80160d0:	f7ff fe13 	bl	8015cfa <lv_area_get_width>
 80160d4:	4603      	mov	r3, r0
 80160d6:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
    lv_color_t * vdb_buf_tmp = vdb->buf_act;
 80160da:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80160dc:	689b      	ldr	r3, [r3, #8]
 80160de:	663b      	str	r3, [r7, #96]	; 0x60
    lv_coord_t col, row;

    uint8_t width_byte_scr = g.box_w >> 3; /*Width in bytes (on the screen finally) (e.g. w = 11 -> 2 bytes wide)*/
 80160e0:	7dbb      	ldrb	r3, [r7, #22]
 80160e2:	08db      	lsrs	r3, r3, #3
 80160e4:	f887 3045 	strb.w	r3, [r7, #69]	; 0x45
    if(g.box_w & 0x7) width_byte_scr++;
 80160e8:	7dbb      	ldrb	r3, [r7, #22]
 80160ea:	f003 0307 	and.w	r3, r3, #7
 80160ee:	2b00      	cmp	r3, #0
 80160f0:	d004      	beq.n	80160fc <lv_draw_letter+0x1b0>
 80160f2:	f897 3045 	ldrb.w	r3, [r7, #69]	; 0x45
 80160f6:	3301      	adds	r3, #1
 80160f8:	f887 3045 	strb.w	r3, [r7, #69]	; 0x45
    uint16_t width_bit = g.box_w * g.bpp; /*Letter width in bits*/
 80160fc:	7dbb      	ldrb	r3, [r7, #22]
 80160fe:	b29a      	uxth	r2, r3
 8016100:	7ebb      	ldrb	r3, [r7, #26]
 8016102:	b29b      	uxth	r3, r3
 8016104:	fb12 f303 	smulbb	r3, r2, r3
 8016108:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42

    /* Calculate the col/row start/end on the map*/
    lv_coord_t col_start = pos_x >= mask_p->x1 ? 0 : mask_p->x1 - pos_x;
 801610c:	68bb      	ldr	r3, [r7, #8]
 801610e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8016112:	f9b7 2054 	ldrsh.w	r2, [r7, #84]	; 0x54
 8016116:	429a      	cmp	r2, r3
 8016118:	da09      	bge.n	801612e <lv_draw_letter+0x1e2>
 801611a:	68bb      	ldr	r3, [r7, #8]
 801611c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8016120:	b29a      	uxth	r2, r3
 8016122:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 8016126:	1ad3      	subs	r3, r2, r3
 8016128:	b29b      	uxth	r3, r3
 801612a:	b21b      	sxth	r3, r3
 801612c:	e000      	b.n	8016130 <lv_draw_letter+0x1e4>
 801612e:	2300      	movs	r3, #0
 8016130:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40
    lv_coord_t col_end   = pos_x + g.box_w <= mask_p->x2 ? g.box_w : mask_p->x2 - pos_x + 1;
 8016134:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 8016138:	7dba      	ldrb	r2, [r7, #22]
 801613a:	4413      	add	r3, r2
 801613c:	68ba      	ldr	r2, [r7, #8]
 801613e:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
 8016142:	4293      	cmp	r3, r2
 8016144:	dc02      	bgt.n	801614c <lv_draw_letter+0x200>
 8016146:	7dbb      	ldrb	r3, [r7, #22]
 8016148:	b21b      	sxth	r3, r3
 801614a:	e00a      	b.n	8016162 <lv_draw_letter+0x216>
 801614c:	68bb      	ldr	r3, [r7, #8]
 801614e:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8016152:	b29a      	uxth	r2, r3
 8016154:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 8016158:	1ad3      	subs	r3, r2, r3
 801615a:	b29b      	uxth	r3, r3
 801615c:	3301      	adds	r3, #1
 801615e:	b29b      	uxth	r3, r3
 8016160:	b21b      	sxth	r3, r3
 8016162:	87fb      	strh	r3, [r7, #62]	; 0x3e
    lv_coord_t row_start = pos_y >= mask_p->y1 ? 0 : mask_p->y1 - pos_y;
 8016164:	68bb      	ldr	r3, [r7, #8]
 8016166:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801616a:	f9b7 2052 	ldrsh.w	r2, [r7, #82]	; 0x52
 801616e:	429a      	cmp	r2, r3
 8016170:	da09      	bge.n	8016186 <lv_draw_letter+0x23a>
 8016172:	68bb      	ldr	r3, [r7, #8]
 8016174:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8016178:	b29a      	uxth	r2, r3
 801617a:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 801617e:	1ad3      	subs	r3, r2, r3
 8016180:	b29b      	uxth	r3, r3
 8016182:	b21b      	sxth	r3, r3
 8016184:	e000      	b.n	8016188 <lv_draw_letter+0x23c>
 8016186:	2300      	movs	r3, #0
 8016188:	87bb      	strh	r3, [r7, #60]	; 0x3c
    lv_coord_t row_end   = pos_y + g.box_h <= mask_p->y2 ? g.box_h : mask_p->y2 - pos_y + 1;
 801618a:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 801618e:	7dfa      	ldrb	r2, [r7, #23]
 8016190:	4413      	add	r3, r2
 8016192:	68ba      	ldr	r2, [r7, #8]
 8016194:	f9b2 2006 	ldrsh.w	r2, [r2, #6]
 8016198:	4293      	cmp	r3, r2
 801619a:	dc02      	bgt.n	80161a2 <lv_draw_letter+0x256>
 801619c:	7dfb      	ldrb	r3, [r7, #23]
 801619e:	b21b      	sxth	r3, r3
 80161a0:	e00a      	b.n	80161b8 <lv_draw_letter+0x26c>
 80161a2:	68bb      	ldr	r3, [r7, #8]
 80161a4:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80161a8:	b29a      	uxth	r2, r3
 80161aa:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 80161ae:	1ad3      	subs	r3, r2, r3
 80161b0:	b29b      	uxth	r3, r3
 80161b2:	3301      	adds	r3, #1
 80161b4:	b29b      	uxth	r3, r3
 80161b6:	b21b      	sxth	r3, r3
 80161b8:	877b      	strh	r3, [r7, #58]	; 0x3a

    /*Set a pointer on VDB to the first pixel of the letter*/
    vdb_buf_tmp += ((pos_y - vdb->area.y1) * vdb_width) + pos_x - vdb->area.x1;
 80161ba:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 80161be:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80161c0:	f9b2 2012 	ldrsh.w	r2, [r2, #18]
 80161c4:	1a9b      	subs	r3, r3, r2
 80161c6:	f9b7 2046 	ldrsh.w	r2, [r7, #70]	; 0x46
 80161ca:	fb02 f203 	mul.w	r2, r2, r3
 80161ce:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 80161d2:	4413      	add	r3, r2
 80161d4:	6cba      	ldr	r2, [r7, #72]	; 0x48
 80161d6:	f9b2 2010 	ldrsh.w	r2, [r2, #16]
 80161da:	1a9b      	subs	r3, r3, r2
 80161dc:	005b      	lsls	r3, r3, #1
 80161de:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 80161e0:	4413      	add	r3, r2
 80161e2:	663b      	str	r3, [r7, #96]	; 0x60

    /*If the letter is partially out of mask the move there on VDB*/
    vdb_buf_tmp += (row_start * vdb_width) + col_start;
 80161e4:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 80161e8:	f9b7 2046 	ldrsh.w	r2, [r7, #70]	; 0x46
 80161ec:	fb02 f203 	mul.w	r2, r2, r3
 80161f0:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 80161f4:	4413      	add	r3, r2
 80161f6:	005b      	lsls	r3, r3, #1
 80161f8:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 80161fa:	4413      	add	r3, r2
 80161fc:	663b      	str	r3, [r7, #96]	; 0x60

    /*Move on the map too*/
    uint32_t bit_ofs = (row_start * width_bit) + (col_start * g.bpp);
 80161fe:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 8016202:	f8b7 2042 	ldrh.w	r2, [r7, #66]	; 0x42
 8016206:	fb02 f203 	mul.w	r2, r2, r3
 801620a:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 801620e:	7eb9      	ldrb	r1, [r7, #26]
 8016210:	fb01 f303 	mul.w	r3, r1, r3
 8016214:	4413      	add	r3, r2
 8016216:	637b      	str	r3, [r7, #52]	; 0x34
    map_p += bit_ofs >> 3;
 8016218:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801621a:	08db      	lsrs	r3, r3, #3
 801621c:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 801621e:	4413      	add	r3, r2
 8016220:	667b      	str	r3, [r7, #100]	; 0x64

    uint8_t letter_px;
    lv_opa_t px_opa;
    uint16_t col_bit;
    col_bit = bit_ofs & 0x7; /* "& 0x7" equals to "% 8" just faster */
 8016222:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8016224:	b29b      	uxth	r3, r3
 8016226:	f003 0307 	and.w	r3, r3, #7
 801622a:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58

    bool scr_transp = false;
 801622e:	2300      	movs	r3, #0
 8016230:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
#if LV_COLOR_DEPTH == 32 && LV_COLOR_SCREEN_TRANSP
    scr_transp = disp->driver.screen_transp;
#endif

    for(row = row_start; row < row_end; row++) {
 8016234:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 8016236:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
 801623a:	e114      	b.n	8016466 <lv_draw_letter+0x51a>
        bitmask = bitmask_init >> col_bit;
 801623c:	f897 206b 	ldrb.w	r2, [r7, #107]	; 0x6b
 8016240:	f8b7 3058 	ldrh.w	r3, [r7, #88]	; 0x58
 8016244:	fa42 f303 	asr.w	r3, r2, r3
 8016248:	f887 306a 	strb.w	r3, [r7, #106]	; 0x6a
        for(col = col_start; col < col_end; col++) {
 801624c:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 8016250:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
 8016254:	e0cc      	b.n	80163f0 <lv_draw_letter+0x4a4>
 8016256:	bf00      	nop
 8016258:	ffaa5500 	.word	0xffaa5500
 801625c:	080228c4 	.word	0x080228c4
            letter_px = (*map_p & bitmask) >> (8 - col_bit - g.bpp);
 8016260:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8016262:	781a      	ldrb	r2, [r3, #0]
 8016264:	f897 306a 	ldrb.w	r3, [r7, #106]	; 0x6a
 8016268:	4013      	ands	r3, r2
 801626a:	b2db      	uxtb	r3, r3
 801626c:	461a      	mov	r2, r3
 801626e:	f8b7 3058 	ldrh.w	r3, [r7, #88]	; 0x58
 8016272:	f1c3 0308 	rsb	r3, r3, #8
 8016276:	7eb9      	ldrb	r1, [r7, #26]
 8016278:	1a5b      	subs	r3, r3, r1
 801627a:	fa42 f303 	asr.w	r3, r2, r3
 801627e:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
            if(letter_px != 0) {
 8016282:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 8016286:	2b00      	cmp	r3, #0
 8016288:	f000 8089 	beq.w	801639e <lv_draw_letter+0x452>
                if(opa == LV_OPA_COVER) {
 801628c:	f897 308c 	ldrb.w	r3, [r7, #140]	; 0x8c
 8016290:	2bff      	cmp	r3, #255	; 0xff
 8016292:	d10d      	bne.n	80162b0 <lv_draw_letter+0x364>
                    px_opa = g.bpp == 8 ? letter_px : bpp_opa_table[letter_px];
 8016294:	7ebb      	ldrb	r3, [r7, #26]
 8016296:	2b08      	cmp	r3, #8
 8016298:	d005      	beq.n	80162a6 <lv_draw_letter+0x35a>
 801629a:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 801629e:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 80162a0:	4413      	add	r3, r2
 80162a2:	781b      	ldrb	r3, [r3, #0]
 80162a4:	e001      	b.n	80162aa <lv_draw_letter+0x35e>
 80162a6:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 80162aa:	f887 305b 	strb.w	r3, [r7, #91]	; 0x5b
 80162ae:	e020      	b.n	80162f2 <lv_draw_letter+0x3a6>
                } else {
                    px_opa = g.bpp == 8 ? (uint16_t)((uint16_t)letter_px * opa) >> 8
 80162b0:	7ebb      	ldrb	r3, [r7, #26]
 80162b2:	2b08      	cmp	r3, #8
 80162b4:	d10c      	bne.n	80162d0 <lv_draw_letter+0x384>
 80162b6:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 80162ba:	b29a      	uxth	r2, r3
 80162bc:	f897 308c 	ldrb.w	r3, [r7, #140]	; 0x8c
 80162c0:	b29b      	uxth	r3, r3
 80162c2:	fb12 f303 	smulbb	r3, r2, r3
 80162c6:	b29b      	uxth	r3, r3
 80162c8:	0a1b      	lsrs	r3, r3, #8
 80162ca:	b29b      	uxth	r3, r3
 80162cc:	b2db      	uxtb	r3, r3
 80162ce:	e00e      	b.n	80162ee <lv_draw_letter+0x3a2>
                                        : (uint16_t)((uint16_t)bpp_opa_table[letter_px] * opa) >> 8;
 80162d0:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 80162d4:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 80162d6:	4413      	add	r3, r2
 80162d8:	781b      	ldrb	r3, [r3, #0]
 80162da:	b29a      	uxth	r2, r3
 80162dc:	f897 308c 	ldrb.w	r3, [r7, #140]	; 0x8c
 80162e0:	b29b      	uxth	r3, r3
 80162e2:	fb12 f303 	smulbb	r3, r2, r3
 80162e6:	b29b      	uxth	r3, r3
                    px_opa = g.bpp == 8 ? (uint16_t)((uint16_t)letter_px * opa) >> 8
 80162e8:	0a1b      	lsrs	r3, r3, #8
 80162ea:	b29b      	uxth	r3, r3
 80162ec:	b2db      	uxtb	r3, r3
 80162ee:	f887 305b 	strb.w	r3, [r7, #91]	; 0x5b
                }

                if(disp->driver.set_px_cb) {
 80162f2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80162f4:	695b      	ldr	r3, [r3, #20]
 80162f6:	2b00      	cmp	r3, #0
 80162f8:	d02c      	beq.n	8016354 <lv_draw_letter+0x408>
                    disp->driver.set_px_cb(&disp->driver, (uint8_t *)vdb->buf_act, vdb_width,
 80162fa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80162fc:	695c      	ldr	r4, [r3, #20]
 80162fe:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8016300:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016302:	6899      	ldr	r1, [r3, #8]
                                           (col + pos_x) - vdb->area.x1, (row + pos_y) - vdb->area.y1, color, px_opa);
 8016304:	f8b7 205e 	ldrh.w	r2, [r7, #94]	; 0x5e
 8016308:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 801630c:	4413      	add	r3, r2
 801630e:	b29a      	uxth	r2, r3
 8016310:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8016312:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8016316:	b29b      	uxth	r3, r3
 8016318:	1ad3      	subs	r3, r2, r3
 801631a:	b29b      	uxth	r3, r3
                    disp->driver.set_px_cb(&disp->driver, (uint8_t *)vdb->buf_act, vdb_width,
 801631c:	b21e      	sxth	r6, r3
                                           (col + pos_x) - vdb->area.x1, (row + pos_y) - vdb->area.y1, color, px_opa);
 801631e:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 8016322:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 8016326:	4413      	add	r3, r2
 8016328:	b29a      	uxth	r2, r3
 801632a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801632c:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8016330:	b29b      	uxth	r3, r3
 8016332:	1ad3      	subs	r3, r2, r3
 8016334:	b29b      	uxth	r3, r3
                    disp->driver.set_px_cb(&disp->driver, (uint8_t *)vdb->buf_act, vdb_width,
 8016336:	b21b      	sxth	r3, r3
 8016338:	f9b7 5046 	ldrsh.w	r5, [r7, #70]	; 0x46
 801633c:	f897 205b 	ldrb.w	r2, [r7, #91]	; 0x5b
 8016340:	9202      	str	r2, [sp, #8]
 8016342:	f8b7 2088 	ldrh.w	r2, [r7, #136]	; 0x88
 8016346:	f8ad 2004 	strh.w	r2, [sp, #4]
 801634a:	9300      	str	r3, [sp, #0]
 801634c:	4633      	mov	r3, r6
 801634e:	462a      	mov	r2, r5
 8016350:	47a0      	blx	r4
 8016352:	e024      	b.n	801639e <lv_draw_letter+0x452>
                } else if(vdb_buf_tmp->full != color.full) {
 8016354:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8016356:	881a      	ldrh	r2, [r3, #0]
 8016358:	f8b7 3088 	ldrh.w	r3, [r7, #136]	; 0x88
 801635c:	429a      	cmp	r2, r3
 801635e:	d01e      	beq.n	801639e <lv_draw_letter+0x452>
                    if(px_opa > LV_OPA_MAX)
 8016360:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 8016364:	2bfb      	cmp	r3, #251	; 0xfb
 8016366:	d904      	bls.n	8016372 <lv_draw_letter+0x426>
                        *vdb_buf_tmp = color;
 8016368:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801636a:	f8b7 2088 	ldrh.w	r2, [r7, #136]	; 0x88
 801636e:	801a      	strh	r2, [r3, #0]
 8016370:	e015      	b.n	801639e <lv_draw_letter+0x452>
                    else if(px_opa > LV_OPA_MIN) {
 8016372:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 8016376:	2b10      	cmp	r3, #16
 8016378:	d911      	bls.n	801639e <lv_draw_letter+0x452>
                        if(scr_transp == false) {
 801637a:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 801637e:	f083 0301 	eor.w	r3, r3, #1
 8016382:	b2db      	uxtb	r3, r3
 8016384:	2b00      	cmp	r3, #0
 8016386:	d00a      	beq.n	801639e <lv_draw_letter+0x452>
                            *vdb_buf_tmp = lv_color_mix(color, *vdb_buf_tmp, px_opa);
 8016388:	f897 205b 	ldrb.w	r2, [r7, #91]	; 0x5b
 801638c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801638e:	8819      	ldrh	r1, [r3, #0]
 8016390:	f8b7 0088 	ldrh.w	r0, [r7, #136]	; 0x88
 8016394:	f7ff fc40 	bl	8015c18 <lv_color_mix>
 8016398:	4602      	mov	r2, r0
 801639a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801639c:	801a      	strh	r2, [r3, #0]
                        }
                    }
                }
            }

            vdb_buf_tmp++;
 801639e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 80163a0:	3302      	adds	r3, #2
 80163a2:	663b      	str	r3, [r7, #96]	; 0x60

            if(col_bit < 8 - g.bpp) {
 80163a4:	f8b7 2058 	ldrh.w	r2, [r7, #88]	; 0x58
 80163a8:	7ebb      	ldrb	r3, [r7, #26]
 80163aa:	f1c3 0308 	rsb	r3, r3, #8
 80163ae:	429a      	cmp	r2, r3
 80163b0:	da0d      	bge.n	80163ce <lv_draw_letter+0x482>
                col_bit += g.bpp;
 80163b2:	7ebb      	ldrb	r3, [r7, #26]
 80163b4:	b29a      	uxth	r2, r3
 80163b6:	f8b7 3058 	ldrh.w	r3, [r7, #88]	; 0x58
 80163ba:	4413      	add	r3, r2
 80163bc:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58
                bitmask = bitmask >> g.bpp;
 80163c0:	f897 306a 	ldrb.w	r3, [r7, #106]	; 0x6a
 80163c4:	7eba      	ldrb	r2, [r7, #26]
 80163c6:	4113      	asrs	r3, r2
 80163c8:	f887 306a 	strb.w	r3, [r7, #106]	; 0x6a
 80163cc:	e009      	b.n	80163e2 <lv_draw_letter+0x496>
            } else {
                col_bit = 0;
 80163ce:	2300      	movs	r3, #0
 80163d0:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58
                bitmask = bitmask_init;
 80163d4:	f897 306b 	ldrb.w	r3, [r7, #107]	; 0x6b
 80163d8:	f887 306a 	strb.w	r3, [r7, #106]	; 0x6a
                map_p++;
 80163dc:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80163de:	3301      	adds	r3, #1
 80163e0:	667b      	str	r3, [r7, #100]	; 0x64
        for(col = col_start; col < col_end; col++) {
 80163e2:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 80163e6:	b29b      	uxth	r3, r3
 80163e8:	3301      	adds	r3, #1
 80163ea:	b29b      	uxth	r3, r3
 80163ec:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
 80163f0:	f9b7 205e 	ldrsh.w	r2, [r7, #94]	; 0x5e
 80163f4:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 80163f8:	429a      	cmp	r2, r3
 80163fa:	f6ff af31 	blt.w	8016260 <lv_draw_letter+0x314>
            }
        }
        col_bit += ((g.box_w - col_end) + col_start) * g.bpp;
 80163fe:	7dbb      	ldrb	r3, [r7, #22]
 8016400:	461a      	mov	r2, r3
 8016402:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8016406:	1ad2      	subs	r2, r2, r3
 8016408:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 801640c:	4413      	add	r3, r2
 801640e:	b29a      	uxth	r2, r3
 8016410:	7ebb      	ldrb	r3, [r7, #26]
 8016412:	b29b      	uxth	r3, r3
 8016414:	fb12 f303 	smulbb	r3, r2, r3
 8016418:	b29a      	uxth	r2, r3
 801641a:	f8b7 3058 	ldrh.w	r3, [r7, #88]	; 0x58
 801641e:	4413      	add	r3, r2
 8016420:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58

        map_p += (col_bit >> 3);
 8016424:	f8b7 3058 	ldrh.w	r3, [r7, #88]	; 0x58
 8016428:	08db      	lsrs	r3, r3, #3
 801642a:	b29b      	uxth	r3, r3
 801642c:	461a      	mov	r2, r3
 801642e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8016430:	4413      	add	r3, r2
 8016432:	667b      	str	r3, [r7, #100]	; 0x64
        col_bit = col_bit & 0x7;
 8016434:	f8b7 3058 	ldrh.w	r3, [r7, #88]	; 0x58
 8016438:	f003 0307 	and.w	r3, r3, #7
 801643c:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58
        vdb_buf_tmp += vdb_width - (col_end - col_start); /*Next row in VDB*/
 8016440:	f9b7 2046 	ldrsh.w	r2, [r7, #70]	; 0x46
 8016444:	f9b7 103e 	ldrsh.w	r1, [r7, #62]	; 0x3e
 8016448:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 801644c:	1acb      	subs	r3, r1, r3
 801644e:	1ad3      	subs	r3, r2, r3
 8016450:	005b      	lsls	r3, r3, #1
 8016452:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8016454:	4413      	add	r3, r2
 8016456:	663b      	str	r3, [r7, #96]	; 0x60
    for(row = row_start; row < row_end; row++) {
 8016458:	f9b7 305c 	ldrsh.w	r3, [r7, #92]	; 0x5c
 801645c:	b29b      	uxth	r3, r3
 801645e:	3301      	adds	r3, #1
 8016460:	b29b      	uxth	r3, r3
 8016462:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
 8016466:	f9b7 205c 	ldrsh.w	r2, [r7, #92]	; 0x5c
 801646a:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 801646e:	429a      	cmp	r2, r3
 8016470:	f6ff aee4 	blt.w	801623c <lv_draw_letter+0x2f0>
 8016474:	e00a      	b.n	801648c <lv_draw_letter+0x540>
    if(opa < LV_OPA_MIN) return;
 8016476:	bf00      	nop
 8016478:	e008      	b.n	801648c <lv_draw_letter+0x540>
        return;
 801647a:	bf00      	nop
 801647c:	e006      	b.n	801648c <lv_draw_letter+0x540>
    if(g_ret == false) return;
 801647e:	bf00      	nop
 8016480:	e004      	b.n	801648c <lv_draw_letter+0x540>
        default: return; /*Invalid bpp. Can't render the letter*/
 8016482:	bf00      	nop
 8016484:	e002      	b.n	801648c <lv_draw_letter+0x540>
    if(map_p == NULL) return;
 8016486:	bf00      	nop
 8016488:	e000      	b.n	801648c <lv_draw_letter+0x540>
    if(pos_x + g.box_w < mask_p->x1 || pos_x > mask_p->x2 || pos_y + g.box_h < mask_p->y1 || pos_y > mask_p->y2) return;
 801648a:	bf00      	nop
    }
}
 801648c:	3774      	adds	r7, #116	; 0x74
 801648e:	46bd      	mov	sp, r7
 8016490:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8016492:	bf00      	nop

08016494 <lv_draw_map>:
 * @param recolor mix the pixels with this color
 * @param recolor_opa the intense of recoloring
 */
void lv_draw_map(const lv_area_t * cords_p, const lv_area_t * mask_p, const uint8_t * map_p, lv_opa_t opa,
                 bool chroma_key, bool alpha_byte, lv_color_t recolor, lv_opa_t recolor_opa)
{
 8016494:	b5b0      	push	{r4, r5, r7, lr}
 8016496:	b098      	sub	sp, #96	; 0x60
 8016498:	af04      	add	r7, sp, #16
 801649a:	60f8      	str	r0, [r7, #12]
 801649c:	60b9      	str	r1, [r7, #8]
 801649e:	607a      	str	r2, [r7, #4]
 80164a0:	70fb      	strb	r3, [r7, #3]

    if(opa < LV_OPA_MIN) return;
 80164a2:	78fb      	ldrb	r3, [r7, #3]
 80164a4:	2b0f      	cmp	r3, #15
 80164a6:	f240 8266 	bls.w	8016976 <lv_draw_map+0x4e2>
    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
 80164aa:	78fb      	ldrb	r3, [r7, #3]
 80164ac:	2bfb      	cmp	r3, #251	; 0xfb
 80164ae:	d901      	bls.n	80164b4 <lv_draw_map+0x20>
 80164b0:	23ff      	movs	r3, #255	; 0xff
 80164b2:	70fb      	strb	r3, [r7, #3]
    bool union_ok;

    /*Get the union of map size and mask*/
    /* The mask is already truncated to the vdb size
     * in 'lv_refr_area_with_vdb' function */
    union_ok = lv_area_intersect(&masked_a, cords_p, mask_p);
 80164b4:	f107 0320 	add.w	r3, r7, #32
 80164b8:	68ba      	ldr	r2, [r7, #8]
 80164ba:	68f9      	ldr	r1, [r7, #12]
 80164bc:	4618      	mov	r0, r3
 80164be:	f007 f9ab 	bl	801d818 <lv_area_intersect>
 80164c2:	4603      	mov	r3, r0
 80164c4:	f887 3044 	strb.w	r3, [r7, #68]	; 0x44

    /*If there are common part of the three area then draw to the vdb*/
    if(union_ok == false) return;
 80164c8:	f897 3044 	ldrb.w	r3, [r7, #68]	; 0x44
 80164cc:	f083 0301 	eor.w	r3, r3, #1
 80164d0:	b2db      	uxtb	r3, r3
 80164d2:	2b00      	cmp	r3, #0
 80164d4:	f040 8251 	bne.w	801697a <lv_draw_map+0x4e6>

    /*The pixel size in byte is different if an alpha byte is added too*/
    uint8_t px_size_byte = alpha_byte ? LV_IMG_PX_SIZE_ALPHA_BYTE : sizeof(lv_color_t);
 80164d8:	f897 3064 	ldrb.w	r3, [r7, #100]	; 0x64
 80164dc:	2b00      	cmp	r3, #0
 80164de:	d001      	beq.n	80164e4 <lv_draw_map+0x50>
 80164e0:	2303      	movs	r3, #3
 80164e2:	e000      	b.n	80164e6 <lv_draw_map+0x52>
 80164e4:	2302      	movs	r3, #2
 80164e6:	f887 3043 	strb.w	r3, [r7, #67]	; 0x43

    /*If the map starts OUT of the masked area then calc. the first pixel*/
    lv_coord_t map_width = lv_area_get_width(cords_p);
 80164ea:	68f8      	ldr	r0, [r7, #12]
 80164ec:	f7ff fc05 	bl	8015cfa <lv_area_get_width>
 80164f0:	4603      	mov	r3, r0
 80164f2:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40
    if(cords_p->y1 < masked_a.y1) {
 80164f6:	68fb      	ldr	r3, [r7, #12]
 80164f8:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 80164fc:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8016500:	429a      	cmp	r2, r3
 8016502:	da11      	bge.n	8016528 <lv_draw_map+0x94>
        map_p += (uint32_t)map_width * ((masked_a.y1 - cords_p->y1)) * px_size_byte;
 8016504:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 8016508:	f9b7 2022 	ldrsh.w	r2, [r7, #34]	; 0x22
 801650c:	4611      	mov	r1, r2
 801650e:	68fa      	ldr	r2, [r7, #12]
 8016510:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
 8016514:	1a8a      	subs	r2, r1, r2
 8016516:	fb02 f303 	mul.w	r3, r2, r3
 801651a:	f897 2043 	ldrb.w	r2, [r7, #67]	; 0x43
 801651e:	fb02 f303 	mul.w	r3, r2, r3
 8016522:	687a      	ldr	r2, [r7, #4]
 8016524:	4413      	add	r3, r2
 8016526:	607b      	str	r3, [r7, #4]
    }
    if(cords_p->x1 < masked_a.x1) {
 8016528:	68fb      	ldr	r3, [r7, #12]
 801652a:	f9b3 2000 	ldrsh.w	r2, [r3]
 801652e:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 8016532:	429a      	cmp	r2, r3
 8016534:	da0e      	bge.n	8016554 <lv_draw_map+0xc0>
        map_p += (masked_a.x1 - cords_p->x1) * px_size_byte;
 8016536:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 801653a:	461a      	mov	r2, r3
 801653c:	68fb      	ldr	r3, [r7, #12]
 801653e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8016542:	1ad3      	subs	r3, r2, r3
 8016544:	f897 2043 	ldrb.w	r2, [r7, #67]	; 0x43
 8016548:	fb02 f303 	mul.w	r3, r2, r3
 801654c:	461a      	mov	r2, r3
 801654e:	687b      	ldr	r3, [r7, #4]
 8016550:	4413      	add	r3, r2
 8016552:	607b      	str	r3, [r7, #4]
    }

    lv_disp_t * disp    = lv_refr_get_disp_refreshing();
 8016554:	f7fd ff9e 	bl	8014494 <lv_refr_get_disp_refreshing>
 8016558:	63f8      	str	r0, [r7, #60]	; 0x3c
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
 801655a:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 801655c:	f006 fe49 	bl	801d1f2 <lv_disp_get_buf>
 8016560:	63b8      	str	r0, [r7, #56]	; 0x38

    /*Stores coordinates relative to the current VDB*/
    masked_a.x1 = masked_a.x1 - vdb->area.x1;
 8016562:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 8016566:	b29a      	uxth	r2, r3
 8016568:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801656a:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 801656e:	b29b      	uxth	r3, r3
 8016570:	1ad3      	subs	r3, r2, r3
 8016572:	b29b      	uxth	r3, r3
 8016574:	b21b      	sxth	r3, r3
 8016576:	843b      	strh	r3, [r7, #32]
    masked_a.y1 = masked_a.y1 - vdb->area.y1;
 8016578:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 801657c:	b29a      	uxth	r2, r3
 801657e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016580:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8016584:	b29b      	uxth	r3, r3
 8016586:	1ad3      	subs	r3, r2, r3
 8016588:	b29b      	uxth	r3, r3
 801658a:	b21b      	sxth	r3, r3
 801658c:	847b      	strh	r3, [r7, #34]	; 0x22
    masked_a.x2 = masked_a.x2 - vdb->area.x1;
 801658e:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8016592:	b29a      	uxth	r2, r3
 8016594:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016596:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 801659a:	b29b      	uxth	r3, r3
 801659c:	1ad3      	subs	r3, r2, r3
 801659e:	b29b      	uxth	r3, r3
 80165a0:	b21b      	sxth	r3, r3
 80165a2:	84bb      	strh	r3, [r7, #36]	; 0x24
    masked_a.y2 = masked_a.y2 - vdb->area.y1;
 80165a4:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 80165a8:	b29a      	uxth	r2, r3
 80165aa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80165ac:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 80165b0:	b29b      	uxth	r3, r3
 80165b2:	1ad3      	subs	r3, r2, r3
 80165b4:	b29b      	uxth	r3, r3
 80165b6:	b21b      	sxth	r3, r3
 80165b8:	84fb      	strh	r3, [r7, #38]	; 0x26

    lv_coord_t vdb_width     = lv_area_get_width(&vdb->area);
 80165ba:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80165bc:	3310      	adds	r3, #16
 80165be:	4618      	mov	r0, r3
 80165c0:	f7ff fb9b 	bl	8015cfa <lv_area_get_width>
 80165c4:	4603      	mov	r3, r0
 80165c6:	86fb      	strh	r3, [r7, #54]	; 0x36
    lv_color_t * vdb_buf_tmp = vdb->buf_act;
 80165c8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80165ca:	689b      	ldr	r3, [r3, #8]
 80165cc:	64fb      	str	r3, [r7, #76]	; 0x4c
    vdb_buf_tmp += (uint32_t)vdb_width * masked_a.y1; /*Move to the first row*/
 80165ce:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 80165d2:	f9b7 2022 	ldrsh.w	r2, [r7, #34]	; 0x22
 80165d6:	fb02 f303 	mul.w	r3, r2, r3
 80165da:	005b      	lsls	r3, r3, #1
 80165dc:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80165de:	4413      	add	r3, r2
 80165e0:	64fb      	str	r3, [r7, #76]	; 0x4c
    vdb_buf_tmp += (uint32_t)masked_a.x1;             /*Move to the first col*/
 80165e2:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 80165e6:	005b      	lsls	r3, r3, #1
 80165e8:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80165ea:	4413      	add	r3, r2
 80165ec:	64fb      	str	r3, [r7, #76]	; 0x4c

    lv_coord_t row;
    lv_coord_t map_useful_w = lv_area_get_width(&masked_a);
 80165ee:	f107 0320 	add.w	r3, r7, #32
 80165f2:	4618      	mov	r0, r3
 80165f4:	f7ff fb81 	bl	8015cfa <lv_area_get_width>
 80165f8:	4603      	mov	r3, r0
 80165fa:	86bb      	strh	r3, [r7, #52]	; 0x34

    bool scr_transp = false;
 80165fc:	2300      	movs	r3, #0
 80165fe:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
#if LV_COLOR_DEPTH == 32 && LV_COLOR_SCREEN_TRANSP
    scr_transp = disp->driver.screen_transp;
#endif

    /*The simplest case just copy the pixels into the VDB*/
    if(chroma_key == false && alpha_byte == false && opa == LV_OPA_COVER && recolor_opa == LV_OPA_TRANSP) {
 8016602:	f897 3060 	ldrb.w	r3, [r7, #96]	; 0x60
 8016606:	f083 0301 	eor.w	r3, r3, #1
 801660a:	b2db      	uxtb	r3, r3
 801660c:	2b00      	cmp	r3, #0
 801660e:	f000 808d 	beq.w	801672c <lv_draw_map+0x298>
 8016612:	f897 3064 	ldrb.w	r3, [r7, #100]	; 0x64
 8016616:	f083 0301 	eor.w	r3, r3, #1
 801661a:	b2db      	uxtb	r3, r3
 801661c:	2b00      	cmp	r3, #0
 801661e:	f000 8085 	beq.w	801672c <lv_draw_map+0x298>
 8016622:	78fb      	ldrb	r3, [r7, #3]
 8016624:	2bff      	cmp	r3, #255	; 0xff
 8016626:	f040 8081 	bne.w	801672c <lv_draw_map+0x298>
 801662a:	f897 306c 	ldrb.w	r3, [r7, #108]	; 0x6c
 801662e:	2b00      	cmp	r3, #0
 8016630:	d17c      	bne.n	801672c <lv_draw_map+0x298>

        /*Use the custom VDB write function is exists*/
        if(disp->driver.set_px_cb) {
 8016632:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016634:	695b      	ldr	r3, [r3, #20]
 8016636:	2b00      	cmp	r3, #0
 8016638:	d04f      	beq.n	80166da <lv_draw_map+0x246>
            lv_coord_t col;
            for(row = masked_a.y1; row <= masked_a.y2; row++) {
 801663a:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 801663c:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
 8016640:	e044      	b.n	80166cc <lv_draw_map+0x238>
                for(col = 0; col < map_useful_w; col++) {
 8016642:	2300      	movs	r3, #0
 8016644:	f8a7 3048 	strh.w	r3, [r7, #72]	; 0x48
 8016648:	e029      	b.n	801669e <lv_draw_map+0x20a>
                    lv_color_t px_color = *((lv_color_t *)&map_p[(uint32_t)col * px_size_byte]);
 801664a:	f9b7 3048 	ldrsh.w	r3, [r7, #72]	; 0x48
 801664e:	f897 2043 	ldrb.w	r2, [r7, #67]	; 0x43
 8016652:	fb02 f303 	mul.w	r3, r2, r3
 8016656:	687a      	ldr	r2, [r7, #4]
 8016658:	4413      	add	r3, r2
 801665a:	881b      	ldrh	r3, [r3, #0]
 801665c:	83bb      	strh	r3, [r7, #28]
                    disp->driver.set_px_cb(&disp->driver, (uint8_t *)vdb->buf_act, vdb_width, col + masked_a.x1, row,
 801665e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016660:	695c      	ldr	r4, [r3, #20]
 8016662:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 8016664:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016666:	6899      	ldr	r1, [r3, #8]
 8016668:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 801666c:	b29a      	uxth	r2, r3
 801666e:	f8b7 3048 	ldrh.w	r3, [r7, #72]	; 0x48
 8016672:	4413      	add	r3, r2
 8016674:	b29b      	uxth	r3, r3
 8016676:	b21d      	sxth	r5, r3
 8016678:	f9b7 2036 	ldrsh.w	r2, [r7, #54]	; 0x36
 801667c:	78fb      	ldrb	r3, [r7, #3]
 801667e:	9302      	str	r3, [sp, #8]
 8016680:	8bbb      	ldrh	r3, [r7, #28]
 8016682:	f8ad 3004 	strh.w	r3, [sp, #4]
 8016686:	f9b7 304a 	ldrsh.w	r3, [r7, #74]	; 0x4a
 801668a:	9300      	str	r3, [sp, #0]
 801668c:	462b      	mov	r3, r5
 801668e:	47a0      	blx	r4
                for(col = 0; col < map_useful_w; col++) {
 8016690:	f9b7 3048 	ldrsh.w	r3, [r7, #72]	; 0x48
 8016694:	b29b      	uxth	r3, r3
 8016696:	3301      	adds	r3, #1
 8016698:	b29b      	uxth	r3, r3
 801669a:	f8a7 3048 	strh.w	r3, [r7, #72]	; 0x48
 801669e:	f9b7 2048 	ldrsh.w	r2, [r7, #72]	; 0x48
 80166a2:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 80166a6:	429a      	cmp	r2, r3
 80166a8:	dbcf      	blt.n	801664a <lv_draw_map+0x1b6>
                                           px_color, opa);
                }
                map_p += map_width * px_size_byte; /*Next row on the map*/
 80166aa:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 80166ae:	f897 2043 	ldrb.w	r2, [r7, #67]	; 0x43
 80166b2:	fb02 f303 	mul.w	r3, r2, r3
 80166b6:	461a      	mov	r2, r3
 80166b8:	687b      	ldr	r3, [r7, #4]
 80166ba:	4413      	add	r3, r2
 80166bc:	607b      	str	r3, [r7, #4]
            for(row = masked_a.y1; row <= masked_a.y2; row++) {
 80166be:	f9b7 304a 	ldrsh.w	r3, [r7, #74]	; 0x4a
 80166c2:	b29b      	uxth	r3, r3
 80166c4:	3301      	adds	r3, #1
 80166c6:	b29b      	uxth	r3, r3
 80166c8:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
 80166cc:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 80166d0:	f9b7 204a 	ldrsh.w	r2, [r7, #74]	; 0x4a
 80166d4:	429a      	cmp	r2, r3
 80166d6:	ddb4      	ble.n	8016642 <lv_draw_map+0x1ae>
        if(disp->driver.set_px_cb) {
 80166d8:	e150      	b.n	801697c <lv_draw_map+0x4e8>
            }
        }
        /*Normal native VDB*/
        else {
            for(row = masked_a.y1; row <= masked_a.y2; row++) {
 80166da:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 80166dc:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
 80166e0:	e01d      	b.n	801671e <lv_draw_map+0x28a>
                    sw_mem_blend(vdb_buf_tmp, (lv_color_t *)map_p, map_useful_w, opa);
                } else {
                    disp->driver.gpu_blend_cb(&disp->driver, vdb_buf_tmp, (lv_color_t *)map_p, map_useful_w, opa);
                }
#else
                sw_mem_blend(vdb_buf_tmp, (lv_color_t *)map_p, map_useful_w, opa);
 80166e2:	f9b7 2034 	ldrsh.w	r2, [r7, #52]	; 0x34
 80166e6:	78fb      	ldrb	r3, [r7, #3]
 80166e8:	6879      	ldr	r1, [r7, #4]
 80166ea:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 80166ec:	f000 f949 	bl	8016982 <sw_mem_blend>
#endif
                map_p += map_width * px_size_byte; /*Next row on the map*/
 80166f0:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 80166f4:	f897 2043 	ldrb.w	r2, [r7, #67]	; 0x43
 80166f8:	fb02 f303 	mul.w	r3, r2, r3
 80166fc:	461a      	mov	r2, r3
 80166fe:	687b      	ldr	r3, [r7, #4]
 8016700:	4413      	add	r3, r2
 8016702:	607b      	str	r3, [r7, #4]
                vdb_buf_tmp += vdb_width;          /*Next row on the VDB*/
 8016704:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8016708:	005b      	lsls	r3, r3, #1
 801670a:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801670c:	4413      	add	r3, r2
 801670e:	64fb      	str	r3, [r7, #76]	; 0x4c
            for(row = masked_a.y1; row <= masked_a.y2; row++) {
 8016710:	f9b7 304a 	ldrsh.w	r3, [r7, #74]	; 0x4a
 8016714:	b29b      	uxth	r3, r3
 8016716:	3301      	adds	r3, #1
 8016718:	b29b      	uxth	r3, r3
 801671a:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
 801671e:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8016722:	f9b7 204a 	ldrsh.w	r2, [r7, #74]	; 0x4a
 8016726:	429a      	cmp	r2, r3
 8016728:	dddb      	ble.n	80166e2 <lv_draw_map+0x24e>
        if(disp->driver.set_px_cb) {
 801672a:	e127      	b.n	801697c <lv_draw_map+0x4e8>

    /*In the other cases every pixel need to be checked one-by-one*/
    else {

        lv_coord_t col;
        lv_color_t last_img_px  = LV_COLOR_BLACK;
 801672c:	7e3b      	ldrb	r3, [r7, #24]
 801672e:	f36f 0304 	bfc	r3, #0, #5
 8016732:	763b      	strb	r3, [r7, #24]
 8016734:	8b3b      	ldrh	r3, [r7, #24]
 8016736:	f36f 134a 	bfc	r3, #5, #6
 801673a:	833b      	strh	r3, [r7, #24]
 801673c:	7e7b      	ldrb	r3, [r7, #25]
 801673e:	f36f 03c7 	bfc	r3, #3, #5
 8016742:	767b      	strb	r3, [r7, #25]
        lv_color_t recolored_px = lv_color_mix(recolor, last_img_px, recolor_opa);
 8016744:	f897 306c 	ldrb.w	r3, [r7, #108]	; 0x6c
 8016748:	461a      	mov	r2, r3
 801674a:	8b39      	ldrh	r1, [r7, #24]
 801674c:	f8b7 0068 	ldrh.w	r0, [r7, #104]	; 0x68
 8016750:	f7ff fa62 	bl	8015c18 <lv_color_mix>
 8016754:	4603      	mov	r3, r0
 8016756:	82bb      	strh	r3, [r7, #20]
        for(row = masked_a.y1; row <= masked_a.y2; row++) {
 8016758:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 801675a:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
 801675e:	e102      	b.n	8016966 <lv_draw_map+0x4d2>
            for(col = 0; col < map_useful_w; col++) {
 8016760:	2300      	movs	r3, #0
 8016762:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
 8016766:	e0e0      	b.n	801692a <lv_draw_map+0x496>
                lv_opa_t opa_result  = opa;
 8016768:	78fb      	ldrb	r3, [r7, #3]
 801676a:	f887 3045 	strb.w	r3, [r7, #69]	; 0x45
                uint8_t * px_color_p = (uint8_t *)&map_p[(uint32_t)col * px_size_byte];
 801676e:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 8016772:	f897 2043 	ldrb.w	r2, [r7, #67]	; 0x43
 8016776:	fb02 f303 	mul.w	r3, r2, r3
 801677a:	687a      	ldr	r2, [r7, #4]
 801677c:	4413      	add	r3, r2
 801677e:	62fb      	str	r3, [r7, #44]	; 0x2c
                lv_color_t px_color;

                /*Calculate with the pixel level alpha*/
                if(alpha_byte) {
 8016780:	f897 3064 	ldrb.w	r3, [r7, #100]	; 0x64
 8016784:	2b00      	cmp	r3, #0
 8016786:	d022      	beq.n	80167ce <lv_draw_map+0x33a>
#if LV_COLOR_DEPTH == 8 || LV_COLOR_DEPTH == 1
                    px_color.full = px_color_p[0];
#elif LV_COLOR_DEPTH == 16
                    /*Because of Alpha byte 16 bit color can start on odd address which can cause
                     * crash*/
                    px_color.full = px_color_p[0] + (px_color_p[1] << 8);
 8016788:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801678a:	781b      	ldrb	r3, [r3, #0]
 801678c:	b29a      	uxth	r2, r3
 801678e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016790:	3301      	adds	r3, #1
 8016792:	781b      	ldrb	r3, [r3, #0]
 8016794:	b29b      	uxth	r3, r3
 8016796:	021b      	lsls	r3, r3, #8
 8016798:	b29b      	uxth	r3, r3
 801679a:	4413      	add	r3, r2
 801679c:	b29b      	uxth	r3, r3
 801679e:	823b      	strh	r3, [r7, #16]
#elif LV_COLOR_DEPTH == 32
                    px_color = *((lv_color_t *)px_color_p);
#endif
                    lv_opa_t px_opa = *(px_color_p + LV_IMG_PX_SIZE_ALPHA_BYTE - 1);
 80167a0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80167a2:	789b      	ldrb	r3, [r3, #2]
 80167a4:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
                    if(px_opa == LV_OPA_TRANSP)
 80167a8:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 80167ac:	2b00      	cmp	r3, #0
 80167ae:	f000 80b2 	beq.w	8016916 <lv_draw_map+0x482>
                        continue;
                    else if(px_opa != LV_OPA_COVER)
 80167b2:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 80167b6:	2bff      	cmp	r3, #255	; 0xff
 80167b8:	d00c      	beq.n	80167d4 <lv_draw_map+0x340>
                        opa_result = (uint32_t)((uint32_t)px_opa * opa_result) >> 8;
 80167ba:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 80167be:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 80167c2:	fb02 f303 	mul.w	r3, r2, r3
 80167c6:	0a1b      	lsrs	r3, r3, #8
 80167c8:	f887 3045 	strb.w	r3, [r7, #69]	; 0x45
 80167cc:	e002      	b.n	80167d4 <lv_draw_map+0x340>
                } else {
                    px_color = *((lv_color_t *)px_color_p);
 80167ce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80167d0:	881b      	ldrh	r3, [r3, #0]
 80167d2:	823b      	strh	r3, [r7, #16]
                }

                /*Handle chroma key*/
                if(chroma_key && px_color.full == disp->driver.color_chroma_key.full) continue;
 80167d4:	f897 3060 	ldrb.w	r3, [r7, #96]	; 0x60
 80167d8:	2b00      	cmp	r3, #0
 80167da:	d005      	beq.n	80167e8 <lv_draw_map+0x354>
 80167dc:	8a3a      	ldrh	r2, [r7, #16]
 80167de:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80167e0:	8b9b      	ldrh	r3, [r3, #28]
 80167e2:	429a      	cmp	r2, r3
 80167e4:	f000 8099 	beq.w	801691a <lv_draw_map+0x486>

                /*Re-color the pixel if required*/
                if(recolor_opa != LV_OPA_TRANSP) {
 80167e8:	f897 306c 	ldrb.w	r3, [r7, #108]	; 0x6c
 80167ec:	2b00      	cmp	r3, #0
 80167ee:	d04d      	beq.n	801688c <lv_draw_map+0x3f8>
                    if(last_img_px.full != px_color.full) { /*Minor acceleration: calculate only for
 80167f0:	8b3a      	ldrh	r2, [r7, #24]
 80167f2:	8a3b      	ldrh	r3, [r7, #16]
 80167f4:	429a      	cmp	r2, r3
 80167f6:	d00b      	beq.n	8016810 <lv_draw_map+0x37c>
                                                               new colors (save the last)*/
                        last_img_px  = px_color;
 80167f8:	8a3b      	ldrh	r3, [r7, #16]
 80167fa:	833b      	strh	r3, [r7, #24]
                        recolored_px = lv_color_mix(recolor, last_img_px, recolor_opa);
 80167fc:	f897 306c 	ldrb.w	r3, [r7, #108]	; 0x6c
 8016800:	461a      	mov	r2, r3
 8016802:	8b39      	ldrh	r1, [r7, #24]
 8016804:	f8b7 0068 	ldrh.w	r0, [r7, #104]	; 0x68
 8016808:	f7ff fa06 	bl	8015c18 <lv_color_mix>
 801680c:	4603      	mov	r3, r0
 801680e:	82bb      	strh	r3, [r7, #20]
                    }
                    /*Handle custom VDB write is present*/
                    if(disp->driver.set_px_cb) {
 8016810:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016812:	695b      	ldr	r3, [r3, #20]
 8016814:	2b00      	cmp	r3, #0
 8016816:	d01a      	beq.n	801684e <lv_draw_map+0x3ba>
                        disp->driver.set_px_cb(&disp->driver, (uint8_t *)vdb->buf_act, vdb_width, col + masked_a.x1,
 8016818:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801681a:	695c      	ldr	r4, [r3, #20]
 801681c:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 801681e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8016820:	6899      	ldr	r1, [r3, #8]
 8016822:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 8016826:	b29a      	uxth	r2, r3
 8016828:	f8b7 3046 	ldrh.w	r3, [r7, #70]	; 0x46
 801682c:	4413      	add	r3, r2
 801682e:	b29b      	uxth	r3, r3
 8016830:	b21d      	sxth	r5, r3
 8016832:	f9b7 2036 	ldrsh.w	r2, [r7, #54]	; 0x36
 8016836:	f897 3045 	ldrb.w	r3, [r7, #69]	; 0x45
 801683a:	9302      	str	r3, [sp, #8]
 801683c:	8abb      	ldrh	r3, [r7, #20]
 801683e:	f8ad 3004 	strh.w	r3, [sp, #4]
 8016842:	f9b7 304a 	ldrsh.w	r3, [r7, #74]	; 0x4a
 8016846:	9300      	str	r3, [sp, #0]
 8016848:	462b      	mov	r3, r5
 801684a:	47a0      	blx	r4
 801684c:	e066      	b.n	801691c <lv_draw_map+0x488>
                                               row, recolored_px, opa_result);
                    }
                    /*Normal native VDB write*/
                    else {
                        if(opa_result == LV_OPA_COVER)
 801684e:	f897 3045 	ldrb.w	r3, [r7, #69]	; 0x45
 8016852:	2bff      	cmp	r3, #255	; 0xff
 8016854:	d107      	bne.n	8016866 <lv_draw_map+0x3d2>
                            vdb_buf_tmp[col].full = recolored_px.full;
 8016856:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 801685a:	005b      	lsls	r3, r3, #1
 801685c:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801685e:	4413      	add	r3, r2
 8016860:	8aba      	ldrh	r2, [r7, #20]
 8016862:	801a      	strh	r2, [r3, #0]
 8016864:	e05a      	b.n	801691c <lv_draw_map+0x488>
                        else
                            vdb_buf_tmp[col] = lv_color_mix(recolored_px, vdb_buf_tmp[col], opa_result);
 8016866:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 801686a:	005b      	lsls	r3, r3, #1
 801686c:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801686e:	4413      	add	r3, r2
 8016870:	f9b7 2046 	ldrsh.w	r2, [r7, #70]	; 0x46
 8016874:	0052      	lsls	r2, r2, #1
 8016876:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 8016878:	188c      	adds	r4, r1, r2
 801687a:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 801687e:	8819      	ldrh	r1, [r3, #0]
 8016880:	8ab8      	ldrh	r0, [r7, #20]
 8016882:	f7ff f9c9 	bl	8015c18 <lv_color_mix>
 8016886:	4603      	mov	r3, r0
 8016888:	8023      	strh	r3, [r4, #0]
 801688a:	e047      	b.n	801691c <lv_draw_map+0x488>
                    }
                } else {
                    /*Handle custom VDB write is present*/
                    if(disp->driver.set_px_cb) {
 801688c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801688e:	695b      	ldr	r3, [r3, #20]
 8016890:	2b00      	cmp	r3, #0
 8016892:	d01a      	beq.n	80168ca <lv_draw_map+0x436>
                        disp->driver.set_px_cb(&disp->driver, (uint8_t *)vdb->buf_act, vdb_width, col + masked_a.x1,
 8016894:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8016896:	695c      	ldr	r4, [r3, #20]
 8016898:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 801689a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801689c:	6899      	ldr	r1, [r3, #8]
 801689e:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 80168a2:	b29a      	uxth	r2, r3
 80168a4:	f8b7 3046 	ldrh.w	r3, [r7, #70]	; 0x46
 80168a8:	4413      	add	r3, r2
 80168aa:	b29b      	uxth	r3, r3
 80168ac:	b21d      	sxth	r5, r3
 80168ae:	f9b7 2036 	ldrsh.w	r2, [r7, #54]	; 0x36
 80168b2:	f897 3045 	ldrb.w	r3, [r7, #69]	; 0x45
 80168b6:	9302      	str	r3, [sp, #8]
 80168b8:	8a3b      	ldrh	r3, [r7, #16]
 80168ba:	f8ad 3004 	strh.w	r3, [sp, #4]
 80168be:	f9b7 304a 	ldrsh.w	r3, [r7, #74]	; 0x4a
 80168c2:	9300      	str	r3, [sp, #0]
 80168c4:	462b      	mov	r3, r5
 80168c6:	47a0      	blx	r4
 80168c8:	e028      	b.n	801691c <lv_draw_map+0x488>
                                               row, px_color, opa_result);
                    }
                    /*Normal native VDB write*/
                    else {

                        if(opa_result == LV_OPA_COVER)
 80168ca:	f897 3045 	ldrb.w	r3, [r7, #69]	; 0x45
 80168ce:	2bff      	cmp	r3, #255	; 0xff
 80168d0:	d107      	bne.n	80168e2 <lv_draw_map+0x44e>
                            vdb_buf_tmp[col] = px_color;
 80168d2:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 80168d6:	005b      	lsls	r3, r3, #1
 80168d8:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80168da:	4413      	add	r3, r2
 80168dc:	8a3a      	ldrh	r2, [r7, #16]
 80168de:	801a      	strh	r2, [r3, #0]
 80168e0:	e01c      	b.n	801691c <lv_draw_map+0x488>
                        else {
                            if(scr_transp == false) {
 80168e2:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 80168e6:	f083 0301 	eor.w	r3, r3, #1
 80168ea:	b2db      	uxtb	r3, r3
 80168ec:	2b00      	cmp	r3, #0
 80168ee:	d015      	beq.n	801691c <lv_draw_map+0x488>
                                vdb_buf_tmp[col] = lv_color_mix(px_color, vdb_buf_tmp[col], opa_result);
 80168f0:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 80168f4:	005b      	lsls	r3, r3, #1
 80168f6:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80168f8:	4413      	add	r3, r2
 80168fa:	f9b7 2046 	ldrsh.w	r2, [r7, #70]	; 0x46
 80168fe:	0052      	lsls	r2, r2, #1
 8016900:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
 8016902:	188c      	adds	r4, r1, r2
 8016904:	f897 2045 	ldrb.w	r2, [r7, #69]	; 0x45
 8016908:	8819      	ldrh	r1, [r3, #0]
 801690a:	8a38      	ldrh	r0, [r7, #16]
 801690c:	f7ff f984 	bl	8015c18 <lv_color_mix>
 8016910:	4603      	mov	r3, r0
 8016912:	8023      	strh	r3, [r4, #0]
 8016914:	e002      	b.n	801691c <lv_draw_map+0x488>
                        continue;
 8016916:	bf00      	nop
 8016918:	e000      	b.n	801691c <lv_draw_map+0x488>
                if(chroma_key && px_color.full == disp->driver.color_chroma_key.full) continue;
 801691a:	bf00      	nop
            for(col = 0; col < map_useful_w; col++) {
 801691c:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 8016920:	b29b      	uxth	r3, r3
 8016922:	3301      	adds	r3, #1
 8016924:	b29b      	uxth	r3, r3
 8016926:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
 801692a:	f9b7 2046 	ldrsh.w	r2, [r7, #70]	; 0x46
 801692e:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8016932:	429a      	cmp	r2, r3
 8016934:	f6ff af18 	blt.w	8016768 <lv_draw_map+0x2d4>
                        }
                    }
                }
            }

            map_p += map_width * px_size_byte; /*Next row on the map*/
 8016938:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 801693c:	f897 2043 	ldrb.w	r2, [r7, #67]	; 0x43
 8016940:	fb02 f303 	mul.w	r3, r2, r3
 8016944:	461a      	mov	r2, r3
 8016946:	687b      	ldr	r3, [r7, #4]
 8016948:	4413      	add	r3, r2
 801694a:	607b      	str	r3, [r7, #4]
            vdb_buf_tmp += vdb_width;          /*Next row on the VDB*/
 801694c:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8016950:	005b      	lsls	r3, r3, #1
 8016952:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8016954:	4413      	add	r3, r2
 8016956:	64fb      	str	r3, [r7, #76]	; 0x4c
        for(row = masked_a.y1; row <= masked_a.y2; row++) {
 8016958:	f9b7 304a 	ldrsh.w	r3, [r7, #74]	; 0x4a
 801695c:	b29b      	uxth	r3, r3
 801695e:	3301      	adds	r3, #1
 8016960:	b29b      	uxth	r3, r3
 8016962:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
 8016966:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 801696a:	f9b7 204a 	ldrsh.w	r2, [r7, #74]	; 0x4a
 801696e:	429a      	cmp	r2, r3
 8016970:	f77f aef6 	ble.w	8016760 <lv_draw_map+0x2cc>
 8016974:	e002      	b.n	801697c <lv_draw_map+0x4e8>
    if(opa < LV_OPA_MIN) return;
 8016976:	bf00      	nop
 8016978:	e000      	b.n	801697c <lv_draw_map+0x4e8>
    if(union_ok == false) return;
 801697a:	bf00      	nop
        }
    }
}
 801697c:	3750      	adds	r7, #80	; 0x50
 801697e:	46bd      	mov	sp, r7
 8016980:	bdb0      	pop	{r4, r5, r7, pc}

08016982 <sw_mem_blend>:
 * @param src pointer to pixel map. Copy it to 'dest'.
 * @param length number of pixels in 'src'
 * @param opa opacity (0, LV_OPA_TRANSP: transparent ... 255, LV_OPA_COVER, fully cover)
 */
static void sw_mem_blend(lv_color_t * dest, const lv_color_t * src, uint32_t length, lv_opa_t opa)
{
 8016982:	b590      	push	{r4, r7, lr}
 8016984:	b087      	sub	sp, #28
 8016986:	af00      	add	r7, sp, #0
 8016988:	60f8      	str	r0, [r7, #12]
 801698a:	60b9      	str	r1, [r7, #8]
 801698c:	607a      	str	r2, [r7, #4]
 801698e:	70fb      	strb	r3, [r7, #3]
    if(opa == LV_OPA_COVER) {
 8016990:	78fb      	ldrb	r3, [r7, #3]
 8016992:	2bff      	cmp	r3, #255	; 0xff
 8016994:	d107      	bne.n	80169a6 <sw_mem_blend+0x24>
        memcpy(dest, src, length * sizeof(lv_color_t));
 8016996:	687b      	ldr	r3, [r7, #4]
 8016998:	005b      	lsls	r3, r3, #1
 801699a:	461a      	mov	r2, r3
 801699c:	68b9      	ldr	r1, [r7, #8]
 801699e:	68f8      	ldr	r0, [r7, #12]
 80169a0:	f00b f95a 	bl	8021c58 <memcpy>
        uint32_t col;
        for(col = 0; col < length; col++) {
            dest[col] = lv_color_mix(src[col], dest[col], opa);
        }
    }
}
 80169a4:	e01c      	b.n	80169e0 <sw_mem_blend+0x5e>
        for(col = 0; col < length; col++) {
 80169a6:	2300      	movs	r3, #0
 80169a8:	617b      	str	r3, [r7, #20]
 80169aa:	e015      	b.n	80169d8 <sw_mem_blend+0x56>
            dest[col] = lv_color_mix(src[col], dest[col], opa);
 80169ac:	697b      	ldr	r3, [r7, #20]
 80169ae:	005b      	lsls	r3, r3, #1
 80169b0:	68ba      	ldr	r2, [r7, #8]
 80169b2:	4413      	add	r3, r2
 80169b4:	697a      	ldr	r2, [r7, #20]
 80169b6:	0052      	lsls	r2, r2, #1
 80169b8:	68f9      	ldr	r1, [r7, #12]
 80169ba:	4411      	add	r1, r2
 80169bc:	697a      	ldr	r2, [r7, #20]
 80169be:	0052      	lsls	r2, r2, #1
 80169c0:	68f8      	ldr	r0, [r7, #12]
 80169c2:	1884      	adds	r4, r0, r2
 80169c4:	78fa      	ldrb	r2, [r7, #3]
 80169c6:	8809      	ldrh	r1, [r1, #0]
 80169c8:	8818      	ldrh	r0, [r3, #0]
 80169ca:	f7ff f925 	bl	8015c18 <lv_color_mix>
 80169ce:	4603      	mov	r3, r0
 80169d0:	8023      	strh	r3, [r4, #0]
        for(col = 0; col < length; col++) {
 80169d2:	697b      	ldr	r3, [r7, #20]
 80169d4:	3301      	adds	r3, #1
 80169d6:	617b      	str	r3, [r7, #20]
 80169d8:	697a      	ldr	r2, [r7, #20]
 80169da:	687b      	ldr	r3, [r7, #4]
 80169dc:	429a      	cmp	r2, r3
 80169de:	d3e5      	bcc.n	80169ac <sw_mem_blend+0x2a>
}
 80169e0:	bf00      	nop
 80169e2:	371c      	adds	r7, #28
 80169e4:	46bd      	mov	sp, r7
 80169e6:	bd90      	pop	{r4, r7, pc}

080169e8 <sw_color_fill>:
 * @param color fill color
 * @param opa opacity (0, LV_OPA_TRANSP: transparent ... 255, LV_OPA_COVER, fully cover)
 */
static void sw_color_fill(lv_color_t * mem, lv_coord_t mem_width, const lv_area_t * fill_area, lv_color_t color,
                          lv_opa_t opa)
{
 80169e8:	b590      	push	{r4, r7, lr}
 80169ea:	b08f      	sub	sp, #60	; 0x3c
 80169ec:	af04      	add	r7, sp, #16
 80169ee:	60f8      	str	r0, [r7, #12]
 80169f0:	607a      	str	r2, [r7, #4]
 80169f2:	813b      	strh	r3, [r7, #8]
 80169f4:	460b      	mov	r3, r1
 80169f6:	817b      	strh	r3, [r7, #10]
    /*Set all row in vdb to the given color*/
    lv_coord_t row;
    lv_coord_t col;

    lv_disp_t * disp = lv_refr_get_disp_refreshing();
 80169f8:	f7fd fd4c 	bl	8014494 <lv_refr_get_disp_refreshing>
 80169fc:	6238      	str	r0, [r7, #32]
    if(disp->driver.set_px_cb) {
 80169fe:	6a3b      	ldr	r3, [r7, #32]
 8016a00:	695b      	ldr	r3, [r3, #20]
 8016a02:	2b00      	cmp	r3, #0
 8016a04:	d035      	beq.n	8016a72 <sw_color_fill+0x8a>
        for(col = fill_area->x1; col <= fill_area->x2; col++) {
 8016a06:	687b      	ldr	r3, [r7, #4]
 8016a08:	881b      	ldrh	r3, [r3, #0]
 8016a0a:	84bb      	strh	r3, [r7, #36]	; 0x24
 8016a0c:	e029      	b.n	8016a62 <sw_color_fill+0x7a>
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
 8016a0e:	687b      	ldr	r3, [r7, #4]
 8016a10:	885b      	ldrh	r3, [r3, #2]
 8016a12:	84fb      	strh	r3, [r7, #38]	; 0x26
 8016a14:	e018      	b.n	8016a48 <sw_color_fill+0x60>
                disp->driver.set_px_cb(&disp->driver, (uint8_t *)mem, mem_width, col, row, color, opa);
 8016a16:	6a3b      	ldr	r3, [r7, #32]
 8016a18:	695c      	ldr	r4, [r3, #20]
 8016a1a:	6a38      	ldr	r0, [r7, #32]
 8016a1c:	f9b7 1024 	ldrsh.w	r1, [r7, #36]	; 0x24
 8016a20:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 8016a24:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 8016a28:	9302      	str	r3, [sp, #8]
 8016a2a:	893b      	ldrh	r3, [r7, #8]
 8016a2c:	f8ad 3004 	strh.w	r3, [sp, #4]
 8016a30:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8016a34:	9300      	str	r3, [sp, #0]
 8016a36:	460b      	mov	r3, r1
 8016a38:	68f9      	ldr	r1, [r7, #12]
 8016a3a:	47a0      	blx	r4
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
 8016a3c:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8016a40:	b29b      	uxth	r3, r3
 8016a42:	3301      	adds	r3, #1
 8016a44:	b29b      	uxth	r3, r3
 8016a46:	84fb      	strh	r3, [r7, #38]	; 0x26
 8016a48:	687b      	ldr	r3, [r7, #4]
 8016a4a:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8016a4e:	f9b7 2026 	ldrsh.w	r2, [r7, #38]	; 0x26
 8016a52:	429a      	cmp	r2, r3
 8016a54:	dddf      	ble.n	8016a16 <sw_color_fill+0x2e>
        for(col = fill_area->x1; col <= fill_area->x2; col++) {
 8016a56:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8016a5a:	b29b      	uxth	r3, r3
 8016a5c:	3301      	adds	r3, #1
 8016a5e:	b29b      	uxth	r3, r3
 8016a60:	84bb      	strh	r3, [r7, #36]	; 0x24
 8016a62:	687b      	ldr	r3, [r7, #4]
 8016a64:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8016a68:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
 8016a6c:	429a      	cmp	r2, r3
 8016a6e:	ddce      	ble.n	8016a0e <sw_color_fill+0x26>
                }
                mem += mem_width;
            }
        }
    }
}
 8016a70:	e0ce      	b.n	8016c10 <sw_color_fill+0x228>
        mem += fill_area->y1 * mem_width; /*Go to the first row*/
 8016a72:	687b      	ldr	r3, [r7, #4]
 8016a74:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8016a78:	461a      	mov	r2, r3
 8016a7a:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8016a7e:	fb03 f302 	mul.w	r3, r3, r2
 8016a82:	005b      	lsls	r3, r3, #1
 8016a84:	68fa      	ldr	r2, [r7, #12]
 8016a86:	4413      	add	r3, r2
 8016a88:	60fb      	str	r3, [r7, #12]
        if(opa == LV_OPA_COVER) {
 8016a8a:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 8016a8e:	2bff      	cmp	r3, #255	; 0xff
 8016a90:	d159      	bne.n	8016b46 <sw_color_fill+0x15e>
            for(col = fill_area->x1; col <= fill_area->x2; col++) {
 8016a92:	687b      	ldr	r3, [r7, #4]
 8016a94:	881b      	ldrh	r3, [r3, #0]
 8016a96:	84bb      	strh	r3, [r7, #36]	; 0x24
 8016a98:	e00c      	b.n	8016ab4 <sw_color_fill+0xcc>
                mem[col] = color;
 8016a9a:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8016a9e:	005b      	lsls	r3, r3, #1
 8016aa0:	68fa      	ldr	r2, [r7, #12]
 8016aa2:	4413      	add	r3, r2
 8016aa4:	893a      	ldrh	r2, [r7, #8]
 8016aa6:	801a      	strh	r2, [r3, #0]
            for(col = fill_area->x1; col <= fill_area->x2; col++) {
 8016aa8:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8016aac:	b29b      	uxth	r3, r3
 8016aae:	3301      	adds	r3, #1
 8016ab0:	b29b      	uxth	r3, r3
 8016ab2:	84bb      	strh	r3, [r7, #36]	; 0x24
 8016ab4:	687b      	ldr	r3, [r7, #4]
 8016ab6:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8016aba:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
 8016abe:	429a      	cmp	r2, r3
 8016ac0:	ddeb      	ble.n	8016a9a <sw_color_fill+0xb2>
            lv_color_t * mem_first = &mem[fill_area->x1];
 8016ac2:	687b      	ldr	r3, [r7, #4]
 8016ac4:	f9b3 3000 	ldrsh.w	r3, [r3]
 8016ac8:	005b      	lsls	r3, r3, #1
 8016aca:	68fa      	ldr	r2, [r7, #12]
 8016acc:	4413      	add	r3, r2
 8016ace:	61bb      	str	r3, [r7, #24]
            lv_coord_t copy_size   = (fill_area->x2 - fill_area->x1 + 1) * sizeof(lv_color_t);
 8016ad0:	687b      	ldr	r3, [r7, #4]
 8016ad2:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8016ad6:	461a      	mov	r2, r3
 8016ad8:	687b      	ldr	r3, [r7, #4]
 8016ada:	f9b3 3000 	ldrsh.w	r3, [r3]
 8016ade:	1ad3      	subs	r3, r2, r3
 8016ae0:	3301      	adds	r3, #1
 8016ae2:	b29b      	uxth	r3, r3
 8016ae4:	005b      	lsls	r3, r3, #1
 8016ae6:	b29b      	uxth	r3, r3
 8016ae8:	82fb      	strh	r3, [r7, #22]
            mem += mem_width;
 8016aea:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8016aee:	005b      	lsls	r3, r3, #1
 8016af0:	68fa      	ldr	r2, [r7, #12]
 8016af2:	4413      	add	r3, r2
 8016af4:	60fb      	str	r3, [r7, #12]
            for(row = fill_area->y1 + 1; row <= fill_area->y2; row++) {
 8016af6:	687b      	ldr	r3, [r7, #4]
 8016af8:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8016afc:	b29b      	uxth	r3, r3
 8016afe:	3301      	adds	r3, #1
 8016b00:	b29b      	uxth	r3, r3
 8016b02:	84fb      	strh	r3, [r7, #38]	; 0x26
 8016b04:	e017      	b.n	8016b36 <sw_color_fill+0x14e>
                memcpy(&mem[fill_area->x1], mem_first, copy_size);
 8016b06:	687b      	ldr	r3, [r7, #4]
 8016b08:	f9b3 3000 	ldrsh.w	r3, [r3]
 8016b0c:	005b      	lsls	r3, r3, #1
 8016b0e:	68fa      	ldr	r2, [r7, #12]
 8016b10:	4413      	add	r3, r2
 8016b12:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 8016b16:	69b9      	ldr	r1, [r7, #24]
 8016b18:	4618      	mov	r0, r3
 8016b1a:	f00b f89d 	bl	8021c58 <memcpy>
                mem += mem_width;
 8016b1e:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8016b22:	005b      	lsls	r3, r3, #1
 8016b24:	68fa      	ldr	r2, [r7, #12]
 8016b26:	4413      	add	r3, r2
 8016b28:	60fb      	str	r3, [r7, #12]
            for(row = fill_area->y1 + 1; row <= fill_area->y2; row++) {
 8016b2a:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8016b2e:	b29b      	uxth	r3, r3
 8016b30:	3301      	adds	r3, #1
 8016b32:	b29b      	uxth	r3, r3
 8016b34:	84fb      	strh	r3, [r7, #38]	; 0x26
 8016b36:	687b      	ldr	r3, [r7, #4]
 8016b38:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8016b3c:	f9b7 2026 	ldrsh.w	r2, [r7, #38]	; 0x26
 8016b40:	429a      	cmp	r2, r3
 8016b42:	dde0      	ble.n	8016b06 <sw_color_fill+0x11e>
}
 8016b44:	e064      	b.n	8016c10 <sw_color_fill+0x228>
            bool scr_transp = false;
 8016b46:	2300      	movs	r3, #0
 8016b48:	77fb      	strb	r3, [r7, #31]
            lv_color_t bg_tmp  = LV_COLOR_BLACK;
 8016b4a:	7d3b      	ldrb	r3, [r7, #20]
 8016b4c:	f36f 0304 	bfc	r3, #0, #5
 8016b50:	753b      	strb	r3, [r7, #20]
 8016b52:	8abb      	ldrh	r3, [r7, #20]
 8016b54:	f36f 134a 	bfc	r3, #5, #6
 8016b58:	82bb      	strh	r3, [r7, #20]
 8016b5a:	7d7b      	ldrb	r3, [r7, #21]
 8016b5c:	f36f 03c7 	bfc	r3, #3, #5
 8016b60:	757b      	strb	r3, [r7, #21]
            lv_color_t opa_tmp = lv_color_mix(color, bg_tmp, opa);
 8016b62:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 8016b66:	461a      	mov	r2, r3
 8016b68:	8ab9      	ldrh	r1, [r7, #20]
 8016b6a:	8938      	ldrh	r0, [r7, #8]
 8016b6c:	f7ff f854 	bl	8015c18 <lv_color_mix>
 8016b70:	4603      	mov	r3, r0
 8016b72:	823b      	strh	r3, [r7, #16]
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
 8016b74:	687b      	ldr	r3, [r7, #4]
 8016b76:	885b      	ldrh	r3, [r3, #2]
 8016b78:	84fb      	strh	r3, [r7, #38]	; 0x26
 8016b7a:	e042      	b.n	8016c02 <sw_color_fill+0x21a>
                for(col = fill_area->x1; col <= fill_area->x2; col++) {
 8016b7c:	687b      	ldr	r3, [r7, #4]
 8016b7e:	881b      	ldrh	r3, [r3, #0]
 8016b80:	84bb      	strh	r3, [r7, #36]	; 0x24
 8016b82:	e02b      	b.n	8016bdc <sw_color_fill+0x1f4>
                    if(scr_transp == false) {
 8016b84:	7ffb      	ldrb	r3, [r7, #31]
 8016b86:	f083 0301 	eor.w	r3, r3, #1
 8016b8a:	b2db      	uxtb	r3, r3
 8016b8c:	2b00      	cmp	r3, #0
 8016b8e:	d01f      	beq.n	8016bd0 <sw_color_fill+0x1e8>
                        if(mem[col].full != bg_tmp.full) {
 8016b90:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8016b94:	005b      	lsls	r3, r3, #1
 8016b96:	68fa      	ldr	r2, [r7, #12]
 8016b98:	4413      	add	r3, r2
 8016b9a:	881a      	ldrh	r2, [r3, #0]
 8016b9c:	8abb      	ldrh	r3, [r7, #20]
 8016b9e:	429a      	cmp	r2, r3
 8016ba0:	d00f      	beq.n	8016bc2 <sw_color_fill+0x1da>
                            bg_tmp  = mem[col];
 8016ba2:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8016ba6:	005b      	lsls	r3, r3, #1
 8016ba8:	68fa      	ldr	r2, [r7, #12]
 8016baa:	4413      	add	r3, r2
 8016bac:	881b      	ldrh	r3, [r3, #0]
 8016bae:	82bb      	strh	r3, [r7, #20]
                            opa_tmp = lv_color_mix(color, bg_tmp, opa);
 8016bb0:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 8016bb4:	461a      	mov	r2, r3
 8016bb6:	8ab9      	ldrh	r1, [r7, #20]
 8016bb8:	8938      	ldrh	r0, [r7, #8]
 8016bba:	f7ff f82d 	bl	8015c18 <lv_color_mix>
 8016bbe:	4603      	mov	r3, r0
 8016bc0:	823b      	strh	r3, [r7, #16]
                        mem[col] = opa_tmp;
 8016bc2:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8016bc6:	005b      	lsls	r3, r3, #1
 8016bc8:	68fa      	ldr	r2, [r7, #12]
 8016bca:	4413      	add	r3, r2
 8016bcc:	8a3a      	ldrh	r2, [r7, #16]
 8016bce:	801a      	strh	r2, [r3, #0]
                for(col = fill_area->x1; col <= fill_area->x2; col++) {
 8016bd0:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8016bd4:	b29b      	uxth	r3, r3
 8016bd6:	3301      	adds	r3, #1
 8016bd8:	b29b      	uxth	r3, r3
 8016bda:	84bb      	strh	r3, [r7, #36]	; 0x24
 8016bdc:	687b      	ldr	r3, [r7, #4]
 8016bde:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8016be2:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
 8016be6:	429a      	cmp	r2, r3
 8016be8:	ddcc      	ble.n	8016b84 <sw_color_fill+0x19c>
                mem += mem_width;
 8016bea:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8016bee:	005b      	lsls	r3, r3, #1
 8016bf0:	68fa      	ldr	r2, [r7, #12]
 8016bf2:	4413      	add	r3, r2
 8016bf4:	60fb      	str	r3, [r7, #12]
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
 8016bf6:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8016bfa:	b29b      	uxth	r3, r3
 8016bfc:	3301      	adds	r3, #1
 8016bfe:	b29b      	uxth	r3, r3
 8016c00:	84fb      	strh	r3, [r7, #38]	; 0x26
 8016c02:	687b      	ldr	r3, [r7, #4]
 8016c04:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8016c08:	f9b7 2026 	ldrsh.w	r2, [r7, #38]	; 0x26
 8016c0c:	429a      	cmp	r2, r3
 8016c0e:	ddb5      	ble.n	8016b7c <sw_color_fill+0x194>
}
 8016c10:	bf00      	nop
 8016c12:	372c      	adds	r7, #44	; 0x2c
 8016c14:	46bd      	mov	sp, r7
 8016c16:	bd90      	pop	{r4, r7, pc}

08016c18 <lv_area_copy>:
 * Copy an area
 * @param dest pointer to the destination area
 * @param src pointer to the source area
 */
inline static void lv_area_copy(lv_area_t * dest, const lv_area_t * src)
{
 8016c18:	b580      	push	{r7, lr}
 8016c1a:	b082      	sub	sp, #8
 8016c1c:	af00      	add	r7, sp, #0
 8016c1e:	6078      	str	r0, [r7, #4]
 8016c20:	6039      	str	r1, [r7, #0]
    memcpy(dest, src, sizeof(lv_area_t));
 8016c22:	2208      	movs	r2, #8
 8016c24:	6839      	ldr	r1, [r7, #0]
 8016c26:	6878      	ldr	r0, [r7, #4]
 8016c28:	f00b f816 	bl	8021c58 <memcpy>
}
 8016c2c:	bf00      	nop
 8016c2e:	3708      	adds	r7, #8
 8016c30:	46bd      	mov	sp, r7
 8016c32:	bd80      	pop	{r7, pc}

08016c34 <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
 8016c34:	b480      	push	{r7}
 8016c36:	b083      	sub	sp, #12
 8016c38:	af00      	add	r7, sp, #0
 8016c3a:	6078      	str	r0, [r7, #4]
    return area_p->x2 - area_p->x1 + 1;
 8016c3c:	687b      	ldr	r3, [r7, #4]
 8016c3e:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8016c42:	b29a      	uxth	r2, r3
 8016c44:	687b      	ldr	r3, [r7, #4]
 8016c46:	f9b3 3000 	ldrsh.w	r3, [r3]
 8016c4a:	b29b      	uxth	r3, r3
 8016c4c:	1ad3      	subs	r3, r2, r3
 8016c4e:	b29b      	uxth	r3, r3
 8016c50:	3301      	adds	r3, #1
 8016c52:	b29b      	uxth	r3, r3
 8016c54:	b21b      	sxth	r3, r3
}
 8016c56:	4618      	mov	r0, r3
 8016c58:	370c      	adds	r7, #12
 8016c5a:	46bd      	mov	sp, r7
 8016c5c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016c60:	4770      	bx	lr
	...

08016c64 <lv_draw_img>:
 * @param style style of the image
 * @param opa_scale scale down all opacities by the factor
 */
void lv_draw_img(const lv_area_t * coords, const lv_area_t * mask, const void * src, const lv_style_t * style,
                 lv_opa_t opa_scale)
{
 8016c64:	b580      	push	{r7, lr}
 8016c66:	b08c      	sub	sp, #48	; 0x30
 8016c68:	af06      	add	r7, sp, #24
 8016c6a:	60f8      	str	r0, [r7, #12]
 8016c6c:	60b9      	str	r1, [r7, #8]
 8016c6e:	607a      	str	r2, [r7, #4]
 8016c70:	603b      	str	r3, [r7, #0]
    if(src == NULL) {
 8016c72:	687b      	ldr	r3, [r7, #4]
 8016c74:	2b00      	cmp	r3, #0
 8016c76:	d11a      	bne.n	8016cae <lv_draw_img+0x4a>
        LV_LOG_WARN("Image draw: src is NULL");
        lv_draw_rect(coords, mask, &lv_style_plain, LV_OPA_COVER);
 8016c78:	23ff      	movs	r3, #255	; 0xff
 8016c7a:	4a23      	ldr	r2, [pc, #140]	; (8016d08 <lv_draw_img+0xa4>)
 8016c7c:	68b9      	ldr	r1, [r7, #8]
 8016c7e:	68f8      	ldr	r0, [r7, #12]
 8016c80:	f000 ff0b 	bl	8017a9a <lv_draw_rect>
        lv_draw_label(coords, mask, &lv_style_plain, LV_OPA_COVER, "No\ndata", LV_TXT_FLAG_NONE, NULL, -1, -1, NULL);
 8016c84:	2300      	movs	r3, #0
 8016c86:	9305      	str	r3, [sp, #20]
 8016c88:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8016c8c:	9304      	str	r3, [sp, #16]
 8016c8e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8016c92:	9303      	str	r3, [sp, #12]
 8016c94:	2300      	movs	r3, #0
 8016c96:	9302      	str	r3, [sp, #8]
 8016c98:	2300      	movs	r3, #0
 8016c9a:	9301      	str	r3, [sp, #4]
 8016c9c:	4b1b      	ldr	r3, [pc, #108]	; (8016d0c <lv_draw_img+0xa8>)
 8016c9e:	9300      	str	r3, [sp, #0]
 8016ca0:	23ff      	movs	r3, #255	; 0xff
 8016ca2:	4a19      	ldr	r2, [pc, #100]	; (8016d08 <lv_draw_img+0xa4>)
 8016ca4:	68b9      	ldr	r1, [r7, #8]
 8016ca6:	68f8      	ldr	r0, [r7, #12]
 8016ca8:	f000 fa5e 	bl	8017168 <lv_draw_label>
        return;
 8016cac:	e028      	b.n	8016d00 <lv_draw_img+0x9c>
    }

    lv_res_t res;
    res = lv_img_draw_core(coords, mask, src, style, opa_scale);
 8016cae:	f897 3020 	ldrb.w	r3, [r7, #32]
 8016cb2:	9300      	str	r3, [sp, #0]
 8016cb4:	683b      	ldr	r3, [r7, #0]
 8016cb6:	687a      	ldr	r2, [r7, #4]
 8016cb8:	68b9      	ldr	r1, [r7, #8]
 8016cba:	68f8      	ldr	r0, [r7, #12]
 8016cbc:	f000 f8e4 	bl	8016e88 <lv_img_draw_core>
 8016cc0:	4603      	mov	r3, r0
 8016cc2:	75fb      	strb	r3, [r7, #23]

    if(res == LV_RES_INV) {
 8016cc4:	7dfb      	ldrb	r3, [r7, #23]
 8016cc6:	2b00      	cmp	r3, #0
 8016cc8:	d11a      	bne.n	8016d00 <lv_draw_img+0x9c>
        LV_LOG_WARN("Image draw error");
        lv_draw_rect(coords, mask, &lv_style_plain, LV_OPA_COVER);
 8016cca:	23ff      	movs	r3, #255	; 0xff
 8016ccc:	4a0e      	ldr	r2, [pc, #56]	; (8016d08 <lv_draw_img+0xa4>)
 8016cce:	68b9      	ldr	r1, [r7, #8]
 8016cd0:	68f8      	ldr	r0, [r7, #12]
 8016cd2:	f000 fee2 	bl	8017a9a <lv_draw_rect>
        lv_draw_label(coords, mask, &lv_style_plain, LV_OPA_COVER, "No\ndata", LV_TXT_FLAG_NONE, NULL, -1, -1, NULL);
 8016cd6:	2300      	movs	r3, #0
 8016cd8:	9305      	str	r3, [sp, #20]
 8016cda:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8016cde:	9304      	str	r3, [sp, #16]
 8016ce0:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8016ce4:	9303      	str	r3, [sp, #12]
 8016ce6:	2300      	movs	r3, #0
 8016ce8:	9302      	str	r3, [sp, #8]
 8016cea:	2300      	movs	r3, #0
 8016cec:	9301      	str	r3, [sp, #4]
 8016cee:	4b07      	ldr	r3, [pc, #28]	; (8016d0c <lv_draw_img+0xa8>)
 8016cf0:	9300      	str	r3, [sp, #0]
 8016cf2:	23ff      	movs	r3, #255	; 0xff
 8016cf4:	4a04      	ldr	r2, [pc, #16]	; (8016d08 <lv_draw_img+0xa4>)
 8016cf6:	68b9      	ldr	r1, [r7, #8]
 8016cf8:	68f8      	ldr	r0, [r7, #12]
 8016cfa:	f000 fa35 	bl	8017168 <lv_draw_label>
        return;
 8016cfe:	bf00      	nop
    }
}
 8016d00:	3718      	adds	r7, #24
 8016d02:	46bd      	mov	sp, r7
 8016d04:	bd80      	pop	{r7, pc}
 8016d06:	bf00      	nop
 8016d08:	240634f8 	.word	0x240634f8
 8016d0c:	080228d4 	.word	0x080228d4

08016d10 <lv_img_color_format_get_px_size>:
 * Get the pixel size of a color format in bits
 * @param cf a color format (`LV_IMG_CF_...`)
 * @return the pixel size in bits
 */
uint8_t lv_img_color_format_get_px_size(lv_img_cf_t cf)
{
 8016d10:	b480      	push	{r7}
 8016d12:	b085      	sub	sp, #20
 8016d14:	af00      	add	r7, sp, #0
 8016d16:	4603      	mov	r3, r0
 8016d18:	71fb      	strb	r3, [r7, #7]
    uint8_t px_size = 0;
 8016d1a:	2300      	movs	r3, #0
 8016d1c:	73fb      	strb	r3, [r7, #15]

    switch(cf) {
 8016d1e:	79fb      	ldrb	r3, [r7, #7]
 8016d20:	2b0e      	cmp	r3, #14
 8016d22:	d836      	bhi.n	8016d92 <lv_img_color_format_get_px_size+0x82>
 8016d24:	a201      	add	r2, pc, #4	; (adr r2, 8016d2c <lv_img_color_format_get_px_size+0x1c>)
 8016d26:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8016d2a:	bf00      	nop
 8016d2c:	08016d69 	.word	0x08016d69
 8016d30:	08016d69 	.word	0x08016d69
 8016d34:	08016d93 	.word	0x08016d93
 8016d38:	08016d93 	.word	0x08016d93
 8016d3c:	08016d6f 	.word	0x08016d6f
 8016d40:	08016d75 	.word	0x08016d75
 8016d44:	08016d6f 	.word	0x08016d6f
 8016d48:	08016d7b 	.word	0x08016d7b
 8016d4c:	08016d81 	.word	0x08016d81
 8016d50:	08016d87 	.word	0x08016d87
 8016d54:	08016d8d 	.word	0x08016d8d
 8016d58:	08016d7b 	.word	0x08016d7b
 8016d5c:	08016d81 	.word	0x08016d81
 8016d60:	08016d87 	.word	0x08016d87
 8016d64:	08016d8d 	.word	0x08016d8d
        case LV_IMG_CF_UNKNOWN:
        case LV_IMG_CF_RAW: px_size = 0; break;
 8016d68:	2300      	movs	r3, #0
 8016d6a:	73fb      	strb	r3, [r7, #15]
 8016d6c:	e014      	b.n	8016d98 <lv_img_color_format_get_px_size+0x88>
        case LV_IMG_CF_TRUE_COLOR:
        case LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED: px_size = LV_COLOR_SIZE; break;
 8016d6e:	2310      	movs	r3, #16
 8016d70:	73fb      	strb	r3, [r7, #15]
 8016d72:	e011      	b.n	8016d98 <lv_img_color_format_get_px_size+0x88>
        case LV_IMG_CF_TRUE_COLOR_ALPHA: px_size = LV_IMG_PX_SIZE_ALPHA_BYTE << 3; break;
 8016d74:	2318      	movs	r3, #24
 8016d76:	73fb      	strb	r3, [r7, #15]
 8016d78:	e00e      	b.n	8016d98 <lv_img_color_format_get_px_size+0x88>
        case LV_IMG_CF_INDEXED_1BIT:
        case LV_IMG_CF_ALPHA_1BIT: px_size = 1; break;
 8016d7a:	2301      	movs	r3, #1
 8016d7c:	73fb      	strb	r3, [r7, #15]
 8016d7e:	e00b      	b.n	8016d98 <lv_img_color_format_get_px_size+0x88>
        case LV_IMG_CF_INDEXED_2BIT:
        case LV_IMG_CF_ALPHA_2BIT: px_size = 2; break;
 8016d80:	2302      	movs	r3, #2
 8016d82:	73fb      	strb	r3, [r7, #15]
 8016d84:	e008      	b.n	8016d98 <lv_img_color_format_get_px_size+0x88>
        case LV_IMG_CF_INDEXED_4BIT:
        case LV_IMG_CF_ALPHA_4BIT: px_size = 4; break;
 8016d86:	2304      	movs	r3, #4
 8016d88:	73fb      	strb	r3, [r7, #15]
 8016d8a:	e005      	b.n	8016d98 <lv_img_color_format_get_px_size+0x88>
        case LV_IMG_CF_INDEXED_8BIT:
        case LV_IMG_CF_ALPHA_8BIT: px_size = 8; break;
 8016d8c:	2308      	movs	r3, #8
 8016d8e:	73fb      	strb	r3, [r7, #15]
 8016d90:	e002      	b.n	8016d98 <lv_img_color_format_get_px_size+0x88>
        default: px_size = 0; break;
 8016d92:	2300      	movs	r3, #0
 8016d94:	73fb      	strb	r3, [r7, #15]
 8016d96:	bf00      	nop
    }

    return px_size;
 8016d98:	7bfb      	ldrb	r3, [r7, #15]
}
 8016d9a:	4618      	mov	r0, r3
 8016d9c:	3714      	adds	r7, #20
 8016d9e:	46bd      	mov	sp, r7
 8016da0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016da4:	4770      	bx	lr
 8016da6:	bf00      	nop

08016da8 <lv_img_color_format_is_chroma_keyed>:
 * Check if a color format is chroma keyed or not
 * @param cf a color format (`LV_IMG_CF_...`)
 * @return true: chroma keyed; false: not chroma keyed
 */
bool lv_img_color_format_is_chroma_keyed(lv_img_cf_t cf)
{
 8016da8:	b480      	push	{r7}
 8016daa:	b085      	sub	sp, #20
 8016dac:	af00      	add	r7, sp, #0
 8016dae:	4603      	mov	r3, r0
 8016db0:	71fb      	strb	r3, [r7, #7]
    bool is_chroma_keyed = false;
 8016db2:	2300      	movs	r3, #0
 8016db4:	73fb      	strb	r3, [r7, #15]

    switch(cf) {
 8016db6:	79fb      	ldrb	r3, [r7, #7]
 8016db8:	2b03      	cmp	r3, #3
 8016dba:	d004      	beq.n	8016dc6 <lv_img_color_format_is_chroma_keyed+0x1e>
 8016dbc:	2b03      	cmp	r3, #3
 8016dbe:	db05      	blt.n	8016dcc <lv_img_color_format_is_chroma_keyed+0x24>
 8016dc0:	3b06      	subs	r3, #6
 8016dc2:	2b04      	cmp	r3, #4
 8016dc4:	d802      	bhi.n	8016dcc <lv_img_color_format_is_chroma_keyed+0x24>
        case LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED:
        case LV_IMG_CF_RAW_CHROMA_KEYED:
        case LV_IMG_CF_INDEXED_1BIT:
        case LV_IMG_CF_INDEXED_2BIT:
        case LV_IMG_CF_INDEXED_4BIT:
        case LV_IMG_CF_INDEXED_8BIT: is_chroma_keyed = true; break;
 8016dc6:	2301      	movs	r3, #1
 8016dc8:	73fb      	strb	r3, [r7, #15]
 8016dca:	e002      	b.n	8016dd2 <lv_img_color_format_is_chroma_keyed+0x2a>
        default: is_chroma_keyed = false; break;
 8016dcc:	2300      	movs	r3, #0
 8016dce:	73fb      	strb	r3, [r7, #15]
 8016dd0:	bf00      	nop
    }

    return is_chroma_keyed;
 8016dd2:	7bfb      	ldrb	r3, [r7, #15]
}
 8016dd4:	4618      	mov	r0, r3
 8016dd6:	3714      	adds	r7, #20
 8016dd8:	46bd      	mov	sp, r7
 8016dda:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016dde:	4770      	bx	lr

08016de0 <lv_img_color_format_has_alpha>:
 * Check if a color format has alpha channel or not
 * @param cf a color format (`LV_IMG_CF_...`)
 * @return true: has alpha channel; false: doesn't have alpha channel
 */
bool lv_img_color_format_has_alpha(lv_img_cf_t cf)
{
 8016de0:	b480      	push	{r7}
 8016de2:	b085      	sub	sp, #20
 8016de4:	af00      	add	r7, sp, #0
 8016de6:	4603      	mov	r3, r0
 8016de8:	71fb      	strb	r3, [r7, #7]
    bool has_alpha = false;
 8016dea:	2300      	movs	r3, #0
 8016dec:	73fb      	strb	r3, [r7, #15]

    switch(cf) {
 8016dee:	79fb      	ldrb	r3, [r7, #7]
 8016df0:	3b02      	subs	r3, #2
 8016df2:	2b0c      	cmp	r3, #12
 8016df4:	bf8c      	ite	hi
 8016df6:	2201      	movhi	r2, #1
 8016df8:	2200      	movls	r2, #0
 8016dfa:	b2d2      	uxtb	r2, r2
 8016dfc:	2a00      	cmp	r2, #0
 8016dfe:	d10e      	bne.n	8016e1e <lv_img_color_format_has_alpha+0x3e>
 8016e00:	2201      	movs	r2, #1
 8016e02:	409a      	lsls	r2, r3
 8016e04:	f641 6309 	movw	r3, #7689	; 0x1e09
 8016e08:	4013      	ands	r3, r2
 8016e0a:	2b00      	cmp	r3, #0
 8016e0c:	bf14      	ite	ne
 8016e0e:	2301      	movne	r3, #1
 8016e10:	2300      	moveq	r3, #0
 8016e12:	b2db      	uxtb	r3, r3
 8016e14:	2b00      	cmp	r3, #0
 8016e16:	d002      	beq.n	8016e1e <lv_img_color_format_has_alpha+0x3e>
        case LV_IMG_CF_TRUE_COLOR_ALPHA:
        case LV_IMG_CF_RAW_ALPHA:
        case LV_IMG_CF_ALPHA_1BIT:
        case LV_IMG_CF_ALPHA_2BIT:
        case LV_IMG_CF_ALPHA_4BIT:
        case LV_IMG_CF_ALPHA_8BIT: has_alpha = true; break;
 8016e18:	2301      	movs	r3, #1
 8016e1a:	73fb      	strb	r3, [r7, #15]
 8016e1c:	e002      	b.n	8016e24 <lv_img_color_format_has_alpha+0x44>
        default: has_alpha = false; break;
 8016e1e:	2300      	movs	r3, #0
 8016e20:	73fb      	strb	r3, [r7, #15]
 8016e22:	bf00      	nop
    }

    return has_alpha;
 8016e24:	7bfb      	ldrb	r3, [r7, #15]
}
 8016e26:	4618      	mov	r0, r3
 8016e28:	3714      	adds	r7, #20
 8016e2a:	46bd      	mov	sp, r7
 8016e2c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016e30:	4770      	bx	lr

08016e32 <lv_img_src_get_type>:
 *  - a path to a file (e.g. "S:/folder/image.bin")
 *  - or a symbol (e.g. LV_SYMBOL_CLOSE)
 * @return type of the image source LV_IMG_SRC_VARIABLE/FILE/SYMBOL/UNKNOWN
 */
lv_img_src_t lv_img_src_get_type(const void * src)
{
 8016e32:	b480      	push	{r7}
 8016e34:	b085      	sub	sp, #20
 8016e36:	af00      	add	r7, sp, #0
 8016e38:	6078      	str	r0, [r7, #4]
    lv_img_src_t img_src_type = LV_IMG_SRC_UNKNOWN;
 8016e3a:	2303      	movs	r3, #3
 8016e3c:	73fb      	strb	r3, [r7, #15]

    if(src == NULL) return img_src_type;
 8016e3e:	687b      	ldr	r3, [r7, #4]
 8016e40:	2b00      	cmp	r3, #0
 8016e42:	d101      	bne.n	8016e48 <lv_img_src_get_type+0x16>
 8016e44:	7bfb      	ldrb	r3, [r7, #15]
 8016e46:	e018      	b.n	8016e7a <lv_img_src_get_type+0x48>
    const uint8_t * u8_p = src;
 8016e48:	687b      	ldr	r3, [r7, #4]
 8016e4a:	60bb      	str	r3, [r7, #8]

    /*The first byte shows the type of the image source*/
    if(u8_p[0] >= 0x20 && u8_p[0] <= 0x7F) {
 8016e4c:	68bb      	ldr	r3, [r7, #8]
 8016e4e:	781b      	ldrb	r3, [r3, #0]
 8016e50:	2b1f      	cmp	r3, #31
 8016e52:	d907      	bls.n	8016e64 <lv_img_src_get_type+0x32>
 8016e54:	68bb      	ldr	r3, [r7, #8]
 8016e56:	781b      	ldrb	r3, [r3, #0]
 8016e58:	b25b      	sxtb	r3, r3
 8016e5a:	2b00      	cmp	r3, #0
 8016e5c:	db02      	blt.n	8016e64 <lv_img_src_get_type+0x32>
        img_src_type = LV_IMG_SRC_FILE; /*If it's an ASCII character then it's file name*/
 8016e5e:	2301      	movs	r3, #1
 8016e60:	73fb      	strb	r3, [r7, #15]
 8016e62:	e009      	b.n	8016e78 <lv_img_src_get_type+0x46>
    } else if(u8_p[0] >= 0x80) {
 8016e64:	68bb      	ldr	r3, [r7, #8]
 8016e66:	781b      	ldrb	r3, [r3, #0]
 8016e68:	b25b      	sxtb	r3, r3
 8016e6a:	2b00      	cmp	r3, #0
 8016e6c:	da02      	bge.n	8016e74 <lv_img_src_get_type+0x42>
        img_src_type = LV_IMG_SRC_SYMBOL; /*Symbols begins after 0x7F*/
 8016e6e:	2302      	movs	r3, #2
 8016e70:	73fb      	strb	r3, [r7, #15]
 8016e72:	e001      	b.n	8016e78 <lv_img_src_get_type+0x46>
    } else {
        img_src_type = LV_IMG_SRC_VARIABLE; /*`lv_img_dsc_t` is design to the first byte < 0x20*/
 8016e74:	2300      	movs	r3, #0
 8016e76:	73fb      	strb	r3, [r7, #15]

    if(LV_IMG_SRC_UNKNOWN == img_src_type) {
        LV_LOG_WARN("lv_img_src_get_type: unknown image type");
    }

    return img_src_type;
 8016e78:	7bfb      	ldrb	r3, [r7, #15]
}
 8016e7a:	4618      	mov	r0, r3
 8016e7c:	3714      	adds	r7, #20
 8016e7e:	46bd      	mov	sp, r7
 8016e80:	f85d 7b04 	ldr.w	r7, [sp], #4
 8016e84:	4770      	bx	lr
	...

08016e88 <lv_img_draw_core>:
 *   STATIC FUNCTIONS
 **********************/

static lv_res_t lv_img_draw_core(const lv_area_t * coords, const lv_area_t * mask, const void * src,
                                 const lv_style_t * style, lv_opa_t opa_scale)
{
 8016e88:	b590      	push	{r4, r7, lr}
 8016e8a:	b095      	sub	sp, #84	; 0x54
 8016e8c:	af06      	add	r7, sp, #24
 8016e8e:	60f8      	str	r0, [r7, #12]
 8016e90:	60b9      	str	r1, [r7, #8]
 8016e92:	607a      	str	r2, [r7, #4]
 8016e94:	603b      	str	r3, [r7, #0]

    lv_area_t mask_com; /*Common area of mask and coords*/
    bool union_ok;
    union_ok = lv_area_intersect(&mask_com, mask, coords);
 8016e96:	f107 0318 	add.w	r3, r7, #24
 8016e9a:	68fa      	ldr	r2, [r7, #12]
 8016e9c:	68b9      	ldr	r1, [r7, #8]
 8016e9e:	4618      	mov	r0, r3
 8016ea0:	f006 fcba 	bl	801d818 <lv_area_intersect>
 8016ea4:	4603      	mov	r3, r0
 8016ea6:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
    if(union_ok == false) {
 8016eaa:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8016eae:	f083 0301 	eor.w	r3, r3, #1
 8016eb2:	b2db      	uxtb	r3, r3
 8016eb4:	2b00      	cmp	r3, #0
 8016eb6:	d001      	beq.n	8016ebc <lv_img_draw_core+0x34>
        return LV_RES_OK; /*Out of mask. There is nothing to draw so the image is drawn
 8016eb8:	2301      	movs	r3, #1
 8016eba:	e0fd      	b.n	80170b8 <lv_img_draw_core+0x230>
                             successfully.*/
    }

    lv_opa_t opa =
 8016ebc:	f897 3048 	ldrb.w	r3, [r7, #72]	; 0x48
 8016ec0:	2bff      	cmp	r3, #255	; 0xff
 8016ec2:	d103      	bne.n	8016ecc <lv_img_draw_core+0x44>
 8016ec4:	683b      	ldr	r3, [r7, #0]
 8016ec6:	f893 3033 	ldrb.w	r3, [r3, #51]	; 0x33
 8016eca:	e00c      	b.n	8016ee6 <lv_img_draw_core+0x5e>
        opa_scale == LV_OPA_COVER ? style->image.opa : (uint16_t)((uint16_t)style->image.opa * opa_scale) >> 8;
 8016ecc:	683b      	ldr	r3, [r7, #0]
 8016ece:	f893 3033 	ldrb.w	r3, [r3, #51]	; 0x33
 8016ed2:	b29a      	uxth	r2, r3
 8016ed4:	f897 3048 	ldrb.w	r3, [r7, #72]	; 0x48
 8016ed8:	b29b      	uxth	r3, r3
 8016eda:	fb12 f303 	smulbb	r3, r2, r3
 8016ede:	b29b      	uxth	r3, r3
    lv_opa_t opa =
 8016ee0:	0a1b      	lsrs	r3, r3, #8
 8016ee2:	b29b      	uxth	r3, r3
 8016ee4:	b2db      	uxtb	r3, r3
 8016ee6:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32

    lv_img_cache_entry_t * cdsc = lv_img_cache_open(src, style);
 8016eea:	6839      	ldr	r1, [r7, #0]
 8016eec:	6878      	ldr	r0, [r7, #4]
 8016eee:	f004 fceb 	bl	801b8c8 <lv_img_cache_open>
 8016ef2:	62f8      	str	r0, [r7, #44]	; 0x2c

    if(cdsc == NULL) return LV_RES_INV;
 8016ef4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016ef6:	2b00      	cmp	r3, #0
 8016ef8:	d101      	bne.n	8016efe <lv_img_draw_core+0x76>
 8016efa:	2300      	movs	r3, #0
 8016efc:	e0dc      	b.n	80170b8 <lv_img_draw_core+0x230>

    bool chroma_keyed = lv_img_color_format_is_chroma_keyed(cdsc->dec_dsc.header.cf);
 8016efe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016f00:	7c1b      	ldrb	r3, [r3, #16]
 8016f02:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8016f06:	b2db      	uxtb	r3, r3
 8016f08:	4618      	mov	r0, r3
 8016f0a:	f7ff ff4d 	bl	8016da8 <lv_img_color_format_is_chroma_keyed>
 8016f0e:	4603      	mov	r3, r0
 8016f10:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
    bool alpha_byte   = lv_img_color_format_has_alpha(cdsc->dec_dsc.header.cf);
 8016f14:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016f16:	7c1b      	ldrb	r3, [r3, #16]
 8016f18:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8016f1c:	b2db      	uxtb	r3, r3
 8016f1e:	4618      	mov	r0, r3
 8016f20:	f7ff ff5e 	bl	8016de0 <lv_img_color_format_has_alpha>
 8016f24:	4603      	mov	r3, r0
 8016f26:	f887 302a 	strb.w	r3, [r7, #42]	; 0x2a

    if(cdsc->dec_dsc.error_msg != NULL) {
 8016f2a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016f2c:	69db      	ldr	r3, [r3, #28]
 8016f2e:	2b00      	cmp	r3, #0
 8016f30:	d01b      	beq.n	8016f6a <lv_img_draw_core+0xe2>
        LV_LOG_WARN("Image draw error");
        lv_draw_rect(coords, mask, &lv_style_plain, LV_OPA_COVER);
 8016f32:	23ff      	movs	r3, #255	; 0xff
 8016f34:	4a62      	ldr	r2, [pc, #392]	; (80170c0 <lv_img_draw_core+0x238>)
 8016f36:	68b9      	ldr	r1, [r7, #8]
 8016f38:	68f8      	ldr	r0, [r7, #12]
 8016f3a:	f000 fdae 	bl	8017a9a <lv_draw_rect>
        lv_draw_label(coords, mask, &lv_style_plain, LV_OPA_COVER, cdsc->dec_dsc.error_msg, LV_TXT_FLAG_NONE, NULL, -1,
 8016f3e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016f40:	69db      	ldr	r3, [r3, #28]
 8016f42:	2200      	movs	r2, #0
 8016f44:	9205      	str	r2, [sp, #20]
 8016f46:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8016f4a:	9204      	str	r2, [sp, #16]
 8016f4c:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8016f50:	9203      	str	r2, [sp, #12]
 8016f52:	2200      	movs	r2, #0
 8016f54:	9202      	str	r2, [sp, #8]
 8016f56:	2200      	movs	r2, #0
 8016f58:	9201      	str	r2, [sp, #4]
 8016f5a:	9300      	str	r3, [sp, #0]
 8016f5c:	23ff      	movs	r3, #255	; 0xff
 8016f5e:	4a58      	ldr	r2, [pc, #352]	; (80170c0 <lv_img_draw_core+0x238>)
 8016f60:	68b9      	ldr	r1, [r7, #8]
 8016f62:	68f8      	ldr	r0, [r7, #12]
 8016f64:	f000 f900 	bl	8017168 <lv_draw_label>
 8016f68:	e0a5      	b.n	80170b6 <lv_img_draw_core+0x22e>
                      -1, NULL);
    }
    /* The decoder open could open the image and gave the entire uncompressed image.
     * Just draw it!*/
    else if(cdsc->dec_dsc.img_data) {
 8016f6a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016f6c:	695b      	ldr	r3, [r3, #20]
 8016f6e:	2b00      	cmp	r3, #0
 8016f70:	d017      	beq.n	8016fa2 <lv_img_draw_core+0x11a>
        lv_draw_map(coords, mask, cdsc->dec_dsc.img_data, opa, chroma_keyed, alpha_byte, style->image.color,
 8016f72:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8016f74:	695a      	ldr	r2, [r3, #20]
 8016f76:	683b      	ldr	r3, [r7, #0]
 8016f78:	f893 3032 	ldrb.w	r3, [r3, #50]	; 0x32
 8016f7c:	f897 1032 	ldrb.w	r1, [r7, #50]	; 0x32
 8016f80:	9303      	str	r3, [sp, #12]
 8016f82:	683b      	ldr	r3, [r7, #0]
 8016f84:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 8016f86:	f8ad 3008 	strh.w	r3, [sp, #8]
 8016f8a:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 8016f8e:	9301      	str	r3, [sp, #4]
 8016f90:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 8016f94:	9300      	str	r3, [sp, #0]
 8016f96:	460b      	mov	r3, r1
 8016f98:	68b9      	ldr	r1, [r7, #8]
 8016f9a:	68f8      	ldr	r0, [r7, #12]
 8016f9c:	f7ff fa7a 	bl	8016494 <lv_draw_map>
 8016fa0:	e089      	b.n	80170b6 <lv_img_draw_core+0x22e>
                    style->image.intense);
    }
    /* The whole uncompressed image is not available. Try to read it line-by-line*/
    else {
        lv_coord_t width = lv_area_get_width(&mask_com);
 8016fa2:	f107 0318 	add.w	r3, r7, #24
 8016fa6:	4618      	mov	r0, r3
 8016fa8:	f7ff fe44 	bl	8016c34 <lv_area_get_width>
 8016fac:	4603      	mov	r3, r0
 8016fae:	853b      	strh	r3, [r7, #40]	; 0x28

        uint8_t  * buf = lv_draw_get_buf(lv_area_get_width(&mask_com) * ((LV_COLOR_DEPTH >> 3) + 1));  /*+1 because of the possible alpha byte*/
 8016fb0:	f107 0318 	add.w	r3, r7, #24
 8016fb4:	4618      	mov	r0, r3
 8016fb6:	f7ff fe3d 	bl	8016c34 <lv_area_get_width>
 8016fba:	4603      	mov	r3, r0
 8016fbc:	461a      	mov	r2, r3
 8016fbe:	4613      	mov	r3, r2
 8016fc0:	005b      	lsls	r3, r3, #1
 8016fc2:	4413      	add	r3, r2
 8016fc4:	4618      	mov	r0, r3
 8016fc6:	f7fe f9e7 	bl	8015398 <lv_draw_get_buf>
 8016fca:	6278      	str	r0, [r7, #36]	; 0x24

        lv_area_t line;
        lv_area_copy(&line, &mask_com);
 8016fcc:	f107 0218 	add.w	r2, r7, #24
 8016fd0:	f107 0310 	add.w	r3, r7, #16
 8016fd4:	4611      	mov	r1, r2
 8016fd6:	4618      	mov	r0, r3
 8016fd8:	f7ff fe1e 	bl	8016c18 <lv_area_copy>
        lv_area_set_height(&line, 1);
 8016fdc:	f107 0310 	add.w	r3, r7, #16
 8016fe0:	2101      	movs	r1, #1
 8016fe2:	4618      	mov	r0, r3
 8016fe4:	f006 fbdf 	bl	801d7a6 <lv_area_set_height>
        lv_coord_t x = mask_com.x1 - coords->x1;
 8016fe8:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8016fec:	b29a      	uxth	r2, r3
 8016fee:	68fb      	ldr	r3, [r7, #12]
 8016ff0:	f9b3 3000 	ldrsh.w	r3, [r3]
 8016ff4:	b29b      	uxth	r3, r3
 8016ff6:	1ad3      	subs	r3, r2, r3
 8016ff8:	b29b      	uxth	r3, r3
 8016ffa:	847b      	strh	r3, [r7, #34]	; 0x22
        lv_coord_t y = mask_com.y1 - coords->y1;
 8016ffc:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8017000:	b29a      	uxth	r2, r3
 8017002:	68fb      	ldr	r3, [r7, #12]
 8017004:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8017008:	b29b      	uxth	r3, r3
 801700a:	1ad3      	subs	r3, r2, r3
 801700c:	b29b      	uxth	r3, r3
 801700e:	86fb      	strh	r3, [r7, #54]	; 0x36
        lv_coord_t row;
        lv_res_t read_res;
        for(row = mask_com.y1; row <= mask_com.y2; row++) {
 8017010:	8b7b      	ldrh	r3, [r7, #26]
 8017012:	86bb      	strh	r3, [r7, #52]	; 0x34
 8017014:	e049      	b.n	80170aa <lv_img_draw_core+0x222>
            read_res = lv_img_decoder_read_line(&cdsc->dec_dsc, x, y, width, buf);
 8017016:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8017018:	f9b7 4028 	ldrsh.w	r4, [r7, #40]	; 0x28
 801701c:	f9b7 2036 	ldrsh.w	r2, [r7, #54]	; 0x36
 8017020:	f9b7 1022 	ldrsh.w	r1, [r7, #34]	; 0x22
 8017024:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8017026:	9300      	str	r3, [sp, #0]
 8017028:	4623      	mov	r3, r4
 801702a:	f004 ff1b 	bl	801be64 <lv_img_decoder_read_line>
 801702e:	4603      	mov	r3, r0
 8017030:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
            if(read_res != LV_RES_OK) {
 8017034:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8017038:	2b01      	cmp	r3, #1
 801703a:	d005      	beq.n	8017048 <lv_img_draw_core+0x1c0>
                lv_img_decoder_close(&cdsc->dec_dsc);
 801703c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801703e:	4618      	mov	r0, r3
 8017040:	f004 ff3c 	bl	801bebc <lv_img_decoder_close>
                LV_LOG_WARN("Image draw can't read the line");
                return LV_RES_INV;
 8017044:	2300      	movs	r3, #0
 8017046:	e037      	b.n	80170b8 <lv_img_draw_core+0x230>
            }
            lv_draw_map(&line, mask, buf, opa, chroma_keyed, alpha_byte, style->image.color, style->image.intense);
 8017048:	683b      	ldr	r3, [r7, #0]
 801704a:	f893 3032 	ldrb.w	r3, [r3, #50]	; 0x32
 801704e:	f897 2032 	ldrb.w	r2, [r7, #50]	; 0x32
 8017052:	f107 0010 	add.w	r0, r7, #16
 8017056:	9303      	str	r3, [sp, #12]
 8017058:	683b      	ldr	r3, [r7, #0]
 801705a:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 801705c:	f8ad 3008 	strh.w	r3, [sp, #8]
 8017060:	f897 302a 	ldrb.w	r3, [r7, #42]	; 0x2a
 8017064:	9301      	str	r3, [sp, #4]
 8017066:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 801706a:	9300      	str	r3, [sp, #0]
 801706c:	4613      	mov	r3, r2
 801706e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8017070:	68b9      	ldr	r1, [r7, #8]
 8017072:	f7ff fa0f 	bl	8016494 <lv_draw_map>
            line.y1++;
 8017076:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801707a:	b29b      	uxth	r3, r3
 801707c:	3301      	adds	r3, #1
 801707e:	b29b      	uxth	r3, r3
 8017080:	b21b      	sxth	r3, r3
 8017082:	827b      	strh	r3, [r7, #18]
            line.y2++;
 8017084:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8017088:	b29b      	uxth	r3, r3
 801708a:	3301      	adds	r3, #1
 801708c:	b29b      	uxth	r3, r3
 801708e:	b21b      	sxth	r3, r3
 8017090:	82fb      	strh	r3, [r7, #22]
            y++;
 8017092:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8017096:	b29b      	uxth	r3, r3
 8017098:	3301      	adds	r3, #1
 801709a:	b29b      	uxth	r3, r3
 801709c:	86fb      	strh	r3, [r7, #54]	; 0x36
        for(row = mask_com.y1; row <= mask_com.y2; row++) {
 801709e:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 80170a2:	b29b      	uxth	r3, r3
 80170a4:	3301      	adds	r3, #1
 80170a6:	b29b      	uxth	r3, r3
 80170a8:	86bb      	strh	r3, [r7, #52]	; 0x34
 80170aa:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 80170ae:	f9b7 2034 	ldrsh.w	r2, [r7, #52]	; 0x34
 80170b2:	429a      	cmp	r2, r3
 80170b4:	ddaf      	ble.n	8017016 <lv_img_draw_core+0x18e>
        }
    }

    return LV_RES_OK;
 80170b6:	2301      	movs	r3, #1
}
 80170b8:	4618      	mov	r0, r3
 80170ba:	373c      	adds	r7, #60	; 0x3c
 80170bc:	46bd      	mov	sp, r7
 80170be:	bd90      	pop	{r4, r7, pc}
 80170c0:	240634f8 	.word	0x240634f8

080170c4 <lv_font_get_line_height>:
 * Get the line height of a font. All characters fit into this height
 * @param font_p pointer to a font
 * @return the height of a font
 */
static inline uint8_t lv_font_get_line_height(const lv_font_t * font_p)
{
 80170c4:	b480      	push	{r7}
 80170c6:	b083      	sub	sp, #12
 80170c8:	af00      	add	r7, sp, #0
 80170ca:	6078      	str	r0, [r7, #4]
    return font_p->line_height;
 80170cc:	687b      	ldr	r3, [r7, #4]
 80170ce:	7a1b      	ldrb	r3, [r3, #8]
}
 80170d0:	4618      	mov	r0, r3
 80170d2:	370c      	adds	r7, #12
 80170d4:	46bd      	mov	sp, r7
 80170d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80170da:	4770      	bx	lr

080170dc <lv_color_make>:
}
#elif LV_COLOR_DEPTH == 16
#if LV_COLOR_16_SWAP == 0
#define LV_COLOR_MAKE(r8, g8, b8) ((lv_color_t){{b8 >> 3, g8 >> 2, r8 >> 3}})
static inline lv_color_t lv_color_make(uint8_t r8, uint8_t g8, uint8_t b8)
{
 80170dc:	b480      	push	{r7}
 80170de:	b085      	sub	sp, #20
 80170e0:	af00      	add	r7, sp, #0
 80170e2:	4603      	mov	r3, r0
 80170e4:	71fb      	strb	r3, [r7, #7]
 80170e6:	460b      	mov	r3, r1
 80170e8:	71bb      	strb	r3, [r7, #6]
 80170ea:	4613      	mov	r3, r2
 80170ec:	717b      	strb	r3, [r7, #5]
    lv_color_t color;
    color.ch.blue  = (uint16_t)(b8 >> 3);
 80170ee:	797b      	ldrb	r3, [r7, #5]
 80170f0:	08db      	lsrs	r3, r3, #3
 80170f2:	b2db      	uxtb	r3, r3
 80170f4:	f003 031f 	and.w	r3, r3, #31
 80170f8:	b2da      	uxtb	r2, r3
 80170fa:	7b3b      	ldrb	r3, [r7, #12]
 80170fc:	f362 0304 	bfi	r3, r2, #0, #5
 8017100:	733b      	strb	r3, [r7, #12]
    color.ch.green = (uint16_t)(g8 >> 2);
 8017102:	79bb      	ldrb	r3, [r7, #6]
 8017104:	089b      	lsrs	r3, r3, #2
 8017106:	b2db      	uxtb	r3, r3
 8017108:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801710c:	b2da      	uxtb	r2, r3
 801710e:	89bb      	ldrh	r3, [r7, #12]
 8017110:	f362 134a 	bfi	r3, r2, #5, #6
 8017114:	81bb      	strh	r3, [r7, #12]
    color.ch.red   = (uint16_t)(r8 >> 3);
 8017116:	79fb      	ldrb	r3, [r7, #7]
 8017118:	08db      	lsrs	r3, r3, #3
 801711a:	b2db      	uxtb	r3, r3
 801711c:	f003 031f 	and.w	r3, r3, #31
 8017120:	b2da      	uxtb	r2, r3
 8017122:	7b7b      	ldrb	r3, [r7, #13]
 8017124:	f362 03c7 	bfi	r3, r2, #3, #5
 8017128:	737b      	strb	r3, [r7, #13]
    return color;
 801712a:	89bb      	ldrh	r3, [r7, #12]
}
 801712c:	4618      	mov	r0, r3
 801712e:	3714      	adds	r7, #20
 8017130:	46bd      	mov	sp, r7
 8017132:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017136:	4770      	bx	lr

08017138 <lv_area_get_width>:
{
 8017138:	b480      	push	{r7}
 801713a:	b083      	sub	sp, #12
 801713c:	af00      	add	r7, sp, #0
 801713e:	6078      	str	r0, [r7, #4]
    return area_p->x2 - area_p->x1 + 1;
 8017140:	687b      	ldr	r3, [r7, #4]
 8017142:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8017146:	b29a      	uxth	r2, r3
 8017148:	687b      	ldr	r3, [r7, #4]
 801714a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801714e:	b29b      	uxth	r3, r3
 8017150:	1ad3      	subs	r3, r2, r3
 8017152:	b29b      	uxth	r3, r3
 8017154:	3301      	adds	r3, #1
 8017156:	b29b      	uxth	r3, r3
 8017158:	b21b      	sxth	r3, r3
}
 801715a:	4618      	mov	r0, r3
 801715c:	370c      	adds	r7, #12
 801715e:	46bd      	mov	sp, r7
 8017160:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017164:	4770      	bx	lr
	...

08017168 <lv_draw_label>:
 * @param sel_end end index of selected area (`LV_LABEL_TXT_SEL_OFF` if none)
 */
void lv_draw_label(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style, lv_opa_t opa_scale,
                   const char * txt, lv_txt_flag_t flag, lv_point_t * offset, uint16_t sel_start, uint16_t sel_end,
                   lv_draw_label_hint_t * hint)
{
 8017168:	b590      	push	{r4, r7, lr}
 801716a:	b0b1      	sub	sp, #196	; 0xc4
 801716c:	af04      	add	r7, sp, #16
 801716e:	60f8      	str	r0, [r7, #12]
 8017170:	60b9      	str	r1, [r7, #8]
 8017172:	607a      	str	r2, [r7, #4]
 8017174:	70fb      	strb	r3, [r7, #3]
    const lv_font_t * font = style->text.font;
 8017176:	687b      	ldr	r3, [r7, #4]
 8017178:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801717a:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
    lv_coord_t w;
    if((flag & LV_TXT_FLAG_EXPAND) == 0) {
 801717e:	f897 30c4 	ldrb.w	r3, [r7, #196]	; 0xc4
 8017182:	f003 0302 	and.w	r3, r3, #2
 8017186:	2b00      	cmp	r3, #0
 8017188:	d106      	bne.n	8017198 <lv_draw_label+0x30>
        /*Normally use the label's width as width*/
        w = lv_area_get_width(coords);
 801718a:	68f8      	ldr	r0, [r7, #12]
 801718c:	f7ff ffd4 	bl	8017138 <lv_area_get_width>
 8017190:	4603      	mov	r3, r0
 8017192:	f8a7 30ae 	strh.w	r3, [r7, #174]	; 0xae
 8017196:	e019      	b.n	80171cc <lv_draw_label+0x64>
    } else {
        /*If EXAPND is enabled then not limit the text's width to the object's width*/
        lv_point_t p;
        lv_txt_get_size(&p, txt, style->text.font, style->text.letter_space, style->text.line_space, LV_COORD_MAX,
 8017198:	687b      	ldr	r3, [r7, #4]
 801719a:	6a59      	ldr	r1, [r3, #36]	; 0x24
 801719c:	687b      	ldr	r3, [r7, #4]
 801719e:	f9b3 4028 	ldrsh.w	r4, [r3, #40]	; 0x28
 80171a2:	687b      	ldr	r3, [r7, #4]
 80171a4:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 80171a8:	f107 0024 	add.w	r0, r7, #36	; 0x24
 80171ac:	f897 20c4 	ldrb.w	r2, [r7, #196]	; 0xc4
 80171b0:	9202      	str	r2, [sp, #8]
 80171b2:	f647 4218 	movw	r2, #31768	; 0x7c18
 80171b6:	9201      	str	r2, [sp, #4]
 80171b8:	9300      	str	r3, [sp, #0]
 80171ba:	4623      	mov	r3, r4
 80171bc:	460a      	mov	r2, r1
 80171be:	f8d7 10c0 	ldr.w	r1, [r7, #192]	; 0xc0
 80171c2:	f007 fac1 	bl	801e748 <lv_txt_get_size>
                        flag);
        w = p.x;
 80171c6:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 80171c8:	f8a7 30ae 	strh.w	r3, [r7, #174]	; 0xae
    }

    lv_coord_t line_height = lv_font_get_line_height(font) + style->text.line_space;
 80171cc:	f8d7 0094 	ldr.w	r0, [r7, #148]	; 0x94
 80171d0:	f7ff ff78 	bl	80170c4 <lv_font_get_line_height>
 80171d4:	4603      	mov	r3, r0
 80171d6:	b29a      	uxth	r2, r3
 80171d8:	687b      	ldr	r3, [r7, #4]
 80171da:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 80171de:	b29b      	uxth	r3, r3
 80171e0:	4413      	add	r3, r2
 80171e2:	b29b      	uxth	r3, r3
 80171e4:	f8a7 3092 	strh.w	r3, [r7, #146]	; 0x92

    /*Init variables for the first line*/
    lv_coord_t line_width = 0;
 80171e8:	2300      	movs	r3, #0
 80171ea:	f8a7 3090 	strh.w	r3, [r7, #144]	; 0x90
    lv_point_t pos;
    pos.x = coords->x1;
 80171ee:	68fb      	ldr	r3, [r7, #12]
 80171f0:	f9b3 3000 	ldrsh.w	r3, [r3]
 80171f4:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
    pos.y = coords->y1;
 80171f8:	68fb      	ldr	r3, [r7, #12]
 80171fa:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80171fe:	f8a7 306e 	strh.w	r3, [r7, #110]	; 0x6e

    lv_coord_t x_ofs = 0;
 8017202:	2300      	movs	r3, #0
 8017204:	f8a7 30ac 	strh.w	r3, [r7, #172]	; 0xac
    lv_coord_t y_ofs = 0;
 8017208:	2300      	movs	r3, #0
 801720a:	f8a7 30aa 	strh.w	r3, [r7, #170]	; 0xaa
    if(offset != NULL) {
 801720e:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8017212:	2b00      	cmp	r3, #0
 8017214:	d013      	beq.n	801723e <lv_draw_label+0xd6>
        x_ofs = offset->x;
 8017216:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 801721a:	881b      	ldrh	r3, [r3, #0]
 801721c:	f8a7 30ac 	strh.w	r3, [r7, #172]	; 0xac
        y_ofs = offset->y;
 8017220:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8017224:	885b      	ldrh	r3, [r3, #2]
 8017226:	f8a7 30aa 	strh.w	r3, [r7, #170]	; 0xaa
        pos.y += y_ofs;
 801722a:	f9b7 306e 	ldrsh.w	r3, [r7, #110]	; 0x6e
 801722e:	b29a      	uxth	r2, r3
 8017230:	f8b7 30aa 	ldrh.w	r3, [r7, #170]	; 0xaa
 8017234:	4413      	add	r3, r2
 8017236:	b29b      	uxth	r3, r3
 8017238:	b21b      	sxth	r3, r3
 801723a:	f8a7 306e 	strh.w	r3, [r7, #110]	; 0x6e
    }

    uint32_t line_start     = 0;
 801723e:	2300      	movs	r3, #0
 8017240:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
    int32_t last_line_start = -1;
 8017244:	f04f 33ff 	mov.w	r3, #4294967295
 8017248:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0

    /*Check the hint to use the cached info*/
    if(hint && y_ofs == 0 && coords->y1 < 0) {
 801724c:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8017250:	2b00      	cmp	r3, #0
 8017252:	d024      	beq.n	801729e <lv_draw_label+0x136>
 8017254:	f9b7 30aa 	ldrsh.w	r3, [r7, #170]	; 0xaa
 8017258:	2b00      	cmp	r3, #0
 801725a:	d120      	bne.n	801729e <lv_draw_label+0x136>
 801725c:	68fb      	ldr	r3, [r7, #12]
 801725e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8017262:	2b00      	cmp	r3, #0
 8017264:	da1b      	bge.n	801729e <lv_draw_label+0x136>
        /*If the label changed too much recalculate the hint.*/
        if(LV_MATH_ABS(hint->coord_y - coords->y1) > LV_LABEL_HINT_UPDATE_TH - 2 * line_height) {
 8017266:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 801726a:	689b      	ldr	r3, [r3, #8]
 801726c:	68fa      	ldr	r2, [r7, #12]
 801726e:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
 8017272:	1a9b      	subs	r3, r3, r2
 8017274:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 8017278:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
 801727c:	f9b7 3092 	ldrsh.w	r3, [r7, #146]	; 0x92
 8017280:	f5c3 7300 	rsb	r3, r3, #512	; 0x200
 8017284:	005b      	lsls	r3, r3, #1
 8017286:	429a      	cmp	r2, r3
 8017288:	dd04      	ble.n	8017294 <lv_draw_label+0x12c>
            hint->line_start = -1;
 801728a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 801728e:	f04f 32ff 	mov.w	r2, #4294967295
 8017292:	601a      	str	r2, [r3, #0]
        }
        last_line_start = hint->line_start;
 8017294:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8017298:	681b      	ldr	r3, [r3, #0]
 801729a:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
    }

    /*Use the hint if it's valid*/
    if(hint && last_line_start >= 0) {
 801729e:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80172a2:	2b00      	cmp	r3, #0
 80172a4:	d013      	beq.n	80172ce <lv_draw_label+0x166>
 80172a6:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 80172aa:	2b00      	cmp	r3, #0
 80172ac:	db0f      	blt.n	80172ce <lv_draw_label+0x166>
        line_start = last_line_start;
 80172ae:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 80172b2:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
        pos.y += hint->y;
 80172b6:	f9b7 306e 	ldrsh.w	r3, [r7, #110]	; 0x6e
 80172ba:	b29a      	uxth	r2, r3
 80172bc:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80172c0:	685b      	ldr	r3, [r3, #4]
 80172c2:	b29b      	uxth	r3, r3
 80172c4:	4413      	add	r3, r2
 80172c6:	b29b      	uxth	r3, r3
 80172c8:	b21b      	sxth	r3, r3
 80172ca:	f8a7 306e 	strh.w	r3, [r7, #110]	; 0x6e
    }

    uint32_t line_end = line_start + lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
 80172ce:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 80172d2:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 80172d6:	18d0      	adds	r0, r2, r3
 80172d8:	687b      	ldr	r3, [r7, #4]
 80172da:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
 80172de:	f9b7 10ae 	ldrsh.w	r1, [r7, #174]	; 0xae
 80172e2:	f897 30c4 	ldrb.w	r3, [r7, #196]	; 0xc4
 80172e6:	9300      	str	r3, [sp, #0]
 80172e8:	460b      	mov	r3, r1
 80172ea:	f8d7 1094 	ldr.w	r1, [r7, #148]	; 0x94
 80172ee:	f007 fadd 	bl	801e8ac <lv_txt_get_next_line>
 80172f2:	4603      	mov	r3, r0
 80172f4:	461a      	mov	r2, r3
 80172f6:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 80172fa:	4413      	add	r3, r2
 80172fc:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c

    /*Go the first visible line*/
    while(pos.y + line_height < mask->y1) {
 8017300:	e053      	b.n	80173aa <lv_draw_label+0x242>
        /*Go to next line*/
        line_start = line_end;
 8017302:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8017306:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
        line_end += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
 801730a:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 801730e:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8017312:	18d0      	adds	r0, r2, r3
 8017314:	687b      	ldr	r3, [r7, #4]
 8017316:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
 801731a:	f9b7 10ae 	ldrsh.w	r1, [r7, #174]	; 0xae
 801731e:	f897 30c4 	ldrb.w	r3, [r7, #196]	; 0xc4
 8017322:	9300      	str	r3, [sp, #0]
 8017324:	460b      	mov	r3, r1
 8017326:	f8d7 1094 	ldr.w	r1, [r7, #148]	; 0x94
 801732a:	f007 fabf 	bl	801e8ac <lv_txt_get_next_line>
 801732e:	4603      	mov	r3, r0
 8017330:	461a      	mov	r2, r3
 8017332:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8017336:	4413      	add	r3, r2
 8017338:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
        pos.y += line_height;
 801733c:	f9b7 306e 	ldrsh.w	r3, [r7, #110]	; 0x6e
 8017340:	b29a      	uxth	r2, r3
 8017342:	f8b7 3092 	ldrh.w	r3, [r7, #146]	; 0x92
 8017346:	4413      	add	r3, r2
 8017348:	b29b      	uxth	r3, r3
 801734a:	b21b      	sxth	r3, r3
 801734c:	f8a7 306e 	strh.w	r3, [r7, #110]	; 0x6e

        /*Save at the threshold coordinate*/
        if(hint && pos.y >= -LV_LABEL_HINT_UPDATE_TH && hint->line_start < 0) {
 8017350:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8017354:	2b00      	cmp	r3, #0
 8017356:	d01f      	beq.n	8017398 <lv_draw_label+0x230>
 8017358:	f9b7 306e 	ldrsh.w	r3, [r7, #110]	; 0x6e
 801735c:	f513 6f80 	cmn.w	r3, #1024	; 0x400
 8017360:	db1a      	blt.n	8017398 <lv_draw_label+0x230>
 8017362:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8017366:	681b      	ldr	r3, [r3, #0]
 8017368:	2b00      	cmp	r3, #0
 801736a:	da15      	bge.n	8017398 <lv_draw_label+0x230>
            hint->line_start = line_start;
 801736c:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 8017370:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8017374:	601a      	str	r2, [r3, #0]
            hint->y          = pos.y - coords->y1;
 8017376:	f9b7 306e 	ldrsh.w	r3, [r7, #110]	; 0x6e
 801737a:	461a      	mov	r2, r3
 801737c:	68fb      	ldr	r3, [r7, #12]
 801737e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8017382:	1ad2      	subs	r2, r2, r3
 8017384:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8017388:	605a      	str	r2, [r3, #4]
            hint->coord_y    = coords->y1;
 801738a:	68fb      	ldr	r3, [r7, #12]
 801738c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8017390:	461a      	mov	r2, r3
 8017392:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8017396:	609a      	str	r2, [r3, #8]
        }

        if(txt[line_start] == '\0') return;
 8017398:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 801739c:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 80173a0:	4413      	add	r3, r2
 80173a2:	781b      	ldrb	r3, [r3, #0]
 80173a4:	2b00      	cmp	r3, #0
 80173a6:	f000 827f 	beq.w	80178a8 <lv_draw_label+0x740>
    while(pos.y + line_height < mask->y1) {
 80173aa:	f9b7 306e 	ldrsh.w	r3, [r7, #110]	; 0x6e
 80173ae:	461a      	mov	r2, r3
 80173b0:	f9b7 3092 	ldrsh.w	r3, [r7, #146]	; 0x92
 80173b4:	4413      	add	r3, r2
 80173b6:	68ba      	ldr	r2, [r7, #8]
 80173b8:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
 80173bc:	4293      	cmp	r3, r2
 80173be:	dba0      	blt.n	8017302 <lv_draw_label+0x19a>
    }

    /*Align to middle*/
    if(flag & LV_TXT_FLAG_CENTER) {
 80173c0:	f897 30c4 	ldrb.w	r3, [r7, #196]	; 0xc4
 80173c4:	f003 0304 	and.w	r3, r3, #4
 80173c8:	2b00      	cmp	r3, #0
 80173ca:	d031      	beq.n	8017430 <lv_draw_label+0x2c8>
        line_width = lv_txt_get_width(&txt[line_start], line_end - line_start, font, style->text.letter_space, flag);
 80173cc:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 80173d0:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 80173d4:	18d0      	adds	r0, r2, r3
 80173d6:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 80173da:	b29a      	uxth	r2, r3
 80173dc:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 80173e0:	b29b      	uxth	r3, r3
 80173e2:	1ad3      	subs	r3, r2, r3
 80173e4:	b299      	uxth	r1, r3
 80173e6:	687b      	ldr	r3, [r7, #4]
 80173e8:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
 80173ec:	f897 30c4 	ldrb.w	r3, [r7, #196]	; 0xc4
 80173f0:	9300      	str	r3, [sp, #0]
 80173f2:	4613      	mov	r3, r2
 80173f4:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 80173f8:	f007 fb0a 	bl	801ea10 <lv_txt_get_width>
 80173fc:	4603      	mov	r3, r0
 80173fe:	f8a7 3090 	strh.w	r3, [r7, #144]	; 0x90

        pos.x += (lv_area_get_width(coords) - line_width) / 2;
 8017402:	68f8      	ldr	r0, [r7, #12]
 8017404:	f7ff fe98 	bl	8017138 <lv_area_get_width>
 8017408:	4603      	mov	r3, r0
 801740a:	461a      	mov	r2, r3
 801740c:	f9b7 3090 	ldrsh.w	r3, [r7, #144]	; 0x90
 8017410:	1ad3      	subs	r3, r2, r3
 8017412:	2b00      	cmp	r3, #0
 8017414:	da00      	bge.n	8017418 <lv_draw_label+0x2b0>
 8017416:	3301      	adds	r3, #1
 8017418:	105b      	asrs	r3, r3, #1
 801741a:	4619      	mov	r1, r3
 801741c:	f9b7 306c 	ldrsh.w	r3, [r7, #108]	; 0x6c
 8017420:	b29a      	uxth	r2, r3
 8017422:	b28b      	uxth	r3, r1
 8017424:	4413      	add	r3, r2
 8017426:	b29b      	uxth	r3, r3
 8017428:	b21b      	sxth	r3, r3
 801742a:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
 801742e:	e031      	b.n	8017494 <lv_draw_label+0x32c>

    }
    /*Align to the right*/
    else if(flag & LV_TXT_FLAG_RIGHT) {
 8017430:	f897 30c4 	ldrb.w	r3, [r7, #196]	; 0xc4
 8017434:	f003 0308 	and.w	r3, r3, #8
 8017438:	2b00      	cmp	r3, #0
 801743a:	d02b      	beq.n	8017494 <lv_draw_label+0x32c>
        line_width = lv_txt_get_width(&txt[line_start], line_end - line_start, font, style->text.letter_space, flag);
 801743c:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 8017440:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8017444:	18d0      	adds	r0, r2, r3
 8017446:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 801744a:	b29a      	uxth	r2, r3
 801744c:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8017450:	b29b      	uxth	r3, r3
 8017452:	1ad3      	subs	r3, r2, r3
 8017454:	b299      	uxth	r1, r3
 8017456:	687b      	ldr	r3, [r7, #4]
 8017458:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
 801745c:	f897 30c4 	ldrb.w	r3, [r7, #196]	; 0xc4
 8017460:	9300      	str	r3, [sp, #0]
 8017462:	4613      	mov	r3, r2
 8017464:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 8017468:	f007 fad2 	bl	801ea10 <lv_txt_get_width>
 801746c:	4603      	mov	r3, r0
 801746e:	f8a7 3090 	strh.w	r3, [r7, #144]	; 0x90
        pos.x += lv_area_get_width(coords) - line_width;
 8017472:	68f8      	ldr	r0, [r7, #12]
 8017474:	f7ff fe60 	bl	8017138 <lv_area_get_width>
 8017478:	4603      	mov	r3, r0
 801747a:	461a      	mov	r2, r3
 801747c:	f9b7 3090 	ldrsh.w	r3, [r7, #144]	; 0x90
 8017480:	1ad3      	subs	r3, r2, r3
 8017482:	f9b7 206c 	ldrsh.w	r2, [r7, #108]	; 0x6c
 8017486:	b292      	uxth	r2, r2
 8017488:	b29b      	uxth	r3, r3
 801748a:	4413      	add	r3, r2
 801748c:	b29b      	uxth	r3, r3
 801748e:	b21b      	sxth	r3, r3
 8017490:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
    }

    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->text.opa : (uint16_t)((uint16_t)style->text.opa * opa_scale) >> 8;
 8017494:	78fb      	ldrb	r3, [r7, #3]
 8017496:	2bff      	cmp	r3, #255	; 0xff
 8017498:	d103      	bne.n	80174a2 <lv_draw_label+0x33a>
 801749a:	687b      	ldr	r3, [r7, #4]
 801749c:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 80174a0:	e00b      	b.n	80174ba <lv_draw_label+0x352>
 80174a2:	687b      	ldr	r3, [r7, #4]
 80174a4:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 80174a8:	b29a      	uxth	r2, r3
 80174aa:	78fb      	ldrb	r3, [r7, #3]
 80174ac:	b29b      	uxth	r3, r3
 80174ae:	fb12 f303 	smulbb	r3, r2, r3
 80174b2:	b29b      	uxth	r3, r3
 80174b4:	0a1b      	lsrs	r3, r3, #8
 80174b6:	b29b      	uxth	r3, r3
 80174b8:	b2db      	uxtb	r3, r3
 80174ba:	f887 308f 	strb.w	r3, [r7, #143]	; 0x8f

    cmd_state_t cmd_state = CMD_STATE_WAIT;
 80174be:	2300      	movs	r3, #0
 80174c0:	f887 309b 	strb.w	r3, [r7, #155]	; 0x9b
    uint32_t i;
    uint16_t par_start = 0;
 80174c4:	2300      	movs	r3, #0
 80174c6:	f8a7 3098 	strh.w	r3, [r7, #152]	; 0x98
    lv_color_t recolor;
    lv_coord_t letter_w;
    lv_style_t sel_style;
    lv_style_copy(&sel_style, &lv_style_plain_color);
 80174ca:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80174ce:	499c      	ldr	r1, [pc, #624]	; (8017740 <lv_draw_label+0x5d8>)
 80174d0:	4618      	mov	r0, r3
 80174d2:	f7fd ff53 	bl	801537c <lv_style_copy>
    sel_style.body.main_color = sel_style.body.grad_color = style->text.sel_color;
 80174d6:	687b      	ldr	r3, [r7, #4]
 80174d8:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 80174da:	85bb      	strh	r3, [r7, #44]	; 0x2c
 80174dc:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 80174de:	857b      	strh	r3, [r7, #42]	; 0x2a

    /*Write out all lines*/
    while(txt[line_start] != '\0') {
 80174e0:	e1d8      	b.n	8017894 <lv_draw_label+0x72c>
        if(offset != NULL) {
 80174e2:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 80174e6:	2b00      	cmp	r3, #0
 80174e8:	d009      	beq.n	80174fe <lv_draw_label+0x396>
            pos.x += x_ofs;
 80174ea:	f9b7 306c 	ldrsh.w	r3, [r7, #108]	; 0x6c
 80174ee:	b29a      	uxth	r2, r3
 80174f0:	f8b7 30ac 	ldrh.w	r3, [r7, #172]	; 0xac
 80174f4:	4413      	add	r3, r2
 80174f6:	b29b      	uxth	r3, r3
 80174f8:	b21b      	sxth	r3, r3
 80174fa:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
        }
        /*Write all letter of a line*/
        cmd_state = CMD_STATE_WAIT;
 80174fe:	2300      	movs	r3, #0
 8017500:	f887 309b 	strb.w	r3, [r7, #155]	; 0x9b
        i         = line_start;
 8017504:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8017508:	66bb      	str	r3, [r7, #104]	; 0x68
        uint32_t letter;
        uint32_t letter_next;
        while(i < line_end) {
 801750a:	e120      	b.n	801774e <lv_draw_label+0x5e6>
            letter      = lv_txt_encoded_next(txt, &i);
 801750c:	4b8d      	ldr	r3, [pc, #564]	; (8017744 <lv_draw_label+0x5dc>)
 801750e:	681b      	ldr	r3, [r3, #0]
 8017510:	f107 0268 	add.w	r2, r7, #104	; 0x68
 8017514:	4611      	mov	r1, r2
 8017516:	f8d7 00c0 	ldr.w	r0, [r7, #192]	; 0xc0
 801751a:	4798      	blx	r3
 801751c:	f8c7 0088 	str.w	r0, [r7, #136]	; 0x88
            letter_next = lv_txt_encoded_next(&txt[i], NULL);
 8017520:	4b88      	ldr	r3, [pc, #544]	; (8017744 <lv_draw_label+0x5dc>)
 8017522:	681b      	ldr	r3, [r3, #0]
 8017524:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8017526:	f8d7 10c0 	ldr.w	r1, [r7, #192]	; 0xc0
 801752a:	440a      	add	r2, r1
 801752c:	2100      	movs	r1, #0
 801752e:	4610      	mov	r0, r2
 8017530:	4798      	blx	r3
 8017532:	f8c7 0084 	str.w	r0, [r7, #132]	; 0x84

            /*Handle the re-color command*/
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
 8017536:	f897 30c4 	ldrb.w	r3, [r7, #196]	; 0xc4
 801753a:	f003 0301 	and.w	r3, r3, #1
 801753e:	2b00      	cmp	r3, #0
 8017540:	d07a      	beq.n	8017638 <lv_draw_label+0x4d0>
                if(letter == (uint32_t)LV_TXT_COLOR_CMD[0]) {
 8017542:	2323      	movs	r3, #35	; 0x23
 8017544:	461a      	mov	r2, r3
 8017546:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 801754a:	4293      	cmp	r3, r2
 801754c:	d11a      	bne.n	8017584 <lv_draw_label+0x41c>
                    if(cmd_state == CMD_STATE_WAIT) { /*Start char*/
 801754e:	f897 309b 	ldrb.w	r3, [r7, #155]	; 0x9b
 8017552:	2b00      	cmp	r3, #0
 8017554:	d106      	bne.n	8017564 <lv_draw_label+0x3fc>
                        par_start = i;
 8017556:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8017558:	f8a7 3098 	strh.w	r3, [r7, #152]	; 0x98
                        cmd_state = CMD_STATE_PAR;
 801755c:	2301      	movs	r3, #1
 801755e:	f887 309b 	strb.w	r3, [r7, #155]	; 0x9b
                        continue;
 8017562:	e0f4      	b.n	801774e <lv_draw_label+0x5e6>
                    } else if(cmd_state == CMD_STATE_PAR) { /*Other start char in parameter escaped cmd. char */
 8017564:	f897 309b 	ldrb.w	r3, [r7, #155]	; 0x9b
 8017568:	2b01      	cmp	r3, #1
 801756a:	d103      	bne.n	8017574 <lv_draw_label+0x40c>
                        cmd_state = CMD_STATE_WAIT;
 801756c:	2300      	movs	r3, #0
 801756e:	f887 309b 	strb.w	r3, [r7, #155]	; 0x9b
 8017572:	e007      	b.n	8017584 <lv_draw_label+0x41c>
                    } else if(cmd_state == CMD_STATE_IN) { /*Command end */
 8017574:	f897 309b 	ldrb.w	r3, [r7, #155]	; 0x9b
 8017578:	2b02      	cmp	r3, #2
 801757a:	d103      	bne.n	8017584 <lv_draw_label+0x41c>
                        cmd_state = CMD_STATE_WAIT;
 801757c:	2300      	movs	r3, #0
 801757e:	f887 309b 	strb.w	r3, [r7, #155]	; 0x9b
                        continue;
 8017582:	e0e4      	b.n	801774e <lv_draw_label+0x5e6>
                    }
                }

                /*Skip the color parameter and wait the space after it*/
                if(cmd_state == CMD_STATE_PAR) {
 8017584:	f897 309b 	ldrb.w	r3, [r7, #155]	; 0x9b
 8017588:	2b01      	cmp	r3, #1
 801758a:	d155      	bne.n	8017638 <lv_draw_label+0x4d0>
                    if(letter == ' ') {
 801758c:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8017590:	2b20      	cmp	r3, #32
 8017592:	f040 80db 	bne.w	801774c <lv_draw_label+0x5e4>
                        /*Get the parameter*/
                        if(i - par_start == LABEL_RECOLOR_PAR_LENGTH + 1) {
 8017596:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8017598:	f8b7 3098 	ldrh.w	r3, [r7, #152]	; 0x98
 801759c:	1ad3      	subs	r3, r2, r3
 801759e:	2b07      	cmp	r3, #7
 80175a0:	d142      	bne.n	8017628 <lv_draw_label+0x4c0>
                            char buf[LABEL_RECOLOR_PAR_LENGTH + 1];
                            memcpy(buf, &txt[par_start], LABEL_RECOLOR_PAR_LENGTH);
 80175a2:	f8b7 3098 	ldrh.w	r3, [r7, #152]	; 0x98
 80175a6:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 80175aa:	18d1      	adds	r1, r2, r3
 80175ac:	f107 0318 	add.w	r3, r7, #24
 80175b0:	2206      	movs	r2, #6
 80175b2:	4618      	mov	r0, r3
 80175b4:	f00a fb50 	bl	8021c58 <memcpy>
                            buf[LABEL_RECOLOR_PAR_LENGTH] = '\0';
 80175b8:	2300      	movs	r3, #0
 80175ba:	77bb      	strb	r3, [r7, #30]
                            int r, g, b;
                            r       = (hex_char_to_num(buf[0]) << 4) + hex_char_to_num(buf[1]);
 80175bc:	7e3b      	ldrb	r3, [r7, #24]
 80175be:	4618      	mov	r0, r3
 80175c0:	f000 f978 	bl	80178b4 <hex_char_to_num>
 80175c4:	4603      	mov	r3, r0
 80175c6:	011c      	lsls	r4, r3, #4
 80175c8:	7e7b      	ldrb	r3, [r7, #25]
 80175ca:	4618      	mov	r0, r3
 80175cc:	f000 f972 	bl	80178b4 <hex_char_to_num>
 80175d0:	4603      	mov	r3, r0
 80175d2:	4423      	add	r3, r4
 80175d4:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
                            g       = (hex_char_to_num(buf[2]) << 4) + hex_char_to_num(buf[3]);
 80175d8:	7ebb      	ldrb	r3, [r7, #26]
 80175da:	4618      	mov	r0, r3
 80175dc:	f000 f96a 	bl	80178b4 <hex_char_to_num>
 80175e0:	4603      	mov	r3, r0
 80175e2:	011c      	lsls	r4, r3, #4
 80175e4:	7efb      	ldrb	r3, [r7, #27]
 80175e6:	4618      	mov	r0, r3
 80175e8:	f000 f964 	bl	80178b4 <hex_char_to_num>
 80175ec:	4603      	mov	r3, r0
 80175ee:	4423      	add	r3, r4
 80175f0:	67fb      	str	r3, [r7, #124]	; 0x7c
                            b       = (hex_char_to_num(buf[4]) << 4) + hex_char_to_num(buf[5]);
 80175f2:	7f3b      	ldrb	r3, [r7, #28]
 80175f4:	4618      	mov	r0, r3
 80175f6:	f000 f95d 	bl	80178b4 <hex_char_to_num>
 80175fa:	4603      	mov	r3, r0
 80175fc:	011c      	lsls	r4, r3, #4
 80175fe:	7f7b      	ldrb	r3, [r7, #29]
 8017600:	4618      	mov	r0, r3
 8017602:	f000 f957 	bl	80178b4 <hex_char_to_num>
 8017606:	4603      	mov	r3, r0
 8017608:	4423      	add	r3, r4
 801760a:	67bb      	str	r3, [r7, #120]	; 0x78
                            recolor = lv_color_make(r, g, b);
 801760c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8017610:	b2db      	uxtb	r3, r3
 8017612:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 8017614:	b2d1      	uxtb	r1, r2
 8017616:	6fba      	ldr	r2, [r7, #120]	; 0x78
 8017618:	b2d2      	uxtb	r2, r2
 801761a:	4618      	mov	r0, r3
 801761c:	f7ff fd5e 	bl	80170dc <lv_color_make>
 8017620:	4603      	mov	r3, r0
 8017622:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
 8017626:	e003      	b.n	8017630 <lv_draw_label+0x4c8>
                        } else {
                            recolor.full = style->text.color.full;
 8017628:	687b      	ldr	r3, [r7, #4]
 801762a:	8c1b      	ldrh	r3, [r3, #32]
 801762c:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
                        }
                        cmd_state = CMD_STATE_IN; /*After the parameter the text is in the command*/
 8017630:	2302      	movs	r3, #2
 8017632:	f887 309b 	strb.w	r3, [r7, #155]	; 0x9b
                    }
                    continue;
 8017636:	e089      	b.n	801774c <lv_draw_label+0x5e4>
                }
            }

            lv_color_t color = style->text.color;
 8017638:	687b      	ldr	r3, [r7, #4]
 801763a:	8c1b      	ldrh	r3, [r3, #32]
 801763c:	843b      	strh	r3, [r7, #32]

            if(cmd_state == CMD_STATE_IN) color = recolor;
 801763e:	f897 309b 	ldrb.w	r3, [r7, #155]	; 0x9b
 8017642:	2b02      	cmp	r3, #2
 8017644:	d102      	bne.n	801764c <lv_draw_label+0x4e4>
 8017646:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 801764a:	843b      	strh	r3, [r7, #32]

            letter_w = lv_font_get_glyph_width(font, letter, letter_next);
 801764c:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 8017650:	f8d7 1088 	ldr.w	r1, [r7, #136]	; 0x88
 8017654:	f8d7 0094 	ldr.w	r0, [r7, #148]	; 0x94
 8017658:	f005 f984 	bl	801c964 <lv_font_get_glyph_width>
 801765c:	4603      	mov	r3, r0
 801765e:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76

            if(sel_start != 0xFFFF && sel_end != 0xFFFF) {
 8017662:	f8b7 30cc 	ldrh.w	r3, [r7, #204]	; 0xcc
 8017666:	f64f 72ff 	movw	r2, #65535	; 0xffff
 801766a:	4293      	cmp	r3, r2
 801766c:	d043      	beq.n	80176f6 <lv_draw_label+0x58e>
 801766e:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
 8017672:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8017676:	4293      	cmp	r3, r2
 8017678:	d03d      	beq.n	80176f6 <lv_draw_label+0x58e>
                int char_ind = lv_encoded_get_char_id(txt, i);
 801767a:	4b33      	ldr	r3, [pc, #204]	; (8017748 <lv_draw_label+0x5e0>)
 801767c:	681b      	ldr	r3, [r3, #0]
 801767e:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8017680:	4611      	mov	r1, r2
 8017682:	f8d7 00c0 	ldr.w	r0, [r7, #192]	; 0xc0
 8017686:	4798      	blx	r3
 8017688:	4603      	mov	r3, r0
 801768a:	673b      	str	r3, [r7, #112]	; 0x70
                /*Do not draw the rectangle on the character at `sel_start`.*/
                if(char_ind > sel_start && char_ind <= sel_end) {
 801768c:	f8b7 30cc 	ldrh.w	r3, [r7, #204]	; 0xcc
 8017690:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8017692:	429a      	cmp	r2, r3
 8017694:	dd2f      	ble.n	80176f6 <lv_draw_label+0x58e>
 8017696:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
 801769a:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 801769c:	429a      	cmp	r2, r3
 801769e:	dc2a      	bgt.n	80176f6 <lv_draw_label+0x58e>
                    lv_area_t sel_coords;
                    sel_coords.x1 = pos.x;
 80176a0:	f9b7 306c 	ldrsh.w	r3, [r7, #108]	; 0x6c
 80176a4:	823b      	strh	r3, [r7, #16]
                    sel_coords.y1 = pos.y;
 80176a6:	f9b7 306e 	ldrsh.w	r3, [r7, #110]	; 0x6e
 80176aa:	827b      	strh	r3, [r7, #18]
                    sel_coords.x2 = pos.x + letter_w + style->text.letter_space - 1;
 80176ac:	f9b7 306c 	ldrsh.w	r3, [r7, #108]	; 0x6c
 80176b0:	b29a      	uxth	r2, r3
 80176b2:	f8b7 3076 	ldrh.w	r3, [r7, #118]	; 0x76
 80176b6:	4413      	add	r3, r2
 80176b8:	b29a      	uxth	r2, r3
 80176ba:	687b      	ldr	r3, [r7, #4]
 80176bc:	f9b3 3028 	ldrsh.w	r3, [r3, #40]	; 0x28
 80176c0:	b29b      	uxth	r3, r3
 80176c2:	4413      	add	r3, r2
 80176c4:	b29b      	uxth	r3, r3
 80176c6:	3b01      	subs	r3, #1
 80176c8:	b29b      	uxth	r3, r3
 80176ca:	b21b      	sxth	r3, r3
 80176cc:	82bb      	strh	r3, [r7, #20]
                    sel_coords.y2 = pos.y + line_height - 1;
 80176ce:	f9b7 306e 	ldrsh.w	r3, [r7, #110]	; 0x6e
 80176d2:	b29a      	uxth	r2, r3
 80176d4:	f8b7 3092 	ldrh.w	r3, [r7, #146]	; 0x92
 80176d8:	4413      	add	r3, r2
 80176da:	b29b      	uxth	r3, r3
 80176dc:	3b01      	subs	r3, #1
 80176de:	b29b      	uxth	r3, r3
 80176e0:	b21b      	sxth	r3, r3
 80176e2:	82fb      	strh	r3, [r7, #22]
                    lv_draw_rect(&sel_coords, mask, &sel_style, opa);
 80176e4:	f897 308f 	ldrb.w	r3, [r7, #143]	; 0x8f
 80176e8:	f107 0228 	add.w	r2, r7, #40	; 0x28
 80176ec:	f107 0010 	add.w	r0, r7, #16
 80176f0:	68b9      	ldr	r1, [r7, #8]
 80176f2:	f000 f9d2 	bl	8017a9a <lv_draw_rect>
                }
            }
            lv_draw_letter(&pos, mask, font, letter, color, opa);
 80176f6:	f107 006c 	add.w	r0, r7, #108	; 0x6c
 80176fa:	f897 308f 	ldrb.w	r3, [r7, #143]	; 0x8f
 80176fe:	9301      	str	r3, [sp, #4]
 8017700:	8c3b      	ldrh	r3, [r7, #32]
 8017702:	f8ad 3000 	strh.w	r3, [sp]
 8017706:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 801770a:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 801770e:	68b9      	ldr	r1, [r7, #8]
 8017710:	f7fe fc1c 	bl	8015f4c <lv_draw_letter>

            if(letter_w > 0) {
 8017714:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8017718:	2b00      	cmp	r3, #0
 801771a:	dd18      	ble.n	801774e <lv_draw_label+0x5e6>
                pos.x += letter_w + style->text.letter_space;
 801771c:	f9b7 306c 	ldrsh.w	r3, [r7, #108]	; 0x6c
 8017720:	b29a      	uxth	r2, r3
 8017722:	687b      	ldr	r3, [r7, #4]
 8017724:	f9b3 3028 	ldrsh.w	r3, [r3, #40]	; 0x28
 8017728:	b299      	uxth	r1, r3
 801772a:	f8b7 3076 	ldrh.w	r3, [r7, #118]	; 0x76
 801772e:	440b      	add	r3, r1
 8017730:	b29b      	uxth	r3, r3
 8017732:	4413      	add	r3, r2
 8017734:	b29b      	uxth	r3, r3
 8017736:	b21b      	sxth	r3, r3
 8017738:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
 801773c:	e007      	b.n	801774e <lv_draw_label+0x5e6>
 801773e:	bf00      	nop
 8017740:	240635e8 	.word	0x240635e8
 8017744:	240001d0 	.word	0x240001d0
 8017748:	240001dc 	.word	0x240001dc
                    continue;
 801774c:	bf00      	nop
        while(i < line_end) {
 801774e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8017750:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 8017754:	429a      	cmp	r2, r3
 8017756:	f63f aed9 	bhi.w	801750c <lv_draw_label+0x3a4>
            }
        }
        /*Go to next line*/
        line_start = line_end;
 801775a:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 801775e:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
        line_end += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
 8017762:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 8017766:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 801776a:	18d0      	adds	r0, r2, r3
 801776c:	687b      	ldr	r3, [r7, #4]
 801776e:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
 8017772:	f9b7 10ae 	ldrsh.w	r1, [r7, #174]	; 0xae
 8017776:	f897 30c4 	ldrb.w	r3, [r7, #196]	; 0xc4
 801777a:	9300      	str	r3, [sp, #0]
 801777c:	460b      	mov	r3, r1
 801777e:	f8d7 1094 	ldr.w	r1, [r7, #148]	; 0x94
 8017782:	f007 f893 	bl	801e8ac <lv_txt_get_next_line>
 8017786:	4603      	mov	r3, r0
 8017788:	461a      	mov	r2, r3
 801778a:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 801778e:	4413      	add	r3, r2
 8017790:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c

        pos.x = coords->x1;
 8017794:	68fb      	ldr	r3, [r7, #12]
 8017796:	f9b3 3000 	ldrsh.w	r3, [r3]
 801779a:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
        /*Align to middle*/
        if(flag & LV_TXT_FLAG_CENTER) {
 801779e:	f897 30c4 	ldrb.w	r3, [r7, #196]	; 0xc4
 80177a2:	f003 0304 	and.w	r3, r3, #4
 80177a6:	2b00      	cmp	r3, #0
 80177a8:	d031      	beq.n	801780e <lv_draw_label+0x6a6>
            line_width =
                lv_txt_get_width(&txt[line_start], line_end - line_start, font, style->text.letter_space, flag);
 80177aa:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 80177ae:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 80177b2:	18d0      	adds	r0, r2, r3
 80177b4:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 80177b8:	b29a      	uxth	r2, r3
 80177ba:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 80177be:	b29b      	uxth	r3, r3
 80177c0:	1ad3      	subs	r3, r2, r3
 80177c2:	b299      	uxth	r1, r3
 80177c4:	687b      	ldr	r3, [r7, #4]
 80177c6:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
 80177ca:	f897 30c4 	ldrb.w	r3, [r7, #196]	; 0xc4
 80177ce:	9300      	str	r3, [sp, #0]
 80177d0:	4613      	mov	r3, r2
 80177d2:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 80177d6:	f007 f91b 	bl	801ea10 <lv_txt_get_width>
 80177da:	4603      	mov	r3, r0
 80177dc:	f8a7 3090 	strh.w	r3, [r7, #144]	; 0x90

            pos.x += (lv_area_get_width(coords) - line_width) / 2;
 80177e0:	68f8      	ldr	r0, [r7, #12]
 80177e2:	f7ff fca9 	bl	8017138 <lv_area_get_width>
 80177e6:	4603      	mov	r3, r0
 80177e8:	461a      	mov	r2, r3
 80177ea:	f9b7 3090 	ldrsh.w	r3, [r7, #144]	; 0x90
 80177ee:	1ad3      	subs	r3, r2, r3
 80177f0:	2b00      	cmp	r3, #0
 80177f2:	da00      	bge.n	80177f6 <lv_draw_label+0x68e>
 80177f4:	3301      	adds	r3, #1
 80177f6:	105b      	asrs	r3, r3, #1
 80177f8:	4619      	mov	r1, r3
 80177fa:	f9b7 306c 	ldrsh.w	r3, [r7, #108]	; 0x6c
 80177fe:	b29a      	uxth	r2, r3
 8017800:	b28b      	uxth	r3, r1
 8017802:	4413      	add	r3, r2
 8017804:	b29b      	uxth	r3, r3
 8017806:	b21b      	sxth	r3, r3
 8017808:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
 801780c:	e031      	b.n	8017872 <lv_draw_label+0x70a>

        }
        /*Align to the right*/
        else if(flag & LV_TXT_FLAG_RIGHT) {
 801780e:	f897 30c4 	ldrb.w	r3, [r7, #196]	; 0xc4
 8017812:	f003 0308 	and.w	r3, r3, #8
 8017816:	2b00      	cmp	r3, #0
 8017818:	d02b      	beq.n	8017872 <lv_draw_label+0x70a>
            line_width =
                lv_txt_get_width(&txt[line_start], line_end - line_start, font, style->text.letter_space, flag);
 801781a:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 801781e:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8017822:	18d0      	adds	r0, r2, r3
 8017824:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8017828:	b29a      	uxth	r2, r3
 801782a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 801782e:	b29b      	uxth	r3, r3
 8017830:	1ad3      	subs	r3, r2, r3
 8017832:	b299      	uxth	r1, r3
 8017834:	687b      	ldr	r3, [r7, #4]
 8017836:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
 801783a:	f897 30c4 	ldrb.w	r3, [r7, #196]	; 0xc4
 801783e:	9300      	str	r3, [sp, #0]
 8017840:	4613      	mov	r3, r2
 8017842:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 8017846:	f007 f8e3 	bl	801ea10 <lv_txt_get_width>
 801784a:	4603      	mov	r3, r0
 801784c:	f8a7 3090 	strh.w	r3, [r7, #144]	; 0x90
            pos.x += lv_area_get_width(coords) - line_width;
 8017850:	68f8      	ldr	r0, [r7, #12]
 8017852:	f7ff fc71 	bl	8017138 <lv_area_get_width>
 8017856:	4603      	mov	r3, r0
 8017858:	461a      	mov	r2, r3
 801785a:	f9b7 3090 	ldrsh.w	r3, [r7, #144]	; 0x90
 801785e:	1ad3      	subs	r3, r2, r3
 8017860:	f9b7 206c 	ldrsh.w	r2, [r7, #108]	; 0x6c
 8017864:	b292      	uxth	r2, r2
 8017866:	b29b      	uxth	r3, r3
 8017868:	4413      	add	r3, r2
 801786a:	b29b      	uxth	r3, r3
 801786c:	b21b      	sxth	r3, r3
 801786e:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
        }

        /*Go the next line position*/
        pos.y += line_height;
 8017872:	f9b7 306e 	ldrsh.w	r3, [r7, #110]	; 0x6e
 8017876:	b29a      	uxth	r2, r3
 8017878:	f8b7 3092 	ldrh.w	r3, [r7, #146]	; 0x92
 801787c:	4413      	add	r3, r2
 801787e:	b29b      	uxth	r3, r3
 8017880:	b21b      	sxth	r3, r3
 8017882:	f8a7 306e 	strh.w	r3, [r7, #110]	; 0x6e

        if(pos.y > mask->y2) return;
 8017886:	f9b7 206e 	ldrsh.w	r2, [r7, #110]	; 0x6e
 801788a:	68bb      	ldr	r3, [r7, #8]
 801788c:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8017890:	429a      	cmp	r2, r3
 8017892:	dc0b      	bgt.n	80178ac <lv_draw_label+0x744>
    while(txt[line_start] != '\0') {
 8017894:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 8017898:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 801789c:	4413      	add	r3, r2
 801789e:	781b      	ldrb	r3, [r3, #0]
 80178a0:	2b00      	cmp	r3, #0
 80178a2:	f47f ae1e 	bne.w	80174e2 <lv_draw_label+0x37a>
 80178a6:	e002      	b.n	80178ae <lv_draw_label+0x746>
        if(txt[line_start] == '\0') return;
 80178a8:	bf00      	nop
 80178aa:	e000      	b.n	80178ae <lv_draw_label+0x746>
        if(pos.y > mask->y2) return;
 80178ac:	bf00      	nop
    }
}
 80178ae:	37b4      	adds	r7, #180	; 0xb4
 80178b0:	46bd      	mov	sp, r7
 80178b2:	bd90      	pop	{r4, r7, pc}

080178b4 <hex_char_to_num>:
 * Convert a hexadecimal characters to a number (0..15)
 * @param hex Pointer to a hexadecimal character (0..9, A..F)
 * @return the numerical value of `hex` or 0 on error
 */
static uint8_t hex_char_to_num(char hex)
{
 80178b4:	b480      	push	{r7}
 80178b6:	b085      	sub	sp, #20
 80178b8:	af00      	add	r7, sp, #0
 80178ba:	4603      	mov	r3, r0
 80178bc:	71fb      	strb	r3, [r7, #7]
    uint8_t result = 0;
 80178be:	2300      	movs	r3, #0
 80178c0:	73fb      	strb	r3, [r7, #15]

    if(hex >= '0' && hex <= '9') {
 80178c2:	79fb      	ldrb	r3, [r7, #7]
 80178c4:	2b2f      	cmp	r3, #47	; 0x2f
 80178c6:	d906      	bls.n	80178d6 <hex_char_to_num+0x22>
 80178c8:	79fb      	ldrb	r3, [r7, #7]
 80178ca:	2b39      	cmp	r3, #57	; 0x39
 80178cc:	d803      	bhi.n	80178d6 <hex_char_to_num+0x22>
        result = hex - '0';
 80178ce:	79fb      	ldrb	r3, [r7, #7]
 80178d0:	3b30      	subs	r3, #48	; 0x30
 80178d2:	73fb      	strb	r3, [r7, #15]
 80178d4:	e02d      	b.n	8017932 <hex_char_to_num+0x7e>
    } else {
        if(hex >= 'a') hex -= 'a' - 'A'; /*Convert to upper case*/
 80178d6:	79fb      	ldrb	r3, [r7, #7]
 80178d8:	2b60      	cmp	r3, #96	; 0x60
 80178da:	d902      	bls.n	80178e2 <hex_char_to_num+0x2e>
 80178dc:	79fb      	ldrb	r3, [r7, #7]
 80178de:	3b20      	subs	r3, #32
 80178e0:	71fb      	strb	r3, [r7, #7]

        switch(hex) {
 80178e2:	79fb      	ldrb	r3, [r7, #7]
 80178e4:	3b41      	subs	r3, #65	; 0x41
 80178e6:	2b05      	cmp	r3, #5
 80178e8:	d820      	bhi.n	801792c <hex_char_to_num+0x78>
 80178ea:	a201      	add	r2, pc, #4	; (adr r2, 80178f0 <hex_char_to_num+0x3c>)
 80178ec:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80178f0:	08017909 	.word	0x08017909
 80178f4:	0801790f 	.word	0x0801790f
 80178f8:	08017915 	.word	0x08017915
 80178fc:	0801791b 	.word	0x0801791b
 8017900:	08017921 	.word	0x08017921
 8017904:	08017927 	.word	0x08017927
            case 'A': result = 10; break;
 8017908:	230a      	movs	r3, #10
 801790a:	73fb      	strb	r3, [r7, #15]
 801790c:	e011      	b.n	8017932 <hex_char_to_num+0x7e>
            case 'B': result = 11; break;
 801790e:	230b      	movs	r3, #11
 8017910:	73fb      	strb	r3, [r7, #15]
 8017912:	e00e      	b.n	8017932 <hex_char_to_num+0x7e>
            case 'C': result = 12; break;
 8017914:	230c      	movs	r3, #12
 8017916:	73fb      	strb	r3, [r7, #15]
 8017918:	e00b      	b.n	8017932 <hex_char_to_num+0x7e>
            case 'D': result = 13; break;
 801791a:	230d      	movs	r3, #13
 801791c:	73fb      	strb	r3, [r7, #15]
 801791e:	e008      	b.n	8017932 <hex_char_to_num+0x7e>
            case 'E': result = 14; break;
 8017920:	230e      	movs	r3, #14
 8017922:	73fb      	strb	r3, [r7, #15]
 8017924:	e005      	b.n	8017932 <hex_char_to_num+0x7e>
            case 'F': result = 15; break;
 8017926:	230f      	movs	r3, #15
 8017928:	73fb      	strb	r3, [r7, #15]
 801792a:	e002      	b.n	8017932 <hex_char_to_num+0x7e>
            default: result = 0; break;
 801792c:	2300      	movs	r3, #0
 801792e:	73fb      	strb	r3, [r7, #15]
 8017930:	bf00      	nop
        }
    }

    return result;
 8017932:	7bfb      	ldrb	r3, [r7, #15]
}
 8017934:	4618      	mov	r0, r3
 8017936:	3714      	adds	r7, #20
 8017938:	46bd      	mov	sp, r7
 801793a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801793e:	4770      	bx	lr

08017940 <lv_color_mix>:
{
 8017940:	b480      	push	{r7}
 8017942:	b085      	sub	sp, #20
 8017944:	af00      	add	r7, sp, #0
 8017946:	80b8      	strh	r0, [r7, #4]
 8017948:	8039      	strh	r1, [r7, #0]
 801794a:	4613      	mov	r3, r2
 801794c:	70fb      	strb	r3, [r7, #3]
    ret.ch.red = (uint16_t)((uint16_t)c1.ch.red * mix + (c2.ch.red * (255 - mix))) >> 8;
 801794e:	797b      	ldrb	r3, [r7, #5]
 8017950:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8017954:	b2db      	uxtb	r3, r3
 8017956:	b29a      	uxth	r2, r3
 8017958:	78fb      	ldrb	r3, [r7, #3]
 801795a:	b29b      	uxth	r3, r3
 801795c:	fb12 f303 	smulbb	r3, r2, r3
 8017960:	b29a      	uxth	r2, r3
 8017962:	787b      	ldrb	r3, [r7, #1]
 8017964:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8017968:	b2db      	uxtb	r3, r3
 801796a:	b299      	uxth	r1, r3
 801796c:	78fb      	ldrb	r3, [r7, #3]
 801796e:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8017972:	b29b      	uxth	r3, r3
 8017974:	fb11 f303 	smulbb	r3, r1, r3
 8017978:	b29b      	uxth	r3, r3
 801797a:	4413      	add	r3, r2
 801797c:	b29b      	uxth	r3, r3
 801797e:	0a1b      	lsrs	r3, r3, #8
 8017980:	b29b      	uxth	r3, r3
 8017982:	f003 031f 	and.w	r3, r3, #31
 8017986:	b2da      	uxtb	r2, r3
 8017988:	7b7b      	ldrb	r3, [r7, #13]
 801798a:	f362 03c7 	bfi	r3, r2, #3, #5
 801798e:	737b      	strb	r3, [r7, #13]
    ret.ch.green = (uint16_t)((uint16_t)c1.ch.green * mix + (c2.ch.green * (255 - mix))) >> 8;
 8017990:	88bb      	ldrh	r3, [r7, #4]
 8017992:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8017996:	b2db      	uxtb	r3, r3
 8017998:	b29a      	uxth	r2, r3
 801799a:	78fb      	ldrb	r3, [r7, #3]
 801799c:	b29b      	uxth	r3, r3
 801799e:	fb12 f303 	smulbb	r3, r2, r3
 80179a2:	b29a      	uxth	r2, r3
 80179a4:	883b      	ldrh	r3, [r7, #0]
 80179a6:	f3c3 1345 	ubfx	r3, r3, #5, #6
 80179aa:	b2db      	uxtb	r3, r3
 80179ac:	b299      	uxth	r1, r3
 80179ae:	78fb      	ldrb	r3, [r7, #3]
 80179b0:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 80179b4:	b29b      	uxth	r3, r3
 80179b6:	fb11 f303 	smulbb	r3, r1, r3
 80179ba:	b29b      	uxth	r3, r3
 80179bc:	4413      	add	r3, r2
 80179be:	b29b      	uxth	r3, r3
 80179c0:	0a1b      	lsrs	r3, r3, #8
 80179c2:	b29b      	uxth	r3, r3
 80179c4:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80179c8:	b2da      	uxtb	r2, r3
 80179ca:	89bb      	ldrh	r3, [r7, #12]
 80179cc:	f362 134a 	bfi	r3, r2, #5, #6
 80179d0:	81bb      	strh	r3, [r7, #12]
    ret.ch.blue = (uint16_t)((uint16_t)c1.ch.blue * mix + (c2.ch.blue * (255 - mix))) >> 8;
 80179d2:	793b      	ldrb	r3, [r7, #4]
 80179d4:	f3c3 0304 	ubfx	r3, r3, #0, #5
 80179d8:	b2db      	uxtb	r3, r3
 80179da:	b29a      	uxth	r2, r3
 80179dc:	78fb      	ldrb	r3, [r7, #3]
 80179de:	b29b      	uxth	r3, r3
 80179e0:	fb12 f303 	smulbb	r3, r2, r3
 80179e4:	b29a      	uxth	r2, r3
 80179e6:	783b      	ldrb	r3, [r7, #0]
 80179e8:	f3c3 0304 	ubfx	r3, r3, #0, #5
 80179ec:	b2db      	uxtb	r3, r3
 80179ee:	b299      	uxth	r1, r3
 80179f0:	78fb      	ldrb	r3, [r7, #3]
 80179f2:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 80179f6:	b29b      	uxth	r3, r3
 80179f8:	fb11 f303 	smulbb	r3, r1, r3
 80179fc:	b29b      	uxth	r3, r3
 80179fe:	4413      	add	r3, r2
 8017a00:	b29b      	uxth	r3, r3
 8017a02:	0a1b      	lsrs	r3, r3, #8
 8017a04:	b29b      	uxth	r3, r3
 8017a06:	f003 031f 	and.w	r3, r3, #31
 8017a0a:	b2da      	uxtb	r2, r3
 8017a0c:	7b3b      	ldrb	r3, [r7, #12]
 8017a0e:	f362 0304 	bfi	r3, r2, #0, #5
 8017a12:	733b      	strb	r3, [r7, #12]
    return ret;
 8017a14:	89bb      	ldrh	r3, [r7, #12]
}
 8017a16:	4618      	mov	r0, r3
 8017a18:	3714      	adds	r7, #20
 8017a1a:	46bd      	mov	sp, r7
 8017a1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017a20:	4770      	bx	lr

08017a22 <lv_area_copy>:
{
 8017a22:	b580      	push	{r7, lr}
 8017a24:	b082      	sub	sp, #8
 8017a26:	af00      	add	r7, sp, #0
 8017a28:	6078      	str	r0, [r7, #4]
 8017a2a:	6039      	str	r1, [r7, #0]
    memcpy(dest, src, sizeof(lv_area_t));
 8017a2c:	2208      	movs	r2, #8
 8017a2e:	6839      	ldr	r1, [r7, #0]
 8017a30:	6878      	ldr	r0, [r7, #4]
 8017a32:	f00a f911 	bl	8021c58 <memcpy>
}
 8017a36:	bf00      	nop
 8017a38:	3708      	adds	r7, #8
 8017a3a:	46bd      	mov	sp, r7
 8017a3c:	bd80      	pop	{r7, pc}

08017a3e <lv_area_get_width>:
{
 8017a3e:	b480      	push	{r7}
 8017a40:	b083      	sub	sp, #12
 8017a42:	af00      	add	r7, sp, #0
 8017a44:	6078      	str	r0, [r7, #4]
    return area_p->x2 - area_p->x1 + 1;
 8017a46:	687b      	ldr	r3, [r7, #4]
 8017a48:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8017a4c:	b29a      	uxth	r2, r3
 8017a4e:	687b      	ldr	r3, [r7, #4]
 8017a50:	f9b3 3000 	ldrsh.w	r3, [r3]
 8017a54:	b29b      	uxth	r3, r3
 8017a56:	1ad3      	subs	r3, r2, r3
 8017a58:	b29b      	uxth	r3, r3
 8017a5a:	3301      	adds	r3, #1
 8017a5c:	b29b      	uxth	r3, r3
 8017a5e:	b21b      	sxth	r3, r3
}
 8017a60:	4618      	mov	r0, r3
 8017a62:	370c      	adds	r7, #12
 8017a64:	46bd      	mov	sp, r7
 8017a66:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017a6a:	4770      	bx	lr

08017a6c <lv_area_get_height>:
 * Get the height of an area
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
 8017a6c:	b480      	push	{r7}
 8017a6e:	b083      	sub	sp, #12
 8017a70:	af00      	add	r7, sp, #0
 8017a72:	6078      	str	r0, [r7, #4]
    return area_p->y2 - area_p->y1 + 1;
 8017a74:	687b      	ldr	r3, [r7, #4]
 8017a76:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8017a7a:	b29a      	uxth	r2, r3
 8017a7c:	687b      	ldr	r3, [r7, #4]
 8017a7e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8017a82:	b29b      	uxth	r3, r3
 8017a84:	1ad3      	subs	r3, r2, r3
 8017a86:	b29b      	uxth	r3, r3
 8017a88:	3301      	adds	r3, #1
 8017a8a:	b29b      	uxth	r3, r3
 8017a8c:	b21b      	sxth	r3, r3
}
 8017a8e:	4618      	mov	r0, r3
 8017a90:	370c      	adds	r7, #12
 8017a92:	46bd      	mov	sp, r7
 8017a94:	f85d 7b04 	ldr.w	r7, [sp], #4
 8017a98:	4770      	bx	lr

08017a9a <lv_draw_rect>:
 * @param mask the rectangle will be drawn only in this mask
 * @param style pointer to a style
 * @param opa_scale scale down all opacities by the factor
 */
void lv_draw_rect(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style, lv_opa_t opa_scale)
{
 8017a9a:	b580      	push	{r7, lr}
 8017a9c:	b084      	sub	sp, #16
 8017a9e:	af00      	add	r7, sp, #0
 8017aa0:	60f8      	str	r0, [r7, #12]
 8017aa2:	60b9      	str	r1, [r7, #8]
 8017aa4:	607a      	str	r2, [r7, #4]
 8017aa6:	70fb      	strb	r3, [r7, #3]
    if(lv_area_get_height(coords) < 1 || lv_area_get_width(coords) < 1) return;
 8017aa8:	68f8      	ldr	r0, [r7, #12]
 8017aaa:	f7ff ffdf 	bl	8017a6c <lv_area_get_height>
 8017aae:	4603      	mov	r3, r0
 8017ab0:	2b00      	cmp	r3, #0
 8017ab2:	dd4e      	ble.n	8017b52 <lv_draw_rect+0xb8>
 8017ab4:	68f8      	ldr	r0, [r7, #12]
 8017ab6:	f7ff ffc2 	bl	8017a3e <lv_area_get_width>
 8017aba:	4603      	mov	r3, r0
 8017abc:	2b00      	cmp	r3, #0
 8017abe:	dd48      	ble.n	8017b52 <lv_draw_rect+0xb8>

#if LV_USE_SHADOW
    if(style->body.shadow.width != 0) {
 8017ac0:	687b      	ldr	r3, [r7, #4]
 8017ac2:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8017ac6:	2b00      	cmp	r3, #0
 8017ac8:	d005      	beq.n	8017ad6 <lv_draw_rect+0x3c>
        lv_draw_shadow(coords, mask, style, opa_scale);
 8017aca:	78fb      	ldrb	r3, [r7, #3]
 8017acc:	687a      	ldr	r2, [r7, #4]
 8017ace:	68b9      	ldr	r1, [r7, #8]
 8017ad0:	68f8      	ldr	r0, [r7, #12]
 8017ad2:	f002 ff64 	bl	801a99e <lv_draw_shadow>
    }
#endif

    /* If the object is out of the mask there is nothing to draw.
     * Draw shadow before it because the shadow is out of `coords`*/
    if(lv_area_is_on(coords, mask) == false) return;
 8017ad6:	68b9      	ldr	r1, [r7, #8]
 8017ad8:	68f8      	ldr	r0, [r7, #12]
 8017ada:	f005 ff2a 	bl	801d932 <lv_area_is_on>
 8017ade:	4603      	mov	r3, r0
 8017ae0:	f083 0301 	eor.w	r3, r3, #1
 8017ae4:	b2db      	uxtb	r3, r3
 8017ae6:	2b00      	cmp	r3, #0
 8017ae8:	d135      	bne.n	8017b56 <lv_draw_rect+0xbc>

    if(style->body.opa > LV_OPA_MIN) {
 8017aea:	687b      	ldr	r3, [r7, #4]
 8017aec:	7a1b      	ldrb	r3, [r3, #8]
 8017aee:	2b10      	cmp	r3, #16
 8017af0:	d910      	bls.n	8017b14 <lv_draw_rect+0x7a>
        lv_draw_rect_main_mid(coords, mask, style, opa_scale);
 8017af2:	78fb      	ldrb	r3, [r7, #3]
 8017af4:	687a      	ldr	r2, [r7, #4]
 8017af6:	68b9      	ldr	r1, [r7, #8]
 8017af8:	68f8      	ldr	r0, [r7, #12]
 8017afa:	f000 f830 	bl	8017b5e <lv_draw_rect_main_mid>

        if(style->body.radius != 0) {
 8017afe:	687b      	ldr	r3, [r7, #4]
 8017b00:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8017b04:	2b00      	cmp	r3, #0
 8017b06:	d005      	beq.n	8017b14 <lv_draw_rect+0x7a>
            lv_draw_rect_main_corner(coords, mask, style, opa_scale);
 8017b08:	78fb      	ldrb	r3, [r7, #3]
 8017b0a:	687a      	ldr	r2, [r7, #4]
 8017b0c:	68b9      	ldr	r1, [r7, #8]
 8017b0e:	68f8      	ldr	r0, [r7, #12]
 8017b10:	f000 f928 	bl	8017d64 <lv_draw_rect_main_corner>
        }
    }

    if(style->body.border.width != 0 && style->body.border.part != LV_BORDER_NONE &&
 8017b14:	687b      	ldr	r3, [r7, #4]
 8017b16:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8017b1a:	2b00      	cmp	r3, #0
 8017b1c:	d01c      	beq.n	8017b58 <lv_draw_rect+0xbe>
 8017b1e:	687b      	ldr	r3, [r7, #4]
 8017b20:	7b9b      	ldrb	r3, [r3, #14]
 8017b22:	2b00      	cmp	r3, #0
 8017b24:	d018      	beq.n	8017b58 <lv_draw_rect+0xbe>
       style->body.border.opa >= LV_OPA_MIN) {
 8017b26:	687b      	ldr	r3, [r7, #4]
 8017b28:	7bdb      	ldrb	r3, [r3, #15]
    if(style->body.border.width != 0 && style->body.border.part != LV_BORDER_NONE &&
 8017b2a:	2b0f      	cmp	r3, #15
 8017b2c:	d914      	bls.n	8017b58 <lv_draw_rect+0xbe>
        lv_draw_rect_border_straight(coords, mask, style, opa_scale);
 8017b2e:	78fb      	ldrb	r3, [r7, #3]
 8017b30:	687a      	ldr	r2, [r7, #4]
 8017b32:	68b9      	ldr	r1, [r7, #8]
 8017b34:	68f8      	ldr	r0, [r7, #12]
 8017b36:	f001 f93e 	bl	8018db6 <lv_draw_rect_border_straight>

        if(style->body.radius != 0) {
 8017b3a:	687b      	ldr	r3, [r7, #4]
 8017b3c:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8017b40:	2b00      	cmp	r3, #0
 8017b42:	d009      	beq.n	8017b58 <lv_draw_rect+0xbe>
            lv_draw_rect_border_corner(coords, mask, style, opa_scale);
 8017b44:	78fb      	ldrb	r3, [r7, #3]
 8017b46:	687a      	ldr	r2, [r7, #4]
 8017b48:	68b9      	ldr	r1, [r7, #8]
 8017b4a:	68f8      	ldr	r0, [r7, #12]
 8017b4c:	f001 fce0 	bl	8019510 <lv_draw_rect_border_corner>
 8017b50:	e002      	b.n	8017b58 <lv_draw_rect+0xbe>
    if(lv_area_get_height(coords) < 1 || lv_area_get_width(coords) < 1) return;
 8017b52:	bf00      	nop
 8017b54:	e000      	b.n	8017b58 <lv_draw_rect+0xbe>
    if(lv_area_is_on(coords, mask) == false) return;
 8017b56:	bf00      	nop
        }
    }
}
 8017b58:	3710      	adds	r7, #16
 8017b5a:	46bd      	mov	sp, r7
 8017b5c:	bd80      	pop	{r7, pc}

08017b5e <lv_draw_rect_main_mid>:
 * @param rects_p pointer to a rectangle style
 * @param opa_scale scale down all opacities by the factor
 */
static void lv_draw_rect_main_mid(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style,
                                  lv_opa_t opa_scale)
{
 8017b5e:	b580      	push	{r7, lr}
 8017b60:	b08e      	sub	sp, #56	; 0x38
 8017b62:	af00      	add	r7, sp, #0
 8017b64:	60f8      	str	r0, [r7, #12]
 8017b66:	60b9      	str	r1, [r7, #8]
 8017b68:	607a      	str	r2, [r7, #4]
 8017b6a:	70fb      	strb	r3, [r7, #3]
    uint16_t radius = style->body.radius;
 8017b6c:	687b      	ldr	r3, [r7, #4]
 8017b6e:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8017b72:	863b      	strh	r3, [r7, #48]	; 0x30
    bool aa         = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
 8017b74:	f7fc fc8e 	bl	8014494 <lv_refr_get_disp_refreshing>
 8017b78:	4603      	mov	r3, r0
 8017b7a:	4618      	mov	r0, r3
 8017b7c:	f005 fb0d 	bl	801d19a <lv_disp_get_antialiasing>
 8017b80:	4603      	mov	r3, r0
 8017b82:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

    lv_color_t mcolor = style->body.main_color;
 8017b86:	687b      	ldr	r3, [r7, #4]
 8017b88:	885b      	ldrh	r3, [r3, #2]
 8017b8a:	84bb      	strh	r3, [r7, #36]	; 0x24
    lv_color_t gcolor = style->body.grad_color;
 8017b8c:	687b      	ldr	r3, [r7, #4]
 8017b8e:	889b      	ldrh	r3, [r3, #4]
 8017b90:	843b      	strh	r3, [r7, #32]
    uint8_t mix;
    lv_coord_t height = lv_area_get_height(coords);
 8017b92:	68f8      	ldr	r0, [r7, #12]
 8017b94:	f7ff ff6a 	bl	8017a6c <lv_area_get_height>
 8017b98:	4603      	mov	r3, r0
 8017b9a:	85bb      	strh	r3, [r7, #44]	; 0x2c
    lv_coord_t width  = lv_area_get_width(coords);
 8017b9c:	68f8      	ldr	r0, [r7, #12]
 8017b9e:	f7ff ff4e 	bl	8017a3e <lv_area_get_width>
 8017ba2:	4603      	mov	r3, r0
 8017ba4:	857b      	strh	r3, [r7, #42]	; 0x2a
    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->body.opa : (uint16_t)((uint16_t)style->body.opa * opa_scale) >> 8;
 8017ba6:	78fb      	ldrb	r3, [r7, #3]
 8017ba8:	2bff      	cmp	r3, #255	; 0xff
 8017baa:	d102      	bne.n	8017bb2 <lv_draw_rect_main_mid+0x54>
 8017bac:	687b      	ldr	r3, [r7, #4]
 8017bae:	7a1b      	ldrb	r3, [r3, #8]
 8017bb0:	e00a      	b.n	8017bc8 <lv_draw_rect_main_mid+0x6a>
 8017bb2:	687b      	ldr	r3, [r7, #4]
 8017bb4:	7a1b      	ldrb	r3, [r3, #8]
 8017bb6:	b29a      	uxth	r2, r3
 8017bb8:	78fb      	ldrb	r3, [r7, #3]
 8017bba:	b29b      	uxth	r3, r3
 8017bbc:	fb12 f303 	smulbb	r3, r2, r3
 8017bc0:	b29b      	uxth	r3, r3
 8017bc2:	0a1b      	lsrs	r3, r3, #8
 8017bc4:	b29b      	uxth	r3, r3
 8017bc6:	b2db      	uxtb	r3, r3
 8017bc8:	f887 3029 	strb.w	r3, [r7, #41]	; 0x29

    radius = lv_draw_cont_radius_corr(radius, width, height);
 8017bcc:	f9b7 202c 	ldrsh.w	r2, [r7, #44]	; 0x2c
 8017bd0:	f9b7 102a 	ldrsh.w	r1, [r7, #42]	; 0x2a
 8017bd4:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 8017bd6:	4618      	mov	r0, r3
 8017bd8:	f003 fddc 	bl	801b794 <lv_draw_cont_radius_corr>
 8017bdc:	4603      	mov	r3, r0
 8017bde:	863b      	strh	r3, [r7, #48]	; 0x30

    /*If the radius is too big then there is no body*/
    if(radius > height / 2) return;
 8017be0:	8e3a      	ldrh	r2, [r7, #48]	; 0x30
 8017be2:	f9b7 302c 	ldrsh.w	r3, [r7, #44]	; 0x2c
 8017be6:	2b00      	cmp	r3, #0
 8017be8:	da00      	bge.n	8017bec <lv_draw_rect_main_mid+0x8e>
 8017bea:	3301      	adds	r3, #1
 8017bec:	105b      	asrs	r3, r3, #1
 8017bee:	b21b      	sxth	r3, r3
 8017bf0:	429a      	cmp	r2, r3
 8017bf2:	f300 80b3 	bgt.w	8017d5c <lv_draw_rect_main_mid+0x1fe>

    lv_area_t work_area;
    work_area.x1 = coords->x1;
 8017bf6:	68fb      	ldr	r3, [r7, #12]
 8017bf8:	f9b3 3000 	ldrsh.w	r3, [r3]
 8017bfc:	833b      	strh	r3, [r7, #24]
    work_area.x2 = coords->x2;
 8017bfe:	68fb      	ldr	r3, [r7, #12]
 8017c00:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8017c04:	83bb      	strh	r3, [r7, #28]

    if(mcolor.full == gcolor.full) {
 8017c06:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 8017c08:	8c3b      	ldrh	r3, [r7, #32]
 8017c0a:	429a      	cmp	r2, r3
 8017c0c:	d140      	bne.n	8017c90 <lv_draw_rect_main_mid+0x132>
        work_area.y1 = coords->y1 + radius;
 8017c0e:	68fb      	ldr	r3, [r7, #12]
 8017c10:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8017c14:	b29a      	uxth	r2, r3
 8017c16:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 8017c18:	4413      	add	r3, r2
 8017c1a:	b29b      	uxth	r3, r3
 8017c1c:	b21b      	sxth	r3, r3
 8017c1e:	837b      	strh	r3, [r7, #26]
        work_area.y2 = coords->y2 - radius;
 8017c20:	68fb      	ldr	r3, [r7, #12]
 8017c22:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8017c26:	b29a      	uxth	r2, r3
 8017c28:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 8017c2a:	1ad3      	subs	r3, r2, r3
 8017c2c:	b29b      	uxth	r3, r3
 8017c2e:	b21b      	sxth	r3, r3
 8017c30:	83fb      	strh	r3, [r7, #30]

        if(style->body.radius != 0) {
 8017c32:	687b      	ldr	r3, [r7, #4]
 8017c34:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8017c38:	2b00      	cmp	r3, #0
 8017c3a:	d020      	beq.n	8017c7e <lv_draw_rect_main_mid+0x120>

            if(aa) {
 8017c3c:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8017c40:	2b00      	cmp	r3, #0
 8017c42:	d00e      	beq.n	8017c62 <lv_draw_rect_main_mid+0x104>
                work_area.y1 += 2;
 8017c44:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8017c48:	b29b      	uxth	r3, r3
 8017c4a:	3302      	adds	r3, #2
 8017c4c:	b29b      	uxth	r3, r3
 8017c4e:	b21b      	sxth	r3, r3
 8017c50:	837b      	strh	r3, [r7, #26]
                work_area.y2 -= 2;
 8017c52:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8017c56:	b29b      	uxth	r3, r3
 8017c58:	3b02      	subs	r3, #2
 8017c5a:	b29b      	uxth	r3, r3
 8017c5c:	b21b      	sxth	r3, r3
 8017c5e:	83fb      	strh	r3, [r7, #30]
 8017c60:	e00d      	b.n	8017c7e <lv_draw_rect_main_mid+0x120>
            } else {
                work_area.y1 += 1;
 8017c62:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8017c66:	b29b      	uxth	r3, r3
 8017c68:	3301      	adds	r3, #1
 8017c6a:	b29b      	uxth	r3, r3
 8017c6c:	b21b      	sxth	r3, r3
 8017c6e:	837b      	strh	r3, [r7, #26]
                work_area.y2 -= 1;
 8017c70:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8017c74:	b29b      	uxth	r3, r3
 8017c76:	3b01      	subs	r3, #1
 8017c78:	b29b      	uxth	r3, r3
 8017c7a:	b21b      	sxth	r3, r3
 8017c7c:	83fb      	strh	r3, [r7, #30]
            }
        }

        lv_draw_fill(&work_area, mask, mcolor, opa);
 8017c7e:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8017c82:	f107 0018 	add.w	r0, r7, #24
 8017c86:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 8017c88:	68b9      	ldr	r1, [r7, #8]
 8017c8a:	f7fe f8e5 	bl	8015e58 <lv_draw_fill>
 8017c8e:	e066      	b.n	8017d5e <lv_draw_rect_main_mid+0x200>
    } else {
        lv_coord_t row;
        lv_coord_t row_start = coords->y1 + radius;
 8017c90:	68fb      	ldr	r3, [r7, #12]
 8017c92:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8017c96:	b29a      	uxth	r2, r3
 8017c98:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 8017c9a:	4413      	add	r3, r2
 8017c9c:	b29b      	uxth	r3, r3
 8017c9e:	86bb      	strh	r3, [r7, #52]	; 0x34
        lv_coord_t row_end   = coords->y2 - radius;
 8017ca0:	68fb      	ldr	r3, [r7, #12]
 8017ca2:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8017ca6:	b29a      	uxth	r2, r3
 8017ca8:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 8017caa:	1ad3      	subs	r3, r2, r3
 8017cac:	b29b      	uxth	r3, r3
 8017cae:	867b      	strh	r3, [r7, #50]	; 0x32
        lv_color_t act_color;

        if(style->body.radius != 0) {
 8017cb0:	687b      	ldr	r3, [r7, #4]
 8017cb2:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8017cb6:	2b00      	cmp	r3, #0
 8017cb8:	d014      	beq.n	8017ce4 <lv_draw_rect_main_mid+0x186>
            if(aa) {
 8017cba:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8017cbe:	2b00      	cmp	r3, #0
 8017cc0:	d008      	beq.n	8017cd4 <lv_draw_rect_main_mid+0x176>
                row_start += 2;
 8017cc2:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 8017cc4:	3302      	adds	r3, #2
 8017cc6:	b29b      	uxth	r3, r3
 8017cc8:	86bb      	strh	r3, [r7, #52]	; 0x34
                row_end -= 2;
 8017cca:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 8017ccc:	3b02      	subs	r3, #2
 8017cce:	b29b      	uxth	r3, r3
 8017cd0:	867b      	strh	r3, [r7, #50]	; 0x32
 8017cd2:	e007      	b.n	8017ce4 <lv_draw_rect_main_mid+0x186>
            } else {
                row_start += 1;
 8017cd4:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 8017cd6:	3301      	adds	r3, #1
 8017cd8:	b29b      	uxth	r3, r3
 8017cda:	86bb      	strh	r3, [r7, #52]	; 0x34
                row_end -= 1;
 8017cdc:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 8017cde:	3b01      	subs	r3, #1
 8017ce0:	b29b      	uxth	r3, r3
 8017ce2:	867b      	strh	r3, [r7, #50]	; 0x32
            }
        }
        if(row_start < 0) row_start = 0;
 8017ce4:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8017ce8:	2b00      	cmp	r3, #0
 8017cea:	da01      	bge.n	8017cf0 <lv_draw_rect_main_mid+0x192>
 8017cec:	2300      	movs	r3, #0
 8017cee:	86bb      	strh	r3, [r7, #52]	; 0x34

        for(row = row_start; row <= row_end; row++) {
 8017cf0:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 8017cf2:	86fb      	strh	r3, [r7, #54]	; 0x36
 8017cf4:	e02b      	b.n	8017d4e <lv_draw_rect_main_mid+0x1f0>
            work_area.y1 = row;
 8017cf6:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8017cf8:	837b      	strh	r3, [r7, #26]
            work_area.y2 = row;
 8017cfa:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8017cfc:	83fb      	strh	r3, [r7, #30]
            mix          = (uint32_t)((uint32_t)(coords->y2 - work_area.y1) * 255) / height;
 8017cfe:	68fb      	ldr	r3, [r7, #12]
 8017d00:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8017d04:	461a      	mov	r2, r3
 8017d06:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8017d0a:	1ad3      	subs	r3, r2, r3
 8017d0c:	461a      	mov	r2, r3
 8017d0e:	4613      	mov	r3, r2
 8017d10:	021b      	lsls	r3, r3, #8
 8017d12:	1a9a      	subs	r2, r3, r2
 8017d14:	f9b7 302c 	ldrsh.w	r3, [r7, #44]	; 0x2c
 8017d18:	fbb2 f3f3 	udiv	r3, r2, r3
 8017d1c:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
            act_color    = lv_color_mix(mcolor, gcolor, mix);
 8017d20:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 8017d24:	461a      	mov	r2, r3
 8017d26:	8c39      	ldrh	r1, [r7, #32]
 8017d28:	8cb8      	ldrh	r0, [r7, #36]	; 0x24
 8017d2a:	f7ff fe09 	bl	8017940 <lv_color_mix>
 8017d2e:	4603      	mov	r3, r0
 8017d30:	82bb      	strh	r3, [r7, #20]

            lv_draw_fill(&work_area, mask, act_color, opa);
 8017d32:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8017d36:	f107 0018 	add.w	r0, r7, #24
 8017d3a:	8aba      	ldrh	r2, [r7, #20]
 8017d3c:	68b9      	ldr	r1, [r7, #8]
 8017d3e:	f7fe f88b 	bl	8015e58 <lv_draw_fill>
        for(row = row_start; row <= row_end; row++) {
 8017d42:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8017d46:	b29b      	uxth	r3, r3
 8017d48:	3301      	adds	r3, #1
 8017d4a:	b29b      	uxth	r3, r3
 8017d4c:	86fb      	strh	r3, [r7, #54]	; 0x36
 8017d4e:	f9b7 2036 	ldrsh.w	r2, [r7, #54]	; 0x36
 8017d52:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8017d56:	429a      	cmp	r2, r3
 8017d58:	ddcd      	ble.n	8017cf6 <lv_draw_rect_main_mid+0x198>
 8017d5a:	e000      	b.n	8017d5e <lv_draw_rect_main_mid+0x200>
    if(radius > height / 2) return;
 8017d5c:	bf00      	nop
        }
    }
}
 8017d5e:	3738      	adds	r7, #56	; 0x38
 8017d60:	46bd      	mov	sp, r7
 8017d62:	bd80      	pop	{r7, pc}

08017d64 <lv_draw_rect_main_corner>:
 * @param rects_p pointer to a rectangle style
 * @param opa_scale scale down all opacities by the factor
 */
static void lv_draw_rect_main_corner(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style,
                                     lv_opa_t opa_scale)
{
 8017d64:	b5b0      	push	{r4, r5, r7, lr}
 8017d66:	b0a4      	sub	sp, #144	; 0x90
 8017d68:	af02      	add	r7, sp, #8
 8017d6a:	60f8      	str	r0, [r7, #12]
 8017d6c:	60b9      	str	r1, [r7, #8]
 8017d6e:	607a      	str	r2, [r7, #4]
 8017d70:	70fb      	strb	r3, [r7, #3]
    uint16_t radius = style->body.radius;
 8017d72:	687b      	ldr	r3, [r7, #4]
 8017d74:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8017d78:	f8a7 3078 	strh.w	r3, [r7, #120]	; 0x78
    bool aa         = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
 8017d7c:	f7fc fb8a 	bl	8014494 <lv_refr_get_disp_refreshing>
 8017d80:	4603      	mov	r3, r0
 8017d82:	4618      	mov	r0, r3
 8017d84:	f005 fa09 	bl	801d19a <lv_disp_get_antialiasing>
 8017d88:	4603      	mov	r3, r0
 8017d8a:	f887 3077 	strb.w	r3, [r7, #119]	; 0x77

    lv_color_t mcolor = style->body.main_color;
 8017d8e:	687b      	ldr	r3, [r7, #4]
 8017d90:	885b      	ldrh	r3, [r3, #2]
 8017d92:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
    lv_color_t gcolor = style->body.grad_color;
 8017d96:	687b      	ldr	r3, [r7, #4]
 8017d98:	889b      	ldrh	r3, [r3, #4]
 8017d9a:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60
    lv_color_t act_color;
    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->body.opa : (uint16_t)((uint16_t)style->body.opa * opa_scale) >> 8;
 8017d9e:	78fb      	ldrb	r3, [r7, #3]
 8017da0:	2bff      	cmp	r3, #255	; 0xff
 8017da2:	d102      	bne.n	8017daa <lv_draw_rect_main_corner+0x46>
 8017da4:	687b      	ldr	r3, [r7, #4]
 8017da6:	7a1b      	ldrb	r3, [r3, #8]
 8017da8:	e00a      	b.n	8017dc0 <lv_draw_rect_main_corner+0x5c>
 8017daa:	687b      	ldr	r3, [r7, #4]
 8017dac:	7a1b      	ldrb	r3, [r3, #8]
 8017dae:	b29a      	uxth	r2, r3
 8017db0:	78fb      	ldrb	r3, [r7, #3]
 8017db2:	b29b      	uxth	r3, r3
 8017db4:	fb12 f303 	smulbb	r3, r2, r3
 8017db8:	b29b      	uxth	r3, r3
 8017dba:	0a1b      	lsrs	r3, r3, #8
 8017dbc:	b29b      	uxth	r3, r3
 8017dbe:	b2db      	uxtb	r3, r3
 8017dc0:	f887 3076 	strb.w	r3, [r7, #118]	; 0x76
    uint8_t mix;
    lv_coord_t height = lv_area_get_height(coords);
 8017dc4:	68f8      	ldr	r0, [r7, #12]
 8017dc6:	f7ff fe51 	bl	8017a6c <lv_area_get_height>
 8017dca:	4603      	mov	r3, r0
 8017dcc:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74
    lv_coord_t width  = lv_area_get_width(coords);
 8017dd0:	68f8      	ldr	r0, [r7, #12]
 8017dd2:	f7ff fe34 	bl	8017a3e <lv_area_get_width>
 8017dd6:	4603      	mov	r3, r0
 8017dd8:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72

    radius = lv_draw_cont_radius_corr(radius, width, height);
 8017ddc:	f9b7 2074 	ldrsh.w	r2, [r7, #116]	; 0x74
 8017de0:	f9b7 1072 	ldrsh.w	r1, [r7, #114]	; 0x72
 8017de4:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 8017de8:	4618      	mov	r0, r3
 8017dea:	f003 fcd3 	bl	801b794 <lv_draw_cont_radius_corr>
 8017dee:	4603      	mov	r3, r0
 8017df0:	f8a7 3078 	strh.w	r3, [r7, #120]	; 0x78
    lv_point_t lt_origo; /*Left  Top    origo*/
    lv_point_t lb_origo; /*Left  Bottom origo*/
    lv_point_t rt_origo; /*Right Top    origo*/
    lv_point_t rb_origo; /*Left  Bottom origo*/

    lt_origo.x = coords->x1 + radius + aa;
 8017df4:	68fb      	ldr	r3, [r7, #12]
 8017df6:	f9b3 3000 	ldrsh.w	r3, [r3]
 8017dfa:	b29a      	uxth	r2, r3
 8017dfc:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 8017e00:	4413      	add	r3, r2
 8017e02:	b29a      	uxth	r2, r3
 8017e04:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 8017e08:	b29b      	uxth	r3, r3
 8017e0a:	4413      	add	r3, r2
 8017e0c:	b29b      	uxth	r3, r3
 8017e0e:	b21b      	sxth	r3, r3
 8017e10:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58
    lt_origo.y = coords->y1 + radius + aa;
 8017e14:	68fb      	ldr	r3, [r7, #12]
 8017e16:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8017e1a:	b29a      	uxth	r2, r3
 8017e1c:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 8017e20:	4413      	add	r3, r2
 8017e22:	b29a      	uxth	r2, r3
 8017e24:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 8017e28:	b29b      	uxth	r3, r3
 8017e2a:	4413      	add	r3, r2
 8017e2c:	b29b      	uxth	r3, r3
 8017e2e:	b21b      	sxth	r3, r3
 8017e30:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a

    lb_origo.x = coords->x1 + radius + aa;
 8017e34:	68fb      	ldr	r3, [r7, #12]
 8017e36:	f9b3 3000 	ldrsh.w	r3, [r3]
 8017e3a:	b29a      	uxth	r2, r3
 8017e3c:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 8017e40:	4413      	add	r3, r2
 8017e42:	b29a      	uxth	r2, r3
 8017e44:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 8017e48:	b29b      	uxth	r3, r3
 8017e4a:	4413      	add	r3, r2
 8017e4c:	b29b      	uxth	r3, r3
 8017e4e:	b21b      	sxth	r3, r3
 8017e50:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
    lb_origo.y = coords->y2 - radius - aa;
 8017e54:	68fb      	ldr	r3, [r7, #12]
 8017e56:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8017e5a:	b29a      	uxth	r2, r3
 8017e5c:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 8017e60:	1ad3      	subs	r3, r2, r3
 8017e62:	b29a      	uxth	r2, r3
 8017e64:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 8017e68:	b29b      	uxth	r3, r3
 8017e6a:	1ad3      	subs	r3, r2, r3
 8017e6c:	b29b      	uxth	r3, r3
 8017e6e:	b21b      	sxth	r3, r3
 8017e70:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56

    rt_origo.x = coords->x2 - radius - aa;
 8017e74:	68fb      	ldr	r3, [r7, #12]
 8017e76:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8017e7a:	b29a      	uxth	r2, r3
 8017e7c:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 8017e80:	1ad3      	subs	r3, r2, r3
 8017e82:	b29a      	uxth	r2, r3
 8017e84:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 8017e88:	b29b      	uxth	r3, r3
 8017e8a:	1ad3      	subs	r3, r2, r3
 8017e8c:	b29b      	uxth	r3, r3
 8017e8e:	b21b      	sxth	r3, r3
 8017e90:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
    rt_origo.y = coords->y1 + radius + aa;
 8017e94:	68fb      	ldr	r3, [r7, #12]
 8017e96:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8017e9a:	b29a      	uxth	r2, r3
 8017e9c:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 8017ea0:	4413      	add	r3, r2
 8017ea2:	b29a      	uxth	r2, r3
 8017ea4:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 8017ea8:	b29b      	uxth	r3, r3
 8017eaa:	4413      	add	r3, r2
 8017eac:	b29b      	uxth	r3, r3
 8017eae:	b21b      	sxth	r3, r3
 8017eb0:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52

    rb_origo.x = coords->x2 - radius - aa;
 8017eb4:	68fb      	ldr	r3, [r7, #12]
 8017eb6:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8017eba:	b29a      	uxth	r2, r3
 8017ebc:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 8017ec0:	1ad3      	subs	r3, r2, r3
 8017ec2:	b29a      	uxth	r2, r3
 8017ec4:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 8017ec8:	b29b      	uxth	r3, r3
 8017eca:	1ad3      	subs	r3, r2, r3
 8017ecc:	b29b      	uxth	r3, r3
 8017ece:	b21b      	sxth	r3, r3
 8017ed0:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c
    rb_origo.y = coords->y2 - radius - aa;
 8017ed4:	68fb      	ldr	r3, [r7, #12]
 8017ed6:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8017eda:	b29a      	uxth	r2, r3
 8017edc:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 8017ee0:	1ad3      	subs	r3, r2, r3
 8017ee2:	b29a      	uxth	r2, r3
 8017ee4:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 8017ee8:	b29b      	uxth	r3, r3
 8017eea:	1ad3      	subs	r3, r2, r3
 8017eec:	b29b      	uxth	r3, r3
 8017eee:	b21b      	sxth	r3, r3
 8017ef0:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
    lv_area_t mid_bot_area;
    lv_area_t edge_bot_area;

    lv_point_t cir;
    lv_coord_t cir_tmp;
    lv_circ_init(&cir, &cir_tmp, radius);
 8017ef4:	f9b7 2078 	ldrsh.w	r2, [r7, #120]	; 0x78
 8017ef8:	f107 0126 	add.w	r1, r7, #38	; 0x26
 8017efc:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8017f00:	4618      	mov	r0, r3
 8017f02:	f005 fd74 	bl	801d9ee <lv_circ_init>

    /*Init the areas*/
    lv_area_set(&mid_bot_area, lb_origo.x + LV_CIRC_OCT4_X(cir), lb_origo.y + LV_CIRC_OCT4_Y(cir),
 8017f06:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 8017f0a:	b29a      	uxth	r2, r3
 8017f0c:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8017f10:	b29b      	uxth	r3, r3
 8017f12:	1ad3      	subs	r3, r2, r3
 8017f14:	b29b      	uxth	r3, r3
 8017f16:	b219      	sxth	r1, r3
 8017f18:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 8017f1c:	b29a      	uxth	r2, r3
 8017f1e:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8017f22:	b29b      	uxth	r3, r3
 8017f24:	4413      	add	r3, r2
 8017f26:	b29b      	uxth	r3, r3
 8017f28:	b21c      	sxth	r4, r3
                rb_origo.x + LV_CIRC_OCT1_X(cir), rb_origo.y + LV_CIRC_OCT1_Y(cir));
 8017f2a:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 8017f2e:	b29a      	uxth	r2, r3
 8017f30:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8017f34:	b29b      	uxth	r3, r3
 8017f36:	4413      	add	r3, r2
 8017f38:	b29b      	uxth	r3, r3
    lv_area_set(&mid_bot_area, lb_origo.x + LV_CIRC_OCT4_X(cir), lb_origo.y + LV_CIRC_OCT4_Y(cir),
 8017f3a:	b21d      	sxth	r5, r3
                rb_origo.x + LV_CIRC_OCT1_X(cir), rb_origo.y + LV_CIRC_OCT1_Y(cir));
 8017f3c:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 8017f40:	b29a      	uxth	r2, r3
 8017f42:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8017f46:	b29b      	uxth	r3, r3
 8017f48:	4413      	add	r3, r2
 8017f4a:	b29b      	uxth	r3, r3
    lv_area_set(&mid_bot_area, lb_origo.x + LV_CIRC_OCT4_X(cir), lb_origo.y + LV_CIRC_OCT4_Y(cir),
 8017f4c:	b21b      	sxth	r3, r3
 8017f4e:	f107 0034 	add.w	r0, r7, #52	; 0x34
 8017f52:	9300      	str	r3, [sp, #0]
 8017f54:	462b      	mov	r3, r5
 8017f56:	4622      	mov	r2, r4
 8017f58:	f005 fc06 	bl	801d768 <lv_area_set>

    lv_area_set(&edge_bot_area, lb_origo.x + LV_CIRC_OCT3_X(cir), lb_origo.y + LV_CIRC_OCT3_Y(cir),
 8017f5c:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 8017f60:	b29a      	uxth	r2, r3
 8017f62:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8017f66:	b29b      	uxth	r3, r3
 8017f68:	1ad3      	subs	r3, r2, r3
 8017f6a:	b29b      	uxth	r3, r3
 8017f6c:	b219      	sxth	r1, r3
 8017f6e:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 8017f72:	b29a      	uxth	r2, r3
 8017f74:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8017f78:	b29b      	uxth	r3, r3
 8017f7a:	4413      	add	r3, r2
 8017f7c:	b29b      	uxth	r3, r3
 8017f7e:	b21c      	sxth	r4, r3
                rb_origo.x + LV_CIRC_OCT2_X(cir), rb_origo.y + LV_CIRC_OCT2_Y(cir));
 8017f80:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 8017f84:	b29a      	uxth	r2, r3
 8017f86:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8017f8a:	b29b      	uxth	r3, r3
 8017f8c:	4413      	add	r3, r2
 8017f8e:	b29b      	uxth	r3, r3
    lv_area_set(&edge_bot_area, lb_origo.x + LV_CIRC_OCT3_X(cir), lb_origo.y + LV_CIRC_OCT3_Y(cir),
 8017f90:	b21d      	sxth	r5, r3
                rb_origo.x + LV_CIRC_OCT2_X(cir), rb_origo.y + LV_CIRC_OCT2_Y(cir));
 8017f92:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 8017f96:	b29a      	uxth	r2, r3
 8017f98:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8017f9c:	b29b      	uxth	r3, r3
 8017f9e:	4413      	add	r3, r2
 8017fa0:	b29b      	uxth	r3, r3
    lv_area_set(&edge_bot_area, lb_origo.x + LV_CIRC_OCT3_X(cir), lb_origo.y + LV_CIRC_OCT3_Y(cir),
 8017fa2:	b21b      	sxth	r3, r3
 8017fa4:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 8017fa8:	9300      	str	r3, [sp, #0]
 8017faa:	462b      	mov	r3, r5
 8017fac:	4622      	mov	r2, r4
 8017fae:	f005 fbdb 	bl	801d768 <lv_area_set>

    lv_area_set(&mid_top_area, lt_origo.x + LV_CIRC_OCT5_X(cir), lt_origo.y + LV_CIRC_OCT5_Y(cir),
 8017fb2:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 8017fb6:	b29a      	uxth	r2, r3
 8017fb8:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8017fbc:	b29b      	uxth	r3, r3
 8017fbe:	1ad3      	subs	r3, r2, r3
 8017fc0:	b29b      	uxth	r3, r3
 8017fc2:	b219      	sxth	r1, r3
 8017fc4:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8017fc8:	b29a      	uxth	r2, r3
 8017fca:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8017fce:	b29b      	uxth	r3, r3
 8017fd0:	1ad3      	subs	r3, r2, r3
 8017fd2:	b29b      	uxth	r3, r3
 8017fd4:	b21c      	sxth	r4, r3
                rt_origo.x + LV_CIRC_OCT8_X(cir), rt_origo.y + LV_CIRC_OCT8_Y(cir));
 8017fd6:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 8017fda:	b29a      	uxth	r2, r3
 8017fdc:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8017fe0:	b29b      	uxth	r3, r3
 8017fe2:	4413      	add	r3, r2
 8017fe4:	b29b      	uxth	r3, r3
    lv_area_set(&mid_top_area, lt_origo.x + LV_CIRC_OCT5_X(cir), lt_origo.y + LV_CIRC_OCT5_Y(cir),
 8017fe6:	b21d      	sxth	r5, r3
                rt_origo.x + LV_CIRC_OCT8_X(cir), rt_origo.y + LV_CIRC_OCT8_Y(cir));
 8017fe8:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 8017fec:	b29a      	uxth	r2, r3
 8017fee:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8017ff2:	b29b      	uxth	r3, r3
 8017ff4:	1ad3      	subs	r3, r2, r3
 8017ff6:	b29b      	uxth	r3, r3
    lv_area_set(&mid_top_area, lt_origo.x + LV_CIRC_OCT5_X(cir), lt_origo.y + LV_CIRC_OCT5_Y(cir),
 8017ff8:	b21b      	sxth	r3, r3
 8017ffa:	f107 003c 	add.w	r0, r7, #60	; 0x3c
 8017ffe:	9300      	str	r3, [sp, #0]
 8018000:	462b      	mov	r3, r5
 8018002:	4622      	mov	r2, r4
 8018004:	f005 fbb0 	bl	801d768 <lv_area_set>

    lv_area_set(&edge_top_area, lt_origo.x + LV_CIRC_OCT6_X(cir), lt_origo.y + LV_CIRC_OCT6_Y(cir),
 8018008:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 801800c:	b29a      	uxth	r2, r3
 801800e:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8018012:	b29b      	uxth	r3, r3
 8018014:	1ad3      	subs	r3, r2, r3
 8018016:	b29b      	uxth	r3, r3
 8018018:	b219      	sxth	r1, r3
 801801a:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 801801e:	b29a      	uxth	r2, r3
 8018020:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8018024:	b29b      	uxth	r3, r3
 8018026:	1ad3      	subs	r3, r2, r3
 8018028:	b29b      	uxth	r3, r3
 801802a:	b21c      	sxth	r4, r3
                rt_origo.x + LV_CIRC_OCT7_X(cir), rt_origo.y + LV_CIRC_OCT7_Y(cir));
 801802c:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 8018030:	b29a      	uxth	r2, r3
 8018032:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8018036:	b29b      	uxth	r3, r3
 8018038:	4413      	add	r3, r2
 801803a:	b29b      	uxth	r3, r3
    lv_area_set(&edge_top_area, lt_origo.x + LV_CIRC_OCT6_X(cir), lt_origo.y + LV_CIRC_OCT6_Y(cir),
 801803c:	b21d      	sxth	r5, r3
                rt_origo.x + LV_CIRC_OCT7_X(cir), rt_origo.y + LV_CIRC_OCT7_Y(cir));
 801803e:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 8018042:	b29a      	uxth	r2, r3
 8018044:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8018048:	b29b      	uxth	r3, r3
 801804a:	1ad3      	subs	r3, r2, r3
 801804c:	b29b      	uxth	r3, r3
    lv_area_set(&edge_top_area, lt_origo.x + LV_CIRC_OCT6_X(cir), lt_origo.y + LV_CIRC_OCT6_Y(cir),
 801804e:	b21b      	sxth	r3, r3
 8018050:	f107 0044 	add.w	r0, r7, #68	; 0x44
 8018054:	9300      	str	r3, [sp, #0]
 8018056:	462b      	mov	r3, r5
 8018058:	4622      	mov	r2, r4
 801805a:	f005 fb85 	bl	801d768 <lv_area_set>
#if LV_ANTIALIAS
    /*Store some internal states for anti-aliasing*/
    lv_coord_t out_y_seg_start = 0;
 801805e:	2300      	movs	r3, #0
 8018060:	f8a7 3086 	strh.w	r3, [r7, #134]	; 0x86
    lv_coord_t out_y_seg_end   = 0;
 8018064:	2300      	movs	r3, #0
 8018066:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
    lv_coord_t out_x_last      = radius;
 801806a:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 801806e:	f8a7 3084 	strh.w	r3, [r7, #132]	; 0x84
    lv_color_t aa_color_hor_top;
    lv_color_t aa_color_hor_bottom;
    lv_color_t aa_color_ver;
#endif

    while(lv_circ_cont(&cir)) {
 8018072:	e367      	b.n	8018744 <lv_draw_rect_main_corner+0x9e0>
#if LV_ANTIALIAS
        if(aa) {
 8018074:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 8018078:	2b00      	cmp	r3, #0
 801807a:	f000 8197 	beq.w	80183ac <lv_draw_rect_main_corner+0x648>
            /*New step in y on the outter circle*/
            if(out_x_last != cir.x) {
 801807e:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8018082:	f9b7 2084 	ldrsh.w	r2, [r7, #132]	; 0x84
 8018086:	429a      	cmp	r2, r3
 8018088:	f000 8190 	beq.w	80183ac <lv_draw_rect_main_corner+0x648>
                out_y_seg_end       = cir.y;
 801808c:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 801808e:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
                lv_coord_t seg_size = out_y_seg_end - out_y_seg_start;
 8018092:	f8b7 2070 	ldrh.w	r2, [r7, #112]	; 0x70
 8018096:	f8b7 3086 	ldrh.w	r3, [r7, #134]	; 0x86
 801809a:	1ad3      	subs	r3, r2, r3
 801809c:	b29b      	uxth	r3, r3
 801809e:	f8a7 3068 	strh.w	r3, [r7, #104]	; 0x68
                lv_point_t aa_p;

                aa_p.x = out_x_last;
 80180a2:	f8b7 3084 	ldrh.w	r3, [r7, #132]	; 0x84
 80180a6:	833b      	strh	r3, [r7, #24]
                aa_p.y = out_y_seg_start;
 80180a8:	f8b7 3086 	ldrh.w	r3, [r7, #134]	; 0x86
 80180ac:	837b      	strh	r3, [r7, #26]

                mix                 = (uint32_t)((uint32_t)(radius - out_x_last) * 255) / height;
 80180ae:	f8b7 2078 	ldrh.w	r2, [r7, #120]	; 0x78
 80180b2:	f9b7 3084 	ldrsh.w	r3, [r7, #132]	; 0x84
 80180b6:	1ad3      	subs	r3, r2, r3
 80180b8:	461a      	mov	r2, r3
 80180ba:	4613      	mov	r3, r2
 80180bc:	021b      	lsls	r3, r3, #8
 80180be:	1a9a      	subs	r2, r3, r2
 80180c0:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 80180c4:	fbb2 f3f3 	udiv	r3, r2, r3
 80180c8:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
                aa_color_hor_top    = lv_color_mix(gcolor, mcolor, mix);
 80180cc:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 80180d0:	461a      	mov	r2, r3
 80180d2:	f8b7 1064 	ldrh.w	r1, [r7, #100]	; 0x64
 80180d6:	f8b7 0060 	ldrh.w	r0, [r7, #96]	; 0x60
 80180da:	f7ff fc31 	bl	8017940 <lv_color_mix>
 80180de:	4603      	mov	r3, r0
 80180e0:	84bb      	strh	r3, [r7, #36]	; 0x24
                aa_color_hor_bottom = lv_color_mix(mcolor, gcolor, mix);
 80180e2:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 80180e6:	461a      	mov	r2, r3
 80180e8:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 80180ec:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 80180f0:	f7ff fc26 	bl	8017940 <lv_color_mix>
 80180f4:	4603      	mov	r3, r0
 80180f6:	843b      	strh	r3, [r7, #32]

                lv_coord_t i;
                for(i = 0; i < seg_size; i++) {
 80180f8:	2300      	movs	r3, #0
 80180fa:	f8a7 3082 	strh.w	r3, [r7, #130]	; 0x82
 80180fe:	e147      	b.n	8018390 <lv_draw_rect_main_corner+0x62c>
                    lv_opa_t aa_opa;
                    if(seg_size > CIRCLE_AA_NON_LINEAR_OPA_THRESHOLD) { /*Use non-linear opa mapping
 8018100:	f9b7 3068 	ldrsh.w	r3, [r7, #104]	; 0x68
 8018104:	2b01      	cmp	r3, #1
 8018106:	dd0c      	ble.n	8018122 <lv_draw_rect_main_corner+0x3be>
                                                                           on the first segment*/
                        aa_opa = antialias_get_opa_circ(seg_size, i, opa);
 8018108:	f897 2076 	ldrb.w	r2, [r7, #118]	; 0x76
 801810c:	f9b7 1082 	ldrsh.w	r1, [r7, #130]	; 0x82
 8018110:	f9b7 3068 	ldrsh.w	r3, [r7, #104]	; 0x68
 8018114:	4618      	mov	r0, r3
 8018116:	f003 fb7f 	bl	801b818 <antialias_get_opa_circ>
 801811a:	4603      	mov	r3, r0
 801811c:	f887 3081 	strb.w	r3, [r7, #129]	; 0x81
 8018120:	e00f      	b.n	8018142 <lv_draw_rect_main_corner+0x3de>
                    } else {
                        aa_opa = opa - lv_draw_aa_get_opa(seg_size, i, opa);
 8018122:	f897 2076 	ldrb.w	r2, [r7, #118]	; 0x76
 8018126:	f9b7 1082 	ldrsh.w	r1, [r7, #130]	; 0x82
 801812a:	f9b7 3068 	ldrsh.w	r3, [r7, #104]	; 0x68
 801812e:	4618      	mov	r0, r3
 8018130:	f7fd f984 	bl	801543c <lv_draw_aa_get_opa>
 8018134:	4603      	mov	r3, r0
 8018136:	461a      	mov	r2, r3
 8018138:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 801813c:	1a9b      	subs	r3, r3, r2
 801813e:	f887 3081 	strb.w	r3, [r7, #129]	; 0x81
                    }

                    lv_draw_px(rb_origo.x + LV_CIRC_OCT2_X(aa_p) + i, rb_origo.y + LV_CIRC_OCT2_Y(aa_p) + 1, mask,
 8018142:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 8018146:	b29a      	uxth	r2, r3
 8018148:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 801814c:	b29b      	uxth	r3, r3
 801814e:	4413      	add	r3, r2
 8018150:	b29a      	uxth	r2, r3
 8018152:	f8b7 3082 	ldrh.w	r3, [r7, #130]	; 0x82
 8018156:	4413      	add	r3, r2
 8018158:	b29b      	uxth	r3, r3
 801815a:	b218      	sxth	r0, r3
 801815c:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 8018160:	b29a      	uxth	r2, r3
 8018162:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8018166:	b29b      	uxth	r3, r3
 8018168:	4413      	add	r3, r2
 801816a:	b29b      	uxth	r3, r3
 801816c:	3301      	adds	r3, #1
 801816e:	b29b      	uxth	r3, r3
 8018170:	b219      	sxth	r1, r3
 8018172:	f897 3081 	ldrb.w	r3, [r7, #129]	; 0x81
 8018176:	9300      	str	r3, [sp, #0]
 8018178:	8c3b      	ldrh	r3, [r7, #32]
 801817a:	68ba      	ldr	r2, [r7, #8]
 801817c:	f7fd fdd4 	bl	8015d28 <lv_draw_px>
                               aa_color_hor_bottom, aa_opa);
                    lv_draw_px(lb_origo.x + LV_CIRC_OCT3_X(aa_p) - i, lb_origo.y + LV_CIRC_OCT3_Y(aa_p) + 1, mask,
 8018180:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 8018184:	b29a      	uxth	r2, r3
 8018186:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 801818a:	b29b      	uxth	r3, r3
 801818c:	1ad3      	subs	r3, r2, r3
 801818e:	b29a      	uxth	r2, r3
 8018190:	f8b7 3082 	ldrh.w	r3, [r7, #130]	; 0x82
 8018194:	1ad3      	subs	r3, r2, r3
 8018196:	b29b      	uxth	r3, r3
 8018198:	b218      	sxth	r0, r3
 801819a:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 801819e:	b29a      	uxth	r2, r3
 80181a0:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 80181a4:	b29b      	uxth	r3, r3
 80181a6:	4413      	add	r3, r2
 80181a8:	b29b      	uxth	r3, r3
 80181aa:	3301      	adds	r3, #1
 80181ac:	b29b      	uxth	r3, r3
 80181ae:	b219      	sxth	r1, r3
 80181b0:	f897 3081 	ldrb.w	r3, [r7, #129]	; 0x81
 80181b4:	9300      	str	r3, [sp, #0]
 80181b6:	8c3b      	ldrh	r3, [r7, #32]
 80181b8:	68ba      	ldr	r2, [r7, #8]
 80181ba:	f7fd fdb5 	bl	8015d28 <lv_draw_px>
                               aa_color_hor_bottom, aa_opa);
                    lv_draw_px(lt_origo.x + LV_CIRC_OCT6_X(aa_p) - i, lt_origo.y + LV_CIRC_OCT6_Y(aa_p) - 1, mask,
 80181be:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 80181c2:	b29a      	uxth	r2, r3
 80181c4:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80181c8:	b29b      	uxth	r3, r3
 80181ca:	1ad3      	subs	r3, r2, r3
 80181cc:	b29a      	uxth	r2, r3
 80181ce:	f8b7 3082 	ldrh.w	r3, [r7, #130]	; 0x82
 80181d2:	1ad3      	subs	r3, r2, r3
 80181d4:	b29b      	uxth	r3, r3
 80181d6:	b218      	sxth	r0, r3
 80181d8:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 80181dc:	b29a      	uxth	r2, r3
 80181de:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 80181e2:	b29b      	uxth	r3, r3
 80181e4:	1ad3      	subs	r3, r2, r3
 80181e6:	b29b      	uxth	r3, r3
 80181e8:	3b01      	subs	r3, #1
 80181ea:	b29b      	uxth	r3, r3
 80181ec:	b219      	sxth	r1, r3
 80181ee:	f897 3081 	ldrb.w	r3, [r7, #129]	; 0x81
 80181f2:	9300      	str	r3, [sp, #0]
 80181f4:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 80181f6:	68ba      	ldr	r2, [r7, #8]
 80181f8:	f7fd fd96 	bl	8015d28 <lv_draw_px>
                               aa_color_hor_top, aa_opa);
                    lv_draw_px(rt_origo.x + LV_CIRC_OCT7_X(aa_p) + i, rt_origo.y + LV_CIRC_OCT7_Y(aa_p) - 1, mask,
 80181fc:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 8018200:	b29a      	uxth	r2, r3
 8018202:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8018206:	b29b      	uxth	r3, r3
 8018208:	4413      	add	r3, r2
 801820a:	b29a      	uxth	r2, r3
 801820c:	f8b7 3082 	ldrh.w	r3, [r7, #130]	; 0x82
 8018210:	4413      	add	r3, r2
 8018212:	b29b      	uxth	r3, r3
 8018214:	b218      	sxth	r0, r3
 8018216:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 801821a:	b29a      	uxth	r2, r3
 801821c:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8018220:	b29b      	uxth	r3, r3
 8018222:	1ad3      	subs	r3, r2, r3
 8018224:	b29b      	uxth	r3, r3
 8018226:	3b01      	subs	r3, #1
 8018228:	b29b      	uxth	r3, r3
 801822a:	b219      	sxth	r1, r3
 801822c:	f897 3081 	ldrb.w	r3, [r7, #129]	; 0x81
 8018230:	9300      	str	r3, [sp, #0]
 8018232:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8018234:	68ba      	ldr	r2, [r7, #8]
 8018236:	f7fd fd77 	bl	8015d28 <lv_draw_px>
                               aa_color_hor_top, aa_opa);

                    mix          = (uint32_t)((uint32_t)(radius - out_y_seg_start + i) * 255) / height;
 801823a:	f8b7 2078 	ldrh.w	r2, [r7, #120]	; 0x78
 801823e:	f9b7 3086 	ldrsh.w	r3, [r7, #134]	; 0x86
 8018242:	1ad2      	subs	r2, r2, r3
 8018244:	f9b7 3082 	ldrsh.w	r3, [r7, #130]	; 0x82
 8018248:	4413      	add	r3, r2
 801824a:	461a      	mov	r2, r3
 801824c:	4613      	mov	r3, r2
 801824e:	021b      	lsls	r3, r3, #8
 8018250:	1a9a      	subs	r2, r3, r2
 8018252:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 8018256:	fbb2 f3f3 	udiv	r3, r2, r3
 801825a:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
                    aa_color_ver = lv_color_mix(mcolor, gcolor, mix);
 801825e:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8018262:	461a      	mov	r2, r3
 8018264:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 8018268:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 801826c:	f7ff fb68 	bl	8017940 <lv_color_mix>
 8018270:	4603      	mov	r3, r0
 8018272:	83bb      	strh	r3, [r7, #28]
                    lv_draw_px(rb_origo.x + LV_CIRC_OCT1_X(aa_p) + 1, rb_origo.y + LV_CIRC_OCT1_Y(aa_p) + i, mask,
 8018274:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 8018278:	b29a      	uxth	r2, r3
 801827a:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 801827e:	b29b      	uxth	r3, r3
 8018280:	4413      	add	r3, r2
 8018282:	b29b      	uxth	r3, r3
 8018284:	3301      	adds	r3, #1
 8018286:	b29b      	uxth	r3, r3
 8018288:	b218      	sxth	r0, r3
 801828a:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 801828e:	b29a      	uxth	r2, r3
 8018290:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8018294:	b29b      	uxth	r3, r3
 8018296:	4413      	add	r3, r2
 8018298:	b29a      	uxth	r2, r3
 801829a:	f8b7 3082 	ldrh.w	r3, [r7, #130]	; 0x82
 801829e:	4413      	add	r3, r2
 80182a0:	b29b      	uxth	r3, r3
 80182a2:	b219      	sxth	r1, r3
 80182a4:	f897 3081 	ldrb.w	r3, [r7, #129]	; 0x81
 80182a8:	9300      	str	r3, [sp, #0]
 80182aa:	8bbb      	ldrh	r3, [r7, #28]
 80182ac:	68ba      	ldr	r2, [r7, #8]
 80182ae:	f7fd fd3b 	bl	8015d28 <lv_draw_px>
                               aa_color_ver, aa_opa);
                    lv_draw_px(lb_origo.x + LV_CIRC_OCT4_X(aa_p) - 1, lb_origo.y + LV_CIRC_OCT4_Y(aa_p) + i, mask,
 80182b2:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 80182b6:	b29a      	uxth	r2, r3
 80182b8:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 80182bc:	b29b      	uxth	r3, r3
 80182be:	1ad3      	subs	r3, r2, r3
 80182c0:	b29b      	uxth	r3, r3
 80182c2:	3b01      	subs	r3, #1
 80182c4:	b29b      	uxth	r3, r3
 80182c6:	b218      	sxth	r0, r3
 80182c8:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 80182cc:	b29a      	uxth	r2, r3
 80182ce:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80182d2:	b29b      	uxth	r3, r3
 80182d4:	4413      	add	r3, r2
 80182d6:	b29a      	uxth	r2, r3
 80182d8:	f8b7 3082 	ldrh.w	r3, [r7, #130]	; 0x82
 80182dc:	4413      	add	r3, r2
 80182de:	b29b      	uxth	r3, r3
 80182e0:	b219      	sxth	r1, r3
 80182e2:	f897 3081 	ldrb.w	r3, [r7, #129]	; 0x81
 80182e6:	9300      	str	r3, [sp, #0]
 80182e8:	8bbb      	ldrh	r3, [r7, #28]
 80182ea:	68ba      	ldr	r2, [r7, #8]
 80182ec:	f7fd fd1c 	bl	8015d28 <lv_draw_px>
                               aa_color_ver, aa_opa);

                    aa_color_ver = lv_color_mix(gcolor, mcolor, mix);
 80182f0:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 80182f4:	461a      	mov	r2, r3
 80182f6:	f8b7 1064 	ldrh.w	r1, [r7, #100]	; 0x64
 80182fa:	f8b7 0060 	ldrh.w	r0, [r7, #96]	; 0x60
 80182fe:	f7ff fb1f 	bl	8017940 <lv_color_mix>
 8018302:	4603      	mov	r3, r0
 8018304:	83bb      	strh	r3, [r7, #28]
                    lv_draw_px(lt_origo.x + LV_CIRC_OCT5_X(aa_p) - 1, lt_origo.y + LV_CIRC_OCT5_Y(aa_p) - i, mask,
 8018306:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 801830a:	b29a      	uxth	r2, r3
 801830c:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8018310:	b29b      	uxth	r3, r3
 8018312:	1ad3      	subs	r3, r2, r3
 8018314:	b29b      	uxth	r3, r3
 8018316:	3b01      	subs	r3, #1
 8018318:	b29b      	uxth	r3, r3
 801831a:	b218      	sxth	r0, r3
 801831c:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8018320:	b29a      	uxth	r2, r3
 8018322:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8018326:	b29b      	uxth	r3, r3
 8018328:	1ad3      	subs	r3, r2, r3
 801832a:	b29a      	uxth	r2, r3
 801832c:	f8b7 3082 	ldrh.w	r3, [r7, #130]	; 0x82
 8018330:	1ad3      	subs	r3, r2, r3
 8018332:	b29b      	uxth	r3, r3
 8018334:	b219      	sxth	r1, r3
 8018336:	f897 3081 	ldrb.w	r3, [r7, #129]	; 0x81
 801833a:	9300      	str	r3, [sp, #0]
 801833c:	8bbb      	ldrh	r3, [r7, #28]
 801833e:	68ba      	ldr	r2, [r7, #8]
 8018340:	f7fd fcf2 	bl	8015d28 <lv_draw_px>
                               aa_color_ver, aa_opa);
                    lv_draw_px(rt_origo.x + LV_CIRC_OCT8_X(aa_p) + 1, rt_origo.y + LV_CIRC_OCT8_Y(aa_p) - i, mask,
 8018344:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 8018348:	b29a      	uxth	r2, r3
 801834a:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 801834e:	b29b      	uxth	r3, r3
 8018350:	4413      	add	r3, r2
 8018352:	b29b      	uxth	r3, r3
 8018354:	3301      	adds	r3, #1
 8018356:	b29b      	uxth	r3, r3
 8018358:	b218      	sxth	r0, r3
 801835a:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 801835e:	b29a      	uxth	r2, r3
 8018360:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8018364:	b29b      	uxth	r3, r3
 8018366:	1ad3      	subs	r3, r2, r3
 8018368:	b29a      	uxth	r2, r3
 801836a:	f8b7 3082 	ldrh.w	r3, [r7, #130]	; 0x82
 801836e:	1ad3      	subs	r3, r2, r3
 8018370:	b29b      	uxth	r3, r3
 8018372:	b219      	sxth	r1, r3
 8018374:	f897 3081 	ldrb.w	r3, [r7, #129]	; 0x81
 8018378:	9300      	str	r3, [sp, #0]
 801837a:	8bbb      	ldrh	r3, [r7, #28]
 801837c:	68ba      	ldr	r2, [r7, #8]
 801837e:	f7fd fcd3 	bl	8015d28 <lv_draw_px>
                for(i = 0; i < seg_size; i++) {
 8018382:	f9b7 3082 	ldrsh.w	r3, [r7, #130]	; 0x82
 8018386:	b29b      	uxth	r3, r3
 8018388:	3301      	adds	r3, #1
 801838a:	b29b      	uxth	r3, r3
 801838c:	f8a7 3082 	strh.w	r3, [r7, #130]	; 0x82
 8018390:	f9b7 2082 	ldrsh.w	r2, [r7, #130]	; 0x82
 8018394:	f9b7 3068 	ldrsh.w	r3, [r7, #104]	; 0x68
 8018398:	429a      	cmp	r2, r3
 801839a:	f6ff aeb1 	blt.w	8018100 <lv_draw_rect_main_corner+0x39c>
                               aa_color_ver, aa_opa);
                }

                out_x_last      = cir.x;
 801839e:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 80183a0:	f8a7 3084 	strh.w	r3, [r7, #132]	; 0x84
                out_y_seg_start = out_y_seg_end;
 80183a4:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
 80183a8:	f8a7 3086 	strh.w	r3, [r7, #134]	; 0x86
            }
        }
#endif
        uint8_t edge_top_refr = 0;
 80183ac:	2300      	movs	r3, #0
 80183ae:	f887 3080 	strb.w	r3, [r7, #128]	; 0x80
        uint8_t mid_top_refr  = 0;
 80183b2:	2300      	movs	r3, #0
 80183b4:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
        uint8_t mid_bot_refr  = 0;
 80183b8:	2300      	movs	r3, #0
 80183ba:	f887 307e 	strb.w	r3, [r7, #126]	; 0x7e
        uint8_t edge_bot_refr = 0;
 80183be:	2300      	movs	r3, #0
 80183c0:	f887 307d 	strb.w	r3, [r7, #125]	; 0x7d

        /* If a new row coming draw the previous
         * The y coordinate can remain the same so wait for a new*/
        if(mid_bot_area.y1 != LV_CIRC_OCT4_Y(cir) + lb_origo.y) mid_bot_refr = 1;
 80183c4:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 80183c8:	461a      	mov	r2, r3
 80183ca:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 80183ce:	4619      	mov	r1, r3
 80183d0:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 80183d4:	440b      	add	r3, r1
 80183d6:	429a      	cmp	r2, r3
 80183d8:	d002      	beq.n	80183e0 <lv_draw_rect_main_corner+0x67c>
 80183da:	2301      	movs	r3, #1
 80183dc:	f887 307e 	strb.w	r3, [r7, #126]	; 0x7e

        if(edge_bot_area.y1 != LV_CIRC_OCT2_Y(cir) + lb_origo.y) edge_bot_refr = 1;
 80183e0:	f9b7 302e 	ldrsh.w	r3, [r7, #46]	; 0x2e
 80183e4:	461a      	mov	r2, r3
 80183e6:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 80183ea:	4619      	mov	r1, r3
 80183ec:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 80183f0:	440b      	add	r3, r1
 80183f2:	429a      	cmp	r2, r3
 80183f4:	d002      	beq.n	80183fc <lv_draw_rect_main_corner+0x698>
 80183f6:	2301      	movs	r3, #1
 80183f8:	f887 307d 	strb.w	r3, [r7, #125]	; 0x7d

        if(mid_top_area.y1 != LV_CIRC_OCT8_Y(cir) + lt_origo.y) mid_top_refr = 1;
 80183fc:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8018400:	461a      	mov	r2, r3
 8018402:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8018406:	4619      	mov	r1, r3
 8018408:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 801840c:	1acb      	subs	r3, r1, r3
 801840e:	429a      	cmp	r2, r3
 8018410:	d002      	beq.n	8018418 <lv_draw_rect_main_corner+0x6b4>
 8018412:	2301      	movs	r3, #1
 8018414:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f

        if(edge_top_area.y1 != LV_CIRC_OCT7_Y(cir) + lt_origo.y) edge_top_refr = 1;
 8018418:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 801841c:	461a      	mov	r2, r3
 801841e:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8018422:	4619      	mov	r1, r3
 8018424:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8018428:	1acb      	subs	r3, r1, r3
 801842a:	429a      	cmp	r2, r3
 801842c:	d002      	beq.n	8018434 <lv_draw_rect_main_corner+0x6d0>
 801842e:	2301      	movs	r3, #1
 8018430:	f887 3080 	strb.w	r3, [r7, #128]	; 0x80

        /*Draw the areas which are not disabled*/
        if(edge_top_refr != 0) {
 8018434:	f897 3080 	ldrb.w	r3, [r7, #128]	; 0x80
 8018438:	2b00      	cmp	r3, #0
 801843a:	d030      	beq.n	801849e <lv_draw_rect_main_corner+0x73a>
            if(mcolor.full == gcolor.full)
 801843c:	f8b7 2064 	ldrh.w	r2, [r7, #100]	; 0x64
 8018440:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 8018444:	429a      	cmp	r2, r3
 8018446:	d104      	bne.n	8018452 <lv_draw_rect_main_corner+0x6ee>
                act_color = mcolor;
 8018448:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 801844c:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
 8018450:	e01c      	b.n	801848c <lv_draw_rect_main_corner+0x728>
            else {
                mix       = (uint32_t)((uint32_t)(coords->y2 - edge_top_area.y1) * 255) / height;
 8018452:	68fb      	ldr	r3, [r7, #12]
 8018454:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8018458:	461a      	mov	r2, r3
 801845a:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 801845e:	1ad3      	subs	r3, r2, r3
 8018460:	461a      	mov	r2, r3
 8018462:	4613      	mov	r3, r2
 8018464:	021b      	lsls	r3, r3, #8
 8018466:	1a9a      	subs	r2, r3, r2
 8018468:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 801846c:	fbb2 f3f3 	udiv	r3, r2, r3
 8018470:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
                act_color = lv_color_mix(mcolor, gcolor, mix);
 8018474:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8018478:	461a      	mov	r2, r3
 801847a:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 801847e:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 8018482:	f7ff fa5d 	bl	8017940 <lv_color_mix>
 8018486:	4603      	mov	r3, r0
 8018488:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
            }
            lv_draw_fill(&edge_top_area, mask, act_color, opa);
 801848c:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 8018490:	f107 0044 	add.w	r0, r7, #68	; 0x44
 8018494:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 8018498:	68b9      	ldr	r1, [r7, #8]
 801849a:	f7fd fcdd 	bl	8015e58 <lv_draw_fill>
        }

        if(mid_top_refr != 0) {
 801849e:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
 80184a2:	2b00      	cmp	r3, #0
 80184a4:	d030      	beq.n	8018508 <lv_draw_rect_main_corner+0x7a4>
            if(mcolor.full == gcolor.full)
 80184a6:	f8b7 2064 	ldrh.w	r2, [r7, #100]	; 0x64
 80184aa:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 80184ae:	429a      	cmp	r2, r3
 80184b0:	d104      	bne.n	80184bc <lv_draw_rect_main_corner+0x758>
                act_color = mcolor;
 80184b2:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 80184b6:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
 80184ba:	e01c      	b.n	80184f6 <lv_draw_rect_main_corner+0x792>
            else {
                mix       = (uint32_t)((uint32_t)(coords->y2 - mid_top_area.y1) * 255) / height;
 80184bc:	68fb      	ldr	r3, [r7, #12]
 80184be:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80184c2:	461a      	mov	r2, r3
 80184c4:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 80184c8:	1ad3      	subs	r3, r2, r3
 80184ca:	461a      	mov	r2, r3
 80184cc:	4613      	mov	r3, r2
 80184ce:	021b      	lsls	r3, r3, #8
 80184d0:	1a9a      	subs	r2, r3, r2
 80184d2:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 80184d6:	fbb2 f3f3 	udiv	r3, r2, r3
 80184da:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
                act_color = lv_color_mix(mcolor, gcolor, mix);
 80184de:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 80184e2:	461a      	mov	r2, r3
 80184e4:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 80184e8:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 80184ec:	f7ff fa28 	bl	8017940 <lv_color_mix>
 80184f0:	4603      	mov	r3, r0
 80184f2:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
            }
            lv_draw_fill(&mid_top_area, mask, act_color, opa);
 80184f6:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 80184fa:	f107 003c 	add.w	r0, r7, #60	; 0x3c
 80184fe:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 8018502:	68b9      	ldr	r1, [r7, #8]
 8018504:	f7fd fca8 	bl	8015e58 <lv_draw_fill>
        }

        if(mid_bot_refr != 0) {
 8018508:	f897 307e 	ldrb.w	r3, [r7, #126]	; 0x7e
 801850c:	2b00      	cmp	r3, #0
 801850e:	d030      	beq.n	8018572 <lv_draw_rect_main_corner+0x80e>
            if(mcolor.full == gcolor.full)
 8018510:	f8b7 2064 	ldrh.w	r2, [r7, #100]	; 0x64
 8018514:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 8018518:	429a      	cmp	r2, r3
 801851a:	d104      	bne.n	8018526 <lv_draw_rect_main_corner+0x7c2>
                act_color = mcolor;
 801851c:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 8018520:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
 8018524:	e01c      	b.n	8018560 <lv_draw_rect_main_corner+0x7fc>
            else {
                mix       = (uint32_t)((uint32_t)(coords->y2 - mid_bot_area.y1) * 255) / height;
 8018526:	68fb      	ldr	r3, [r7, #12]
 8018528:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801852c:	461a      	mov	r2, r3
 801852e:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8018532:	1ad3      	subs	r3, r2, r3
 8018534:	461a      	mov	r2, r3
 8018536:	4613      	mov	r3, r2
 8018538:	021b      	lsls	r3, r3, #8
 801853a:	1a9a      	subs	r2, r3, r2
 801853c:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 8018540:	fbb2 f3f3 	udiv	r3, r2, r3
 8018544:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
                act_color = lv_color_mix(mcolor, gcolor, mix);
 8018548:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 801854c:	461a      	mov	r2, r3
 801854e:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 8018552:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 8018556:	f7ff f9f3 	bl	8017940 <lv_color_mix>
 801855a:	4603      	mov	r3, r0
 801855c:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
            }
            lv_draw_fill(&mid_bot_area, mask, act_color, opa);
 8018560:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 8018564:	f107 0034 	add.w	r0, r7, #52	; 0x34
 8018568:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 801856c:	68b9      	ldr	r1, [r7, #8]
 801856e:	f7fd fc73 	bl	8015e58 <lv_draw_fill>
        }

        if(edge_bot_refr != 0) {
 8018572:	f897 307d 	ldrb.w	r3, [r7, #125]	; 0x7d
 8018576:	2b00      	cmp	r3, #0
 8018578:	d030      	beq.n	80185dc <lv_draw_rect_main_corner+0x878>

            if(mcolor.full == gcolor.full)
 801857a:	f8b7 2064 	ldrh.w	r2, [r7, #100]	; 0x64
 801857e:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 8018582:	429a      	cmp	r2, r3
 8018584:	d104      	bne.n	8018590 <lv_draw_rect_main_corner+0x82c>
                act_color = mcolor;
 8018586:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 801858a:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
 801858e:	e01c      	b.n	80185ca <lv_draw_rect_main_corner+0x866>
            else {
                mix       = (uint32_t)((uint32_t)(coords->y2 - edge_bot_area.y1) * 255) / height;
 8018590:	68fb      	ldr	r3, [r7, #12]
 8018592:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8018596:	461a      	mov	r2, r3
 8018598:	f9b7 302e 	ldrsh.w	r3, [r7, #46]	; 0x2e
 801859c:	1ad3      	subs	r3, r2, r3
 801859e:	461a      	mov	r2, r3
 80185a0:	4613      	mov	r3, r2
 80185a2:	021b      	lsls	r3, r3, #8
 80185a4:	1a9a      	subs	r2, r3, r2
 80185a6:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 80185aa:	fbb2 f3f3 	udiv	r3, r2, r3
 80185ae:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
                act_color = lv_color_mix(mcolor, gcolor, mix);
 80185b2:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 80185b6:	461a      	mov	r2, r3
 80185b8:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 80185bc:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 80185c0:	f7ff f9be 	bl	8017940 <lv_color_mix>
 80185c4:	4603      	mov	r3, r0
 80185c6:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
            }
            lv_draw_fill(&edge_bot_area, mask, act_color, opa);
 80185ca:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 80185ce:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 80185d2:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 80185d6:	68b9      	ldr	r1, [r7, #8]
 80185d8:	f7fd fc3e 	bl	8015e58 <lv_draw_fill>
        }

        /*Save the current coordinates*/
        lv_area_set(&mid_bot_area, lb_origo.x + LV_CIRC_OCT4_X(cir), lb_origo.y + LV_CIRC_OCT4_Y(cir),
 80185dc:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 80185e0:	b29a      	uxth	r2, r3
 80185e2:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 80185e6:	b29b      	uxth	r3, r3
 80185e8:	1ad3      	subs	r3, r2, r3
 80185ea:	b29b      	uxth	r3, r3
 80185ec:	b219      	sxth	r1, r3
 80185ee:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 80185f2:	b29a      	uxth	r2, r3
 80185f4:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 80185f8:	b29b      	uxth	r3, r3
 80185fa:	4413      	add	r3, r2
 80185fc:	b29b      	uxth	r3, r3
 80185fe:	b21c      	sxth	r4, r3
                    rb_origo.x + LV_CIRC_OCT1_X(cir), rb_origo.y + LV_CIRC_OCT1_Y(cir));
 8018600:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 8018604:	b29a      	uxth	r2, r3
 8018606:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 801860a:	b29b      	uxth	r3, r3
 801860c:	4413      	add	r3, r2
 801860e:	b29b      	uxth	r3, r3
        lv_area_set(&mid_bot_area, lb_origo.x + LV_CIRC_OCT4_X(cir), lb_origo.y + LV_CIRC_OCT4_Y(cir),
 8018610:	b21d      	sxth	r5, r3
                    rb_origo.x + LV_CIRC_OCT1_X(cir), rb_origo.y + LV_CIRC_OCT1_Y(cir));
 8018612:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 8018616:	b29a      	uxth	r2, r3
 8018618:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 801861c:	b29b      	uxth	r3, r3
 801861e:	4413      	add	r3, r2
 8018620:	b29b      	uxth	r3, r3
        lv_area_set(&mid_bot_area, lb_origo.x + LV_CIRC_OCT4_X(cir), lb_origo.y + LV_CIRC_OCT4_Y(cir),
 8018622:	b21b      	sxth	r3, r3
 8018624:	f107 0034 	add.w	r0, r7, #52	; 0x34
 8018628:	9300      	str	r3, [sp, #0]
 801862a:	462b      	mov	r3, r5
 801862c:	4622      	mov	r2, r4
 801862e:	f005 f89b 	bl	801d768 <lv_area_set>

        lv_area_set(&edge_bot_area, lb_origo.x + LV_CIRC_OCT3_X(cir), lb_origo.y + LV_CIRC_OCT3_Y(cir),
 8018632:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 8018636:	b29a      	uxth	r2, r3
 8018638:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 801863c:	b29b      	uxth	r3, r3
 801863e:	1ad3      	subs	r3, r2, r3
 8018640:	b29b      	uxth	r3, r3
 8018642:	b219      	sxth	r1, r3
 8018644:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 8018648:	b29a      	uxth	r2, r3
 801864a:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 801864e:	b29b      	uxth	r3, r3
 8018650:	4413      	add	r3, r2
 8018652:	b29b      	uxth	r3, r3
 8018654:	b21c      	sxth	r4, r3
                    rb_origo.x + LV_CIRC_OCT2_X(cir), rb_origo.y + LV_CIRC_OCT2_Y(cir));
 8018656:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 801865a:	b29a      	uxth	r2, r3
 801865c:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8018660:	b29b      	uxth	r3, r3
 8018662:	4413      	add	r3, r2
 8018664:	b29b      	uxth	r3, r3
        lv_area_set(&edge_bot_area, lb_origo.x + LV_CIRC_OCT3_X(cir), lb_origo.y + LV_CIRC_OCT3_Y(cir),
 8018666:	b21d      	sxth	r5, r3
                    rb_origo.x + LV_CIRC_OCT2_X(cir), rb_origo.y + LV_CIRC_OCT2_Y(cir));
 8018668:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 801866c:	b29a      	uxth	r2, r3
 801866e:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8018672:	b29b      	uxth	r3, r3
 8018674:	4413      	add	r3, r2
 8018676:	b29b      	uxth	r3, r3
        lv_area_set(&edge_bot_area, lb_origo.x + LV_CIRC_OCT3_X(cir), lb_origo.y + LV_CIRC_OCT3_Y(cir),
 8018678:	b21b      	sxth	r3, r3
 801867a:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 801867e:	9300      	str	r3, [sp, #0]
 8018680:	462b      	mov	r3, r5
 8018682:	4622      	mov	r2, r4
 8018684:	f005 f870 	bl	801d768 <lv_area_set>

        lv_area_set(&mid_top_area, lt_origo.x + LV_CIRC_OCT5_X(cir), lt_origo.y + LV_CIRC_OCT5_Y(cir),
 8018688:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 801868c:	b29a      	uxth	r2, r3
 801868e:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8018692:	b29b      	uxth	r3, r3
 8018694:	1ad3      	subs	r3, r2, r3
 8018696:	b29b      	uxth	r3, r3
 8018698:	b219      	sxth	r1, r3
 801869a:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 801869e:	b29a      	uxth	r2, r3
 80186a0:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 80186a4:	b29b      	uxth	r3, r3
 80186a6:	1ad3      	subs	r3, r2, r3
 80186a8:	b29b      	uxth	r3, r3
 80186aa:	b21c      	sxth	r4, r3
                    rt_origo.x + LV_CIRC_OCT8_X(cir), rt_origo.y + LV_CIRC_OCT8_Y(cir));
 80186ac:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 80186b0:	b29a      	uxth	r2, r3
 80186b2:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 80186b6:	b29b      	uxth	r3, r3
 80186b8:	4413      	add	r3, r2
 80186ba:	b29b      	uxth	r3, r3
        lv_area_set(&mid_top_area, lt_origo.x + LV_CIRC_OCT5_X(cir), lt_origo.y + LV_CIRC_OCT5_Y(cir),
 80186bc:	b21d      	sxth	r5, r3
                    rt_origo.x + LV_CIRC_OCT8_X(cir), rt_origo.y + LV_CIRC_OCT8_Y(cir));
 80186be:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 80186c2:	b29a      	uxth	r2, r3
 80186c4:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 80186c8:	b29b      	uxth	r3, r3
 80186ca:	1ad3      	subs	r3, r2, r3
 80186cc:	b29b      	uxth	r3, r3
        lv_area_set(&mid_top_area, lt_origo.x + LV_CIRC_OCT5_X(cir), lt_origo.y + LV_CIRC_OCT5_Y(cir),
 80186ce:	b21b      	sxth	r3, r3
 80186d0:	f107 003c 	add.w	r0, r7, #60	; 0x3c
 80186d4:	9300      	str	r3, [sp, #0]
 80186d6:	462b      	mov	r3, r5
 80186d8:	4622      	mov	r2, r4
 80186da:	f005 f845 	bl	801d768 <lv_area_set>

        lv_area_set(&edge_top_area, lt_origo.x + LV_CIRC_OCT6_X(cir), lt_origo.y + LV_CIRC_OCT6_Y(cir),
 80186de:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 80186e2:	b29a      	uxth	r2, r3
 80186e4:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 80186e8:	b29b      	uxth	r3, r3
 80186ea:	1ad3      	subs	r3, r2, r3
 80186ec:	b29b      	uxth	r3, r3
 80186ee:	b219      	sxth	r1, r3
 80186f0:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 80186f4:	b29a      	uxth	r2, r3
 80186f6:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 80186fa:	b29b      	uxth	r3, r3
 80186fc:	1ad3      	subs	r3, r2, r3
 80186fe:	b29b      	uxth	r3, r3
 8018700:	b21c      	sxth	r4, r3
                    rt_origo.x + LV_CIRC_OCT7_X(cir), rt_origo.y + LV_CIRC_OCT7_Y(cir));
 8018702:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 8018706:	b29a      	uxth	r2, r3
 8018708:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 801870c:	b29b      	uxth	r3, r3
 801870e:	4413      	add	r3, r2
 8018710:	b29b      	uxth	r3, r3
        lv_area_set(&edge_top_area, lt_origo.x + LV_CIRC_OCT6_X(cir), lt_origo.y + LV_CIRC_OCT6_Y(cir),
 8018712:	b21d      	sxth	r5, r3
                    rt_origo.x + LV_CIRC_OCT7_X(cir), rt_origo.y + LV_CIRC_OCT7_Y(cir));
 8018714:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 8018718:	b29a      	uxth	r2, r3
 801871a:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 801871e:	b29b      	uxth	r3, r3
 8018720:	1ad3      	subs	r3, r2, r3
 8018722:	b29b      	uxth	r3, r3
        lv_area_set(&edge_top_area, lt_origo.x + LV_CIRC_OCT6_X(cir), lt_origo.y + LV_CIRC_OCT6_Y(cir),
 8018724:	b21b      	sxth	r3, r3
 8018726:	f107 0044 	add.w	r0, r7, #68	; 0x44
 801872a:	9300      	str	r3, [sp, #0]
 801872c:	462b      	mov	r3, r5
 801872e:	4622      	mov	r2, r4
 8018730:	f005 f81a 	bl	801d768 <lv_area_set>

        lv_circ_next(&cir, &cir_tmp);
 8018734:	f107 0226 	add.w	r2, r7, #38	; 0x26
 8018738:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801873c:	4611      	mov	r1, r2
 801873e:	4618      	mov	r0, r3
 8018740:	f005 f984 	bl	801da4c <lv_circ_next>
    while(lv_circ_cont(&cir)) {
 8018744:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8018748:	4618      	mov	r0, r3
 801874a:	f005 f96a 	bl	801da22 <lv_circ_cont>
 801874e:	4603      	mov	r3, r0
 8018750:	2b00      	cmp	r3, #0
 8018752:	f47f ac8f 	bne.w	8018074 <lv_draw_rect_main_corner+0x310>
    }

    if(mcolor.full == gcolor.full)
 8018756:	f8b7 2064 	ldrh.w	r2, [r7, #100]	; 0x64
 801875a:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 801875e:	429a      	cmp	r2, r3
 8018760:	d104      	bne.n	801876c <lv_draw_rect_main_corner+0xa08>
        act_color = mcolor;
 8018762:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 8018766:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
 801876a:	e01c      	b.n	80187a6 <lv_draw_rect_main_corner+0xa42>
    else {
        mix       = (uint32_t)((uint32_t)(coords->y2 - edge_top_area.y1) * 255) / height;
 801876c:	68fb      	ldr	r3, [r7, #12]
 801876e:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8018772:	461a      	mov	r2, r3
 8018774:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 8018778:	1ad3      	subs	r3, r2, r3
 801877a:	461a      	mov	r2, r3
 801877c:	4613      	mov	r3, r2
 801877e:	021b      	lsls	r3, r3, #8
 8018780:	1a9a      	subs	r2, r3, r2
 8018782:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 8018786:	fbb2 f3f3 	udiv	r3, r2, r3
 801878a:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
        act_color = lv_color_mix(mcolor, gcolor, mix);
 801878e:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8018792:	461a      	mov	r2, r3
 8018794:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 8018798:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 801879c:	f7ff f8d0 	bl	8017940 <lv_color_mix>
 80187a0:	4603      	mov	r3, r0
 80187a2:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
    }
    lv_draw_fill(&edge_top_area, mask, act_color, opa);
 80187a6:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 80187aa:	f107 0044 	add.w	r0, r7, #68	; 0x44
 80187ae:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 80187b2:	68b9      	ldr	r1, [r7, #8]
 80187b4:	f7fd fb50 	bl	8015e58 <lv_draw_fill>

    if(edge_top_area.y1 != mid_top_area.y1) {
 80187b8:	f9b7 2046 	ldrsh.w	r2, [r7, #70]	; 0x46
 80187bc:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 80187c0:	429a      	cmp	r2, r3
 80187c2:	d030      	beq.n	8018826 <lv_draw_rect_main_corner+0xac2>

        if(mcolor.full == gcolor.full)
 80187c4:	f8b7 2064 	ldrh.w	r2, [r7, #100]	; 0x64
 80187c8:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 80187cc:	429a      	cmp	r2, r3
 80187ce:	d104      	bne.n	80187da <lv_draw_rect_main_corner+0xa76>
            act_color = mcolor;
 80187d0:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 80187d4:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
 80187d8:	e01c      	b.n	8018814 <lv_draw_rect_main_corner+0xab0>
        else {
            mix       = (uint32_t)((uint32_t)(coords->y2 - mid_top_area.y1) * 255) / height;
 80187da:	68fb      	ldr	r3, [r7, #12]
 80187dc:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80187e0:	461a      	mov	r2, r3
 80187e2:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 80187e6:	1ad3      	subs	r3, r2, r3
 80187e8:	461a      	mov	r2, r3
 80187ea:	4613      	mov	r3, r2
 80187ec:	021b      	lsls	r3, r3, #8
 80187ee:	1a9a      	subs	r2, r3, r2
 80187f0:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 80187f4:	fbb2 f3f3 	udiv	r3, r2, r3
 80187f8:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
            act_color = lv_color_mix(mcolor, gcolor, mix);
 80187fc:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8018800:	461a      	mov	r2, r3
 8018802:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 8018806:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 801880a:	f7ff f899 	bl	8017940 <lv_color_mix>
 801880e:	4603      	mov	r3, r0
 8018810:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
        }
        lv_draw_fill(&mid_top_area, mask, act_color, opa);
 8018814:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 8018818:	f107 003c 	add.w	r0, r7, #60	; 0x3c
 801881c:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 8018820:	68b9      	ldr	r1, [r7, #8]
 8018822:	f7fd fb19 	bl	8015e58 <lv_draw_fill>
    }

    if(mcolor.full == gcolor.full)
 8018826:	f8b7 2064 	ldrh.w	r2, [r7, #100]	; 0x64
 801882a:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 801882e:	429a      	cmp	r2, r3
 8018830:	d104      	bne.n	801883c <lv_draw_rect_main_corner+0xad8>
        act_color = mcolor;
 8018832:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 8018836:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
 801883a:	e01c      	b.n	8018876 <lv_draw_rect_main_corner+0xb12>
    else {
        mix       = (uint32_t)((uint32_t)(coords->y2 - mid_bot_area.y1) * 255) / height;
 801883c:	68fb      	ldr	r3, [r7, #12]
 801883e:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8018842:	461a      	mov	r2, r3
 8018844:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8018848:	1ad3      	subs	r3, r2, r3
 801884a:	461a      	mov	r2, r3
 801884c:	4613      	mov	r3, r2
 801884e:	021b      	lsls	r3, r3, #8
 8018850:	1a9a      	subs	r2, r3, r2
 8018852:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 8018856:	fbb2 f3f3 	udiv	r3, r2, r3
 801885a:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
        act_color = lv_color_mix(mcolor, gcolor, mix);
 801885e:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8018862:	461a      	mov	r2, r3
 8018864:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 8018868:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 801886c:	f7ff f868 	bl	8017940 <lv_color_mix>
 8018870:	4603      	mov	r3, r0
 8018872:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
    }
    lv_draw_fill(&mid_bot_area, mask, act_color, opa);
 8018876:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 801887a:	f107 0034 	add.w	r0, r7, #52	; 0x34
 801887e:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 8018882:	68b9      	ldr	r1, [r7, #8]
 8018884:	f7fd fae8 	bl	8015e58 <lv_draw_fill>

    if(edge_bot_area.y1 != mid_bot_area.y1) {
 8018888:	f9b7 202e 	ldrsh.w	r2, [r7, #46]	; 0x2e
 801888c:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8018890:	429a      	cmp	r2, r3
 8018892:	d030      	beq.n	80188f6 <lv_draw_rect_main_corner+0xb92>

        if(mcolor.full == gcolor.full)
 8018894:	f8b7 2064 	ldrh.w	r2, [r7, #100]	; 0x64
 8018898:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 801889c:	429a      	cmp	r2, r3
 801889e:	d104      	bne.n	80188aa <lv_draw_rect_main_corner+0xb46>
            act_color = mcolor;
 80188a0:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 80188a4:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
 80188a8:	e01c      	b.n	80188e4 <lv_draw_rect_main_corner+0xb80>
        else {
            mix       = (uint32_t)((uint32_t)(coords->y2 - edge_bot_area.y1) * 255) / height;
 80188aa:	68fb      	ldr	r3, [r7, #12]
 80188ac:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80188b0:	461a      	mov	r2, r3
 80188b2:	f9b7 302e 	ldrsh.w	r3, [r7, #46]	; 0x2e
 80188b6:	1ad3      	subs	r3, r2, r3
 80188b8:	461a      	mov	r2, r3
 80188ba:	4613      	mov	r3, r2
 80188bc:	021b      	lsls	r3, r3, #8
 80188be:	1a9a      	subs	r2, r3, r2
 80188c0:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 80188c4:	fbb2 f3f3 	udiv	r3, r2, r3
 80188c8:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
            act_color = lv_color_mix(mcolor, gcolor, mix);
 80188cc:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 80188d0:	461a      	mov	r2, r3
 80188d2:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 80188d6:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 80188da:	f7ff f831 	bl	8017940 <lv_color_mix>
 80188de:	4603      	mov	r3, r0
 80188e0:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
        }
        lv_draw_fill(&edge_bot_area, mask, act_color, opa);
 80188e4:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 80188e8:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 80188ec:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 80188f0:	68b9      	ldr	r1, [r7, #8]
 80188f2:	f7fd fab1 	bl	8015e58 <lv_draw_fill>
    }

#if LV_ANTIALIAS
    if(aa) {
 80188f6:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 80188fa:	2b00      	cmp	r3, #0
 80188fc:	f000 8257 	beq.w	8018dae <lv_draw_rect_main_corner+0x104a>
        /*The first and the last line is not drawn*/
        edge_top_area.x1 = coords->x1 + radius + 2;
 8018900:	68fb      	ldr	r3, [r7, #12]
 8018902:	f9b3 3000 	ldrsh.w	r3, [r3]
 8018906:	b29a      	uxth	r2, r3
 8018908:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 801890c:	4413      	add	r3, r2
 801890e:	b29b      	uxth	r3, r3
 8018910:	3302      	adds	r3, #2
 8018912:	b29b      	uxth	r3, r3
 8018914:	b21b      	sxth	r3, r3
 8018916:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
        edge_top_area.x2 = coords->x2 - radius - 2;
 801891a:	68fb      	ldr	r3, [r7, #12]
 801891c:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8018920:	b29a      	uxth	r2, r3
 8018922:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 8018926:	1ad3      	subs	r3, r2, r3
 8018928:	b29b      	uxth	r3, r3
 801892a:	3b02      	subs	r3, #2
 801892c:	b29b      	uxth	r3, r3
 801892e:	b21b      	sxth	r3, r3
 8018930:	f8a7 3048 	strh.w	r3, [r7, #72]	; 0x48
        edge_top_area.y1 = coords->y1;
 8018934:	68fb      	ldr	r3, [r7, #12]
 8018936:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801893a:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
        edge_top_area.y2 = coords->y1;
 801893e:	68fb      	ldr	r3, [r7, #12]
 8018940:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8018944:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
        lv_draw_fill(&edge_top_area, mask, style->body.main_color, opa);
 8018948:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 801894c:	687a      	ldr	r2, [r7, #4]
 801894e:	f107 0044 	add.w	r0, r7, #68	; 0x44
 8018952:	8852      	ldrh	r2, [r2, #2]
 8018954:	68b9      	ldr	r1, [r7, #8]
 8018956:	f7fd fa7f 	bl	8015e58 <lv_draw_fill>

        edge_top_area.y1 = coords->y2;
 801895a:	68fb      	ldr	r3, [r7, #12]
 801895c:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8018960:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
        edge_top_area.y2 = coords->y2;
 8018964:	68fb      	ldr	r3, [r7, #12]
 8018966:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801896a:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
        lv_draw_fill(&edge_top_area, mask, style->body.grad_color, opa);
 801896e:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 8018972:	687a      	ldr	r2, [r7, #4]
 8018974:	f107 0044 	add.w	r0, r7, #68	; 0x44
 8018978:	8892      	ldrh	r2, [r2, #4]
 801897a:	68b9      	ldr	r1, [r7, #8]
 801897c:	f7fd fa6c 	bl	8015e58 <lv_draw_fill>

        /*Last parts of the anti-alias*/
        out_y_seg_end       = cir.y;
 8018980:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8018982:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
        lv_coord_t seg_size = out_y_seg_end - out_y_seg_start;
 8018986:	f8b7 2070 	ldrh.w	r2, [r7, #112]	; 0x70
 801898a:	f8b7 3086 	ldrh.w	r3, [r7, #134]	; 0x86
 801898e:	1ad3      	subs	r3, r2, r3
 8018990:	b29b      	uxth	r3, r3
 8018992:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
        lv_point_t aa_p;

        aa_p.x = out_x_last;
 8018996:	f8b7 3084 	ldrh.w	r3, [r7, #132]	; 0x84
 801899a:	82bb      	strh	r3, [r7, #20]
        aa_p.y = out_y_seg_start;
 801899c:	f8b7 3086 	ldrh.w	r3, [r7, #134]	; 0x86
 80189a0:	82fb      	strh	r3, [r7, #22]

        mix                 = (uint32_t)((uint32_t)(radius - out_x_last) * 255) / height;
 80189a2:	f8b7 2078 	ldrh.w	r2, [r7, #120]	; 0x78
 80189a6:	f9b7 3084 	ldrsh.w	r3, [r7, #132]	; 0x84
 80189aa:	1ad3      	subs	r3, r2, r3
 80189ac:	461a      	mov	r2, r3
 80189ae:	4613      	mov	r3, r2
 80189b0:	021b      	lsls	r3, r3, #8
 80189b2:	1a9a      	subs	r2, r3, r2
 80189b4:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 80189b8:	fbb2 f3f3 	udiv	r3, r2, r3
 80189bc:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
        aa_color_hor_bottom = lv_color_mix(gcolor, mcolor, mix);
 80189c0:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 80189c4:	461a      	mov	r2, r3
 80189c6:	f8b7 1064 	ldrh.w	r1, [r7, #100]	; 0x64
 80189ca:	f8b7 0060 	ldrh.w	r0, [r7, #96]	; 0x60
 80189ce:	f7fe ffb7 	bl	8017940 <lv_color_mix>
 80189d2:	4603      	mov	r3, r0
 80189d4:	843b      	strh	r3, [r7, #32]
        aa_color_hor_top    = lv_color_mix(mcolor, gcolor, mix);
 80189d6:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 80189da:	461a      	mov	r2, r3
 80189dc:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 80189e0:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 80189e4:	f7fe ffac 	bl	8017940 <lv_color_mix>
 80189e8:	4603      	mov	r3, r0
 80189ea:	84bb      	strh	r3, [r7, #36]	; 0x24

        lv_coord_t i;
        for(i = 0; i < seg_size; i++) {
 80189ec:	2300      	movs	r3, #0
 80189ee:	f8a7 307a 	strh.w	r3, [r7, #122]	; 0x7a
 80189f2:	e136      	b.n	8018c62 <lv_draw_rect_main_corner+0xefe>
            lv_opa_t aa_opa = opa - lv_draw_aa_get_opa(seg_size, i, opa);
 80189f4:	f897 2076 	ldrb.w	r2, [r7, #118]	; 0x76
 80189f8:	f9b7 107a 	ldrsh.w	r1, [r7, #122]	; 0x7a
 80189fc:	f9b7 306c 	ldrsh.w	r3, [r7, #108]	; 0x6c
 8018a00:	4618      	mov	r0, r3
 8018a02:	f7fc fd1b 	bl	801543c <lv_draw_aa_get_opa>
 8018a06:	4603      	mov	r3, r0
 8018a08:	461a      	mov	r2, r3
 8018a0a:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 8018a0e:	1a9b      	subs	r3, r3, r2
 8018a10:	f887 306a 	strb.w	r3, [r7, #106]	; 0x6a
            lv_draw_px(rb_origo.x + LV_CIRC_OCT2_X(aa_p) + i, rb_origo.y + LV_CIRC_OCT2_Y(aa_p) + 1, mask,
 8018a14:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 8018a18:	b29a      	uxth	r2, r3
 8018a1a:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8018a1e:	b29b      	uxth	r3, r3
 8018a20:	4413      	add	r3, r2
 8018a22:	b29a      	uxth	r2, r3
 8018a24:	f8b7 307a 	ldrh.w	r3, [r7, #122]	; 0x7a
 8018a28:	4413      	add	r3, r2
 8018a2a:	b29b      	uxth	r3, r3
 8018a2c:	b218      	sxth	r0, r3
 8018a2e:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 8018a32:	b29a      	uxth	r2, r3
 8018a34:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8018a38:	b29b      	uxth	r3, r3
 8018a3a:	4413      	add	r3, r2
 8018a3c:	b29b      	uxth	r3, r3
 8018a3e:	3301      	adds	r3, #1
 8018a40:	b29b      	uxth	r3, r3
 8018a42:	b219      	sxth	r1, r3
 8018a44:	f897 306a 	ldrb.w	r3, [r7, #106]	; 0x6a
 8018a48:	9300      	str	r3, [sp, #0]
 8018a4a:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8018a4c:	68ba      	ldr	r2, [r7, #8]
 8018a4e:	f7fd f96b 	bl	8015d28 <lv_draw_px>
                       aa_color_hor_top, aa_opa);
            lv_draw_px(lb_origo.x + LV_CIRC_OCT3_X(aa_p) - i, lb_origo.y + LV_CIRC_OCT3_Y(aa_p) + 1, mask,
 8018a52:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 8018a56:	b29a      	uxth	r2, r3
 8018a58:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8018a5c:	b29b      	uxth	r3, r3
 8018a5e:	1ad3      	subs	r3, r2, r3
 8018a60:	b29a      	uxth	r2, r3
 8018a62:	f8b7 307a 	ldrh.w	r3, [r7, #122]	; 0x7a
 8018a66:	1ad3      	subs	r3, r2, r3
 8018a68:	b29b      	uxth	r3, r3
 8018a6a:	b218      	sxth	r0, r3
 8018a6c:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 8018a70:	b29a      	uxth	r2, r3
 8018a72:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8018a76:	b29b      	uxth	r3, r3
 8018a78:	4413      	add	r3, r2
 8018a7a:	b29b      	uxth	r3, r3
 8018a7c:	3301      	adds	r3, #1
 8018a7e:	b29b      	uxth	r3, r3
 8018a80:	b219      	sxth	r1, r3
 8018a82:	f897 306a 	ldrb.w	r3, [r7, #106]	; 0x6a
 8018a86:	9300      	str	r3, [sp, #0]
 8018a88:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8018a8a:	68ba      	ldr	r2, [r7, #8]
 8018a8c:	f7fd f94c 	bl	8015d28 <lv_draw_px>
                       aa_color_hor_top, aa_opa);
            lv_draw_px(lt_origo.x + LV_CIRC_OCT6_X(aa_p) - i, lt_origo.y + LV_CIRC_OCT6_Y(aa_p) - 1, mask,
 8018a90:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 8018a94:	b29a      	uxth	r2, r3
 8018a96:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8018a9a:	b29b      	uxth	r3, r3
 8018a9c:	1ad3      	subs	r3, r2, r3
 8018a9e:	b29a      	uxth	r2, r3
 8018aa0:	f8b7 307a 	ldrh.w	r3, [r7, #122]	; 0x7a
 8018aa4:	1ad3      	subs	r3, r2, r3
 8018aa6:	b29b      	uxth	r3, r3
 8018aa8:	b218      	sxth	r0, r3
 8018aaa:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8018aae:	b29a      	uxth	r2, r3
 8018ab0:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8018ab4:	b29b      	uxth	r3, r3
 8018ab6:	1ad3      	subs	r3, r2, r3
 8018ab8:	b29b      	uxth	r3, r3
 8018aba:	3b01      	subs	r3, #1
 8018abc:	b29b      	uxth	r3, r3
 8018abe:	b219      	sxth	r1, r3
 8018ac0:	f897 306a 	ldrb.w	r3, [r7, #106]	; 0x6a
 8018ac4:	9300      	str	r3, [sp, #0]
 8018ac6:	8c3b      	ldrh	r3, [r7, #32]
 8018ac8:	68ba      	ldr	r2, [r7, #8]
 8018aca:	f7fd f92d 	bl	8015d28 <lv_draw_px>
                       aa_color_hor_bottom, aa_opa);
            lv_draw_px(rt_origo.x + LV_CIRC_OCT7_X(aa_p) + i, rt_origo.y + LV_CIRC_OCT7_Y(aa_p) - 1, mask,
 8018ace:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 8018ad2:	b29a      	uxth	r2, r3
 8018ad4:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8018ad8:	b29b      	uxth	r3, r3
 8018ada:	4413      	add	r3, r2
 8018adc:	b29a      	uxth	r2, r3
 8018ade:	f8b7 307a 	ldrh.w	r3, [r7, #122]	; 0x7a
 8018ae2:	4413      	add	r3, r2
 8018ae4:	b29b      	uxth	r3, r3
 8018ae6:	b218      	sxth	r0, r3
 8018ae8:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 8018aec:	b29a      	uxth	r2, r3
 8018aee:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8018af2:	b29b      	uxth	r3, r3
 8018af4:	1ad3      	subs	r3, r2, r3
 8018af6:	b29b      	uxth	r3, r3
 8018af8:	3b01      	subs	r3, #1
 8018afa:	b29b      	uxth	r3, r3
 8018afc:	b219      	sxth	r1, r3
 8018afe:	f897 306a 	ldrb.w	r3, [r7, #106]	; 0x6a
 8018b02:	9300      	str	r3, [sp, #0]
 8018b04:	8c3b      	ldrh	r3, [r7, #32]
 8018b06:	68ba      	ldr	r2, [r7, #8]
 8018b08:	f7fd f90e 	bl	8015d28 <lv_draw_px>
                       aa_color_hor_bottom, aa_opa);

            mix          = (uint32_t)((uint32_t)(radius - out_y_seg_start + i) * 255) / height;
 8018b0c:	f8b7 2078 	ldrh.w	r2, [r7, #120]	; 0x78
 8018b10:	f9b7 3086 	ldrsh.w	r3, [r7, #134]	; 0x86
 8018b14:	1ad2      	subs	r2, r2, r3
 8018b16:	f9b7 307a 	ldrsh.w	r3, [r7, #122]	; 0x7a
 8018b1a:	4413      	add	r3, r2
 8018b1c:	461a      	mov	r2, r3
 8018b1e:	4613      	mov	r3, r2
 8018b20:	021b      	lsls	r3, r3, #8
 8018b22:	1a9a      	subs	r2, r3, r2
 8018b24:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 8018b28:	fbb2 f3f3 	udiv	r3, r2, r3
 8018b2c:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
            aa_color_ver = lv_color_mix(mcolor, gcolor, mix);
 8018b30:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8018b34:	461a      	mov	r2, r3
 8018b36:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 8018b3a:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 8018b3e:	f7fe feff 	bl	8017940 <lv_color_mix>
 8018b42:	4603      	mov	r3, r0
 8018b44:	83bb      	strh	r3, [r7, #28]
            lv_draw_px(rb_origo.x + LV_CIRC_OCT1_X(aa_p) + 1, rb_origo.y + LV_CIRC_OCT1_Y(aa_p) + i, mask, aa_color_ver,
 8018b46:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 8018b4a:	b29a      	uxth	r2, r3
 8018b4c:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8018b50:	b29b      	uxth	r3, r3
 8018b52:	4413      	add	r3, r2
 8018b54:	b29b      	uxth	r3, r3
 8018b56:	3301      	adds	r3, #1
 8018b58:	b29b      	uxth	r3, r3
 8018b5a:	b218      	sxth	r0, r3
 8018b5c:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 8018b60:	b29a      	uxth	r2, r3
 8018b62:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8018b66:	b29b      	uxth	r3, r3
 8018b68:	4413      	add	r3, r2
 8018b6a:	b29a      	uxth	r2, r3
 8018b6c:	f8b7 307a 	ldrh.w	r3, [r7, #122]	; 0x7a
 8018b70:	4413      	add	r3, r2
 8018b72:	b29b      	uxth	r3, r3
 8018b74:	b219      	sxth	r1, r3
 8018b76:	f897 306a 	ldrb.w	r3, [r7, #106]	; 0x6a
 8018b7a:	9300      	str	r3, [sp, #0]
 8018b7c:	8bbb      	ldrh	r3, [r7, #28]
 8018b7e:	68ba      	ldr	r2, [r7, #8]
 8018b80:	f7fd f8d2 	bl	8015d28 <lv_draw_px>
                       aa_opa);
            lv_draw_px(lb_origo.x + LV_CIRC_OCT4_X(aa_p) - 1, lb_origo.y + LV_CIRC_OCT4_Y(aa_p) + i, mask, aa_color_ver,
 8018b84:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 8018b88:	b29a      	uxth	r2, r3
 8018b8a:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8018b8e:	b29b      	uxth	r3, r3
 8018b90:	1ad3      	subs	r3, r2, r3
 8018b92:	b29b      	uxth	r3, r3
 8018b94:	3b01      	subs	r3, #1
 8018b96:	b29b      	uxth	r3, r3
 8018b98:	b218      	sxth	r0, r3
 8018b9a:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 8018b9e:	b29a      	uxth	r2, r3
 8018ba0:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8018ba4:	b29b      	uxth	r3, r3
 8018ba6:	4413      	add	r3, r2
 8018ba8:	b29a      	uxth	r2, r3
 8018baa:	f8b7 307a 	ldrh.w	r3, [r7, #122]	; 0x7a
 8018bae:	4413      	add	r3, r2
 8018bb0:	b29b      	uxth	r3, r3
 8018bb2:	b219      	sxth	r1, r3
 8018bb4:	f897 306a 	ldrb.w	r3, [r7, #106]	; 0x6a
 8018bb8:	9300      	str	r3, [sp, #0]
 8018bba:	8bbb      	ldrh	r3, [r7, #28]
 8018bbc:	68ba      	ldr	r2, [r7, #8]
 8018bbe:	f7fd f8b3 	bl	8015d28 <lv_draw_px>
                       aa_opa);

            aa_color_ver = lv_color_mix(gcolor, mcolor, mix);
 8018bc2:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8018bc6:	461a      	mov	r2, r3
 8018bc8:	f8b7 1064 	ldrh.w	r1, [r7, #100]	; 0x64
 8018bcc:	f8b7 0060 	ldrh.w	r0, [r7, #96]	; 0x60
 8018bd0:	f7fe feb6 	bl	8017940 <lv_color_mix>
 8018bd4:	4603      	mov	r3, r0
 8018bd6:	83bb      	strh	r3, [r7, #28]
            lv_draw_px(lt_origo.x + LV_CIRC_OCT5_X(aa_p) - 1, lt_origo.y + LV_CIRC_OCT5_Y(aa_p) - i, mask, aa_color_ver,
 8018bd8:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 8018bdc:	b29a      	uxth	r2, r3
 8018bde:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8018be2:	b29b      	uxth	r3, r3
 8018be4:	1ad3      	subs	r3, r2, r3
 8018be6:	b29b      	uxth	r3, r3
 8018be8:	3b01      	subs	r3, #1
 8018bea:	b29b      	uxth	r3, r3
 8018bec:	b218      	sxth	r0, r3
 8018bee:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8018bf2:	b29a      	uxth	r2, r3
 8018bf4:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8018bf8:	b29b      	uxth	r3, r3
 8018bfa:	1ad3      	subs	r3, r2, r3
 8018bfc:	b29a      	uxth	r2, r3
 8018bfe:	f8b7 307a 	ldrh.w	r3, [r7, #122]	; 0x7a
 8018c02:	1ad3      	subs	r3, r2, r3
 8018c04:	b29b      	uxth	r3, r3
 8018c06:	b219      	sxth	r1, r3
 8018c08:	f897 306a 	ldrb.w	r3, [r7, #106]	; 0x6a
 8018c0c:	9300      	str	r3, [sp, #0]
 8018c0e:	8bbb      	ldrh	r3, [r7, #28]
 8018c10:	68ba      	ldr	r2, [r7, #8]
 8018c12:	f7fd f889 	bl	8015d28 <lv_draw_px>
                       aa_opa);
            lv_draw_px(rt_origo.x + LV_CIRC_OCT8_X(aa_p) + 1, rt_origo.y + LV_CIRC_OCT8_Y(aa_p) - i, mask, aa_color_ver,
 8018c16:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 8018c1a:	b29a      	uxth	r2, r3
 8018c1c:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8018c20:	b29b      	uxth	r3, r3
 8018c22:	4413      	add	r3, r2
 8018c24:	b29b      	uxth	r3, r3
 8018c26:	3301      	adds	r3, #1
 8018c28:	b29b      	uxth	r3, r3
 8018c2a:	b218      	sxth	r0, r3
 8018c2c:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 8018c30:	b29a      	uxth	r2, r3
 8018c32:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8018c36:	b29b      	uxth	r3, r3
 8018c38:	1ad3      	subs	r3, r2, r3
 8018c3a:	b29a      	uxth	r2, r3
 8018c3c:	f8b7 307a 	ldrh.w	r3, [r7, #122]	; 0x7a
 8018c40:	1ad3      	subs	r3, r2, r3
 8018c42:	b29b      	uxth	r3, r3
 8018c44:	b219      	sxth	r1, r3
 8018c46:	f897 306a 	ldrb.w	r3, [r7, #106]	; 0x6a
 8018c4a:	9300      	str	r3, [sp, #0]
 8018c4c:	8bbb      	ldrh	r3, [r7, #28]
 8018c4e:	68ba      	ldr	r2, [r7, #8]
 8018c50:	f7fd f86a 	bl	8015d28 <lv_draw_px>
        for(i = 0; i < seg_size; i++) {
 8018c54:	f9b7 307a 	ldrsh.w	r3, [r7, #122]	; 0x7a
 8018c58:	b29b      	uxth	r3, r3
 8018c5a:	3301      	adds	r3, #1
 8018c5c:	b29b      	uxth	r3, r3
 8018c5e:	f8a7 307a 	strh.w	r3, [r7, #122]	; 0x7a
 8018c62:	f9b7 207a 	ldrsh.w	r2, [r7, #122]	; 0x7a
 8018c66:	f9b7 306c 	ldrsh.w	r3, [r7, #108]	; 0x6c
 8018c6a:	429a      	cmp	r2, r3
 8018c6c:	f6ff aec2 	blt.w	80189f4 <lv_draw_rect_main_corner+0xc90>
                       aa_opa);
        }

        /*In some cases the last pixel is not drawn*/
        if(LV_MATH_ABS(aa_p.x - aa_p.y) == seg_size) {
 8018c70:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8018c74:	461a      	mov	r2, r3
 8018c76:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8018c7a:	1ad3      	subs	r3, r2, r3
 8018c7c:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 8018c80:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
 8018c84:	f9b7 306c 	ldrsh.w	r3, [r7, #108]	; 0x6c
 8018c88:	429a      	cmp	r2, r3
 8018c8a:	f040 8090 	bne.w	8018dae <lv_draw_rect_main_corner+0x104a>
            aa_p.x = out_x_last;
 8018c8e:	f8b7 3084 	ldrh.w	r3, [r7, #132]	; 0x84
 8018c92:	82bb      	strh	r3, [r7, #20]
            aa_p.y = out_x_last;
 8018c94:	f8b7 3084 	ldrh.w	r3, [r7, #132]	; 0x84
 8018c98:	82fb      	strh	r3, [r7, #22]

            mix                 = (uint32_t)((uint32_t)(out_x_last)*255) / height;
 8018c9a:	f9b7 2084 	ldrsh.w	r2, [r7, #132]	; 0x84
 8018c9e:	4613      	mov	r3, r2
 8018ca0:	021b      	lsls	r3, r3, #8
 8018ca2:	1a9a      	subs	r2, r3, r2
 8018ca4:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 8018ca8:	fbb2 f3f3 	udiv	r3, r2, r3
 8018cac:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
            aa_color_hor_top    = lv_color_mix(gcolor, mcolor, mix);
 8018cb0:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8018cb4:	461a      	mov	r2, r3
 8018cb6:	f8b7 1064 	ldrh.w	r1, [r7, #100]	; 0x64
 8018cba:	f8b7 0060 	ldrh.w	r0, [r7, #96]	; 0x60
 8018cbe:	f7fe fe3f 	bl	8017940 <lv_color_mix>
 8018cc2:	4603      	mov	r3, r0
 8018cc4:	84bb      	strh	r3, [r7, #36]	; 0x24
            aa_color_hor_bottom = lv_color_mix(mcolor, gcolor, mix);
 8018cc6:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8018cca:	461a      	mov	r2, r3
 8018ccc:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 8018cd0:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 8018cd4:	f7fe fe34 	bl	8017940 <lv_color_mix>
 8018cd8:	4603      	mov	r3, r0
 8018cda:	843b      	strh	r3, [r7, #32]

            lv_opa_t aa_opa = opa >> 1;
 8018cdc:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 8018ce0:	085b      	lsrs	r3, r3, #1
 8018ce2:	f887 306b 	strb.w	r3, [r7, #107]	; 0x6b
            lv_draw_px(rb_origo.x + LV_CIRC_OCT2_X(aa_p), rb_origo.y + LV_CIRC_OCT2_Y(aa_p), mask, aa_color_hor_bottom,
 8018ce6:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 8018cea:	b29a      	uxth	r2, r3
 8018cec:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8018cf0:	b29b      	uxth	r3, r3
 8018cf2:	4413      	add	r3, r2
 8018cf4:	b29b      	uxth	r3, r3
 8018cf6:	b218      	sxth	r0, r3
 8018cf8:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 8018cfc:	b29a      	uxth	r2, r3
 8018cfe:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8018d02:	b29b      	uxth	r3, r3
 8018d04:	4413      	add	r3, r2
 8018d06:	b29b      	uxth	r3, r3
 8018d08:	b219      	sxth	r1, r3
 8018d0a:	f897 306b 	ldrb.w	r3, [r7, #107]	; 0x6b
 8018d0e:	9300      	str	r3, [sp, #0]
 8018d10:	8c3b      	ldrh	r3, [r7, #32]
 8018d12:	68ba      	ldr	r2, [r7, #8]
 8018d14:	f7fd f808 	bl	8015d28 <lv_draw_px>
                       aa_opa);
            lv_draw_px(lb_origo.x + LV_CIRC_OCT4_X(aa_p), lb_origo.y + LV_CIRC_OCT4_Y(aa_p), mask, aa_color_hor_bottom,
 8018d18:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 8018d1c:	b29a      	uxth	r2, r3
 8018d1e:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8018d22:	b29b      	uxth	r3, r3
 8018d24:	1ad3      	subs	r3, r2, r3
 8018d26:	b29b      	uxth	r3, r3
 8018d28:	b218      	sxth	r0, r3
 8018d2a:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 8018d2e:	b29a      	uxth	r2, r3
 8018d30:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8018d34:	b29b      	uxth	r3, r3
 8018d36:	4413      	add	r3, r2
 8018d38:	b29b      	uxth	r3, r3
 8018d3a:	b219      	sxth	r1, r3
 8018d3c:	f897 306b 	ldrb.w	r3, [r7, #107]	; 0x6b
 8018d40:	9300      	str	r3, [sp, #0]
 8018d42:	8c3b      	ldrh	r3, [r7, #32]
 8018d44:	68ba      	ldr	r2, [r7, #8]
 8018d46:	f7fc ffef 	bl	8015d28 <lv_draw_px>
                       aa_opa);
            lv_draw_px(lt_origo.x + LV_CIRC_OCT6_X(aa_p), lt_origo.y + LV_CIRC_OCT6_Y(aa_p), mask, aa_color_hor_top,
 8018d4a:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 8018d4e:	b29a      	uxth	r2, r3
 8018d50:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8018d54:	b29b      	uxth	r3, r3
 8018d56:	1ad3      	subs	r3, r2, r3
 8018d58:	b29b      	uxth	r3, r3
 8018d5a:	b218      	sxth	r0, r3
 8018d5c:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8018d60:	b29a      	uxth	r2, r3
 8018d62:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8018d66:	b29b      	uxth	r3, r3
 8018d68:	1ad3      	subs	r3, r2, r3
 8018d6a:	b29b      	uxth	r3, r3
 8018d6c:	b219      	sxth	r1, r3
 8018d6e:	f897 306b 	ldrb.w	r3, [r7, #107]	; 0x6b
 8018d72:	9300      	str	r3, [sp, #0]
 8018d74:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8018d76:	68ba      	ldr	r2, [r7, #8]
 8018d78:	f7fc ffd6 	bl	8015d28 <lv_draw_px>
                       aa_opa);
            lv_draw_px(rt_origo.x + LV_CIRC_OCT8_X(aa_p), rt_origo.y + LV_CIRC_OCT8_Y(aa_p), mask, aa_color_hor_top,
 8018d7c:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 8018d80:	b29a      	uxth	r2, r3
 8018d82:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8018d86:	b29b      	uxth	r3, r3
 8018d88:	4413      	add	r3, r2
 8018d8a:	b29b      	uxth	r3, r3
 8018d8c:	b218      	sxth	r0, r3
 8018d8e:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 8018d92:	b29a      	uxth	r2, r3
 8018d94:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8018d98:	b29b      	uxth	r3, r3
 8018d9a:	1ad3      	subs	r3, r2, r3
 8018d9c:	b29b      	uxth	r3, r3
 8018d9e:	b219      	sxth	r1, r3
 8018da0:	f897 306b 	ldrb.w	r3, [r7, #107]	; 0x6b
 8018da4:	9300      	str	r3, [sp, #0]
 8018da6:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8018da8:	68ba      	ldr	r2, [r7, #8]
 8018daa:	f7fc ffbd 	bl	8015d28 <lv_draw_px>
                       aa_opa);
        }
    }
#endif
}
 8018dae:	bf00      	nop
 8018db0:	3788      	adds	r7, #136	; 0x88
 8018db2:	46bd      	mov	sp, r7
 8018db4:	bdb0      	pop	{r4, r5, r7, pc}

08018db6 <lv_draw_rect_border_straight>:
 * @param rstyle pointer to a rectangle style
 * @param opa_scale scale down all opacities by the factor
 */
static void lv_draw_rect_border_straight(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style,
                                         lv_opa_t opa_scale)
{
 8018db6:	b580      	push	{r7, lr}
 8018db8:	b08c      	sub	sp, #48	; 0x30
 8018dba:	af00      	add	r7, sp, #0
 8018dbc:	60f8      	str	r0, [r7, #12]
 8018dbe:	60b9      	str	r1, [r7, #8]
 8018dc0:	607a      	str	r2, [r7, #4]
 8018dc2:	70fb      	strb	r3, [r7, #3]
    uint16_t radius = style->body.radius;
 8018dc4:	687b      	ldr	r3, [r7, #4]
 8018dc6:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8018dca:	857b      	strh	r3, [r7, #42]	; 0x2a
    bool aa         = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
 8018dcc:	f7fb fb62 	bl	8014494 <lv_refr_get_disp_refreshing>
 8018dd0:	4603      	mov	r3, r0
 8018dd2:	4618      	mov	r0, r3
 8018dd4:	f004 f9e1 	bl	801d19a <lv_disp_get_antialiasing>
 8018dd8:	4603      	mov	r3, r0
 8018dda:	f887 3029 	strb.w	r3, [r7, #41]	; 0x29

    lv_coord_t width  = lv_area_get_width(coords);
 8018dde:	68f8      	ldr	r0, [r7, #12]
 8018de0:	f7fe fe2d 	bl	8017a3e <lv_area_get_width>
 8018de4:	4603      	mov	r3, r0
 8018de6:	84fb      	strh	r3, [r7, #38]	; 0x26
    lv_coord_t height = lv_area_get_height(coords);
 8018de8:	68f8      	ldr	r0, [r7, #12]
 8018dea:	f7fe fe3f 	bl	8017a6c <lv_area_get_height>
 8018dee:	4603      	mov	r3, r0
 8018df0:	84bb      	strh	r3, [r7, #36]	; 0x24
    lv_coord_t bwidth = style->body.border.width;
 8018df2:	687b      	ldr	r3, [r7, #4]
 8018df4:	899b      	ldrh	r3, [r3, #12]
 8018df6:	847b      	strh	r3, [r7, #34]	; 0x22
    lv_opa_t opa      = opa_scale == LV_OPA_COVER ? style->body.border.opa
 8018df8:	78fb      	ldrb	r3, [r7, #3]
 8018dfa:	2bff      	cmp	r3, #255	; 0xff
 8018dfc:	d102      	bne.n	8018e04 <lv_draw_rect_border_straight+0x4e>
 8018dfe:	687b      	ldr	r3, [r7, #4]
 8018e00:	7bdb      	ldrb	r3, [r3, #15]
 8018e02:	e00a      	b.n	8018e1a <lv_draw_rect_border_straight+0x64>
                                             : (uint16_t)((uint16_t)style->body.border.opa * opa_scale) >> 8;
 8018e04:	687b      	ldr	r3, [r7, #4]
 8018e06:	7bdb      	ldrb	r3, [r3, #15]
 8018e08:	b29a      	uxth	r2, r3
 8018e0a:	78fb      	ldrb	r3, [r7, #3]
 8018e0c:	b29b      	uxth	r3, r3
 8018e0e:	fb12 f303 	smulbb	r3, r2, r3
 8018e12:	b29b      	uxth	r3, r3
    lv_opa_t opa      = opa_scale == LV_OPA_COVER ? style->body.border.opa
 8018e14:	0a1b      	lsrs	r3, r3, #8
 8018e16:	b29b      	uxth	r3, r3
 8018e18:	b2db      	uxtb	r3, r3
 8018e1a:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
    lv_border_part_t part = style->body.border.part;
 8018e1e:	687b      	ldr	r3, [r7, #4]
 8018e20:	7b9b      	ldrb	r3, [r3, #14]
 8018e22:	f887 3020 	strb.w	r3, [r7, #32]
    lv_color_t color      = style->body.border.color;
 8018e26:	687b      	ldr	r3, [r7, #4]
 8018e28:	895b      	ldrh	r3, [r3, #10]
 8018e2a:	83bb      	strh	r3, [r7, #28]
    lv_area_t work_area;
    lv_coord_t length_corr = 0;
 8018e2c:	2300      	movs	r3, #0
 8018e2e:	85fb      	strh	r3, [r7, #46]	; 0x2e
    lv_coord_t corner_size = 0;
 8018e30:	2300      	movs	r3, #0
 8018e32:	85bb      	strh	r3, [r7, #44]	; 0x2c

    /*the 0 px border width drawn as 1 px, so decrement the b_width*/
    bwidth--;
 8018e34:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8018e38:	b29b      	uxth	r3, r3
 8018e3a:	3b01      	subs	r3, #1
 8018e3c:	b29b      	uxth	r3, r3
 8018e3e:	847b      	strh	r3, [r7, #34]	; 0x22

    radius = lv_draw_cont_radius_corr(radius, width, height);
 8018e40:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
 8018e44:	f9b7 1026 	ldrsh.w	r1, [r7, #38]	; 0x26
 8018e48:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8018e4a:	4618      	mov	r0, r3
 8018e4c:	f002 fca2 	bl	801b794 <lv_draw_cont_radius_corr>
 8018e50:	4603      	mov	r3, r0
 8018e52:	857b      	strh	r3, [r7, #42]	; 0x2a

    if(radius < bwidth) {
 8018e54:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
 8018e56:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8018e5a:	429a      	cmp	r2, r3
 8018e5c:	da0c      	bge.n	8018e78 <lv_draw_rect_border_straight+0xc2>
        length_corr = bwidth - radius - aa;
 8018e5e:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
 8018e60:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8018e62:	1ad3      	subs	r3, r2, r3
 8018e64:	b29a      	uxth	r2, r3
 8018e66:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8018e6a:	b29b      	uxth	r3, r3
 8018e6c:	1ad3      	subs	r3, r2, r3
 8018e6e:	b29b      	uxth	r3, r3
 8018e70:	85fb      	strh	r3, [r7, #46]	; 0x2e
        corner_size = bwidth;
 8018e72:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8018e74:	85bb      	strh	r3, [r7, #44]	; 0x2c
 8018e76:	e006      	b.n	8018e86 <lv_draw_rect_border_straight+0xd0>
    } else {
        corner_size = radius + aa;
 8018e78:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8018e7c:	b29a      	uxth	r2, r3
 8018e7e:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8018e80:	4413      	add	r3, r2
 8018e82:	b29b      	uxth	r3, r3
 8018e84:	85bb      	strh	r3, [r7, #44]	; 0x2c
    }

    /*If radius == 0 is a special case*/
    if(style->body.radius == 0) {
 8018e86:	687b      	ldr	r3, [r7, #4]
 8018e88:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8018e8c:	2b00      	cmp	r3, #0
 8018e8e:	f040 80ca 	bne.w	8019026 <lv_draw_rect_border_straight+0x270>
        /*Left top corner*/
        if(part & LV_BORDER_TOP) {
 8018e92:	f897 3020 	ldrb.w	r3, [r7, #32]
 8018e96:	f003 0302 	and.w	r3, r3, #2
 8018e9a:	2b00      	cmp	r3, #0
 8018e9c:	d01c      	beq.n	8018ed8 <lv_draw_rect_border_straight+0x122>
            work_area.x1 = coords->x1;
 8018e9e:	68fb      	ldr	r3, [r7, #12]
 8018ea0:	f9b3 3000 	ldrsh.w	r3, [r3]
 8018ea4:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x2;
 8018ea6:	68fb      	ldr	r3, [r7, #12]
 8018ea8:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8018eac:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y1;
 8018eae:	68fb      	ldr	r3, [r7, #12]
 8018eb0:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8018eb4:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y1 + bwidth;
 8018eb6:	68fb      	ldr	r3, [r7, #12]
 8018eb8:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8018ebc:	b29a      	uxth	r2, r3
 8018ebe:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8018ec0:	4413      	add	r3, r2
 8018ec2:	b29b      	uxth	r3, r3
 8018ec4:	b21b      	sxth	r3, r3
 8018ec6:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 8018ec8:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8018ecc:	f107 0014 	add.w	r0, r7, #20
 8018ed0:	8bba      	ldrh	r2, [r7, #28]
 8018ed2:	68b9      	ldr	r1, [r7, #8]
 8018ed4:	f7fc ffc0 	bl	8015e58 <lv_draw_fill>
        }

        /*Right top corner*/
        if(part & LV_BORDER_RIGHT) {
 8018ed8:	f897 3020 	ldrb.w	r3, [r7, #32]
 8018edc:	f003 0308 	and.w	r3, r3, #8
 8018ee0:	2b00      	cmp	r3, #0
 8018ee2:	d03a      	beq.n	8018f5a <lv_draw_rect_border_straight+0x1a4>
            work_area.x1 = coords->x2 - bwidth;
 8018ee4:	68fb      	ldr	r3, [r7, #12]
 8018ee6:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8018eea:	b29a      	uxth	r2, r3
 8018eec:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8018eee:	1ad3      	subs	r3, r2, r3
 8018ef0:	b29b      	uxth	r3, r3
 8018ef2:	b21b      	sxth	r3, r3
 8018ef4:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x2;
 8018ef6:	68fb      	ldr	r3, [r7, #12]
 8018ef8:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8018efc:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y1 + (part & LV_BORDER_TOP ? bwidth + 1 : 0);
 8018efe:	68fb      	ldr	r3, [r7, #12]
 8018f00:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8018f04:	b29a      	uxth	r2, r3
 8018f06:	f897 3020 	ldrb.w	r3, [r7, #32]
 8018f0a:	f003 0302 	and.w	r3, r3, #2
 8018f0e:	2b00      	cmp	r3, #0
 8018f10:	d003      	beq.n	8018f1a <lv_draw_rect_border_straight+0x164>
 8018f12:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8018f14:	3301      	adds	r3, #1
 8018f16:	b29b      	uxth	r3, r3
 8018f18:	e000      	b.n	8018f1c <lv_draw_rect_border_straight+0x166>
 8018f1a:	2300      	movs	r3, #0
 8018f1c:	4413      	add	r3, r2
 8018f1e:	b29b      	uxth	r3, r3
 8018f20:	b21b      	sxth	r3, r3
 8018f22:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y2 - (part & LV_BORDER_BOTTOM ? bwidth + 1 : 0);
 8018f24:	68fb      	ldr	r3, [r7, #12]
 8018f26:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8018f2a:	b29a      	uxth	r2, r3
 8018f2c:	f897 3020 	ldrb.w	r3, [r7, #32]
 8018f30:	f003 0301 	and.w	r3, r3, #1
 8018f34:	2b00      	cmp	r3, #0
 8018f36:	d003      	beq.n	8018f40 <lv_draw_rect_border_straight+0x18a>
 8018f38:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8018f3a:	3301      	adds	r3, #1
 8018f3c:	b29b      	uxth	r3, r3
 8018f3e:	e000      	b.n	8018f42 <lv_draw_rect_border_straight+0x18c>
 8018f40:	2300      	movs	r3, #0
 8018f42:	1ad3      	subs	r3, r2, r3
 8018f44:	b29b      	uxth	r3, r3
 8018f46:	b21b      	sxth	r3, r3
 8018f48:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 8018f4a:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8018f4e:	f107 0014 	add.w	r0, r7, #20
 8018f52:	8bba      	ldrh	r2, [r7, #28]
 8018f54:	68b9      	ldr	r1, [r7, #8]
 8018f56:	f7fc ff7f 	bl	8015e58 <lv_draw_fill>
        }

        /*Left bottom corner*/
        if(part & LV_BORDER_LEFT) {
 8018f5a:	f897 3020 	ldrb.w	r3, [r7, #32]
 8018f5e:	f003 0304 	and.w	r3, r3, #4
 8018f62:	2b00      	cmp	r3, #0
 8018f64:	d03a      	beq.n	8018fdc <lv_draw_rect_border_straight+0x226>
            work_area.x1 = coords->x1;
 8018f66:	68fb      	ldr	r3, [r7, #12]
 8018f68:	f9b3 3000 	ldrsh.w	r3, [r3]
 8018f6c:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x1 + bwidth;
 8018f6e:	68fb      	ldr	r3, [r7, #12]
 8018f70:	f9b3 3000 	ldrsh.w	r3, [r3]
 8018f74:	b29a      	uxth	r2, r3
 8018f76:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8018f78:	4413      	add	r3, r2
 8018f7a:	b29b      	uxth	r3, r3
 8018f7c:	b21b      	sxth	r3, r3
 8018f7e:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y1 + (part & LV_BORDER_TOP ? bwidth + 1 : 0);
 8018f80:	68fb      	ldr	r3, [r7, #12]
 8018f82:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8018f86:	b29a      	uxth	r2, r3
 8018f88:	f897 3020 	ldrb.w	r3, [r7, #32]
 8018f8c:	f003 0302 	and.w	r3, r3, #2
 8018f90:	2b00      	cmp	r3, #0
 8018f92:	d003      	beq.n	8018f9c <lv_draw_rect_border_straight+0x1e6>
 8018f94:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8018f96:	3301      	adds	r3, #1
 8018f98:	b29b      	uxth	r3, r3
 8018f9a:	e000      	b.n	8018f9e <lv_draw_rect_border_straight+0x1e8>
 8018f9c:	2300      	movs	r3, #0
 8018f9e:	4413      	add	r3, r2
 8018fa0:	b29b      	uxth	r3, r3
 8018fa2:	b21b      	sxth	r3, r3
 8018fa4:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y2 - (part & LV_BORDER_BOTTOM ? bwidth + 1 : 0);
 8018fa6:	68fb      	ldr	r3, [r7, #12]
 8018fa8:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8018fac:	b29a      	uxth	r2, r3
 8018fae:	f897 3020 	ldrb.w	r3, [r7, #32]
 8018fb2:	f003 0301 	and.w	r3, r3, #1
 8018fb6:	2b00      	cmp	r3, #0
 8018fb8:	d003      	beq.n	8018fc2 <lv_draw_rect_border_straight+0x20c>
 8018fba:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8018fbc:	3301      	adds	r3, #1
 8018fbe:	b29b      	uxth	r3, r3
 8018fc0:	e000      	b.n	8018fc4 <lv_draw_rect_border_straight+0x20e>
 8018fc2:	2300      	movs	r3, #0
 8018fc4:	1ad3      	subs	r3, r2, r3
 8018fc6:	b29b      	uxth	r3, r3
 8018fc8:	b21b      	sxth	r3, r3
 8018fca:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 8018fcc:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8018fd0:	f107 0014 	add.w	r0, r7, #20
 8018fd4:	8bba      	ldrh	r2, [r7, #28]
 8018fd6:	68b9      	ldr	r1, [r7, #8]
 8018fd8:	f7fc ff3e 	bl	8015e58 <lv_draw_fill>
        }

        /*Right bottom corner*/
        if(part & LV_BORDER_BOTTOM) {
 8018fdc:	f897 3020 	ldrb.w	r3, [r7, #32]
 8018fe0:	f003 0301 	and.w	r3, r3, #1
 8018fe4:	2b00      	cmp	r3, #0
 8018fe6:	f000 828f 	beq.w	8019508 <lv_draw_rect_border_straight+0x752>
            work_area.x1 = coords->x1;
 8018fea:	68fb      	ldr	r3, [r7, #12]
 8018fec:	f9b3 3000 	ldrsh.w	r3, [r3]
 8018ff0:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x2;
 8018ff2:	68fb      	ldr	r3, [r7, #12]
 8018ff4:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8018ff8:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y2 - bwidth;
 8018ffa:	68fb      	ldr	r3, [r7, #12]
 8018ffc:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8019000:	b29a      	uxth	r2, r3
 8019002:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8019004:	1ad3      	subs	r3, r2, r3
 8019006:	b29b      	uxth	r3, r3
 8019008:	b21b      	sxth	r3, r3
 801900a:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y2;
 801900c:	68fb      	ldr	r3, [r7, #12]
 801900e:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8019012:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 8019014:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8019018:	f107 0014 	add.w	r0, r7, #20
 801901c:	8bba      	ldrh	r2, [r7, #28]
 801901e:	68b9      	ldr	r1, [r7, #8]
 8019020:	f7fc ff1a 	bl	8015e58 <lv_draw_fill>
 8019024:	e271      	b.n	801950a <lv_draw_rect_border_straight+0x754>
        }
        return;
    }

    /* Modify the corner_size if corner is drawn */
    corner_size++;
 8019026:	f9b7 302c 	ldrsh.w	r3, [r7, #44]	; 0x2c
 801902a:	b29b      	uxth	r3, r3
 801902c:	3301      	adds	r3, #1
 801902e:	b29b      	uxth	r3, r3
 8019030:	85bb      	strh	r3, [r7, #44]	; 0x2c

    /*Depending one which part's are drawn modify the area lengths */
    if(part & LV_BORDER_TOP)
 8019032:	f897 3020 	ldrb.w	r3, [r7, #32]
 8019036:	f003 0302 	and.w	r3, r3, #2
 801903a:	2b00      	cmp	r3, #0
 801903c:	d009      	beq.n	8019052 <lv_draw_rect_border_straight+0x29c>
        work_area.y1 = coords->y1 + corner_size;
 801903e:	68fb      	ldr	r3, [r7, #12]
 8019040:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8019044:	b29a      	uxth	r2, r3
 8019046:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 8019048:	4413      	add	r3, r2
 801904a:	b29b      	uxth	r3, r3
 801904c:	b21b      	sxth	r3, r3
 801904e:	82fb      	strh	r3, [r7, #22]
 8019050:	e008      	b.n	8019064 <lv_draw_rect_border_straight+0x2ae>
    else
        work_area.y1 = coords->y1 + radius;
 8019052:	68fb      	ldr	r3, [r7, #12]
 8019054:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8019058:	b29a      	uxth	r2, r3
 801905a:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 801905c:	4413      	add	r3, r2
 801905e:	b29b      	uxth	r3, r3
 8019060:	b21b      	sxth	r3, r3
 8019062:	82fb      	strh	r3, [r7, #22]

    if(part & LV_BORDER_BOTTOM)
 8019064:	f897 3020 	ldrb.w	r3, [r7, #32]
 8019068:	f003 0301 	and.w	r3, r3, #1
 801906c:	2b00      	cmp	r3, #0
 801906e:	d009      	beq.n	8019084 <lv_draw_rect_border_straight+0x2ce>
        work_area.y2 = coords->y2 - corner_size;
 8019070:	68fb      	ldr	r3, [r7, #12]
 8019072:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8019076:	b29a      	uxth	r2, r3
 8019078:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 801907a:	1ad3      	subs	r3, r2, r3
 801907c:	b29b      	uxth	r3, r3
 801907e:	b21b      	sxth	r3, r3
 8019080:	837b      	strh	r3, [r7, #26]
 8019082:	e008      	b.n	8019096 <lv_draw_rect_border_straight+0x2e0>
    else
        work_area.y2 = coords->y2 - radius;
 8019084:	68fb      	ldr	r3, [r7, #12]
 8019086:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801908a:	b29a      	uxth	r2, r3
 801908c:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 801908e:	1ad3      	subs	r3, r2, r3
 8019090:	b29b      	uxth	r3, r3
 8019092:	b21b      	sxth	r3, r3
 8019094:	837b      	strh	r3, [r7, #26]

    /*Left border*/
    if(part & LV_BORDER_LEFT) {
 8019096:	f897 3020 	ldrb.w	r3, [r7, #32]
 801909a:	f003 0304 	and.w	r3, r3, #4
 801909e:	2b00      	cmp	r3, #0
 80190a0:	d013      	beq.n	80190ca <lv_draw_rect_border_straight+0x314>
        work_area.x1 = coords->x1;
 80190a2:	68fb      	ldr	r3, [r7, #12]
 80190a4:	f9b3 3000 	ldrsh.w	r3, [r3]
 80190a8:	82bb      	strh	r3, [r7, #20]
        work_area.x2 = work_area.x1 + bwidth;
 80190aa:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 80190ae:	b29a      	uxth	r2, r3
 80190b0:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 80190b2:	4413      	add	r3, r2
 80190b4:	b29b      	uxth	r3, r3
 80190b6:	b21b      	sxth	r3, r3
 80190b8:	833b      	strh	r3, [r7, #24]
        lv_draw_fill(&work_area, mask, color, opa);
 80190ba:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 80190be:	f107 0014 	add.w	r0, r7, #20
 80190c2:	8bba      	ldrh	r2, [r7, #28]
 80190c4:	68b9      	ldr	r1, [r7, #8]
 80190c6:	f7fc fec7 	bl	8015e58 <lv_draw_fill>
    }

    /*Right border*/
    if(part & LV_BORDER_RIGHT) {
 80190ca:	f897 3020 	ldrb.w	r3, [r7, #32]
 80190ce:	f003 0308 	and.w	r3, r3, #8
 80190d2:	2b00      	cmp	r3, #0
 80190d4:	d013      	beq.n	80190fe <lv_draw_rect_border_straight+0x348>
        work_area.x2 = coords->x2;
 80190d6:	68fb      	ldr	r3, [r7, #12]
 80190d8:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80190dc:	833b      	strh	r3, [r7, #24]
        work_area.x1 = work_area.x2 - bwidth;
 80190de:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 80190e2:	b29a      	uxth	r2, r3
 80190e4:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 80190e6:	1ad3      	subs	r3, r2, r3
 80190e8:	b29b      	uxth	r3, r3
 80190ea:	b21b      	sxth	r3, r3
 80190ec:	82bb      	strh	r3, [r7, #20]
        lv_draw_fill(&work_area, mask, color, opa);
 80190ee:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 80190f2:	f107 0014 	add.w	r0, r7, #20
 80190f6:	8bba      	ldrh	r2, [r7, #28]
 80190f8:	68b9      	ldr	r1, [r7, #8]
 80190fa:	f7fc fead 	bl	8015e58 <lv_draw_fill>
    }

    work_area.x1 = coords->x1 + corner_size - length_corr;
 80190fe:	68fb      	ldr	r3, [r7, #12]
 8019100:	f9b3 3000 	ldrsh.w	r3, [r3]
 8019104:	b29a      	uxth	r2, r3
 8019106:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 8019108:	4413      	add	r3, r2
 801910a:	b29a      	uxth	r2, r3
 801910c:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 801910e:	1ad3      	subs	r3, r2, r3
 8019110:	b29b      	uxth	r3, r3
 8019112:	b21b      	sxth	r3, r3
 8019114:	82bb      	strh	r3, [r7, #20]
    work_area.x2 = coords->x2 - corner_size + length_corr;
 8019116:	68fb      	ldr	r3, [r7, #12]
 8019118:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801911c:	b29a      	uxth	r2, r3
 801911e:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 8019120:	1ad3      	subs	r3, r2, r3
 8019122:	b29a      	uxth	r2, r3
 8019124:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8019126:	4413      	add	r3, r2
 8019128:	b29b      	uxth	r3, r3
 801912a:	b21b      	sxth	r3, r3
 801912c:	833b      	strh	r3, [r7, #24]

    /*Upper border*/
    if(part & LV_BORDER_TOP) {
 801912e:	f897 3020 	ldrb.w	r3, [r7, #32]
 8019132:	f003 0302 	and.w	r3, r3, #2
 8019136:	2b00      	cmp	r3, #0
 8019138:	d014      	beq.n	8019164 <lv_draw_rect_border_straight+0x3ae>
        work_area.y1 = coords->y1;
 801913a:	68fb      	ldr	r3, [r7, #12]
 801913c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8019140:	82fb      	strh	r3, [r7, #22]
        work_area.y2 = coords->y1 + bwidth;
 8019142:	68fb      	ldr	r3, [r7, #12]
 8019144:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8019148:	b29a      	uxth	r2, r3
 801914a:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 801914c:	4413      	add	r3, r2
 801914e:	b29b      	uxth	r3, r3
 8019150:	b21b      	sxth	r3, r3
 8019152:	837b      	strh	r3, [r7, #26]
        lv_draw_fill(&work_area, mask, color, opa);
 8019154:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8019158:	f107 0014 	add.w	r0, r7, #20
 801915c:	8bba      	ldrh	r2, [r7, #28]
 801915e:	68b9      	ldr	r1, [r7, #8]
 8019160:	f7fc fe7a 	bl	8015e58 <lv_draw_fill>
    }

    /*Lower border*/
    if(part & LV_BORDER_BOTTOM) {
 8019164:	f897 3020 	ldrb.w	r3, [r7, #32]
 8019168:	f003 0301 	and.w	r3, r3, #1
 801916c:	2b00      	cmp	r3, #0
 801916e:	d013      	beq.n	8019198 <lv_draw_rect_border_straight+0x3e2>
        work_area.y2 = coords->y2;
 8019170:	68fb      	ldr	r3, [r7, #12]
 8019172:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8019176:	837b      	strh	r3, [r7, #26]
        work_area.y1 = work_area.y2 - bwidth;
 8019178:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 801917c:	b29a      	uxth	r2, r3
 801917e:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8019180:	1ad3      	subs	r3, r2, r3
 8019182:	b29b      	uxth	r3, r3
 8019184:	b21b      	sxth	r3, r3
 8019186:	82fb      	strh	r3, [r7, #22]
        lv_draw_fill(&work_area, mask, color, opa);
 8019188:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 801918c:	f107 0014 	add.w	r0, r7, #20
 8019190:	8bba      	ldrh	r2, [r7, #28]
 8019192:	68b9      	ldr	r1, [r7, #8]
 8019194:	f7fc fe60 	bl	8015e58 <lv_draw_fill>
    }

    /*Draw the a remaining rectangles if the radius is smaller then bwidth */
    if(length_corr != 0) {
 8019198:	f9b7 302e 	ldrsh.w	r3, [r7, #46]	; 0x2e
 801919c:	2b00      	cmp	r3, #0
 801919e:	f000 80fc 	beq.w	801939a <lv_draw_rect_border_straight+0x5e4>
        /*Left top correction*/
        if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
 80191a2:	f897 3020 	ldrb.w	r3, [r7, #32]
 80191a6:	f003 0302 	and.w	r3, r3, #2
 80191aa:	2b00      	cmp	r3, #0
 80191ac:	d038      	beq.n	8019220 <lv_draw_rect_border_straight+0x46a>
 80191ae:	f897 3020 	ldrb.w	r3, [r7, #32]
 80191b2:	f003 0304 	and.w	r3, r3, #4
 80191b6:	2b00      	cmp	r3, #0
 80191b8:	d032      	beq.n	8019220 <lv_draw_rect_border_straight+0x46a>
            work_area.x1 = coords->x1;
 80191ba:	68fb      	ldr	r3, [r7, #12]
 80191bc:	f9b3 3000 	ldrsh.w	r3, [r3]
 80191c0:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x1 + radius + aa;
 80191c2:	68fb      	ldr	r3, [r7, #12]
 80191c4:	f9b3 3000 	ldrsh.w	r3, [r3]
 80191c8:	b29a      	uxth	r2, r3
 80191ca:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 80191cc:	4413      	add	r3, r2
 80191ce:	b29a      	uxth	r2, r3
 80191d0:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 80191d4:	b29b      	uxth	r3, r3
 80191d6:	4413      	add	r3, r2
 80191d8:	b29b      	uxth	r3, r3
 80191da:	b21b      	sxth	r3, r3
 80191dc:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y1 + radius + 1 + aa;
 80191de:	68fb      	ldr	r3, [r7, #12]
 80191e0:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80191e4:	b29a      	uxth	r2, r3
 80191e6:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 80191e8:	4413      	add	r3, r2
 80191ea:	b29a      	uxth	r2, r3
 80191ec:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 80191f0:	b29b      	uxth	r3, r3
 80191f2:	4413      	add	r3, r2
 80191f4:	b29b      	uxth	r3, r3
 80191f6:	3301      	adds	r3, #1
 80191f8:	b29b      	uxth	r3, r3
 80191fa:	b21b      	sxth	r3, r3
 80191fc:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y1 + bwidth;
 80191fe:	68fb      	ldr	r3, [r7, #12]
 8019200:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8019204:	b29a      	uxth	r2, r3
 8019206:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8019208:	4413      	add	r3, r2
 801920a:	b29b      	uxth	r3, r3
 801920c:	b21b      	sxth	r3, r3
 801920e:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 8019210:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8019214:	f107 0014 	add.w	r0, r7, #20
 8019218:	8bba      	ldrh	r2, [r7, #28]
 801921a:	68b9      	ldr	r1, [r7, #8]
 801921c:	f7fc fe1c 	bl	8015e58 <lv_draw_fill>
        }

        /*Right top correction*/
        if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
 8019220:	f897 3020 	ldrb.w	r3, [r7, #32]
 8019224:	f003 0302 	and.w	r3, r3, #2
 8019228:	2b00      	cmp	r3, #0
 801922a:	d038      	beq.n	801929e <lv_draw_rect_border_straight+0x4e8>
 801922c:	f897 3020 	ldrb.w	r3, [r7, #32]
 8019230:	f003 0308 	and.w	r3, r3, #8
 8019234:	2b00      	cmp	r3, #0
 8019236:	d032      	beq.n	801929e <lv_draw_rect_border_straight+0x4e8>
            work_area.x1 = coords->x2 - radius - aa;
 8019238:	68fb      	ldr	r3, [r7, #12]
 801923a:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801923e:	b29a      	uxth	r2, r3
 8019240:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8019242:	1ad3      	subs	r3, r2, r3
 8019244:	b29a      	uxth	r2, r3
 8019246:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 801924a:	b29b      	uxth	r3, r3
 801924c:	1ad3      	subs	r3, r2, r3
 801924e:	b29b      	uxth	r3, r3
 8019250:	b21b      	sxth	r3, r3
 8019252:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x2;
 8019254:	68fb      	ldr	r3, [r7, #12]
 8019256:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801925a:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y1 + radius + 1 + aa;
 801925c:	68fb      	ldr	r3, [r7, #12]
 801925e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8019262:	b29a      	uxth	r2, r3
 8019264:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8019266:	4413      	add	r3, r2
 8019268:	b29a      	uxth	r2, r3
 801926a:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 801926e:	b29b      	uxth	r3, r3
 8019270:	4413      	add	r3, r2
 8019272:	b29b      	uxth	r3, r3
 8019274:	3301      	adds	r3, #1
 8019276:	b29b      	uxth	r3, r3
 8019278:	b21b      	sxth	r3, r3
 801927a:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y1 + bwidth;
 801927c:	68fb      	ldr	r3, [r7, #12]
 801927e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8019282:	b29a      	uxth	r2, r3
 8019284:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8019286:	4413      	add	r3, r2
 8019288:	b29b      	uxth	r3, r3
 801928a:	b21b      	sxth	r3, r3
 801928c:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 801928e:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8019292:	f107 0014 	add.w	r0, r7, #20
 8019296:	8bba      	ldrh	r2, [r7, #28]
 8019298:	68b9      	ldr	r1, [r7, #8]
 801929a:	f7fc fddd 	bl	8015e58 <lv_draw_fill>
        }

        /*Left bottom correction*/
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
 801929e:	f897 3020 	ldrb.w	r3, [r7, #32]
 80192a2:	f003 0301 	and.w	r3, r3, #1
 80192a6:	2b00      	cmp	r3, #0
 80192a8:	d038      	beq.n	801931c <lv_draw_rect_border_straight+0x566>
 80192aa:	f897 3020 	ldrb.w	r3, [r7, #32]
 80192ae:	f003 0304 	and.w	r3, r3, #4
 80192b2:	2b00      	cmp	r3, #0
 80192b4:	d032      	beq.n	801931c <lv_draw_rect_border_straight+0x566>
            work_area.x1 = coords->x1;
 80192b6:	68fb      	ldr	r3, [r7, #12]
 80192b8:	f9b3 3000 	ldrsh.w	r3, [r3]
 80192bc:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x1 + radius + aa;
 80192be:	68fb      	ldr	r3, [r7, #12]
 80192c0:	f9b3 3000 	ldrsh.w	r3, [r3]
 80192c4:	b29a      	uxth	r2, r3
 80192c6:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 80192c8:	4413      	add	r3, r2
 80192ca:	b29a      	uxth	r2, r3
 80192cc:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 80192d0:	b29b      	uxth	r3, r3
 80192d2:	4413      	add	r3, r2
 80192d4:	b29b      	uxth	r3, r3
 80192d6:	b21b      	sxth	r3, r3
 80192d8:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y2 - bwidth;
 80192da:	68fb      	ldr	r3, [r7, #12]
 80192dc:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80192e0:	b29a      	uxth	r2, r3
 80192e2:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 80192e4:	1ad3      	subs	r3, r2, r3
 80192e6:	b29b      	uxth	r3, r3
 80192e8:	b21b      	sxth	r3, r3
 80192ea:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y2 - radius - 1 - aa;
 80192ec:	68fb      	ldr	r3, [r7, #12]
 80192ee:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80192f2:	b29a      	uxth	r2, r3
 80192f4:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 80192f6:	1ad3      	subs	r3, r2, r3
 80192f8:	b29a      	uxth	r2, r3
 80192fa:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 80192fe:	b29b      	uxth	r3, r3
 8019300:	1ad3      	subs	r3, r2, r3
 8019302:	b29b      	uxth	r3, r3
 8019304:	3b01      	subs	r3, #1
 8019306:	b29b      	uxth	r3, r3
 8019308:	b21b      	sxth	r3, r3
 801930a:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 801930c:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8019310:	f107 0014 	add.w	r0, r7, #20
 8019314:	8bba      	ldrh	r2, [r7, #28]
 8019316:	68b9      	ldr	r1, [r7, #8]
 8019318:	f7fc fd9e 	bl	8015e58 <lv_draw_fill>
        }

        /*Right bottom correction*/
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
 801931c:	f897 3020 	ldrb.w	r3, [r7, #32]
 8019320:	f003 0301 	and.w	r3, r3, #1
 8019324:	2b00      	cmp	r3, #0
 8019326:	d038      	beq.n	801939a <lv_draw_rect_border_straight+0x5e4>
 8019328:	f897 3020 	ldrb.w	r3, [r7, #32]
 801932c:	f003 0308 	and.w	r3, r3, #8
 8019330:	2b00      	cmp	r3, #0
 8019332:	d032      	beq.n	801939a <lv_draw_rect_border_straight+0x5e4>
            work_area.x1 = coords->x2 - radius - aa;
 8019334:	68fb      	ldr	r3, [r7, #12]
 8019336:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801933a:	b29a      	uxth	r2, r3
 801933c:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 801933e:	1ad3      	subs	r3, r2, r3
 8019340:	b29a      	uxth	r2, r3
 8019342:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8019346:	b29b      	uxth	r3, r3
 8019348:	1ad3      	subs	r3, r2, r3
 801934a:	b29b      	uxth	r3, r3
 801934c:	b21b      	sxth	r3, r3
 801934e:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x2;
 8019350:	68fb      	ldr	r3, [r7, #12]
 8019352:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8019356:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y2 - bwidth;
 8019358:	68fb      	ldr	r3, [r7, #12]
 801935a:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801935e:	b29a      	uxth	r2, r3
 8019360:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8019362:	1ad3      	subs	r3, r2, r3
 8019364:	b29b      	uxth	r3, r3
 8019366:	b21b      	sxth	r3, r3
 8019368:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y2 - radius - 1 - aa;
 801936a:	68fb      	ldr	r3, [r7, #12]
 801936c:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8019370:	b29a      	uxth	r2, r3
 8019372:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8019374:	1ad3      	subs	r3, r2, r3
 8019376:	b29a      	uxth	r2, r3
 8019378:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 801937c:	b29b      	uxth	r3, r3
 801937e:	1ad3      	subs	r3, r2, r3
 8019380:	b29b      	uxth	r3, r3
 8019382:	3b01      	subs	r3, #1
 8019384:	b29b      	uxth	r3, r3
 8019386:	b21b      	sxth	r3, r3
 8019388:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 801938a:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 801938e:	f107 0014 	add.w	r0, r7, #20
 8019392:	8bba      	ldrh	r2, [r7, #28]
 8019394:	68b9      	ldr	r1, [r7, #8]
 8019396:	f7fc fd5f 	bl	8015e58 <lv_draw_fill>
        }
    }

    /*If radius == 0 one px on the corners are not drawn by main drawer*/
    if(style->body.radius == 0) {
 801939a:	687b      	ldr	r3, [r7, #4]
 801939c:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80193a0:	2b00      	cmp	r3, #0
 80193a2:	f040 80b2 	bne.w	801950a <lv_draw_rect_border_straight+0x754>
        /*Left top corner*/
        if(part & (LV_BORDER_TOP | LV_BORDER_LEFT)) {
 80193a6:	f897 3020 	ldrb.w	r3, [r7, #32]
 80193aa:	f003 0306 	and.w	r3, r3, #6
 80193ae:	2b00      	cmp	r3, #0
 80193b0:	d025      	beq.n	80193fe <lv_draw_rect_border_straight+0x648>
            work_area.x1 = coords->x1;
 80193b2:	68fb      	ldr	r3, [r7, #12]
 80193b4:	f9b3 3000 	ldrsh.w	r3, [r3]
 80193b8:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x1 + aa;
 80193ba:	68fb      	ldr	r3, [r7, #12]
 80193bc:	f9b3 3000 	ldrsh.w	r3, [r3]
 80193c0:	b29a      	uxth	r2, r3
 80193c2:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 80193c6:	b29b      	uxth	r3, r3
 80193c8:	4413      	add	r3, r2
 80193ca:	b29b      	uxth	r3, r3
 80193cc:	b21b      	sxth	r3, r3
 80193ce:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y1;
 80193d0:	68fb      	ldr	r3, [r7, #12]
 80193d2:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80193d6:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y1 + aa;
 80193d8:	68fb      	ldr	r3, [r7, #12]
 80193da:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80193de:	b29a      	uxth	r2, r3
 80193e0:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 80193e4:	b29b      	uxth	r3, r3
 80193e6:	4413      	add	r3, r2
 80193e8:	b29b      	uxth	r3, r3
 80193ea:	b21b      	sxth	r3, r3
 80193ec:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 80193ee:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 80193f2:	f107 0014 	add.w	r0, r7, #20
 80193f6:	8bba      	ldrh	r2, [r7, #28]
 80193f8:	68b9      	ldr	r1, [r7, #8]
 80193fa:	f7fc fd2d 	bl	8015e58 <lv_draw_fill>
        }

        /*Right top corner*/
        if(part & (LV_BORDER_TOP | LV_BORDER_RIGHT)) {
 80193fe:	f897 3020 	ldrb.w	r3, [r7, #32]
 8019402:	f003 030a 	and.w	r3, r3, #10
 8019406:	2b00      	cmp	r3, #0
 8019408:	d025      	beq.n	8019456 <lv_draw_rect_border_straight+0x6a0>
            work_area.x1 = coords->x2 - aa;
 801940a:	68fb      	ldr	r3, [r7, #12]
 801940c:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8019410:	b29a      	uxth	r2, r3
 8019412:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8019416:	b29b      	uxth	r3, r3
 8019418:	1ad3      	subs	r3, r2, r3
 801941a:	b29b      	uxth	r3, r3
 801941c:	b21b      	sxth	r3, r3
 801941e:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x2;
 8019420:	68fb      	ldr	r3, [r7, #12]
 8019422:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8019426:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y1;
 8019428:	68fb      	ldr	r3, [r7, #12]
 801942a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801942e:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y1 + aa;
 8019430:	68fb      	ldr	r3, [r7, #12]
 8019432:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8019436:	b29a      	uxth	r2, r3
 8019438:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 801943c:	b29b      	uxth	r3, r3
 801943e:	4413      	add	r3, r2
 8019440:	b29b      	uxth	r3, r3
 8019442:	b21b      	sxth	r3, r3
 8019444:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 8019446:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 801944a:	f107 0014 	add.w	r0, r7, #20
 801944e:	8bba      	ldrh	r2, [r7, #28]
 8019450:	68b9      	ldr	r1, [r7, #8]
 8019452:	f7fc fd01 	bl	8015e58 <lv_draw_fill>
        }

        /*Left bottom corner*/
        if(part & (LV_BORDER_BOTTOM | LV_BORDER_LEFT)) {
 8019456:	f897 3020 	ldrb.w	r3, [r7, #32]
 801945a:	f003 0305 	and.w	r3, r3, #5
 801945e:	2b00      	cmp	r3, #0
 8019460:	d025      	beq.n	80194ae <lv_draw_rect_border_straight+0x6f8>
            work_area.x1 = coords->x1;
 8019462:	68fb      	ldr	r3, [r7, #12]
 8019464:	f9b3 3000 	ldrsh.w	r3, [r3]
 8019468:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x1 + aa;
 801946a:	68fb      	ldr	r3, [r7, #12]
 801946c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8019470:	b29a      	uxth	r2, r3
 8019472:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8019476:	b29b      	uxth	r3, r3
 8019478:	4413      	add	r3, r2
 801947a:	b29b      	uxth	r3, r3
 801947c:	b21b      	sxth	r3, r3
 801947e:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y2 - aa;
 8019480:	68fb      	ldr	r3, [r7, #12]
 8019482:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8019486:	b29a      	uxth	r2, r3
 8019488:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 801948c:	b29b      	uxth	r3, r3
 801948e:	1ad3      	subs	r3, r2, r3
 8019490:	b29b      	uxth	r3, r3
 8019492:	b21b      	sxth	r3, r3
 8019494:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y2;
 8019496:	68fb      	ldr	r3, [r7, #12]
 8019498:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801949c:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 801949e:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 80194a2:	f107 0014 	add.w	r0, r7, #20
 80194a6:	8bba      	ldrh	r2, [r7, #28]
 80194a8:	68b9      	ldr	r1, [r7, #8]
 80194aa:	f7fc fcd5 	bl	8015e58 <lv_draw_fill>
        }

        /*Right bottom corner*/
        if(part & (LV_BORDER_BOTTOM | LV_BORDER_RIGHT)) {
 80194ae:	f897 3020 	ldrb.w	r3, [r7, #32]
 80194b2:	f003 0309 	and.w	r3, r3, #9
 80194b6:	2b00      	cmp	r3, #0
 80194b8:	d027      	beq.n	801950a <lv_draw_rect_border_straight+0x754>
            work_area.x1 = coords->x2 - aa;
 80194ba:	68fb      	ldr	r3, [r7, #12]
 80194bc:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80194c0:	b29a      	uxth	r2, r3
 80194c2:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 80194c6:	b29b      	uxth	r3, r3
 80194c8:	1ad3      	subs	r3, r2, r3
 80194ca:	b29b      	uxth	r3, r3
 80194cc:	b21b      	sxth	r3, r3
 80194ce:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x2;
 80194d0:	68fb      	ldr	r3, [r7, #12]
 80194d2:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80194d6:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y2 - aa;
 80194d8:	68fb      	ldr	r3, [r7, #12]
 80194da:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80194de:	b29a      	uxth	r2, r3
 80194e0:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 80194e4:	b29b      	uxth	r3, r3
 80194e6:	1ad3      	subs	r3, r2, r3
 80194e8:	b29b      	uxth	r3, r3
 80194ea:	b21b      	sxth	r3, r3
 80194ec:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y2;
 80194ee:	68fb      	ldr	r3, [r7, #12]
 80194f0:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80194f4:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 80194f6:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 80194fa:	f107 0014 	add.w	r0, r7, #20
 80194fe:	8bba      	ldrh	r2, [r7, #28]
 8019500:	68b9      	ldr	r1, [r7, #8]
 8019502:	f7fc fca9 	bl	8015e58 <lv_draw_fill>
 8019506:	e000      	b.n	801950a <lv_draw_rect_border_straight+0x754>
        return;
 8019508:	bf00      	nop
        }
    }
}
 801950a:	3730      	adds	r7, #48	; 0x30
 801950c:	46bd      	mov	sp, r7
 801950e:	bd80      	pop	{r7, pc}

08019510 <lv_draw_rect_border_corner>:
 * @param style pointer to a style
 * @param opa_scale scale down all opacities by the factor
 */
static void lv_draw_rect_border_corner(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style,
                                       lv_opa_t opa_scale)
{
 8019510:	b580      	push	{r7, lr}
 8019512:	b0a0      	sub	sp, #128	; 0x80
 8019514:	af02      	add	r7, sp, #8
 8019516:	60f8      	str	r0, [r7, #12]
 8019518:	60b9      	str	r1, [r7, #8]
 801951a:	607a      	str	r2, [r7, #4]
 801951c:	70fb      	strb	r3, [r7, #3]
    uint16_t radius       = style->body.radius;
 801951e:	687b      	ldr	r3, [r7, #4]
 8019520:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8019524:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
    bool aa               = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
 8019528:	f7fa ffb4 	bl	8014494 <lv_refr_get_disp_refreshing>
 801952c:	4603      	mov	r3, r0
 801952e:	4618      	mov	r0, r3
 8019530:	f003 fe33 	bl	801d19a <lv_disp_get_antialiasing>
 8019534:	4603      	mov	r3, r0
 8019536:	f887 305b 	strb.w	r3, [r7, #91]	; 0x5b
    lv_coord_t bwidth     = style->body.border.width;
 801953a:	687b      	ldr	r3, [r7, #4]
 801953c:	899b      	ldrh	r3, [r3, #12]
 801953e:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76
    lv_color_t color      = style->body.border.color;
 8019542:	687b      	ldr	r3, [r7, #4]
 8019544:	895b      	ldrh	r3, [r3, #10]
 8019546:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
    lv_border_part_t part = style->body.border.part;
 801954a:	687b      	ldr	r3, [r7, #4]
 801954c:	7b9b      	ldrb	r3, [r3, #14]
 801954e:	f887 305a 	strb.w	r3, [r7, #90]	; 0x5a
    lv_opa_t opa          = opa_scale == LV_OPA_COVER ? style->body.border.opa
 8019552:	78fb      	ldrb	r3, [r7, #3]
 8019554:	2bff      	cmp	r3, #255	; 0xff
 8019556:	d102      	bne.n	801955e <lv_draw_rect_border_corner+0x4e>
 8019558:	687b      	ldr	r3, [r7, #4]
 801955a:	7bdb      	ldrb	r3, [r3, #15]
 801955c:	e00a      	b.n	8019574 <lv_draw_rect_border_corner+0x64>
                                             : (uint16_t)((uint16_t)style->body.border.opa * opa_scale) >> 8;
 801955e:	687b      	ldr	r3, [r7, #4]
 8019560:	7bdb      	ldrb	r3, [r3, #15]
 8019562:	b29a      	uxth	r2, r3
 8019564:	78fb      	ldrb	r3, [r7, #3]
 8019566:	b29b      	uxth	r3, r3
 8019568:	fb12 f303 	smulbb	r3, r2, r3
 801956c:	b29b      	uxth	r3, r3
    lv_opa_t opa          = opa_scale == LV_OPA_COVER ? style->body.border.opa
 801956e:	0a1b      	lsrs	r3, r3, #8
 8019570:	b29b      	uxth	r3, r3
 8019572:	b2db      	uxtb	r3, r3
 8019574:	f887 3059 	strb.w	r3, [r7, #89]	; 0x59
    /*0 px border width drawn as 1 px, so decrement the bwidth*/
    bwidth--;
 8019578:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 801957c:	b29b      	uxth	r3, r3
 801957e:	3b01      	subs	r3, #1
 8019580:	b29b      	uxth	r3, r3
 8019582:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76

#if LV_ANTIALIAS
    if(aa) bwidth--; /*Because of anti-aliasing the border seems one pixel ticker*/
 8019586:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 801958a:	2b00      	cmp	r3, #0
 801958c:	d006      	beq.n	801959c <lv_draw_rect_border_corner+0x8c>
 801958e:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8019592:	b29b      	uxth	r3, r3
 8019594:	3b01      	subs	r3, #1
 8019596:	b29b      	uxth	r3, r3
 8019598:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76
#endif

    lv_coord_t width  = lv_area_get_width(coords);
 801959c:	68f8      	ldr	r0, [r7, #12]
 801959e:	f7fe fa4e 	bl	8017a3e <lv_area_get_width>
 80195a2:	4603      	mov	r3, r0
 80195a4:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
    lv_coord_t height = lv_area_get_height(coords);
 80195a8:	68f8      	ldr	r0, [r7, #12]
 80195aa:	f7fe fa5f 	bl	8017a6c <lv_area_get_height>
 80195ae:	4603      	mov	r3, r0
 80195b0:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54

    radius = lv_draw_cont_radius_corr(radius, width, height);
 80195b4:	f9b7 2054 	ldrsh.w	r2, [r7, #84]	; 0x54
 80195b8:	f9b7 1056 	ldrsh.w	r1, [r7, #86]	; 0x56
 80195bc:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 80195c0:	4618      	mov	r0, r3
 80195c2:	f002 f8e7 	bl	801b794 <lv_draw_cont_radius_corr>
 80195c6:	4603      	mov	r3, r0
 80195c8:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
    lv_point_t lt_origo; /*Left  Top    origo*/
    lv_point_t lb_origo; /*Left  Bottom origo*/
    lv_point_t rt_origo; /*Right Top    origo*/
    lv_point_t rb_origo; /*Left  Bottom origo*/

    lt_origo.x = coords->x1 + radius + aa;
 80195cc:	68fb      	ldr	r3, [r7, #12]
 80195ce:	f9b3 3000 	ldrsh.w	r3, [r3]
 80195d2:	b29a      	uxth	r2, r3
 80195d4:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 80195d8:	4413      	add	r3, r2
 80195da:	b29a      	uxth	r2, r3
 80195dc:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 80195e0:	b29b      	uxth	r3, r3
 80195e2:	4413      	add	r3, r2
 80195e4:	b29b      	uxth	r3, r3
 80195e6:	b21b      	sxth	r3, r3
 80195e8:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40
    lt_origo.y = coords->y1 + radius + aa;
 80195ec:	68fb      	ldr	r3, [r7, #12]
 80195ee:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80195f2:	b29a      	uxth	r2, r3
 80195f4:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 80195f8:	4413      	add	r3, r2
 80195fa:	b29a      	uxth	r2, r3
 80195fc:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 8019600:	b29b      	uxth	r3, r3
 8019602:	4413      	add	r3, r2
 8019604:	b29b      	uxth	r3, r3
 8019606:	b21b      	sxth	r3, r3
 8019608:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42

    lb_origo.x = coords->x1 + radius + aa;
 801960c:	68fb      	ldr	r3, [r7, #12]
 801960e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8019612:	b29a      	uxth	r2, r3
 8019614:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 8019618:	4413      	add	r3, r2
 801961a:	b29a      	uxth	r2, r3
 801961c:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 8019620:	b29b      	uxth	r3, r3
 8019622:	4413      	add	r3, r2
 8019624:	b29b      	uxth	r3, r3
 8019626:	b21b      	sxth	r3, r3
 8019628:	87bb      	strh	r3, [r7, #60]	; 0x3c
    lb_origo.y = coords->y2 - radius - aa;
 801962a:	68fb      	ldr	r3, [r7, #12]
 801962c:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8019630:	b29a      	uxth	r2, r3
 8019632:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 8019636:	1ad3      	subs	r3, r2, r3
 8019638:	b29a      	uxth	r2, r3
 801963a:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 801963e:	b29b      	uxth	r3, r3
 8019640:	1ad3      	subs	r3, r2, r3
 8019642:	b29b      	uxth	r3, r3
 8019644:	b21b      	sxth	r3, r3
 8019646:	87fb      	strh	r3, [r7, #62]	; 0x3e

    rt_origo.x = coords->x2 - radius - aa;
 8019648:	68fb      	ldr	r3, [r7, #12]
 801964a:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801964e:	b29a      	uxth	r2, r3
 8019650:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 8019654:	1ad3      	subs	r3, r2, r3
 8019656:	b29a      	uxth	r2, r3
 8019658:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 801965c:	b29b      	uxth	r3, r3
 801965e:	1ad3      	subs	r3, r2, r3
 8019660:	b29b      	uxth	r3, r3
 8019662:	b21b      	sxth	r3, r3
 8019664:	873b      	strh	r3, [r7, #56]	; 0x38
    rt_origo.y = coords->y1 + radius + aa;
 8019666:	68fb      	ldr	r3, [r7, #12]
 8019668:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801966c:	b29a      	uxth	r2, r3
 801966e:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 8019672:	4413      	add	r3, r2
 8019674:	b29a      	uxth	r2, r3
 8019676:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 801967a:	b29b      	uxth	r3, r3
 801967c:	4413      	add	r3, r2
 801967e:	b29b      	uxth	r3, r3
 8019680:	b21b      	sxth	r3, r3
 8019682:	877b      	strh	r3, [r7, #58]	; 0x3a

    rb_origo.x = coords->x2 - radius - aa;
 8019684:	68fb      	ldr	r3, [r7, #12]
 8019686:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801968a:	b29a      	uxth	r2, r3
 801968c:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 8019690:	1ad3      	subs	r3, r2, r3
 8019692:	b29a      	uxth	r2, r3
 8019694:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 8019698:	b29b      	uxth	r3, r3
 801969a:	1ad3      	subs	r3, r2, r3
 801969c:	b29b      	uxth	r3, r3
 801969e:	b21b      	sxth	r3, r3
 80196a0:	86bb      	strh	r3, [r7, #52]	; 0x34
    rb_origo.y = coords->y2 - radius - aa;
 80196a2:	68fb      	ldr	r3, [r7, #12]
 80196a4:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80196a8:	b29a      	uxth	r2, r3
 80196aa:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 80196ae:	1ad3      	subs	r3, r2, r3
 80196b0:	b29a      	uxth	r2, r3
 80196b2:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 80196b6:	b29b      	uxth	r3, r3
 80196b8:	1ad3      	subs	r3, r2, r3
 80196ba:	b29b      	uxth	r3, r3
 80196bc:	b21b      	sxth	r3, r3
 80196be:	86fb      	strh	r3, [r7, #54]	; 0x36

    lv_point_t cir_out;
    lv_coord_t tmp_out;
    lv_circ_init(&cir_out, &tmp_out, radius);
 80196c0:	f9b7 205c 	ldrsh.w	r2, [r7, #92]	; 0x5c
 80196c4:	f107 012e 	add.w	r1, r7, #46	; 0x2e
 80196c8:	f107 0330 	add.w	r3, r7, #48	; 0x30
 80196cc:	4618      	mov	r0, r3
 80196ce:	f004 f98e 	bl	801d9ee <lv_circ_init>

    lv_point_t cir_in;
    lv_coord_t tmp_in;
    lv_coord_t radius_in = radius - bwidth;
 80196d2:	f8b7 3076 	ldrh.w	r3, [r7, #118]	; 0x76
 80196d6:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 80196da:	1ad3      	subs	r3, r2, r3
 80196dc:	b29b      	uxth	r3, r3
 80196de:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74

    if(radius_in < 0) {
 80196e2:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 80196e6:	2b00      	cmp	r3, #0
 80196e8:	da02      	bge.n	80196f0 <lv_draw_rect_border_corner+0x1e0>
        radius_in = 0;
 80196ea:	2300      	movs	r3, #0
 80196ec:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74
    }

    lv_circ_init(&cir_in, &tmp_in, radius_in);
 80196f0:	f9b7 2074 	ldrsh.w	r2, [r7, #116]	; 0x74
 80196f4:	f107 0126 	add.w	r1, r7, #38	; 0x26
 80196f8:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80196fc:	4618      	mov	r0, r3
 80196fe:	f004 f976 	bl	801d9ee <lv_circ_init>
    lv_coord_t act_w1;
    lv_coord_t act_w2;

#if LV_ANTIALIAS
    /*Store some internal states for anti-aliasing*/
    lv_coord_t out_y_seg_start = 0;
 8019702:	2300      	movs	r3, #0
 8019704:	f8a7 306e 	strh.w	r3, [r7, #110]	; 0x6e
    lv_coord_t out_y_seg_end   = 0;
 8019708:	2300      	movs	r3, #0
 801970a:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
    lv_coord_t out_x_last      = radius;
 801970e:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 8019712:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c

    lv_coord_t in_y_seg_start = 0;
 8019716:	2300      	movs	r3, #0
 8019718:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
    lv_coord_t in_y_seg_end   = 0;
 801971c:	2300      	movs	r3, #0
 801971e:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
    lv_coord_t in_x_last      = radius - bwidth;
 8019722:	f8b7 3076 	ldrh.w	r3, [r7, #118]	; 0x76
 8019726:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 801972a:	1ad3      	subs	r3, r2, r3
 801972c:	b29b      	uxth	r3, r3
 801972e:	f8a7 3068 	strh.w	r3, [r7, #104]	; 0x68
#endif

    while(cir_out.y <= cir_out.x) {
 8019732:	f000 bd74 	b.w	801a21e <lv_draw_rect_border_corner+0xd0e>

        /*Calculate the actual width to avoid overwriting pixels*/
        if(cir_in.y < cir_in.x) {
 8019736:	f9b7 202a 	ldrsh.w	r2, [r7, #42]	; 0x2a
 801973a:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 801973e:	429a      	cmp	r2, r3
 8019740:	da0e      	bge.n	8019760 <lv_draw_rect_border_corner+0x250>
            act_w1 = cir_out.x - cir_in.x;
 8019742:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8019746:	b29a      	uxth	r2, r3
 8019748:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 801974c:	b29b      	uxth	r3, r3
 801974e:	1ad3      	subs	r3, r2, r3
 8019750:	b29b      	uxth	r3, r3
 8019752:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
            act_w2 = act_w1;
 8019756:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
 801975a:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
 801975e:	e00f      	b.n	8019780 <lv_draw_rect_border_corner+0x270>
        } else {
            act_w1 = cir_out.x - cir_out.y;
 8019760:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8019764:	b29a      	uxth	r2, r3
 8019766:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 801976a:	b29b      	uxth	r3, r3
 801976c:	1ad3      	subs	r3, r2, r3
 801976e:	b29b      	uxth	r3, r3
 8019770:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
            act_w2 = act_w1 - 1;
 8019774:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
 8019778:	3b01      	subs	r3, #1
 801977a:	b29b      	uxth	r3, r3
 801977c:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
        }

#if LV_ANTIALIAS
        if(aa) {
 8019780:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 8019784:	2b00      	cmp	r3, #0
 8019786:	f000 8340 	beq.w	8019e0a <lv_draw_rect_border_corner+0x8fa>
            /*New step in y on the outter circle*/
            if(out_x_last != cir_out.x) {
 801978a:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 801978e:	f9b7 206c 	ldrsh.w	r2, [r7, #108]	; 0x6c
 8019792:	429a      	cmp	r2, r3
 8019794:	f000 817b 	beq.w	8019a8e <lv_draw_rect_border_corner+0x57e>
                out_y_seg_end       = cir_out.y;
 8019798:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 801979a:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
                lv_coord_t seg_size = out_y_seg_end - out_y_seg_start;
 801979e:	f8b7 2052 	ldrh.w	r2, [r7, #82]	; 0x52
 80197a2:	f8b7 306e 	ldrh.w	r3, [r7, #110]	; 0x6e
 80197a6:	1ad3      	subs	r3, r2, r3
 80197a8:	b29b      	uxth	r3, r3
 80197aa:	f8a7 3048 	strh.w	r3, [r7, #72]	; 0x48
                lv_point_t aa_p;

                aa_p.x = out_x_last;
 80197ae:	f8b7 306c 	ldrh.w	r3, [r7, #108]	; 0x6c
 80197b2:	833b      	strh	r3, [r7, #24]
                aa_p.y = out_y_seg_start;
 80197b4:	f8b7 306e 	ldrh.w	r3, [r7, #110]	; 0x6e
 80197b8:	837b      	strh	r3, [r7, #26]

                lv_coord_t i;
                for(i = 0; i < seg_size; i++) {
 80197ba:	2300      	movs	r3, #0
 80197bc:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 80197c0:	e157      	b.n	8019a72 <lv_draw_rect_border_corner+0x562>
                    lv_opa_t aa_opa;

                    if(seg_size > CIRCLE_AA_NON_LINEAR_OPA_THRESHOLD) { /*Use non-linear opa mapping
 80197c2:	f9b7 3048 	ldrsh.w	r3, [r7, #72]	; 0x48
 80197c6:	2b01      	cmp	r3, #1
 80197c8:	dd0c      	ble.n	80197e4 <lv_draw_rect_border_corner+0x2d4>
                                                                           on the first segment*/
                        aa_opa = antialias_get_opa_circ(seg_size, i, opa);
 80197ca:	f897 2059 	ldrb.w	r2, [r7, #89]	; 0x59
 80197ce:	f9b7 1066 	ldrsh.w	r1, [r7, #102]	; 0x66
 80197d2:	f9b7 3048 	ldrsh.w	r3, [r7, #72]	; 0x48
 80197d6:	4618      	mov	r0, r3
 80197d8:	f002 f81e 	bl	801b818 <antialias_get_opa_circ>
 80197dc:	4603      	mov	r3, r0
 80197de:	f887 3065 	strb.w	r3, [r7, #101]	; 0x65
 80197e2:	e00f      	b.n	8019804 <lv_draw_rect_border_corner+0x2f4>
                    } else {
                        aa_opa = opa - lv_draw_aa_get_opa(seg_size, i, opa);
 80197e4:	f897 2059 	ldrb.w	r2, [r7, #89]	; 0x59
 80197e8:	f9b7 1066 	ldrsh.w	r1, [r7, #102]	; 0x66
 80197ec:	f9b7 3048 	ldrsh.w	r3, [r7, #72]	; 0x48
 80197f0:	4618      	mov	r0, r3
 80197f2:	f7fb fe23 	bl	801543c <lv_draw_aa_get_opa>
 80197f6:	4603      	mov	r3, r0
 80197f8:	461a      	mov	r2, r3
 80197fa:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 80197fe:	1a9b      	subs	r3, r3, r2
 8019800:	f887 3065 	strb.w	r3, [r7, #101]	; 0x65
                    }

                    if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
 8019804:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8019808:	f003 0301 	and.w	r3, r3, #1
 801980c:	2b00      	cmp	r3, #0
 801980e:	d045      	beq.n	801989c <lv_draw_rect_border_corner+0x38c>
 8019810:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8019814:	f003 0308 	and.w	r3, r3, #8
 8019818:	2b00      	cmp	r3, #0
 801981a:	d03f      	beq.n	801989c <lv_draw_rect_border_corner+0x38c>
                        lv_draw_px(rb_origo.x + LV_CIRC_OCT1_X(aa_p) + 1, rb_origo.y + LV_CIRC_OCT1_Y(aa_p) + i, mask,
 801981c:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8019820:	b29a      	uxth	r2, r3
 8019822:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8019826:	b29b      	uxth	r3, r3
 8019828:	4413      	add	r3, r2
 801982a:	b29b      	uxth	r3, r3
 801982c:	3301      	adds	r3, #1
 801982e:	b29b      	uxth	r3, r3
 8019830:	b218      	sxth	r0, r3
 8019832:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8019836:	b29a      	uxth	r2, r3
 8019838:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 801983c:	b29b      	uxth	r3, r3
 801983e:	4413      	add	r3, r2
 8019840:	b29a      	uxth	r2, r3
 8019842:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8019846:	4413      	add	r3, r2
 8019848:	b29b      	uxth	r3, r3
 801984a:	b219      	sxth	r1, r3
 801984c:	687b      	ldr	r3, [r7, #4]
 801984e:	f897 2065 	ldrb.w	r2, [r7, #101]	; 0x65
 8019852:	9200      	str	r2, [sp, #0]
 8019854:	895b      	ldrh	r3, [r3, #10]
 8019856:	68ba      	ldr	r2, [r7, #8]
 8019858:	f7fc fa66 	bl	8015d28 <lv_draw_px>
                                   style->body.border.color, aa_opa);
                        lv_draw_px(rb_origo.x + LV_CIRC_OCT2_X(aa_p) + i, rb_origo.y + LV_CIRC_OCT2_Y(aa_p) + 1, mask,
 801985c:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8019860:	b29a      	uxth	r2, r3
 8019862:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8019866:	b29b      	uxth	r3, r3
 8019868:	4413      	add	r3, r2
 801986a:	b29a      	uxth	r2, r3
 801986c:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8019870:	4413      	add	r3, r2
 8019872:	b29b      	uxth	r3, r3
 8019874:	b218      	sxth	r0, r3
 8019876:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 801987a:	b29a      	uxth	r2, r3
 801987c:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8019880:	b29b      	uxth	r3, r3
 8019882:	4413      	add	r3, r2
 8019884:	b29b      	uxth	r3, r3
 8019886:	3301      	adds	r3, #1
 8019888:	b29b      	uxth	r3, r3
 801988a:	b219      	sxth	r1, r3
 801988c:	687b      	ldr	r3, [r7, #4]
 801988e:	f897 2065 	ldrb.w	r2, [r7, #101]	; 0x65
 8019892:	9200      	str	r2, [sp, #0]
 8019894:	895b      	ldrh	r3, [r3, #10]
 8019896:	68ba      	ldr	r2, [r7, #8]
 8019898:	f7fc fa46 	bl	8015d28 <lv_draw_px>
                                   style->body.border.color, aa_opa);
                    }

                    if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
 801989c:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80198a0:	f003 0301 	and.w	r3, r3, #1
 80198a4:	2b00      	cmp	r3, #0
 80198a6:	d045      	beq.n	8019934 <lv_draw_rect_border_corner+0x424>
 80198a8:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80198ac:	f003 0304 	and.w	r3, r3, #4
 80198b0:	2b00      	cmp	r3, #0
 80198b2:	d03f      	beq.n	8019934 <lv_draw_rect_border_corner+0x424>
                        lv_draw_px(lb_origo.x + LV_CIRC_OCT3_X(aa_p) - i, lb_origo.y + LV_CIRC_OCT3_Y(aa_p) + 1, mask,
 80198b4:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 80198b8:	b29a      	uxth	r2, r3
 80198ba:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80198be:	b29b      	uxth	r3, r3
 80198c0:	1ad3      	subs	r3, r2, r3
 80198c2:	b29a      	uxth	r2, r3
 80198c4:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 80198c8:	1ad3      	subs	r3, r2, r3
 80198ca:	b29b      	uxth	r3, r3
 80198cc:	b218      	sxth	r0, r3
 80198ce:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 80198d2:	b29a      	uxth	r2, r3
 80198d4:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 80198d8:	b29b      	uxth	r3, r3
 80198da:	4413      	add	r3, r2
 80198dc:	b29b      	uxth	r3, r3
 80198de:	3301      	adds	r3, #1
 80198e0:	b29b      	uxth	r3, r3
 80198e2:	b219      	sxth	r1, r3
 80198e4:	687b      	ldr	r3, [r7, #4]
 80198e6:	f897 2065 	ldrb.w	r2, [r7, #101]	; 0x65
 80198ea:	9200      	str	r2, [sp, #0]
 80198ec:	895b      	ldrh	r3, [r3, #10]
 80198ee:	68ba      	ldr	r2, [r7, #8]
 80198f0:	f7fc fa1a 	bl	8015d28 <lv_draw_px>
                                   style->body.border.color, aa_opa);
                        lv_draw_px(lb_origo.x + LV_CIRC_OCT4_X(aa_p) - 1, lb_origo.y + LV_CIRC_OCT4_Y(aa_p) + i, mask,
 80198f4:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 80198f8:	b29a      	uxth	r2, r3
 80198fa:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 80198fe:	b29b      	uxth	r3, r3
 8019900:	1ad3      	subs	r3, r2, r3
 8019902:	b29b      	uxth	r3, r3
 8019904:	3b01      	subs	r3, #1
 8019906:	b29b      	uxth	r3, r3
 8019908:	b218      	sxth	r0, r3
 801990a:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 801990e:	b29a      	uxth	r2, r3
 8019910:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8019914:	b29b      	uxth	r3, r3
 8019916:	4413      	add	r3, r2
 8019918:	b29a      	uxth	r2, r3
 801991a:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 801991e:	4413      	add	r3, r2
 8019920:	b29b      	uxth	r3, r3
 8019922:	b219      	sxth	r1, r3
 8019924:	687b      	ldr	r3, [r7, #4]
 8019926:	f897 2065 	ldrb.w	r2, [r7, #101]	; 0x65
 801992a:	9200      	str	r2, [sp, #0]
 801992c:	895b      	ldrh	r3, [r3, #10]
 801992e:	68ba      	ldr	r2, [r7, #8]
 8019930:	f7fc f9fa 	bl	8015d28 <lv_draw_px>
                                   style->body.border.color, aa_opa);
                    }

                    if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
 8019934:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8019938:	f003 0302 	and.w	r3, r3, #2
 801993c:	2b00      	cmp	r3, #0
 801993e:	d045      	beq.n	80199cc <lv_draw_rect_border_corner+0x4bc>
 8019940:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8019944:	f003 0304 	and.w	r3, r3, #4
 8019948:	2b00      	cmp	r3, #0
 801994a:	d03f      	beq.n	80199cc <lv_draw_rect_border_corner+0x4bc>
                        lv_draw_px(lt_origo.x + LV_CIRC_OCT5_X(aa_p) - 1, lt_origo.y + LV_CIRC_OCT5_Y(aa_p) - i, mask,
 801994c:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 8019950:	b29a      	uxth	r2, r3
 8019952:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8019956:	b29b      	uxth	r3, r3
 8019958:	1ad3      	subs	r3, r2, r3
 801995a:	b29b      	uxth	r3, r3
 801995c:	3b01      	subs	r3, #1
 801995e:	b29b      	uxth	r3, r3
 8019960:	b218      	sxth	r0, r3
 8019962:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 8019966:	b29a      	uxth	r2, r3
 8019968:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 801996c:	b29b      	uxth	r3, r3
 801996e:	1ad3      	subs	r3, r2, r3
 8019970:	b29a      	uxth	r2, r3
 8019972:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8019976:	1ad3      	subs	r3, r2, r3
 8019978:	b29b      	uxth	r3, r3
 801997a:	b219      	sxth	r1, r3
 801997c:	687b      	ldr	r3, [r7, #4]
 801997e:	f897 2065 	ldrb.w	r2, [r7, #101]	; 0x65
 8019982:	9200      	str	r2, [sp, #0]
 8019984:	895b      	ldrh	r3, [r3, #10]
 8019986:	68ba      	ldr	r2, [r7, #8]
 8019988:	f7fc f9ce 	bl	8015d28 <lv_draw_px>
                                   style->body.border.color, aa_opa);
                        lv_draw_px(lt_origo.x + LV_CIRC_OCT6_X(aa_p) - i, lt_origo.y + LV_CIRC_OCT6_Y(aa_p) - 1, mask,
 801998c:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 8019990:	b29a      	uxth	r2, r3
 8019992:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8019996:	b29b      	uxth	r3, r3
 8019998:	1ad3      	subs	r3, r2, r3
 801999a:	b29a      	uxth	r2, r3
 801999c:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 80199a0:	1ad3      	subs	r3, r2, r3
 80199a2:	b29b      	uxth	r3, r3
 80199a4:	b218      	sxth	r0, r3
 80199a6:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 80199aa:	b29a      	uxth	r2, r3
 80199ac:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 80199b0:	b29b      	uxth	r3, r3
 80199b2:	1ad3      	subs	r3, r2, r3
 80199b4:	b29b      	uxth	r3, r3
 80199b6:	3b01      	subs	r3, #1
 80199b8:	b29b      	uxth	r3, r3
 80199ba:	b219      	sxth	r1, r3
 80199bc:	687b      	ldr	r3, [r7, #4]
 80199be:	f897 2065 	ldrb.w	r2, [r7, #101]	; 0x65
 80199c2:	9200      	str	r2, [sp, #0]
 80199c4:	895b      	ldrh	r3, [r3, #10]
 80199c6:	68ba      	ldr	r2, [r7, #8]
 80199c8:	f7fc f9ae 	bl	8015d28 <lv_draw_px>
                                   style->body.border.color, aa_opa);
                    }

                    if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
 80199cc:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80199d0:	f003 0302 	and.w	r3, r3, #2
 80199d4:	2b00      	cmp	r3, #0
 80199d6:	d045      	beq.n	8019a64 <lv_draw_rect_border_corner+0x554>
 80199d8:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80199dc:	f003 0308 	and.w	r3, r3, #8
 80199e0:	2b00      	cmp	r3, #0
 80199e2:	d03f      	beq.n	8019a64 <lv_draw_rect_border_corner+0x554>
                        lv_draw_px(rt_origo.x + LV_CIRC_OCT7_X(aa_p) + i, rt_origo.y + LV_CIRC_OCT7_Y(aa_p) - 1, mask,
 80199e4:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 80199e8:	b29a      	uxth	r2, r3
 80199ea:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80199ee:	b29b      	uxth	r3, r3
 80199f0:	4413      	add	r3, r2
 80199f2:	b29a      	uxth	r2, r3
 80199f4:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 80199f8:	4413      	add	r3, r2
 80199fa:	b29b      	uxth	r3, r3
 80199fc:	b218      	sxth	r0, r3
 80199fe:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8019a02:	b29a      	uxth	r2, r3
 8019a04:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8019a08:	b29b      	uxth	r3, r3
 8019a0a:	1ad3      	subs	r3, r2, r3
 8019a0c:	b29b      	uxth	r3, r3
 8019a0e:	3b01      	subs	r3, #1
 8019a10:	b29b      	uxth	r3, r3
 8019a12:	b219      	sxth	r1, r3
 8019a14:	687b      	ldr	r3, [r7, #4]
 8019a16:	f897 2065 	ldrb.w	r2, [r7, #101]	; 0x65
 8019a1a:	9200      	str	r2, [sp, #0]
 8019a1c:	895b      	ldrh	r3, [r3, #10]
 8019a1e:	68ba      	ldr	r2, [r7, #8]
 8019a20:	f7fc f982 	bl	8015d28 <lv_draw_px>
                                   style->body.border.color, aa_opa);
                        lv_draw_px(rt_origo.x + LV_CIRC_OCT8_X(aa_p) + 1, rt_origo.y + LV_CIRC_OCT8_Y(aa_p) - i, mask,
 8019a24:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 8019a28:	b29a      	uxth	r2, r3
 8019a2a:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8019a2e:	b29b      	uxth	r3, r3
 8019a30:	4413      	add	r3, r2
 8019a32:	b29b      	uxth	r3, r3
 8019a34:	3301      	adds	r3, #1
 8019a36:	b29b      	uxth	r3, r3
 8019a38:	b218      	sxth	r0, r3
 8019a3a:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8019a3e:	b29a      	uxth	r2, r3
 8019a40:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8019a44:	b29b      	uxth	r3, r3
 8019a46:	1ad3      	subs	r3, r2, r3
 8019a48:	b29a      	uxth	r2, r3
 8019a4a:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8019a4e:	1ad3      	subs	r3, r2, r3
 8019a50:	b29b      	uxth	r3, r3
 8019a52:	b219      	sxth	r1, r3
 8019a54:	687b      	ldr	r3, [r7, #4]
 8019a56:	f897 2065 	ldrb.w	r2, [r7, #101]	; 0x65
 8019a5a:	9200      	str	r2, [sp, #0]
 8019a5c:	895b      	ldrh	r3, [r3, #10]
 8019a5e:	68ba      	ldr	r2, [r7, #8]
 8019a60:	f7fc f962 	bl	8015d28 <lv_draw_px>
                for(i = 0; i < seg_size; i++) {
 8019a64:	f9b7 3066 	ldrsh.w	r3, [r7, #102]	; 0x66
 8019a68:	b29b      	uxth	r3, r3
 8019a6a:	3301      	adds	r3, #1
 8019a6c:	b29b      	uxth	r3, r3
 8019a6e:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 8019a72:	f9b7 2066 	ldrsh.w	r2, [r7, #102]	; 0x66
 8019a76:	f9b7 3048 	ldrsh.w	r3, [r7, #72]	; 0x48
 8019a7a:	429a      	cmp	r2, r3
 8019a7c:	f6ff aea1 	blt.w	80197c2 <lv_draw_rect_border_corner+0x2b2>
                                   style->body.border.color, aa_opa);
                    }
                }

                out_x_last      = cir_out.x;
 8019a80:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 8019a82:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
                out_y_seg_start = out_y_seg_end;
 8019a86:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 8019a8a:	f8a7 306e 	strh.w	r3, [r7, #110]	; 0x6e
            }

            /*New step in y on the inner circle*/
            if(in_x_last != cir_in.x) {
 8019a8e:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8019a92:	f9b7 2068 	ldrsh.w	r2, [r7, #104]	; 0x68
 8019a96:	429a      	cmp	r2, r3
 8019a98:	f000 81b7 	beq.w	8019e0a <lv_draw_rect_border_corner+0x8fa>
                in_y_seg_end        = cir_out.y;
 8019a9c:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 8019a9e:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
                lv_coord_t seg_size = in_y_seg_end - in_y_seg_start;
 8019aa2:	f8b7 2050 	ldrh.w	r2, [r7, #80]	; 0x50
 8019aa6:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
 8019aaa:	1ad3      	subs	r3, r2, r3
 8019aac:	b29b      	uxth	r3, r3
 8019aae:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
                lv_point_t aa_p;

                aa_p.x = in_x_last;
 8019ab2:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
 8019ab6:	82bb      	strh	r3, [r7, #20]
                aa_p.y = in_y_seg_start;
 8019ab8:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
 8019abc:	82fb      	strh	r3, [r7, #22]

                lv_coord_t i;
                for(i = 0; i < seg_size; i++) {
 8019abe:	2300      	movs	r3, #0
 8019ac0:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
 8019ac4:	e193      	b.n	8019dee <lv_draw_rect_border_corner+0x8de>
                    lv_opa_t aa_opa;

                    if(seg_size > CIRCLE_AA_NON_LINEAR_OPA_THRESHOLD) { /*Use non-linear opa mapping
 8019ac6:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 8019aca:	2b01      	cmp	r3, #1
 8019acc:	dd10      	ble.n	8019af0 <lv_draw_rect_border_corner+0x5e0>
                                                                           on the first segment*/
                        aa_opa = opa - antialias_get_opa_circ(seg_size, i, opa);
 8019ace:	f897 2059 	ldrb.w	r2, [r7, #89]	; 0x59
 8019ad2:	f9b7 1062 	ldrsh.w	r1, [r7, #98]	; 0x62
 8019ad6:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 8019ada:	4618      	mov	r0, r3
 8019adc:	f001 fe9c 	bl	801b818 <antialias_get_opa_circ>
 8019ae0:	4603      	mov	r3, r0
 8019ae2:	461a      	mov	r2, r3
 8019ae4:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 8019ae8:	1a9b      	subs	r3, r3, r2
 8019aea:	f887 3061 	strb.w	r3, [r7, #97]	; 0x61
 8019aee:	e00b      	b.n	8019b08 <lv_draw_rect_border_corner+0x5f8>
                    } else {
                        aa_opa = lv_draw_aa_get_opa(seg_size, i, opa);
 8019af0:	f897 2059 	ldrb.w	r2, [r7, #89]	; 0x59
 8019af4:	f9b7 1062 	ldrsh.w	r1, [r7, #98]	; 0x62
 8019af8:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 8019afc:	4618      	mov	r0, r3
 8019afe:	f7fb fc9d 	bl	801543c <lv_draw_aa_get_opa>
 8019b02:	4603      	mov	r3, r0
 8019b04:	f887 3061 	strb.w	r3, [r7, #97]	; 0x61
                    }

                    if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
 8019b08:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8019b0c:	f003 0301 	and.w	r3, r3, #1
 8019b10:	2b00      	cmp	r3, #0
 8019b12:	d025      	beq.n	8019b60 <lv_draw_rect_border_corner+0x650>
 8019b14:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8019b18:	f003 0308 	and.w	r3, r3, #8
 8019b1c:	2b00      	cmp	r3, #0
 8019b1e:	d01f      	beq.n	8019b60 <lv_draw_rect_border_corner+0x650>
                        lv_draw_px(rb_origo.x + LV_CIRC_OCT1_X(aa_p) - 1, rb_origo.y + LV_CIRC_OCT1_Y(aa_p) + i, mask,
 8019b20:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8019b24:	b29a      	uxth	r2, r3
 8019b26:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8019b2a:	b29b      	uxth	r3, r3
 8019b2c:	4413      	add	r3, r2
 8019b2e:	b29b      	uxth	r3, r3
 8019b30:	3b01      	subs	r3, #1
 8019b32:	b29b      	uxth	r3, r3
 8019b34:	b218      	sxth	r0, r3
 8019b36:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8019b3a:	b29a      	uxth	r2, r3
 8019b3c:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8019b40:	b29b      	uxth	r3, r3
 8019b42:	4413      	add	r3, r2
 8019b44:	b29a      	uxth	r2, r3
 8019b46:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 8019b4a:	4413      	add	r3, r2
 8019b4c:	b29b      	uxth	r3, r3
 8019b4e:	b219      	sxth	r1, r3
 8019b50:	687b      	ldr	r3, [r7, #4]
 8019b52:	f897 2061 	ldrb.w	r2, [r7, #97]	; 0x61
 8019b56:	9200      	str	r2, [sp, #0]
 8019b58:	895b      	ldrh	r3, [r3, #10]
 8019b5a:	68ba      	ldr	r2, [r7, #8]
 8019b5c:	f7fc f8e4 	bl	8015d28 <lv_draw_px>
                                   style->body.border.color, aa_opa);
                    }

                    if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
 8019b60:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8019b64:	f003 0301 	and.w	r3, r3, #1
 8019b68:	2b00      	cmp	r3, #0
 8019b6a:	d025      	beq.n	8019bb8 <lv_draw_rect_border_corner+0x6a8>
 8019b6c:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8019b70:	f003 0304 	and.w	r3, r3, #4
 8019b74:	2b00      	cmp	r3, #0
 8019b76:	d01f      	beq.n	8019bb8 <lv_draw_rect_border_corner+0x6a8>
                        lv_draw_px(lb_origo.x + LV_CIRC_OCT3_X(aa_p) - i, lb_origo.y + LV_CIRC_OCT3_Y(aa_p) - 1, mask,
 8019b78:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 8019b7c:	b29a      	uxth	r2, r3
 8019b7e:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8019b82:	b29b      	uxth	r3, r3
 8019b84:	1ad3      	subs	r3, r2, r3
 8019b86:	b29a      	uxth	r2, r3
 8019b88:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 8019b8c:	1ad3      	subs	r3, r2, r3
 8019b8e:	b29b      	uxth	r3, r3
 8019b90:	b218      	sxth	r0, r3
 8019b92:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8019b96:	b29a      	uxth	r2, r3
 8019b98:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8019b9c:	b29b      	uxth	r3, r3
 8019b9e:	4413      	add	r3, r2
 8019ba0:	b29b      	uxth	r3, r3
 8019ba2:	3b01      	subs	r3, #1
 8019ba4:	b29b      	uxth	r3, r3
 8019ba6:	b219      	sxth	r1, r3
 8019ba8:	687b      	ldr	r3, [r7, #4]
 8019baa:	f897 2061 	ldrb.w	r2, [r7, #97]	; 0x61
 8019bae:	9200      	str	r2, [sp, #0]
 8019bb0:	895b      	ldrh	r3, [r3, #10]
 8019bb2:	68ba      	ldr	r2, [r7, #8]
 8019bb4:	f7fc f8b8 	bl	8015d28 <lv_draw_px>
                                   style->body.border.color, aa_opa);
                    }

                    if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
 8019bb8:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8019bbc:	f003 0302 	and.w	r3, r3, #2
 8019bc0:	2b00      	cmp	r3, #0
 8019bc2:	d025      	beq.n	8019c10 <lv_draw_rect_border_corner+0x700>
 8019bc4:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8019bc8:	f003 0304 	and.w	r3, r3, #4
 8019bcc:	2b00      	cmp	r3, #0
 8019bce:	d01f      	beq.n	8019c10 <lv_draw_rect_border_corner+0x700>
                        lv_draw_px(lt_origo.x + LV_CIRC_OCT5_X(aa_p) + 1, lt_origo.y + LV_CIRC_OCT5_Y(aa_p) - i, mask,
 8019bd0:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 8019bd4:	b29a      	uxth	r2, r3
 8019bd6:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8019bda:	b29b      	uxth	r3, r3
 8019bdc:	1ad3      	subs	r3, r2, r3
 8019bde:	b29b      	uxth	r3, r3
 8019be0:	3301      	adds	r3, #1
 8019be2:	b29b      	uxth	r3, r3
 8019be4:	b218      	sxth	r0, r3
 8019be6:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 8019bea:	b29a      	uxth	r2, r3
 8019bec:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8019bf0:	b29b      	uxth	r3, r3
 8019bf2:	1ad3      	subs	r3, r2, r3
 8019bf4:	b29a      	uxth	r2, r3
 8019bf6:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 8019bfa:	1ad3      	subs	r3, r2, r3
 8019bfc:	b29b      	uxth	r3, r3
 8019bfe:	b219      	sxth	r1, r3
 8019c00:	687b      	ldr	r3, [r7, #4]
 8019c02:	f897 2061 	ldrb.w	r2, [r7, #97]	; 0x61
 8019c06:	9200      	str	r2, [sp, #0]
 8019c08:	895b      	ldrh	r3, [r3, #10]
 8019c0a:	68ba      	ldr	r2, [r7, #8]
 8019c0c:	f7fc f88c 	bl	8015d28 <lv_draw_px>
                                   style->body.border.color, aa_opa);
                    }

                    if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
 8019c10:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8019c14:	f003 0302 	and.w	r3, r3, #2
 8019c18:	2b00      	cmp	r3, #0
 8019c1a:	d025      	beq.n	8019c68 <lv_draw_rect_border_corner+0x758>
 8019c1c:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8019c20:	f003 0308 	and.w	r3, r3, #8
 8019c24:	2b00      	cmp	r3, #0
 8019c26:	d01f      	beq.n	8019c68 <lv_draw_rect_border_corner+0x758>
                        lv_draw_px(rt_origo.x + LV_CIRC_OCT7_X(aa_p) + i, rt_origo.y + LV_CIRC_OCT7_Y(aa_p) + 1, mask,
 8019c28:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 8019c2c:	b29a      	uxth	r2, r3
 8019c2e:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8019c32:	b29b      	uxth	r3, r3
 8019c34:	4413      	add	r3, r2
 8019c36:	b29a      	uxth	r2, r3
 8019c38:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 8019c3c:	4413      	add	r3, r2
 8019c3e:	b29b      	uxth	r3, r3
 8019c40:	b218      	sxth	r0, r3
 8019c42:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8019c46:	b29a      	uxth	r2, r3
 8019c48:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8019c4c:	b29b      	uxth	r3, r3
 8019c4e:	1ad3      	subs	r3, r2, r3
 8019c50:	b29b      	uxth	r3, r3
 8019c52:	3301      	adds	r3, #1
 8019c54:	b29b      	uxth	r3, r3
 8019c56:	b219      	sxth	r1, r3
 8019c58:	687b      	ldr	r3, [r7, #4]
 8019c5a:	f897 2061 	ldrb.w	r2, [r7, #97]	; 0x61
 8019c5e:	9200      	str	r2, [sp, #0]
 8019c60:	895b      	ldrh	r3, [r3, #10]
 8019c62:	68ba      	ldr	r2, [r7, #8]
 8019c64:	f7fc f860 	bl	8015d28 <lv_draw_px>
                                   style->body.border.color, aa_opa);
                    }

                    /*Be sure the pixels on the middle are not drawn twice*/
                    if(LV_CIRC_OCT1_X(aa_p) - 1 != LV_CIRC_OCT2_X(aa_p) + i) {
 8019c68:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8019c6c:	1e5a      	subs	r2, r3, #1
 8019c6e:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8019c72:	4619      	mov	r1, r3
 8019c74:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 8019c78:	440b      	add	r3, r1
 8019c7a:	429a      	cmp	r2, r3
 8019c7c:	f000 80b0 	beq.w	8019de0 <lv_draw_rect_border_corner+0x8d0>
                        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
 8019c80:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8019c84:	f003 0301 	and.w	r3, r3, #1
 8019c88:	2b00      	cmp	r3, #0
 8019c8a:	d025      	beq.n	8019cd8 <lv_draw_rect_border_corner+0x7c8>
 8019c8c:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8019c90:	f003 0308 	and.w	r3, r3, #8
 8019c94:	2b00      	cmp	r3, #0
 8019c96:	d01f      	beq.n	8019cd8 <lv_draw_rect_border_corner+0x7c8>
                            lv_draw_px(rb_origo.x + LV_CIRC_OCT2_X(aa_p) + i, rb_origo.y + LV_CIRC_OCT2_Y(aa_p) - 1,
 8019c98:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8019c9c:	b29a      	uxth	r2, r3
 8019c9e:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8019ca2:	b29b      	uxth	r3, r3
 8019ca4:	4413      	add	r3, r2
 8019ca6:	b29a      	uxth	r2, r3
 8019ca8:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 8019cac:	4413      	add	r3, r2
 8019cae:	b29b      	uxth	r3, r3
 8019cb0:	b218      	sxth	r0, r3
 8019cb2:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8019cb6:	b29a      	uxth	r2, r3
 8019cb8:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8019cbc:	b29b      	uxth	r3, r3
 8019cbe:	4413      	add	r3, r2
 8019cc0:	b29b      	uxth	r3, r3
 8019cc2:	3b01      	subs	r3, #1
 8019cc4:	b29b      	uxth	r3, r3
 8019cc6:	b219      	sxth	r1, r3
 8019cc8:	687b      	ldr	r3, [r7, #4]
 8019cca:	f897 2061 	ldrb.w	r2, [r7, #97]	; 0x61
 8019cce:	9200      	str	r2, [sp, #0]
 8019cd0:	895b      	ldrh	r3, [r3, #10]
 8019cd2:	68ba      	ldr	r2, [r7, #8]
 8019cd4:	f7fc f828 	bl	8015d28 <lv_draw_px>
                                       mask, style->body.border.color, aa_opa);
                        }

                        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
 8019cd8:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8019cdc:	f003 0301 	and.w	r3, r3, #1
 8019ce0:	2b00      	cmp	r3, #0
 8019ce2:	d025      	beq.n	8019d30 <lv_draw_rect_border_corner+0x820>
 8019ce4:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8019ce8:	f003 0304 	and.w	r3, r3, #4
 8019cec:	2b00      	cmp	r3, #0
 8019cee:	d01f      	beq.n	8019d30 <lv_draw_rect_border_corner+0x820>
                            lv_draw_px(lb_origo.x + LV_CIRC_OCT4_X(aa_p) + 1, lb_origo.y + LV_CIRC_OCT4_Y(aa_p) + i,
 8019cf0:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 8019cf4:	b29a      	uxth	r2, r3
 8019cf6:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8019cfa:	b29b      	uxth	r3, r3
 8019cfc:	1ad3      	subs	r3, r2, r3
 8019cfe:	b29b      	uxth	r3, r3
 8019d00:	3301      	adds	r3, #1
 8019d02:	b29b      	uxth	r3, r3
 8019d04:	b218      	sxth	r0, r3
 8019d06:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8019d0a:	b29a      	uxth	r2, r3
 8019d0c:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8019d10:	b29b      	uxth	r3, r3
 8019d12:	4413      	add	r3, r2
 8019d14:	b29a      	uxth	r2, r3
 8019d16:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 8019d1a:	4413      	add	r3, r2
 8019d1c:	b29b      	uxth	r3, r3
 8019d1e:	b219      	sxth	r1, r3
 8019d20:	687b      	ldr	r3, [r7, #4]
 8019d22:	f897 2061 	ldrb.w	r2, [r7, #97]	; 0x61
 8019d26:	9200      	str	r2, [sp, #0]
 8019d28:	895b      	ldrh	r3, [r3, #10]
 8019d2a:	68ba      	ldr	r2, [r7, #8]
 8019d2c:	f7fb fffc 	bl	8015d28 <lv_draw_px>
                                       mask, style->body.border.color, aa_opa);
                        }

                        if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
 8019d30:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8019d34:	f003 0302 	and.w	r3, r3, #2
 8019d38:	2b00      	cmp	r3, #0
 8019d3a:	d025      	beq.n	8019d88 <lv_draw_rect_border_corner+0x878>
 8019d3c:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8019d40:	f003 0304 	and.w	r3, r3, #4
 8019d44:	2b00      	cmp	r3, #0
 8019d46:	d01f      	beq.n	8019d88 <lv_draw_rect_border_corner+0x878>
                            lv_draw_px(lt_origo.x + LV_CIRC_OCT6_X(aa_p) - i, lt_origo.y + LV_CIRC_OCT6_Y(aa_p) + 1,
 8019d48:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 8019d4c:	b29a      	uxth	r2, r3
 8019d4e:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8019d52:	b29b      	uxth	r3, r3
 8019d54:	1ad3      	subs	r3, r2, r3
 8019d56:	b29a      	uxth	r2, r3
 8019d58:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 8019d5c:	1ad3      	subs	r3, r2, r3
 8019d5e:	b29b      	uxth	r3, r3
 8019d60:	b218      	sxth	r0, r3
 8019d62:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 8019d66:	b29a      	uxth	r2, r3
 8019d68:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8019d6c:	b29b      	uxth	r3, r3
 8019d6e:	1ad3      	subs	r3, r2, r3
 8019d70:	b29b      	uxth	r3, r3
 8019d72:	3301      	adds	r3, #1
 8019d74:	b29b      	uxth	r3, r3
 8019d76:	b219      	sxth	r1, r3
 8019d78:	687b      	ldr	r3, [r7, #4]
 8019d7a:	f897 2061 	ldrb.w	r2, [r7, #97]	; 0x61
 8019d7e:	9200      	str	r2, [sp, #0]
 8019d80:	895b      	ldrh	r3, [r3, #10]
 8019d82:	68ba      	ldr	r2, [r7, #8]
 8019d84:	f7fb ffd0 	bl	8015d28 <lv_draw_px>
                                       mask, style->body.border.color, aa_opa);
                        }

                        if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
 8019d88:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8019d8c:	f003 0302 	and.w	r3, r3, #2
 8019d90:	2b00      	cmp	r3, #0
 8019d92:	d025      	beq.n	8019de0 <lv_draw_rect_border_corner+0x8d0>
 8019d94:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8019d98:	f003 0308 	and.w	r3, r3, #8
 8019d9c:	2b00      	cmp	r3, #0
 8019d9e:	d01f      	beq.n	8019de0 <lv_draw_rect_border_corner+0x8d0>
                            lv_draw_px(rt_origo.x + LV_CIRC_OCT8_X(aa_p) - 1, rt_origo.y + LV_CIRC_OCT8_Y(aa_p) - i,
 8019da0:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 8019da4:	b29a      	uxth	r2, r3
 8019da6:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8019daa:	b29b      	uxth	r3, r3
 8019dac:	4413      	add	r3, r2
 8019dae:	b29b      	uxth	r3, r3
 8019db0:	3b01      	subs	r3, #1
 8019db2:	b29b      	uxth	r3, r3
 8019db4:	b218      	sxth	r0, r3
 8019db6:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8019dba:	b29a      	uxth	r2, r3
 8019dbc:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8019dc0:	b29b      	uxth	r3, r3
 8019dc2:	1ad3      	subs	r3, r2, r3
 8019dc4:	b29a      	uxth	r2, r3
 8019dc6:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 8019dca:	1ad3      	subs	r3, r2, r3
 8019dcc:	b29b      	uxth	r3, r3
 8019dce:	b219      	sxth	r1, r3
 8019dd0:	687b      	ldr	r3, [r7, #4]
 8019dd2:	f897 2061 	ldrb.w	r2, [r7, #97]	; 0x61
 8019dd6:	9200      	str	r2, [sp, #0]
 8019dd8:	895b      	ldrh	r3, [r3, #10]
 8019dda:	68ba      	ldr	r2, [r7, #8]
 8019ddc:	f7fb ffa4 	bl	8015d28 <lv_draw_px>
                for(i = 0; i < seg_size; i++) {
 8019de0:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 8019de4:	b29b      	uxth	r3, r3
 8019de6:	3301      	adds	r3, #1
 8019de8:	b29b      	uxth	r3, r3
 8019dea:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
 8019dee:	f9b7 2062 	ldrsh.w	r2, [r7, #98]	; 0x62
 8019df2:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 8019df6:	429a      	cmp	r2, r3
 8019df8:	f6ff ae65 	blt.w	8019ac6 <lv_draw_rect_border_corner+0x5b6>
                                       mask, style->body.border.color, aa_opa);
                        }
                    }
                }

                in_x_last      = cir_in.x;
 8019dfc:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8019dfe:	f8a7 3068 	strh.w	r3, [r7, #104]	; 0x68
                in_y_seg_start = in_y_seg_end;
 8019e02:	f8b7 3050 	ldrh.w	r3, [r7, #80]	; 0x50
 8019e06:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
            }
        }
#endif

        /*Draw the octets to the right bottom corner*/
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
 8019e0a:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8019e0e:	f003 0301 	and.w	r3, r3, #1
 8019e12:	2b00      	cmp	r3, #0
 8019e14:	d06f      	beq.n	8019ef6 <lv_draw_rect_border_corner+0x9e6>
 8019e16:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8019e1a:	f003 0308 	and.w	r3, r3, #8
 8019e1e:	2b00      	cmp	r3, #0
 8019e20:	d069      	beq.n	8019ef6 <lv_draw_rect_border_corner+0x9e6>
            circ_area.x1 = rb_origo.x + LV_CIRC_OCT1_X(cir_out) - act_w2;
 8019e22:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8019e26:	b29a      	uxth	r2, r3
 8019e28:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8019e2c:	b29b      	uxth	r3, r3
 8019e2e:	4413      	add	r3, r2
 8019e30:	b29a      	uxth	r2, r3
 8019e32:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
 8019e36:	1ad3      	subs	r3, r2, r3
 8019e38:	b29b      	uxth	r3, r3
 8019e3a:	b21b      	sxth	r3, r3
 8019e3c:	83bb      	strh	r3, [r7, #28]
            circ_area.x2 = rb_origo.x + LV_CIRC_OCT1_X(cir_out);
 8019e3e:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8019e42:	b29a      	uxth	r2, r3
 8019e44:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8019e48:	b29b      	uxth	r3, r3
 8019e4a:	4413      	add	r3, r2
 8019e4c:	b29b      	uxth	r3, r3
 8019e4e:	b21b      	sxth	r3, r3
 8019e50:	843b      	strh	r3, [r7, #32]
            circ_area.y1 = rb_origo.y + LV_CIRC_OCT1_Y(cir_out);
 8019e52:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8019e56:	b29a      	uxth	r2, r3
 8019e58:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8019e5c:	b29b      	uxth	r3, r3
 8019e5e:	4413      	add	r3, r2
 8019e60:	b29b      	uxth	r3, r3
 8019e62:	b21b      	sxth	r3, r3
 8019e64:	83fb      	strh	r3, [r7, #30]
            circ_area.y2 = rb_origo.y + LV_CIRC_OCT1_Y(cir_out);
 8019e66:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8019e6a:	b29a      	uxth	r2, r3
 8019e6c:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8019e70:	b29b      	uxth	r3, r3
 8019e72:	4413      	add	r3, r2
 8019e74:	b29b      	uxth	r3, r3
 8019e76:	b21b      	sxth	r3, r3
 8019e78:	847b      	strh	r3, [r7, #34]	; 0x22
            lv_draw_fill(&circ_area, mask, color, opa);
 8019e7a:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 8019e7e:	f107 001c 	add.w	r0, r7, #28
 8019e82:	f8b7 2044 	ldrh.w	r2, [r7, #68]	; 0x44
 8019e86:	68b9      	ldr	r1, [r7, #8]
 8019e88:	f7fb ffe6 	bl	8015e58 <lv_draw_fill>

            circ_area.x1 = rb_origo.x + LV_CIRC_OCT2_X(cir_out);
 8019e8c:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8019e90:	b29a      	uxth	r2, r3
 8019e92:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8019e96:	b29b      	uxth	r3, r3
 8019e98:	4413      	add	r3, r2
 8019e9a:	b29b      	uxth	r3, r3
 8019e9c:	b21b      	sxth	r3, r3
 8019e9e:	83bb      	strh	r3, [r7, #28]
            circ_area.x2 = rb_origo.x + LV_CIRC_OCT2_X(cir_out);
 8019ea0:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8019ea4:	b29a      	uxth	r2, r3
 8019ea6:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8019eaa:	b29b      	uxth	r3, r3
 8019eac:	4413      	add	r3, r2
 8019eae:	b29b      	uxth	r3, r3
 8019eb0:	b21b      	sxth	r3, r3
 8019eb2:	843b      	strh	r3, [r7, #32]
            circ_area.y1 = rb_origo.y + LV_CIRC_OCT2_Y(cir_out) - act_w1;
 8019eb4:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8019eb8:	b29a      	uxth	r2, r3
 8019eba:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8019ebe:	b29b      	uxth	r3, r3
 8019ec0:	4413      	add	r3, r2
 8019ec2:	b29a      	uxth	r2, r3
 8019ec4:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
 8019ec8:	1ad3      	subs	r3, r2, r3
 8019eca:	b29b      	uxth	r3, r3
 8019ecc:	b21b      	sxth	r3, r3
 8019ece:	83fb      	strh	r3, [r7, #30]
            circ_area.y2 = rb_origo.y + LV_CIRC_OCT2_Y(cir_out);
 8019ed0:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8019ed4:	b29a      	uxth	r2, r3
 8019ed6:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8019eda:	b29b      	uxth	r3, r3
 8019edc:	4413      	add	r3, r2
 8019ede:	b29b      	uxth	r3, r3
 8019ee0:	b21b      	sxth	r3, r3
 8019ee2:	847b      	strh	r3, [r7, #34]	; 0x22
            lv_draw_fill(&circ_area, mask, color, opa);
 8019ee4:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 8019ee8:	f107 001c 	add.w	r0, r7, #28
 8019eec:	f8b7 2044 	ldrh.w	r2, [r7, #68]	; 0x44
 8019ef0:	68b9      	ldr	r1, [r7, #8]
 8019ef2:	f7fb ffb1 	bl	8015e58 <lv_draw_fill>
        }

        /*Draw the octets to the left bottom corner*/
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
 8019ef6:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8019efa:	f003 0301 	and.w	r3, r3, #1
 8019efe:	2b00      	cmp	r3, #0
 8019f00:	d06f      	beq.n	8019fe2 <lv_draw_rect_border_corner+0xad2>
 8019f02:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8019f06:	f003 0304 	and.w	r3, r3, #4
 8019f0a:	2b00      	cmp	r3, #0
 8019f0c:	d069      	beq.n	8019fe2 <lv_draw_rect_border_corner+0xad2>
            circ_area.x1 = lb_origo.x + LV_CIRC_OCT3_X(cir_out);
 8019f0e:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 8019f12:	b29a      	uxth	r2, r3
 8019f14:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8019f18:	b29b      	uxth	r3, r3
 8019f1a:	1ad3      	subs	r3, r2, r3
 8019f1c:	b29b      	uxth	r3, r3
 8019f1e:	b21b      	sxth	r3, r3
 8019f20:	83bb      	strh	r3, [r7, #28]
            circ_area.x2 = lb_origo.x + LV_CIRC_OCT3_X(cir_out);
 8019f22:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 8019f26:	b29a      	uxth	r2, r3
 8019f28:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8019f2c:	b29b      	uxth	r3, r3
 8019f2e:	1ad3      	subs	r3, r2, r3
 8019f30:	b29b      	uxth	r3, r3
 8019f32:	b21b      	sxth	r3, r3
 8019f34:	843b      	strh	r3, [r7, #32]
            circ_area.y1 = lb_origo.y + LV_CIRC_OCT3_Y(cir_out) - act_w2;
 8019f36:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8019f3a:	b29a      	uxth	r2, r3
 8019f3c:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8019f40:	b29b      	uxth	r3, r3
 8019f42:	4413      	add	r3, r2
 8019f44:	b29a      	uxth	r2, r3
 8019f46:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
 8019f4a:	1ad3      	subs	r3, r2, r3
 8019f4c:	b29b      	uxth	r3, r3
 8019f4e:	b21b      	sxth	r3, r3
 8019f50:	83fb      	strh	r3, [r7, #30]
            circ_area.y2 = lb_origo.y + LV_CIRC_OCT3_Y(cir_out);
 8019f52:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8019f56:	b29a      	uxth	r2, r3
 8019f58:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8019f5c:	b29b      	uxth	r3, r3
 8019f5e:	4413      	add	r3, r2
 8019f60:	b29b      	uxth	r3, r3
 8019f62:	b21b      	sxth	r3, r3
 8019f64:	847b      	strh	r3, [r7, #34]	; 0x22
            lv_draw_fill(&circ_area, mask, color, opa);
 8019f66:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 8019f6a:	f107 001c 	add.w	r0, r7, #28
 8019f6e:	f8b7 2044 	ldrh.w	r2, [r7, #68]	; 0x44
 8019f72:	68b9      	ldr	r1, [r7, #8]
 8019f74:	f7fb ff70 	bl	8015e58 <lv_draw_fill>

            circ_area.x1 = lb_origo.x + LV_CIRC_OCT4_X(cir_out);
 8019f78:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 8019f7c:	b29a      	uxth	r2, r3
 8019f7e:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8019f82:	b29b      	uxth	r3, r3
 8019f84:	1ad3      	subs	r3, r2, r3
 8019f86:	b29b      	uxth	r3, r3
 8019f88:	b21b      	sxth	r3, r3
 8019f8a:	83bb      	strh	r3, [r7, #28]
            circ_area.x2 = lb_origo.x + LV_CIRC_OCT4_X(cir_out) + act_w1;
 8019f8c:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 8019f90:	b29a      	uxth	r2, r3
 8019f92:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8019f96:	b29b      	uxth	r3, r3
 8019f98:	1ad3      	subs	r3, r2, r3
 8019f9a:	b29a      	uxth	r2, r3
 8019f9c:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
 8019fa0:	4413      	add	r3, r2
 8019fa2:	b29b      	uxth	r3, r3
 8019fa4:	b21b      	sxth	r3, r3
 8019fa6:	843b      	strh	r3, [r7, #32]
            circ_area.y1 = lb_origo.y + LV_CIRC_OCT4_Y(cir_out);
 8019fa8:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8019fac:	b29a      	uxth	r2, r3
 8019fae:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8019fb2:	b29b      	uxth	r3, r3
 8019fb4:	4413      	add	r3, r2
 8019fb6:	b29b      	uxth	r3, r3
 8019fb8:	b21b      	sxth	r3, r3
 8019fba:	83fb      	strh	r3, [r7, #30]
            circ_area.y2 = lb_origo.y + LV_CIRC_OCT4_Y(cir_out);
 8019fbc:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8019fc0:	b29a      	uxth	r2, r3
 8019fc2:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8019fc6:	b29b      	uxth	r3, r3
 8019fc8:	4413      	add	r3, r2
 8019fca:	b29b      	uxth	r3, r3
 8019fcc:	b21b      	sxth	r3, r3
 8019fce:	847b      	strh	r3, [r7, #34]	; 0x22
            lv_draw_fill(&circ_area, mask, color, opa);
 8019fd0:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 8019fd4:	f107 001c 	add.w	r0, r7, #28
 8019fd8:	f8b7 2044 	ldrh.w	r2, [r7, #68]	; 0x44
 8019fdc:	68b9      	ldr	r1, [r7, #8]
 8019fde:	f7fb ff3b 	bl	8015e58 <lv_draw_fill>
        }

        /*Draw the octets to the left top corner*/
        if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
 8019fe2:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8019fe6:	f003 0302 	and.w	r3, r3, #2
 8019fea:	2b00      	cmp	r3, #0
 8019fec:	d07d      	beq.n	801a0ea <lv_draw_rect_border_corner+0xbda>
 8019fee:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8019ff2:	f003 0304 	and.w	r3, r3, #4
 8019ff6:	2b00      	cmp	r3, #0
 8019ff8:	d077      	beq.n	801a0ea <lv_draw_rect_border_corner+0xbda>
            if(lb_origo.y + LV_CIRC_OCT4_Y(cir_out) > lt_origo.y + LV_CIRC_OCT5_Y(cir_out)) {
 8019ffa:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8019ffe:	461a      	mov	r2, r3
 801a000:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 801a004:	441a      	add	r2, r3
 801a006:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 801a00a:	4619      	mov	r1, r3
 801a00c:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 801a010:	1acb      	subs	r3, r1, r3
 801a012:	429a      	cmp	r2, r3
 801a014:	dd34      	ble.n	801a080 <lv_draw_rect_border_corner+0xb70>
                /*Don't draw if the lines are common in the middle*/
                circ_area.x1 = lt_origo.x + LV_CIRC_OCT5_X(cir_out);
 801a016:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 801a01a:	b29a      	uxth	r2, r3
 801a01c:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 801a020:	b29b      	uxth	r3, r3
 801a022:	1ad3      	subs	r3, r2, r3
 801a024:	b29b      	uxth	r3, r3
 801a026:	b21b      	sxth	r3, r3
 801a028:	83bb      	strh	r3, [r7, #28]
                circ_area.x2 = lt_origo.x + LV_CIRC_OCT5_X(cir_out) + act_w2;
 801a02a:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 801a02e:	b29a      	uxth	r2, r3
 801a030:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 801a034:	b29b      	uxth	r3, r3
 801a036:	1ad3      	subs	r3, r2, r3
 801a038:	b29a      	uxth	r2, r3
 801a03a:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
 801a03e:	4413      	add	r3, r2
 801a040:	b29b      	uxth	r3, r3
 801a042:	b21b      	sxth	r3, r3
 801a044:	843b      	strh	r3, [r7, #32]
                circ_area.y1 = lt_origo.y + LV_CIRC_OCT5_Y(cir_out);
 801a046:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 801a04a:	b29a      	uxth	r2, r3
 801a04c:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 801a050:	b29b      	uxth	r3, r3
 801a052:	1ad3      	subs	r3, r2, r3
 801a054:	b29b      	uxth	r3, r3
 801a056:	b21b      	sxth	r3, r3
 801a058:	83fb      	strh	r3, [r7, #30]
                circ_area.y2 = lt_origo.y + LV_CIRC_OCT5_Y(cir_out);
 801a05a:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 801a05e:	b29a      	uxth	r2, r3
 801a060:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 801a064:	b29b      	uxth	r3, r3
 801a066:	1ad3      	subs	r3, r2, r3
 801a068:	b29b      	uxth	r3, r3
 801a06a:	b21b      	sxth	r3, r3
 801a06c:	847b      	strh	r3, [r7, #34]	; 0x22
                lv_draw_fill(&circ_area, mask, color, opa);
 801a06e:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 801a072:	f107 001c 	add.w	r0, r7, #28
 801a076:	f8b7 2044 	ldrh.w	r2, [r7, #68]	; 0x44
 801a07a:	68b9      	ldr	r1, [r7, #8]
 801a07c:	f7fb feec 	bl	8015e58 <lv_draw_fill>
            }

            circ_area.x1 = lt_origo.x + LV_CIRC_OCT6_X(cir_out);
 801a080:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 801a084:	b29a      	uxth	r2, r3
 801a086:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 801a08a:	b29b      	uxth	r3, r3
 801a08c:	1ad3      	subs	r3, r2, r3
 801a08e:	b29b      	uxth	r3, r3
 801a090:	b21b      	sxth	r3, r3
 801a092:	83bb      	strh	r3, [r7, #28]
            circ_area.x2 = lt_origo.x + LV_CIRC_OCT6_X(cir_out);
 801a094:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 801a098:	b29a      	uxth	r2, r3
 801a09a:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 801a09e:	b29b      	uxth	r3, r3
 801a0a0:	1ad3      	subs	r3, r2, r3
 801a0a2:	b29b      	uxth	r3, r3
 801a0a4:	b21b      	sxth	r3, r3
 801a0a6:	843b      	strh	r3, [r7, #32]
            circ_area.y1 = lt_origo.y + LV_CIRC_OCT6_Y(cir_out);
 801a0a8:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 801a0ac:	b29a      	uxth	r2, r3
 801a0ae:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 801a0b2:	b29b      	uxth	r3, r3
 801a0b4:	1ad3      	subs	r3, r2, r3
 801a0b6:	b29b      	uxth	r3, r3
 801a0b8:	b21b      	sxth	r3, r3
 801a0ba:	83fb      	strh	r3, [r7, #30]
            circ_area.y2 = lt_origo.y + LV_CIRC_OCT6_Y(cir_out) + act_w1;
 801a0bc:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 801a0c0:	b29a      	uxth	r2, r3
 801a0c2:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 801a0c6:	b29b      	uxth	r3, r3
 801a0c8:	1ad3      	subs	r3, r2, r3
 801a0ca:	b29a      	uxth	r2, r3
 801a0cc:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
 801a0d0:	4413      	add	r3, r2
 801a0d2:	b29b      	uxth	r3, r3
 801a0d4:	b21b      	sxth	r3, r3
 801a0d6:	847b      	strh	r3, [r7, #34]	; 0x22
            lv_draw_fill(&circ_area, mask, color, opa);
 801a0d8:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 801a0dc:	f107 001c 	add.w	r0, r7, #28
 801a0e0:	f8b7 2044 	ldrh.w	r2, [r7, #68]	; 0x44
 801a0e4:	68b9      	ldr	r1, [r7, #8]
 801a0e6:	f7fb feb7 	bl	8015e58 <lv_draw_fill>
        }

        /*Draw the octets to the right top corner*/
        if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
 801a0ea:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a0ee:	f003 0302 	and.w	r3, r3, #2
 801a0f2:	2b00      	cmp	r3, #0
 801a0f4:	d07d      	beq.n	801a1f2 <lv_draw_rect_border_corner+0xce2>
 801a0f6:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a0fa:	f003 0308 	and.w	r3, r3, #8
 801a0fe:	2b00      	cmp	r3, #0
 801a100:	d077      	beq.n	801a1f2 <lv_draw_rect_border_corner+0xce2>
            circ_area.x1 = rt_origo.x + LV_CIRC_OCT7_X(cir_out);
 801a102:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 801a106:	b29a      	uxth	r2, r3
 801a108:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 801a10c:	b29b      	uxth	r3, r3
 801a10e:	4413      	add	r3, r2
 801a110:	b29b      	uxth	r3, r3
 801a112:	b21b      	sxth	r3, r3
 801a114:	83bb      	strh	r3, [r7, #28]
            circ_area.x2 = rt_origo.x + LV_CIRC_OCT7_X(cir_out);
 801a116:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 801a11a:	b29a      	uxth	r2, r3
 801a11c:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 801a120:	b29b      	uxth	r3, r3
 801a122:	4413      	add	r3, r2
 801a124:	b29b      	uxth	r3, r3
 801a126:	b21b      	sxth	r3, r3
 801a128:	843b      	strh	r3, [r7, #32]
            circ_area.y1 = rt_origo.y + LV_CIRC_OCT7_Y(cir_out);
 801a12a:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 801a12e:	b29a      	uxth	r2, r3
 801a130:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 801a134:	b29b      	uxth	r3, r3
 801a136:	1ad3      	subs	r3, r2, r3
 801a138:	b29b      	uxth	r3, r3
 801a13a:	b21b      	sxth	r3, r3
 801a13c:	83fb      	strh	r3, [r7, #30]
            circ_area.y2 = rt_origo.y + LV_CIRC_OCT7_Y(cir_out) + act_w2;
 801a13e:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 801a142:	b29a      	uxth	r2, r3
 801a144:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 801a148:	b29b      	uxth	r3, r3
 801a14a:	1ad3      	subs	r3, r2, r3
 801a14c:	b29a      	uxth	r2, r3
 801a14e:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
 801a152:	4413      	add	r3, r2
 801a154:	b29b      	uxth	r3, r3
 801a156:	b21b      	sxth	r3, r3
 801a158:	847b      	strh	r3, [r7, #34]	; 0x22
            lv_draw_fill(&circ_area, mask, color, opa);
 801a15a:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 801a15e:	f107 001c 	add.w	r0, r7, #28
 801a162:	f8b7 2044 	ldrh.w	r2, [r7, #68]	; 0x44
 801a166:	68b9      	ldr	r1, [r7, #8]
 801a168:	f7fb fe76 	bl	8015e58 <lv_draw_fill>

            /*Don't draw if the lines are common in the middle*/
            if(rb_origo.y + LV_CIRC_OCT1_Y(cir_out) > rt_origo.y + LV_CIRC_OCT8_Y(cir_out)) {
 801a16c:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 801a170:	461a      	mov	r2, r3
 801a172:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 801a176:	441a      	add	r2, r3
 801a178:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 801a17c:	4619      	mov	r1, r3
 801a17e:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 801a182:	1acb      	subs	r3, r1, r3
 801a184:	429a      	cmp	r2, r3
 801a186:	dd34      	ble.n	801a1f2 <lv_draw_rect_border_corner+0xce2>
                circ_area.x1 = rt_origo.x + LV_CIRC_OCT8_X(cir_out) - act_w1;
 801a188:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 801a18c:	b29a      	uxth	r2, r3
 801a18e:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 801a192:	b29b      	uxth	r3, r3
 801a194:	4413      	add	r3, r2
 801a196:	b29a      	uxth	r2, r3
 801a198:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
 801a19c:	1ad3      	subs	r3, r2, r3
 801a19e:	b29b      	uxth	r3, r3
 801a1a0:	b21b      	sxth	r3, r3
 801a1a2:	83bb      	strh	r3, [r7, #28]
                circ_area.x2 = rt_origo.x + LV_CIRC_OCT8_X(cir_out);
 801a1a4:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 801a1a8:	b29a      	uxth	r2, r3
 801a1aa:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 801a1ae:	b29b      	uxth	r3, r3
 801a1b0:	4413      	add	r3, r2
 801a1b2:	b29b      	uxth	r3, r3
 801a1b4:	b21b      	sxth	r3, r3
 801a1b6:	843b      	strh	r3, [r7, #32]
                circ_area.y1 = rt_origo.y + LV_CIRC_OCT8_Y(cir_out);
 801a1b8:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 801a1bc:	b29a      	uxth	r2, r3
 801a1be:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 801a1c2:	b29b      	uxth	r3, r3
 801a1c4:	1ad3      	subs	r3, r2, r3
 801a1c6:	b29b      	uxth	r3, r3
 801a1c8:	b21b      	sxth	r3, r3
 801a1ca:	83fb      	strh	r3, [r7, #30]
                circ_area.y2 = rt_origo.y + LV_CIRC_OCT8_Y(cir_out);
 801a1cc:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 801a1d0:	b29a      	uxth	r2, r3
 801a1d2:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 801a1d6:	b29b      	uxth	r3, r3
 801a1d8:	1ad3      	subs	r3, r2, r3
 801a1da:	b29b      	uxth	r3, r3
 801a1dc:	b21b      	sxth	r3, r3
 801a1de:	847b      	strh	r3, [r7, #34]	; 0x22
                lv_draw_fill(&circ_area, mask, color, opa);
 801a1e0:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 801a1e4:	f107 001c 	add.w	r0, r7, #28
 801a1e8:	f8b7 2044 	ldrh.w	r2, [r7, #68]	; 0x44
 801a1ec:	68b9      	ldr	r1, [r7, #8]
 801a1ee:	f7fb fe33 	bl	8015e58 <lv_draw_fill>
            }
        }
        lv_circ_next(&cir_out, &tmp_out);
 801a1f2:	f107 022e 	add.w	r2, r7, #46	; 0x2e
 801a1f6:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801a1fa:	4611      	mov	r1, r2
 801a1fc:	4618      	mov	r0, r3
 801a1fe:	f003 fc25 	bl	801da4c <lv_circ_next>

        /*The internal circle will be ready faster
         * so check it! */
        if(cir_in.y < cir_in.x) {
 801a202:	f9b7 202a 	ldrsh.w	r2, [r7, #42]	; 0x2a
 801a206:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 801a20a:	429a      	cmp	r2, r3
 801a20c:	da07      	bge.n	801a21e <lv_draw_rect_border_corner+0xd0e>
            lv_circ_next(&cir_in, &tmp_in);
 801a20e:	f107 0226 	add.w	r2, r7, #38	; 0x26
 801a212:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801a216:	4611      	mov	r1, r2
 801a218:	4618      	mov	r0, r3
 801a21a:	f003 fc17 	bl	801da4c <lv_circ_next>
    while(cir_out.y <= cir_out.x) {
 801a21e:	f9b7 2032 	ldrsh.w	r2, [r7, #50]	; 0x32
 801a222:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 801a226:	429a      	cmp	r2, r3
 801a228:	f77f aa85 	ble.w	8019736 <lv_draw_rect_border_corner+0x226>
        }
    }

#if LV_ANTIALIAS
    if(aa) {
 801a22c:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 801a230:	2b00      	cmp	r3, #0
 801a232:	f000 83b0 	beq.w	801a996 <lv_draw_rect_border_corner+0x1486>
        /*Last parts of the outer anti-alias*/
        out_y_seg_end       = cir_out.y;
 801a236:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 801a238:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
        lv_coord_t seg_size = out_y_seg_end - out_y_seg_start;
 801a23c:	f8b7 2052 	ldrh.w	r2, [r7, #82]	; 0x52
 801a240:	f8b7 306e 	ldrh.w	r3, [r7, #110]	; 0x6e
 801a244:	1ad3      	subs	r3, r2, r3
 801a246:	b29b      	uxth	r3, r3
 801a248:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
        lv_point_t aa_p;

        aa_p.x = out_x_last;
 801a24c:	f8b7 306c 	ldrh.w	r3, [r7, #108]	; 0x6c
 801a250:	823b      	strh	r3, [r7, #16]
        aa_p.y = out_y_seg_start;
 801a252:	f8b7 306e 	ldrh.w	r3, [r7, #110]	; 0x6e
 801a256:	827b      	strh	r3, [r7, #18]

        lv_coord_t i;
        for(i = 0; i < seg_size; i++) {
 801a258:	2300      	movs	r3, #0
 801a25a:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
 801a25e:	e146      	b.n	801a4ee <lv_draw_rect_border_corner+0xfde>
            lv_opa_t aa_opa = opa - lv_draw_aa_get_opa(seg_size, i, opa);
 801a260:	f897 2059 	ldrb.w	r2, [r7, #89]	; 0x59
 801a264:	f9b7 105e 	ldrsh.w	r1, [r7, #94]	; 0x5e
 801a268:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 801a26c:	4618      	mov	r0, r3
 801a26e:	f7fb f8e5 	bl	801543c <lv_draw_aa_get_opa>
 801a272:	4603      	mov	r3, r0
 801a274:	461a      	mov	r2, r3
 801a276:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 801a27a:	1a9b      	subs	r3, r3, r2
 801a27c:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
            if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
 801a280:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a284:	f003 0301 	and.w	r3, r3, #1
 801a288:	2b00      	cmp	r3, #0
 801a28a:	d045      	beq.n	801a318 <lv_draw_rect_border_corner+0xe08>
 801a28c:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a290:	f003 0308 	and.w	r3, r3, #8
 801a294:	2b00      	cmp	r3, #0
 801a296:	d03f      	beq.n	801a318 <lv_draw_rect_border_corner+0xe08>
                lv_draw_px(rb_origo.x + LV_CIRC_OCT1_X(aa_p) + 1, rb_origo.y + LV_CIRC_OCT1_Y(aa_p) + i, mask,
 801a298:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 801a29c:	b29a      	uxth	r2, r3
 801a29e:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801a2a2:	b29b      	uxth	r3, r3
 801a2a4:	4413      	add	r3, r2
 801a2a6:	b29b      	uxth	r3, r3
 801a2a8:	3301      	adds	r3, #1
 801a2aa:	b29b      	uxth	r3, r3
 801a2ac:	b218      	sxth	r0, r3
 801a2ae:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 801a2b2:	b29a      	uxth	r2, r3
 801a2b4:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801a2b8:	b29b      	uxth	r3, r3
 801a2ba:	4413      	add	r3, r2
 801a2bc:	b29a      	uxth	r2, r3
 801a2be:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801a2c2:	4413      	add	r3, r2
 801a2c4:	b29b      	uxth	r3, r3
 801a2c6:	b219      	sxth	r1, r3
 801a2c8:	687b      	ldr	r3, [r7, #4]
 801a2ca:	f897 204b 	ldrb.w	r2, [r7, #75]	; 0x4b
 801a2ce:	9200      	str	r2, [sp, #0]
 801a2d0:	895b      	ldrh	r3, [r3, #10]
 801a2d2:	68ba      	ldr	r2, [r7, #8]
 801a2d4:	f7fb fd28 	bl	8015d28 <lv_draw_px>
                           style->body.border.color, aa_opa);
                lv_draw_px(rb_origo.x + LV_CIRC_OCT2_X(aa_p) + i, rb_origo.y + LV_CIRC_OCT2_Y(aa_p) + 1, mask,
 801a2d8:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 801a2dc:	b29a      	uxth	r2, r3
 801a2de:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801a2e2:	b29b      	uxth	r3, r3
 801a2e4:	4413      	add	r3, r2
 801a2e6:	b29a      	uxth	r2, r3
 801a2e8:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801a2ec:	4413      	add	r3, r2
 801a2ee:	b29b      	uxth	r3, r3
 801a2f0:	b218      	sxth	r0, r3
 801a2f2:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 801a2f6:	b29a      	uxth	r2, r3
 801a2f8:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801a2fc:	b29b      	uxth	r3, r3
 801a2fe:	4413      	add	r3, r2
 801a300:	b29b      	uxth	r3, r3
 801a302:	3301      	adds	r3, #1
 801a304:	b29b      	uxth	r3, r3
 801a306:	b219      	sxth	r1, r3
 801a308:	687b      	ldr	r3, [r7, #4]
 801a30a:	f897 204b 	ldrb.w	r2, [r7, #75]	; 0x4b
 801a30e:	9200      	str	r2, [sp, #0]
 801a310:	895b      	ldrh	r3, [r3, #10]
 801a312:	68ba      	ldr	r2, [r7, #8]
 801a314:	f7fb fd08 	bl	8015d28 <lv_draw_px>
                           style->body.border.color, aa_opa);
            }

            if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
 801a318:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a31c:	f003 0301 	and.w	r3, r3, #1
 801a320:	2b00      	cmp	r3, #0
 801a322:	d045      	beq.n	801a3b0 <lv_draw_rect_border_corner+0xea0>
 801a324:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a328:	f003 0304 	and.w	r3, r3, #4
 801a32c:	2b00      	cmp	r3, #0
 801a32e:	d03f      	beq.n	801a3b0 <lv_draw_rect_border_corner+0xea0>
                lv_draw_px(lb_origo.x + LV_CIRC_OCT3_X(aa_p) - i, lb_origo.y + LV_CIRC_OCT3_Y(aa_p) + 1, mask,
 801a330:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 801a334:	b29a      	uxth	r2, r3
 801a336:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801a33a:	b29b      	uxth	r3, r3
 801a33c:	1ad3      	subs	r3, r2, r3
 801a33e:	b29a      	uxth	r2, r3
 801a340:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801a344:	1ad3      	subs	r3, r2, r3
 801a346:	b29b      	uxth	r3, r3
 801a348:	b218      	sxth	r0, r3
 801a34a:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 801a34e:	b29a      	uxth	r2, r3
 801a350:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801a354:	b29b      	uxth	r3, r3
 801a356:	4413      	add	r3, r2
 801a358:	b29b      	uxth	r3, r3
 801a35a:	3301      	adds	r3, #1
 801a35c:	b29b      	uxth	r3, r3
 801a35e:	b219      	sxth	r1, r3
 801a360:	687b      	ldr	r3, [r7, #4]
 801a362:	f897 204b 	ldrb.w	r2, [r7, #75]	; 0x4b
 801a366:	9200      	str	r2, [sp, #0]
 801a368:	895b      	ldrh	r3, [r3, #10]
 801a36a:	68ba      	ldr	r2, [r7, #8]
 801a36c:	f7fb fcdc 	bl	8015d28 <lv_draw_px>
                           style->body.border.color, aa_opa);
                lv_draw_px(lb_origo.x + LV_CIRC_OCT4_X(aa_p) - 1, lb_origo.y + LV_CIRC_OCT4_Y(aa_p) + i, mask,
 801a370:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 801a374:	b29a      	uxth	r2, r3
 801a376:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801a37a:	b29b      	uxth	r3, r3
 801a37c:	1ad3      	subs	r3, r2, r3
 801a37e:	b29b      	uxth	r3, r3
 801a380:	3b01      	subs	r3, #1
 801a382:	b29b      	uxth	r3, r3
 801a384:	b218      	sxth	r0, r3
 801a386:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 801a38a:	b29a      	uxth	r2, r3
 801a38c:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801a390:	b29b      	uxth	r3, r3
 801a392:	4413      	add	r3, r2
 801a394:	b29a      	uxth	r2, r3
 801a396:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801a39a:	4413      	add	r3, r2
 801a39c:	b29b      	uxth	r3, r3
 801a39e:	b219      	sxth	r1, r3
 801a3a0:	687b      	ldr	r3, [r7, #4]
 801a3a2:	f897 204b 	ldrb.w	r2, [r7, #75]	; 0x4b
 801a3a6:	9200      	str	r2, [sp, #0]
 801a3a8:	895b      	ldrh	r3, [r3, #10]
 801a3aa:	68ba      	ldr	r2, [r7, #8]
 801a3ac:	f7fb fcbc 	bl	8015d28 <lv_draw_px>
                           style->body.border.color, aa_opa);
            }

            if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
 801a3b0:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a3b4:	f003 0302 	and.w	r3, r3, #2
 801a3b8:	2b00      	cmp	r3, #0
 801a3ba:	d045      	beq.n	801a448 <lv_draw_rect_border_corner+0xf38>
 801a3bc:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a3c0:	f003 0304 	and.w	r3, r3, #4
 801a3c4:	2b00      	cmp	r3, #0
 801a3c6:	d03f      	beq.n	801a448 <lv_draw_rect_border_corner+0xf38>
                lv_draw_px(lt_origo.x + LV_CIRC_OCT5_X(aa_p) - 1, lt_origo.y + LV_CIRC_OCT5_Y(aa_p) - i, mask,
 801a3c8:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 801a3cc:	b29a      	uxth	r2, r3
 801a3ce:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801a3d2:	b29b      	uxth	r3, r3
 801a3d4:	1ad3      	subs	r3, r2, r3
 801a3d6:	b29b      	uxth	r3, r3
 801a3d8:	3b01      	subs	r3, #1
 801a3da:	b29b      	uxth	r3, r3
 801a3dc:	b218      	sxth	r0, r3
 801a3de:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 801a3e2:	b29a      	uxth	r2, r3
 801a3e4:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801a3e8:	b29b      	uxth	r3, r3
 801a3ea:	1ad3      	subs	r3, r2, r3
 801a3ec:	b29a      	uxth	r2, r3
 801a3ee:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801a3f2:	1ad3      	subs	r3, r2, r3
 801a3f4:	b29b      	uxth	r3, r3
 801a3f6:	b219      	sxth	r1, r3
 801a3f8:	687b      	ldr	r3, [r7, #4]
 801a3fa:	f897 204b 	ldrb.w	r2, [r7, #75]	; 0x4b
 801a3fe:	9200      	str	r2, [sp, #0]
 801a400:	895b      	ldrh	r3, [r3, #10]
 801a402:	68ba      	ldr	r2, [r7, #8]
 801a404:	f7fb fc90 	bl	8015d28 <lv_draw_px>
                           style->body.border.color, aa_opa);
                lv_draw_px(lt_origo.x + LV_CIRC_OCT6_X(aa_p) - i, lt_origo.y + LV_CIRC_OCT6_Y(aa_p) - 1, mask,
 801a408:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 801a40c:	b29a      	uxth	r2, r3
 801a40e:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801a412:	b29b      	uxth	r3, r3
 801a414:	1ad3      	subs	r3, r2, r3
 801a416:	b29a      	uxth	r2, r3
 801a418:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801a41c:	1ad3      	subs	r3, r2, r3
 801a41e:	b29b      	uxth	r3, r3
 801a420:	b218      	sxth	r0, r3
 801a422:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 801a426:	b29a      	uxth	r2, r3
 801a428:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801a42c:	b29b      	uxth	r3, r3
 801a42e:	1ad3      	subs	r3, r2, r3
 801a430:	b29b      	uxth	r3, r3
 801a432:	3b01      	subs	r3, #1
 801a434:	b29b      	uxth	r3, r3
 801a436:	b219      	sxth	r1, r3
 801a438:	687b      	ldr	r3, [r7, #4]
 801a43a:	f897 204b 	ldrb.w	r2, [r7, #75]	; 0x4b
 801a43e:	9200      	str	r2, [sp, #0]
 801a440:	895b      	ldrh	r3, [r3, #10]
 801a442:	68ba      	ldr	r2, [r7, #8]
 801a444:	f7fb fc70 	bl	8015d28 <lv_draw_px>
                           style->body.border.color, aa_opa);
            }

            if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
 801a448:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a44c:	f003 0302 	and.w	r3, r3, #2
 801a450:	2b00      	cmp	r3, #0
 801a452:	d045      	beq.n	801a4e0 <lv_draw_rect_border_corner+0xfd0>
 801a454:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a458:	f003 0308 	and.w	r3, r3, #8
 801a45c:	2b00      	cmp	r3, #0
 801a45e:	d03f      	beq.n	801a4e0 <lv_draw_rect_border_corner+0xfd0>
                lv_draw_px(rt_origo.x + LV_CIRC_OCT7_X(aa_p) + i, rt_origo.y + LV_CIRC_OCT7_Y(aa_p) - 1, mask,
 801a460:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 801a464:	b29a      	uxth	r2, r3
 801a466:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801a46a:	b29b      	uxth	r3, r3
 801a46c:	4413      	add	r3, r2
 801a46e:	b29a      	uxth	r2, r3
 801a470:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801a474:	4413      	add	r3, r2
 801a476:	b29b      	uxth	r3, r3
 801a478:	b218      	sxth	r0, r3
 801a47a:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 801a47e:	b29a      	uxth	r2, r3
 801a480:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801a484:	b29b      	uxth	r3, r3
 801a486:	1ad3      	subs	r3, r2, r3
 801a488:	b29b      	uxth	r3, r3
 801a48a:	3b01      	subs	r3, #1
 801a48c:	b29b      	uxth	r3, r3
 801a48e:	b219      	sxth	r1, r3
 801a490:	687b      	ldr	r3, [r7, #4]
 801a492:	f897 204b 	ldrb.w	r2, [r7, #75]	; 0x4b
 801a496:	9200      	str	r2, [sp, #0]
 801a498:	895b      	ldrh	r3, [r3, #10]
 801a49a:	68ba      	ldr	r2, [r7, #8]
 801a49c:	f7fb fc44 	bl	8015d28 <lv_draw_px>
                           style->body.border.color, aa_opa);
                lv_draw_px(rt_origo.x + LV_CIRC_OCT8_X(aa_p) + 1, rt_origo.y + LV_CIRC_OCT8_Y(aa_p) - i, mask,
 801a4a0:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 801a4a4:	b29a      	uxth	r2, r3
 801a4a6:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801a4aa:	b29b      	uxth	r3, r3
 801a4ac:	4413      	add	r3, r2
 801a4ae:	b29b      	uxth	r3, r3
 801a4b0:	3301      	adds	r3, #1
 801a4b2:	b29b      	uxth	r3, r3
 801a4b4:	b218      	sxth	r0, r3
 801a4b6:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 801a4ba:	b29a      	uxth	r2, r3
 801a4bc:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801a4c0:	b29b      	uxth	r3, r3
 801a4c2:	1ad3      	subs	r3, r2, r3
 801a4c4:	b29a      	uxth	r2, r3
 801a4c6:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801a4ca:	1ad3      	subs	r3, r2, r3
 801a4cc:	b29b      	uxth	r3, r3
 801a4ce:	b219      	sxth	r1, r3
 801a4d0:	687b      	ldr	r3, [r7, #4]
 801a4d2:	f897 204b 	ldrb.w	r2, [r7, #75]	; 0x4b
 801a4d6:	9200      	str	r2, [sp, #0]
 801a4d8:	895b      	ldrh	r3, [r3, #10]
 801a4da:	68ba      	ldr	r2, [r7, #8]
 801a4dc:	f7fb fc24 	bl	8015d28 <lv_draw_px>
        for(i = 0; i < seg_size; i++) {
 801a4e0:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 801a4e4:	b29b      	uxth	r3, r3
 801a4e6:	3301      	adds	r3, #1
 801a4e8:	b29b      	uxth	r3, r3
 801a4ea:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
 801a4ee:	f9b7 205e 	ldrsh.w	r2, [r7, #94]	; 0x5e
 801a4f2:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 801a4f6:	429a      	cmp	r2, r3
 801a4f8:	f6ff aeb2 	blt.w	801a260 <lv_draw_rect_border_corner+0xd50>
                           style->body.border.color, aa_opa);
            }
        }

        /*In some cases the last pixel in the outer middle is not drawn*/
        if(LV_MATH_ABS(aa_p.x - aa_p.y) == seg_size) {
 801a4fc:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801a500:	461a      	mov	r2, r3
 801a502:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801a506:	1ad3      	subs	r3, r2, r3
 801a508:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 801a50c:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
 801a510:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 801a514:	429a      	cmp	r2, r3
 801a516:	f040 80a3 	bne.w	801a660 <lv_draw_rect_border_corner+0x1150>
            aa_p.x = out_x_last;
 801a51a:	f8b7 306c 	ldrh.w	r3, [r7, #108]	; 0x6c
 801a51e:	823b      	strh	r3, [r7, #16]
            aa_p.y = out_x_last;
 801a520:	f8b7 306c 	ldrh.w	r3, [r7, #108]	; 0x6c
 801a524:	827b      	strh	r3, [r7, #18]

            lv_opa_t aa_opa = opa >> 1;
 801a526:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 801a52a:	085b      	lsrs	r3, r3, #1
 801a52c:	f887 304d 	strb.w	r3, [r7, #77]	; 0x4d

            if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
 801a530:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a534:	f003 0301 	and.w	r3, r3, #1
 801a538:	2b00      	cmp	r3, #0
 801a53a:	d01f      	beq.n	801a57c <lv_draw_rect_border_corner+0x106c>
 801a53c:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a540:	f003 0308 	and.w	r3, r3, #8
 801a544:	2b00      	cmp	r3, #0
 801a546:	d019      	beq.n	801a57c <lv_draw_rect_border_corner+0x106c>
                lv_draw_px(rb_origo.x + LV_CIRC_OCT2_X(aa_p), rb_origo.y + LV_CIRC_OCT2_Y(aa_p), mask,
 801a548:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 801a54c:	b29a      	uxth	r2, r3
 801a54e:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801a552:	b29b      	uxth	r3, r3
 801a554:	4413      	add	r3, r2
 801a556:	b29b      	uxth	r3, r3
 801a558:	b218      	sxth	r0, r3
 801a55a:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 801a55e:	b29a      	uxth	r2, r3
 801a560:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801a564:	b29b      	uxth	r3, r3
 801a566:	4413      	add	r3, r2
 801a568:	b29b      	uxth	r3, r3
 801a56a:	b219      	sxth	r1, r3
 801a56c:	687b      	ldr	r3, [r7, #4]
 801a56e:	f897 204d 	ldrb.w	r2, [r7, #77]	; 0x4d
 801a572:	9200      	str	r2, [sp, #0]
 801a574:	895b      	ldrh	r3, [r3, #10]
 801a576:	68ba      	ldr	r2, [r7, #8]
 801a578:	f7fb fbd6 	bl	8015d28 <lv_draw_px>
                           style->body.border.color, aa_opa);
            }

            if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
 801a57c:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a580:	f003 0301 	and.w	r3, r3, #1
 801a584:	2b00      	cmp	r3, #0
 801a586:	d01f      	beq.n	801a5c8 <lv_draw_rect_border_corner+0x10b8>
 801a588:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a58c:	f003 0304 	and.w	r3, r3, #4
 801a590:	2b00      	cmp	r3, #0
 801a592:	d019      	beq.n	801a5c8 <lv_draw_rect_border_corner+0x10b8>
                lv_draw_px(lb_origo.x + LV_CIRC_OCT4_X(aa_p), lb_origo.y + LV_CIRC_OCT4_Y(aa_p), mask,
 801a594:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 801a598:	b29a      	uxth	r2, r3
 801a59a:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801a59e:	b29b      	uxth	r3, r3
 801a5a0:	1ad3      	subs	r3, r2, r3
 801a5a2:	b29b      	uxth	r3, r3
 801a5a4:	b218      	sxth	r0, r3
 801a5a6:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 801a5aa:	b29a      	uxth	r2, r3
 801a5ac:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801a5b0:	b29b      	uxth	r3, r3
 801a5b2:	4413      	add	r3, r2
 801a5b4:	b29b      	uxth	r3, r3
 801a5b6:	b219      	sxth	r1, r3
 801a5b8:	687b      	ldr	r3, [r7, #4]
 801a5ba:	f897 204d 	ldrb.w	r2, [r7, #77]	; 0x4d
 801a5be:	9200      	str	r2, [sp, #0]
 801a5c0:	895b      	ldrh	r3, [r3, #10]
 801a5c2:	68ba      	ldr	r2, [r7, #8]
 801a5c4:	f7fb fbb0 	bl	8015d28 <lv_draw_px>
                           style->body.border.color, aa_opa);
            }

            if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
 801a5c8:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a5cc:	f003 0302 	and.w	r3, r3, #2
 801a5d0:	2b00      	cmp	r3, #0
 801a5d2:	d01f      	beq.n	801a614 <lv_draw_rect_border_corner+0x1104>
 801a5d4:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a5d8:	f003 0304 	and.w	r3, r3, #4
 801a5dc:	2b00      	cmp	r3, #0
 801a5de:	d019      	beq.n	801a614 <lv_draw_rect_border_corner+0x1104>
                lv_draw_px(lt_origo.x + LV_CIRC_OCT6_X(aa_p), lt_origo.y + LV_CIRC_OCT6_Y(aa_p), mask,
 801a5e0:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 801a5e4:	b29a      	uxth	r2, r3
 801a5e6:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801a5ea:	b29b      	uxth	r3, r3
 801a5ec:	1ad3      	subs	r3, r2, r3
 801a5ee:	b29b      	uxth	r3, r3
 801a5f0:	b218      	sxth	r0, r3
 801a5f2:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 801a5f6:	b29a      	uxth	r2, r3
 801a5f8:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801a5fc:	b29b      	uxth	r3, r3
 801a5fe:	1ad3      	subs	r3, r2, r3
 801a600:	b29b      	uxth	r3, r3
 801a602:	b219      	sxth	r1, r3
 801a604:	687b      	ldr	r3, [r7, #4]
 801a606:	f897 204d 	ldrb.w	r2, [r7, #77]	; 0x4d
 801a60a:	9200      	str	r2, [sp, #0]
 801a60c:	895b      	ldrh	r3, [r3, #10]
 801a60e:	68ba      	ldr	r2, [r7, #8]
 801a610:	f7fb fb8a 	bl	8015d28 <lv_draw_px>
                           style->body.border.color, aa_opa);
            }

            if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
 801a614:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a618:	f003 0302 	and.w	r3, r3, #2
 801a61c:	2b00      	cmp	r3, #0
 801a61e:	d01f      	beq.n	801a660 <lv_draw_rect_border_corner+0x1150>
 801a620:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a624:	f003 0308 	and.w	r3, r3, #8
 801a628:	2b00      	cmp	r3, #0
 801a62a:	d019      	beq.n	801a660 <lv_draw_rect_border_corner+0x1150>
                lv_draw_px(rt_origo.x + LV_CIRC_OCT8_X(aa_p), rt_origo.y + LV_CIRC_OCT8_Y(aa_p), mask,
 801a62c:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 801a630:	b29a      	uxth	r2, r3
 801a632:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801a636:	b29b      	uxth	r3, r3
 801a638:	4413      	add	r3, r2
 801a63a:	b29b      	uxth	r3, r3
 801a63c:	b218      	sxth	r0, r3
 801a63e:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 801a642:	b29a      	uxth	r2, r3
 801a644:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801a648:	b29b      	uxth	r3, r3
 801a64a:	1ad3      	subs	r3, r2, r3
 801a64c:	b29b      	uxth	r3, r3
 801a64e:	b219      	sxth	r1, r3
 801a650:	687b      	ldr	r3, [r7, #4]
 801a652:	f897 204d 	ldrb.w	r2, [r7, #77]	; 0x4d
 801a656:	9200      	str	r2, [sp, #0]
 801a658:	895b      	ldrh	r3, [r3, #10]
 801a65a:	68ba      	ldr	r2, [r7, #8]
 801a65c:	f7fb fb64 	bl	8015d28 <lv_draw_px>
                           style->body.border.color, aa_opa);
            }
        }

        /*Last parts of the inner anti-alias*/
        in_y_seg_end = cir_in.y;
 801a660:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 801a662:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
        aa_p.x       = in_x_last;
 801a666:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
 801a66a:	823b      	strh	r3, [r7, #16]
        aa_p.y       = in_y_seg_start;
 801a66c:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
 801a670:	827b      	strh	r3, [r7, #18]
        seg_size     = in_y_seg_end - in_y_seg_start;
 801a672:	f8b7 2050 	ldrh.w	r2, [r7, #80]	; 0x50
 801a676:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
 801a67a:	1ad3      	subs	r3, r2, r3
 801a67c:	b29b      	uxth	r3, r3
 801a67e:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

        for(i = 0; i < seg_size; i++) {
 801a682:	2300      	movs	r3, #0
 801a684:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
 801a688:	e17e      	b.n	801a988 <lv_draw_rect_border_corner+0x1478>
            lv_opa_t aa_opa = lv_draw_aa_get_opa(seg_size, i, opa);
 801a68a:	f897 2059 	ldrb.w	r2, [r7, #89]	; 0x59
 801a68e:	f9b7 105e 	ldrsh.w	r1, [r7, #94]	; 0x5e
 801a692:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 801a696:	4618      	mov	r0, r3
 801a698:	f7fa fed0 	bl	801543c <lv_draw_aa_get_opa>
 801a69c:	4603      	mov	r3, r0
 801a69e:	f887 304c 	strb.w	r3, [r7, #76]	; 0x4c
            if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
 801a6a2:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a6a6:	f003 0301 	and.w	r3, r3, #1
 801a6aa:	2b00      	cmp	r3, #0
 801a6ac:	d025      	beq.n	801a6fa <lv_draw_rect_border_corner+0x11ea>
 801a6ae:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a6b2:	f003 0308 	and.w	r3, r3, #8
 801a6b6:	2b00      	cmp	r3, #0
 801a6b8:	d01f      	beq.n	801a6fa <lv_draw_rect_border_corner+0x11ea>
                lv_draw_px(rb_origo.x + LV_CIRC_OCT1_X(aa_p) - 1, rb_origo.y + LV_CIRC_OCT1_Y(aa_p) + i, mask,
 801a6ba:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 801a6be:	b29a      	uxth	r2, r3
 801a6c0:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801a6c4:	b29b      	uxth	r3, r3
 801a6c6:	4413      	add	r3, r2
 801a6c8:	b29b      	uxth	r3, r3
 801a6ca:	3b01      	subs	r3, #1
 801a6cc:	b29b      	uxth	r3, r3
 801a6ce:	b218      	sxth	r0, r3
 801a6d0:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 801a6d4:	b29a      	uxth	r2, r3
 801a6d6:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801a6da:	b29b      	uxth	r3, r3
 801a6dc:	4413      	add	r3, r2
 801a6de:	b29a      	uxth	r2, r3
 801a6e0:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801a6e4:	4413      	add	r3, r2
 801a6e6:	b29b      	uxth	r3, r3
 801a6e8:	b219      	sxth	r1, r3
 801a6ea:	687b      	ldr	r3, [r7, #4]
 801a6ec:	f897 204c 	ldrb.w	r2, [r7, #76]	; 0x4c
 801a6f0:	9200      	str	r2, [sp, #0]
 801a6f2:	895b      	ldrh	r3, [r3, #10]
 801a6f4:	68ba      	ldr	r2, [r7, #8]
 801a6f6:	f7fb fb17 	bl	8015d28 <lv_draw_px>
                           style->body.border.color, aa_opa);
            }

            if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
 801a6fa:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a6fe:	f003 0301 	and.w	r3, r3, #1
 801a702:	2b00      	cmp	r3, #0
 801a704:	d025      	beq.n	801a752 <lv_draw_rect_border_corner+0x1242>
 801a706:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a70a:	f003 0304 	and.w	r3, r3, #4
 801a70e:	2b00      	cmp	r3, #0
 801a710:	d01f      	beq.n	801a752 <lv_draw_rect_border_corner+0x1242>
                lv_draw_px(lb_origo.x + LV_CIRC_OCT3_X(aa_p) - i, lb_origo.y + LV_CIRC_OCT3_Y(aa_p) - 1, mask,
 801a712:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 801a716:	b29a      	uxth	r2, r3
 801a718:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801a71c:	b29b      	uxth	r3, r3
 801a71e:	1ad3      	subs	r3, r2, r3
 801a720:	b29a      	uxth	r2, r3
 801a722:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801a726:	1ad3      	subs	r3, r2, r3
 801a728:	b29b      	uxth	r3, r3
 801a72a:	b218      	sxth	r0, r3
 801a72c:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 801a730:	b29a      	uxth	r2, r3
 801a732:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801a736:	b29b      	uxth	r3, r3
 801a738:	4413      	add	r3, r2
 801a73a:	b29b      	uxth	r3, r3
 801a73c:	3b01      	subs	r3, #1
 801a73e:	b29b      	uxth	r3, r3
 801a740:	b219      	sxth	r1, r3
 801a742:	687b      	ldr	r3, [r7, #4]
 801a744:	f897 204c 	ldrb.w	r2, [r7, #76]	; 0x4c
 801a748:	9200      	str	r2, [sp, #0]
 801a74a:	895b      	ldrh	r3, [r3, #10]
 801a74c:	68ba      	ldr	r2, [r7, #8]
 801a74e:	f7fb faeb 	bl	8015d28 <lv_draw_px>
                           style->body.border.color, aa_opa);
            }

            if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
 801a752:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a756:	f003 0302 	and.w	r3, r3, #2
 801a75a:	2b00      	cmp	r3, #0
 801a75c:	d025      	beq.n	801a7aa <lv_draw_rect_border_corner+0x129a>
 801a75e:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a762:	f003 0304 	and.w	r3, r3, #4
 801a766:	2b00      	cmp	r3, #0
 801a768:	d01f      	beq.n	801a7aa <lv_draw_rect_border_corner+0x129a>
                lv_draw_px(lt_origo.x + LV_CIRC_OCT5_X(aa_p) + 1, lt_origo.y + LV_CIRC_OCT5_Y(aa_p) - i, mask,
 801a76a:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 801a76e:	b29a      	uxth	r2, r3
 801a770:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801a774:	b29b      	uxth	r3, r3
 801a776:	1ad3      	subs	r3, r2, r3
 801a778:	b29b      	uxth	r3, r3
 801a77a:	3301      	adds	r3, #1
 801a77c:	b29b      	uxth	r3, r3
 801a77e:	b218      	sxth	r0, r3
 801a780:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 801a784:	b29a      	uxth	r2, r3
 801a786:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801a78a:	b29b      	uxth	r3, r3
 801a78c:	1ad3      	subs	r3, r2, r3
 801a78e:	b29a      	uxth	r2, r3
 801a790:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801a794:	1ad3      	subs	r3, r2, r3
 801a796:	b29b      	uxth	r3, r3
 801a798:	b219      	sxth	r1, r3
 801a79a:	687b      	ldr	r3, [r7, #4]
 801a79c:	f897 204c 	ldrb.w	r2, [r7, #76]	; 0x4c
 801a7a0:	9200      	str	r2, [sp, #0]
 801a7a2:	895b      	ldrh	r3, [r3, #10]
 801a7a4:	68ba      	ldr	r2, [r7, #8]
 801a7a6:	f7fb fabf 	bl	8015d28 <lv_draw_px>
                           style->body.border.color, aa_opa);
            }

            if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
 801a7aa:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a7ae:	f003 0302 	and.w	r3, r3, #2
 801a7b2:	2b00      	cmp	r3, #0
 801a7b4:	d025      	beq.n	801a802 <lv_draw_rect_border_corner+0x12f2>
 801a7b6:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a7ba:	f003 0308 	and.w	r3, r3, #8
 801a7be:	2b00      	cmp	r3, #0
 801a7c0:	d01f      	beq.n	801a802 <lv_draw_rect_border_corner+0x12f2>
                lv_draw_px(rt_origo.x + LV_CIRC_OCT7_X(aa_p) + i, rt_origo.y + LV_CIRC_OCT7_Y(aa_p) + 1, mask,
 801a7c2:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 801a7c6:	b29a      	uxth	r2, r3
 801a7c8:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801a7cc:	b29b      	uxth	r3, r3
 801a7ce:	4413      	add	r3, r2
 801a7d0:	b29a      	uxth	r2, r3
 801a7d2:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801a7d6:	4413      	add	r3, r2
 801a7d8:	b29b      	uxth	r3, r3
 801a7da:	b218      	sxth	r0, r3
 801a7dc:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 801a7e0:	b29a      	uxth	r2, r3
 801a7e2:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801a7e6:	b29b      	uxth	r3, r3
 801a7e8:	1ad3      	subs	r3, r2, r3
 801a7ea:	b29b      	uxth	r3, r3
 801a7ec:	3301      	adds	r3, #1
 801a7ee:	b29b      	uxth	r3, r3
 801a7f0:	b219      	sxth	r1, r3
 801a7f2:	687b      	ldr	r3, [r7, #4]
 801a7f4:	f897 204c 	ldrb.w	r2, [r7, #76]	; 0x4c
 801a7f8:	9200      	str	r2, [sp, #0]
 801a7fa:	895b      	ldrh	r3, [r3, #10]
 801a7fc:	68ba      	ldr	r2, [r7, #8]
 801a7fe:	f7fb fa93 	bl	8015d28 <lv_draw_px>
                           style->body.border.color, aa_opa);
            }

            if(LV_CIRC_OCT1_X(aa_p) - 1 != LV_CIRC_OCT2_X(aa_p) + i) {
 801a802:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801a806:	1e5a      	subs	r2, r3, #1
 801a808:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801a80c:	4619      	mov	r1, r3
 801a80e:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 801a812:	440b      	add	r3, r1
 801a814:	429a      	cmp	r2, r3
 801a816:	f000 80b0 	beq.w	801a97a <lv_draw_rect_border_corner+0x146a>
                if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
 801a81a:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a81e:	f003 0301 	and.w	r3, r3, #1
 801a822:	2b00      	cmp	r3, #0
 801a824:	d025      	beq.n	801a872 <lv_draw_rect_border_corner+0x1362>
 801a826:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a82a:	f003 0308 	and.w	r3, r3, #8
 801a82e:	2b00      	cmp	r3, #0
 801a830:	d01f      	beq.n	801a872 <lv_draw_rect_border_corner+0x1362>
                    lv_draw_px(rb_origo.x + LV_CIRC_OCT2_X(aa_p) + i, rb_origo.y + LV_CIRC_OCT2_Y(aa_p) - 1, mask,
 801a832:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 801a836:	b29a      	uxth	r2, r3
 801a838:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801a83c:	b29b      	uxth	r3, r3
 801a83e:	4413      	add	r3, r2
 801a840:	b29a      	uxth	r2, r3
 801a842:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801a846:	4413      	add	r3, r2
 801a848:	b29b      	uxth	r3, r3
 801a84a:	b218      	sxth	r0, r3
 801a84c:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 801a850:	b29a      	uxth	r2, r3
 801a852:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801a856:	b29b      	uxth	r3, r3
 801a858:	4413      	add	r3, r2
 801a85a:	b29b      	uxth	r3, r3
 801a85c:	3b01      	subs	r3, #1
 801a85e:	b29b      	uxth	r3, r3
 801a860:	b219      	sxth	r1, r3
 801a862:	687b      	ldr	r3, [r7, #4]
 801a864:	f897 204c 	ldrb.w	r2, [r7, #76]	; 0x4c
 801a868:	9200      	str	r2, [sp, #0]
 801a86a:	895b      	ldrh	r3, [r3, #10]
 801a86c:	68ba      	ldr	r2, [r7, #8]
 801a86e:	f7fb fa5b 	bl	8015d28 <lv_draw_px>
                               style->body.border.color, aa_opa);
                }

                if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
 801a872:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a876:	f003 0301 	and.w	r3, r3, #1
 801a87a:	2b00      	cmp	r3, #0
 801a87c:	d025      	beq.n	801a8ca <lv_draw_rect_border_corner+0x13ba>
 801a87e:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a882:	f003 0304 	and.w	r3, r3, #4
 801a886:	2b00      	cmp	r3, #0
 801a888:	d01f      	beq.n	801a8ca <lv_draw_rect_border_corner+0x13ba>
                    lv_draw_px(lb_origo.x + LV_CIRC_OCT4_X(aa_p) + 1, lb_origo.y + LV_CIRC_OCT4_Y(aa_p) + i, mask,
 801a88a:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 801a88e:	b29a      	uxth	r2, r3
 801a890:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801a894:	b29b      	uxth	r3, r3
 801a896:	1ad3      	subs	r3, r2, r3
 801a898:	b29b      	uxth	r3, r3
 801a89a:	3301      	adds	r3, #1
 801a89c:	b29b      	uxth	r3, r3
 801a89e:	b218      	sxth	r0, r3
 801a8a0:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 801a8a4:	b29a      	uxth	r2, r3
 801a8a6:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801a8aa:	b29b      	uxth	r3, r3
 801a8ac:	4413      	add	r3, r2
 801a8ae:	b29a      	uxth	r2, r3
 801a8b0:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801a8b4:	4413      	add	r3, r2
 801a8b6:	b29b      	uxth	r3, r3
 801a8b8:	b219      	sxth	r1, r3
 801a8ba:	687b      	ldr	r3, [r7, #4]
 801a8bc:	f897 204c 	ldrb.w	r2, [r7, #76]	; 0x4c
 801a8c0:	9200      	str	r2, [sp, #0]
 801a8c2:	895b      	ldrh	r3, [r3, #10]
 801a8c4:	68ba      	ldr	r2, [r7, #8]
 801a8c6:	f7fb fa2f 	bl	8015d28 <lv_draw_px>
                               style->body.border.color, aa_opa);
                }

                if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
 801a8ca:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a8ce:	f003 0302 	and.w	r3, r3, #2
 801a8d2:	2b00      	cmp	r3, #0
 801a8d4:	d025      	beq.n	801a922 <lv_draw_rect_border_corner+0x1412>
 801a8d6:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a8da:	f003 0304 	and.w	r3, r3, #4
 801a8de:	2b00      	cmp	r3, #0
 801a8e0:	d01f      	beq.n	801a922 <lv_draw_rect_border_corner+0x1412>
                    lv_draw_px(lt_origo.x + LV_CIRC_OCT6_X(aa_p) - i, lt_origo.y + LV_CIRC_OCT6_Y(aa_p) + 1, mask,
 801a8e2:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 801a8e6:	b29a      	uxth	r2, r3
 801a8e8:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801a8ec:	b29b      	uxth	r3, r3
 801a8ee:	1ad3      	subs	r3, r2, r3
 801a8f0:	b29a      	uxth	r2, r3
 801a8f2:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801a8f6:	1ad3      	subs	r3, r2, r3
 801a8f8:	b29b      	uxth	r3, r3
 801a8fa:	b218      	sxth	r0, r3
 801a8fc:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 801a900:	b29a      	uxth	r2, r3
 801a902:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801a906:	b29b      	uxth	r3, r3
 801a908:	1ad3      	subs	r3, r2, r3
 801a90a:	b29b      	uxth	r3, r3
 801a90c:	3301      	adds	r3, #1
 801a90e:	b29b      	uxth	r3, r3
 801a910:	b219      	sxth	r1, r3
 801a912:	687b      	ldr	r3, [r7, #4]
 801a914:	f897 204c 	ldrb.w	r2, [r7, #76]	; 0x4c
 801a918:	9200      	str	r2, [sp, #0]
 801a91a:	895b      	ldrh	r3, [r3, #10]
 801a91c:	68ba      	ldr	r2, [r7, #8]
 801a91e:	f7fb fa03 	bl	8015d28 <lv_draw_px>
                               style->body.border.color, aa_opa);
                }

                if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
 801a922:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a926:	f003 0302 	and.w	r3, r3, #2
 801a92a:	2b00      	cmp	r3, #0
 801a92c:	d025      	beq.n	801a97a <lv_draw_rect_border_corner+0x146a>
 801a92e:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801a932:	f003 0308 	and.w	r3, r3, #8
 801a936:	2b00      	cmp	r3, #0
 801a938:	d01f      	beq.n	801a97a <lv_draw_rect_border_corner+0x146a>
                    lv_draw_px(rt_origo.x + LV_CIRC_OCT8_X(aa_p) - 1, rt_origo.y + LV_CIRC_OCT8_Y(aa_p) - i, mask,
 801a93a:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 801a93e:	b29a      	uxth	r2, r3
 801a940:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801a944:	b29b      	uxth	r3, r3
 801a946:	4413      	add	r3, r2
 801a948:	b29b      	uxth	r3, r3
 801a94a:	3b01      	subs	r3, #1
 801a94c:	b29b      	uxth	r3, r3
 801a94e:	b218      	sxth	r0, r3
 801a950:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 801a954:	b29a      	uxth	r2, r3
 801a956:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801a95a:	b29b      	uxth	r3, r3
 801a95c:	1ad3      	subs	r3, r2, r3
 801a95e:	b29a      	uxth	r2, r3
 801a960:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801a964:	1ad3      	subs	r3, r2, r3
 801a966:	b29b      	uxth	r3, r3
 801a968:	b219      	sxth	r1, r3
 801a96a:	687b      	ldr	r3, [r7, #4]
 801a96c:	f897 204c 	ldrb.w	r2, [r7, #76]	; 0x4c
 801a970:	9200      	str	r2, [sp, #0]
 801a972:	895b      	ldrh	r3, [r3, #10]
 801a974:	68ba      	ldr	r2, [r7, #8]
 801a976:	f7fb f9d7 	bl	8015d28 <lv_draw_px>
        for(i = 0; i < seg_size; i++) {
 801a97a:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 801a97e:	b29b      	uxth	r3, r3
 801a980:	3301      	adds	r3, #1
 801a982:	b29b      	uxth	r3, r3
 801a984:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
 801a988:	f9b7 205e 	ldrsh.w	r2, [r7, #94]	; 0x5e
 801a98c:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 801a990:	429a      	cmp	r2, r3
 801a992:	f6ff ae7a 	blt.w	801a68a <lv_draw_rect_border_corner+0x117a>
                }
            }
        }
    }
#endif
}
 801a996:	bf00      	nop
 801a998:	3778      	adds	r7, #120	; 0x78
 801a99a:	46bd      	mov	sp, r7
 801a99c:	bd80      	pop	{r7, pc}

0801a99e <lv_draw_shadow>:
 * @param mask pointer to a mask area (from the design functions)
 * @param opa_scale scale down all opacities by the factor
 */
static void lv_draw_shadow(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style,
                           lv_opa_t opa_scale)
{
 801a99e:	b580      	push	{r7, lr}
 801a9a0:	b088      	sub	sp, #32
 801a9a2:	af00      	add	r7, sp, #0
 801a9a4:	60f8      	str	r0, [r7, #12]
 801a9a6:	60b9      	str	r1, [r7, #8]
 801a9a8:	607a      	str	r2, [r7, #4]
 801a9aa:	70fb      	strb	r3, [r7, #3]
    /* If mask is in the middle of cords do not draw shadow*/
    lv_coord_t radius = style->body.radius;
 801a9ac:	687b      	ldr	r3, [r7, #4]
 801a9ae:	88db      	ldrh	r3, [r3, #6]
 801a9b0:	83fb      	strh	r3, [r7, #30]
    lv_coord_t width  = lv_area_get_width(coords);
 801a9b2:	68f8      	ldr	r0, [r7, #12]
 801a9b4:	f7fd f843 	bl	8017a3e <lv_area_get_width>
 801a9b8:	4603      	mov	r3, r0
 801a9ba:	83bb      	strh	r3, [r7, #28]
    lv_coord_t height = lv_area_get_height(coords);
 801a9bc:	68f8      	ldr	r0, [r7, #12]
 801a9be:	f7fd f855 	bl	8017a6c <lv_area_get_height>
 801a9c2:	4603      	mov	r3, r0
 801a9c4:	837b      	strh	r3, [r7, #26]
    radius            = lv_draw_cont_radius_corr(radius, width, height);
 801a9c6:	8bfb      	ldrh	r3, [r7, #30]
 801a9c8:	f9b7 201a 	ldrsh.w	r2, [r7, #26]
 801a9cc:	f9b7 101c 	ldrsh.w	r1, [r7, #28]
 801a9d0:	4618      	mov	r0, r3
 801a9d2:	f000 fedf 	bl	801b794 <lv_draw_cont_radius_corr>
 801a9d6:	4603      	mov	r3, r0
 801a9d8:	83fb      	strh	r3, [r7, #30]
    lv_area_t area_tmp;

    /*Check horizontally without radius*/
    lv_area_copy(&area_tmp, coords);
 801a9da:	f107 0310 	add.w	r3, r7, #16
 801a9de:	68f9      	ldr	r1, [r7, #12]
 801a9e0:	4618      	mov	r0, r3
 801a9e2:	f7fd f81e 	bl	8017a22 <lv_area_copy>
    area_tmp.x1 += radius;
 801a9e6:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801a9ea:	b29a      	uxth	r2, r3
 801a9ec:	8bfb      	ldrh	r3, [r7, #30]
 801a9ee:	4413      	add	r3, r2
 801a9f0:	b29b      	uxth	r3, r3
 801a9f2:	b21b      	sxth	r3, r3
 801a9f4:	823b      	strh	r3, [r7, #16]
    area_tmp.x2 -= radius;
 801a9f6:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 801a9fa:	b29a      	uxth	r2, r3
 801a9fc:	8bfb      	ldrh	r3, [r7, #30]
 801a9fe:	1ad3      	subs	r3, r2, r3
 801aa00:	b29b      	uxth	r3, r3
 801aa02:	b21b      	sxth	r3, r3
 801aa04:	82bb      	strh	r3, [r7, #20]
    if(lv_area_is_in(mask, &area_tmp) != false) return;
 801aa06:	f107 0310 	add.w	r3, r7, #16
 801aa0a:	4619      	mov	r1, r3
 801aa0c:	68b8      	ldr	r0, [r7, #8]
 801aa0e:	f002 ffbe 	bl	801d98e <lv_area_is_in>
 801aa12:	4603      	mov	r3, r0
 801aa14:	2b00      	cmp	r3, #0
 801aa16:	d134      	bne.n	801aa82 <lv_draw_shadow+0xe4>

    /*Check vertically without radius*/
    lv_area_copy(&area_tmp, coords);
 801aa18:	f107 0310 	add.w	r3, r7, #16
 801aa1c:	68f9      	ldr	r1, [r7, #12]
 801aa1e:	4618      	mov	r0, r3
 801aa20:	f7fc ffff 	bl	8017a22 <lv_area_copy>
    area_tmp.y1 += radius;
 801aa24:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801aa28:	b29a      	uxth	r2, r3
 801aa2a:	8bfb      	ldrh	r3, [r7, #30]
 801aa2c:	4413      	add	r3, r2
 801aa2e:	b29b      	uxth	r3, r3
 801aa30:	b21b      	sxth	r3, r3
 801aa32:	827b      	strh	r3, [r7, #18]
    area_tmp.y2 -= radius;
 801aa34:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 801aa38:	b29a      	uxth	r2, r3
 801aa3a:	8bfb      	ldrh	r3, [r7, #30]
 801aa3c:	1ad3      	subs	r3, r2, r3
 801aa3e:	b29b      	uxth	r3, r3
 801aa40:	b21b      	sxth	r3, r3
 801aa42:	82fb      	strh	r3, [r7, #22]
    if(lv_area_is_in(mask, &area_tmp) != false) return;
 801aa44:	f107 0310 	add.w	r3, r7, #16
 801aa48:	4619      	mov	r1, r3
 801aa4a:	68b8      	ldr	r0, [r7, #8]
 801aa4c:	f002 ff9f 	bl	801d98e <lv_area_is_in>
 801aa50:	4603      	mov	r3, r0
 801aa52:	2b00      	cmp	r3, #0
 801aa54:	d117      	bne.n	801aa86 <lv_draw_shadow+0xe8>

    if(style->body.shadow.type == LV_SHADOW_FULL) {
 801aa56:	687b      	ldr	r3, [r7, #4]
 801aa58:	7d1b      	ldrb	r3, [r3, #20]
 801aa5a:	2b01      	cmp	r3, #1
 801aa5c:	d106      	bne.n	801aa6c <lv_draw_shadow+0xce>
        lv_draw_shadow_full(coords, mask, style, opa_scale);
 801aa5e:	78fb      	ldrb	r3, [r7, #3]
 801aa60:	687a      	ldr	r2, [r7, #4]
 801aa62:	68b9      	ldr	r1, [r7, #8]
 801aa64:	68f8      	ldr	r0, [r7, #12]
 801aa66:	f000 f812 	bl	801aa8e <lv_draw_shadow_full>
 801aa6a:	e00d      	b.n	801aa88 <lv_draw_shadow+0xea>
    } else if(style->body.shadow.type == LV_SHADOW_BOTTOM) {
 801aa6c:	687b      	ldr	r3, [r7, #4]
 801aa6e:	7d1b      	ldrb	r3, [r3, #20]
 801aa70:	2b00      	cmp	r3, #0
 801aa72:	d109      	bne.n	801aa88 <lv_draw_shadow+0xea>
        lv_draw_shadow_bottom(coords, mask, style, opa_scale);
 801aa74:	78fb      	ldrb	r3, [r7, #3]
 801aa76:	687a      	ldr	r2, [r7, #4]
 801aa78:	68b9      	ldr	r1, [r7, #8]
 801aa7a:	68f8      	ldr	r0, [r7, #12]
 801aa7c:	f000 fb2f 	bl	801b0de <lv_draw_shadow_bottom>
 801aa80:	e002      	b.n	801aa88 <lv_draw_shadow+0xea>
    if(lv_area_is_in(mask, &area_tmp) != false) return;
 801aa82:	bf00      	nop
 801aa84:	e000      	b.n	801aa88 <lv_draw_shadow+0xea>
    if(lv_area_is_in(mask, &area_tmp) != false) return;
 801aa86:	bf00      	nop
    }
}
 801aa88:	3720      	adds	r7, #32
 801aa8a:	46bd      	mov	sp, r7
 801aa8c:	bd80      	pop	{r7, pc}

0801aa8e <lv_draw_shadow_full>:

static void lv_draw_shadow_full(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style,
                                lv_opa_t opa_scale)
{
 801aa8e:	b580      	push	{r7, lr}
 801aa90:	b0a0      	sub	sp, #128	; 0x80
 801aa92:	af02      	add	r7, sp, #8
 801aa94:	60f8      	str	r0, [r7, #12]
 801aa96:	60b9      	str	r1, [r7, #8]
 801aa98:	607a      	str	r2, [r7, #4]
 801aa9a:	70fb      	strb	r3, [r7, #3]
     * radius means smaller average shadow opacity. The solution should be to start `line` from `-
     * swidth` and handle if the straight part is short (or zero) and the value is taken from the
     * other corner. `col` also should start from `- swidth`
     */

    bool aa = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
 801aa9c:	f7f9 fcfa 	bl	8014494 <lv_refr_get_disp_refreshing>
 801aaa0:	4603      	mov	r3, r0
 801aaa2:	4618      	mov	r0, r3
 801aaa4:	f002 fb79 	bl	801d19a <lv_disp_get_antialiasing>
 801aaa8:	4603      	mov	r3, r0
 801aaaa:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67

    lv_coord_t radius = style->body.radius;
 801aaae:	687b      	ldr	r3, [r7, #4]
 801aab0:	88db      	ldrh	r3, [r3, #6]
 801aab2:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
    lv_coord_t swidth = style->body.shadow.width;
 801aab6:	687b      	ldr	r3, [r7, #4]
 801aab8:	8a5b      	ldrh	r3, [r3, #18]
 801aaba:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62

    lv_coord_t width  = lv_area_get_width(coords);
 801aabe:	68f8      	ldr	r0, [r7, #12]
 801aac0:	f7fc ffbd 	bl	8017a3e <lv_area_get_width>
 801aac4:	4603      	mov	r3, r0
 801aac6:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60
    lv_coord_t height = lv_area_get_height(coords);
 801aaca:	68f8      	ldr	r0, [r7, #12]
 801aacc:	f7fc ffce 	bl	8017a6c <lv_area_get_height>
 801aad0:	4603      	mov	r3, r0
 801aad2:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e

    radius = lv_draw_cont_radius_corr(radius, width, height);
 801aad6:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 801aada:	f9b7 205e 	ldrsh.w	r2, [r7, #94]	; 0x5e
 801aade:	f9b7 1060 	ldrsh.w	r1, [r7, #96]	; 0x60
 801aae2:	4618      	mov	r0, r3
 801aae4:	f000 fe56 	bl	801b794 <lv_draw_cont_radius_corr>
 801aae8:	4603      	mov	r3, r0
 801aaea:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64

    radius += aa;
 801aaee:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 801aaf2:	b29a      	uxth	r2, r3
 801aaf4:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 801aaf8:	4413      	add	r3, r2
 801aafa:	b29b      	uxth	r3, r3
 801aafc:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64

    /*Allocate a draw buffer the buffer required to draw the shadow*/
    int16_t filter_width = 2 * swidth + 1;
 801ab00:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 801ab04:	005b      	lsls	r3, r3, #1
 801ab06:	b29b      	uxth	r3, r3
 801ab08:	3301      	adds	r3, #1
 801ab0a:	b29b      	uxth	r3, r3
 801ab0c:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
    uint32_t curve_x_size = ((radius + swidth + 1) + 3) & ~0x3; /*Round to 4*/
 801ab10:	f9b7 2064 	ldrsh.w	r2, [r7, #100]	; 0x64
 801ab14:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 801ab18:	4413      	add	r3, r2
 801ab1a:	3304      	adds	r3, #4
 801ab1c:	f023 0303 	bic.w	r3, r3, #3
 801ab20:	65bb      	str	r3, [r7, #88]	; 0x58
    curve_x_size *= sizeof(lv_coord_t);
 801ab22:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801ab24:	005b      	lsls	r3, r3, #1
 801ab26:	65bb      	str	r3, [r7, #88]	; 0x58
    uint32_t line_1d_blur_size = (filter_width + 3) & ~0x3;     /*Round to 4*/
 801ab28:	f9b7 305c 	ldrsh.w	r3, [r7, #92]	; 0x5c
 801ab2c:	3303      	adds	r3, #3
 801ab2e:	f023 0303 	bic.w	r3, r3, #3
 801ab32:	657b      	str	r3, [r7, #84]	; 0x54
    line_1d_blur_size *= sizeof(uint32_t);
 801ab34:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801ab36:	009b      	lsls	r3, r3, #2
 801ab38:	657b      	str	r3, [r7, #84]	; 0x54
    uint32_t line_2d_blur_size = ((radius + swidth + 1) + 3) & ~0x3;     /*Round to 4*/
 801ab3a:	f9b7 2064 	ldrsh.w	r2, [r7, #100]	; 0x64
 801ab3e:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 801ab42:	4413      	add	r3, r2
 801ab44:	3304      	adds	r3, #4
 801ab46:	f023 0303 	bic.w	r3, r3, #3
 801ab4a:	653b      	str	r3, [r7, #80]	; 0x50
    line_2d_blur_size *= sizeof(lv_opa_t);

    uint8_t * draw_buf = lv_draw_get_buf(curve_x_size + line_1d_blur_size + line_2d_blur_size);
 801ab4c:	6dba      	ldr	r2, [r7, #88]	; 0x58
 801ab4e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801ab50:	441a      	add	r2, r3
 801ab52:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801ab54:	4413      	add	r3, r2
 801ab56:	4618      	mov	r0, r3
 801ab58:	f7fa fc1e 	bl	8015398 <lv_draw_get_buf>
 801ab5c:	64f8      	str	r0, [r7, #76]	; 0x4c

    /*Divide the draw buffer*/
    lv_coord_t  * curve_x = (lv_coord_t *)&draw_buf[0]; /*Stores the 'x' coordinates of a quarter circle.*/
 801ab5e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 801ab60:	64bb      	str	r3, [r7, #72]	; 0x48
    uint32_t * line_1d_blur = (uint32_t *)&draw_buf[curve_x_size];
 801ab62:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801ab64:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801ab66:	4413      	add	r3, r2
 801ab68:	647b      	str	r3, [r7, #68]	; 0x44
    lv_opa_t * line_2d_blur = (lv_opa_t *)&draw_buf[curve_x_size + line_1d_blur_size];
 801ab6a:	6dba      	ldr	r2, [r7, #88]	; 0x58
 801ab6c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801ab6e:	4413      	add	r3, r2
 801ab70:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 801ab72:	4413      	add	r3, r2
 801ab74:	643b      	str	r3, [r7, #64]	; 0x40

    memset(curve_x, 0, curve_x_size);
 801ab76:	6dba      	ldr	r2, [r7, #88]	; 0x58
 801ab78:	2100      	movs	r1, #0
 801ab7a:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 801ab7c:	f007 f87a 	bl	8021c74 <memset>
    lv_point_t circ;
    lv_coord_t circ_tmp;
    lv_circ_init(&circ, &circ_tmp, radius);
 801ab80:	f9b7 2064 	ldrsh.w	r2, [r7, #100]	; 0x64
 801ab84:	f107 0136 	add.w	r1, r7, #54	; 0x36
 801ab88:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801ab8c:	4618      	mov	r0, r3
 801ab8e:	f002 ff2e 	bl	801d9ee <lv_circ_init>
    while(lv_circ_cont(&circ)) {
 801ab92:	e017      	b.n	801abc4 <lv_draw_shadow_full+0x136>
        curve_x[LV_CIRC_OCT1_Y(circ)] = LV_CIRC_OCT1_X(circ);
 801ab94:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 801ab98:	005b      	lsls	r3, r3, #1
 801ab9a:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801ab9c:	4413      	add	r3, r2
 801ab9e:	f9b7 2038 	ldrsh.w	r2, [r7, #56]	; 0x38
 801aba2:	801a      	strh	r2, [r3, #0]
        curve_x[LV_CIRC_OCT2_Y(circ)] = LV_CIRC_OCT2_X(circ);
 801aba4:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 801aba8:	005b      	lsls	r3, r3, #1
 801abaa:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801abac:	4413      	add	r3, r2
 801abae:	f9b7 203a 	ldrsh.w	r2, [r7, #58]	; 0x3a
 801abb2:	801a      	strh	r2, [r3, #0]
        lv_circ_next(&circ, &circ_tmp);
 801abb4:	f107 0236 	add.w	r2, r7, #54	; 0x36
 801abb8:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801abbc:	4611      	mov	r1, r2
 801abbe:	4618      	mov	r0, r3
 801abc0:	f002 ff44 	bl	801da4c <lv_circ_next>
    while(lv_circ_cont(&circ)) {
 801abc4:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801abc8:	4618      	mov	r0, r3
 801abca:	f002 ff2a 	bl	801da22 <lv_circ_cont>
 801abce:	4603      	mov	r3, r0
 801abd0:	2b00      	cmp	r3, #0
 801abd2:	d1df      	bne.n	801ab94 <lv_draw_shadow_full+0x106>
    }
    int16_t line;
    /*1D Blur horizontally*/
    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->body.opa : (uint16_t)((uint16_t)style->body.opa * opa_scale) >> 8;
 801abd4:	78fb      	ldrb	r3, [r7, #3]
 801abd6:	2bff      	cmp	r3, #255	; 0xff
 801abd8:	d102      	bne.n	801abe0 <lv_draw_shadow_full+0x152>
 801abda:	687b      	ldr	r3, [r7, #4]
 801abdc:	7a1b      	ldrb	r3, [r3, #8]
 801abde:	e00a      	b.n	801abf6 <lv_draw_shadow_full+0x168>
 801abe0:	687b      	ldr	r3, [r7, #4]
 801abe2:	7a1b      	ldrb	r3, [r3, #8]
 801abe4:	b29a      	uxth	r2, r3
 801abe6:	78fb      	ldrb	r3, [r7, #3]
 801abe8:	b29b      	uxth	r3, r3
 801abea:	fb12 f303 	smulbb	r3, r2, r3
 801abee:	b29b      	uxth	r3, r3
 801abf0:	0a1b      	lsrs	r3, r3, #8
 801abf2:	b29b      	uxth	r3, r3
 801abf4:	b2db      	uxtb	r3, r3
 801abf6:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
    for(line = 0; line < filter_width; line++) {
 801abfa:	2300      	movs	r3, #0
 801abfc:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76
 801ac00:	e021      	b.n	801ac46 <lv_draw_shadow_full+0x1b8>
        line_1d_blur[line] = (uint32_t)((uint32_t)(filter_width - line) * (opa * 2) << SHADOW_OPA_EXTRA_PRECISION) /
 801ac02:	f9b7 205c 	ldrsh.w	r2, [r7, #92]	; 0x5c
 801ac06:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 801ac0a:	1ad3      	subs	r3, r2, r3
 801ac0c:	461a      	mov	r2, r3
 801ac0e:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 801ac12:	fb03 f302 	mul.w	r3, r3, r2
 801ac16:	005b      	lsls	r3, r3, #1
 801ac18:	021a      	lsls	r2, r3, #8
                             (filter_width * filter_width);
 801ac1a:	f9b7 305c 	ldrsh.w	r3, [r7, #92]	; 0x5c
 801ac1e:	f9b7 105c 	ldrsh.w	r1, [r7, #92]	; 0x5c
 801ac22:	fb01 f303 	mul.w	r3, r1, r3
 801ac26:	4618      	mov	r0, r3
        line_1d_blur[line] = (uint32_t)((uint32_t)(filter_width - line) * (opa * 2) << SHADOW_OPA_EXTRA_PRECISION) /
 801ac28:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 801ac2c:	009b      	lsls	r3, r3, #2
 801ac2e:	6c79      	ldr	r1, [r7, #68]	; 0x44
 801ac30:	440b      	add	r3, r1
 801ac32:	fbb2 f2f0 	udiv	r2, r2, r0
 801ac36:	601a      	str	r2, [r3, #0]
    for(line = 0; line < filter_width; line++) {
 801ac38:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 801ac3c:	b29b      	uxth	r3, r3
 801ac3e:	3301      	adds	r3, #1
 801ac40:	b29b      	uxth	r3, r3
 801ac42:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76
 801ac46:	f9b7 2076 	ldrsh.w	r2, [r7, #118]	; 0x76
 801ac4a:	f9b7 305c 	ldrsh.w	r3, [r7, #92]	; 0x5c
 801ac4e:	429a      	cmp	r2, r3
 801ac50:	dbd7      	blt.n	801ac02 <lv_draw_shadow_full+0x174>
    lv_point_t point_lb;
    lv_point_t ofs_rb;
    lv_point_t ofs_rt;
    lv_point_t ofs_lb;
    lv_point_t ofs_lt;
    ofs_rb.x = coords->x2 - radius - aa;
 801ac52:	68fb      	ldr	r3, [r7, #12]
 801ac54:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801ac58:	b29a      	uxth	r2, r3
 801ac5a:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 801ac5e:	1ad3      	subs	r3, r2, r3
 801ac60:	b29a      	uxth	r2, r3
 801ac62:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 801ac66:	b29b      	uxth	r3, r3
 801ac68:	1ad3      	subs	r3, r2, r3
 801ac6a:	b29b      	uxth	r3, r3
 801ac6c:	b21b      	sxth	r3, r3
 801ac6e:	843b      	strh	r3, [r7, #32]
    ofs_rb.y = coords->y2 - radius - aa;
 801ac70:	68fb      	ldr	r3, [r7, #12]
 801ac72:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801ac76:	b29a      	uxth	r2, r3
 801ac78:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 801ac7c:	1ad3      	subs	r3, r2, r3
 801ac7e:	b29a      	uxth	r2, r3
 801ac80:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 801ac84:	b29b      	uxth	r3, r3
 801ac86:	1ad3      	subs	r3, r2, r3
 801ac88:	b29b      	uxth	r3, r3
 801ac8a:	b21b      	sxth	r3, r3
 801ac8c:	847b      	strh	r3, [r7, #34]	; 0x22

    ofs_rt.x = coords->x2 - radius - aa;
 801ac8e:	68fb      	ldr	r3, [r7, #12]
 801ac90:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801ac94:	b29a      	uxth	r2, r3
 801ac96:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 801ac9a:	1ad3      	subs	r3, r2, r3
 801ac9c:	b29a      	uxth	r2, r3
 801ac9e:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 801aca2:	b29b      	uxth	r3, r3
 801aca4:	1ad3      	subs	r3, r2, r3
 801aca6:	b29b      	uxth	r3, r3
 801aca8:	b21b      	sxth	r3, r3
 801acaa:	83bb      	strh	r3, [r7, #28]
    ofs_rt.y = coords->y1 + radius + aa;
 801acac:	68fb      	ldr	r3, [r7, #12]
 801acae:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801acb2:	b29a      	uxth	r2, r3
 801acb4:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 801acb8:	4413      	add	r3, r2
 801acba:	b29a      	uxth	r2, r3
 801acbc:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 801acc0:	b29b      	uxth	r3, r3
 801acc2:	4413      	add	r3, r2
 801acc4:	b29b      	uxth	r3, r3
 801acc6:	b21b      	sxth	r3, r3
 801acc8:	83fb      	strh	r3, [r7, #30]

    ofs_lb.x = coords->x1 + radius + aa;
 801acca:	68fb      	ldr	r3, [r7, #12]
 801accc:	f9b3 3000 	ldrsh.w	r3, [r3]
 801acd0:	b29a      	uxth	r2, r3
 801acd2:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 801acd6:	4413      	add	r3, r2
 801acd8:	b29a      	uxth	r2, r3
 801acda:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 801acde:	b29b      	uxth	r3, r3
 801ace0:	4413      	add	r3, r2
 801ace2:	b29b      	uxth	r3, r3
 801ace4:	b21b      	sxth	r3, r3
 801ace6:	833b      	strh	r3, [r7, #24]
    ofs_lb.y = coords->y2 - radius - aa;
 801ace8:	68fb      	ldr	r3, [r7, #12]
 801acea:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801acee:	b29a      	uxth	r2, r3
 801acf0:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 801acf4:	1ad3      	subs	r3, r2, r3
 801acf6:	b29a      	uxth	r2, r3
 801acf8:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 801acfc:	b29b      	uxth	r3, r3
 801acfe:	1ad3      	subs	r3, r2, r3
 801ad00:	b29b      	uxth	r3, r3
 801ad02:	b21b      	sxth	r3, r3
 801ad04:	837b      	strh	r3, [r7, #26]

    ofs_lt.x = coords->x1 + radius + aa;
 801ad06:	68fb      	ldr	r3, [r7, #12]
 801ad08:	f9b3 3000 	ldrsh.w	r3, [r3]
 801ad0c:	b29a      	uxth	r2, r3
 801ad0e:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 801ad12:	4413      	add	r3, r2
 801ad14:	b29a      	uxth	r2, r3
 801ad16:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 801ad1a:	b29b      	uxth	r3, r3
 801ad1c:	4413      	add	r3, r2
 801ad1e:	b29b      	uxth	r3, r3
 801ad20:	b21b      	sxth	r3, r3
 801ad22:	82bb      	strh	r3, [r7, #20]
    ofs_lt.y = coords->y1 + radius + aa;
 801ad24:	68fb      	ldr	r3, [r7, #12]
 801ad26:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801ad2a:	b29a      	uxth	r2, r3
 801ad2c:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 801ad30:	4413      	add	r3, r2
 801ad32:	b29a      	uxth	r2, r3
 801ad34:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 801ad38:	b29b      	uxth	r3, r3
 801ad3a:	4413      	add	r3, r2
 801ad3c:	b29b      	uxth	r3, r3
 801ad3e:	b21b      	sxth	r3, r3
 801ad40:	82fb      	strh	r3, [r7, #22]
    bool line_ready;
    for(line = 0; line <= radius + swidth; line++) { /*Check all rows and make the 1D blur to 2D*/
 801ad42:	2300      	movs	r3, #0
 801ad44:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76
 801ad48:	e1ba      	b.n	801b0c0 <lv_draw_shadow_full+0x632>
        line_ready = false;
 801ad4a:	2300      	movs	r3, #0
 801ad4c:	f887 3073 	strb.w	r3, [r7, #115]	; 0x73
        for(col = 0; col <= radius + swidth; col++) { /*Check all pixels in a 1D blur line (from the origo to last
 801ad50:	2300      	movs	r3, #0
 801ad52:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74
 801ad56:	e098      	b.n	801ae8a <lv_draw_shadow_full+0x3fc>
                                                         shadow pixel (radius + swidth))*/

            /*Sum the opacities from the lines above and below this 'row'*/
            int16_t line_rel;
            uint32_t px_opa_sum = 0;
 801ad58:	2300      	movs	r3, #0
 801ad5a:	66fb      	str	r3, [r7, #108]	; 0x6c
            for(line_rel = -swidth; line_rel <= swidth; line_rel++) {
 801ad5c:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 801ad60:	425b      	negs	r3, r3
 801ad62:	b29b      	uxth	r3, r3
 801ad64:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
 801ad68:	e06e      	b.n	801ae48 <lv_draw_shadow_full+0x3ba>
                /*Get the relative x position of the 'line_rel' to 'line'*/
                int16_t col_rel;
                if(line + line_rel < 0) { /*Below the radius, here is the blur of the edge */
 801ad6a:	f9b7 2076 	ldrsh.w	r2, [r7, #118]	; 0x76
 801ad6e:	f9b7 3070 	ldrsh.w	r3, [r7, #112]	; 0x70
 801ad72:	4413      	add	r3, r2
 801ad74:	2b00      	cmp	r3, #0
 801ad76:	da12      	bge.n	801ad9e <lv_draw_shadow_full+0x310>
                    col_rel = radius - curve_x[line] - col;
 801ad78:	f8b7 2064 	ldrh.w	r2, [r7, #100]	; 0x64
 801ad7c:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 801ad80:	005b      	lsls	r3, r3, #1
 801ad82:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 801ad84:	440b      	add	r3, r1
 801ad86:	f9b3 3000 	ldrsh.w	r3, [r3]
 801ad8a:	b29b      	uxth	r3, r3
 801ad8c:	1ad3      	subs	r3, r2, r3
 801ad8e:	b29a      	uxth	r2, r3
 801ad90:	f8b7 3074 	ldrh.w	r3, [r7, #116]	; 0x74
 801ad94:	1ad3      	subs	r3, r2, r3
 801ad96:	b29b      	uxth	r3, r3
 801ad98:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
 801ad9c:	e023      	b.n	801ade6 <lv_draw_shadow_full+0x358>
                } else if(line + line_rel > radius) { /*Above the radius, here won't be more 1D blur*/
 801ad9e:	f9b7 2076 	ldrsh.w	r2, [r7, #118]	; 0x76
 801ada2:	f9b7 3070 	ldrsh.w	r3, [r7, #112]	; 0x70
 801ada6:	441a      	add	r2, r3
 801ada8:	f9b7 3064 	ldrsh.w	r3, [r7, #100]	; 0x64
 801adac:	429a      	cmp	r2, r3
 801adae:	dc52      	bgt.n	801ae56 <lv_draw_shadow_full+0x3c8>
                    break;
                } else { /*Blur from the curve*/
                    col_rel = curve_x[line + line_rel] - curve_x[line] - col;
 801adb0:	f9b7 2076 	ldrsh.w	r2, [r7, #118]	; 0x76
 801adb4:	f9b7 3070 	ldrsh.w	r3, [r7, #112]	; 0x70
 801adb8:	4413      	add	r3, r2
 801adba:	005b      	lsls	r3, r3, #1
 801adbc:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801adbe:	4413      	add	r3, r2
 801adc0:	f9b3 3000 	ldrsh.w	r3, [r3]
 801adc4:	b29a      	uxth	r2, r3
 801adc6:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 801adca:	005b      	lsls	r3, r3, #1
 801adcc:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 801adce:	440b      	add	r3, r1
 801add0:	f9b3 3000 	ldrsh.w	r3, [r3]
 801add4:	b29b      	uxth	r3, r3
 801add6:	1ad3      	subs	r3, r2, r3
 801add8:	b29a      	uxth	r2, r3
 801adda:	f8b7 3074 	ldrh.w	r3, [r7, #116]	; 0x74
 801adde:	1ad3      	subs	r3, r2, r3
 801ade0:	b29b      	uxth	r3, r3
 801ade2:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
                }

                /*Add the value of the 1D blur on 'col_rel' position*/
                if(col_rel < -swidth) { /*Outside of the blurred area. */
 801ade6:	f9b7 206a 	ldrsh.w	r2, [r7, #106]	; 0x6a
 801adea:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 801adee:	425b      	negs	r3, r3
 801adf0:	429a      	cmp	r2, r3
 801adf2:	da0a      	bge.n	801ae0a <lv_draw_shadow_full+0x37c>
                    if(line_rel == -swidth)
 801adf4:	f9b7 2070 	ldrsh.w	r2, [r7, #112]	; 0x70
 801adf8:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 801adfc:	425b      	negs	r3, r3
 801adfe:	429a      	cmp	r2, r3
 801ae00:	d12b      	bne.n	801ae5a <lv_draw_shadow_full+0x3cc>
                        line_ready = true; /*If no data even on the very first line then it wont't
 801ae02:	2301      	movs	r3, #1
 801ae04:	f887 3073 	strb.w	r3, [r7, #115]	; 0x73
                                              be anything else in this line*/
                    break;                 /*Break anyway because only smaller 'col_rel' values will come */
 801ae08:	e027      	b.n	801ae5a <lv_draw_shadow_full+0x3cc>
                } else if(col_rel > swidth)
 801ae0a:	f9b7 206a 	ldrsh.w	r2, [r7, #106]	; 0x6a
 801ae0e:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 801ae12:	429a      	cmp	r2, r3
 801ae14:	dd05      	ble.n	801ae22 <lv_draw_shadow_full+0x394>
                    px_opa_sum += line_1d_blur[0]; /*Inside the not blurred area*/
 801ae16:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801ae18:	681b      	ldr	r3, [r3, #0]
 801ae1a:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 801ae1c:	4413      	add	r3, r2
 801ae1e:	66fb      	str	r3, [r7, #108]	; 0x6c
 801ae20:	e00b      	b.n	801ae3a <lv_draw_shadow_full+0x3ac>
                else
                    px_opa_sum += line_1d_blur[swidth - col_rel]; /*On the 1D blur (+ swidth to align to the center)*/
 801ae22:	f9b7 2062 	ldrsh.w	r2, [r7, #98]	; 0x62
 801ae26:	f9b7 306a 	ldrsh.w	r3, [r7, #106]	; 0x6a
 801ae2a:	1ad3      	subs	r3, r2, r3
 801ae2c:	009b      	lsls	r3, r3, #2
 801ae2e:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 801ae30:	4413      	add	r3, r2
 801ae32:	681b      	ldr	r3, [r3, #0]
 801ae34:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 801ae36:	4413      	add	r3, r2
 801ae38:	66fb      	str	r3, [r7, #108]	; 0x6c
            for(line_rel = -swidth; line_rel <= swidth; line_rel++) {
 801ae3a:	f9b7 3070 	ldrsh.w	r3, [r7, #112]	; 0x70
 801ae3e:	b29b      	uxth	r3, r3
 801ae40:	3301      	adds	r3, #1
 801ae42:	b29b      	uxth	r3, r3
 801ae44:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
 801ae48:	f9b7 2070 	ldrsh.w	r2, [r7, #112]	; 0x70
 801ae4c:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 801ae50:	429a      	cmp	r2, r3
 801ae52:	dd8a      	ble.n	801ad6a <lv_draw_shadow_full+0x2dc>
 801ae54:	e002      	b.n	801ae5c <lv_draw_shadow_full+0x3ce>
                    break;
 801ae56:	bf00      	nop
 801ae58:	e000      	b.n	801ae5c <lv_draw_shadow_full+0x3ce>
                    break;                 /*Break anyway because only smaller 'col_rel' values will come */
 801ae5a:	bf00      	nop
            }

            line_2d_blur[col] = px_opa_sum >> SHADOW_OPA_EXTRA_PRECISION;
 801ae5c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801ae5e:	0a19      	lsrs	r1, r3, #8
 801ae60:	f8b7 3074 	ldrh.w	r3, [r7, #116]	; 0x74
 801ae64:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801ae66:	4413      	add	r3, r2
 801ae68:	b2ca      	uxtb	r2, r1
 801ae6a:	701a      	strb	r2, [r3, #0]
            if(line_ready) {
 801ae6c:	f897 3073 	ldrb.w	r3, [r7, #115]	; 0x73
 801ae70:	2b00      	cmp	r3, #0
 801ae72:	d005      	beq.n	801ae80 <lv_draw_shadow_full+0x3f2>
                col++; /*To make this line to the last one ( drawing will go to '< col')*/
 801ae74:	f8b7 3074 	ldrh.w	r3, [r7, #116]	; 0x74
 801ae78:	3301      	adds	r3, #1
 801ae7a:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74
                break;
 801ae7e:	e00e      	b.n	801ae9e <lv_draw_shadow_full+0x410>
        for(col = 0; col <= radius + swidth; col++) { /*Check all pixels in a 1D blur line (from the origo to last
 801ae80:	f8b7 3074 	ldrh.w	r3, [r7, #116]	; 0x74
 801ae84:	3301      	adds	r3, #1
 801ae86:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74
 801ae8a:	f8b7 2074 	ldrh.w	r2, [r7, #116]	; 0x74
 801ae8e:	f9b7 1064 	ldrsh.w	r1, [r7, #100]	; 0x64
 801ae92:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 801ae96:	440b      	add	r3, r1
 801ae98:	429a      	cmp	r2, r3
 801ae9a:	f77f af5d 	ble.w	801ad58 <lv_draw_shadow_full+0x2ca>
            }
        }

        /*Flush the line*/
        point_rt.x = curve_x[line] + ofs_rt.x + 1;
 801ae9e:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 801aea2:	005b      	lsls	r3, r3, #1
 801aea4:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801aea6:	4413      	add	r3, r2
 801aea8:	f9b3 3000 	ldrsh.w	r3, [r3]
 801aeac:	b29a      	uxth	r2, r3
 801aeae:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 801aeb2:	b29b      	uxth	r3, r3
 801aeb4:	4413      	add	r3, r2
 801aeb6:	b29b      	uxth	r3, r3
 801aeb8:	3301      	adds	r3, #1
 801aeba:	b29b      	uxth	r3, r3
 801aebc:	b21b      	sxth	r3, r3
 801aebe:	863b      	strh	r3, [r7, #48]	; 0x30
        point_rt.y = ofs_rt.y - line;
 801aec0:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 801aec4:	b29a      	uxth	r2, r3
 801aec6:	f8b7 3076 	ldrh.w	r3, [r7, #118]	; 0x76
 801aeca:	1ad3      	subs	r3, r2, r3
 801aecc:	b29b      	uxth	r3, r3
 801aece:	b21b      	sxth	r3, r3
 801aed0:	867b      	strh	r3, [r7, #50]	; 0x32

        point_rb.x = curve_x[line] + ofs_rb.x + 1;
 801aed2:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 801aed6:	005b      	lsls	r3, r3, #1
 801aed8:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801aeda:	4413      	add	r3, r2
 801aedc:	f9b3 3000 	ldrsh.w	r3, [r3]
 801aee0:	b29a      	uxth	r2, r3
 801aee2:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 801aee6:	b29b      	uxth	r3, r3
 801aee8:	4413      	add	r3, r2
 801aeea:	b29b      	uxth	r3, r3
 801aeec:	3301      	adds	r3, #1
 801aeee:	b29b      	uxth	r3, r3
 801aef0:	b21b      	sxth	r3, r3
 801aef2:	85bb      	strh	r3, [r7, #44]	; 0x2c
        point_rb.y = ofs_rb.y + line;
 801aef4:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 801aef8:	b29a      	uxth	r2, r3
 801aefa:	f8b7 3076 	ldrh.w	r3, [r7, #118]	; 0x76
 801aefe:	4413      	add	r3, r2
 801af00:	b29b      	uxth	r3, r3
 801af02:	b21b      	sxth	r3, r3
 801af04:	85fb      	strh	r3, [r7, #46]	; 0x2e

        point_lt.x = ofs_lt.x - curve_x[line] - 1;
 801af06:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 801af0a:	b29a      	uxth	r2, r3
 801af0c:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 801af10:	005b      	lsls	r3, r3, #1
 801af12:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 801af14:	440b      	add	r3, r1
 801af16:	f9b3 3000 	ldrsh.w	r3, [r3]
 801af1a:	b29b      	uxth	r3, r3
 801af1c:	1ad3      	subs	r3, r2, r3
 801af1e:	b29b      	uxth	r3, r3
 801af20:	3b01      	subs	r3, #1
 801af22:	b29b      	uxth	r3, r3
 801af24:	b21b      	sxth	r3, r3
 801af26:	853b      	strh	r3, [r7, #40]	; 0x28
        point_lt.y = ofs_lt.y - line;
 801af28:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 801af2c:	b29a      	uxth	r2, r3
 801af2e:	f8b7 3076 	ldrh.w	r3, [r7, #118]	; 0x76
 801af32:	1ad3      	subs	r3, r2, r3
 801af34:	b29b      	uxth	r3, r3
 801af36:	b21b      	sxth	r3, r3
 801af38:	857b      	strh	r3, [r7, #42]	; 0x2a

        point_lb.x = ofs_lb.x - curve_x[line] - 1;
 801af3a:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 801af3e:	b29a      	uxth	r2, r3
 801af40:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 801af44:	005b      	lsls	r3, r3, #1
 801af46:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 801af48:	440b      	add	r3, r1
 801af4a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801af4e:	b29b      	uxth	r3, r3
 801af50:	1ad3      	subs	r3, r2, r3
 801af52:	b29b      	uxth	r3, r3
 801af54:	3b01      	subs	r3, #1
 801af56:	b29b      	uxth	r3, r3
 801af58:	b21b      	sxth	r3, r3
 801af5a:	84bb      	strh	r3, [r7, #36]	; 0x24
        point_lb.y = ofs_lb.y + line;
 801af5c:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 801af60:	b29a      	uxth	r2, r3
 801af62:	f8b7 3076 	ldrh.w	r3, [r7, #118]	; 0x76
 801af66:	4413      	add	r3, r2
 801af68:	b29b      	uxth	r3, r3
 801af6a:	b21b      	sxth	r3, r3
 801af6c:	84fb      	strh	r3, [r7, #38]	; 0x26

        uint16_t d;
        for(d = 1; d < col; d++) {
 801af6e:	2301      	movs	r3, #1
 801af70:	f8a7 3068 	strh.w	r3, [r7, #104]	; 0x68
 801af74:	e08c      	b.n	801b090 <lv_draw_shadow_full+0x602>

            if(point_lt.x < ofs_lt.x && point_lt.y < ofs_lt.y) {
 801af76:	f9b7 2028 	ldrsh.w	r2, [r7, #40]	; 0x28
 801af7a:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 801af7e:	429a      	cmp	r2, r3
 801af80:	da14      	bge.n	801afac <lv_draw_shadow_full+0x51e>
 801af82:	f9b7 202a 	ldrsh.w	r2, [r7, #42]	; 0x2a
 801af86:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 801af8a:	429a      	cmp	r2, r3
 801af8c:	da0e      	bge.n	801afac <lv_draw_shadow_full+0x51e>
                lv_draw_px(point_lt.x, point_lt.y, mask, style->body.shadow.color, line_2d_blur[d]);
 801af8e:	f9b7 0028 	ldrsh.w	r0, [r7, #40]	; 0x28
 801af92:	f9b7 102a 	ldrsh.w	r1, [r7, #42]	; 0x2a
 801af96:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
 801af9a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801af9c:	4413      	add	r3, r2
 801af9e:	781a      	ldrb	r2, [r3, #0]
 801afa0:	687b      	ldr	r3, [r7, #4]
 801afa2:	9200      	str	r2, [sp, #0]
 801afa4:	8a1b      	ldrh	r3, [r3, #16]
 801afa6:	68ba      	ldr	r2, [r7, #8]
 801afa8:	f7fa febe 	bl	8015d28 <lv_draw_px>
            }

            if(point_lb.x < ofs_lb.x && point_lb.y > ofs_lb.y) {
 801afac:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
 801afb0:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 801afb4:	429a      	cmp	r2, r3
 801afb6:	da14      	bge.n	801afe2 <lv_draw_shadow_full+0x554>
 801afb8:	f9b7 2026 	ldrsh.w	r2, [r7, #38]	; 0x26
 801afbc:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 801afc0:	429a      	cmp	r2, r3
 801afc2:	dd0e      	ble.n	801afe2 <lv_draw_shadow_full+0x554>
                lv_draw_px(point_lb.x, point_lb.y, mask, style->body.shadow.color, line_2d_blur[d]);
 801afc4:	f9b7 0024 	ldrsh.w	r0, [r7, #36]	; 0x24
 801afc8:	f9b7 1026 	ldrsh.w	r1, [r7, #38]	; 0x26
 801afcc:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
 801afd0:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801afd2:	4413      	add	r3, r2
 801afd4:	781a      	ldrb	r2, [r3, #0]
 801afd6:	687b      	ldr	r3, [r7, #4]
 801afd8:	9200      	str	r2, [sp, #0]
 801afda:	8a1b      	ldrh	r3, [r3, #16]
 801afdc:	68ba      	ldr	r2, [r7, #8]
 801afde:	f7fa fea3 	bl	8015d28 <lv_draw_px>
            }

            if(point_rt.x > ofs_rt.x && point_rt.y < ofs_rt.y) {
 801afe2:	f9b7 2030 	ldrsh.w	r2, [r7, #48]	; 0x30
 801afe6:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 801afea:	429a      	cmp	r2, r3
 801afec:	dd14      	ble.n	801b018 <lv_draw_shadow_full+0x58a>
 801afee:	f9b7 2032 	ldrsh.w	r2, [r7, #50]	; 0x32
 801aff2:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 801aff6:	429a      	cmp	r2, r3
 801aff8:	da0e      	bge.n	801b018 <lv_draw_shadow_full+0x58a>
                lv_draw_px(point_rt.x, point_rt.y, mask, style->body.shadow.color, line_2d_blur[d]);
 801affa:	f9b7 0030 	ldrsh.w	r0, [r7, #48]	; 0x30
 801affe:	f9b7 1032 	ldrsh.w	r1, [r7, #50]	; 0x32
 801b002:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
 801b006:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801b008:	4413      	add	r3, r2
 801b00a:	781a      	ldrb	r2, [r3, #0]
 801b00c:	687b      	ldr	r3, [r7, #4]
 801b00e:	9200      	str	r2, [sp, #0]
 801b010:	8a1b      	ldrh	r3, [r3, #16]
 801b012:	68ba      	ldr	r2, [r7, #8]
 801b014:	f7fa fe88 	bl	8015d28 <lv_draw_px>
            }

            if(point_rb.x > ofs_rb.x && point_rb.y > ofs_rb.y) {
 801b018:	f9b7 202c 	ldrsh.w	r2, [r7, #44]	; 0x2c
 801b01c:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 801b020:	429a      	cmp	r2, r3
 801b022:	dd14      	ble.n	801b04e <lv_draw_shadow_full+0x5c0>
 801b024:	f9b7 202e 	ldrsh.w	r2, [r7, #46]	; 0x2e
 801b028:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 801b02c:	429a      	cmp	r2, r3
 801b02e:	dd0e      	ble.n	801b04e <lv_draw_shadow_full+0x5c0>
                lv_draw_px(point_rb.x, point_rb.y, mask, style->body.shadow.color, line_2d_blur[d]);
 801b030:	f9b7 002c 	ldrsh.w	r0, [r7, #44]	; 0x2c
 801b034:	f9b7 102e 	ldrsh.w	r1, [r7, #46]	; 0x2e
 801b038:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
 801b03c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801b03e:	4413      	add	r3, r2
 801b040:	781a      	ldrb	r2, [r3, #0]
 801b042:	687b      	ldr	r3, [r7, #4]
 801b044:	9200      	str	r2, [sp, #0]
 801b046:	8a1b      	ldrh	r3, [r3, #16]
 801b048:	68ba      	ldr	r2, [r7, #8]
 801b04a:	f7fa fe6d 	bl	8015d28 <lv_draw_px>
            }

            point_rb.x++;
 801b04e:	f9b7 302c 	ldrsh.w	r3, [r7, #44]	; 0x2c
 801b052:	b29b      	uxth	r3, r3
 801b054:	3301      	adds	r3, #1
 801b056:	b29b      	uxth	r3, r3
 801b058:	b21b      	sxth	r3, r3
 801b05a:	85bb      	strh	r3, [r7, #44]	; 0x2c
            point_lb.x--;
 801b05c:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 801b060:	b29b      	uxth	r3, r3
 801b062:	3b01      	subs	r3, #1
 801b064:	b29b      	uxth	r3, r3
 801b066:	b21b      	sxth	r3, r3
 801b068:	84bb      	strh	r3, [r7, #36]	; 0x24

            point_rt.x++;
 801b06a:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 801b06e:	b29b      	uxth	r3, r3
 801b070:	3301      	adds	r3, #1
 801b072:	b29b      	uxth	r3, r3
 801b074:	b21b      	sxth	r3, r3
 801b076:	863b      	strh	r3, [r7, #48]	; 0x30
            point_lt.x--;
 801b078:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 801b07c:	b29b      	uxth	r3, r3
 801b07e:	3b01      	subs	r3, #1
 801b080:	b29b      	uxth	r3, r3
 801b082:	b21b      	sxth	r3, r3
 801b084:	853b      	strh	r3, [r7, #40]	; 0x28
        for(d = 1; d < col; d++) {
 801b086:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
 801b08a:	3301      	adds	r3, #1
 801b08c:	f8a7 3068 	strh.w	r3, [r7, #104]	; 0x68
 801b090:	f8b7 2068 	ldrh.w	r2, [r7, #104]	; 0x68
 801b094:	f8b7 3074 	ldrh.w	r3, [r7, #116]	; 0x74
 801b098:	429a      	cmp	r2, r3
 801b09a:	f4ff af6c 	bcc.w	801af76 <lv_draw_shadow_full+0x4e8>
        }

        /* Put the first line to the edges too.
         * It is not correct because blur should be done below the corner too
         * but is is simple, fast and gives a good enough result*/
        if(line == 0) lv_draw_shadow_full_straight(coords, mask, style, line_2d_blur);
 801b09e:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 801b0a2:	2b00      	cmp	r3, #0
 801b0a4:	d105      	bne.n	801b0b2 <lv_draw_shadow_full+0x624>
 801b0a6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b0a8:	687a      	ldr	r2, [r7, #4]
 801b0aa:	68b9      	ldr	r1, [r7, #8]
 801b0ac:	68f8      	ldr	r0, [r7, #12]
 801b0ae:	f000 fa19 	bl	801b4e4 <lv_draw_shadow_full_straight>
    for(line = 0; line <= radius + swidth; line++) { /*Check all rows and make the 1D blur to 2D*/
 801b0b2:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 801b0b6:	b29b      	uxth	r3, r3
 801b0b8:	3301      	adds	r3, #1
 801b0ba:	b29b      	uxth	r3, r3
 801b0bc:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76
 801b0c0:	f9b7 2076 	ldrsh.w	r2, [r7, #118]	; 0x76
 801b0c4:	f9b7 1064 	ldrsh.w	r1, [r7, #100]	; 0x64
 801b0c8:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 801b0cc:	440b      	add	r3, r1
 801b0ce:	429a      	cmp	r2, r3
 801b0d0:	f77f ae3b 	ble.w	801ad4a <lv_draw_shadow_full+0x2bc>
    }
}
 801b0d4:	bf00      	nop
 801b0d6:	bf00      	nop
 801b0d8:	3778      	adds	r7, #120	; 0x78
 801b0da:	46bd      	mov	sp, r7
 801b0dc:	bd80      	pop	{r7, pc}

0801b0de <lv_draw_shadow_bottom>:

static void lv_draw_shadow_bottom(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style,
                                  lv_opa_t opa_scale)
{
 801b0de:	b580      	push	{r7, lr}
 801b0e0:	b09a      	sub	sp, #104	; 0x68
 801b0e2:	af02      	add	r7, sp, #8
 801b0e4:	60f8      	str	r0, [r7, #12]
 801b0e6:	60b9      	str	r1, [r7, #8]
 801b0e8:	607a      	str	r2, [r7, #4]
 801b0ea:	70fb      	strb	r3, [r7, #3]
    bool aa           = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
 801b0ec:	f7f9 f9d2 	bl	8014494 <lv_refr_get_disp_refreshing>
 801b0f0:	4603      	mov	r3, r0
 801b0f2:	4618      	mov	r0, r3
 801b0f4:	f002 f851 	bl	801d19a <lv_disp_get_antialiasing>
 801b0f8:	4603      	mov	r3, r0
 801b0fa:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
    lv_coord_t radius = style->body.radius;
 801b0fe:	687b      	ldr	r3, [r7, #4]
 801b100:	88db      	ldrh	r3, [r3, #6]
 801b102:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
    lv_coord_t swidth = style->body.shadow.width;
 801b106:	687b      	ldr	r3, [r7, #4]
 801b108:	8a5b      	ldrh	r3, [r3, #18]
 801b10a:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
    lv_coord_t width  = lv_area_get_width(coords);
 801b10e:	68f8      	ldr	r0, [r7, #12]
 801b110:	f7fc fc95 	bl	8017a3e <lv_area_get_width>
 801b114:	4603      	mov	r3, r0
 801b116:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
    lv_coord_t height = lv_area_get_height(coords);
 801b11a:	68f8      	ldr	r0, [r7, #12]
 801b11c:	f7fc fca6 	bl	8017a6c <lv_area_get_height>
 801b120:	4603      	mov	r3, r0
 801b122:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

    radius = lv_draw_cont_radius_corr(radius, width, height);
 801b126:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 801b12a:	f9b7 204e 	ldrsh.w	r2, [r7, #78]	; 0x4e
 801b12e:	f9b7 1050 	ldrsh.w	r1, [r7, #80]	; 0x50
 801b132:	4618      	mov	r0, r3
 801b134:	f000 fb2e 	bl	801b794 <lv_draw_cont_radius_corr>
 801b138:	4603      	mov	r3, r0
 801b13a:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
    radius += aa * SHADOW_BOTTOM_AA_EXTRA_RADIUS;
 801b13e:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 801b142:	b29b      	uxth	r3, r3
 801b144:	461a      	mov	r2, r3
 801b146:	0052      	lsls	r2, r2, #1
 801b148:	4413      	add	r3, r2
 801b14a:	b29a      	uxth	r2, r3
 801b14c:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 801b150:	4413      	add	r3, r2
 801b152:	b29b      	uxth	r3, r3
 801b154:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
    swidth += aa;
 801b158:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 801b15c:	b29a      	uxth	r2, r3
 801b15e:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 801b162:	4413      	add	r3, r2
 801b164:	b29b      	uxth	r3, r3
 801b166:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52

    uint32_t curve_x_size = ((radius + 1) + 3) & ~0x3; /*Round to 4*/
 801b16a:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 801b16e:	3304      	adds	r3, #4
 801b170:	f023 0303 	bic.w	r3, r3, #3
 801b174:	64bb      	str	r3, [r7, #72]	; 0x48
    curve_x_size *= sizeof(lv_coord_t);
 801b176:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801b178:	005b      	lsls	r3, r3, #1
 801b17a:	64bb      	str	r3, [r7, #72]	; 0x48
    lv_opa_t line_1d_blur_size = (swidth + 3) & ~0x3;     /*Round to 4*/
 801b17c:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 801b180:	b2db      	uxtb	r3, r3
 801b182:	3303      	adds	r3, #3
 801b184:	b2db      	uxtb	r3, r3
 801b186:	f023 0303 	bic.w	r3, r3, #3
 801b18a:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
    line_1d_blur_size *= sizeof(lv_opa_t);

    uint8_t * draw_buf = lv_draw_get_buf(curve_x_size + line_1d_blur_size);
 801b18e:	f897 2047 	ldrb.w	r2, [r7, #71]	; 0x47
 801b192:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801b194:	4413      	add	r3, r2
 801b196:	4618      	mov	r0, r3
 801b198:	f7fa f8fe 	bl	8015398 <lv_draw_get_buf>
 801b19c:	6438      	str	r0, [r7, #64]	; 0x40

    /*Divide the draw buffer*/
    lv_coord_t  * curve_x = (lv_coord_t *)&draw_buf[0]; /*Stores the 'x' coordinates of a quarter circle.*/
 801b19e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801b1a0:	63fb      	str	r3, [r7, #60]	; 0x3c
    lv_opa_t * line_1d_blur = (lv_opa_t *)&draw_buf[curve_x_size];
 801b1a2:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801b1a4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801b1a6:	4413      	add	r3, r2
 801b1a8:	63bb      	str	r3, [r7, #56]	; 0x38

    lv_point_t circ;
    lv_coord_t circ_tmp;
    lv_circ_init(&circ, &circ_tmp, radius);
 801b1aa:	f9b7 2054 	ldrsh.w	r2, [r7, #84]	; 0x54
 801b1ae:	f107 012e 	add.w	r1, r7, #46	; 0x2e
 801b1b2:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801b1b6:	4618      	mov	r0, r3
 801b1b8:	f002 fc19 	bl	801d9ee <lv_circ_init>
    while(lv_circ_cont(&circ)) {
 801b1bc:	e017      	b.n	801b1ee <lv_draw_shadow_bottom+0x110>
        curve_x[LV_CIRC_OCT1_Y(circ)] = LV_CIRC_OCT1_X(circ);
 801b1be:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 801b1c2:	005b      	lsls	r3, r3, #1
 801b1c4:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801b1c6:	4413      	add	r3, r2
 801b1c8:	f9b7 2030 	ldrsh.w	r2, [r7, #48]	; 0x30
 801b1cc:	801a      	strh	r2, [r3, #0]
        curve_x[LV_CIRC_OCT2_Y(circ)] = LV_CIRC_OCT2_X(circ);
 801b1ce:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 801b1d2:	005b      	lsls	r3, r3, #1
 801b1d4:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801b1d6:	4413      	add	r3, r2
 801b1d8:	f9b7 2032 	ldrsh.w	r2, [r7, #50]	; 0x32
 801b1dc:	801a      	strh	r2, [r3, #0]
        lv_circ_next(&circ, &circ_tmp);
 801b1de:	f107 022e 	add.w	r2, r7, #46	; 0x2e
 801b1e2:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801b1e6:	4611      	mov	r1, r2
 801b1e8:	4618      	mov	r0, r3
 801b1ea:	f002 fc2f 	bl	801da4c <lv_circ_next>
    while(lv_circ_cont(&circ)) {
 801b1ee:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801b1f2:	4618      	mov	r0, r3
 801b1f4:	f002 fc15 	bl	801da22 <lv_circ_cont>
 801b1f8:	4603      	mov	r3, r0
 801b1fa:	2b00      	cmp	r3, #0
 801b1fc:	d1df      	bne.n	801b1be <lv_draw_shadow_bottom+0xe0>
    }

    int16_t col;

    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->body.opa : (uint16_t)((uint16_t)style->body.opa * opa_scale) >> 8;
 801b1fe:	78fb      	ldrb	r3, [r7, #3]
 801b200:	2bff      	cmp	r3, #255	; 0xff
 801b202:	d102      	bne.n	801b20a <lv_draw_shadow_bottom+0x12c>
 801b204:	687b      	ldr	r3, [r7, #4]
 801b206:	7a1b      	ldrb	r3, [r3, #8]
 801b208:	e00a      	b.n	801b220 <lv_draw_shadow_bottom+0x142>
 801b20a:	687b      	ldr	r3, [r7, #4]
 801b20c:	7a1b      	ldrb	r3, [r3, #8]
 801b20e:	b29a      	uxth	r2, r3
 801b210:	78fb      	ldrb	r3, [r7, #3]
 801b212:	b29b      	uxth	r3, r3
 801b214:	fb12 f303 	smulbb	r3, r2, r3
 801b218:	b29b      	uxth	r3, r3
 801b21a:	0a1b      	lsrs	r3, r3, #8
 801b21c:	b29b      	uxth	r3, r3
 801b21e:	b2db      	uxtb	r3, r3
 801b220:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    for(col = 0; col < swidth; col++) {
 801b224:	2300      	movs	r3, #0
 801b226:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
 801b22a:	e01b      	b.n	801b264 <lv_draw_shadow_bottom+0x186>
        line_1d_blur[col] = (uint32_t)((uint32_t)(swidth - col) * opa / 2) / (swidth);
 801b22c:	f9b7 2052 	ldrsh.w	r2, [r7, #82]	; 0x52
 801b230:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 801b234:	1ad3      	subs	r3, r2, r3
 801b236:	461a      	mov	r2, r3
 801b238:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801b23c:	fb03 f302 	mul.w	r3, r3, r2
 801b240:	085a      	lsrs	r2, r3, #1
 801b242:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 801b246:	fbb2 f1f3 	udiv	r1, r2, r3
 801b24a:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 801b24e:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801b250:	4413      	add	r3, r2
 801b252:	b2ca      	uxtb	r2, r1
 801b254:	701a      	strb	r2, [r3, #0]
    for(col = 0; col < swidth; col++) {
 801b256:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 801b25a:	b29b      	uxth	r3, r3
 801b25c:	3301      	adds	r3, #1
 801b25e:	b29b      	uxth	r3, r3
 801b260:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
 801b264:	f9b7 205e 	ldrsh.w	r2, [r7, #94]	; 0x5e
 801b268:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 801b26c:	429a      	cmp	r2, r3
 801b26e:	dbdd      	blt.n	801b22c <lv_draw_shadow_bottom+0x14e>
    lv_point_t point_r;
    lv_area_t area_mid;
    lv_point_t ofs_l;
    lv_point_t ofs_r;

    ofs_l.x = coords->x1 + radius;
 801b270:	68fb      	ldr	r3, [r7, #12]
 801b272:	f9b3 3000 	ldrsh.w	r3, [r3]
 801b276:	b29a      	uxth	r2, r3
 801b278:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 801b27c:	4413      	add	r3, r2
 801b27e:	b29b      	uxth	r3, r3
 801b280:	b21b      	sxth	r3, r3
 801b282:	833b      	strh	r3, [r7, #24]
    ofs_l.y = coords->y2 - radius + 1 - aa;
 801b284:	68fb      	ldr	r3, [r7, #12]
 801b286:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801b28a:	b29a      	uxth	r2, r3
 801b28c:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 801b290:	1ad3      	subs	r3, r2, r3
 801b292:	b29a      	uxth	r2, r3
 801b294:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 801b298:	b29b      	uxth	r3, r3
 801b29a:	1ad3      	subs	r3, r2, r3
 801b29c:	b29b      	uxth	r3, r3
 801b29e:	3301      	adds	r3, #1
 801b2a0:	b29b      	uxth	r3, r3
 801b2a2:	b21b      	sxth	r3, r3
 801b2a4:	837b      	strh	r3, [r7, #26]

    ofs_r.x = coords->x2 - radius;
 801b2a6:	68fb      	ldr	r3, [r7, #12]
 801b2a8:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801b2ac:	b29a      	uxth	r2, r3
 801b2ae:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 801b2b2:	1ad3      	subs	r3, r2, r3
 801b2b4:	b29b      	uxth	r3, r3
 801b2b6:	b21b      	sxth	r3, r3
 801b2b8:	82bb      	strh	r3, [r7, #20]
    ofs_r.y = coords->y2 - radius + 1 - aa;
 801b2ba:	68fb      	ldr	r3, [r7, #12]
 801b2bc:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801b2c0:	b29a      	uxth	r2, r3
 801b2c2:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 801b2c6:	1ad3      	subs	r3, r2, r3
 801b2c8:	b29a      	uxth	r2, r3
 801b2ca:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 801b2ce:	b29b      	uxth	r3, r3
 801b2d0:	1ad3      	subs	r3, r2, r3
 801b2d2:	b29b      	uxth	r3, r3
 801b2d4:	3301      	adds	r3, #1
 801b2d6:	b29b      	uxth	r3, r3
 801b2d8:	b21b      	sxth	r3, r3
 801b2da:	82fb      	strh	r3, [r7, #22]

    for(col = 0; col <= radius; col++) {
 801b2dc:	2300      	movs	r3, #0
 801b2de:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
 801b2e2:	e0b0      	b.n	801b446 <lv_draw_shadow_bottom+0x368>
        point_l.x = ofs_l.x - col;
 801b2e4:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 801b2e8:	b29a      	uxth	r2, r3
 801b2ea:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801b2ee:	1ad3      	subs	r3, r2, r3
 801b2f0:	b29b      	uxth	r3, r3
 801b2f2:	b21b      	sxth	r3, r3
 801b2f4:	853b      	strh	r3, [r7, #40]	; 0x28
        point_l.y = ofs_l.y + curve_x[col];
 801b2f6:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 801b2fa:	b29a      	uxth	r2, r3
 801b2fc:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 801b300:	005b      	lsls	r3, r3, #1
 801b302:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 801b304:	440b      	add	r3, r1
 801b306:	f9b3 3000 	ldrsh.w	r3, [r3]
 801b30a:	b29b      	uxth	r3, r3
 801b30c:	4413      	add	r3, r2
 801b30e:	b29b      	uxth	r3, r3
 801b310:	b21b      	sxth	r3, r3
 801b312:	857b      	strh	r3, [r7, #42]	; 0x2a

        point_r.x = ofs_r.x + col;
 801b314:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 801b318:	b29a      	uxth	r2, r3
 801b31a:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801b31e:	4413      	add	r3, r2
 801b320:	b29b      	uxth	r3, r3
 801b322:	b21b      	sxth	r3, r3
 801b324:	84bb      	strh	r3, [r7, #36]	; 0x24
        point_r.y = ofs_r.y + curve_x[col];
 801b326:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 801b32a:	b29a      	uxth	r2, r3
 801b32c:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 801b330:	005b      	lsls	r3, r3, #1
 801b332:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 801b334:	440b      	add	r3, r1
 801b336:	f9b3 3000 	ldrsh.w	r3, [r3]
 801b33a:	b29b      	uxth	r3, r3
 801b33c:	4413      	add	r3, r2
 801b33e:	b29b      	uxth	r3, r3
 801b340:	b21b      	sxth	r3, r3
 801b342:	84fb      	strh	r3, [r7, #38]	; 0x26

        lv_opa_t px_opa;
        int16_t diff = col == 0 ? 0 : curve_x[col - 1] - curve_x[col];
 801b344:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 801b348:	2b00      	cmp	r3, #0
 801b34a:	d016      	beq.n	801b37a <lv_draw_shadow_bottom+0x29c>
 801b34c:	f9b7 205e 	ldrsh.w	r2, [r7, #94]	; 0x5e
 801b350:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 801b354:	4413      	add	r3, r2
 801b356:	005b      	lsls	r3, r3, #1
 801b358:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801b35a:	4413      	add	r3, r2
 801b35c:	f9b3 3000 	ldrsh.w	r3, [r3]
 801b360:	b29a      	uxth	r2, r3
 801b362:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 801b366:	005b      	lsls	r3, r3, #1
 801b368:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 801b36a:	440b      	add	r3, r1
 801b36c:	f9b3 3000 	ldrsh.w	r3, [r3]
 801b370:	b29b      	uxth	r3, r3
 801b372:	1ad3      	subs	r3, r2, r3
 801b374:	b29b      	uxth	r3, r3
 801b376:	b21b      	sxth	r3, r3
 801b378:	e000      	b.n	801b37c <lv_draw_shadow_bottom+0x29e>
 801b37a:	2300      	movs	r3, #0
 801b37c:	86bb      	strh	r3, [r7, #52]	; 0x34
        uint16_t d;
        for(d = 0; d < swidth; d++) {
 801b37e:	2300      	movs	r3, #0
 801b380:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
 801b384:	e052      	b.n	801b42c <lv_draw_shadow_bottom+0x34e>
            /*When stepping a pixel in y calculate the average with the pixel from the prev. column
             * to make a blur */
            if(diff == 0) {
 801b386:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 801b38a:	2b00      	cmp	r3, #0
 801b38c:	d107      	bne.n	801b39e <lv_draw_shadow_bottom+0x2c0>
                px_opa = line_1d_blur[d];
 801b38e:	f8b7 305a 	ldrh.w	r3, [r7, #90]	; 0x5a
 801b392:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801b394:	4413      	add	r3, r2
 801b396:	781b      	ldrb	r3, [r3, #0]
 801b398:	f887 305d 	strb.w	r3, [r7, #93]	; 0x5d
 801b39c:	e015      	b.n	801b3ca <lv_draw_shadow_bottom+0x2ec>
            } else {
                px_opa = (uint16_t)((uint16_t)line_1d_blur[d] + line_1d_blur[d - diff]) >> 1;
 801b39e:	f8b7 305a 	ldrh.w	r3, [r7, #90]	; 0x5a
 801b3a2:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801b3a4:	4413      	add	r3, r2
 801b3a6:	781b      	ldrb	r3, [r3, #0]
 801b3a8:	b29a      	uxth	r2, r3
 801b3aa:	f8b7 105a 	ldrh.w	r1, [r7, #90]	; 0x5a
 801b3ae:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 801b3b2:	1acb      	subs	r3, r1, r3
 801b3b4:	4619      	mov	r1, r3
 801b3b6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801b3b8:	440b      	add	r3, r1
 801b3ba:	781b      	ldrb	r3, [r3, #0]
 801b3bc:	b29b      	uxth	r3, r3
 801b3be:	4413      	add	r3, r2
 801b3c0:	b29b      	uxth	r3, r3
 801b3c2:	085b      	lsrs	r3, r3, #1
 801b3c4:	b29b      	uxth	r3, r3
 801b3c6:	f887 305d 	strb.w	r3, [r7, #93]	; 0x5d
            }
            lv_draw_px(point_l.x, point_l.y, mask, style->body.shadow.color, px_opa);
 801b3ca:	f9b7 0028 	ldrsh.w	r0, [r7, #40]	; 0x28
 801b3ce:	f9b7 102a 	ldrsh.w	r1, [r7, #42]	; 0x2a
 801b3d2:	687b      	ldr	r3, [r7, #4]
 801b3d4:	f897 205d 	ldrb.w	r2, [r7, #93]	; 0x5d
 801b3d8:	9200      	str	r2, [sp, #0]
 801b3da:	8a1b      	ldrh	r3, [r3, #16]
 801b3dc:	68ba      	ldr	r2, [r7, #8]
 801b3de:	f7fa fca3 	bl	8015d28 <lv_draw_px>
            point_l.y++;
 801b3e2:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 801b3e6:	b29b      	uxth	r3, r3
 801b3e8:	3301      	adds	r3, #1
 801b3ea:	b29b      	uxth	r3, r3
 801b3ec:	b21b      	sxth	r3, r3
 801b3ee:	857b      	strh	r3, [r7, #42]	; 0x2a

            /*Don't overdraw the pixel on the middle*/
            if(point_r.x > ofs_l.x) {
 801b3f0:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
 801b3f4:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 801b3f8:	429a      	cmp	r2, r3
 801b3fa:	dd0b      	ble.n	801b414 <lv_draw_shadow_bottom+0x336>
                lv_draw_px(point_r.x, point_r.y, mask, style->body.shadow.color, px_opa);
 801b3fc:	f9b7 0024 	ldrsh.w	r0, [r7, #36]	; 0x24
 801b400:	f9b7 1026 	ldrsh.w	r1, [r7, #38]	; 0x26
 801b404:	687b      	ldr	r3, [r7, #4]
 801b406:	f897 205d 	ldrb.w	r2, [r7, #93]	; 0x5d
 801b40a:	9200      	str	r2, [sp, #0]
 801b40c:	8a1b      	ldrh	r3, [r3, #16]
 801b40e:	68ba      	ldr	r2, [r7, #8]
 801b410:	f7fa fc8a 	bl	8015d28 <lv_draw_px>
            }
            point_r.y++;
 801b414:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 801b418:	b29b      	uxth	r3, r3
 801b41a:	3301      	adds	r3, #1
 801b41c:	b29b      	uxth	r3, r3
 801b41e:	b21b      	sxth	r3, r3
 801b420:	84fb      	strh	r3, [r7, #38]	; 0x26
        for(d = 0; d < swidth; d++) {
 801b422:	f8b7 305a 	ldrh.w	r3, [r7, #90]	; 0x5a
 801b426:	3301      	adds	r3, #1
 801b428:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
 801b42c:	f8b7 205a 	ldrh.w	r2, [r7, #90]	; 0x5a
 801b430:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 801b434:	429a      	cmp	r2, r3
 801b436:	dba6      	blt.n	801b386 <lv_draw_shadow_bottom+0x2a8>
    for(col = 0; col <= radius; col++) {
 801b438:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 801b43c:	b29b      	uxth	r3, r3
 801b43e:	3301      	adds	r3, #1
 801b440:	b29b      	uxth	r3, r3
 801b442:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
 801b446:	f9b7 205e 	ldrsh.w	r2, [r7, #94]	; 0x5e
 801b44a:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 801b44e:	429a      	cmp	r2, r3
 801b450:	f77f af48 	ble.w	801b2e4 <lv_draw_shadow_bottom+0x206>
        }
    }

    area_mid.x1 = ofs_l.x + 1;
 801b454:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 801b458:	b29b      	uxth	r3, r3
 801b45a:	3301      	adds	r3, #1
 801b45c:	b29b      	uxth	r3, r3
 801b45e:	b21b      	sxth	r3, r3
 801b460:	83bb      	strh	r3, [r7, #28]
    area_mid.y1 = ofs_l.y + radius;
 801b462:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 801b466:	b29a      	uxth	r2, r3
 801b468:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 801b46c:	4413      	add	r3, r2
 801b46e:	b29b      	uxth	r3, r3
 801b470:	b21b      	sxth	r3, r3
 801b472:	83fb      	strh	r3, [r7, #30]
    area_mid.x2 = ofs_r.x - 1;
 801b474:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 801b478:	b29b      	uxth	r3, r3
 801b47a:	3b01      	subs	r3, #1
 801b47c:	b29b      	uxth	r3, r3
 801b47e:	b21b      	sxth	r3, r3
 801b480:	843b      	strh	r3, [r7, #32]
    area_mid.y2 = area_mid.y1;
 801b482:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 801b486:	847b      	strh	r3, [r7, #34]	; 0x22

    uint16_t d;
    for(d = 0; d < swidth; d++) {
 801b488:	2300      	movs	r3, #0
 801b48a:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58
 801b48e:	e01e      	b.n	801b4ce <lv_draw_shadow_bottom+0x3f0>
        lv_draw_fill(&area_mid, mask, style->body.shadow.color, line_1d_blur[d]);
 801b490:	f8b7 3058 	ldrh.w	r3, [r7, #88]	; 0x58
 801b494:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801b496:	4413      	add	r3, r2
 801b498:	781b      	ldrb	r3, [r3, #0]
 801b49a:	687a      	ldr	r2, [r7, #4]
 801b49c:	f107 001c 	add.w	r0, r7, #28
 801b4a0:	8a12      	ldrh	r2, [r2, #16]
 801b4a2:	68b9      	ldr	r1, [r7, #8]
 801b4a4:	f7fa fcd8 	bl	8015e58 <lv_draw_fill>
        area_mid.y1++;
 801b4a8:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 801b4ac:	b29b      	uxth	r3, r3
 801b4ae:	3301      	adds	r3, #1
 801b4b0:	b29b      	uxth	r3, r3
 801b4b2:	b21b      	sxth	r3, r3
 801b4b4:	83fb      	strh	r3, [r7, #30]
        area_mid.y2++;
 801b4b6:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 801b4ba:	b29b      	uxth	r3, r3
 801b4bc:	3301      	adds	r3, #1
 801b4be:	b29b      	uxth	r3, r3
 801b4c0:	b21b      	sxth	r3, r3
 801b4c2:	847b      	strh	r3, [r7, #34]	; 0x22
    for(d = 0; d < swidth; d++) {
 801b4c4:	f8b7 3058 	ldrh.w	r3, [r7, #88]	; 0x58
 801b4c8:	3301      	adds	r3, #1
 801b4ca:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58
 801b4ce:	f8b7 2058 	ldrh.w	r2, [r7, #88]	; 0x58
 801b4d2:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 801b4d6:	429a      	cmp	r2, r3
 801b4d8:	dbda      	blt.n	801b490 <lv_draw_shadow_bottom+0x3b2>
    }
}
 801b4da:	bf00      	nop
 801b4dc:	bf00      	nop
 801b4de:	3760      	adds	r7, #96	; 0x60
 801b4e0:	46bd      	mov	sp, r7
 801b4e2:	bd80      	pop	{r7, pc}

0801b4e4 <lv_draw_shadow_full_straight>:

static void lv_draw_shadow_full_straight(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style,
                                         const lv_opa_t * map)
{
 801b4e4:	b580      	push	{r7, lr}
 801b4e6:	b090      	sub	sp, #64	; 0x40
 801b4e8:	af00      	add	r7, sp, #0
 801b4ea:	60f8      	str	r0, [r7, #12]
 801b4ec:	60b9      	str	r1, [r7, #8]
 801b4ee:	607a      	str	r2, [r7, #4]
 801b4f0:	603b      	str	r3, [r7, #0]
    bool aa           = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
 801b4f2:	f7f8 ffcf 	bl	8014494 <lv_refr_get_disp_refreshing>
 801b4f6:	4603      	mov	r3, r0
 801b4f8:	4618      	mov	r0, r3
 801b4fa:	f001 fe4e 	bl	801d19a <lv_disp_get_antialiasing>
 801b4fe:	4603      	mov	r3, r0
 801b500:	f887 303d 	strb.w	r3, [r7, #61]	; 0x3d
    lv_coord_t radius = style->body.radius;
 801b504:	687b      	ldr	r3, [r7, #4]
 801b506:	88db      	ldrh	r3, [r3, #6]
 801b508:	877b      	strh	r3, [r7, #58]	; 0x3a
    lv_coord_t swidth = style->body.shadow.width;
 801b50a:	687b      	ldr	r3, [r7, #4]
 801b50c:	8a5b      	ldrh	r3, [r3, #18]
 801b50e:	873b      	strh	r3, [r7, #56]	; 0x38
    lv_coord_t width  = lv_area_get_width(coords);
 801b510:	68f8      	ldr	r0, [r7, #12]
 801b512:	f7fc fa94 	bl	8017a3e <lv_area_get_width>
 801b516:	4603      	mov	r3, r0
 801b518:	86fb      	strh	r3, [r7, #54]	; 0x36
    lv_coord_t height = lv_area_get_height(coords);
 801b51a:	68f8      	ldr	r0, [r7, #12]
 801b51c:	f7fc faa6 	bl	8017a6c <lv_area_get_height>
 801b520:	4603      	mov	r3, r0
 801b522:	86bb      	strh	r3, [r7, #52]	; 0x34

    radius = lv_draw_cont_radius_corr(radius, width, height);
 801b524:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 801b526:	f9b7 2034 	ldrsh.w	r2, [r7, #52]	; 0x34
 801b52a:	f9b7 1036 	ldrsh.w	r1, [r7, #54]	; 0x36
 801b52e:	4618      	mov	r0, r3
 801b530:	f000 f930 	bl	801b794 <lv_draw_cont_radius_corr>
 801b534:	4603      	mov	r3, r0
 801b536:	877b      	strh	r3, [r7, #58]	; 0x3a
    radius += aa;
 801b538:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 801b53c:	b29a      	uxth	r2, r3
 801b53e:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 801b540:	4413      	add	r3, r2
 801b542:	b29b      	uxth	r3, r3
 801b544:	877b      	strh	r3, [r7, #58]	; 0x3a

    lv_area_t right_area;
    right_area.x1 = coords->x2 + 1 - aa;
 801b546:	68fb      	ldr	r3, [r7, #12]
 801b548:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801b54c:	b29a      	uxth	r2, r3
 801b54e:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 801b552:	b29b      	uxth	r3, r3
 801b554:	1ad3      	subs	r3, r2, r3
 801b556:	b29b      	uxth	r3, r3
 801b558:	3301      	adds	r3, #1
 801b55a:	b29b      	uxth	r3, r3
 801b55c:	b21b      	sxth	r3, r3
 801b55e:	853b      	strh	r3, [r7, #40]	; 0x28
    right_area.y1 = coords->y1 + radius + aa;
 801b560:	68fb      	ldr	r3, [r7, #12]
 801b562:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801b566:	b29a      	uxth	r2, r3
 801b568:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 801b56a:	4413      	add	r3, r2
 801b56c:	b29a      	uxth	r2, r3
 801b56e:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 801b572:	b29b      	uxth	r3, r3
 801b574:	4413      	add	r3, r2
 801b576:	b29b      	uxth	r3, r3
 801b578:	b21b      	sxth	r3, r3
 801b57a:	857b      	strh	r3, [r7, #42]	; 0x2a
    right_area.x2 = right_area.x1;
 801b57c:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 801b580:	85bb      	strh	r3, [r7, #44]	; 0x2c
    right_area.y2 = coords->y2 - radius - aa;
 801b582:	68fb      	ldr	r3, [r7, #12]
 801b584:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801b588:	b29a      	uxth	r2, r3
 801b58a:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 801b58c:	1ad3      	subs	r3, r2, r3
 801b58e:	b29a      	uxth	r2, r3
 801b590:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 801b594:	b29b      	uxth	r3, r3
 801b596:	1ad3      	subs	r3, r2, r3
 801b598:	b29b      	uxth	r3, r3
 801b59a:	b21b      	sxth	r3, r3
 801b59c:	85fb      	strh	r3, [r7, #46]	; 0x2e

    lv_area_t left_area;
    left_area.x1 = coords->x1 - 1 + aa;
 801b59e:	68fb      	ldr	r3, [r7, #12]
 801b5a0:	f9b3 3000 	ldrsh.w	r3, [r3]
 801b5a4:	b29a      	uxth	r2, r3
 801b5a6:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 801b5aa:	b29b      	uxth	r3, r3
 801b5ac:	4413      	add	r3, r2
 801b5ae:	b29b      	uxth	r3, r3
 801b5b0:	3b01      	subs	r3, #1
 801b5b2:	b29b      	uxth	r3, r3
 801b5b4:	b21b      	sxth	r3, r3
 801b5b6:	843b      	strh	r3, [r7, #32]
    left_area.y1 = coords->y1 + radius + aa;
 801b5b8:	68fb      	ldr	r3, [r7, #12]
 801b5ba:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801b5be:	b29a      	uxth	r2, r3
 801b5c0:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 801b5c2:	4413      	add	r3, r2
 801b5c4:	b29a      	uxth	r2, r3
 801b5c6:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 801b5ca:	b29b      	uxth	r3, r3
 801b5cc:	4413      	add	r3, r2
 801b5ce:	b29b      	uxth	r3, r3
 801b5d0:	b21b      	sxth	r3, r3
 801b5d2:	847b      	strh	r3, [r7, #34]	; 0x22
    left_area.x2 = left_area.x1;
 801b5d4:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 801b5d8:	84bb      	strh	r3, [r7, #36]	; 0x24
    left_area.y2 = coords->y2 - radius - aa;
 801b5da:	68fb      	ldr	r3, [r7, #12]
 801b5dc:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801b5e0:	b29a      	uxth	r2, r3
 801b5e2:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 801b5e4:	1ad3      	subs	r3, r2, r3
 801b5e6:	b29a      	uxth	r2, r3
 801b5e8:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 801b5ec:	b29b      	uxth	r3, r3
 801b5ee:	1ad3      	subs	r3, r2, r3
 801b5f0:	b29b      	uxth	r3, r3
 801b5f2:	b21b      	sxth	r3, r3
 801b5f4:	84fb      	strh	r3, [r7, #38]	; 0x26

    lv_area_t top_area;
    top_area.x1 = coords->x1 + radius + aa;
 801b5f6:	68fb      	ldr	r3, [r7, #12]
 801b5f8:	f9b3 3000 	ldrsh.w	r3, [r3]
 801b5fc:	b29a      	uxth	r2, r3
 801b5fe:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 801b600:	4413      	add	r3, r2
 801b602:	b29a      	uxth	r2, r3
 801b604:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 801b608:	b29b      	uxth	r3, r3
 801b60a:	4413      	add	r3, r2
 801b60c:	b29b      	uxth	r3, r3
 801b60e:	b21b      	sxth	r3, r3
 801b610:	833b      	strh	r3, [r7, #24]
    top_area.y1 = coords->y1 - 1 + aa;
 801b612:	68fb      	ldr	r3, [r7, #12]
 801b614:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801b618:	b29a      	uxth	r2, r3
 801b61a:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 801b61e:	b29b      	uxth	r3, r3
 801b620:	4413      	add	r3, r2
 801b622:	b29b      	uxth	r3, r3
 801b624:	3b01      	subs	r3, #1
 801b626:	b29b      	uxth	r3, r3
 801b628:	b21b      	sxth	r3, r3
 801b62a:	837b      	strh	r3, [r7, #26]
    top_area.x2 = coords->x2 - radius - aa;
 801b62c:	68fb      	ldr	r3, [r7, #12]
 801b62e:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801b632:	b29a      	uxth	r2, r3
 801b634:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 801b636:	1ad3      	subs	r3, r2, r3
 801b638:	b29a      	uxth	r2, r3
 801b63a:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 801b63e:	b29b      	uxth	r3, r3
 801b640:	1ad3      	subs	r3, r2, r3
 801b642:	b29b      	uxth	r3, r3
 801b644:	b21b      	sxth	r3, r3
 801b646:	83bb      	strh	r3, [r7, #28]
    top_area.y2 = top_area.y1;
 801b648:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 801b64c:	83fb      	strh	r3, [r7, #30]

    lv_area_t bottom_area;
    bottom_area.x1 = coords->x1 + radius + aa;
 801b64e:	68fb      	ldr	r3, [r7, #12]
 801b650:	f9b3 3000 	ldrsh.w	r3, [r3]
 801b654:	b29a      	uxth	r2, r3
 801b656:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 801b658:	4413      	add	r3, r2
 801b65a:	b29a      	uxth	r2, r3
 801b65c:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 801b660:	b29b      	uxth	r3, r3
 801b662:	4413      	add	r3, r2
 801b664:	b29b      	uxth	r3, r3
 801b666:	b21b      	sxth	r3, r3
 801b668:	823b      	strh	r3, [r7, #16]
    bottom_area.y1 = coords->y2 + 1 - aa;
 801b66a:	68fb      	ldr	r3, [r7, #12]
 801b66c:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801b670:	b29a      	uxth	r2, r3
 801b672:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 801b676:	b29b      	uxth	r3, r3
 801b678:	1ad3      	subs	r3, r2, r3
 801b67a:	b29b      	uxth	r3, r3
 801b67c:	3301      	adds	r3, #1
 801b67e:	b29b      	uxth	r3, r3
 801b680:	b21b      	sxth	r3, r3
 801b682:	827b      	strh	r3, [r7, #18]
    bottom_area.x2 = coords->x2 - radius - aa;
 801b684:	68fb      	ldr	r3, [r7, #12]
 801b686:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801b68a:	b29a      	uxth	r2, r3
 801b68c:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 801b68e:	1ad3      	subs	r3, r2, r3
 801b690:	b29a      	uxth	r2, r3
 801b692:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 801b696:	b29b      	uxth	r3, r3
 801b698:	1ad3      	subs	r3, r2, r3
 801b69a:	b29b      	uxth	r3, r3
 801b69c:	b21b      	sxth	r3, r3
 801b69e:	82bb      	strh	r3, [r7, #20]
    bottom_area.y2 = bottom_area.y1;
 801b6a0:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801b6a4:	82fb      	strh	r3, [r7, #22]

    lv_opa_t opa_act;
    int16_t d;
    for(d = 1 /*+ LV_ANTIALIAS*/; d <= swidth /* - LV_ANTIALIAS*/; d++) {
 801b6a6:	2301      	movs	r3, #1
 801b6a8:	87fb      	strh	r3, [r7, #62]	; 0x3e
 801b6aa:	e068      	b.n	801b77e <lv_draw_shadow_full_straight+0x29a>
        opa_act = map[d];
 801b6ac:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 801b6b0:	683a      	ldr	r2, [r7, #0]
 801b6b2:	4413      	add	r3, r2
 801b6b4:	781b      	ldrb	r3, [r3, #0]
 801b6b6:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33

        lv_draw_fill(&right_area, mask, style->body.shadow.color, opa_act);
 801b6ba:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 801b6be:	687a      	ldr	r2, [r7, #4]
 801b6c0:	f107 0028 	add.w	r0, r7, #40	; 0x28
 801b6c4:	8a12      	ldrh	r2, [r2, #16]
 801b6c6:	68b9      	ldr	r1, [r7, #8]
 801b6c8:	f7fa fbc6 	bl	8015e58 <lv_draw_fill>
        right_area.x1++;
 801b6cc:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 801b6d0:	b29b      	uxth	r3, r3
 801b6d2:	3301      	adds	r3, #1
 801b6d4:	b29b      	uxth	r3, r3
 801b6d6:	b21b      	sxth	r3, r3
 801b6d8:	853b      	strh	r3, [r7, #40]	; 0x28
        right_area.x2++;
 801b6da:	f9b7 302c 	ldrsh.w	r3, [r7, #44]	; 0x2c
 801b6de:	b29b      	uxth	r3, r3
 801b6e0:	3301      	adds	r3, #1
 801b6e2:	b29b      	uxth	r3, r3
 801b6e4:	b21b      	sxth	r3, r3
 801b6e6:	85bb      	strh	r3, [r7, #44]	; 0x2c

        lv_draw_fill(&left_area, mask, style->body.shadow.color, opa_act);
 801b6e8:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 801b6ec:	687a      	ldr	r2, [r7, #4]
 801b6ee:	f107 0020 	add.w	r0, r7, #32
 801b6f2:	8a12      	ldrh	r2, [r2, #16]
 801b6f4:	68b9      	ldr	r1, [r7, #8]
 801b6f6:	f7fa fbaf 	bl	8015e58 <lv_draw_fill>
        left_area.x1--;
 801b6fa:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 801b6fe:	b29b      	uxth	r3, r3
 801b700:	3b01      	subs	r3, #1
 801b702:	b29b      	uxth	r3, r3
 801b704:	b21b      	sxth	r3, r3
 801b706:	843b      	strh	r3, [r7, #32]
        left_area.x2--;
 801b708:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 801b70c:	b29b      	uxth	r3, r3
 801b70e:	3b01      	subs	r3, #1
 801b710:	b29b      	uxth	r3, r3
 801b712:	b21b      	sxth	r3, r3
 801b714:	84bb      	strh	r3, [r7, #36]	; 0x24

        lv_draw_fill(&top_area, mask, style->body.shadow.color, opa_act);
 801b716:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 801b71a:	687a      	ldr	r2, [r7, #4]
 801b71c:	f107 0018 	add.w	r0, r7, #24
 801b720:	8a12      	ldrh	r2, [r2, #16]
 801b722:	68b9      	ldr	r1, [r7, #8]
 801b724:	f7fa fb98 	bl	8015e58 <lv_draw_fill>
        top_area.y1--;
 801b728:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 801b72c:	b29b      	uxth	r3, r3
 801b72e:	3b01      	subs	r3, #1
 801b730:	b29b      	uxth	r3, r3
 801b732:	b21b      	sxth	r3, r3
 801b734:	837b      	strh	r3, [r7, #26]
        top_area.y2--;
 801b736:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 801b73a:	b29b      	uxth	r3, r3
 801b73c:	3b01      	subs	r3, #1
 801b73e:	b29b      	uxth	r3, r3
 801b740:	b21b      	sxth	r3, r3
 801b742:	83fb      	strh	r3, [r7, #30]

        lv_draw_fill(&bottom_area, mask, style->body.shadow.color, opa_act);
 801b744:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 801b748:	687a      	ldr	r2, [r7, #4]
 801b74a:	f107 0010 	add.w	r0, r7, #16
 801b74e:	8a12      	ldrh	r2, [r2, #16]
 801b750:	68b9      	ldr	r1, [r7, #8]
 801b752:	f7fa fb81 	bl	8015e58 <lv_draw_fill>
        bottom_area.y1++;
 801b756:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801b75a:	b29b      	uxth	r3, r3
 801b75c:	3301      	adds	r3, #1
 801b75e:	b29b      	uxth	r3, r3
 801b760:	b21b      	sxth	r3, r3
 801b762:	827b      	strh	r3, [r7, #18]
        bottom_area.y2++;
 801b764:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 801b768:	b29b      	uxth	r3, r3
 801b76a:	3301      	adds	r3, #1
 801b76c:	b29b      	uxth	r3, r3
 801b76e:	b21b      	sxth	r3, r3
 801b770:	82fb      	strh	r3, [r7, #22]
    for(d = 1 /*+ LV_ANTIALIAS*/; d <= swidth /* - LV_ANTIALIAS*/; d++) {
 801b772:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 801b776:	b29b      	uxth	r3, r3
 801b778:	3301      	adds	r3, #1
 801b77a:	b29b      	uxth	r3, r3
 801b77c:	87fb      	strh	r3, [r7, #62]	; 0x3e
 801b77e:	f9b7 203e 	ldrsh.w	r2, [r7, #62]	; 0x3e
 801b782:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 801b786:	429a      	cmp	r2, r3
 801b788:	dd90      	ble.n	801b6ac <lv_draw_shadow_full_straight+0x1c8>
    }
}
 801b78a:	bf00      	nop
 801b78c:	bf00      	nop
 801b78e:	3740      	adds	r7, #64	; 0x40
 801b790:	46bd      	mov	sp, r7
 801b792:	bd80      	pop	{r7, pc}

0801b794 <lv_draw_cont_radius_corr>:

#endif

static uint16_t lv_draw_cont_radius_corr(uint16_t r, lv_coord_t w, lv_coord_t h)
{
 801b794:	b580      	push	{r7, lr}
 801b796:	b084      	sub	sp, #16
 801b798:	af00      	add	r7, sp, #0
 801b79a:	4603      	mov	r3, r0
 801b79c:	80fb      	strh	r3, [r7, #6]
 801b79e:	460b      	mov	r3, r1
 801b7a0:	80bb      	strh	r3, [r7, #4]
 801b7a2:	4613      	mov	r3, r2
 801b7a4:	807b      	strh	r3, [r7, #2]
    bool aa = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
 801b7a6:	f7f8 fe75 	bl	8014494 <lv_refr_get_disp_refreshing>
 801b7aa:	4603      	mov	r3, r0
 801b7ac:	4618      	mov	r0, r3
 801b7ae:	f001 fcf4 	bl	801d19a <lv_disp_get_antialiasing>
 801b7b2:	4603      	mov	r3, r0
 801b7b4:	73fb      	strb	r3, [r7, #15]

    if(r >= (w >> 1)) {
 801b7b6:	88fb      	ldrh	r3, [r7, #6]
 801b7b8:	f9b7 2004 	ldrsh.w	r2, [r7, #4]
 801b7bc:	1052      	asrs	r2, r2, #1
 801b7be:	b212      	sxth	r2, r2
 801b7c0:	4293      	cmp	r3, r2
 801b7c2:	db0a      	blt.n	801b7da <lv_draw_cont_radius_corr+0x46>
        r = (w >> 1);
 801b7c4:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 801b7c8:	105b      	asrs	r3, r3, #1
 801b7ca:	b21b      	sxth	r3, r3
 801b7cc:	80fb      	strh	r3, [r7, #6]
        if(r != 0) r--;
 801b7ce:	88fb      	ldrh	r3, [r7, #6]
 801b7d0:	2b00      	cmp	r3, #0
 801b7d2:	d002      	beq.n	801b7da <lv_draw_cont_radius_corr+0x46>
 801b7d4:	88fb      	ldrh	r3, [r7, #6]
 801b7d6:	3b01      	subs	r3, #1
 801b7d8:	80fb      	strh	r3, [r7, #6]
    }
    if(r >= (h >> 1)) {
 801b7da:	88fb      	ldrh	r3, [r7, #6]
 801b7dc:	f9b7 2002 	ldrsh.w	r2, [r7, #2]
 801b7e0:	1052      	asrs	r2, r2, #1
 801b7e2:	b212      	sxth	r2, r2
 801b7e4:	4293      	cmp	r3, r2
 801b7e6:	db0a      	blt.n	801b7fe <lv_draw_cont_radius_corr+0x6a>
        r = (h >> 1);
 801b7e8:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 801b7ec:	105b      	asrs	r3, r3, #1
 801b7ee:	b21b      	sxth	r3, r3
 801b7f0:	80fb      	strh	r3, [r7, #6]
        if(r != 0) r--;
 801b7f2:	88fb      	ldrh	r3, [r7, #6]
 801b7f4:	2b00      	cmp	r3, #0
 801b7f6:	d002      	beq.n	801b7fe <lv_draw_cont_radius_corr+0x6a>
 801b7f8:	88fb      	ldrh	r3, [r7, #6]
 801b7fa:	3b01      	subs	r3, #1
 801b7fc:	80fb      	strh	r3, [r7, #6]
    }

    if(r > 0) r -= aa;
 801b7fe:	88fb      	ldrh	r3, [r7, #6]
 801b800:	2b00      	cmp	r3, #0
 801b802:	d004      	beq.n	801b80e <lv_draw_cont_radius_corr+0x7a>
 801b804:	7bfb      	ldrb	r3, [r7, #15]
 801b806:	b29b      	uxth	r3, r3
 801b808:	88fa      	ldrh	r2, [r7, #6]
 801b80a:	1ad3      	subs	r3, r2, r3
 801b80c:	80fb      	strh	r3, [r7, #6]

    return r;
 801b80e:	88fb      	ldrh	r3, [r7, #6]
}
 801b810:	4618      	mov	r0, r3
 801b812:	3710      	adds	r7, #16
 801b814:	46bd      	mov	sp, r7
 801b816:	bd80      	pop	{r7, pc}

0801b818 <antialias_get_opa_circ>:
 * @param px_id index of pixel on the line segment
 * @param line_opa opacity of the lien (it will be the max opacity)
 * @return the desired opacity of the pixel
 */
static lv_opa_t antialias_get_opa_circ(lv_coord_t seg, lv_coord_t px_id, lv_opa_t opa)
{
 801b818:	b480      	push	{r7}
 801b81a:	b085      	sub	sp, #20
 801b81c:	af00      	add	r7, sp, #0
 801b81e:	4603      	mov	r3, r0
 801b820:	80fb      	strh	r3, [r7, #6]
 801b822:	460b      	mov	r3, r1
 801b824:	80bb      	strh	r3, [r7, #4]
 801b826:	4613      	mov	r3, r2
 801b828:	70fb      	strb	r3, [r7, #3]
#if CIRCLE_AA_NON_LINEAR_OPA_THRESHOLD < 1
    if(seg == 1) return 170;
#endif

#if CIRCLE_AA_NON_LINEAR_OPA_THRESHOLD < 2
    if(seg == 2) return (opa_map2[px_id] * opa) >> 8;
 801b82a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801b82e:	2b02      	cmp	r3, #2
 801b830:	d10a      	bne.n	801b848 <antialias_get_opa_circ+0x30>
 801b832:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 801b836:	4a20      	ldr	r2, [pc, #128]	; (801b8b8 <antialias_get_opa_circ+0xa0>)
 801b838:	5cd3      	ldrb	r3, [r2, r3]
 801b83a:	461a      	mov	r2, r3
 801b83c:	78fb      	ldrb	r3, [r7, #3]
 801b83e:	fb03 f302 	mul.w	r3, r3, r2
 801b842:	121b      	asrs	r3, r3, #8
 801b844:	b2db      	uxtb	r3, r3
 801b846:	e031      	b.n	801b8ac <antialias_get_opa_circ+0x94>
#endif

#if CIRCLE_AA_NON_LINEAR_OPA_THRESHOLD < 3
    if(seg == 3) return (opa_map3[px_id] * opa) >> 8;
 801b848:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801b84c:	2b03      	cmp	r3, #3
 801b84e:	d10a      	bne.n	801b866 <antialias_get_opa_circ+0x4e>
 801b850:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 801b854:	4a19      	ldr	r2, [pc, #100]	; (801b8bc <antialias_get_opa_circ+0xa4>)
 801b856:	5cd3      	ldrb	r3, [r2, r3]
 801b858:	461a      	mov	r2, r3
 801b85a:	78fb      	ldrb	r3, [r7, #3]
 801b85c:	fb03 f302 	mul.w	r3, r3, r2
 801b860:	121b      	asrs	r3, r3, #8
 801b862:	b2db      	uxtb	r3, r3
 801b864:	e022      	b.n	801b8ac <antialias_get_opa_circ+0x94>
#endif

#if CIRCLE_AA_NON_LINEAR_OPA_THRESHOLD < 4
    if(seg == 4) return (opa_map4[px_id] * opa) >> 8;
 801b866:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801b86a:	2b04      	cmp	r3, #4
 801b86c:	d10a      	bne.n	801b884 <antialias_get_opa_circ+0x6c>
 801b86e:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 801b872:	4a13      	ldr	r2, [pc, #76]	; (801b8c0 <antialias_get_opa_circ+0xa8>)
 801b874:	5cd3      	ldrb	r3, [r2, r3]
 801b876:	461a      	mov	r2, r3
 801b878:	78fb      	ldrb	r3, [r7, #3]
 801b87a:	fb03 f302 	mul.w	r3, r3, r2
 801b87e:	121b      	asrs	r3, r3, #8
 801b880:	b2db      	uxtb	r3, r3
 801b882:	e013      	b.n	801b8ac <antialias_get_opa_circ+0x94>
#endif

    uint8_t id = (uint32_t)((uint32_t)px_id * (sizeof(opa_map8) - 1)) / (seg - 1);
 801b884:	f9b7 2004 	ldrsh.w	r2, [r7, #4]
 801b888:	4613      	mov	r3, r2
 801b88a:	00db      	lsls	r3, r3, #3
 801b88c:	1a9b      	subs	r3, r3, r2
 801b88e:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 801b892:	3a01      	subs	r2, #1
 801b894:	fbb3 f3f2 	udiv	r3, r3, r2
 801b898:	73fb      	strb	r3, [r7, #15]
    return (uint32_t)((uint32_t)opa_map8[id] * opa) >> 8;
 801b89a:	7bfb      	ldrb	r3, [r7, #15]
 801b89c:	4a09      	ldr	r2, [pc, #36]	; (801b8c4 <antialias_get_opa_circ+0xac>)
 801b89e:	5cd3      	ldrb	r3, [r2, r3]
 801b8a0:	461a      	mov	r2, r3
 801b8a2:	78fb      	ldrb	r3, [r7, #3]
 801b8a4:	fb03 f302 	mul.w	r3, r3, r2
 801b8a8:	0a1b      	lsrs	r3, r3, #8
 801b8aa:	b2db      	uxtb	r3, r3
}
 801b8ac:	4618      	mov	r0, r3
 801b8ae:	3714      	adds	r7, #20
 801b8b0:	46bd      	mov	sp, r7
 801b8b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b8b6:	4770      	bx	lr
 801b8b8:	080d9cdc 	.word	0x080d9cdc
 801b8bc:	080d9ce0 	.word	0x080d9ce0
 801b8c0:	080d9ce4 	.word	0x080d9ce4
 801b8c4:	080d9ce8 	.word	0x080d9ce8

0801b8c8 <lv_img_cache_open>:
 * @param src source of the image. Path to file or pointer to an `lv_img_dsc_t` variable
 * @param style style of the image
 * @return pointer to the cache entry or NULL if can open the image
 */
lv_img_cache_entry_t * lv_img_cache_open(const void * src, const lv_style_t * style)
{
 801b8c8:	b580      	push	{r7, lr}
 801b8ca:	b08a      	sub	sp, #40	; 0x28
 801b8cc:	af00      	add	r7, sp, #0
 801b8ce:	6078      	str	r0, [r7, #4]
 801b8d0:	6039      	str	r1, [r7, #0]
    if(entry_cnt == 0) {
 801b8d2:	4b82      	ldr	r3, [pc, #520]	; (801badc <lv_img_cache_open+0x214>)
 801b8d4:	881b      	ldrh	r3, [r3, #0]
 801b8d6:	2b00      	cmp	r3, #0
 801b8d8:	d101      	bne.n	801b8de <lv_img_cache_open+0x16>
        LV_LOG_WARN("lv_img_cache_open: the cache size is 0");
        return NULL;
 801b8da:	2300      	movs	r3, #0
 801b8dc:	e0fa      	b.n	801bad4 <lv_img_cache_open+0x20c>
    }

    lv_img_cache_entry_t * cache = LV_GC_ROOT(_lv_img_cache_array);
 801b8de:	4b80      	ldr	r3, [pc, #512]	; (801bae0 <lv_img_cache_open+0x218>)
 801b8e0:	681b      	ldr	r3, [r3, #0]
 801b8e2:	61bb      	str	r3, [r7, #24]

    /*Decrement all lifes. Make the entries older*/
    uint16_t i;
    for(i = 0; i < entry_cnt; i++) {
 801b8e4:	2300      	movs	r3, #0
 801b8e6:	84fb      	strh	r3, [r7, #38]	; 0x26
 801b8e8:	e021      	b.n	801b92e <lv_img_cache_open+0x66>
        if(cache[i].life > INT32_MIN + LV_IMG_CACHE_AGING) {
 801b8ea:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801b8ec:	4613      	mov	r3, r2
 801b8ee:	009b      	lsls	r3, r3, #2
 801b8f0:	4413      	add	r3, r2
 801b8f2:	00db      	lsls	r3, r3, #3
 801b8f4:	461a      	mov	r2, r3
 801b8f6:	69bb      	ldr	r3, [r7, #24]
 801b8f8:	4413      	add	r3, r2
 801b8fa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801b8fc:	4a79      	ldr	r2, [pc, #484]	; (801bae4 <lv_img_cache_open+0x21c>)
 801b8fe:	4293      	cmp	r3, r2
 801b900:	db12      	blt.n	801b928 <lv_img_cache_open+0x60>
            cache[i].life -= LV_IMG_CACHE_AGING;
 801b902:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801b904:	4613      	mov	r3, r2
 801b906:	009b      	lsls	r3, r3, #2
 801b908:	4413      	add	r3, r2
 801b90a:	00db      	lsls	r3, r3, #3
 801b90c:	461a      	mov	r2, r3
 801b90e:	69bb      	ldr	r3, [r7, #24]
 801b910:	4413      	add	r3, r2
 801b912:	6a59      	ldr	r1, [r3, #36]	; 0x24
 801b914:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801b916:	4613      	mov	r3, r2
 801b918:	009b      	lsls	r3, r3, #2
 801b91a:	4413      	add	r3, r2
 801b91c:	00db      	lsls	r3, r3, #3
 801b91e:	461a      	mov	r2, r3
 801b920:	69bb      	ldr	r3, [r7, #24]
 801b922:	4413      	add	r3, r2
 801b924:	1e4a      	subs	r2, r1, #1
 801b926:	625a      	str	r2, [r3, #36]	; 0x24
    for(i = 0; i < entry_cnt; i++) {
 801b928:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801b92a:	3301      	adds	r3, #1
 801b92c:	84fb      	strh	r3, [r7, #38]	; 0x26
 801b92e:	4b6b      	ldr	r3, [pc, #428]	; (801badc <lv_img_cache_open+0x214>)
 801b930:	881b      	ldrh	r3, [r3, #0]
 801b932:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801b934:	429a      	cmp	r2, r3
 801b936:	d3d8      	bcc.n	801b8ea <lv_img_cache_open+0x22>
        }
    }

    /*Is the image cached?*/
    lv_img_cache_entry_t * cached_src = NULL;
 801b938:	2300      	movs	r3, #0
 801b93a:	623b      	str	r3, [r7, #32]
    for(i = 0; i < entry_cnt; i++) {
 801b93c:	2300      	movs	r3, #0
 801b93e:	84fb      	strh	r3, [r7, #38]	; 0x26
 801b940:	e058      	b.n	801b9f4 <lv_img_cache_open+0x12c>
        bool match = false;
 801b942:	2300      	movs	r3, #0
 801b944:	77fb      	strb	r3, [r7, #31]
        lv_img_src_t src_type = lv_img_src_get_type(cache[i].dec_dsc.src);
 801b946:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801b948:	4613      	mov	r3, r2
 801b94a:	009b      	lsls	r3, r3, #2
 801b94c:	4413      	add	r3, r2
 801b94e:	00db      	lsls	r3, r3, #3
 801b950:	461a      	mov	r2, r3
 801b952:	69bb      	ldr	r3, [r7, #24]
 801b954:	4413      	add	r3, r2
 801b956:	685b      	ldr	r3, [r3, #4]
 801b958:	4618      	mov	r0, r3
 801b95a:	f7fb fa6a 	bl	8016e32 <lv_img_src_get_type>
 801b95e:	4603      	mov	r3, r0
 801b960:	75fb      	strb	r3, [r7, #23]
        if(src_type == LV_IMG_SRC_VARIABLE) {
 801b962:	7dfb      	ldrb	r3, [r7, #23]
 801b964:	2b00      	cmp	r3, #0
 801b966:	d10e      	bne.n	801b986 <lv_img_cache_open+0xbe>
            if(cache[i].dec_dsc.src == src) match = true;
 801b968:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801b96a:	4613      	mov	r3, r2
 801b96c:	009b      	lsls	r3, r3, #2
 801b96e:	4413      	add	r3, r2
 801b970:	00db      	lsls	r3, r3, #3
 801b972:	461a      	mov	r2, r3
 801b974:	69bb      	ldr	r3, [r7, #24]
 801b976:	4413      	add	r3, r2
 801b978:	685b      	ldr	r3, [r3, #4]
 801b97a:	687a      	ldr	r2, [r7, #4]
 801b97c:	429a      	cmp	r2, r3
 801b97e:	d117      	bne.n	801b9b0 <lv_img_cache_open+0xe8>
 801b980:	2301      	movs	r3, #1
 801b982:	77fb      	strb	r3, [r7, #31]
 801b984:	e014      	b.n	801b9b0 <lv_img_cache_open+0xe8>
        } else if(src_type == LV_IMG_SRC_FILE) {
 801b986:	7dfb      	ldrb	r3, [r7, #23]
 801b988:	2b01      	cmp	r3, #1
 801b98a:	d111      	bne.n	801b9b0 <lv_img_cache_open+0xe8>
            if(strcmp(cache[i].dec_dsc.src, src) == 0) match = true;
 801b98c:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801b98e:	4613      	mov	r3, r2
 801b990:	009b      	lsls	r3, r3, #2
 801b992:	4413      	add	r3, r2
 801b994:	00db      	lsls	r3, r3, #3
 801b996:	461a      	mov	r2, r3
 801b998:	69bb      	ldr	r3, [r7, #24]
 801b99a:	4413      	add	r3, r2
 801b99c:	685b      	ldr	r3, [r3, #4]
 801b99e:	6879      	ldr	r1, [r7, #4]
 801b9a0:	4618      	mov	r0, r3
 801b9a2:	f7e4 fc9d 	bl	80002e0 <strcmp>
 801b9a6:	4603      	mov	r3, r0
 801b9a8:	2b00      	cmp	r3, #0
 801b9aa:	d101      	bne.n	801b9b0 <lv_img_cache_open+0xe8>
 801b9ac:	2301      	movs	r3, #1
 801b9ae:	77fb      	strb	r3, [r7, #31]
        }

        if(match) {
 801b9b0:	7ffb      	ldrb	r3, [r7, #31]
 801b9b2:	2b00      	cmp	r3, #0
 801b9b4:	d01b      	beq.n	801b9ee <lv_img_cache_open+0x126>
            /* If opened increment its life.
             * Image difficult to open should live longer to keep avoid frequent their recaching.
             * Therefore increase `life` with `time_to_open`*/
            cached_src = &cache[i];
 801b9b6:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801b9b8:	4613      	mov	r3, r2
 801b9ba:	009b      	lsls	r3, r3, #2
 801b9bc:	4413      	add	r3, r2
 801b9be:	00db      	lsls	r3, r3, #3
 801b9c0:	461a      	mov	r2, r3
 801b9c2:	69bb      	ldr	r3, [r7, #24]
 801b9c4:	4413      	add	r3, r2
 801b9c6:	623b      	str	r3, [r7, #32]
            cached_src->life += cached_src->dec_dsc.time_to_open * LV_IMG_CACHE_LIFE_GAIN;
 801b9c8:	6a3b      	ldr	r3, [r7, #32]
 801b9ca:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801b9cc:	461a      	mov	r2, r3
 801b9ce:	6a3b      	ldr	r3, [r7, #32]
 801b9d0:	699b      	ldr	r3, [r3, #24]
 801b9d2:	4413      	add	r3, r2
 801b9d4:	461a      	mov	r2, r3
 801b9d6:	6a3b      	ldr	r3, [r7, #32]
 801b9d8:	625a      	str	r2, [r3, #36]	; 0x24
            if(cached_src->life > LV_IMG_CACHE_LIFE_LIMIT) cached_src->life = LV_IMG_CACHE_LIFE_LIMIT;
 801b9da:	6a3b      	ldr	r3, [r7, #32]
 801b9dc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801b9de:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 801b9e2:	dd0d      	ble.n	801ba00 <lv_img_cache_open+0x138>
 801b9e4:	6a3b      	ldr	r3, [r7, #32]
 801b9e6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 801b9ea:	625a      	str	r2, [r3, #36]	; 0x24
            LV_LOG_TRACE("image draw: image found in the cache");
            break;
 801b9ec:	e008      	b.n	801ba00 <lv_img_cache_open+0x138>
    for(i = 0; i < entry_cnt; i++) {
 801b9ee:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801b9f0:	3301      	adds	r3, #1
 801b9f2:	84fb      	strh	r3, [r7, #38]	; 0x26
 801b9f4:	4b39      	ldr	r3, [pc, #228]	; (801badc <lv_img_cache_open+0x214>)
 801b9f6:	881b      	ldrh	r3, [r3, #0]
 801b9f8:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801b9fa:	429a      	cmp	r2, r3
 801b9fc:	d3a1      	bcc.n	801b942 <lv_img_cache_open+0x7a>
 801b9fe:	e000      	b.n	801ba02 <lv_img_cache_open+0x13a>
            break;
 801ba00:	bf00      	nop
        }
    }

    /*The image is not cached then cache it now*/
    if(cached_src == NULL) {
 801ba02:	6a3b      	ldr	r3, [r7, #32]
 801ba04:	2b00      	cmp	r3, #0
 801ba06:	d164      	bne.n	801bad2 <lv_img_cache_open+0x20a>
        /*Find an entry to reuse. Select the entry with the least life*/
        cached_src = &cache[0];
 801ba08:	69bb      	ldr	r3, [r7, #24]
 801ba0a:	623b      	str	r3, [r7, #32]
        for(i = 1; i < entry_cnt; i++) {
 801ba0c:	2301      	movs	r3, #1
 801ba0e:	84fb      	strh	r3, [r7, #38]	; 0x26
 801ba10:	e018      	b.n	801ba44 <lv_img_cache_open+0x17c>
            if(cache[i].life < cached_src->life) {
 801ba12:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801ba14:	4613      	mov	r3, r2
 801ba16:	009b      	lsls	r3, r3, #2
 801ba18:	4413      	add	r3, r2
 801ba1a:	00db      	lsls	r3, r3, #3
 801ba1c:	461a      	mov	r2, r3
 801ba1e:	69bb      	ldr	r3, [r7, #24]
 801ba20:	4413      	add	r3, r2
 801ba22:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 801ba24:	6a3b      	ldr	r3, [r7, #32]
 801ba26:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801ba28:	429a      	cmp	r2, r3
 801ba2a:	da08      	bge.n	801ba3e <lv_img_cache_open+0x176>
                cached_src = &cache[i];
 801ba2c:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801ba2e:	4613      	mov	r3, r2
 801ba30:	009b      	lsls	r3, r3, #2
 801ba32:	4413      	add	r3, r2
 801ba34:	00db      	lsls	r3, r3, #3
 801ba36:	461a      	mov	r2, r3
 801ba38:	69bb      	ldr	r3, [r7, #24]
 801ba3a:	4413      	add	r3, r2
 801ba3c:	623b      	str	r3, [r7, #32]
        for(i = 1; i < entry_cnt; i++) {
 801ba3e:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801ba40:	3301      	adds	r3, #1
 801ba42:	84fb      	strh	r3, [r7, #38]	; 0x26
 801ba44:	4b25      	ldr	r3, [pc, #148]	; (801badc <lv_img_cache_open+0x214>)
 801ba46:	881b      	ldrh	r3, [r3, #0]
 801ba48:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801ba4a:	429a      	cmp	r2, r3
 801ba4c:	d3e1      	bcc.n	801ba12 <lv_img_cache_open+0x14a>
            }
        }

        /*Close the decoder to reuse if it was opened (has a valid source)*/
        if(cached_src->dec_dsc.src) {
 801ba4e:	6a3b      	ldr	r3, [r7, #32]
 801ba50:	685b      	ldr	r3, [r3, #4]
 801ba52:	2b00      	cmp	r3, #0
 801ba54:	d003      	beq.n	801ba5e <lv_img_cache_open+0x196>
            lv_img_decoder_close(&cached_src->dec_dsc);
 801ba56:	6a3b      	ldr	r3, [r7, #32]
 801ba58:	4618      	mov	r0, r3
 801ba5a:	f000 fa2f 	bl	801bebc <lv_img_decoder_close>
            LV_LOG_INFO("image draw: cache miss, cached to an empty entry");
        }

        /*Open the image and measure the time to open*/
        uint32_t t_start;
        t_start                          = lv_tick_get();
 801ba5e:	f001 fc3d 	bl	801d2dc <lv_tick_get>
 801ba62:	6138      	str	r0, [r7, #16]
        cached_src->dec_dsc.time_to_open = 0;
 801ba64:	6a3b      	ldr	r3, [r7, #32]
 801ba66:	2200      	movs	r2, #0
 801ba68:	619a      	str	r2, [r3, #24]
        lv_res_t open_res                = lv_img_decoder_open(&cached_src->dec_dsc, src, style);
 801ba6a:	6a3b      	ldr	r3, [r7, #32]
 801ba6c:	683a      	ldr	r2, [r7, #0]
 801ba6e:	6879      	ldr	r1, [r7, #4]
 801ba70:	4618      	mov	r0, r3
 801ba72:	f000 f97d 	bl	801bd70 <lv_img_decoder_open>
 801ba76:	4603      	mov	r3, r0
 801ba78:	73fb      	strb	r3, [r7, #15]
        if(open_res == LV_RES_INV) {
 801ba7a:	7bfb      	ldrb	r3, [r7, #15]
 801ba7c:	2b00      	cmp	r3, #0
 801ba7e:	d114      	bne.n	801baaa <lv_img_cache_open+0x1e2>
            LV_LOG_WARN("Image draw cannot open the image resource");
            lv_img_decoder_close(&cached_src->dec_dsc);
 801ba80:	6a3b      	ldr	r3, [r7, #32]
 801ba82:	4618      	mov	r0, r3
 801ba84:	f000 fa1a 	bl	801bebc <lv_img_decoder_close>
            memset(&cached_src->dec_dsc, 0, sizeof(lv_img_decoder_dsc_t));
 801ba88:	6a3b      	ldr	r3, [r7, #32]
 801ba8a:	2224      	movs	r2, #36	; 0x24
 801ba8c:	2100      	movs	r1, #0
 801ba8e:	4618      	mov	r0, r3
 801ba90:	f006 f8f0 	bl	8021c74 <memset>
            memset(cached_src, 0, sizeof(lv_img_cache_entry_t));
 801ba94:	2228      	movs	r2, #40	; 0x28
 801ba96:	2100      	movs	r1, #0
 801ba98:	6a38      	ldr	r0, [r7, #32]
 801ba9a:	f006 f8eb 	bl	8021c74 <memset>
            cached_src->life = INT32_MIN; /*Make the empty entry very "weak" to force its use  */
 801ba9e:	6a3b      	ldr	r3, [r7, #32]
 801baa0:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 801baa4:	625a      	str	r2, [r3, #36]	; 0x24
            return NULL;
 801baa6:	2300      	movs	r3, #0
 801baa8:	e014      	b.n	801bad4 <lv_img_cache_open+0x20c>
        }

        cached_src->life = 0;
 801baaa:	6a3b      	ldr	r3, [r7, #32]
 801baac:	2200      	movs	r2, #0
 801baae:	625a      	str	r2, [r3, #36]	; 0x24

        /*If `time_to_open` was not set in the open function set it here*/
        if(cached_src->dec_dsc.time_to_open == 0) {
 801bab0:	6a3b      	ldr	r3, [r7, #32]
 801bab2:	699b      	ldr	r3, [r3, #24]
 801bab4:	2b00      	cmp	r3, #0
 801bab6:	d105      	bne.n	801bac4 <lv_img_cache_open+0x1fc>
            cached_src->dec_dsc.time_to_open = lv_tick_elaps(t_start);
 801bab8:	6938      	ldr	r0, [r7, #16]
 801baba:	f001 fc29 	bl	801d310 <lv_tick_elaps>
 801babe:	4602      	mov	r2, r0
 801bac0:	6a3b      	ldr	r3, [r7, #32]
 801bac2:	619a      	str	r2, [r3, #24]
        }

        if(cached_src->dec_dsc.time_to_open == 0) cached_src->dec_dsc.time_to_open = 1;
 801bac4:	6a3b      	ldr	r3, [r7, #32]
 801bac6:	699b      	ldr	r3, [r3, #24]
 801bac8:	2b00      	cmp	r3, #0
 801baca:	d102      	bne.n	801bad2 <lv_img_cache_open+0x20a>
 801bacc:	6a3b      	ldr	r3, [r7, #32]
 801bace:	2201      	movs	r2, #1
 801bad0:	619a      	str	r2, [r3, #24]
    }

    return cached_src;
 801bad2:	6a3b      	ldr	r3, [r7, #32]
}
 801bad4:	4618      	mov	r0, r3
 801bad6:	3728      	adds	r7, #40	; 0x28
 801bad8:	46bd      	mov	sp, r7
 801bada:	bd80      	pop	{r7, pc}
 801badc:	240623d0 	.word	0x240623d0
 801bae0:	24063668 	.word	0x24063668
 801bae4:	80000002 	.word	0x80000002

0801bae8 <lv_img_cache_set_size>:
 * More cached images mean more opened image at same time which might mean more memory usage.
 * E.g. if 20 PNG or JPG images are open in the RAM they consume memory while opened in the cache.
 * @param new_entry_cnt number of image to cache
 */
void lv_img_cache_set_size(uint16_t new_entry_cnt)
{
 801bae8:	b580      	push	{r7, lr}
 801baea:	b084      	sub	sp, #16
 801baec:	af00      	add	r7, sp, #0
 801baee:	4603      	mov	r3, r0
 801baf0:	80fb      	strh	r3, [r7, #6]
    if(LV_GC_ROOT(_lv_img_cache_array) != NULL) {
 801baf2:	4b27      	ldr	r3, [pc, #156]	; (801bb90 <lv_img_cache_set_size+0xa8>)
 801baf4:	681b      	ldr	r3, [r3, #0]
 801baf6:	2b00      	cmp	r3, #0
 801baf8:	d007      	beq.n	801bb0a <lv_img_cache_set_size+0x22>
        /*Clean the cache before free it*/
        lv_img_cache_invalidate_src(NULL);
 801bafa:	2000      	movs	r0, #0
 801bafc:	f000 f84c 	bl	801bb98 <lv_img_cache_invalidate_src>
        lv_mem_free(LV_GC_ROOT(_lv_img_cache_array));
 801bb00:	4b23      	ldr	r3, [pc, #140]	; (801bb90 <lv_img_cache_set_size+0xa8>)
 801bb02:	681b      	ldr	r3, [r3, #0]
 801bb04:	4618      	mov	r0, r3
 801bb06:	f002 fb13 	bl	801e130 <lv_mem_free>
    }

    /*Reallocate the cache*/
    LV_GC_ROOT(_lv_img_cache_array) = lv_mem_alloc(sizeof(lv_img_cache_entry_t) * new_entry_cnt);
 801bb0a:	88fa      	ldrh	r2, [r7, #6]
 801bb0c:	4613      	mov	r3, r2
 801bb0e:	009b      	lsls	r3, r3, #2
 801bb10:	4413      	add	r3, r2
 801bb12:	00db      	lsls	r3, r3, #3
 801bb14:	4618      	mov	r0, r3
 801bb16:	f002 facb 	bl	801e0b0 <lv_mem_alloc>
 801bb1a:	4603      	mov	r3, r0
 801bb1c:	4a1c      	ldr	r2, [pc, #112]	; (801bb90 <lv_img_cache_set_size+0xa8>)
 801bb1e:	6013      	str	r3, [r2, #0]
    lv_mem_assert(LV_GC_ROOT(_lv_img_cache_array));
 801bb20:	4b1b      	ldr	r3, [pc, #108]	; (801bb90 <lv_img_cache_set_size+0xa8>)
 801bb22:	681b      	ldr	r3, [r3, #0]
 801bb24:	2b00      	cmp	r3, #0
 801bb26:	d100      	bne.n	801bb2a <lv_img_cache_set_size+0x42>
 801bb28:	e7fe      	b.n	801bb28 <lv_img_cache_set_size+0x40>
    if(LV_GC_ROOT(_lv_img_cache_array) == NULL) {
 801bb2a:	4b19      	ldr	r3, [pc, #100]	; (801bb90 <lv_img_cache_set_size+0xa8>)
 801bb2c:	681b      	ldr	r3, [r3, #0]
 801bb2e:	2b00      	cmp	r3, #0
 801bb30:	d103      	bne.n	801bb3a <lv_img_cache_set_size+0x52>
        entry_cnt = 0;
 801bb32:	4b18      	ldr	r3, [pc, #96]	; (801bb94 <lv_img_cache_set_size+0xac>)
 801bb34:	2200      	movs	r2, #0
 801bb36:	801a      	strh	r2, [r3, #0]
        return;
 801bb38:	e027      	b.n	801bb8a <lv_img_cache_set_size+0xa2>
    }
    entry_cnt = new_entry_cnt;
 801bb3a:	4a16      	ldr	r2, [pc, #88]	; (801bb94 <lv_img_cache_set_size+0xac>)
 801bb3c:	88fb      	ldrh	r3, [r7, #6]
 801bb3e:	8013      	strh	r3, [r2, #0]

    /*Clean the cache*/
    uint16_t i;
    for(i = 0; i < entry_cnt; i++) {
 801bb40:	2300      	movs	r3, #0
 801bb42:	81fb      	strh	r3, [r7, #14]
 801bb44:	e01c      	b.n	801bb80 <lv_img_cache_set_size+0x98>
        memset(&LV_GC_ROOT(_lv_img_cache_array)[i].dec_dsc, 0, sizeof(lv_img_decoder_dsc_t));
 801bb46:	4b12      	ldr	r3, [pc, #72]	; (801bb90 <lv_img_cache_set_size+0xa8>)
 801bb48:	6819      	ldr	r1, [r3, #0]
 801bb4a:	89fa      	ldrh	r2, [r7, #14]
 801bb4c:	4613      	mov	r3, r2
 801bb4e:	009b      	lsls	r3, r3, #2
 801bb50:	4413      	add	r3, r2
 801bb52:	00db      	lsls	r3, r3, #3
 801bb54:	440b      	add	r3, r1
 801bb56:	2224      	movs	r2, #36	; 0x24
 801bb58:	2100      	movs	r1, #0
 801bb5a:	4618      	mov	r0, r3
 801bb5c:	f006 f88a 	bl	8021c74 <memset>
        memset(&LV_GC_ROOT(_lv_img_cache_array)[i], 0, sizeof(lv_img_cache_entry_t));
 801bb60:	4b0b      	ldr	r3, [pc, #44]	; (801bb90 <lv_img_cache_set_size+0xa8>)
 801bb62:	6819      	ldr	r1, [r3, #0]
 801bb64:	89fa      	ldrh	r2, [r7, #14]
 801bb66:	4613      	mov	r3, r2
 801bb68:	009b      	lsls	r3, r3, #2
 801bb6a:	4413      	add	r3, r2
 801bb6c:	00db      	lsls	r3, r3, #3
 801bb6e:	440b      	add	r3, r1
 801bb70:	2228      	movs	r2, #40	; 0x28
 801bb72:	2100      	movs	r1, #0
 801bb74:	4618      	mov	r0, r3
 801bb76:	f006 f87d 	bl	8021c74 <memset>
    for(i = 0; i < entry_cnt; i++) {
 801bb7a:	89fb      	ldrh	r3, [r7, #14]
 801bb7c:	3301      	adds	r3, #1
 801bb7e:	81fb      	strh	r3, [r7, #14]
 801bb80:	4b04      	ldr	r3, [pc, #16]	; (801bb94 <lv_img_cache_set_size+0xac>)
 801bb82:	881b      	ldrh	r3, [r3, #0]
 801bb84:	89fa      	ldrh	r2, [r7, #14]
 801bb86:	429a      	cmp	r2, r3
 801bb88:	d3dd      	bcc.n	801bb46 <lv_img_cache_set_size+0x5e>
    }
}
 801bb8a:	3710      	adds	r7, #16
 801bb8c:	46bd      	mov	sp, r7
 801bb8e:	bd80      	pop	{r7, pc}
 801bb90:	24063668 	.word	0x24063668
 801bb94:	240623d0 	.word	0x240623d0

0801bb98 <lv_img_cache_invalidate_src>:
 * Invalidate an image source in the cache.
 * Useful if the image source is updated therefore it needs to be cached again.
 * @param src an image source path to a file or pointer to an `lv_img_dsc_t` variable.
 */
void lv_img_cache_invalidate_src(const void * src)
{
 801bb98:	b580      	push	{r7, lr}
 801bb9a:	b084      	sub	sp, #16
 801bb9c:	af00      	add	r7, sp, #0
 801bb9e:	6078      	str	r0, [r7, #4]

    lv_img_cache_entry_t * cache = LV_GC_ROOT(_lv_img_cache_array);
 801bba0:	4b28      	ldr	r3, [pc, #160]	; (801bc44 <lv_img_cache_invalidate_src+0xac>)
 801bba2:	681b      	ldr	r3, [r3, #0]
 801bba4:	60bb      	str	r3, [r7, #8]

    uint16_t i;
    for(i = 0; i < entry_cnt; i++) {
 801bba6:	2300      	movs	r3, #0
 801bba8:	81fb      	strh	r3, [r7, #14]
 801bbaa:	e041      	b.n	801bc30 <lv_img_cache_invalidate_src+0x98>
        if(cache[i].dec_dsc.src == src || src == NULL) {
 801bbac:	89fa      	ldrh	r2, [r7, #14]
 801bbae:	4613      	mov	r3, r2
 801bbb0:	009b      	lsls	r3, r3, #2
 801bbb2:	4413      	add	r3, r2
 801bbb4:	00db      	lsls	r3, r3, #3
 801bbb6:	461a      	mov	r2, r3
 801bbb8:	68bb      	ldr	r3, [r7, #8]
 801bbba:	4413      	add	r3, r2
 801bbbc:	685b      	ldr	r3, [r3, #4]
 801bbbe:	687a      	ldr	r2, [r7, #4]
 801bbc0:	429a      	cmp	r2, r3
 801bbc2:	d002      	beq.n	801bbca <lv_img_cache_invalidate_src+0x32>
 801bbc4:	687b      	ldr	r3, [r7, #4]
 801bbc6:	2b00      	cmp	r3, #0
 801bbc8:	d12f      	bne.n	801bc2a <lv_img_cache_invalidate_src+0x92>
            if(cache[i].dec_dsc.src != NULL) {
 801bbca:	89fa      	ldrh	r2, [r7, #14]
 801bbcc:	4613      	mov	r3, r2
 801bbce:	009b      	lsls	r3, r3, #2
 801bbd0:	4413      	add	r3, r2
 801bbd2:	00db      	lsls	r3, r3, #3
 801bbd4:	461a      	mov	r2, r3
 801bbd6:	68bb      	ldr	r3, [r7, #8]
 801bbd8:	4413      	add	r3, r2
 801bbda:	685b      	ldr	r3, [r3, #4]
 801bbdc:	2b00      	cmp	r3, #0
 801bbde:	d00a      	beq.n	801bbf6 <lv_img_cache_invalidate_src+0x5e>
                lv_img_decoder_close(&cache[i].dec_dsc);
 801bbe0:	89fa      	ldrh	r2, [r7, #14]
 801bbe2:	4613      	mov	r3, r2
 801bbe4:	009b      	lsls	r3, r3, #2
 801bbe6:	4413      	add	r3, r2
 801bbe8:	00db      	lsls	r3, r3, #3
 801bbea:	461a      	mov	r2, r3
 801bbec:	68bb      	ldr	r3, [r7, #8]
 801bbee:	4413      	add	r3, r2
 801bbf0:	4618      	mov	r0, r3
 801bbf2:	f000 f963 	bl	801bebc <lv_img_decoder_close>
            }

            memset(&cache[i].dec_dsc, 0, sizeof(lv_img_decoder_dsc_t));
 801bbf6:	89fa      	ldrh	r2, [r7, #14]
 801bbf8:	4613      	mov	r3, r2
 801bbfa:	009b      	lsls	r3, r3, #2
 801bbfc:	4413      	add	r3, r2
 801bbfe:	00db      	lsls	r3, r3, #3
 801bc00:	461a      	mov	r2, r3
 801bc02:	68bb      	ldr	r3, [r7, #8]
 801bc04:	4413      	add	r3, r2
 801bc06:	2224      	movs	r2, #36	; 0x24
 801bc08:	2100      	movs	r1, #0
 801bc0a:	4618      	mov	r0, r3
 801bc0c:	f006 f832 	bl	8021c74 <memset>
            memset(&cache[i], 0, sizeof(lv_img_cache_entry_t));
 801bc10:	89fa      	ldrh	r2, [r7, #14]
 801bc12:	4613      	mov	r3, r2
 801bc14:	009b      	lsls	r3, r3, #2
 801bc16:	4413      	add	r3, r2
 801bc18:	00db      	lsls	r3, r3, #3
 801bc1a:	461a      	mov	r2, r3
 801bc1c:	68bb      	ldr	r3, [r7, #8]
 801bc1e:	4413      	add	r3, r2
 801bc20:	2228      	movs	r2, #40	; 0x28
 801bc22:	2100      	movs	r1, #0
 801bc24:	4618      	mov	r0, r3
 801bc26:	f006 f825 	bl	8021c74 <memset>
    for(i = 0; i < entry_cnt; i++) {
 801bc2a:	89fb      	ldrh	r3, [r7, #14]
 801bc2c:	3301      	adds	r3, #1
 801bc2e:	81fb      	strh	r3, [r7, #14]
 801bc30:	4b05      	ldr	r3, [pc, #20]	; (801bc48 <lv_img_cache_invalidate_src+0xb0>)
 801bc32:	881b      	ldrh	r3, [r3, #0]
 801bc34:	89fa      	ldrh	r2, [r7, #14]
 801bc36:	429a      	cmp	r2, r3
 801bc38:	d3b8      	bcc.n	801bbac <lv_img_cache_invalidate_src+0x14>
        }
    }
}
 801bc3a:	bf00      	nop
 801bc3c:	bf00      	nop
 801bc3e:	3710      	adds	r7, #16
 801bc40:	46bd      	mov	sp, r7
 801bc42:	bd80      	pop	{r7, pc}
 801bc44:	24063668 	.word	0x24063668
 801bc48:	240623d0 	.word	0x240623d0

0801bc4c <lv_color_make>:
{
 801bc4c:	b480      	push	{r7}
 801bc4e:	b085      	sub	sp, #20
 801bc50:	af00      	add	r7, sp, #0
 801bc52:	4603      	mov	r3, r0
 801bc54:	71fb      	strb	r3, [r7, #7]
 801bc56:	460b      	mov	r3, r1
 801bc58:	71bb      	strb	r3, [r7, #6]
 801bc5a:	4613      	mov	r3, r2
 801bc5c:	717b      	strb	r3, [r7, #5]
    color.ch.blue  = (uint16_t)(b8 >> 3);
 801bc5e:	797b      	ldrb	r3, [r7, #5]
 801bc60:	08db      	lsrs	r3, r3, #3
 801bc62:	b2db      	uxtb	r3, r3
 801bc64:	f003 031f 	and.w	r3, r3, #31
 801bc68:	b2da      	uxtb	r2, r3
 801bc6a:	7b3b      	ldrb	r3, [r7, #12]
 801bc6c:	f362 0304 	bfi	r3, r2, #0, #5
 801bc70:	733b      	strb	r3, [r7, #12]
    color.ch.green = (uint16_t)(g8 >> 2);
 801bc72:	79bb      	ldrb	r3, [r7, #6]
 801bc74:	089b      	lsrs	r3, r3, #2
 801bc76:	b2db      	uxtb	r3, r3
 801bc78:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801bc7c:	b2da      	uxtb	r2, r3
 801bc7e:	89bb      	ldrh	r3, [r7, #12]
 801bc80:	f362 134a 	bfi	r3, r2, #5, #6
 801bc84:	81bb      	strh	r3, [r7, #12]
    color.ch.red   = (uint16_t)(r8 >> 3);
 801bc86:	79fb      	ldrb	r3, [r7, #7]
 801bc88:	08db      	lsrs	r3, r3, #3
 801bc8a:	b2db      	uxtb	r3, r3
 801bc8c:	f003 031f 	and.w	r3, r3, #31
 801bc90:	b2da      	uxtb	r2, r3
 801bc92:	7b7b      	ldrb	r3, [r7, #13]
 801bc94:	f362 03c7 	bfi	r3, r2, #3, #5
 801bc98:	737b      	strb	r3, [r7, #13]
    return color;
 801bc9a:	89bb      	ldrh	r3, [r7, #12]
}
 801bc9c:	4618      	mov	r0, r3
 801bc9e:	3714      	adds	r7, #20
 801bca0:	46bd      	mov	sp, r7
 801bca2:	f85d 7b04 	ldr.w	r7, [sp], #4
 801bca6:	4770      	bx	lr

0801bca8 <lv_img_decoder_init>:

/**
 * Initialize the image decoder module
 * */
void lv_img_decoder_init(void)
{
 801bca8:	b580      	push	{r7, lr}
 801bcaa:	b082      	sub	sp, #8
 801bcac:	af00      	add	r7, sp, #0
    lv_ll_init(&LV_GC_ROOT(_lv_img_defoder_ll), sizeof(lv_img_decoder_t));
 801bcae:	2110      	movs	r1, #16
 801bcb0:	4810      	ldr	r0, [pc, #64]	; (801bcf4 <lv_img_decoder_init+0x4c>)
 801bcb2:	f001 ff15 	bl	801dae0 <lv_ll_init>

    lv_img_decoder_t * decoder;

    /*Create a decoder for the built in color format*/
    decoder = lv_img_decoder_create();
 801bcb6:	f000 f927 	bl	801bf08 <lv_img_decoder_create>
 801bcba:	6078      	str	r0, [r7, #4]
    if(decoder == NULL) {
 801bcbc:	687b      	ldr	r3, [r7, #4]
 801bcbe:	2b00      	cmp	r3, #0
 801bcc0:	d103      	bne.n	801bcca <lv_img_decoder_init+0x22>
        LV_LOG_WARN("lv_img_decoder_init: out of memory");
        lv_mem_assert(decoder);
 801bcc2:	687b      	ldr	r3, [r7, #4]
 801bcc4:	2b00      	cmp	r3, #0
 801bcc6:	d111      	bne.n	801bcec <lv_img_decoder_init+0x44>
 801bcc8:	e7fe      	b.n	801bcc8 <lv_img_decoder_init+0x20>
        return;
    }

    lv_img_decoder_set_info_cb(decoder, lv_img_decoder_built_in_info);
 801bcca:	490b      	ldr	r1, [pc, #44]	; (801bcf8 <lv_img_decoder_init+0x50>)
 801bccc:	6878      	ldr	r0, [r7, #4]
 801bcce:	f000 f937 	bl	801bf40 <lv_img_decoder_set_info_cb>
    lv_img_decoder_set_open_cb(decoder, lv_img_decoder_built_in_open);
 801bcd2:	490a      	ldr	r1, [pc, #40]	; (801bcfc <lv_img_decoder_init+0x54>)
 801bcd4:	6878      	ldr	r0, [r7, #4]
 801bcd6:	f000 f941 	bl	801bf5c <lv_img_decoder_set_open_cb>
    lv_img_decoder_set_read_line_cb(decoder, lv_img_decoder_built_in_read_line);
 801bcda:	4909      	ldr	r1, [pc, #36]	; (801bd00 <lv_img_decoder_init+0x58>)
 801bcdc:	6878      	ldr	r0, [r7, #4]
 801bcde:	f000 f94b 	bl	801bf78 <lv_img_decoder_set_read_line_cb>
    lv_img_decoder_set_close_cb(decoder, lv_img_decoder_built_in_close);
 801bce2:	4908      	ldr	r1, [pc, #32]	; (801bd04 <lv_img_decoder_init+0x5c>)
 801bce4:	6878      	ldr	r0, [r7, #4]
 801bce6:	f000 f955 	bl	801bf94 <lv_img_decoder_set_close_cb>
 801bcea:	e000      	b.n	801bcee <lv_img_decoder_init+0x46>
        return;
 801bcec:	bf00      	nop
}
 801bcee:	3708      	adds	r7, #8
 801bcf0:	46bd      	mov	sp, r7
 801bcf2:	bd80      	pop	{r7, pc}
 801bcf4:	2406364c 	.word	0x2406364c
 801bcf8:	0801bfb1 	.word	0x0801bfb1
 801bcfc:	0801c061 	.word	0x0801c061
 801bd00:	0801c1c5 	.word	0x0801c1c5
 801bd04:	0801c2e9 	.word	0x0801c2e9

0801bd08 <lv_img_decoder_get_info>:
 * @param src the image source. E.g. file name or variable.
 * @param header the image info will be stored here
 * @return LV_RES_OK: success; LV_RES_INV: wasn't able to get info about the image
 */
lv_res_t lv_img_decoder_get_info(const char * src, lv_img_header_t * header)
{
 801bd08:	b580      	push	{r7, lr}
 801bd0a:	b084      	sub	sp, #16
 801bd0c:	af00      	add	r7, sp, #0
 801bd0e:	6078      	str	r0, [r7, #4]
 801bd10:	6039      	str	r1, [r7, #0]
    header->always_zero = 0;
 801bd12:	683a      	ldr	r2, [r7, #0]
 801bd14:	7813      	ldrb	r3, [r2, #0]
 801bd16:	f36f 1347 	bfc	r3, #5, #3
 801bd1a:	7013      	strb	r3, [r2, #0]

    lv_res_t res = LV_RES_INV;
 801bd1c:	2300      	movs	r3, #0
 801bd1e:	73fb      	strb	r3, [r7, #15]
    lv_img_decoder_t * d;
    LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d)
 801bd20:	4812      	ldr	r0, [pc, #72]	; (801bd6c <lv_img_decoder_get_info+0x64>)
 801bd22:	f002 f85f 	bl	801dde4 <lv_ll_get_head>
 801bd26:	60b8      	str	r0, [r7, #8]
 801bd28:	e015      	b.n	801bd56 <lv_img_decoder_get_info+0x4e>
    {
        res = LV_RES_INV;
 801bd2a:	2300      	movs	r3, #0
 801bd2c:	73fb      	strb	r3, [r7, #15]
        if(d->info_cb) {
 801bd2e:	68bb      	ldr	r3, [r7, #8]
 801bd30:	681b      	ldr	r3, [r3, #0]
 801bd32:	2b00      	cmp	r3, #0
 801bd34:	d00a      	beq.n	801bd4c <lv_img_decoder_get_info+0x44>
            res = d->info_cb(d, src, header);
 801bd36:	68bb      	ldr	r3, [r7, #8]
 801bd38:	681b      	ldr	r3, [r3, #0]
 801bd3a:	683a      	ldr	r2, [r7, #0]
 801bd3c:	6879      	ldr	r1, [r7, #4]
 801bd3e:	68b8      	ldr	r0, [r7, #8]
 801bd40:	4798      	blx	r3
 801bd42:	4603      	mov	r3, r0
 801bd44:	73fb      	strb	r3, [r7, #15]
            if(res == LV_RES_OK) break;
 801bd46:	7bfb      	ldrb	r3, [r7, #15]
 801bd48:	2b01      	cmp	r3, #1
 801bd4a:	d008      	beq.n	801bd5e <lv_img_decoder_get_info+0x56>
    LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d)
 801bd4c:	68b9      	ldr	r1, [r7, #8]
 801bd4e:	4807      	ldr	r0, [pc, #28]	; (801bd6c <lv_img_decoder_get_info+0x64>)
 801bd50:	f002 f86e 	bl	801de30 <lv_ll_get_next>
 801bd54:	60b8      	str	r0, [r7, #8]
 801bd56:	68bb      	ldr	r3, [r7, #8]
 801bd58:	2b00      	cmp	r3, #0
 801bd5a:	d1e6      	bne.n	801bd2a <lv_img_decoder_get_info+0x22>
 801bd5c:	e000      	b.n	801bd60 <lv_img_decoder_get_info+0x58>
            if(res == LV_RES_OK) break;
 801bd5e:	bf00      	nop
        }
    }

    return res;
 801bd60:	7bfb      	ldrb	r3, [r7, #15]
}
 801bd62:	4618      	mov	r0, r3
 801bd64:	3710      	adds	r7, #16
 801bd66:	46bd      	mov	sp, r7
 801bd68:	bd80      	pop	{r7, pc}
 801bd6a:	bf00      	nop
 801bd6c:	2406364c 	.word	0x2406364c

0801bd70 <lv_img_decoder_open>:
 * @param style the style of the image
 * @return LV_RES_OK: opened the image. `dsc->img_data` and `dsc->header` are set.
 *         LV_RES_INV: none of the registered image decoders were able to open the image.
 */
lv_res_t lv_img_decoder_open(lv_img_decoder_dsc_t * dsc, const void * src, const lv_style_t * style)
{
 801bd70:	b580      	push	{r7, lr}
 801bd72:	b088      	sub	sp, #32
 801bd74:	af00      	add	r7, sp, #0
 801bd76:	60f8      	str	r0, [r7, #12]
 801bd78:	60b9      	str	r1, [r7, #8]
 801bd7a:	607a      	str	r2, [r7, #4]
    dsc->style     = style;
 801bd7c:	68fb      	ldr	r3, [r7, #12]
 801bd7e:	687a      	ldr	r2, [r7, #4]
 801bd80:	609a      	str	r2, [r3, #8]
    dsc->src_type  = lv_img_src_get_type(src);
 801bd82:	68b8      	ldr	r0, [r7, #8]
 801bd84:	f7fb f855 	bl	8016e32 <lv_img_src_get_type>
 801bd88:	4603      	mov	r3, r0
 801bd8a:	461a      	mov	r2, r3
 801bd8c:	68fb      	ldr	r3, [r7, #12]
 801bd8e:	731a      	strb	r2, [r3, #12]
    dsc->user_data = NULL;
 801bd90:	68fb      	ldr	r3, [r7, #12]
 801bd92:	2200      	movs	r2, #0
 801bd94:	621a      	str	r2, [r3, #32]

    if(dsc->src_type == LV_IMG_SRC_FILE) {
 801bd96:	68fb      	ldr	r3, [r7, #12]
 801bd98:	7b1b      	ldrb	r3, [r3, #12]
 801bd9a:	2b01      	cmp	r3, #1
 801bd9c:	d113      	bne.n	801bdc6 <lv_img_decoder_open+0x56>
        uint16_t fnlen = strlen(src);
 801bd9e:	68b8      	ldr	r0, [r7, #8]
 801bda0:	f7e4 faa8 	bl	80002f4 <strlen>
 801bda4:	4603      	mov	r3, r0
 801bda6:	82fb      	strh	r3, [r7, #22]
        dsc->src = lv_mem_alloc(fnlen + 1);
 801bda8:	8afb      	ldrh	r3, [r7, #22]
 801bdaa:	3301      	adds	r3, #1
 801bdac:	4618      	mov	r0, r3
 801bdae:	f002 f97f 	bl	801e0b0 <lv_mem_alloc>
 801bdb2:	4602      	mov	r2, r0
 801bdb4:	68fb      	ldr	r3, [r7, #12]
 801bdb6:	605a      	str	r2, [r3, #4]
        strcpy((char *)dsc->src, src);
 801bdb8:	68fb      	ldr	r3, [r7, #12]
 801bdba:	685b      	ldr	r3, [r3, #4]
 801bdbc:	68b9      	ldr	r1, [r7, #8]
 801bdbe:	4618      	mov	r0, r3
 801bdc0:	f006 f854 	bl	8021e6c <strcpy>
 801bdc4:	e002      	b.n	801bdcc <lv_img_decoder_open+0x5c>
    } else {
        dsc->src       = src;
 801bdc6:	68fb      	ldr	r3, [r7, #12]
 801bdc8:	68ba      	ldr	r2, [r7, #8]
 801bdca:	605a      	str	r2, [r3, #4]
    }

    lv_res_t res = LV_RES_INV;
 801bdcc:	2300      	movs	r3, #0
 801bdce:	77fb      	strb	r3, [r7, #31]

    lv_img_decoder_t * d;
    LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d)
 801bdd0:	4823      	ldr	r0, [pc, #140]	; (801be60 <lv_img_decoder_open+0xf0>)
 801bdd2:	f002 f807 	bl	801dde4 <lv_ll_get_head>
 801bdd6:	61b8      	str	r0, [r7, #24]
 801bdd8:	e02f      	b.n	801be3a <lv_img_decoder_open+0xca>
    {
        /*Info an Open callbacks are required*/
        if(d->info_cb == NULL || d->open_cb == NULL) continue;
 801bdda:	69bb      	ldr	r3, [r7, #24]
 801bddc:	681b      	ldr	r3, [r3, #0]
 801bdde:	2b00      	cmp	r3, #0
 801bde0:	d023      	beq.n	801be2a <lv_img_decoder_open+0xba>
 801bde2:	69bb      	ldr	r3, [r7, #24]
 801bde4:	685b      	ldr	r3, [r3, #4]
 801bde6:	2b00      	cmp	r3, #0
 801bde8:	d01f      	beq.n	801be2a <lv_img_decoder_open+0xba>

        res = d->info_cb(d, src, &dsc->header);
 801bdea:	69bb      	ldr	r3, [r7, #24]
 801bdec:	681b      	ldr	r3, [r3, #0]
 801bdee:	68fa      	ldr	r2, [r7, #12]
 801bdf0:	3210      	adds	r2, #16
 801bdf2:	68b9      	ldr	r1, [r7, #8]
 801bdf4:	69b8      	ldr	r0, [r7, #24]
 801bdf6:	4798      	blx	r3
 801bdf8:	4603      	mov	r3, r0
 801bdfa:	77fb      	strb	r3, [r7, #31]
        if(res != LV_RES_OK) continue;
 801bdfc:	7ffb      	ldrb	r3, [r7, #31]
 801bdfe:	2b01      	cmp	r3, #1
 801be00:	d115      	bne.n	801be2e <lv_img_decoder_open+0xbe>

        dsc->error_msg = NULL;
 801be02:	68fb      	ldr	r3, [r7, #12]
 801be04:	2200      	movs	r2, #0
 801be06:	61da      	str	r2, [r3, #28]
        dsc->img_data  = NULL;
 801be08:	68fb      	ldr	r3, [r7, #12]
 801be0a:	2200      	movs	r2, #0
 801be0c:	615a      	str	r2, [r3, #20]
        dsc->decoder   = d;
 801be0e:	68fb      	ldr	r3, [r7, #12]
 801be10:	69ba      	ldr	r2, [r7, #24]
 801be12:	601a      	str	r2, [r3, #0]

        res = d->open_cb(d, dsc);
 801be14:	69bb      	ldr	r3, [r7, #24]
 801be16:	685b      	ldr	r3, [r3, #4]
 801be18:	68f9      	ldr	r1, [r7, #12]
 801be1a:	69b8      	ldr	r0, [r7, #24]
 801be1c:	4798      	blx	r3
 801be1e:	4603      	mov	r3, r0
 801be20:	77fb      	strb	r3, [r7, #31]

        /*Opened successfully. It is a good decoder to for this image source*/
        if(res == LV_RES_OK) break;
 801be22:	7ffb      	ldrb	r3, [r7, #31]
 801be24:	2b01      	cmp	r3, #1
 801be26:	d00c      	beq.n	801be42 <lv_img_decoder_open+0xd2>
 801be28:	e002      	b.n	801be30 <lv_img_decoder_open+0xc0>
        if(d->info_cb == NULL || d->open_cb == NULL) continue;
 801be2a:	bf00      	nop
 801be2c:	e000      	b.n	801be30 <lv_img_decoder_open+0xc0>
        if(res != LV_RES_OK) continue;
 801be2e:	bf00      	nop
    LV_LL_READ(LV_GC_ROOT(_lv_img_defoder_ll), d)
 801be30:	69b9      	ldr	r1, [r7, #24]
 801be32:	480b      	ldr	r0, [pc, #44]	; (801be60 <lv_img_decoder_open+0xf0>)
 801be34:	f001 fffc 	bl	801de30 <lv_ll_get_next>
 801be38:	61b8      	str	r0, [r7, #24]
 801be3a:	69bb      	ldr	r3, [r7, #24]
 801be3c:	2b00      	cmp	r3, #0
 801be3e:	d1cc      	bne.n	801bdda <lv_img_decoder_open+0x6a>
 801be40:	e000      	b.n	801be44 <lv_img_decoder_open+0xd4>
        if(res == LV_RES_OK) break;
 801be42:	bf00      	nop
    }

    if(res == LV_RES_INV) {
 801be44:	7ffb      	ldrb	r3, [r7, #31]
 801be46:	2b00      	cmp	r3, #0
 801be48:	d104      	bne.n	801be54 <lv_img_decoder_open+0xe4>
        memset(dsc, 0, sizeof(lv_img_decoder_dsc_t));
 801be4a:	2224      	movs	r2, #36	; 0x24
 801be4c:	2100      	movs	r1, #0
 801be4e:	68f8      	ldr	r0, [r7, #12]
 801be50:	f005 ff10 	bl	8021c74 <memset>
    }

    return res;
 801be54:	7ffb      	ldrb	r3, [r7, #31]
}
 801be56:	4618      	mov	r0, r3
 801be58:	3720      	adds	r7, #32
 801be5a:	46bd      	mov	sp, r7
 801be5c:	bd80      	pop	{r7, pc}
 801be5e:	bf00      	nop
 801be60:	2406364c 	.word	0x2406364c

0801be64 <lv_img_decoder_read_line>:
 * @param len number of pixels to read
 * @param buf store the data here
 * @return LV_RES_OK: success; LV_RES_INV: an error occurred
 */
lv_res_t lv_img_decoder_read_line(lv_img_decoder_dsc_t * dsc, lv_coord_t x, lv_coord_t y, lv_coord_t len, uint8_t * buf)
{
 801be64:	b590      	push	{r4, r7, lr}
 801be66:	b089      	sub	sp, #36	; 0x24
 801be68:	af02      	add	r7, sp, #8
 801be6a:	60f8      	str	r0, [r7, #12]
 801be6c:	4608      	mov	r0, r1
 801be6e:	4611      	mov	r1, r2
 801be70:	461a      	mov	r2, r3
 801be72:	4603      	mov	r3, r0
 801be74:	817b      	strh	r3, [r7, #10]
 801be76:	460b      	mov	r3, r1
 801be78:	813b      	strh	r3, [r7, #8]
 801be7a:	4613      	mov	r3, r2
 801be7c:	80fb      	strh	r3, [r7, #6]
    lv_res_t res = LV_RES_INV;
 801be7e:	2300      	movs	r3, #0
 801be80:	75fb      	strb	r3, [r7, #23]
    if(dsc->decoder->read_line_cb) res = dsc->decoder->read_line_cb(dsc->decoder, dsc, x, y, len, buf);
 801be82:	68fb      	ldr	r3, [r7, #12]
 801be84:	681b      	ldr	r3, [r3, #0]
 801be86:	689b      	ldr	r3, [r3, #8]
 801be88:	2b00      	cmp	r3, #0
 801be8a:	d012      	beq.n	801beb2 <lv_img_decoder_read_line+0x4e>
 801be8c:	68fb      	ldr	r3, [r7, #12]
 801be8e:	681b      	ldr	r3, [r3, #0]
 801be90:	689c      	ldr	r4, [r3, #8]
 801be92:	68fb      	ldr	r3, [r7, #12]
 801be94:	6818      	ldr	r0, [r3, #0]
 801be96:	f9b7 1008 	ldrsh.w	r1, [r7, #8]
 801be9a:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 801be9e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801bea0:	9301      	str	r3, [sp, #4]
 801bea2:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801bea6:	9300      	str	r3, [sp, #0]
 801bea8:	460b      	mov	r3, r1
 801beaa:	68f9      	ldr	r1, [r7, #12]
 801beac:	47a0      	blx	r4
 801beae:	4603      	mov	r3, r0
 801beb0:	75fb      	strb	r3, [r7, #23]

    return res;
 801beb2:	7dfb      	ldrb	r3, [r7, #23]
}
 801beb4:	4618      	mov	r0, r3
 801beb6:	371c      	adds	r7, #28
 801beb8:	46bd      	mov	sp, r7
 801beba:	bd90      	pop	{r4, r7, pc}

0801bebc <lv_img_decoder_close>:
/**
 * Close a decoding session
 * @param dsc pointer to `lv_img_decoder_dsc_t` used in `lv_img_decoder_open`
 */
void lv_img_decoder_close(lv_img_decoder_dsc_t * dsc)
{
 801bebc:	b580      	push	{r7, lr}
 801bebe:	b082      	sub	sp, #8
 801bec0:	af00      	add	r7, sp, #0
 801bec2:	6078      	str	r0, [r7, #4]
    if(dsc->decoder) {
 801bec4:	687b      	ldr	r3, [r7, #4]
 801bec6:	681b      	ldr	r3, [r3, #0]
 801bec8:	2b00      	cmp	r3, #0
 801beca:	d018      	beq.n	801befe <lv_img_decoder_close+0x42>
        if(dsc->decoder->close_cb) dsc->decoder->close_cb(dsc->decoder, dsc);
 801becc:	687b      	ldr	r3, [r7, #4]
 801bece:	681b      	ldr	r3, [r3, #0]
 801bed0:	68db      	ldr	r3, [r3, #12]
 801bed2:	2b00      	cmp	r3, #0
 801bed4:	d007      	beq.n	801bee6 <lv_img_decoder_close+0x2a>
 801bed6:	687b      	ldr	r3, [r7, #4]
 801bed8:	681b      	ldr	r3, [r3, #0]
 801beda:	68db      	ldr	r3, [r3, #12]
 801bedc:	687a      	ldr	r2, [r7, #4]
 801bede:	6812      	ldr	r2, [r2, #0]
 801bee0:	6879      	ldr	r1, [r7, #4]
 801bee2:	4610      	mov	r0, r2
 801bee4:	4798      	blx	r3

        if(dsc->src_type == LV_IMG_SRC_FILE) {
 801bee6:	687b      	ldr	r3, [r7, #4]
 801bee8:	7b1b      	ldrb	r3, [r3, #12]
 801beea:	2b01      	cmp	r3, #1
 801beec:	d107      	bne.n	801befe <lv_img_decoder_close+0x42>
            lv_mem_free(dsc->src);
 801beee:	687b      	ldr	r3, [r7, #4]
 801bef0:	685b      	ldr	r3, [r3, #4]
 801bef2:	4618      	mov	r0, r3
 801bef4:	f002 f91c 	bl	801e130 <lv_mem_free>
            dsc->src = NULL;
 801bef8:	687b      	ldr	r3, [r7, #4]
 801befa:	2200      	movs	r2, #0
 801befc:	605a      	str	r2, [r3, #4]
        }
    }
}
 801befe:	bf00      	nop
 801bf00:	3708      	adds	r7, #8
 801bf02:	46bd      	mov	sp, r7
 801bf04:	bd80      	pop	{r7, pc}
	...

0801bf08 <lv_img_decoder_create>:
/**
 * Create a new image decoder
 * @return pointer to the new image decoder
 */
lv_img_decoder_t * lv_img_decoder_create(void)
{
 801bf08:	b580      	push	{r7, lr}
 801bf0a:	b082      	sub	sp, #8
 801bf0c:	af00      	add	r7, sp, #0
    lv_img_decoder_t * decoder;
    decoder = lv_ll_ins_head(&LV_GC_ROOT(_lv_img_defoder_ll));
 801bf0e:	480b      	ldr	r0, [pc, #44]	; (801bf3c <lv_img_decoder_create+0x34>)
 801bf10:	f001 fe06 	bl	801db20 <lv_ll_ins_head>
 801bf14:	6078      	str	r0, [r7, #4]
    lv_mem_assert(decoder);
 801bf16:	687b      	ldr	r3, [r7, #4]
 801bf18:	2b00      	cmp	r3, #0
 801bf1a:	d100      	bne.n	801bf1e <lv_img_decoder_create+0x16>
 801bf1c:	e7fe      	b.n	801bf1c <lv_img_decoder_create+0x14>
    if(decoder == NULL) return NULL;
 801bf1e:	687b      	ldr	r3, [r7, #4]
 801bf20:	2b00      	cmp	r3, #0
 801bf22:	d101      	bne.n	801bf28 <lv_img_decoder_create+0x20>
 801bf24:	2300      	movs	r3, #0
 801bf26:	e005      	b.n	801bf34 <lv_img_decoder_create+0x2c>

    memset(decoder, 0, sizeof(lv_img_decoder_t));
 801bf28:	2210      	movs	r2, #16
 801bf2a:	2100      	movs	r1, #0
 801bf2c:	6878      	ldr	r0, [r7, #4]
 801bf2e:	f005 fea1 	bl	8021c74 <memset>

    return decoder;
 801bf32:	687b      	ldr	r3, [r7, #4]
}
 801bf34:	4618      	mov	r0, r3
 801bf36:	3708      	adds	r7, #8
 801bf38:	46bd      	mov	sp, r7
 801bf3a:	bd80      	pop	{r7, pc}
 801bf3c:	2406364c 	.word	0x2406364c

0801bf40 <lv_img_decoder_set_info_cb>:
 * Set a callback to get information about the image
 * @param decoder pointer to an image decoder
 * @param info_cb a function to collect info about an image (fill an `lv_img_header_t` struct)
 */
void lv_img_decoder_set_info_cb(lv_img_decoder_t * decoder, lv_img_decoder_info_f_t info_cb)
{
 801bf40:	b480      	push	{r7}
 801bf42:	b083      	sub	sp, #12
 801bf44:	af00      	add	r7, sp, #0
 801bf46:	6078      	str	r0, [r7, #4]
 801bf48:	6039      	str	r1, [r7, #0]
    decoder->info_cb = info_cb;
 801bf4a:	687b      	ldr	r3, [r7, #4]
 801bf4c:	683a      	ldr	r2, [r7, #0]
 801bf4e:	601a      	str	r2, [r3, #0]
}
 801bf50:	bf00      	nop
 801bf52:	370c      	adds	r7, #12
 801bf54:	46bd      	mov	sp, r7
 801bf56:	f85d 7b04 	ldr.w	r7, [sp], #4
 801bf5a:	4770      	bx	lr

0801bf5c <lv_img_decoder_set_open_cb>:
 * Set a callback to open an image
 * @param decoder pointer to an image decoder
 * @param open_cb a function to open an image
 */
void lv_img_decoder_set_open_cb(lv_img_decoder_t * decoder, lv_img_decoder_open_f_t open_cb)
{
 801bf5c:	b480      	push	{r7}
 801bf5e:	b083      	sub	sp, #12
 801bf60:	af00      	add	r7, sp, #0
 801bf62:	6078      	str	r0, [r7, #4]
 801bf64:	6039      	str	r1, [r7, #0]
    decoder->open_cb = open_cb;
 801bf66:	687b      	ldr	r3, [r7, #4]
 801bf68:	683a      	ldr	r2, [r7, #0]
 801bf6a:	605a      	str	r2, [r3, #4]
}
 801bf6c:	bf00      	nop
 801bf6e:	370c      	adds	r7, #12
 801bf70:	46bd      	mov	sp, r7
 801bf72:	f85d 7b04 	ldr.w	r7, [sp], #4
 801bf76:	4770      	bx	lr

0801bf78 <lv_img_decoder_set_read_line_cb>:
 * Set a callback to a decoded line of an image
 * @param decoder pointer to an image decoder
 * @param read_line_cb a function to read a line of an image
 */
void lv_img_decoder_set_read_line_cb(lv_img_decoder_t * decoder, lv_img_decoder_read_line_f_t read_line_cb)
{
 801bf78:	b480      	push	{r7}
 801bf7a:	b083      	sub	sp, #12
 801bf7c:	af00      	add	r7, sp, #0
 801bf7e:	6078      	str	r0, [r7, #4]
 801bf80:	6039      	str	r1, [r7, #0]
    decoder->read_line_cb = read_line_cb;
 801bf82:	687b      	ldr	r3, [r7, #4]
 801bf84:	683a      	ldr	r2, [r7, #0]
 801bf86:	609a      	str	r2, [r3, #8]
}
 801bf88:	bf00      	nop
 801bf8a:	370c      	adds	r7, #12
 801bf8c:	46bd      	mov	sp, r7
 801bf8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801bf92:	4770      	bx	lr

0801bf94 <lv_img_decoder_set_close_cb>:
 * Set a callback to close a decoding session. E.g. close files and free other resources.
 * @param decoder pointer to an image decoder
 * @param close_cb a function to close a decoding session
 */
void lv_img_decoder_set_close_cb(lv_img_decoder_t * decoder, lv_img_decoder_close_f_t close_cb)
{
 801bf94:	b480      	push	{r7}
 801bf96:	b083      	sub	sp, #12
 801bf98:	af00      	add	r7, sp, #0
 801bf9a:	6078      	str	r0, [r7, #4]
 801bf9c:	6039      	str	r1, [r7, #0]
    decoder->close_cb = close_cb;
 801bf9e:	687b      	ldr	r3, [r7, #4]
 801bfa0:	683a      	ldr	r2, [r7, #0]
 801bfa2:	60da      	str	r2, [r3, #12]
}
 801bfa4:	bf00      	nop
 801bfa6:	370c      	adds	r7, #12
 801bfa8:	46bd      	mov	sp, r7
 801bfaa:	f85d 7b04 	ldr.w	r7, [sp], #4
 801bfae:	4770      	bx	lr

0801bfb0 <lv_img_decoder_built_in_info>:
 * @param src the image source: pointer to an `lv_img_dsc_t` variable, a file path or a symbol
 * @param header store the image data here
 * @return LV_RES_OK: the info is successfully stored in `header`; LV_RES_INV: unknown format or other error.
 */
lv_res_t lv_img_decoder_built_in_info(lv_img_decoder_t * decoder, const void * src, lv_img_header_t * header)
{
 801bfb0:	b580      	push	{r7, lr}
 801bfb2:	b086      	sub	sp, #24
 801bfb4:	af00      	add	r7, sp, #0
 801bfb6:	60f8      	str	r0, [r7, #12]
 801bfb8:	60b9      	str	r1, [r7, #8]
 801bfba:	607a      	str	r2, [r7, #4]
    (void)decoder; /*Unused*/

    lv_img_src_t src_type = lv_img_src_get_type(src);
 801bfbc:	68b8      	ldr	r0, [r7, #8]
 801bfbe:	f7fa ff38 	bl	8016e32 <lv_img_src_get_type>
 801bfc2:	4603      	mov	r3, r0
 801bfc4:	75fb      	strb	r3, [r7, #23]
    if(src_type == LV_IMG_SRC_VARIABLE) {
 801bfc6:	7dfb      	ldrb	r3, [r7, #23]
 801bfc8:	2b00      	cmp	r3, #0
 801bfca:	d12c      	bne.n	801c026 <lv_img_decoder_built_in_info+0x76>
        lv_img_cf_t cf = ((lv_img_dsc_t *)src)->header.cf;
 801bfcc:	68bb      	ldr	r3, [r7, #8]
 801bfce:	781b      	ldrb	r3, [r3, #0]
 801bfd0:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801bfd4:	b2db      	uxtb	r3, r3
 801bfd6:	75bb      	strb	r3, [r7, #22]
        if(cf < CF_BUILT_IN_FIRST || cf > CF_BUILT_IN_LAST) return LV_RES_INV;
 801bfd8:	7dbb      	ldrb	r3, [r7, #22]
 801bfda:	2b03      	cmp	r3, #3
 801bfdc:	d902      	bls.n	801bfe4 <lv_img_decoder_built_in_info+0x34>
 801bfde:	7dbb      	ldrb	r3, [r7, #22]
 801bfe0:	2b0e      	cmp	r3, #14
 801bfe2:	d901      	bls.n	801bfe8 <lv_img_decoder_built_in_info+0x38>
 801bfe4:	2300      	movs	r3, #0
 801bfe6:	e037      	b.n	801c058 <lv_img_decoder_built_in_info+0xa8>

        header->w  = ((lv_img_dsc_t *)src)->header.w;
 801bfe8:	68bb      	ldr	r3, [r7, #8]
 801bfea:	681b      	ldr	r3, [r3, #0]
 801bfec:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801bff0:	b299      	uxth	r1, r3
 801bff2:	687a      	ldr	r2, [r7, #4]
 801bff4:	6813      	ldr	r3, [r2, #0]
 801bff6:	f361 2394 	bfi	r3, r1, #10, #11
 801bffa:	6013      	str	r3, [r2, #0]
        header->h  = ((lv_img_dsc_t *)src)->header.h;
 801bffc:	68bb      	ldr	r3, [r7, #8]
 801bffe:	885b      	ldrh	r3, [r3, #2]
 801c000:	f3c3 134a 	ubfx	r3, r3, #5, #11
 801c004:	b299      	uxth	r1, r3
 801c006:	687a      	ldr	r2, [r7, #4]
 801c008:	8853      	ldrh	r3, [r2, #2]
 801c00a:	f361 134f 	bfi	r3, r1, #5, #11
 801c00e:	8053      	strh	r3, [r2, #2]
        header->cf = ((lv_img_dsc_t *)src)->header.cf;
 801c010:	68bb      	ldr	r3, [r7, #8]
 801c012:	781b      	ldrb	r3, [r3, #0]
 801c014:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801c018:	b2d9      	uxtb	r1, r3
 801c01a:	687a      	ldr	r2, [r7, #4]
 801c01c:	7813      	ldrb	r3, [r2, #0]
 801c01e:	f361 0304 	bfi	r3, r1, #0, #5
 801c022:	7013      	strb	r3, [r2, #0]
 801c024:	e017      	b.n	801c056 <lv_img_decoder_built_in_info+0xa6>

        if(header->cf < CF_BUILT_IN_FIRST || header->cf > CF_BUILT_IN_LAST) return LV_RES_INV;

    }
#endif
    else if(src_type == LV_IMG_SRC_SYMBOL) {
 801c026:	7dfb      	ldrb	r3, [r7, #23]
 801c028:	2b02      	cmp	r3, #2
 801c02a:	d112      	bne.n	801c052 <lv_img_decoder_built_in_info+0xa2>
        /*The size depend on the font but it is unknown here. It should be handled outside of the
         * function*/
        header->w = 1;
 801c02c:	687a      	ldr	r2, [r7, #4]
 801c02e:	6813      	ldr	r3, [r2, #0]
 801c030:	2101      	movs	r1, #1
 801c032:	f361 2394 	bfi	r3, r1, #10, #11
 801c036:	6013      	str	r3, [r2, #0]
        header->h = 1;
 801c038:	687a      	ldr	r2, [r7, #4]
 801c03a:	8853      	ldrh	r3, [r2, #2]
 801c03c:	2101      	movs	r1, #1
 801c03e:	f361 134f 	bfi	r3, r1, #5, #11
 801c042:	8053      	strh	r3, [r2, #2]
        /* Symbols always have transparent parts. Important because of cover check in the design
         * function. The actual value doesn't matter because lv_draw_label will draw it*/
        header->cf = LV_IMG_CF_ALPHA_1BIT;
 801c044:	687a      	ldr	r2, [r7, #4]
 801c046:	7813      	ldrb	r3, [r2, #0]
 801c048:	210b      	movs	r1, #11
 801c04a:	f361 0304 	bfi	r3, r1, #0, #5
 801c04e:	7013      	strb	r3, [r2, #0]
 801c050:	e001      	b.n	801c056 <lv_img_decoder_built_in_info+0xa6>
    } else {
        LV_LOG_WARN("Image get info found unknown src type");
        return LV_RES_INV;
 801c052:	2300      	movs	r3, #0
 801c054:	e000      	b.n	801c058 <lv_img_decoder_built_in_info+0xa8>
    }
    return LV_RES_OK;
 801c056:	2301      	movs	r3, #1
}
 801c058:	4618      	mov	r0, r3
 801c05a:	3718      	adds	r7, #24
 801c05c:	46bd      	mov	sp, r7
 801c05e:	bd80      	pop	{r7, pc}

0801c060 <lv_img_decoder_built_in_open>:
 * @param decoder the decoder where this function belongs
 * @param dsc pointer to decoder descriptor. `src`, `style` are already initialized in it.
 * @return LV_RES_OK: the info is successfully stored in `header`; LV_RES_INV: unknown format or other error.
 */
lv_res_t lv_img_decoder_built_in_open(lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc)
{
 801c060:	b5b0      	push	{r4, r5, r7, lr}
 801c062:	b088      	sub	sp, #32
 801c064:	af00      	add	r7, sp, #0
 801c066:	6078      	str	r0, [r7, #4]
 801c068:	6039      	str	r1, [r7, #0]
    /*Open the file if it's a file*/
    if(dsc->src_type == LV_IMG_SRC_FILE) {
 801c06a:	683b      	ldr	r3, [r7, #0]
 801c06c:	7b1b      	ldrb	r3, [r3, #12]
 801c06e:	2b01      	cmp	r3, #1
 801c070:	d101      	bne.n	801c076 <lv_img_decoder_built_in_open+0x16>

        memcpy(user_data->f, &f, sizeof(f));

#else
        LV_LOG_WARN("Image built-in decoder cannot read file because LV_USE_FILESYSTEM = 0");
        return LV_RES_INV;
 801c072:	2300      	movs	r3, #0
 801c074:	e0a2      	b.n	801c1bc <lv_img_decoder_built_in_open+0x15c>
#endif
    }

    lv_img_cf_t cf = dsc->header.cf;
 801c076:	683b      	ldr	r3, [r7, #0]
 801c078:	7c1b      	ldrb	r3, [r3, #16]
 801c07a:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801c07e:	b2db      	uxtb	r3, r3
 801c080:	76fb      	strb	r3, [r7, #27]
    /*Process true color formats*/
    if(cf == LV_IMG_CF_TRUE_COLOR || cf == LV_IMG_CF_TRUE_COLOR_ALPHA || cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED) {
 801c082:	7efb      	ldrb	r3, [r7, #27]
 801c084:	2b04      	cmp	r3, #4
 801c086:	d005      	beq.n	801c094 <lv_img_decoder_built_in_open+0x34>
 801c088:	7efb      	ldrb	r3, [r7, #27]
 801c08a:	2b05      	cmp	r3, #5
 801c08c:	d002      	beq.n	801c094 <lv_img_decoder_built_in_open+0x34>
 801c08e:	7efb      	ldrb	r3, [r7, #27]
 801c090:	2b06      	cmp	r3, #6
 801c092:	d10f      	bne.n	801c0b4 <lv_img_decoder_built_in_open+0x54>
        if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
 801c094:	683b      	ldr	r3, [r7, #0]
 801c096:	7b1b      	ldrb	r3, [r3, #12]
 801c098:	2b00      	cmp	r3, #0
 801c09a:	d106      	bne.n	801c0aa <lv_img_decoder_built_in_open+0x4a>
            /* In case of uncompressed formats the image stored in the ROM/RAM.
             * So simply give its pointer*/
            dsc->img_data = ((lv_img_dsc_t *)dsc->src)->data;
 801c09c:	683b      	ldr	r3, [r7, #0]
 801c09e:	685b      	ldr	r3, [r3, #4]
 801c0a0:	689a      	ldr	r2, [r3, #8]
 801c0a2:	683b      	ldr	r3, [r7, #0]
 801c0a4:	615a      	str	r2, [r3, #20]
            return LV_RES_OK;
 801c0a6:	2301      	movs	r3, #1
 801c0a8:	e088      	b.n	801c1bc <lv_img_decoder_built_in_open+0x15c>
        } else {
            /*If it's a file it need to be read line by line later*/
            dsc->img_data = NULL;
 801c0aa:	683b      	ldr	r3, [r7, #0]
 801c0ac:	2200      	movs	r2, #0
 801c0ae:	615a      	str	r2, [r3, #20]
            return LV_RES_OK;
 801c0b0:	2301      	movs	r3, #1
 801c0b2:	e083      	b.n	801c1bc <lv_img_decoder_built_in_open+0x15c>
        }
    }
    /*Process indexed images. Build a palette*/
    else if(cf == LV_IMG_CF_INDEXED_1BIT || cf == LV_IMG_CF_INDEXED_2BIT || cf == LV_IMG_CF_INDEXED_4BIT ||
 801c0b4:	7efb      	ldrb	r3, [r7, #27]
 801c0b6:	2b07      	cmp	r3, #7
 801c0b8:	d008      	beq.n	801c0cc <lv_img_decoder_built_in_open+0x6c>
 801c0ba:	7efb      	ldrb	r3, [r7, #27]
 801c0bc:	2b08      	cmp	r3, #8
 801c0be:	d005      	beq.n	801c0cc <lv_img_decoder_built_in_open+0x6c>
 801c0c0:	7efb      	ldrb	r3, [r7, #27]
 801c0c2:	2b09      	cmp	r3, #9
 801c0c4:	d002      	beq.n	801c0cc <lv_img_decoder_built_in_open+0x6c>
 801c0c6:	7efb      	ldrb	r3, [r7, #27]
 801c0c8:	2b0a      	cmp	r3, #10
 801c0ca:	d161      	bne.n	801c190 <lv_img_decoder_built_in_open+0x130>
            cf == LV_IMG_CF_INDEXED_8BIT) {

#if LV_IMG_CF_INDEXED
        uint8_t px_size       = lv_img_color_format_get_px_size(cf);
 801c0cc:	7efb      	ldrb	r3, [r7, #27]
 801c0ce:	4618      	mov	r0, r3
 801c0d0:	f7fa fe1e 	bl	8016d10 <lv_img_color_format_get_px_size>
 801c0d4:	4603      	mov	r3, r0
 801c0d6:	76bb      	strb	r3, [r7, #26]
        uint32_t palette_size = 1 << px_size;
 801c0d8:	7ebb      	ldrb	r3, [r7, #26]
 801c0da:	2201      	movs	r2, #1
 801c0dc:	fa02 f303 	lsl.w	r3, r2, r3
 801c0e0:	617b      	str	r3, [r7, #20]

        /*Allocate the palette*/
        if(dsc->user_data == NULL) {
 801c0e2:	683b      	ldr	r3, [r7, #0]
 801c0e4:	6a1b      	ldr	r3, [r3, #32]
 801c0e6:	2b00      	cmp	r3, #0
 801c0e8:	d115      	bne.n	801c116 <lv_img_decoder_built_in_open+0xb6>
            dsc->user_data = lv_mem_alloc(sizeof(lv_img_decoder_built_in_data_t));
 801c0ea:	2004      	movs	r0, #4
 801c0ec:	f001 ffe0 	bl	801e0b0 <lv_mem_alloc>
 801c0f0:	4602      	mov	r2, r0
 801c0f2:	683b      	ldr	r3, [r7, #0]
 801c0f4:	621a      	str	r2, [r3, #32]
            if(dsc->user_data == NULL) {
 801c0f6:	683b      	ldr	r3, [r7, #0]
 801c0f8:	6a1b      	ldr	r3, [r3, #32]
 801c0fa:	2b00      	cmp	r3, #0
 801c0fc:	d104      	bne.n	801c108 <lv_img_decoder_built_in_open+0xa8>
                LV_LOG_ERROR("img_decoder_built_in_open: out of memory");
                lv_mem_assert(dsc->user_data);
 801c0fe:	683b      	ldr	r3, [r7, #0]
 801c100:	6a1b      	ldr	r3, [r3, #32]
 801c102:	2b00      	cmp	r3, #0
 801c104:	d100      	bne.n	801c108 <lv_img_decoder_built_in_open+0xa8>
 801c106:	e7fe      	b.n	801c106 <lv_img_decoder_built_in_open+0xa6>
            }
            memset(dsc->user_data, 0, sizeof(lv_img_decoder_built_in_data_t));
 801c108:	683b      	ldr	r3, [r7, #0]
 801c10a:	6a1b      	ldr	r3, [r3, #32]
 801c10c:	2204      	movs	r2, #4
 801c10e:	2100      	movs	r1, #0
 801c110:	4618      	mov	r0, r3
 801c112:	f005 fdaf 	bl	8021c74 <memset>
        }

        lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
 801c116:	683b      	ldr	r3, [r7, #0]
 801c118:	6a1b      	ldr	r3, [r3, #32]
 801c11a:	613b      	str	r3, [r7, #16]
        user_data->palette                         = lv_mem_alloc(palette_size * sizeof(lv_color_t));
 801c11c:	697b      	ldr	r3, [r7, #20]
 801c11e:	005b      	lsls	r3, r3, #1
 801c120:	4618      	mov	r0, r3
 801c122:	f001 ffc5 	bl	801e0b0 <lv_mem_alloc>
 801c126:	4602      	mov	r2, r0
 801c128:	693b      	ldr	r3, [r7, #16]
 801c12a:	601a      	str	r2, [r3, #0]
#if LV_USE_FILESYSTEM
            lv_mem_assert(user_data->f);
#endif
        }

        if(dsc->src_type == LV_IMG_SRC_FILE) {
 801c12c:	683b      	ldr	r3, [r7, #0]
 801c12e:	7b1b      	ldrb	r3, [r3, #12]
 801c130:	2b01      	cmp	r3, #1
 801c132:	d101      	bne.n	801c138 <lv_img_decoder_built_in_open+0xd8>
#if LV_USE_FILESYSTEM
            lv_fs_seek(user_data->f, 4); /*Skip the header*/
            lv_fs_read(user_data->f, user_data->palette, palette_size * sizeof(lv_color_t), NULL);
#else
            LV_LOG_WARN("Image built-in decoder can read the palette because LV_USE_FILESYSTEM = 0");
            return LV_RES_INV;
 801c134:	2300      	movs	r3, #0
 801c136:	e041      	b.n	801c1bc <lv_img_decoder_built_in_open+0x15c>
#endif
        } else {
            /*The palette begins in the beginning of the image data. Just point to it.*/
            lv_color32_t * palette_p = (lv_color32_t *)((lv_img_dsc_t *)dsc->src)->data;
 801c138:	683b      	ldr	r3, [r7, #0]
 801c13a:	685b      	ldr	r3, [r3, #4]
 801c13c:	689b      	ldr	r3, [r3, #8]
 801c13e:	60fb      	str	r3, [r7, #12]

            uint32_t i;
            for(i = 0; i < palette_size; i++) {
 801c140:	2300      	movs	r3, #0
 801c142:	61fb      	str	r3, [r7, #28]
 801c144:	e01b      	b.n	801c17e <lv_img_decoder_built_in_open+0x11e>
                user_data->palette[i] = lv_color_make(palette_p[i].ch.red, palette_p[i].ch.green, palette_p[i].ch.blue);
 801c146:	69fb      	ldr	r3, [r7, #28]
 801c148:	009b      	lsls	r3, r3, #2
 801c14a:	68fa      	ldr	r2, [r7, #12]
 801c14c:	4413      	add	r3, r2
 801c14e:	7898      	ldrb	r0, [r3, #2]
 801c150:	69fb      	ldr	r3, [r7, #28]
 801c152:	009b      	lsls	r3, r3, #2
 801c154:	68fa      	ldr	r2, [r7, #12]
 801c156:	4413      	add	r3, r2
 801c158:	7859      	ldrb	r1, [r3, #1]
 801c15a:	69fb      	ldr	r3, [r7, #28]
 801c15c:	009b      	lsls	r3, r3, #2
 801c15e:	68fa      	ldr	r2, [r7, #12]
 801c160:	4413      	add	r3, r2
 801c162:	781d      	ldrb	r5, [r3, #0]
 801c164:	693b      	ldr	r3, [r7, #16]
 801c166:	681a      	ldr	r2, [r3, #0]
 801c168:	69fb      	ldr	r3, [r7, #28]
 801c16a:	005b      	lsls	r3, r3, #1
 801c16c:	18d4      	adds	r4, r2, r3
 801c16e:	462a      	mov	r2, r5
 801c170:	f7ff fd6c 	bl	801bc4c <lv_color_make>
 801c174:	4603      	mov	r3, r0
 801c176:	8023      	strh	r3, [r4, #0]
            for(i = 0; i < palette_size; i++) {
 801c178:	69fb      	ldr	r3, [r7, #28]
 801c17a:	3301      	adds	r3, #1
 801c17c:	61fb      	str	r3, [r7, #28]
 801c17e:	69fa      	ldr	r2, [r7, #28]
 801c180:	697b      	ldr	r3, [r7, #20]
 801c182:	429a      	cmp	r2, r3
 801c184:	d3df      	bcc.n	801c146 <lv_img_decoder_built_in_open+0xe6>
            }
        }

        dsc->img_data = NULL;
 801c186:	683b      	ldr	r3, [r7, #0]
 801c188:	2200      	movs	r2, #0
 801c18a:	615a      	str	r2, [r3, #20]
        return LV_RES_OK;
 801c18c:	2301      	movs	r3, #1
 801c18e:	e015      	b.n	801c1bc <lv_img_decoder_built_in_open+0x15c>
        LV_LOG_WARN("Indexed (palette) images are not enabled in lv_conf.h. See LV_IMG_CF_INDEXED");
        return LV_RES_INV;
#endif
    }
    /*Alpha indexed images. */
    else if(cf == LV_IMG_CF_ALPHA_1BIT || cf == LV_IMG_CF_ALPHA_2BIT || cf == LV_IMG_CF_ALPHA_4BIT ||
 801c190:	7efb      	ldrb	r3, [r7, #27]
 801c192:	2b0b      	cmp	r3, #11
 801c194:	d008      	beq.n	801c1a8 <lv_img_decoder_built_in_open+0x148>
 801c196:	7efb      	ldrb	r3, [r7, #27]
 801c198:	2b0c      	cmp	r3, #12
 801c19a:	d005      	beq.n	801c1a8 <lv_img_decoder_built_in_open+0x148>
 801c19c:	7efb      	ldrb	r3, [r7, #27]
 801c19e:	2b0d      	cmp	r3, #13
 801c1a0:	d002      	beq.n	801c1a8 <lv_img_decoder_built_in_open+0x148>
 801c1a2:	7efb      	ldrb	r3, [r7, #27]
 801c1a4:	2b0e      	cmp	r3, #14
 801c1a6:	d104      	bne.n	801c1b2 <lv_img_decoder_built_in_open+0x152>
            cf == LV_IMG_CF_ALPHA_8BIT) {
#if LV_IMG_CF_ALPHA
        dsc->img_data = NULL;
 801c1a8:	683b      	ldr	r3, [r7, #0]
 801c1aa:	2200      	movs	r2, #0
 801c1ac:	615a      	str	r2, [r3, #20]
        return LV_RES_OK; /*Nothing to process*/
 801c1ae:	2301      	movs	r3, #1
 801c1b0:	e004      	b.n	801c1bc <lv_img_decoder_built_in_open+0x15c>
#endif
    }
    /*Unknown format. Can't decode it.*/
    else {
        /*Free the potentially allocated memories*/
        lv_img_decoder_built_in_close(decoder, dsc);
 801c1b2:	6839      	ldr	r1, [r7, #0]
 801c1b4:	6878      	ldr	r0, [r7, #4]
 801c1b6:	f000 f897 	bl	801c2e8 <lv_img_decoder_built_in_close>

        LV_LOG_WARN("Image decoder open: unknown color format")
        return LV_RES_INV;
 801c1ba:	2300      	movs	r3, #0
    }
}
 801c1bc:	4618      	mov	r0, r3
 801c1be:	3720      	adds	r7, #32
 801c1c0:	46bd      	mov	sp, r7
 801c1c2:	bdb0      	pop	{r4, r5, r7, pc}

0801c1c4 <lv_img_decoder_built_in_read_line>:
 * @param buf a buffer to store the decoded pixels
 * @return LV_RES_OK: ok; LV_RES_INV: failed
 */
lv_res_t lv_img_decoder_built_in_read_line(lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc, lv_coord_t x,
                                                  lv_coord_t y, lv_coord_t len, uint8_t * buf)
{
 801c1c4:	b580      	push	{r7, lr}
 801c1c6:	b088      	sub	sp, #32
 801c1c8:	af02      	add	r7, sp, #8
 801c1ca:	60f8      	str	r0, [r7, #12]
 801c1cc:	60b9      	str	r1, [r7, #8]
 801c1ce:	4611      	mov	r1, r2
 801c1d0:	461a      	mov	r2, r3
 801c1d2:	460b      	mov	r3, r1
 801c1d4:	80fb      	strh	r3, [r7, #6]
 801c1d6:	4613      	mov	r3, r2
 801c1d8:	80bb      	strh	r3, [r7, #4]
    (void)decoder; /*Unused*/

    lv_res_t res = LV_RES_INV;
 801c1da:	2300      	movs	r3, #0
 801c1dc:	75fb      	strb	r3, [r7, #23]

    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||
 801c1de:	68bb      	ldr	r3, [r7, #8]
 801c1e0:	7c1b      	ldrb	r3, [r3, #16]
 801c1e2:	f003 031f 	and.w	r3, r3, #31
 801c1e6:	b2db      	uxtb	r3, r3
 801c1e8:	2b04      	cmp	r3, #4
 801c1ea:	d00d      	beq.n	801c208 <lv_img_decoder_built_in_read_line+0x44>
 801c1ec:	68bb      	ldr	r3, [r7, #8]
 801c1ee:	7c1b      	ldrb	r3, [r3, #16]
 801c1f0:	f003 031f 	and.w	r3, r3, #31
 801c1f4:	b2db      	uxtb	r3, r3
 801c1f6:	2b05      	cmp	r3, #5
 801c1f8:	d006      	beq.n	801c208 <lv_img_decoder_built_in_read_line+0x44>
       dsc->header.cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED) {
 801c1fa:	68bb      	ldr	r3, [r7, #8]
 801c1fc:	7c1b      	ldrb	r3, [r3, #16]
 801c1fe:	f003 031f 	and.w	r3, r3, #31
 801c202:	b2db      	uxtb	r3, r3
    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||
 801c204:	2b06      	cmp	r3, #6
 801c206:	d112      	bne.n	801c22e <lv_img_decoder_built_in_read_line+0x6a>
        /* For TRUE_COLOR images read line required only for files.
         * For variables the image data was returned in `open`*/
        if(dsc->src_type == LV_IMG_SRC_FILE) {
 801c208:	68bb      	ldr	r3, [r7, #8]
 801c20a:	7b1b      	ldrb	r3, [r3, #12]
 801c20c:	2b01      	cmp	r3, #1
 801c20e:	d166      	bne.n	801c2de <lv_img_decoder_built_in_read_line+0x11a>
            res = lv_img_decoder_built_in_line_true_color(dsc, x, y, len, buf);
 801c210:	f9b7 0020 	ldrsh.w	r0, [r7, #32]
 801c214:	f9b7 2004 	ldrsh.w	r2, [r7, #4]
 801c218:	f9b7 1006 	ldrsh.w	r1, [r7, #6]
 801c21c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c21e:	9300      	str	r3, [sp, #0]
 801c220:	4603      	mov	r3, r0
 801c222:	68b8      	ldr	r0, [r7, #8]
 801c224:	f000 f87e 	bl	801c324 <lv_img_decoder_built_in_line_true_color>
 801c228:	4603      	mov	r3, r0
 801c22a:	75fb      	strb	r3, [r7, #23]
        if(dsc->src_type == LV_IMG_SRC_FILE) {
 801c22c:	e057      	b.n	801c2de <lv_img_decoder_built_in_read_line+0x11a>
        }
    } else if(dsc->header.cf == LV_IMG_CF_ALPHA_1BIT || dsc->header.cf == LV_IMG_CF_ALPHA_2BIT ||
 801c22e:	68bb      	ldr	r3, [r7, #8]
 801c230:	7c1b      	ldrb	r3, [r3, #16]
 801c232:	f003 031f 	and.w	r3, r3, #31
 801c236:	b2db      	uxtb	r3, r3
 801c238:	2b0b      	cmp	r3, #11
 801c23a:	d014      	beq.n	801c266 <lv_img_decoder_built_in_read_line+0xa2>
 801c23c:	68bb      	ldr	r3, [r7, #8]
 801c23e:	7c1b      	ldrb	r3, [r3, #16]
 801c240:	f003 031f 	and.w	r3, r3, #31
 801c244:	b2db      	uxtb	r3, r3
 801c246:	2b0c      	cmp	r3, #12
 801c248:	d00d      	beq.n	801c266 <lv_img_decoder_built_in_read_line+0xa2>
              dsc->header.cf == LV_IMG_CF_ALPHA_4BIT || dsc->header.cf == LV_IMG_CF_ALPHA_8BIT) {
 801c24a:	68bb      	ldr	r3, [r7, #8]
 801c24c:	7c1b      	ldrb	r3, [r3, #16]
 801c24e:	f003 031f 	and.w	r3, r3, #31
 801c252:	b2db      	uxtb	r3, r3
    } else if(dsc->header.cf == LV_IMG_CF_ALPHA_1BIT || dsc->header.cf == LV_IMG_CF_ALPHA_2BIT ||
 801c254:	2b0d      	cmp	r3, #13
 801c256:	d006      	beq.n	801c266 <lv_img_decoder_built_in_read_line+0xa2>
              dsc->header.cf == LV_IMG_CF_ALPHA_4BIT || dsc->header.cf == LV_IMG_CF_ALPHA_8BIT) {
 801c258:	68bb      	ldr	r3, [r7, #8]
 801c25a:	7c1b      	ldrb	r3, [r3, #16]
 801c25c:	f003 031f 	and.w	r3, r3, #31
 801c260:	b2db      	uxtb	r3, r3
 801c262:	2b0e      	cmp	r3, #14
 801c264:	d10e      	bne.n	801c284 <lv_img_decoder_built_in_read_line+0xc0>

        res = lv_img_decoder_built_in_line_alpha(dsc, x, y, len, buf);
 801c266:	f9b7 0020 	ldrsh.w	r0, [r7, #32]
 801c26a:	f9b7 2004 	ldrsh.w	r2, [r7, #4]
 801c26e:	f9b7 1006 	ldrsh.w	r1, [r7, #6]
 801c272:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c274:	9300      	str	r3, [sp, #0]
 801c276:	4603      	mov	r3, r0
 801c278:	68b8      	ldr	r0, [r7, #8]
 801c27a:	f000 f867 	bl	801c34c <lv_img_decoder_built_in_line_alpha>
 801c27e:	4603      	mov	r3, r0
 801c280:	75fb      	strb	r3, [r7, #23]
 801c282:	e02c      	b.n	801c2de <lv_img_decoder_built_in_read_line+0x11a>
    } else if(dsc->header.cf == LV_IMG_CF_INDEXED_1BIT || dsc->header.cf == LV_IMG_CF_INDEXED_2BIT ||
 801c284:	68bb      	ldr	r3, [r7, #8]
 801c286:	7c1b      	ldrb	r3, [r3, #16]
 801c288:	f003 031f 	and.w	r3, r3, #31
 801c28c:	b2db      	uxtb	r3, r3
 801c28e:	2b07      	cmp	r3, #7
 801c290:	d014      	beq.n	801c2bc <lv_img_decoder_built_in_read_line+0xf8>
 801c292:	68bb      	ldr	r3, [r7, #8]
 801c294:	7c1b      	ldrb	r3, [r3, #16]
 801c296:	f003 031f 	and.w	r3, r3, #31
 801c29a:	b2db      	uxtb	r3, r3
 801c29c:	2b08      	cmp	r3, #8
 801c29e:	d00d      	beq.n	801c2bc <lv_img_decoder_built_in_read_line+0xf8>
              dsc->header.cf == LV_IMG_CF_INDEXED_4BIT || dsc->header.cf == LV_IMG_CF_INDEXED_8BIT) {
 801c2a0:	68bb      	ldr	r3, [r7, #8]
 801c2a2:	7c1b      	ldrb	r3, [r3, #16]
 801c2a4:	f003 031f 	and.w	r3, r3, #31
 801c2a8:	b2db      	uxtb	r3, r3
    } else if(dsc->header.cf == LV_IMG_CF_INDEXED_1BIT || dsc->header.cf == LV_IMG_CF_INDEXED_2BIT ||
 801c2aa:	2b09      	cmp	r3, #9
 801c2ac:	d006      	beq.n	801c2bc <lv_img_decoder_built_in_read_line+0xf8>
              dsc->header.cf == LV_IMG_CF_INDEXED_4BIT || dsc->header.cf == LV_IMG_CF_INDEXED_8BIT) {
 801c2ae:	68bb      	ldr	r3, [r7, #8]
 801c2b0:	7c1b      	ldrb	r3, [r3, #16]
 801c2b2:	f003 031f 	and.w	r3, r3, #31
 801c2b6:	b2db      	uxtb	r3, r3
 801c2b8:	2b0a      	cmp	r3, #10
 801c2ba:	d10e      	bne.n	801c2da <lv_img_decoder_built_in_read_line+0x116>
        res = lv_img_decoder_built_in_line_indexed(dsc, x, y, len, buf);
 801c2bc:	f9b7 0020 	ldrsh.w	r0, [r7, #32]
 801c2c0:	f9b7 2004 	ldrsh.w	r2, [r7, #4]
 801c2c4:	f9b7 1006 	ldrsh.w	r1, [r7, #6]
 801c2c8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801c2ca:	9300      	str	r3, [sp, #0]
 801c2cc:	4603      	mov	r3, r0
 801c2ce:	68b8      	ldr	r0, [r7, #8]
 801c2d0:	f000 f9d8 	bl	801c684 <lv_img_decoder_built_in_line_indexed>
 801c2d4:	4603      	mov	r3, r0
 801c2d6:	75fb      	strb	r3, [r7, #23]
 801c2d8:	e001      	b.n	801c2de <lv_img_decoder_built_in_read_line+0x11a>
    } else {
        LV_LOG_WARN("Built-in image decoder read not supports the color format");
        return LV_RES_INV;
 801c2da:	2300      	movs	r3, #0
 801c2dc:	e000      	b.n	801c2e0 <lv_img_decoder_built_in_read_line+0x11c>
    }

    return res;
 801c2de:	7dfb      	ldrb	r3, [r7, #23]
}
 801c2e0:	4618      	mov	r0, r3
 801c2e2:	3718      	adds	r7, #24
 801c2e4:	46bd      	mov	sp, r7
 801c2e6:	bd80      	pop	{r7, pc}

0801c2e8 <lv_img_decoder_built_in_close>:
 * Close the pending decoding. Free resources etc.
 * @param decoder pointer to the decoder the function associated with
 * @param dsc pointer to decoder descriptor
 */
void lv_img_decoder_built_in_close(lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc)
{
 801c2e8:	b580      	push	{r7, lr}
 801c2ea:	b084      	sub	sp, #16
 801c2ec:	af00      	add	r7, sp, #0
 801c2ee:	6078      	str	r0, [r7, #4]
 801c2f0:	6039      	str	r1, [r7, #0]
    (void)decoder; /*Unused*/

    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
 801c2f2:	683b      	ldr	r3, [r7, #0]
 801c2f4:	6a1b      	ldr	r3, [r3, #32]
 801c2f6:	60fb      	str	r3, [r7, #12]
    if(user_data) {
 801c2f8:	68fb      	ldr	r3, [r7, #12]
 801c2fa:	2b00      	cmp	r3, #0
 801c2fc:	d00e      	beq.n	801c31c <lv_img_decoder_built_in_close+0x34>
        if(user_data->f) {
            lv_fs_close(user_data->f);
            lv_mem_free(user_data->f);
        }
#endif
        if(user_data->palette) lv_mem_free(user_data->palette);
 801c2fe:	68fb      	ldr	r3, [r7, #12]
 801c300:	681b      	ldr	r3, [r3, #0]
 801c302:	2b00      	cmp	r3, #0
 801c304:	d004      	beq.n	801c310 <lv_img_decoder_built_in_close+0x28>
 801c306:	68fb      	ldr	r3, [r7, #12]
 801c308:	681b      	ldr	r3, [r3, #0]
 801c30a:	4618      	mov	r0, r3
 801c30c:	f001 ff10 	bl	801e130 <lv_mem_free>

        lv_mem_free(user_data);
 801c310:	68f8      	ldr	r0, [r7, #12]
 801c312:	f001 ff0d 	bl	801e130 <lv_mem_free>

        dsc->user_data = NULL;
 801c316:	683b      	ldr	r3, [r7, #0]
 801c318:	2200      	movs	r2, #0
 801c31a:	621a      	str	r2, [r3, #32]
    }
}
 801c31c:	bf00      	nop
 801c31e:	3710      	adds	r7, #16
 801c320:	46bd      	mov	sp, r7
 801c322:	bd80      	pop	{r7, pc}

0801c324 <lv_img_decoder_built_in_line_true_color>:
 *   STATIC FUNCTIONS
 **********************/

static lv_res_t lv_img_decoder_built_in_line_true_color(lv_img_decoder_dsc_t * dsc, lv_coord_t x, lv_coord_t y,
                                                        lv_coord_t len, uint8_t * buf)
{
 801c324:	b480      	push	{r7}
 801c326:	b085      	sub	sp, #20
 801c328:	af00      	add	r7, sp, #0
 801c32a:	60f8      	str	r0, [r7, #12]
 801c32c:	4608      	mov	r0, r1
 801c32e:	4611      	mov	r1, r2
 801c330:	461a      	mov	r2, r3
 801c332:	4603      	mov	r3, r0
 801c334:	817b      	strh	r3, [r7, #10]
 801c336:	460b      	mov	r3, r1
 801c338:	813b      	strh	r3, [r7, #8]
 801c33a:	4613      	mov	r3, r2
 801c33c:	80fb      	strh	r3, [r7, #6]
    }

    return LV_RES_OK;
#else
    LV_LOG_WARN("Image built-in decoder cannot read file because LV_USE_FILESYSTEM = 0");
    return LV_RES_INV;
 801c33e:	2300      	movs	r3, #0
#endif
}
 801c340:	4618      	mov	r0, r3
 801c342:	3714      	adds	r7, #20
 801c344:	46bd      	mov	sp, r7
 801c346:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c34a:	4770      	bx	lr

0801c34c <lv_img_decoder_built_in_line_alpha>:

static lv_res_t lv_img_decoder_built_in_line_alpha(lv_img_decoder_dsc_t * dsc, lv_coord_t x, lv_coord_t y,
                                                   lv_coord_t len, uint8_t * buf)
{
 801c34c:	b590      	push	{r4, r7, lr}
 801c34e:	b095      	sub	sp, #84	; 0x54
 801c350:	af00      	add	r7, sp, #0
 801c352:	60f8      	str	r0, [r7, #12]
 801c354:	4608      	mov	r0, r1
 801c356:	4611      	mov	r1, r2
 801c358:	461a      	mov	r2, r3
 801c35a:	4603      	mov	r3, r0
 801c35c:	817b      	strh	r3, [r7, #10]
 801c35e:	460b      	mov	r3, r1
 801c360:	813b      	strh	r3, [r7, #8]
 801c362:	4613      	mov	r3, r2
 801c364:	80fb      	strh	r3, [r7, #6]

#if LV_IMG_CF_ALPHA
    const lv_opa_t alpha1_opa_table[2]  = {0, 255};          /*Opacity mapping with bpp = 1 (Just for compatibility)*/
 801c366:	f44f 437f 	mov.w	r3, #65280	; 0xff00
 801c36a:	85bb      	strh	r3, [r7, #44]	; 0x2c
    const lv_opa_t alpha2_opa_table[4]  = {0, 85, 170, 255}; /*Opacity mapping with bpp = 2*/
 801c36c:	4ba9      	ldr	r3, [pc, #676]	; (801c614 <lv_img_decoder_built_in_line_alpha+0x2c8>)
 801c36e:	62bb      	str	r3, [r7, #40]	; 0x28
    const lv_opa_t alpha4_opa_table[16] = {0,  17, 34,  51,  /*Opacity mapping with bpp = 4*/
 801c370:	4ba9      	ldr	r3, [pc, #676]	; (801c618 <lv_img_decoder_built_in_line_alpha+0x2cc>)
 801c372:	f107 0418 	add.w	r4, r7, #24
 801c376:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801c378:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
                                           68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255};

    /*Simply fill the buffer with the color. Later only the alpha value will be modified.*/
    lv_color_t bg_color = dsc->style->image.color;
 801c37c:	68fb      	ldr	r3, [r7, #12]
 801c37e:	689b      	ldr	r3, [r3, #8]
 801c380:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 801c382:	82bb      	strh	r3, [r7, #20]
    lv_coord_t i;
    for(i = 0; i < len; i++) {
 801c384:	2300      	movs	r3, #0
 801c386:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 801c38a:	e01e      	b.n	801c3ca <lv_img_decoder_built_in_line_alpha+0x7e>
#if LV_COLOR_DEPTH == 8 || LV_COLOR_DEPTH == 1
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE] = bg_color.full;
#elif LV_COLOR_DEPTH == 16
        /*Because of Alpha byte 16 bit color can start on odd address which can cause crash*/
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE] = bg_color.full & 0xFF;
 801c38c:	8ab9      	ldrh	r1, [r7, #20]
 801c38e:	f9b7 204e 	ldrsh.w	r2, [r7, #78]	; 0x4e
 801c392:	4613      	mov	r3, r2
 801c394:	005b      	lsls	r3, r3, #1
 801c396:	4413      	add	r3, r2
 801c398:	461a      	mov	r2, r3
 801c39a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 801c39c:	4413      	add	r3, r2
 801c39e:	b2ca      	uxtb	r2, r1
 801c3a0:	701a      	strb	r2, [r3, #0]
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + 1] = (bg_color.full >> 8) & 0xFF;
 801c3a2:	8abb      	ldrh	r3, [r7, #20]
 801c3a4:	0a1b      	lsrs	r3, r3, #8
 801c3a6:	b299      	uxth	r1, r3
 801c3a8:	f9b7 204e 	ldrsh.w	r2, [r7, #78]	; 0x4e
 801c3ac:	4613      	mov	r3, r2
 801c3ae:	005b      	lsls	r3, r3, #1
 801c3b0:	4413      	add	r3, r2
 801c3b2:	3301      	adds	r3, #1
 801c3b4:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 801c3b6:	4413      	add	r3, r2
 801c3b8:	b2ca      	uxtb	r2, r1
 801c3ba:	701a      	strb	r2, [r3, #0]
    for(i = 0; i < len; i++) {
 801c3bc:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 801c3c0:	b29b      	uxth	r3, r3
 801c3c2:	3301      	adds	r3, #1
 801c3c4:	b29b      	uxth	r3, r3
 801c3c6:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 801c3ca:	f9b7 204e 	ldrsh.w	r2, [r7, #78]	; 0x4e
 801c3ce:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801c3d2:	429a      	cmp	r2, r3
 801c3d4:	dbda      	blt.n	801c38c <lv_img_decoder_built_in_line_alpha+0x40>
#else
#error "Invalid LV_COLOR_DEPTH. Check it in lv_conf.h"
#endif
    }

    const lv_opa_t * opa_table = NULL;
 801c3d6:	2300      	movs	r3, #0
 801c3d8:	64bb      	str	r3, [r7, #72]	; 0x48
    uint8_t px_size            = lv_img_color_format_get_px_size(dsc->header.cf);
 801c3da:	68fb      	ldr	r3, [r7, #12]
 801c3dc:	7c1b      	ldrb	r3, [r3, #16]
 801c3de:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801c3e2:	b2db      	uxtb	r3, r3
 801c3e4:	4618      	mov	r0, r3
 801c3e6:	f7fa fc93 	bl	8016d10 <lv_img_color_format_get_px_size>
 801c3ea:	4603      	mov	r3, r0
 801c3ec:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    uint16_t mask              = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
 801c3f0:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801c3f4:	2201      	movs	r2, #1
 801c3f6:	fa02 f303 	lsl.w	r3, r2, r3
 801c3fa:	b29b      	uxth	r3, r3
 801c3fc:	3b01      	subs	r3, #1
 801c3fe:	86bb      	strh	r3, [r7, #52]	; 0x34

    lv_coord_t w = 0;
 801c400:	2300      	movs	r3, #0
 801c402:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
    uint32_t ofs = 0;
 801c406:	2300      	movs	r3, #0
 801c408:	643b      	str	r3, [r7, #64]	; 0x40
    int8_t pos   = 0;
 801c40a:	2300      	movs	r3, #0
 801c40c:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
    switch(dsc->header.cf) {
 801c410:	68fb      	ldr	r3, [r7, #12]
 801c412:	7c1b      	ldrb	r3, [r3, #16]
 801c414:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801c418:	b2db      	uxtb	r3, r3
 801c41a:	3b0b      	subs	r3, #11
 801c41c:	2b03      	cmp	r3, #3
 801c41e:	f200 80c0 	bhi.w	801c5a2 <lv_img_decoder_built_in_line_alpha+0x256>
 801c422:	a201      	add	r2, pc, #4	; (adr r2, 801c428 <lv_img_decoder_built_in_line_alpha+0xdc>)
 801c424:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801c428:	0801c439 	.word	0x0801c439
 801c42c:	0801c49f 	.word	0x0801c49f
 801c430:	0801c509 	.word	0x0801c509
 801c434:	0801c573 	.word	0x0801c573
        case LV_IMG_CF_ALPHA_1BIT:
            w = (dsc->header.w >> 3); /*E.g. w = 20 -> w = 2 + 1*/
 801c438:	68fb      	ldr	r3, [r7, #12]
 801c43a:	691b      	ldr	r3, [r3, #16]
 801c43c:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801c440:	b29b      	uxth	r3, r3
 801c442:	10db      	asrs	r3, r3, #3
 801c444:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
            if(dsc->header.w & 0x7) w++;
 801c448:	68fb      	ldr	r3, [r7, #12]
 801c44a:	691b      	ldr	r3, [r3, #16]
 801c44c:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801c450:	b29b      	uxth	r3, r3
 801c452:	f003 0307 	and.w	r3, r3, #7
 801c456:	2b00      	cmp	r3, #0
 801c458:	d006      	beq.n	801c468 <lv_img_decoder_built_in_line_alpha+0x11c>
 801c45a:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 801c45e:	b29b      	uxth	r3, r3
 801c460:	3301      	adds	r3, #1
 801c462:	b29b      	uxth	r3, r3
 801c464:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
            ofs += w * y + (x >> 3); /*First pixel*/
 801c468:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 801c46c:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 801c470:	fb02 f303 	mul.w	r3, r2, r3
 801c474:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 801c478:	10d2      	asrs	r2, r2, #3
 801c47a:	b212      	sxth	r2, r2
 801c47c:	4413      	add	r3, r2
 801c47e:	461a      	mov	r2, r3
 801c480:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c482:	4413      	add	r3, r2
 801c484:	643b      	str	r3, [r7, #64]	; 0x40
            pos       = 7 - (x & 0x7);
 801c486:	897b      	ldrh	r3, [r7, #10]
 801c488:	b25b      	sxtb	r3, r3
 801c48a:	43db      	mvns	r3, r3
 801c48c:	b25b      	sxtb	r3, r3
 801c48e:	f003 0307 	and.w	r3, r3, #7
 801c492:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
            opa_table = alpha1_opa_table;
 801c496:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 801c49a:	64bb      	str	r3, [r7, #72]	; 0x48
            break;
 801c49c:	e081      	b.n	801c5a2 <lv_img_decoder_built_in_line_alpha+0x256>
        case LV_IMG_CF_ALPHA_2BIT:
            w = (dsc->header.w >> 2); /*E.g. w = 13 -> w = 3 + 1 (bytes)*/
 801c49e:	68fb      	ldr	r3, [r7, #12]
 801c4a0:	691b      	ldr	r3, [r3, #16]
 801c4a2:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801c4a6:	b29b      	uxth	r3, r3
 801c4a8:	109b      	asrs	r3, r3, #2
 801c4aa:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
            if(dsc->header.w & 0x3) w++;
 801c4ae:	68fb      	ldr	r3, [r7, #12]
 801c4b0:	691b      	ldr	r3, [r3, #16]
 801c4b2:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801c4b6:	b29b      	uxth	r3, r3
 801c4b8:	f003 0303 	and.w	r3, r3, #3
 801c4bc:	2b00      	cmp	r3, #0
 801c4be:	d006      	beq.n	801c4ce <lv_img_decoder_built_in_line_alpha+0x182>
 801c4c0:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 801c4c4:	b29b      	uxth	r3, r3
 801c4c6:	3301      	adds	r3, #1
 801c4c8:	b29b      	uxth	r3, r3
 801c4ca:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
            ofs += w * y + (x >> 2); /*First pixel*/
 801c4ce:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 801c4d2:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 801c4d6:	fb02 f303 	mul.w	r3, r2, r3
 801c4da:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 801c4de:	1092      	asrs	r2, r2, #2
 801c4e0:	b212      	sxth	r2, r2
 801c4e2:	4413      	add	r3, r2
 801c4e4:	461a      	mov	r2, r3
 801c4e6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c4e8:	4413      	add	r3, r2
 801c4ea:	643b      	str	r3, [r7, #64]	; 0x40
            pos       = 6 - ((x & 0x3) * 2);
 801c4ec:	897b      	ldrh	r3, [r7, #10]
 801c4ee:	43db      	mvns	r3, r3
 801c4f0:	b2db      	uxtb	r3, r3
 801c4f2:	f003 0303 	and.w	r3, r3, #3
 801c4f6:	b2db      	uxtb	r3, r3
 801c4f8:	005b      	lsls	r3, r3, #1
 801c4fa:	b2db      	uxtb	r3, r3
 801c4fc:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
            opa_table = alpha2_opa_table;
 801c500:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801c504:	64bb      	str	r3, [r7, #72]	; 0x48
            break;
 801c506:	e04c      	b.n	801c5a2 <lv_img_decoder_built_in_line_alpha+0x256>
        case LV_IMG_CF_ALPHA_4BIT:
            w = (dsc->header.w >> 1); /*E.g. w = 13 -> w = 6 + 1 (bytes)*/
 801c508:	68fb      	ldr	r3, [r7, #12]
 801c50a:	691b      	ldr	r3, [r3, #16]
 801c50c:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801c510:	b29b      	uxth	r3, r3
 801c512:	105b      	asrs	r3, r3, #1
 801c514:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
            if(dsc->header.w & 0x1) w++;
 801c518:	68fb      	ldr	r3, [r7, #12]
 801c51a:	691b      	ldr	r3, [r3, #16]
 801c51c:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801c520:	b29b      	uxth	r3, r3
 801c522:	f003 0301 	and.w	r3, r3, #1
 801c526:	2b00      	cmp	r3, #0
 801c528:	d006      	beq.n	801c538 <lv_img_decoder_built_in_line_alpha+0x1ec>
 801c52a:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 801c52e:	b29b      	uxth	r3, r3
 801c530:	3301      	adds	r3, #1
 801c532:	b29b      	uxth	r3, r3
 801c534:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
            ofs += w * y + (x >> 1); /*First pixel*/
 801c538:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 801c53c:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 801c540:	fb02 f303 	mul.w	r3, r2, r3
 801c544:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 801c548:	1052      	asrs	r2, r2, #1
 801c54a:	b212      	sxth	r2, r2
 801c54c:	4413      	add	r3, r2
 801c54e:	461a      	mov	r2, r3
 801c550:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c552:	4413      	add	r3, r2
 801c554:	643b      	str	r3, [r7, #64]	; 0x40
            pos       = 4 - ((x & 0x1) * 4);
 801c556:	897b      	ldrh	r3, [r7, #10]
 801c558:	f003 0301 	and.w	r3, r3, #1
 801c55c:	2b00      	cmp	r3, #0
 801c55e:	d101      	bne.n	801c564 <lv_img_decoder_built_in_line_alpha+0x218>
 801c560:	2304      	movs	r3, #4
 801c562:	e000      	b.n	801c566 <lv_img_decoder_built_in_line_alpha+0x21a>
 801c564:	2300      	movs	r3, #0
 801c566:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
            opa_table = alpha4_opa_table;
 801c56a:	f107 0318 	add.w	r3, r7, #24
 801c56e:	64bb      	str	r3, [r7, #72]	; 0x48
            break;
 801c570:	e017      	b.n	801c5a2 <lv_img_decoder_built_in_line_alpha+0x256>
        case LV_IMG_CF_ALPHA_8BIT:
            w = dsc->header.w; /*E.g. x = 7 -> w = 7 (bytes)*/
 801c572:	68fb      	ldr	r3, [r7, #12]
 801c574:	691b      	ldr	r3, [r3, #16]
 801c576:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801c57a:	b29b      	uxth	r3, r3
 801c57c:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
            ofs += w * y + x;  /*First pixel*/
 801c580:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 801c584:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 801c588:	fb02 f203 	mul.w	r2, r2, r3
 801c58c:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 801c590:	4413      	add	r3, r2
 801c592:	461a      	mov	r2, r3
 801c594:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c596:	4413      	add	r3, r2
 801c598:	643b      	str	r3, [r7, #64]	; 0x40
            pos = 0;
 801c59a:	2300      	movs	r3, #0
 801c59c:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
            break;
 801c5a0:	bf00      	nop
#if LV_USE_FILESYSTEM
    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
    uint8_t fs_buf[LV_HOR_RES_MAX];
#endif

    const uint8_t * data_tmp = NULL;
 801c5a2:	2300      	movs	r3, #0
 801c5a4:	63bb      	str	r3, [r7, #56]	; 0x38
    if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
 801c5a6:	68fb      	ldr	r3, [r7, #12]
 801c5a8:	7b1b      	ldrb	r3, [r3, #12]
 801c5aa:	2b00      	cmp	r3, #0
 801c5ac:	d10e      	bne.n	801c5cc <lv_img_decoder_built_in_line_alpha+0x280>
        const lv_img_dsc_t * img_dsc = dsc->src;
 801c5ae:	68fb      	ldr	r3, [r7, #12]
 801c5b0:	685b      	ldr	r3, [r3, #4]
 801c5b2:	633b      	str	r3, [r7, #48]	; 0x30

        data_tmp = img_dsc->data + ofs;
 801c5b4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c5b6:	689a      	ldr	r2, [r3, #8]
 801c5b8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c5ba:	4413      	add	r3, r2
 801c5bc:	63bb      	str	r3, [r7, #56]	; 0x38
        data_tmp = NULL; /*To avoid warnings*/
        return LV_RES_INV;
#endif
    }

    uint8_t byte_act = 0;
 801c5be:	2300      	movs	r3, #0
 801c5c0:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    uint8_t val_act;
    for(i = 0; i < len; i++) {
 801c5c4:	2300      	movs	r3, #0
 801c5c6:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 801c5ca:	e04f      	b.n	801c66c <lv_img_decoder_built_in_line_alpha+0x320>
        data_tmp = NULL; /*To avoid warnings*/
 801c5cc:	2300      	movs	r3, #0
 801c5ce:	63bb      	str	r3, [r7, #56]	; 0x38
        return LV_RES_INV;
 801c5d0:	2300      	movs	r3, #0
 801c5d2:	e052      	b.n	801c67a <lv_img_decoder_built_in_line_alpha+0x32e>
        val_act = (data_tmp[byte_act] & (mask << pos)) >> pos;
 801c5d4:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 801c5d8:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801c5da:	4413      	add	r3, r2
 801c5dc:	781b      	ldrb	r3, [r3, #0]
 801c5de:	4619      	mov	r1, r3
 801c5e0:	8eba      	ldrh	r2, [r7, #52]	; 0x34
 801c5e2:	f997 303f 	ldrsb.w	r3, [r7, #63]	; 0x3f
 801c5e6:	fa02 f303 	lsl.w	r3, r2, r3
 801c5ea:	ea01 0203 	and.w	r2, r1, r3
 801c5ee:	f997 303f 	ldrsb.w	r3, [r7, #63]	; 0x3f
 801c5f2:	fa42 f303 	asr.w	r3, r2, r3
 801c5f6:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e

        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
            dsc->header.cf == LV_IMG_CF_ALPHA_8BIT ? val_act : opa_table[val_act];
 801c5fa:	68fb      	ldr	r3, [r7, #12]
 801c5fc:	7c1b      	ldrb	r3, [r3, #16]
 801c5fe:	f003 031f 	and.w	r3, r3, #31
 801c602:	b2db      	uxtb	r3, r3
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
 801c604:	2b0e      	cmp	r3, #14
 801c606:	d009      	beq.n	801c61c <lv_img_decoder_built_in_line_alpha+0x2d0>
            dsc->header.cf == LV_IMG_CF_ALPHA_8BIT ? val_act : opa_table[val_act];
 801c608:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 801c60c:	6cba      	ldr	r2, [r7, #72]	; 0x48
 801c60e:	4413      	add	r3, r2
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
 801c610:	781a      	ldrb	r2, [r3, #0]
 801c612:	e005      	b.n	801c620 <lv_img_decoder_built_in_line_alpha+0x2d4>
 801c614:	ffaa5500 	.word	0xffaa5500
 801c618:	080228ec 	.word	0x080228ec
 801c61c:	f897 202e 	ldrb.w	r2, [r7, #46]	; 0x2e
 801c620:	f9b7 104e 	ldrsh.w	r1, [r7, #78]	; 0x4e
 801c624:	460b      	mov	r3, r1
 801c626:	005b      	lsls	r3, r3, #1
 801c628:	440b      	add	r3, r1
 801c62a:	3302      	adds	r3, #2
 801c62c:	6e39      	ldr	r1, [r7, #96]	; 0x60
 801c62e:	440b      	add	r3, r1
 801c630:	701a      	strb	r2, [r3, #0]

        pos -= px_size;
 801c632:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 801c636:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801c63a:	1ad3      	subs	r3, r2, r3
 801c63c:	b2db      	uxtb	r3, r3
 801c63e:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
        if(pos < 0) {
 801c642:	f997 303f 	ldrsb.w	r3, [r7, #63]	; 0x3f
 801c646:	2b00      	cmp	r3, #0
 801c648:	da09      	bge.n	801c65e <lv_img_decoder_built_in_line_alpha+0x312>
            pos = 8 - px_size;
 801c64a:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 801c64e:	f1c3 0308 	rsb	r3, r3, #8
 801c652:	b2db      	uxtb	r3, r3
 801c654:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
            data_tmp++;
 801c658:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801c65a:	3301      	adds	r3, #1
 801c65c:	63bb      	str	r3, [r7, #56]	; 0x38
    for(i = 0; i < len; i++) {
 801c65e:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 801c662:	b29b      	uxth	r3, r3
 801c664:	3301      	adds	r3, #1
 801c666:	b29b      	uxth	r3, r3
 801c668:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
 801c66c:	f9b7 204e 	ldrsh.w	r2, [r7, #78]	; 0x4e
 801c670:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801c674:	429a      	cmp	r2, r3
 801c676:	dbad      	blt.n	801c5d4 <lv_img_decoder_built_in_line_alpha+0x288>
        }
    }

    return LV_RES_OK;
 801c678:	2301      	movs	r3, #1

#else
    LV_LOG_WARN("Image built-in alpha line reader failed because LV_IMG_CF_ALPHA is 0 in lv_conf.h");
    return LV_RES_INV;
#endif
}
 801c67a:	4618      	mov	r0, r3
 801c67c:	3754      	adds	r7, #84	; 0x54
 801c67e:	46bd      	mov	sp, r7
 801c680:	bd90      	pop	{r4, r7, pc}
 801c682:	bf00      	nop

0801c684 <lv_img_decoder_built_in_line_indexed>:

static lv_res_t lv_img_decoder_built_in_line_indexed(lv_img_decoder_dsc_t * dsc, lv_coord_t x, lv_coord_t y,
                                                     lv_coord_t len, uint8_t * buf)
{
 801c684:	b580      	push	{r7, lr}
 801c686:	b08e      	sub	sp, #56	; 0x38
 801c688:	af00      	add	r7, sp, #0
 801c68a:	60f8      	str	r0, [r7, #12]
 801c68c:	4608      	mov	r0, r1
 801c68e:	4611      	mov	r1, r2
 801c690:	461a      	mov	r2, r3
 801c692:	4603      	mov	r3, r0
 801c694:	817b      	strh	r3, [r7, #10]
 801c696:	460b      	mov	r3, r1
 801c698:	813b      	strh	r3, [r7, #8]
 801c69a:	4613      	mov	r3, r2
 801c69c:	80fb      	strh	r3, [r7, #6]

#if LV_IMG_CF_INDEXED
    uint8_t px_size = lv_img_color_format_get_px_size(dsc->header.cf);
 801c69e:	68fb      	ldr	r3, [r7, #12]
 801c6a0:	7c1b      	ldrb	r3, [r3, #16]
 801c6a2:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801c6a6:	b2db      	uxtb	r3, r3
 801c6a8:	4618      	mov	r0, r3
 801c6aa:	f7fa fb31 	bl	8016d10 <lv_img_color_format_get_px_size>
 801c6ae:	4603      	mov	r3, r0
 801c6b0:	f887 3029 	strb.w	r3, [r7, #41]	; 0x29
    uint16_t mask   = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
 801c6b4:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 801c6b8:	2201      	movs	r2, #1
 801c6ba:	fa02 f303 	lsl.w	r3, r2, r3
 801c6be:	b29b      	uxth	r3, r3
 801c6c0:	3b01      	subs	r3, #1
 801c6c2:	84fb      	strh	r3, [r7, #38]	; 0x26

    lv_coord_t w = 0;
 801c6c4:	2300      	movs	r3, #0
 801c6c6:	86fb      	strh	r3, [r7, #54]	; 0x36
    int8_t pos   = 0;
 801c6c8:	2300      	movs	r3, #0
 801c6ca:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
    uint32_t ofs = 0;
 801c6ce:	2300      	movs	r3, #0
 801c6d0:	633b      	str	r3, [r7, #48]	; 0x30
    switch(dsc->header.cf) {
 801c6d2:	68fb      	ldr	r3, [r7, #12]
 801c6d4:	7c1b      	ldrb	r3, [r3, #16]
 801c6d6:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801c6da:	b2db      	uxtb	r3, r3
 801c6dc:	3b07      	subs	r3, #7
 801c6de:	2b03      	cmp	r3, #3
 801c6e0:	f200 80be 	bhi.w	801c860 <lv_img_decoder_built_in_line_indexed+0x1dc>
 801c6e4:	a201      	add	r2, pc, #4	; (adr r2, 801c6ec <lv_img_decoder_built_in_line_indexed+0x68>)
 801c6e6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801c6ea:	bf00      	nop
 801c6ec:	0801c6fd 	.word	0x0801c6fd
 801c6f0:	0801c75f 	.word	0x0801c75f
 801c6f4:	0801c7c5 	.word	0x0801c7c5
 801c6f8:	0801c82b 	.word	0x0801c82b
        case LV_IMG_CF_INDEXED_1BIT:
            w = (dsc->header.w >> 3); /*E.g. w = 20 -> w = 2 + 1*/
 801c6fc:	68fb      	ldr	r3, [r7, #12]
 801c6fe:	691b      	ldr	r3, [r3, #16]
 801c700:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801c704:	b29b      	uxth	r3, r3
 801c706:	10db      	asrs	r3, r3, #3
 801c708:	86fb      	strh	r3, [r7, #54]	; 0x36
            if(dsc->header.w & 0x7) w++;
 801c70a:	68fb      	ldr	r3, [r7, #12]
 801c70c:	691b      	ldr	r3, [r3, #16]
 801c70e:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801c712:	b29b      	uxth	r3, r3
 801c714:	f003 0307 	and.w	r3, r3, #7
 801c718:	2b00      	cmp	r3, #0
 801c71a:	d005      	beq.n	801c728 <lv_img_decoder_built_in_line_indexed+0xa4>
 801c71c:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 801c720:	b29b      	uxth	r3, r3
 801c722:	3301      	adds	r3, #1
 801c724:	b29b      	uxth	r3, r3
 801c726:	86fb      	strh	r3, [r7, #54]	; 0x36
            ofs += w * y + (x >> 3); /*First pixel*/
 801c728:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 801c72c:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 801c730:	fb02 f303 	mul.w	r3, r2, r3
 801c734:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 801c738:	10d2      	asrs	r2, r2, #3
 801c73a:	b212      	sxth	r2, r2
 801c73c:	4413      	add	r3, r2
 801c73e:	461a      	mov	r2, r3
 801c740:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c742:	4413      	add	r3, r2
 801c744:	633b      	str	r3, [r7, #48]	; 0x30
            ofs += 8;                /*Skip the palette*/
 801c746:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c748:	3308      	adds	r3, #8
 801c74a:	633b      	str	r3, [r7, #48]	; 0x30
            pos = 7 - (x & 0x7);
 801c74c:	897b      	ldrh	r3, [r7, #10]
 801c74e:	b25b      	sxtb	r3, r3
 801c750:	43db      	mvns	r3, r3
 801c752:	b25b      	sxtb	r3, r3
 801c754:	f003 0307 	and.w	r3, r3, #7
 801c758:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
            break;
 801c75c:	e080      	b.n	801c860 <lv_img_decoder_built_in_line_indexed+0x1dc>
        case LV_IMG_CF_INDEXED_2BIT:
            w = (dsc->header.w >> 2); /*E.g. w = 13 -> w = 3 + 1 (bytes)*/
 801c75e:	68fb      	ldr	r3, [r7, #12]
 801c760:	691b      	ldr	r3, [r3, #16]
 801c762:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801c766:	b29b      	uxth	r3, r3
 801c768:	109b      	asrs	r3, r3, #2
 801c76a:	86fb      	strh	r3, [r7, #54]	; 0x36
            if(dsc->header.w & 0x3) w++;
 801c76c:	68fb      	ldr	r3, [r7, #12]
 801c76e:	691b      	ldr	r3, [r3, #16]
 801c770:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801c774:	b29b      	uxth	r3, r3
 801c776:	f003 0303 	and.w	r3, r3, #3
 801c77a:	2b00      	cmp	r3, #0
 801c77c:	d005      	beq.n	801c78a <lv_img_decoder_built_in_line_indexed+0x106>
 801c77e:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 801c782:	b29b      	uxth	r3, r3
 801c784:	3301      	adds	r3, #1
 801c786:	b29b      	uxth	r3, r3
 801c788:	86fb      	strh	r3, [r7, #54]	; 0x36
            ofs += w * y + (x >> 2); /*First pixel*/
 801c78a:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 801c78e:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 801c792:	fb02 f303 	mul.w	r3, r2, r3
 801c796:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 801c79a:	1092      	asrs	r2, r2, #2
 801c79c:	b212      	sxth	r2, r2
 801c79e:	4413      	add	r3, r2
 801c7a0:	461a      	mov	r2, r3
 801c7a2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c7a4:	4413      	add	r3, r2
 801c7a6:	633b      	str	r3, [r7, #48]	; 0x30
            ofs += 16;               /*Skip the palette*/
 801c7a8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c7aa:	3310      	adds	r3, #16
 801c7ac:	633b      	str	r3, [r7, #48]	; 0x30
            pos = 6 - ((x & 0x3) * 2);
 801c7ae:	897b      	ldrh	r3, [r7, #10]
 801c7b0:	43db      	mvns	r3, r3
 801c7b2:	b2db      	uxtb	r3, r3
 801c7b4:	f003 0303 	and.w	r3, r3, #3
 801c7b8:	b2db      	uxtb	r3, r3
 801c7ba:	005b      	lsls	r3, r3, #1
 801c7bc:	b2db      	uxtb	r3, r3
 801c7be:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
            break;
 801c7c2:	e04d      	b.n	801c860 <lv_img_decoder_built_in_line_indexed+0x1dc>
        case LV_IMG_CF_INDEXED_4BIT:
            w = (dsc->header.w >> 1); /*E.g. w = 13 -> w = 6 + 1 (bytes)*/
 801c7c4:	68fb      	ldr	r3, [r7, #12]
 801c7c6:	691b      	ldr	r3, [r3, #16]
 801c7c8:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801c7cc:	b29b      	uxth	r3, r3
 801c7ce:	105b      	asrs	r3, r3, #1
 801c7d0:	86fb      	strh	r3, [r7, #54]	; 0x36
            if(dsc->header.w & 0x1) w++;
 801c7d2:	68fb      	ldr	r3, [r7, #12]
 801c7d4:	691b      	ldr	r3, [r3, #16]
 801c7d6:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801c7da:	b29b      	uxth	r3, r3
 801c7dc:	f003 0301 	and.w	r3, r3, #1
 801c7e0:	2b00      	cmp	r3, #0
 801c7e2:	d005      	beq.n	801c7f0 <lv_img_decoder_built_in_line_indexed+0x16c>
 801c7e4:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 801c7e8:	b29b      	uxth	r3, r3
 801c7ea:	3301      	adds	r3, #1
 801c7ec:	b29b      	uxth	r3, r3
 801c7ee:	86fb      	strh	r3, [r7, #54]	; 0x36
            ofs += w * y + (x >> 1); /*First pixel*/
 801c7f0:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 801c7f4:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 801c7f8:	fb02 f303 	mul.w	r3, r2, r3
 801c7fc:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 801c800:	1052      	asrs	r2, r2, #1
 801c802:	b212      	sxth	r2, r2
 801c804:	4413      	add	r3, r2
 801c806:	461a      	mov	r2, r3
 801c808:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c80a:	4413      	add	r3, r2
 801c80c:	633b      	str	r3, [r7, #48]	; 0x30
            ofs += 64;               /*Skip the palette*/
 801c80e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c810:	3340      	adds	r3, #64	; 0x40
 801c812:	633b      	str	r3, [r7, #48]	; 0x30
            pos = 4 - ((x & 0x1) * 4);
 801c814:	897b      	ldrh	r3, [r7, #10]
 801c816:	f003 0301 	and.w	r3, r3, #1
 801c81a:	2b00      	cmp	r3, #0
 801c81c:	d101      	bne.n	801c822 <lv_img_decoder_built_in_line_indexed+0x19e>
 801c81e:	2304      	movs	r3, #4
 801c820:	e000      	b.n	801c824 <lv_img_decoder_built_in_line_indexed+0x1a0>
 801c822:	2300      	movs	r3, #0
 801c824:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
            break;
 801c828:	e01a      	b.n	801c860 <lv_img_decoder_built_in_line_indexed+0x1dc>
        case LV_IMG_CF_INDEXED_8BIT:
            w = dsc->header.w; /*E.g. x = 7 -> w = 7 (bytes)*/
 801c82a:	68fb      	ldr	r3, [r7, #12]
 801c82c:	691b      	ldr	r3, [r3, #16]
 801c82e:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801c832:	b29b      	uxth	r3, r3
 801c834:	86fb      	strh	r3, [r7, #54]	; 0x36
            ofs += w * y + x;  /*First pixel*/
 801c836:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 801c83a:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 801c83e:	fb02 f203 	mul.w	r2, r2, r3
 801c842:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 801c846:	4413      	add	r3, r2
 801c848:	461a      	mov	r2, r3
 801c84a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c84c:	4413      	add	r3, r2
 801c84e:	633b      	str	r3, [r7, #48]	; 0x30
            ofs += 1024;       /*Skip the palette*/
 801c850:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c852:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 801c856:	633b      	str	r3, [r7, #48]	; 0x30
            pos = 0;
 801c858:	2300      	movs	r3, #0
 801c85a:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
            break;
 801c85e:	bf00      	nop
    }

    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
 801c860:	68fb      	ldr	r3, [r7, #12]
 801c862:	6a1b      	ldr	r3, [r3, #32]
 801c864:	623b      	str	r3, [r7, #32]

#if LV_USE_FILESYSTEM
    uint8_t fs_buf[LV_HOR_RES_MAX];
#endif
    const uint8_t * data_tmp = NULL;
 801c866:	2300      	movs	r3, #0
 801c868:	62fb      	str	r3, [r7, #44]	; 0x2c
    if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
 801c86a:	68fb      	ldr	r3, [r7, #12]
 801c86c:	7b1b      	ldrb	r3, [r3, #12]
 801c86e:	2b00      	cmp	r3, #0
 801c870:	d10e      	bne.n	801c890 <lv_img_decoder_built_in_line_indexed+0x20c>
        const lv_img_dsc_t * img_dsc = dsc->src;
 801c872:	68fb      	ldr	r3, [r7, #12]
 801c874:	685b      	ldr	r3, [r3, #4]
 801c876:	61fb      	str	r3, [r7, #28]
        data_tmp                     = img_dsc->data + ofs;
 801c878:	69fb      	ldr	r3, [r7, #28]
 801c87a:	689a      	ldr	r2, [r3, #8]
 801c87c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801c87e:	4413      	add	r3, r2
 801c880:	62fb      	str	r3, [r7, #44]	; 0x2c
        data_tmp = NULL; /*To avoid warnings*/
        return LV_RES_INV;
#endif
    }

    uint8_t byte_act = 0;
 801c882:	2300      	movs	r3, #0
 801c884:	76fb      	strb	r3, [r7, #27]
    uint8_t val_act;
    lv_coord_t i;
    lv_color_t * cbuf = (lv_color_t *)buf;
 801c886:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801c888:	617b      	str	r3, [r7, #20]
    for(i = 0; i < len; i++) {
 801c88a:	2300      	movs	r3, #0
 801c88c:	857b      	strh	r3, [r7, #42]	; 0x2a
 801c88e:	e03c      	b.n	801c90a <lv_img_decoder_built_in_line_indexed+0x286>
        data_tmp = NULL; /*To avoid warnings*/
 801c890:	2300      	movs	r3, #0
 801c892:	62fb      	str	r3, [r7, #44]	; 0x2c
        return LV_RES_INV;
 801c894:	2300      	movs	r3, #0
 801c896:	e03f      	b.n	801c918 <lv_img_decoder_built_in_line_indexed+0x294>
        val_act = (data_tmp[byte_act] & (mask << pos)) >> pos;
 801c898:	7efb      	ldrb	r3, [r7, #27]
 801c89a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801c89c:	4413      	add	r3, r2
 801c89e:	781b      	ldrb	r3, [r3, #0]
 801c8a0:	4619      	mov	r1, r3
 801c8a2:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801c8a4:	f997 3035 	ldrsb.w	r3, [r7, #53]	; 0x35
 801c8a8:	fa02 f303 	lsl.w	r3, r2, r3
 801c8ac:	ea01 0203 	and.w	r2, r1, r3
 801c8b0:	f997 3035 	ldrsb.w	r3, [r7, #53]	; 0x35
 801c8b4:	fa42 f303 	asr.w	r3, r2, r3
 801c8b8:	74fb      	strb	r3, [r7, #19]
        cbuf[i] = user_data->palette[val_act];
 801c8ba:	6a3b      	ldr	r3, [r7, #32]
 801c8bc:	681a      	ldr	r2, [r3, #0]
 801c8be:	7cfb      	ldrb	r3, [r7, #19]
 801c8c0:	005b      	lsls	r3, r3, #1
 801c8c2:	441a      	add	r2, r3
 801c8c4:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 801c8c8:	005b      	lsls	r3, r3, #1
 801c8ca:	6979      	ldr	r1, [r7, #20]
 801c8cc:	440b      	add	r3, r1
 801c8ce:	8812      	ldrh	r2, [r2, #0]
 801c8d0:	801a      	strh	r2, [r3, #0]

        pos -= px_size;
 801c8d2:	f897 2035 	ldrb.w	r2, [r7, #53]	; 0x35
 801c8d6:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 801c8da:	1ad3      	subs	r3, r2, r3
 801c8dc:	b2db      	uxtb	r3, r3
 801c8de:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
        if(pos < 0) {
 801c8e2:	f997 3035 	ldrsb.w	r3, [r7, #53]	; 0x35
 801c8e6:	2b00      	cmp	r3, #0
 801c8e8:	da09      	bge.n	801c8fe <lv_img_decoder_built_in_line_indexed+0x27a>
            pos = 8 - px_size;
 801c8ea:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 801c8ee:	f1c3 0308 	rsb	r3, r3, #8
 801c8f2:	b2db      	uxtb	r3, r3
 801c8f4:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
            data_tmp++;
 801c8f8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801c8fa:	3301      	adds	r3, #1
 801c8fc:	62fb      	str	r3, [r7, #44]	; 0x2c
    for(i = 0; i < len; i++) {
 801c8fe:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 801c902:	b29b      	uxth	r3, r3
 801c904:	3301      	adds	r3, #1
 801c906:	b29b      	uxth	r3, r3
 801c908:	857b      	strh	r3, [r7, #42]	; 0x2a
 801c90a:	f9b7 202a 	ldrsh.w	r2, [r7, #42]	; 0x2a
 801c90e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801c912:	429a      	cmp	r2, r3
 801c914:	dbc0      	blt.n	801c898 <lv_img_decoder_built_in_line_indexed+0x214>
        }
    }

    return LV_RES_OK;
 801c916:	2301      	movs	r3, #1
#else
    LV_LOG_WARN("Image built-in indexed line reader failed because LV_IMG_CF_INDEXED is 0 in lv_conf.h");
    return LV_RES_INV;
#endif
}
 801c918:	4618      	mov	r0, r3
 801c91a:	3738      	adds	r7, #56	; 0x38
 801c91c:	46bd      	mov	sp, r7
 801c91e:	bd80      	pop	{r7, pc}

0801c920 <lv_font_get_glyph_bitmap>:
 * @param font_p pointer to a font
 * @param letter an UNICODE character code
 * @return  pointer to the bitmap of the letter
 */
const uint8_t * lv_font_get_glyph_bitmap(const lv_font_t * font_p, uint32_t letter)
{
 801c920:	b580      	push	{r7, lr}
 801c922:	b082      	sub	sp, #8
 801c924:	af00      	add	r7, sp, #0
 801c926:	6078      	str	r0, [r7, #4]
 801c928:	6039      	str	r1, [r7, #0]
    return font_p->get_glyph_bitmap(font_p, letter);
 801c92a:	687b      	ldr	r3, [r7, #4]
 801c92c:	685b      	ldr	r3, [r3, #4]
 801c92e:	6839      	ldr	r1, [r7, #0]
 801c930:	6878      	ldr	r0, [r7, #4]
 801c932:	4798      	blx	r3
 801c934:	4603      	mov	r3, r0
}
 801c936:	4618      	mov	r0, r3
 801c938:	3708      	adds	r7, #8
 801c93a:	46bd      	mov	sp, r7
 801c93c:	bd80      	pop	{r7, pc}

0801c93e <lv_font_get_glyph_dsc>:
 * @param letter an UNICODE letter code
 * @return true: descriptor is successfully loaded into `dsc_out`.
 *         false: the letter was not found, no data is loaded to `dsc_out`
 */
bool lv_font_get_glyph_dsc(const lv_font_t * font_p, lv_font_glyph_dsc_t * dsc_out, uint32_t letter, uint32_t letter_next)
{
 801c93e:	b590      	push	{r4, r7, lr}
 801c940:	b085      	sub	sp, #20
 801c942:	af00      	add	r7, sp, #0
 801c944:	60f8      	str	r0, [r7, #12]
 801c946:	60b9      	str	r1, [r7, #8]
 801c948:	607a      	str	r2, [r7, #4]
 801c94a:	603b      	str	r3, [r7, #0]
    return font_p->get_glyph_dsc(font_p, dsc_out, letter, letter_next);
 801c94c:	68fb      	ldr	r3, [r7, #12]
 801c94e:	681c      	ldr	r4, [r3, #0]
 801c950:	683b      	ldr	r3, [r7, #0]
 801c952:	687a      	ldr	r2, [r7, #4]
 801c954:	68b9      	ldr	r1, [r7, #8]
 801c956:	68f8      	ldr	r0, [r7, #12]
 801c958:	47a0      	blx	r4
 801c95a:	4603      	mov	r3, r0
}
 801c95c:	4618      	mov	r0, r3
 801c95e:	3714      	adds	r7, #20
 801c960:	46bd      	mov	sp, r7
 801c962:	bd90      	pop	{r4, r7, pc}

0801c964 <lv_font_get_glyph_width>:
 * @param letter an UNICODE letter
 * @param letter_next the next letter after `letter`. Used for kerning
 * @return the width of the glyph
 */
uint16_t lv_font_get_glyph_width(const lv_font_t * font, uint32_t letter, uint32_t letter_next)
{
 801c964:	b580      	push	{r7, lr}
 801c966:	b088      	sub	sp, #32
 801c968:	af00      	add	r7, sp, #0
 801c96a:	60f8      	str	r0, [r7, #12]
 801c96c:	60b9      	str	r1, [r7, #8]
 801c96e:	607a      	str	r2, [r7, #4]
    lv_font_glyph_dsc_t g;
    bool ret;
    ret = lv_font_get_glyph_dsc(font, &g, letter, letter_next);
 801c970:	f107 0114 	add.w	r1, r7, #20
 801c974:	687b      	ldr	r3, [r7, #4]
 801c976:	68ba      	ldr	r2, [r7, #8]
 801c978:	68f8      	ldr	r0, [r7, #12]
 801c97a:	f7ff ffe0 	bl	801c93e <lv_font_get_glyph_dsc>
 801c97e:	4603      	mov	r3, r0
 801c980:	77fb      	strb	r3, [r7, #31]
    if(ret) return g.adv_w;
 801c982:	7ffb      	ldrb	r3, [r7, #31]
 801c984:	2b00      	cmp	r3, #0
 801c986:	d001      	beq.n	801c98c <lv_font_get_glyph_width+0x28>
 801c988:	8abb      	ldrh	r3, [r7, #20]
 801c98a:	e000      	b.n	801c98e <lv_font_get_glyph_width+0x2a>
    else return 0;
 801c98c:	2300      	movs	r3, #0
}
 801c98e:	4618      	mov	r0, r3
 801c990:	3720      	adds	r7, #32
 801c992:	46bd      	mov	sp, r7
 801c994:	bd80      	pop	{r7, pc}

0801c996 <lv_font_get_bitmap_fmt_txt>:
 * @param font pointer to font
 * @param unicode_letter an unicode letter which bitmap should be get
 * @return pointer to the bitmap or NULL if not found
 */
const uint8_t * lv_font_get_bitmap_fmt_txt(const lv_font_t * font, uint32_t unicode_letter)
{
 801c996:	b580      	push	{r7, lr}
 801c998:	b086      	sub	sp, #24
 801c99a:	af00      	add	r7, sp, #0
 801c99c:	6078      	str	r0, [r7, #4]
 801c99e:	6039      	str	r1, [r7, #0]
    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
 801c9a0:	687b      	ldr	r3, [r7, #4]
 801c9a2:	68db      	ldr	r3, [r3, #12]
 801c9a4:	617b      	str	r3, [r7, #20]
    uint32_t gid = get_glyph_dsc_id(font, unicode_letter);
 801c9a6:	6839      	ldr	r1, [r7, #0]
 801c9a8:	6878      	ldr	r0, [r7, #4]
 801c9aa:	f000 f883 	bl	801cab4 <get_glyph_dsc_id>
 801c9ae:	6138      	str	r0, [r7, #16]
    if(!gid) return false;
 801c9b0:	693b      	ldr	r3, [r7, #16]
 801c9b2:	2b00      	cmp	r3, #0
 801c9b4:	d101      	bne.n	801c9ba <lv_font_get_bitmap_fmt_txt+0x24>
 801c9b6:	2300      	movs	r3, #0
 801c9b8:	e012      	b.n	801c9e0 <lv_font_get_bitmap_fmt_txt+0x4a>

    const lv_font_fmt_txt_glyph_dsc_t * gdsc = &fdsc->glyph_dsc[gid];
 801c9ba:	697b      	ldr	r3, [r7, #20]
 801c9bc:	6859      	ldr	r1, [r3, #4]
 801c9be:	693a      	ldr	r2, [r7, #16]
 801c9c0:	4613      	mov	r3, r2
 801c9c2:	005b      	lsls	r3, r3, #1
 801c9c4:	4413      	add	r3, r2
 801c9c6:	009b      	lsls	r3, r3, #2
 801c9c8:	440b      	add	r3, r1
 801c9ca:	60fb      	str	r3, [r7, #12]

    if(gdsc) return &fdsc->glyph_bitmap[gdsc->bitmap_index];
 801c9cc:	68fb      	ldr	r3, [r7, #12]
 801c9ce:	2b00      	cmp	r3, #0
 801c9d0:	d005      	beq.n	801c9de <lv_font_get_bitmap_fmt_txt+0x48>
 801c9d2:	697b      	ldr	r3, [r7, #20]
 801c9d4:	681a      	ldr	r2, [r3, #0]
 801c9d6:	68fb      	ldr	r3, [r7, #12]
 801c9d8:	681b      	ldr	r3, [r3, #0]
 801c9da:	4413      	add	r3, r2
 801c9dc:	e000      	b.n	801c9e0 <lv_font_get_bitmap_fmt_txt+0x4a>

    /*If not returned earlier then the letter is not found in this font*/
    return NULL;
 801c9de:	2300      	movs	r3, #0
}
 801c9e0:	4618      	mov	r0, r3
 801c9e2:	3718      	adds	r7, #24
 801c9e4:	46bd      	mov	sp, r7
 801c9e6:	bd80      	pop	{r7, pc}

0801c9e8 <lv_font_get_glyph_dsc_fmt_txt>:
 * @param letter an UNICODE letter code
 * @return true: descriptor is successfully loaded into `dsc_out`.
 *         false: the letter was not found, no data is loaded to `dsc_out`
 */
bool lv_font_get_glyph_dsc_fmt_txt(const lv_font_t * font, lv_font_glyph_dsc_t * dsc_out, uint32_t unicode_letter, uint32_t unicode_letter_next)
{
 801c9e8:	b580      	push	{r7, lr}
 801c9ea:	b08a      	sub	sp, #40	; 0x28
 801c9ec:	af00      	add	r7, sp, #0
 801c9ee:	60f8      	str	r0, [r7, #12]
 801c9f0:	60b9      	str	r1, [r7, #8]
 801c9f2:	607a      	str	r2, [r7, #4]
 801c9f4:	603b      	str	r3, [r7, #0]
    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
 801c9f6:	68fb      	ldr	r3, [r7, #12]
 801c9f8:	68db      	ldr	r3, [r3, #12]
 801c9fa:	623b      	str	r3, [r7, #32]
    uint32_t gid = get_glyph_dsc_id(font, unicode_letter);
 801c9fc:	6879      	ldr	r1, [r7, #4]
 801c9fe:	68f8      	ldr	r0, [r7, #12]
 801ca00:	f000 f858 	bl	801cab4 <get_glyph_dsc_id>
 801ca04:	61f8      	str	r0, [r7, #28]
    if(!gid) return false;
 801ca06:	69fb      	ldr	r3, [r7, #28]
 801ca08:	2b00      	cmp	r3, #0
 801ca0a:	d101      	bne.n	801ca10 <lv_font_get_glyph_dsc_fmt_txt+0x28>
 801ca0c:	2300      	movs	r3, #0
 801ca0e:	e04d      	b.n	801caac <lv_font_get_glyph_dsc_fmt_txt+0xc4>

    int8_t kvalue = 0;
 801ca10:	2300      	movs	r3, #0
 801ca12:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    if(fdsc->kern_dsc) {
 801ca16:	6a3b      	ldr	r3, [r7, #32]
 801ca18:	68db      	ldr	r3, [r3, #12]
 801ca1a:	2b00      	cmp	r3, #0
 801ca1c:	d00f      	beq.n	801ca3e <lv_font_get_glyph_dsc_fmt_txt+0x56>
        uint32_t gid_next = get_glyph_dsc_id(font, unicode_letter_next);
 801ca1e:	6839      	ldr	r1, [r7, #0]
 801ca20:	68f8      	ldr	r0, [r7, #12]
 801ca22:	f000 f847 	bl	801cab4 <get_glyph_dsc_id>
 801ca26:	61b8      	str	r0, [r7, #24]
        if(gid_next) {
 801ca28:	69bb      	ldr	r3, [r7, #24]
 801ca2a:	2b00      	cmp	r3, #0
 801ca2c:	d007      	beq.n	801ca3e <lv_font_get_glyph_dsc_fmt_txt+0x56>
            kvalue = get_kern_value(font, gid, gid_next);
 801ca2e:	69ba      	ldr	r2, [r7, #24]
 801ca30:	69f9      	ldr	r1, [r7, #28]
 801ca32:	68f8      	ldr	r0, [r7, #12]
 801ca34:	f000 f97a 	bl	801cd2c <get_kern_value>
 801ca38:	4603      	mov	r3, r0
 801ca3a:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
        }
    }

    /*Put together a glyph dsc*/
    const lv_font_fmt_txt_glyph_dsc_t * gdsc = &fdsc->glyph_dsc[gid];
 801ca3e:	6a3b      	ldr	r3, [r7, #32]
 801ca40:	6859      	ldr	r1, [r3, #4]
 801ca42:	69fa      	ldr	r2, [r7, #28]
 801ca44:	4613      	mov	r3, r2
 801ca46:	005b      	lsls	r3, r3, #1
 801ca48:	4413      	add	r3, r2
 801ca4a:	009b      	lsls	r3, r3, #2
 801ca4c:	440b      	add	r3, r1
 801ca4e:	617b      	str	r3, [r7, #20]

    uint32_t adv_w = gdsc->adv_w + ((int32_t)((int32_t)kvalue * fdsc->kern_scale) >> 4);
 801ca50:	697b      	ldr	r3, [r7, #20]
 801ca52:	685b      	ldr	r3, [r3, #4]
 801ca54:	f997 2027 	ldrsb.w	r2, [r7, #39]	; 0x27
 801ca58:	6a39      	ldr	r1, [r7, #32]
 801ca5a:	8a09      	ldrh	r1, [r1, #16]
 801ca5c:	fb01 f202 	mul.w	r2, r1, r2
 801ca60:	1112      	asrs	r2, r2, #4
 801ca62:	4413      	add	r3, r2
 801ca64:	613b      	str	r3, [r7, #16]
    adv_w  = (adv_w + (1 << 3)) >> 4;
 801ca66:	693b      	ldr	r3, [r7, #16]
 801ca68:	3308      	adds	r3, #8
 801ca6a:	091b      	lsrs	r3, r3, #4
 801ca6c:	613b      	str	r3, [r7, #16]

    dsc_out->adv_w = adv_w;
 801ca6e:	693b      	ldr	r3, [r7, #16]
 801ca70:	b29a      	uxth	r2, r3
 801ca72:	68bb      	ldr	r3, [r7, #8]
 801ca74:	801a      	strh	r2, [r3, #0]
    dsc_out->box_h = gdsc->box_h;
 801ca76:	697b      	ldr	r3, [r7, #20]
 801ca78:	7a5a      	ldrb	r2, [r3, #9]
 801ca7a:	68bb      	ldr	r3, [r7, #8]
 801ca7c:	70da      	strb	r2, [r3, #3]
    dsc_out->box_w = gdsc->box_w;
 801ca7e:	697b      	ldr	r3, [r7, #20]
 801ca80:	7a1a      	ldrb	r2, [r3, #8]
 801ca82:	68bb      	ldr	r3, [r7, #8]
 801ca84:	709a      	strb	r2, [r3, #2]
    dsc_out->ofs_x = gdsc->ofs_x;
 801ca86:	697b      	ldr	r3, [r7, #20]
 801ca88:	f993 200a 	ldrsb.w	r2, [r3, #10]
 801ca8c:	68bb      	ldr	r3, [r7, #8]
 801ca8e:	711a      	strb	r2, [r3, #4]
    dsc_out->ofs_y = gdsc->ofs_y;
 801ca90:	697b      	ldr	r3, [r7, #20]
 801ca92:	7adb      	ldrb	r3, [r3, #11]
 801ca94:	b25a      	sxtb	r2, r3
 801ca96:	68bb      	ldr	r3, [r7, #8]
 801ca98:	715a      	strb	r2, [r3, #5]
    dsc_out->bpp   = fdsc->bpp;
 801ca9a:	6a3b      	ldr	r3, [r7, #32]
 801ca9c:	7cdb      	ldrb	r3, [r3, #19]
 801ca9e:	f3c3 0382 	ubfx	r3, r3, #2, #3
 801caa2:	b2db      	uxtb	r3, r3
 801caa4:	461a      	mov	r2, r3
 801caa6:	68bb      	ldr	r3, [r7, #8]
 801caa8:	719a      	strb	r2, [r3, #6]

    return true;
 801caaa:	2301      	movs	r3, #1
}
 801caac:	4618      	mov	r0, r3
 801caae:	3728      	adds	r7, #40	; 0x28
 801cab0:	46bd      	mov	sp, r7
 801cab2:	bd80      	pop	{r7, pc}

0801cab4 <get_glyph_dsc_id>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static uint32_t get_glyph_dsc_id(const lv_font_t * font, uint32_t letter)
{
 801cab4:	b590      	push	{r4, r7, lr}
 801cab6:	b08f      	sub	sp, #60	; 0x3c
 801cab8:	af02      	add	r7, sp, #8
 801caba:	6078      	str	r0, [r7, #4]
 801cabc:	6039      	str	r1, [r7, #0]
    if(letter == '\0') return 0;
 801cabe:	683b      	ldr	r3, [r7, #0]
 801cac0:	2b00      	cmp	r3, #0
 801cac2:	d101      	bne.n	801cac8 <get_glyph_dsc_id+0x14>
 801cac4:	2300      	movs	r3, #0
 801cac6:	e12a      	b.n	801cd1e <get_glyph_dsc_id+0x26a>

    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
 801cac8:	687b      	ldr	r3, [r7, #4]
 801caca:	68db      	ldr	r3, [r3, #12]
 801cacc:	627b      	str	r3, [r7, #36]	; 0x24

    /*Check the cache first*/
    if(letter == fdsc->last_letter) return fdsc->last_glyph_id;
 801cace:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801cad0:	695b      	ldr	r3, [r3, #20]
 801cad2:	683a      	ldr	r2, [r7, #0]
 801cad4:	429a      	cmp	r2, r3
 801cad6:	d102      	bne.n	801cade <get_glyph_dsc_id+0x2a>
 801cad8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801cada:	699b      	ldr	r3, [r3, #24]
 801cadc:	e11f      	b.n	801cd1e <get_glyph_dsc_id+0x26a>

    uint16_t i;
    for(i = 0; i < fdsc->cmap_num; i++) {
 801cade:	2300      	movs	r3, #0
 801cae0:	85fb      	strh	r3, [r7, #46]	; 0x2e
 801cae2:	e10b      	b.n	801ccfc <get_glyph_dsc_id+0x248>

        /*Relative code point*/
        uint32_t rcp = letter - fdsc->cmaps[i].range_start;
 801cae4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801cae6:	6899      	ldr	r1, [r3, #8]
 801cae8:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801caea:	4613      	mov	r3, r2
 801caec:	009b      	lsls	r3, r3, #2
 801caee:	4413      	add	r3, r2
 801caf0:	009b      	lsls	r3, r3, #2
 801caf2:	440b      	add	r3, r1
 801caf4:	681b      	ldr	r3, [r3, #0]
 801caf6:	683a      	ldr	r2, [r7, #0]
 801caf8:	1ad3      	subs	r3, r2, r3
 801cafa:	60bb      	str	r3, [r7, #8]
        if(rcp > fdsc->cmaps[i].range_length) continue;
 801cafc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801cafe:	6899      	ldr	r1, [r3, #8]
 801cb00:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801cb02:	4613      	mov	r3, r2
 801cb04:	009b      	lsls	r3, r3, #2
 801cb06:	4413      	add	r3, r2
 801cb08:	009b      	lsls	r3, r3, #2
 801cb0a:	440b      	add	r3, r1
 801cb0c:	889b      	ldrh	r3, [r3, #4]
 801cb0e:	461a      	mov	r2, r3
 801cb10:	68bb      	ldr	r3, [r7, #8]
 801cb12:	429a      	cmp	r2, r3
 801cb14:	d203      	bcs.n	801cb1e <get_glyph_dsc_id+0x6a>
    for(i = 0; i < fdsc->cmap_num; i++) {
 801cb16:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 801cb18:	3301      	adds	r3, #1
 801cb1a:	85fb      	strh	r3, [r7, #46]	; 0x2e
 801cb1c:	e0ee      	b.n	801ccfc <get_glyph_dsc_id+0x248>
        uint32_t glyph_id = 0;
 801cb1e:	2300      	movs	r3, #0
 801cb20:	62bb      	str	r3, [r7, #40]	; 0x28
        if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_FORMAT0_TINY) {
 801cb22:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801cb24:	6899      	ldr	r1, [r3, #8]
 801cb26:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801cb28:	4613      	mov	r3, r2
 801cb2a:	009b      	lsls	r3, r3, #2
 801cb2c:	4413      	add	r3, r2
 801cb2e:	009b      	lsls	r3, r3, #2
 801cb30:	440b      	add	r3, r1
 801cb32:	7c9b      	ldrb	r3, [r3, #18]
 801cb34:	f003 0303 	and.w	r3, r3, #3
 801cb38:	b2db      	uxtb	r3, r3
 801cb3a:	2b00      	cmp	r3, #0
 801cb3c:	d10d      	bne.n	801cb5a <get_glyph_dsc_id+0xa6>
            glyph_id = fdsc->cmaps[i].glyph_id_start + rcp;
 801cb3e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801cb40:	6899      	ldr	r1, [r3, #8]
 801cb42:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801cb44:	4613      	mov	r3, r2
 801cb46:	009b      	lsls	r3, r3, #2
 801cb48:	4413      	add	r3, r2
 801cb4a:	009b      	lsls	r3, r3, #2
 801cb4c:	440b      	add	r3, r1
 801cb4e:	88db      	ldrh	r3, [r3, #6]
 801cb50:	461a      	mov	r2, r3
 801cb52:	68bb      	ldr	r3, [r7, #8]
 801cb54:	4413      	add	r3, r2
 801cb56:	62bb      	str	r3, [r7, #40]	; 0x28
 801cb58:	e0c8      	b.n	801ccec <get_glyph_dsc_id+0x238>
        }
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_FORMAT0_FULL) {
 801cb5a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801cb5c:	6899      	ldr	r1, [r3, #8]
 801cb5e:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801cb60:	4613      	mov	r3, r2
 801cb62:	009b      	lsls	r3, r3, #2
 801cb64:	4413      	add	r3, r2
 801cb66:	009b      	lsls	r3, r3, #2
 801cb68:	440b      	add	r3, r1
 801cb6a:	7c9b      	ldrb	r3, [r3, #18]
 801cb6c:	f003 0303 	and.w	r3, r3, #3
 801cb70:	b2db      	uxtb	r3, r3
 801cb72:	2b01      	cmp	r3, #1
 801cb74:	d11a      	bne.n	801cbac <get_glyph_dsc_id+0xf8>
            const uint8_t * gid_ofs_8 = fdsc->cmaps[i].glyph_id_ofs_list;
 801cb76:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801cb78:	6899      	ldr	r1, [r3, #8]
 801cb7a:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801cb7c:	4613      	mov	r3, r2
 801cb7e:	009b      	lsls	r3, r3, #2
 801cb80:	4413      	add	r3, r2
 801cb82:	009b      	lsls	r3, r3, #2
 801cb84:	440b      	add	r3, r1
 801cb86:	68db      	ldr	r3, [r3, #12]
 801cb88:	60fb      	str	r3, [r7, #12]
            glyph_id = fdsc->cmaps[i].glyph_id_start + gid_ofs_8[rcp];
 801cb8a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801cb8c:	6899      	ldr	r1, [r3, #8]
 801cb8e:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801cb90:	4613      	mov	r3, r2
 801cb92:	009b      	lsls	r3, r3, #2
 801cb94:	4413      	add	r3, r2
 801cb96:	009b      	lsls	r3, r3, #2
 801cb98:	440b      	add	r3, r1
 801cb9a:	88db      	ldrh	r3, [r3, #6]
 801cb9c:	4619      	mov	r1, r3
 801cb9e:	68bb      	ldr	r3, [r7, #8]
 801cba0:	68fa      	ldr	r2, [r7, #12]
 801cba2:	4413      	add	r3, r2
 801cba4:	781b      	ldrb	r3, [r3, #0]
 801cba6:	440b      	add	r3, r1
 801cba8:	62bb      	str	r3, [r7, #40]	; 0x28
 801cbaa:	e09f      	b.n	801ccec <get_glyph_dsc_id+0x238>
        }
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_SPARSE_TINY) {
 801cbac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801cbae:	6899      	ldr	r1, [r3, #8]
 801cbb0:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801cbb2:	4613      	mov	r3, r2
 801cbb4:	009b      	lsls	r3, r3, #2
 801cbb6:	4413      	add	r3, r2
 801cbb8:	009b      	lsls	r3, r3, #2
 801cbba:	440b      	add	r3, r1
 801cbbc:	7c9b      	ldrb	r3, [r3, #18]
 801cbbe:	f003 0303 	and.w	r3, r3, #3
 801cbc2:	b2db      	uxtb	r3, r3
 801cbc4:	2b02      	cmp	r3, #2
 801cbc6:	d13b      	bne.n	801cc40 <get_glyph_dsc_id+0x18c>
            uint8_t * p = lv_utils_bsearch(&rcp, fdsc->cmaps[i].unicode_list, fdsc->cmaps[i].list_length, sizeof(fdsc->cmaps[i].unicode_list[0]), unicode_list_compare);
 801cbc8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801cbca:	6899      	ldr	r1, [r3, #8]
 801cbcc:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801cbce:	4613      	mov	r3, r2
 801cbd0:	009b      	lsls	r3, r3, #2
 801cbd2:	4413      	add	r3, r2
 801cbd4:	009b      	lsls	r3, r3, #2
 801cbd6:	440b      	add	r3, r1
 801cbd8:	689c      	ldr	r4, [r3, #8]
 801cbda:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801cbdc:	6899      	ldr	r1, [r3, #8]
 801cbde:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801cbe0:	4613      	mov	r3, r2
 801cbe2:	009b      	lsls	r3, r3, #2
 801cbe4:	4413      	add	r3, r2
 801cbe6:	009b      	lsls	r3, r3, #2
 801cbe8:	440b      	add	r3, r1
 801cbea:	8a1b      	ldrh	r3, [r3, #16]
 801cbec:	461a      	mov	r2, r3
 801cbee:	f107 0008 	add.w	r0, r7, #8
 801cbf2:	4b4d      	ldr	r3, [pc, #308]	; (801cd28 <get_glyph_dsc_id+0x274>)
 801cbf4:	9300      	str	r3, [sp, #0]
 801cbf6:	2302      	movs	r3, #2
 801cbf8:	4621      	mov	r1, r4
 801cbfa:	f002 f9b9 	bl	801ef70 <lv_utils_bsearch>
 801cbfe:	6178      	str	r0, [r7, #20]

            if(p) {
 801cc00:	697b      	ldr	r3, [r7, #20]
 801cc02:	2b00      	cmp	r3, #0
 801cc04:	d072      	beq.n	801ccec <get_glyph_dsc_id+0x238>
                uint32_t ofs = (lv_uintptr_t)p - (lv_uintptr_t) fdsc->cmaps[i].unicode_list;
 801cc06:	6979      	ldr	r1, [r7, #20]
 801cc08:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801cc0a:	6898      	ldr	r0, [r3, #8]
 801cc0c:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801cc0e:	4613      	mov	r3, r2
 801cc10:	009b      	lsls	r3, r3, #2
 801cc12:	4413      	add	r3, r2
 801cc14:	009b      	lsls	r3, r3, #2
 801cc16:	4403      	add	r3, r0
 801cc18:	689b      	ldr	r3, [r3, #8]
 801cc1a:	1acb      	subs	r3, r1, r3
 801cc1c:	613b      	str	r3, [r7, #16]
                ofs = ofs >> 1;     /*The list stores `uint16_t` so the get the index divide by 2*/
 801cc1e:	693b      	ldr	r3, [r7, #16]
 801cc20:	085b      	lsrs	r3, r3, #1
 801cc22:	613b      	str	r3, [r7, #16]
                glyph_id = fdsc->cmaps[i].glyph_id_start + ofs;
 801cc24:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801cc26:	6899      	ldr	r1, [r3, #8]
 801cc28:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801cc2a:	4613      	mov	r3, r2
 801cc2c:	009b      	lsls	r3, r3, #2
 801cc2e:	4413      	add	r3, r2
 801cc30:	009b      	lsls	r3, r3, #2
 801cc32:	440b      	add	r3, r1
 801cc34:	88db      	ldrh	r3, [r3, #6]
 801cc36:	461a      	mov	r2, r3
 801cc38:	693b      	ldr	r3, [r7, #16]
 801cc3a:	4413      	add	r3, r2
 801cc3c:	62bb      	str	r3, [r7, #40]	; 0x28
 801cc3e:	e055      	b.n	801ccec <get_glyph_dsc_id+0x238>
            }
        }
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_SPARSE_FULL) {
 801cc40:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801cc42:	6899      	ldr	r1, [r3, #8]
 801cc44:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801cc46:	4613      	mov	r3, r2
 801cc48:	009b      	lsls	r3, r3, #2
 801cc4a:	4413      	add	r3, r2
 801cc4c:	009b      	lsls	r3, r3, #2
 801cc4e:	440b      	add	r3, r1
 801cc50:	7c9b      	ldrb	r3, [r3, #18]
 801cc52:	f003 0303 	and.w	r3, r3, #3
 801cc56:	b2db      	uxtb	r3, r3
 801cc58:	2b03      	cmp	r3, #3
 801cc5a:	d147      	bne.n	801ccec <get_glyph_dsc_id+0x238>
            uint8_t * p = lv_utils_bsearch(&rcp, fdsc->cmaps[i].unicode_list, fdsc->cmaps[i].list_length, sizeof(fdsc->cmaps[i].unicode_list[0]), unicode_list_compare);
 801cc5c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801cc5e:	6899      	ldr	r1, [r3, #8]
 801cc60:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801cc62:	4613      	mov	r3, r2
 801cc64:	009b      	lsls	r3, r3, #2
 801cc66:	4413      	add	r3, r2
 801cc68:	009b      	lsls	r3, r3, #2
 801cc6a:	440b      	add	r3, r1
 801cc6c:	689c      	ldr	r4, [r3, #8]
 801cc6e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801cc70:	6899      	ldr	r1, [r3, #8]
 801cc72:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801cc74:	4613      	mov	r3, r2
 801cc76:	009b      	lsls	r3, r3, #2
 801cc78:	4413      	add	r3, r2
 801cc7a:	009b      	lsls	r3, r3, #2
 801cc7c:	440b      	add	r3, r1
 801cc7e:	8a1b      	ldrh	r3, [r3, #16]
 801cc80:	461a      	mov	r2, r3
 801cc82:	f107 0008 	add.w	r0, r7, #8
 801cc86:	4b28      	ldr	r3, [pc, #160]	; (801cd28 <get_glyph_dsc_id+0x274>)
 801cc88:	9300      	str	r3, [sp, #0]
 801cc8a:	2302      	movs	r3, #2
 801cc8c:	4621      	mov	r1, r4
 801cc8e:	f002 f96f 	bl	801ef70 <lv_utils_bsearch>
 801cc92:	6238      	str	r0, [r7, #32]

            if(p) {
 801cc94:	6a3b      	ldr	r3, [r7, #32]
 801cc96:	2b00      	cmp	r3, #0
 801cc98:	d028      	beq.n	801ccec <get_glyph_dsc_id+0x238>
                uint32_t ofs = (lv_uintptr_t)p - (lv_uintptr_t) fdsc->cmaps[i].unicode_list;
 801cc9a:	6a39      	ldr	r1, [r7, #32]
 801cc9c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801cc9e:	6898      	ldr	r0, [r3, #8]
 801cca0:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801cca2:	4613      	mov	r3, r2
 801cca4:	009b      	lsls	r3, r3, #2
 801cca6:	4413      	add	r3, r2
 801cca8:	009b      	lsls	r3, r3, #2
 801ccaa:	4403      	add	r3, r0
 801ccac:	689b      	ldr	r3, [r3, #8]
 801ccae:	1acb      	subs	r3, r1, r3
 801ccb0:	61fb      	str	r3, [r7, #28]
                ofs = ofs >> 1;     /*The list stores `uint16_t` so the get the index divide by 2*/
 801ccb2:	69fb      	ldr	r3, [r7, #28]
 801ccb4:	085b      	lsrs	r3, r3, #1
 801ccb6:	61fb      	str	r3, [r7, #28]
                const uint8_t * gid_ofs_16 = fdsc->cmaps[i].glyph_id_ofs_list;
 801ccb8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ccba:	6899      	ldr	r1, [r3, #8]
 801ccbc:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801ccbe:	4613      	mov	r3, r2
 801ccc0:	009b      	lsls	r3, r3, #2
 801ccc2:	4413      	add	r3, r2
 801ccc4:	009b      	lsls	r3, r3, #2
 801ccc6:	440b      	add	r3, r1
 801ccc8:	68db      	ldr	r3, [r3, #12]
 801ccca:	61bb      	str	r3, [r7, #24]
                glyph_id = fdsc->cmaps[i].glyph_id_start + gid_ofs_16[ofs];
 801cccc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ccce:	6899      	ldr	r1, [r3, #8]
 801ccd0:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801ccd2:	4613      	mov	r3, r2
 801ccd4:	009b      	lsls	r3, r3, #2
 801ccd6:	4413      	add	r3, r2
 801ccd8:	009b      	lsls	r3, r3, #2
 801ccda:	440b      	add	r3, r1
 801ccdc:	88db      	ldrh	r3, [r3, #6]
 801ccde:	4619      	mov	r1, r3
 801cce0:	69ba      	ldr	r2, [r7, #24]
 801cce2:	69fb      	ldr	r3, [r7, #28]
 801cce4:	4413      	add	r3, r2
 801cce6:	781b      	ldrb	r3, [r3, #0]
 801cce8:	440b      	add	r3, r1
 801ccea:	62bb      	str	r3, [r7, #40]	; 0x28
            }
        }

        /*Update the cache*/
        fdsc->last_letter = letter;
 801ccec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ccee:	683a      	ldr	r2, [r7, #0]
 801ccf0:	615a      	str	r2, [r3, #20]
        fdsc->last_glyph_id = glyph_id;
 801ccf2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ccf4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801ccf6:	619a      	str	r2, [r3, #24]
        return glyph_id;
 801ccf8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801ccfa:	e010      	b.n	801cd1e <get_glyph_dsc_id+0x26a>
    for(i = 0; i < fdsc->cmap_num; i++) {
 801ccfc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ccfe:	8a5b      	ldrh	r3, [r3, #18]
 801cd00:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801cd04:	b29b      	uxth	r3, r3
 801cd06:	461a      	mov	r2, r3
 801cd08:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 801cd0a:	4293      	cmp	r3, r2
 801cd0c:	f4ff aeea 	bcc.w	801cae4 <get_glyph_dsc_id+0x30>
    }

    fdsc->last_letter = letter;
 801cd10:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801cd12:	683a      	ldr	r2, [r7, #0]
 801cd14:	615a      	str	r2, [r3, #20]
    fdsc->last_glyph_id = 0;
 801cd16:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801cd18:	2200      	movs	r2, #0
 801cd1a:	619a      	str	r2, [r3, #24]
    return 0;
 801cd1c:	2300      	movs	r3, #0

}
 801cd1e:	4618      	mov	r0, r3
 801cd20:	3734      	adds	r7, #52	; 0x34
 801cd22:	46bd      	mov	sp, r7
 801cd24:	bd90      	pop	{r4, r7, pc}
 801cd26:	bf00      	nop
 801cd28:	0801cf15 	.word	0x0801cf15

0801cd2c <get_kern_value>:

static int8_t get_kern_value(const lv_font_t * font, uint32_t gid_left, uint32_t gid_right)
{
 801cd2c:	b580      	push	{r7, lr}
 801cd2e:	b094      	sub	sp, #80	; 0x50
 801cd30:	af02      	add	r7, sp, #8
 801cd32:	60f8      	str	r0, [r7, #12]
 801cd34:	60b9      	str	r1, [r7, #8]
 801cd36:	607a      	str	r2, [r7, #4]
    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
 801cd38:	68fb      	ldr	r3, [r7, #12]
 801cd3a:	68db      	ldr	r3, [r3, #12]
 801cd3c:	643b      	str	r3, [r7, #64]	; 0x40

    int8_t value = 0;
 801cd3e:	2300      	movs	r3, #0
 801cd40:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47

    if(fdsc->kern_classes == 0) {
 801cd44:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801cd46:	7cdb      	ldrb	r3, [r3, #19]
 801cd48:	f003 0320 	and.w	r3, r3, #32
 801cd4c:	b2db      	uxtb	r3, r3
 801cd4e:	2b00      	cmp	r3, #0
 801cd50:	d164      	bne.n	801ce1c <get_kern_value+0xf0>
        /*Kern pairs*/
        const lv_font_fmt_txt_kern_pair_t * kdsc = fdsc->kern_dsc;
 801cd52:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801cd54:	68db      	ldr	r3, [r3, #12]
 801cd56:	637b      	str	r3, [r7, #52]	; 0x34
        if(kdsc->glyph_ids_size == 0) {
 801cd58:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cd5a:	7adb      	ldrb	r3, [r3, #11]
 801cd5c:	f003 0303 	and.w	r3, r3, #3
 801cd60:	b2db      	uxtb	r3, r3
 801cd62:	2b00      	cmp	r3, #0
 801cd64:	d12b      	bne.n	801cdbe <get_kern_value+0x92>
            /* Use binary search to find the kern value.
             * The pairs are ordered left_id first, then right_id secondly. */
            const uint8_t * g_ids = kdsc->glyph_ids;
 801cd66:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cd68:	681b      	ldr	r3, [r3, #0]
 801cd6a:	627b      	str	r3, [r7, #36]	; 0x24
            uint16_t g_id_both = (gid_right << 8) + gid_left; /*Create one number from the ids*/
 801cd6c:	687b      	ldr	r3, [r7, #4]
 801cd6e:	b29b      	uxth	r3, r3
 801cd70:	021b      	lsls	r3, r3, #8
 801cd72:	b29a      	uxth	r2, r3
 801cd74:	68bb      	ldr	r3, [r7, #8]
 801cd76:	b29b      	uxth	r3, r3
 801cd78:	4413      	add	r3, r2
 801cd7a:	b29b      	uxth	r3, r3
 801cd7c:	837b      	strh	r3, [r7, #26]
            uint8_t * kid_p = lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 2, kern_pair_8_compare);
 801cd7e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cd80:	689b      	ldr	r3, [r3, #8]
 801cd82:	f3c3 0317 	ubfx	r3, r3, #0, #24
 801cd86:	461a      	mov	r2, r3
 801cd88:	f107 001a 	add.w	r0, r7, #26
 801cd8c:	4b3b      	ldr	r3, [pc, #236]	; (801ce7c <get_kern_value+0x150>)
 801cd8e:	9300      	str	r3, [sp, #0]
 801cd90:	2302      	movs	r3, #2
 801cd92:	6a79      	ldr	r1, [r7, #36]	; 0x24
 801cd94:	f002 f8ec 	bl	801ef70 <lv_utils_bsearch>
 801cd98:	6238      	str	r0, [r7, #32]

            /*If the `g_id_both` were found get its index from the pointer*/
            if(kid_p) {
 801cd9a:	6a3b      	ldr	r3, [r7, #32]
 801cd9c:	2b00      	cmp	r3, #0
 801cd9e:	d067      	beq.n	801ce70 <get_kern_value+0x144>
                uint32_t ofs = (lv_uintptr_t)kid_p - (lv_uintptr_t)g_ids;
 801cda0:	6a3a      	ldr	r2, [r7, #32]
 801cda2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801cda4:	1ad3      	subs	r3, r2, r3
 801cda6:	61fb      	str	r3, [r7, #28]
                ofs = ofs >> 1;     /*ofs is for pair, divide by 2 to refer as a single value*/
 801cda8:	69fb      	ldr	r3, [r7, #28]
 801cdaa:	085b      	lsrs	r3, r3, #1
 801cdac:	61fb      	str	r3, [r7, #28]
                value = kdsc->values[ofs];
 801cdae:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cdb0:	685a      	ldr	r2, [r3, #4]
 801cdb2:	69fb      	ldr	r3, [r7, #28]
 801cdb4:	4413      	add	r3, r2
 801cdb6:	781b      	ldrb	r3, [r3, #0]
 801cdb8:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
 801cdbc:	e058      	b.n	801ce70 <get_kern_value+0x144>
            }
        } else if(kdsc->glyph_ids_size == 1) {
 801cdbe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cdc0:	7adb      	ldrb	r3, [r3, #11]
 801cdc2:	f003 0303 	and.w	r3, r3, #3
 801cdc6:	b2db      	uxtb	r3, r3
 801cdc8:	2b01      	cmp	r3, #1
 801cdca:	d151      	bne.n	801ce70 <get_kern_value+0x144>
            /* Use binary search to find the kern value.
             * The pairs are ordered left_id first, then right_id secondly. */
            const uint16_t * g_ids = kdsc->glyph_ids;
 801cdcc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cdce:	681b      	ldr	r3, [r3, #0]
 801cdd0:	633b      	str	r3, [r7, #48]	; 0x30
            uint32_t g_id_both = (uint32_t)((uint32_t)gid_right << 8) + gid_left; /*Create one number from the ids*/
 801cdd2:	687b      	ldr	r3, [r7, #4]
 801cdd4:	021a      	lsls	r2, r3, #8
 801cdd6:	68bb      	ldr	r3, [r7, #8]
 801cdd8:	4413      	add	r3, r2
 801cdda:	617b      	str	r3, [r7, #20]
            uint8_t * kid_p = lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 4, kern_pair_16_compare);
 801cddc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801cdde:	689b      	ldr	r3, [r3, #8]
 801cde0:	f3c3 0317 	ubfx	r3, r3, #0, #24
 801cde4:	461a      	mov	r2, r3
 801cde6:	f107 0014 	add.w	r0, r7, #20
 801cdea:	4b25      	ldr	r3, [pc, #148]	; (801ce80 <get_kern_value+0x154>)
 801cdec:	9300      	str	r3, [sp, #0]
 801cdee:	2304      	movs	r3, #4
 801cdf0:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801cdf2:	f002 f8bd 	bl	801ef70 <lv_utils_bsearch>
 801cdf6:	62f8      	str	r0, [r7, #44]	; 0x2c

            /*If the `g_id_both` were found get its index from the pointer*/
            if(kid_p) {
 801cdf8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801cdfa:	2b00      	cmp	r3, #0
 801cdfc:	d038      	beq.n	801ce70 <get_kern_value+0x144>
                uint32_t ofs = (lv_uintptr_t)kid_p - (lv_uintptr_t)g_ids;
 801cdfe:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801ce00:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ce02:	1ad3      	subs	r3, r2, r3
 801ce04:	62bb      	str	r3, [r7, #40]	; 0x28
                ofs = ofs >> 4;     /*ofs is 4 byte pairs, divide by 4 to refer as a single value*/
 801ce06:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801ce08:	091b      	lsrs	r3, r3, #4
 801ce0a:	62bb      	str	r3, [r7, #40]	; 0x28
                value = kdsc->values[ofs];
 801ce0c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801ce0e:	685a      	ldr	r2, [r3, #4]
 801ce10:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801ce12:	4413      	add	r3, r2
 801ce14:	781b      	ldrb	r3, [r3, #0]
 801ce16:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
 801ce1a:	e029      	b.n	801ce70 <get_kern_value+0x144>
        } else {
            /*Invalid value*/
        }
    } else {
        /*Kern classes*/
        const lv_font_fmt_txt_kern_classes_t * kdsc = fdsc->kern_dsc;
 801ce1c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801ce1e:	68db      	ldr	r3, [r3, #12]
 801ce20:	63fb      	str	r3, [r7, #60]	; 0x3c
        uint8_t left_class = kdsc->left_class_mapping[gid_left];
 801ce22:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801ce24:	685a      	ldr	r2, [r3, #4]
 801ce26:	68bb      	ldr	r3, [r7, #8]
 801ce28:	4413      	add	r3, r2
 801ce2a:	781b      	ldrb	r3, [r3, #0]
 801ce2c:	f887 303b 	strb.w	r3, [r7, #59]	; 0x3b
        uint8_t right_class = kdsc->left_class_mapping[gid_right];
 801ce30:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801ce32:	685a      	ldr	r2, [r3, #4]
 801ce34:	687b      	ldr	r3, [r7, #4]
 801ce36:	4413      	add	r3, r2
 801ce38:	781b      	ldrb	r3, [r3, #0]
 801ce3a:	f887 303a 	strb.w	r3, [r7, #58]	; 0x3a

        /* If class = 0, kerning not exist for that glyph
         * else got the value form `class_pair_values` 2D array*/
        if(left_class > 0 && right_class > 0) {
 801ce3e:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
 801ce42:	2b00      	cmp	r3, #0
 801ce44:	d014      	beq.n	801ce70 <get_kern_value+0x144>
 801ce46:	f897 303a 	ldrb.w	r3, [r7, #58]	; 0x3a
 801ce4a:	2b00      	cmp	r3, #0
 801ce4c:	d010      	beq.n	801ce70 <get_kern_value+0x144>
            value = kdsc->class_pair_values[(left_class-1)* kdsc->right_class_cnt + (right_class-1)];
 801ce4e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801ce50:	681b      	ldr	r3, [r3, #0]
 801ce52:	f897 203b 	ldrb.w	r2, [r7, #59]	; 0x3b
 801ce56:	3a01      	subs	r2, #1
 801ce58:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 801ce5a:	7b49      	ldrb	r1, [r1, #13]
 801ce5c:	fb01 f102 	mul.w	r1, r1, r2
 801ce60:	f897 203a 	ldrb.w	r2, [r7, #58]	; 0x3a
 801ce64:	3a01      	subs	r2, #1
 801ce66:	440a      	add	r2, r1
 801ce68:	4413      	add	r3, r2
 801ce6a:	781b      	ldrb	r3, [r3, #0]
 801ce6c:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
        }

    }
    return value;
 801ce70:	f997 3047 	ldrsb.w	r3, [r7, #71]	; 0x47
}
 801ce74:	4618      	mov	r0, r3
 801ce76:	3748      	adds	r7, #72	; 0x48
 801ce78:	46bd      	mov	sp, r7
 801ce7a:	bd80      	pop	{r7, pc}
 801ce7c:	0801ce85 	.word	0x0801ce85
 801ce80:	0801cecd 	.word	0x0801cecd

0801ce84 <kern_pair_8_compare>:

static int32_t kern_pair_8_compare(const void * ref, const void * element)
{
 801ce84:	b480      	push	{r7}
 801ce86:	b085      	sub	sp, #20
 801ce88:	af00      	add	r7, sp, #0
 801ce8a:	6078      	str	r0, [r7, #4]
 801ce8c:	6039      	str	r1, [r7, #0]
    const uint8_t * ref8_p = ref;
 801ce8e:	687b      	ldr	r3, [r7, #4]
 801ce90:	60fb      	str	r3, [r7, #12]
    const uint8_t * element8_p = element;
 801ce92:	683b      	ldr	r3, [r7, #0]
 801ce94:	60bb      	str	r3, [r7, #8]

    /*If the MSB is different it will matter. If not return the diff. of the LSB*/
    if(ref8_p[0] != element8_p[0]) return (int32_t)ref8_p[0] - element8_p[0];
 801ce96:	68fb      	ldr	r3, [r7, #12]
 801ce98:	781a      	ldrb	r2, [r3, #0]
 801ce9a:	68bb      	ldr	r3, [r7, #8]
 801ce9c:	781b      	ldrb	r3, [r3, #0]
 801ce9e:	429a      	cmp	r2, r3
 801cea0:	d006      	beq.n	801ceb0 <kern_pair_8_compare+0x2c>
 801cea2:	68fb      	ldr	r3, [r7, #12]
 801cea4:	781b      	ldrb	r3, [r3, #0]
 801cea6:	461a      	mov	r2, r3
 801cea8:	68bb      	ldr	r3, [r7, #8]
 801ceaa:	781b      	ldrb	r3, [r3, #0]
 801ceac:	1ad3      	subs	r3, r2, r3
 801ceae:	e007      	b.n	801cec0 <kern_pair_8_compare+0x3c>
    else return (int32_t) ref8_p[1] - element8_p[1];
 801ceb0:	68fb      	ldr	r3, [r7, #12]
 801ceb2:	3301      	adds	r3, #1
 801ceb4:	781b      	ldrb	r3, [r3, #0]
 801ceb6:	461a      	mov	r2, r3
 801ceb8:	68bb      	ldr	r3, [r7, #8]
 801ceba:	3301      	adds	r3, #1
 801cebc:	781b      	ldrb	r3, [r3, #0]
 801cebe:	1ad3      	subs	r3, r2, r3

}
 801cec0:	4618      	mov	r0, r3
 801cec2:	3714      	adds	r7, #20
 801cec4:	46bd      	mov	sp, r7
 801cec6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ceca:	4770      	bx	lr

0801cecc <kern_pair_16_compare>:

static int32_t kern_pair_16_compare(const void * ref, const void * element)
{
 801cecc:	b480      	push	{r7}
 801cece:	b085      	sub	sp, #20
 801ced0:	af00      	add	r7, sp, #0
 801ced2:	6078      	str	r0, [r7, #4]
 801ced4:	6039      	str	r1, [r7, #0]
    const uint16_t * ref16_p = ref;
 801ced6:	687b      	ldr	r3, [r7, #4]
 801ced8:	60fb      	str	r3, [r7, #12]
    const uint16_t * element16_p = element;
 801ceda:	683b      	ldr	r3, [r7, #0]
 801cedc:	60bb      	str	r3, [r7, #8]

    /*If the MSB is different it will matter. If not return the diff. of the LSB*/
    if(ref16_p[0] != element16_p[0]) return (int32_t)ref16_p[0] - element16_p[0];
 801cede:	68fb      	ldr	r3, [r7, #12]
 801cee0:	881a      	ldrh	r2, [r3, #0]
 801cee2:	68bb      	ldr	r3, [r7, #8]
 801cee4:	881b      	ldrh	r3, [r3, #0]
 801cee6:	429a      	cmp	r2, r3
 801cee8:	d006      	beq.n	801cef8 <kern_pair_16_compare+0x2c>
 801ceea:	68fb      	ldr	r3, [r7, #12]
 801ceec:	881b      	ldrh	r3, [r3, #0]
 801ceee:	461a      	mov	r2, r3
 801cef0:	68bb      	ldr	r3, [r7, #8]
 801cef2:	881b      	ldrh	r3, [r3, #0]
 801cef4:	1ad3      	subs	r3, r2, r3
 801cef6:	e007      	b.n	801cf08 <kern_pair_16_compare+0x3c>
    else return (int32_t) ref16_p[1] - element16_p[1];
 801cef8:	68fb      	ldr	r3, [r7, #12]
 801cefa:	3302      	adds	r3, #2
 801cefc:	881b      	ldrh	r3, [r3, #0]
 801cefe:	461a      	mov	r2, r3
 801cf00:	68bb      	ldr	r3, [r7, #8]
 801cf02:	3302      	adds	r3, #2
 801cf04:	881b      	ldrh	r3, [r3, #0]
 801cf06:	1ad3      	subs	r3, r2, r3
}
 801cf08:	4618      	mov	r0, r3
 801cf0a:	3714      	adds	r7, #20
 801cf0c:	46bd      	mov	sp, r7
 801cf0e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cf12:	4770      	bx	lr

0801cf14 <unicode_list_compare>:
 *  @retval = 0   Reference is equal to element.
 *  @retval > 0   Reference is less than element.
 *
 */
static int32_t unicode_list_compare(const void * ref, const void * element)
{
 801cf14:	b480      	push	{r7}
 801cf16:	b083      	sub	sp, #12
 801cf18:	af00      	add	r7, sp, #0
 801cf1a:	6078      	str	r0, [r7, #4]
 801cf1c:	6039      	str	r1, [r7, #0]
    return (*(uint16_t *)ref) - (*(uint16_t *)element);
 801cf1e:	687b      	ldr	r3, [r7, #4]
 801cf20:	881b      	ldrh	r3, [r3, #0]
 801cf22:	461a      	mov	r2, r3
 801cf24:	683b      	ldr	r3, [r7, #0]
 801cf26:	881b      	ldrh	r3, [r3, #0]
 801cf28:	1ad3      	subs	r3, r2, r3
}
 801cf2a:	4618      	mov	r0, r3
 801cf2c:	370c      	adds	r7, #12
 801cf2e:	46bd      	mov	sp, r7
 801cf30:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cf34:	4770      	bx	lr

0801cf36 <lv_disp_drv_init>:
 * It is used to surly have known values in the fields ant not memory junk.
 * After it you can set the fields.
 * @param driver pointer to driver variable to initialize
 */
void lv_disp_drv_init(lv_disp_drv_t * driver)
{
 801cf36:	b580      	push	{r7, lr}
 801cf38:	b082      	sub	sp, #8
 801cf3a:	af00      	add	r7, sp, #0
 801cf3c:	6078      	str	r0, [r7, #4]
    memset(driver, 0, sizeof(lv_disp_drv_t));
 801cf3e:	2220      	movs	r2, #32
 801cf40:	2100      	movs	r1, #0
 801cf42:	6878      	ldr	r0, [r7, #4]
 801cf44:	f004 fe96 	bl	8021c74 <memset>

    driver->flush_cb         = NULL;
 801cf48:	687b      	ldr	r3, [r7, #4]
 801cf4a:	2200      	movs	r2, #0
 801cf4c:	60da      	str	r2, [r3, #12]
    driver->hor_res          = LV_HOR_RES_MAX;
 801cf4e:	687b      	ldr	r3, [r7, #4]
 801cf50:	f44f 7280 	mov.w	r2, #256	; 0x100
 801cf54:	801a      	strh	r2, [r3, #0]
    driver->ver_res          = LV_VER_RES_MAX;
 801cf56:	687b      	ldr	r3, [r7, #4]
 801cf58:	2240      	movs	r2, #64	; 0x40
 801cf5a:	805a      	strh	r2, [r3, #2]
    driver->buffer           = NULL;
 801cf5c:	687b      	ldr	r3, [r7, #4]
 801cf5e:	2200      	movs	r2, #0
 801cf60:	605a      	str	r2, [r3, #4]
    driver->rotated          = 0;
 801cf62:	687a      	ldr	r2, [r7, #4]
 801cf64:	7a13      	ldrb	r3, [r2, #8]
 801cf66:	f36f 0341 	bfc	r3, #1, #1
 801cf6a:	7213      	strb	r3, [r2, #8]
    driver->color_chroma_key = LV_COLOR_TRANSP;
 801cf6c:	687a      	ldr	r2, [r7, #4]
 801cf6e:	7f13      	ldrb	r3, [r2, #28]
 801cf70:	f36f 0304 	bfc	r3, #0, #5
 801cf74:	7713      	strb	r3, [r2, #28]
 801cf76:	687a      	ldr	r2, [r7, #4]
 801cf78:	8b93      	ldrh	r3, [r2, #28]
 801cf7a:	f443 63fc 	orr.w	r3, r3, #2016	; 0x7e0
 801cf7e:	8393      	strh	r3, [r2, #28]
 801cf80:	687a      	ldr	r2, [r7, #4]
 801cf82:	7f53      	ldrb	r3, [r2, #29]
 801cf84:	f36f 03c7 	bfc	r3, #3, #5
 801cf88:	7753      	strb	r3, [r2, #29]

#if LV_ANTIALIAS
    driver->antialiasing = true;
 801cf8a:	687a      	ldr	r2, [r7, #4]
 801cf8c:	7a13      	ldrb	r3, [r2, #8]
 801cf8e:	f043 0301 	orr.w	r3, r3, #1
 801cf92:	7213      	strb	r3, [r2, #8]

#if LV_USE_USER_DATA
    driver->user_data = NULL;
#endif

    driver->set_px_cb = NULL;
 801cf94:	687b      	ldr	r3, [r7, #4]
 801cf96:	2200      	movs	r2, #0
 801cf98:	615a      	str	r2, [r3, #20]
}
 801cf9a:	bf00      	nop
 801cf9c:	3708      	adds	r7, #8
 801cf9e:	46bd      	mov	sp, r7
 801cfa0:	bd80      	pop	{r7, pc}

0801cfa2 <lv_disp_buf_init>:
 *             It lets LittlevGL to render next frame into the other buffer while previous is being
 * sent. Set to `NULL` if unused.
 * @param size_in_px_cnt size of the `buf1` and `buf2` in pixel count.
 */
void lv_disp_buf_init(lv_disp_buf_t * disp_buf, void * buf1, void * buf2, uint32_t size_in_px_cnt)
{
 801cfa2:	b580      	push	{r7, lr}
 801cfa4:	b084      	sub	sp, #16
 801cfa6:	af00      	add	r7, sp, #0
 801cfa8:	60f8      	str	r0, [r7, #12]
 801cfaa:	60b9      	str	r1, [r7, #8]
 801cfac:	607a      	str	r2, [r7, #4]
 801cfae:	603b      	str	r3, [r7, #0]
    memset(disp_buf, 0, sizeof(lv_disp_buf_t));
 801cfb0:	221c      	movs	r2, #28
 801cfb2:	2100      	movs	r1, #0
 801cfb4:	68f8      	ldr	r0, [r7, #12]
 801cfb6:	f004 fe5d 	bl	8021c74 <memset>

    disp_buf->buf1    = buf1;
 801cfba:	68fb      	ldr	r3, [r7, #12]
 801cfbc:	68ba      	ldr	r2, [r7, #8]
 801cfbe:	601a      	str	r2, [r3, #0]
    disp_buf->buf2    = buf2;
 801cfc0:	68fb      	ldr	r3, [r7, #12]
 801cfc2:	687a      	ldr	r2, [r7, #4]
 801cfc4:	605a      	str	r2, [r3, #4]
    disp_buf->buf_act = disp_buf->buf1;
 801cfc6:	68fb      	ldr	r3, [r7, #12]
 801cfc8:	681a      	ldr	r2, [r3, #0]
 801cfca:	68fb      	ldr	r3, [r7, #12]
 801cfcc:	609a      	str	r2, [r3, #8]
    disp_buf->size    = size_in_px_cnt;
 801cfce:	68fb      	ldr	r3, [r7, #12]
 801cfd0:	683a      	ldr	r2, [r7, #0]
 801cfd2:	60da      	str	r2, [r3, #12]
}
 801cfd4:	bf00      	nop
 801cfd6:	3710      	adds	r7, #16
 801cfd8:	46bd      	mov	sp, r7
 801cfda:	bd80      	pop	{r7, pc}

0801cfdc <lv_disp_drv_register>:
 * Automatically set the first display as active.
 * @param driver pointer to an initialized 'lv_disp_drv_t' variable (can be local variable)
 * @return pointer to the new display or NULL on error
 */
lv_disp_t * lv_disp_drv_register(lv_disp_drv_t * driver)
{
 801cfdc:	b580      	push	{r7, lr}
 801cfde:	b084      	sub	sp, #16
 801cfe0:	af00      	add	r7, sp, #0
 801cfe2:	6078      	str	r0, [r7, #4]
    lv_disp_t * disp = lv_ll_ins_head(&LV_GC_ROOT(_lv_disp_ll));
 801cfe4:	4841      	ldr	r0, [pc, #260]	; (801d0ec <lv_disp_drv_register+0x110>)
 801cfe6:	f000 fd9b 	bl	801db20 <lv_ll_ins_head>
 801cfea:	60f8      	str	r0, [r7, #12]
    if(!disp) {
 801cfec:	68fb      	ldr	r3, [r7, #12]
 801cfee:	2b00      	cmp	r3, #0
 801cff0:	d105      	bne.n	801cffe <lv_disp_drv_register+0x22>
        lv_mem_assert(disp);
 801cff2:	68fb      	ldr	r3, [r7, #12]
 801cff4:	2b00      	cmp	r3, #0
 801cff6:	d100      	bne.n	801cffa <lv_disp_drv_register+0x1e>
 801cff8:	e7fe      	b.n	801cff8 <lv_disp_drv_register+0x1c>
        return NULL;
 801cffa:	2300      	movs	r3, #0
 801cffc:	e072      	b.n	801d0e4 <lv_disp_drv_register+0x108>
    }

    memcpy(&disp->driver, driver, sizeof(lv_disp_drv_t));
 801cffe:	68fb      	ldr	r3, [r7, #12]
 801d000:	2220      	movs	r2, #32
 801d002:	6879      	ldr	r1, [r7, #4]
 801d004:	4618      	mov	r0, r3
 801d006:	f004 fe27 	bl	8021c58 <memcpy>
    memset(&disp->inv_area_joined, 0, sizeof(disp->inv_area_joined));
 801d00a:	68fb      	ldr	r3, [r7, #12]
 801d00c:	f503 739e 	add.w	r3, r3, #316	; 0x13c
 801d010:	2220      	movs	r2, #32
 801d012:	2100      	movs	r1, #0
 801d014:	4618      	mov	r0, r3
 801d016:	f004 fe2d 	bl	8021c74 <memset>
    memset(&disp->inv_areas, 0, sizeof(disp->inv_areas));
 801d01a:	68fb      	ldr	r3, [r7, #12]
 801d01c:	333c      	adds	r3, #60	; 0x3c
 801d01e:	f44f 7280 	mov.w	r2, #256	; 0x100
 801d022:	2100      	movs	r1, #0
 801d024:	4618      	mov	r0, r3
 801d026:	f004 fe25 	bl	8021c74 <memset>
    lv_ll_init(&disp->scr_ll, sizeof(lv_obj_t));
 801d02a:	68fb      	ldr	r3, [r7, #12]
 801d02c:	3324      	adds	r3, #36	; 0x24
 801d02e:	2144      	movs	r1, #68	; 0x44
 801d030:	4618      	mov	r0, r3
 801d032:	f000 fd55 	bl	801dae0 <lv_ll_init>

    if(disp_def == NULL) disp_def = disp;
 801d036:	4b2e      	ldr	r3, [pc, #184]	; (801d0f0 <lv_disp_drv_register+0x114>)
 801d038:	681b      	ldr	r3, [r3, #0]
 801d03a:	2b00      	cmp	r3, #0
 801d03c:	d102      	bne.n	801d044 <lv_disp_drv_register+0x68>
 801d03e:	4a2c      	ldr	r2, [pc, #176]	; (801d0f0 <lv_disp_drv_register+0x114>)
 801d040:	68fb      	ldr	r3, [r7, #12]
 801d042:	6013      	str	r3, [r2, #0]

    lv_disp_t * disp_def_tmp = disp_def;
 801d044:	4b2a      	ldr	r3, [pc, #168]	; (801d0f0 <lv_disp_drv_register+0x114>)
 801d046:	681b      	ldr	r3, [r3, #0]
 801d048:	60bb      	str	r3, [r7, #8]
    disp_def                 = disp; /*Temporarily change the default screen to create the default screens on the
 801d04a:	4a29      	ldr	r2, [pc, #164]	; (801d0f0 <lv_disp_drv_register+0x114>)
 801d04c:	68fb      	ldr	r3, [r7, #12]
 801d04e:	6013      	str	r3, [r2, #0]
                                        new display*/

    disp->inv_p = 0;
 801d050:	68fa      	ldr	r2, [r7, #12]
 801d052:	f8b2 315c 	ldrh.w	r3, [r2, #348]	; 0x15c
 801d056:	f36f 0309 	bfc	r3, #0, #10
 801d05a:	f8a2 315c 	strh.w	r3, [r2, #348]	; 0x15c

    disp->act_scr   = lv_obj_create(NULL, NULL); /*Create a default screen on the display*/
 801d05e:	2100      	movs	r1, #0
 801d060:	2000      	movs	r0, #0
 801d062:	f7f5 fb8d 	bl	8012780 <lv_obj_create>
 801d066:	4602      	mov	r2, r0
 801d068:	68fb      	ldr	r3, [r7, #12]
 801d06a:	631a      	str	r2, [r3, #48]	; 0x30
    disp->top_layer = lv_obj_create(NULL, NULL); /*Create top layer on the display*/
 801d06c:	2100      	movs	r1, #0
 801d06e:	2000      	movs	r0, #0
 801d070:	f7f5 fb86 	bl	8012780 <lv_obj_create>
 801d074:	4602      	mov	r2, r0
 801d076:	68fb      	ldr	r3, [r7, #12]
 801d078:	635a      	str	r2, [r3, #52]	; 0x34
    disp->sys_layer = lv_obj_create(NULL, NULL); /*Create sys layer on the display*/
 801d07a:	2100      	movs	r1, #0
 801d07c:	2000      	movs	r0, #0
 801d07e:	f7f5 fb7f 	bl	8012780 <lv_obj_create>
 801d082:	4602      	mov	r2, r0
 801d084:	68fb      	ldr	r3, [r7, #12]
 801d086:	639a      	str	r2, [r3, #56]	; 0x38
    lv_obj_set_style(disp->top_layer, &lv_style_transp);
 801d088:	68fb      	ldr	r3, [r7, #12]
 801d08a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801d08c:	4919      	ldr	r1, [pc, #100]	; (801d0f4 <lv_disp_drv_register+0x118>)
 801d08e:	4618      	mov	r0, r3
 801d090:	f7f6 fcc3 	bl	8013a1a <lv_obj_set_style>
    lv_obj_set_style(disp->sys_layer, &lv_style_transp);
 801d094:	68fb      	ldr	r3, [r7, #12]
 801d096:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 801d098:	4916      	ldr	r1, [pc, #88]	; (801d0f4 <lv_disp_drv_register+0x118>)
 801d09a:	4618      	mov	r0, r3
 801d09c:	f7f6 fcbd 	bl	8013a1a <lv_obj_set_style>

    lv_obj_invalidate(disp->act_scr);
 801d0a0:	68fb      	ldr	r3, [r7, #12]
 801d0a2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 801d0a4:	4618      	mov	r0, r3
 801d0a6:	f7f5 fde1 	bl	8012c6c <lv_obj_invalidate>

    disp_def = disp_def_tmp; /*Revert the default display*/
 801d0aa:	4a11      	ldr	r2, [pc, #68]	; (801d0f0 <lv_disp_drv_register+0x114>)
 801d0ac:	68bb      	ldr	r3, [r7, #8]
 801d0ae:	6013      	str	r3, [r2, #0]

    /*Create a refresh task*/
    disp->refr_task = lv_task_create(lv_disp_refr_task, LV_DISP_DEF_REFR_PERIOD, LV_TASK_PRIO_MID, disp);
 801d0b0:	68fb      	ldr	r3, [r7, #12]
 801d0b2:	2203      	movs	r2, #3
 801d0b4:	211e      	movs	r1, #30
 801d0b6:	4810      	ldr	r0, [pc, #64]	; (801d0f8 <lv_disp_drv_register+0x11c>)
 801d0b8:	f001 fa2a 	bl	801e510 <lv_task_create>
 801d0bc:	4602      	mov	r2, r0
 801d0be:	68fb      	ldr	r3, [r7, #12]
 801d0c0:	621a      	str	r2, [r3, #32]
    lv_mem_assert(disp->refr_task);
 801d0c2:	68fb      	ldr	r3, [r7, #12]
 801d0c4:	6a1b      	ldr	r3, [r3, #32]
 801d0c6:	2b00      	cmp	r3, #0
 801d0c8:	d100      	bne.n	801d0cc <lv_disp_drv_register+0xf0>
 801d0ca:	e7fe      	b.n	801d0ca <lv_disp_drv_register+0xee>
    if(disp->refr_task == NULL) return NULL;
 801d0cc:	68fb      	ldr	r3, [r7, #12]
 801d0ce:	6a1b      	ldr	r3, [r3, #32]
 801d0d0:	2b00      	cmp	r3, #0
 801d0d2:	d101      	bne.n	801d0d8 <lv_disp_drv_register+0xfc>
 801d0d4:	2300      	movs	r3, #0
 801d0d6:	e005      	b.n	801d0e4 <lv_disp_drv_register+0x108>

    lv_task_ready(disp->refr_task); /*Be sure the screen will be refreshed immediately on start up*/
 801d0d8:	68fb      	ldr	r3, [r7, #12]
 801d0da:	6a1b      	ldr	r3, [r3, #32]
 801d0dc:	4618      	mov	r0, r3
 801d0de:	f001 fac5 	bl	801e66c <lv_task_ready>

    return disp;
 801d0e2:	68fb      	ldr	r3, [r7, #12]
}
 801d0e4:	4618      	mov	r0, r3
 801d0e6:	3710      	adds	r7, #16
 801d0e8:	46bd      	mov	sp, r7
 801d0ea:	bd80      	pop	{r7, pc}
 801d0ec:	24063640 	.word	0x24063640
 801d0f0:	240623d4 	.word	0x240623d4
 801d0f4:	24063354 	.word	0x24063354
 801d0f8:	080144ad 	.word	0x080144ad

0801d0fc <lv_disp_get_default>:
/**
 * Get the default display
 * @return pointer to the default display
 */
lv_disp_t * lv_disp_get_default(void)
{
 801d0fc:	b480      	push	{r7}
 801d0fe:	af00      	add	r7, sp, #0
    return disp_def;
 801d100:	4b03      	ldr	r3, [pc, #12]	; (801d110 <lv_disp_get_default+0x14>)
 801d102:	681b      	ldr	r3, [r3, #0]
}
 801d104:	4618      	mov	r0, r3
 801d106:	46bd      	mov	sp, r7
 801d108:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d10c:	4770      	bx	lr
 801d10e:	bf00      	nop
 801d110:	240623d4 	.word	0x240623d4

0801d114 <lv_disp_get_hor_res>:
 * Get the horizontal resolution of a display
 * @param disp pointer to a display (NULL to use the default display)
 * @return the horizontal resolution of the display
 */
lv_coord_t lv_disp_get_hor_res(lv_disp_t * disp)
{
 801d114:	b580      	push	{r7, lr}
 801d116:	b082      	sub	sp, #8
 801d118:	af00      	add	r7, sp, #0
 801d11a:	6078      	str	r0, [r7, #4]
    if(disp == NULL) disp = lv_disp_get_default();
 801d11c:	687b      	ldr	r3, [r7, #4]
 801d11e:	2b00      	cmp	r3, #0
 801d120:	d102      	bne.n	801d128 <lv_disp_get_hor_res+0x14>
 801d122:	f7ff ffeb 	bl	801d0fc <lv_disp_get_default>
 801d126:	6078      	str	r0, [r7, #4]

    if(disp == NULL)
 801d128:	687b      	ldr	r3, [r7, #4]
 801d12a:	2b00      	cmp	r3, #0
 801d12c:	d102      	bne.n	801d134 <lv_disp_get_hor_res+0x20>
        return LV_HOR_RES_MAX;
 801d12e:	f44f 7380 	mov.w	r3, #256	; 0x100
 801d132:	e00d      	b.n	801d150 <lv_disp_get_hor_res+0x3c>
    else
        return disp->driver.rotated == 0 ? disp->driver.hor_res : disp->driver.ver_res;
 801d134:	687b      	ldr	r3, [r7, #4]
 801d136:	7a1b      	ldrb	r3, [r3, #8]
 801d138:	f003 0302 	and.w	r3, r3, #2
 801d13c:	b2db      	uxtb	r3, r3
 801d13e:	2b00      	cmp	r3, #0
 801d140:	d103      	bne.n	801d14a <lv_disp_get_hor_res+0x36>
 801d142:	687b      	ldr	r3, [r7, #4]
 801d144:	f9b3 3000 	ldrsh.w	r3, [r3]
 801d148:	e002      	b.n	801d150 <lv_disp_get_hor_res+0x3c>
 801d14a:	687b      	ldr	r3, [r7, #4]
 801d14c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
}
 801d150:	4618      	mov	r0, r3
 801d152:	3708      	adds	r7, #8
 801d154:	46bd      	mov	sp, r7
 801d156:	bd80      	pop	{r7, pc}

0801d158 <lv_disp_get_ver_res>:
 * Get the vertical resolution of a display
 * @param disp pointer to a display (NULL to use the default display)
 * @return the vertical resolution of the display
 */
lv_coord_t lv_disp_get_ver_res(lv_disp_t * disp)
{
 801d158:	b580      	push	{r7, lr}
 801d15a:	b082      	sub	sp, #8
 801d15c:	af00      	add	r7, sp, #0
 801d15e:	6078      	str	r0, [r7, #4]
    if(disp == NULL) disp = lv_disp_get_default();
 801d160:	687b      	ldr	r3, [r7, #4]
 801d162:	2b00      	cmp	r3, #0
 801d164:	d102      	bne.n	801d16c <lv_disp_get_ver_res+0x14>
 801d166:	f7ff ffc9 	bl	801d0fc <lv_disp_get_default>
 801d16a:	6078      	str	r0, [r7, #4]

    if(disp == NULL)
 801d16c:	687b      	ldr	r3, [r7, #4]
 801d16e:	2b00      	cmp	r3, #0
 801d170:	d101      	bne.n	801d176 <lv_disp_get_ver_res+0x1e>
        return LV_VER_RES_MAX;
 801d172:	2340      	movs	r3, #64	; 0x40
 801d174:	e00d      	b.n	801d192 <lv_disp_get_ver_res+0x3a>
    else
        return disp->driver.rotated == 0 ? disp->driver.ver_res : disp->driver.hor_res;
 801d176:	687b      	ldr	r3, [r7, #4]
 801d178:	7a1b      	ldrb	r3, [r3, #8]
 801d17a:	f003 0302 	and.w	r3, r3, #2
 801d17e:	b2db      	uxtb	r3, r3
 801d180:	2b00      	cmp	r3, #0
 801d182:	d103      	bne.n	801d18c <lv_disp_get_ver_res+0x34>
 801d184:	687b      	ldr	r3, [r7, #4]
 801d186:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801d18a:	e002      	b.n	801d192 <lv_disp_get_ver_res+0x3a>
 801d18c:	687b      	ldr	r3, [r7, #4]
 801d18e:	f9b3 3000 	ldrsh.w	r3, [r3]
}
 801d192:	4618      	mov	r0, r3
 801d194:	3708      	adds	r7, #8
 801d196:	46bd      	mov	sp, r7
 801d198:	bd80      	pop	{r7, pc}

0801d19a <lv_disp_get_antialiasing>:
 * Get if anti-aliasing is enabled for a display or not
 * @param disp pointer to a display (NULL to use the default display)
 * @return true: anti-aliasing is enabled; false: disabled
 */
bool lv_disp_get_antialiasing(lv_disp_t * disp)
{
 801d19a:	b580      	push	{r7, lr}
 801d19c:	b082      	sub	sp, #8
 801d19e:	af00      	add	r7, sp, #0
 801d1a0:	6078      	str	r0, [r7, #4]
#if LV_ANTIALIAS == 0
    return false;
#else
    if(disp == NULL) disp = lv_disp_get_default();
 801d1a2:	687b      	ldr	r3, [r7, #4]
 801d1a4:	2b00      	cmp	r3, #0
 801d1a6:	d102      	bne.n	801d1ae <lv_disp_get_antialiasing+0x14>
 801d1a8:	f7ff ffa8 	bl	801d0fc <lv_disp_get_default>
 801d1ac:	6078      	str	r0, [r7, #4]
    if(disp == NULL) return false;
 801d1ae:	687b      	ldr	r3, [r7, #4]
 801d1b0:	2b00      	cmp	r3, #0
 801d1b2:	d101      	bne.n	801d1b8 <lv_disp_get_antialiasing+0x1e>
 801d1b4:	2300      	movs	r3, #0
 801d1b6:	e008      	b.n	801d1ca <lv_disp_get_antialiasing+0x30>

    return disp->driver.antialiasing ? true : false;
 801d1b8:	687b      	ldr	r3, [r7, #4]
 801d1ba:	7a1b      	ldrb	r3, [r3, #8]
 801d1bc:	f003 0301 	and.w	r3, r3, #1
 801d1c0:	2b00      	cmp	r3, #0
 801d1c2:	bf14      	ite	ne
 801d1c4:	2301      	movne	r3, #1
 801d1c6:	2300      	moveq	r3, #0
 801d1c8:	b2db      	uxtb	r3, r3
#endif
}
 801d1ca:	4618      	mov	r0, r3
 801d1cc:	3708      	adds	r7, #8
 801d1ce:	46bd      	mov	sp, r7
 801d1d0:	bd80      	pop	{r7, pc}

0801d1d2 <lv_disp_flush_ready>:
/**
 * Call in the display driver's `flush_cb` function when the flushing is finished
 * @param disp_drv pointer to display driver in `flush_cb` where this function is called
 */
LV_ATTRIBUTE_FLUSH_READY void lv_disp_flush_ready(lv_disp_drv_t * disp_drv)
{
 801d1d2:	b480      	push	{r7}
 801d1d4:	b083      	sub	sp, #12
 801d1d6:	af00      	add	r7, sp, #0
 801d1d8:	6078      	str	r0, [r7, #4]
    disp_drv->buffer->flushing = 0;
 801d1da:	687b      	ldr	r3, [r7, #4]
 801d1dc:	685a      	ldr	r2, [r3, #4]
 801d1de:	7e13      	ldrb	r3, [r2, #24]
 801d1e0:	f36f 0300 	bfc	r3, #0, #1
 801d1e4:	7613      	strb	r3, [r2, #24]
#if LV_COLOR_SCREEN_TRANSP
    if(disp_drv->screen_transp) {
        memset(disp_drv->buffer->buf_act, 0x00, disp_drv->buffer->size * sizeof(lv_color32_t));
    }
#endif
}
 801d1e6:	bf00      	nop
 801d1e8:	370c      	adds	r7, #12
 801d1ea:	46bd      	mov	sp, r7
 801d1ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d1f0:	4770      	bx	lr

0801d1f2 <lv_disp_get_buf>:
 * Get the internal buffer of a display
 * @param disp pointer to a display
 * @return pointer to the internal buffers
 */
lv_disp_buf_t * lv_disp_get_buf(lv_disp_t * disp)
{
 801d1f2:	b480      	push	{r7}
 801d1f4:	b083      	sub	sp, #12
 801d1f6:	af00      	add	r7, sp, #0
 801d1f8:	6078      	str	r0, [r7, #4]
    return disp->driver.buffer;
 801d1fa:	687b      	ldr	r3, [r7, #4]
 801d1fc:	685b      	ldr	r3, [r3, #4]
}
 801d1fe:	4618      	mov	r0, r3
 801d200:	370c      	adds	r7, #12
 801d202:	46bd      	mov	sp, r7
 801d204:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d208:	4770      	bx	lr

0801d20a <lv_disp_is_double_buf>:
 * Check the driver configuration if it's double buffered (both `buf1` and `buf2` are set)
 * @param disp pointer to to display to check
 * @return true: double buffered; false: not double buffered
 */
bool lv_disp_is_double_buf(lv_disp_t * disp)
{
 801d20a:	b480      	push	{r7}
 801d20c:	b083      	sub	sp, #12
 801d20e:	af00      	add	r7, sp, #0
 801d210:	6078      	str	r0, [r7, #4]
    if(disp->driver.buffer->buf1 && disp->driver.buffer->buf2)
 801d212:	687b      	ldr	r3, [r7, #4]
 801d214:	685b      	ldr	r3, [r3, #4]
 801d216:	681b      	ldr	r3, [r3, #0]
 801d218:	2b00      	cmp	r3, #0
 801d21a:	d006      	beq.n	801d22a <lv_disp_is_double_buf+0x20>
 801d21c:	687b      	ldr	r3, [r7, #4]
 801d21e:	685b      	ldr	r3, [r3, #4]
 801d220:	685b      	ldr	r3, [r3, #4]
 801d222:	2b00      	cmp	r3, #0
 801d224:	d001      	beq.n	801d22a <lv_disp_is_double_buf+0x20>
        return true;
 801d226:	2301      	movs	r3, #1
 801d228:	e000      	b.n	801d22c <lv_disp_is_double_buf+0x22>
    else
        return false;
 801d22a:	2300      	movs	r3, #0
}
 801d22c:	4618      	mov	r0, r3
 801d22e:	370c      	adds	r7, #12
 801d230:	46bd      	mov	sp, r7
 801d232:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d236:	4770      	bx	lr

0801d238 <lv_disp_is_true_double_buf>:
 * `size` is screen sized)
 * @param disp pointer to to display to check
 * @return true: double buffered; false: not double buffered
 */
bool lv_disp_is_true_double_buf(lv_disp_t * disp)
{
 801d238:	b580      	push	{r7, lr}
 801d23a:	b084      	sub	sp, #16
 801d23c:	af00      	add	r7, sp, #0
 801d23e:	6078      	str	r0, [r7, #4]
    uint32_t scr_size = disp->driver.hor_res * disp->driver.ver_res;
 801d240:	687b      	ldr	r3, [r7, #4]
 801d242:	f9b3 3000 	ldrsh.w	r3, [r3]
 801d246:	461a      	mov	r2, r3
 801d248:	687b      	ldr	r3, [r7, #4]
 801d24a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801d24e:	fb03 f302 	mul.w	r3, r3, r2
 801d252:	60fb      	str	r3, [r7, #12]

    if(lv_disp_is_double_buf(disp) && disp->driver.buffer->size == scr_size) {
 801d254:	6878      	ldr	r0, [r7, #4]
 801d256:	f7ff ffd8 	bl	801d20a <lv_disp_is_double_buf>
 801d25a:	4603      	mov	r3, r0
 801d25c:	2b00      	cmp	r3, #0
 801d25e:	d007      	beq.n	801d270 <lv_disp_is_true_double_buf+0x38>
 801d260:	687b      	ldr	r3, [r7, #4]
 801d262:	685b      	ldr	r3, [r3, #4]
 801d264:	68db      	ldr	r3, [r3, #12]
 801d266:	68fa      	ldr	r2, [r7, #12]
 801d268:	429a      	cmp	r2, r3
 801d26a:	d101      	bne.n	801d270 <lv_disp_is_true_double_buf+0x38>
        return true;
 801d26c:	2301      	movs	r3, #1
 801d26e:	e000      	b.n	801d272 <lv_disp_is_true_double_buf+0x3a>
    } else {
        return false;
 801d270:	2300      	movs	r3, #0
    }
}
 801d272:	4618      	mov	r0, r3
 801d274:	3710      	adds	r7, #16
 801d276:	46bd      	mov	sp, r7
 801d278:	bd80      	pop	{r7, pc}
	...

0801d27c <lv_indev_get_next>:
 * @param indev pointer to the current input device. NULL to initialize.
 * @return the next input devise or NULL if no more. Give the first input device when the parameter
 * is NULL
 */
lv_indev_t * lv_indev_get_next(lv_indev_t * indev)
{
 801d27c:	b580      	push	{r7, lr}
 801d27e:	b082      	sub	sp, #8
 801d280:	af00      	add	r7, sp, #0
 801d282:	6078      	str	r0, [r7, #4]
    if(indev == NULL)
 801d284:	687b      	ldr	r3, [r7, #4]
 801d286:	2b00      	cmp	r3, #0
 801d288:	d104      	bne.n	801d294 <lv_indev_get_next+0x18>
        return lv_ll_get_head(&LV_GC_ROOT(_lv_indev_ll));
 801d28a:	4807      	ldr	r0, [pc, #28]	; (801d2a8 <lv_indev_get_next+0x2c>)
 801d28c:	f000 fdaa 	bl	801dde4 <lv_ll_get_head>
 801d290:	4603      	mov	r3, r0
 801d292:	e004      	b.n	801d29e <lv_indev_get_next+0x22>
    else
        return lv_ll_get_next(&LV_GC_ROOT(_lv_indev_ll), indev);
 801d294:	6879      	ldr	r1, [r7, #4]
 801d296:	4804      	ldr	r0, [pc, #16]	; (801d2a8 <lv_indev_get_next+0x2c>)
 801d298:	f000 fdca 	bl	801de30 <lv_ll_get_next>
 801d29c:	4603      	mov	r3, r0
}
 801d29e:	4618      	mov	r0, r3
 801d2a0:	3708      	adds	r7, #8
 801d2a2:	46bd      	mov	sp, r7
 801d2a4:	bd80      	pop	{r7, pc}
 801d2a6:	bf00      	nop
 801d2a8:	24063630 	.word	0x24063630

0801d2ac <lv_tick_inc>:
/**
 * You have to call this function periodically
 * @param tick_period the call period of this function in milliseconds
 */
LV_ATTRIBUTE_TICK_INC void lv_tick_inc(uint32_t tick_period)
{
 801d2ac:	b480      	push	{r7}
 801d2ae:	b083      	sub	sp, #12
 801d2b0:	af00      	add	r7, sp, #0
 801d2b2:	6078      	str	r0, [r7, #4]
    tick_irq_flag = 0;
 801d2b4:	4b07      	ldr	r3, [pc, #28]	; (801d2d4 <lv_tick_inc+0x28>)
 801d2b6:	2200      	movs	r2, #0
 801d2b8:	701a      	strb	r2, [r3, #0]
    sys_time += tick_period;
 801d2ba:	4b07      	ldr	r3, [pc, #28]	; (801d2d8 <lv_tick_inc+0x2c>)
 801d2bc:	681a      	ldr	r2, [r3, #0]
 801d2be:	687b      	ldr	r3, [r7, #4]
 801d2c0:	4413      	add	r3, r2
 801d2c2:	4a05      	ldr	r2, [pc, #20]	; (801d2d8 <lv_tick_inc+0x2c>)
 801d2c4:	6013      	str	r3, [r2, #0]
}
 801d2c6:	bf00      	nop
 801d2c8:	370c      	adds	r7, #12
 801d2ca:	46bd      	mov	sp, r7
 801d2cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d2d0:	4770      	bx	lr
 801d2d2:	bf00      	nop
 801d2d4:	240623dc 	.word	0x240623dc
 801d2d8:	240623d8 	.word	0x240623d8

0801d2dc <lv_tick_get>:
/**
 * Get the elapsed milliseconds since start up
 * @return the elapsed milliseconds
 */
uint32_t lv_tick_get(void)
{
 801d2dc:	b480      	push	{r7}
 801d2de:	b083      	sub	sp, #12
 801d2e0:	af00      	add	r7, sp, #0
#if LV_TICK_CUSTOM == 0
    uint32_t result;
    do {
        tick_irq_flag = 1;
 801d2e2:	4b09      	ldr	r3, [pc, #36]	; (801d308 <lv_tick_get+0x2c>)
 801d2e4:	2201      	movs	r2, #1
 801d2e6:	701a      	strb	r2, [r3, #0]
        result        = sys_time;
 801d2e8:	4b08      	ldr	r3, [pc, #32]	; (801d30c <lv_tick_get+0x30>)
 801d2ea:	681b      	ldr	r3, [r3, #0]
 801d2ec:	607b      	str	r3, [r7, #4]
    } while(!tick_irq_flag); /*'lv_tick_inc()' clears this flag which can be in an interrupt.
 801d2ee:	4b06      	ldr	r3, [pc, #24]	; (801d308 <lv_tick_get+0x2c>)
 801d2f0:	781b      	ldrb	r3, [r3, #0]
 801d2f2:	b2db      	uxtb	r3, r3
 801d2f4:	2b00      	cmp	r3, #0
 801d2f6:	d0f4      	beq.n	801d2e2 <lv_tick_get+0x6>
                                Continue until make a non interrupted cycle */

    return result;
 801d2f8:	687b      	ldr	r3, [r7, #4]
#else
    return LV_TICK_CUSTOM_SYS_TIME_EXPR;
#endif
}
 801d2fa:	4618      	mov	r0, r3
 801d2fc:	370c      	adds	r7, #12
 801d2fe:	46bd      	mov	sp, r7
 801d300:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d304:	4770      	bx	lr
 801d306:	bf00      	nop
 801d308:	240623dc 	.word	0x240623dc
 801d30c:	240623d8 	.word	0x240623d8

0801d310 <lv_tick_elaps>:
 * Get the elapsed milliseconds since a previous time stamp
 * @param prev_tick a previous time stamp (return value of systick_get() )
 * @return the elapsed milliseconds since 'prev_tick'
 */
uint32_t lv_tick_elaps(uint32_t prev_tick)
{
 801d310:	b580      	push	{r7, lr}
 801d312:	b084      	sub	sp, #16
 801d314:	af00      	add	r7, sp, #0
 801d316:	6078      	str	r0, [r7, #4]
    uint32_t act_time = lv_tick_get();
 801d318:	f7ff ffe0 	bl	801d2dc <lv_tick_get>
 801d31c:	60f8      	str	r0, [r7, #12]

    /*If there is no overflow in sys_time simple subtract*/
    if(act_time >= prev_tick) {
 801d31e:	68fa      	ldr	r2, [r7, #12]
 801d320:	687b      	ldr	r3, [r7, #4]
 801d322:	429a      	cmp	r2, r3
 801d324:	d304      	bcc.n	801d330 <lv_tick_elaps+0x20>
        prev_tick = act_time - prev_tick;
 801d326:	68fa      	ldr	r2, [r7, #12]
 801d328:	687b      	ldr	r3, [r7, #4]
 801d32a:	1ad3      	subs	r3, r2, r3
 801d32c:	607b      	str	r3, [r7, #4]
 801d32e:	e006      	b.n	801d33e <lv_tick_elaps+0x2e>
    } else {
        prev_tick = UINT32_MAX - prev_tick + 1;
 801d330:	687b      	ldr	r3, [r7, #4]
 801d332:	425b      	negs	r3, r3
 801d334:	607b      	str	r3, [r7, #4]
        prev_tick += act_time;
 801d336:	687a      	ldr	r2, [r7, #4]
 801d338:	68fb      	ldr	r3, [r7, #12]
 801d33a:	4413      	add	r3, r2
 801d33c:	607b      	str	r3, [r7, #4]
    }

    return prev_tick;
 801d33e:	687b      	ldr	r3, [r7, #4]
}
 801d340:	4618      	mov	r0, r3
 801d342:	3710      	adds	r7, #16
 801d344:	46bd      	mov	sp, r7
 801d346:	bd80      	pop	{r7, pc}

0801d348 <lv_anim_core_init>:

/**
 * Init. the animation module
 */
void lv_anim_core_init(void)
{
 801d348:	b580      	push	{r7, lr}
 801d34a:	af00      	add	r7, sp, #0
    lv_ll_init(&LV_GC_ROOT(_lv_anim_ll), sizeof(lv_anim_t));
 801d34c:	2124      	movs	r1, #36	; 0x24
 801d34e:	4808      	ldr	r0, [pc, #32]	; (801d370 <lv_anim_core_init+0x28>)
 801d350:	f000 fbc6 	bl	801dae0 <lv_ll_init>
    last_task_run = lv_tick_get();
 801d354:	f7ff ffc2 	bl	801d2dc <lv_tick_get>
 801d358:	4603      	mov	r3, r0
 801d35a:	4a06      	ldr	r2, [pc, #24]	; (801d374 <lv_anim_core_init+0x2c>)
 801d35c:	6013      	str	r3, [r2, #0]
    lv_task_create(anim_task, LV_DISP_DEF_REFR_PERIOD, LV_TASK_PRIO_MID, NULL);
 801d35e:	2300      	movs	r3, #0
 801d360:	2203      	movs	r2, #3
 801d362:	211e      	movs	r1, #30
 801d364:	4804      	ldr	r0, [pc, #16]	; (801d378 <lv_anim_core_init+0x30>)
 801d366:	f001 f8d3 	bl	801e510 <lv_task_create>
}
 801d36a:	bf00      	nop
 801d36c:	bd80      	pop	{r7, pc}
 801d36e:	bf00      	nop
 801d370:	2406366c 	.word	0x2406366c
 801d374:	240623e0 	.word	0x240623e0
 801d378:	0801d531 	.word	0x0801d531

0801d37c <lv_anim_create>:
/**
 * Create an animation
 * @param a an initialized 'anim_t' variable. Not required after call.
 */
void lv_anim_create(lv_anim_t * a)
{
 801d37c:	b580      	push	{r7, lr}
 801d37e:	b084      	sub	sp, #16
 801d380:	af00      	add	r7, sp, #0
 801d382:	6078      	str	r0, [r7, #4]
    LV_LOG_TRACE("animation create started")
    /* Do not let two animations for the  same 'var' with the same 'fp'*/
    if(a->exec_cb != NULL) lv_anim_del(a->var, a->exec_cb); /*fp == NULL would delete all animations of var*/
 801d384:	687b      	ldr	r3, [r7, #4]
 801d386:	685b      	ldr	r3, [r3, #4]
 801d388:	2b00      	cmp	r3, #0
 801d38a:	d007      	beq.n	801d39c <lv_anim_create+0x20>
 801d38c:	687b      	ldr	r3, [r7, #4]
 801d38e:	681a      	ldr	r2, [r3, #0]
 801d390:	687b      	ldr	r3, [r7, #4]
 801d392:	685b      	ldr	r3, [r3, #4]
 801d394:	4619      	mov	r1, r3
 801d396:	4610      	mov	r0, r2
 801d398:	f000 f830 	bl	801d3fc <lv_anim_del>

    /*Add the new animation to the animation linked list*/
    lv_anim_t * new_anim = lv_ll_ins_head(&LV_GC_ROOT(_lv_anim_ll));
 801d39c:	4815      	ldr	r0, [pc, #84]	; (801d3f4 <lv_anim_create+0x78>)
 801d39e:	f000 fbbf 	bl	801db20 <lv_ll_ins_head>
 801d3a2:	60f8      	str	r0, [r7, #12]
    lv_mem_assert(new_anim);
 801d3a4:	68fb      	ldr	r3, [r7, #12]
 801d3a6:	2b00      	cmp	r3, #0
 801d3a8:	d100      	bne.n	801d3ac <lv_anim_create+0x30>
 801d3aa:	e7fe      	b.n	801d3aa <lv_anim_create+0x2e>
    if(new_anim == NULL) return;
 801d3ac:	68fb      	ldr	r3, [r7, #12]
 801d3ae:	2b00      	cmp	r3, #0
 801d3b0:	d01c      	beq.n	801d3ec <lv_anim_create+0x70>

    /*Initialize the animation descriptor*/
    a->playback_now = 0;
 801d3b2:	687a      	ldr	r2, [r7, #4]
 801d3b4:	f892 3020 	ldrb.w	r3, [r2, #32]
 801d3b8:	f36f 0382 	bfc	r3, #2, #1
 801d3bc:	f882 3020 	strb.w	r3, [r2, #32]
    memcpy(new_anim, a, sizeof(lv_anim_t));
 801d3c0:	2224      	movs	r2, #36	; 0x24
 801d3c2:	6879      	ldr	r1, [r7, #4]
 801d3c4:	68f8      	ldr	r0, [r7, #12]
 801d3c6:	f004 fc47 	bl	8021c58 <memcpy>

    /*Set the start value*/
    if(new_anim->exec_cb) new_anim->exec_cb(new_anim->var, new_anim->start);
 801d3ca:	68fb      	ldr	r3, [r7, #12]
 801d3cc:	685b      	ldr	r3, [r3, #4]
 801d3ce:	2b00      	cmp	r3, #0
 801d3d0:	d008      	beq.n	801d3e4 <lv_anim_create+0x68>
 801d3d2:	68fb      	ldr	r3, [r7, #12]
 801d3d4:	685b      	ldr	r3, [r3, #4]
 801d3d6:	68fa      	ldr	r2, [r7, #12]
 801d3d8:	6810      	ldr	r0, [r2, #0]
 801d3da:	68fa      	ldr	r2, [r7, #12]
 801d3dc:	6912      	ldr	r2, [r2, #16]
 801d3de:	b212      	sxth	r2, r2
 801d3e0:	4611      	mov	r1, r2
 801d3e2:	4798      	blx	r3

    /* Creating an animation changed the linked list.
     * It's important if it happens in a ready callback. (see `anim_task`)*/
    anim_list_changed = true;
 801d3e4:	4b04      	ldr	r3, [pc, #16]	; (801d3f8 <lv_anim_create+0x7c>)
 801d3e6:	2201      	movs	r2, #1
 801d3e8:	701a      	strb	r2, [r3, #0]
 801d3ea:	e000      	b.n	801d3ee <lv_anim_create+0x72>
    if(new_anim == NULL) return;
 801d3ec:	bf00      	nop

    LV_LOG_TRACE("animation created")
}
 801d3ee:	3710      	adds	r7, #16
 801d3f0:	46bd      	mov	sp, r7
 801d3f2:	bd80      	pop	{r7, pc}
 801d3f4:	2406366c 	.word	0x2406366c
 801d3f8:	240623e4 	.word	0x240623e4

0801d3fc <lv_anim_del>:
 * @param exec_cb a function pointer which is animating 'var',
 *           or NULL to delete all the animations of 'var'
 * @return true: at least 1 animation is deleted, false: no animation is deleted
 */
bool lv_anim_del(void * var, lv_anim_exec_xcb_t exec_cb)
{
 801d3fc:	b580      	push	{r7, lr}
 801d3fe:	b086      	sub	sp, #24
 801d400:	af00      	add	r7, sp, #0
 801d402:	6078      	str	r0, [r7, #4]
 801d404:	6039      	str	r1, [r7, #0]
    lv_anim_t * a;
    lv_anim_t * a_next;
    bool del = false;
 801d406:	2300      	movs	r3, #0
 801d408:	74fb      	strb	r3, [r7, #19]
    a        = lv_ll_get_head(&LV_GC_ROOT(_lv_anim_ll));
 801d40a:	4816      	ldr	r0, [pc, #88]	; (801d464 <lv_anim_del+0x68>)
 801d40c:	f000 fcea 	bl	801dde4 <lv_ll_get_head>
 801d410:	6178      	str	r0, [r7, #20]
    while(a != NULL) {
 801d412:	e01f      	b.n	801d454 <lv_anim_del+0x58>
        /*'a' might be deleted, so get the next object while 'a' is valid*/
        a_next = lv_ll_get_next(&LV_GC_ROOT(_lv_anim_ll), a);
 801d414:	6979      	ldr	r1, [r7, #20]
 801d416:	4813      	ldr	r0, [pc, #76]	; (801d464 <lv_anim_del+0x68>)
 801d418:	f000 fd0a 	bl	801de30 <lv_ll_get_next>
 801d41c:	60f8      	str	r0, [r7, #12]

        if(a->var == var && (a->exec_cb == exec_cb || exec_cb == NULL)) {
 801d41e:	697b      	ldr	r3, [r7, #20]
 801d420:	681b      	ldr	r3, [r3, #0]
 801d422:	687a      	ldr	r2, [r7, #4]
 801d424:	429a      	cmp	r2, r3
 801d426:	d113      	bne.n	801d450 <lv_anim_del+0x54>
 801d428:	697b      	ldr	r3, [r7, #20]
 801d42a:	685b      	ldr	r3, [r3, #4]
 801d42c:	683a      	ldr	r2, [r7, #0]
 801d42e:	429a      	cmp	r2, r3
 801d430:	d002      	beq.n	801d438 <lv_anim_del+0x3c>
 801d432:	683b      	ldr	r3, [r7, #0]
 801d434:	2b00      	cmp	r3, #0
 801d436:	d10b      	bne.n	801d450 <lv_anim_del+0x54>
            lv_ll_rem(&LV_GC_ROOT(_lv_anim_ll), a);
 801d438:	6979      	ldr	r1, [r7, #20]
 801d43a:	480a      	ldr	r0, [pc, #40]	; (801d464 <lv_anim_del+0x68>)
 801d43c:	f000 fc24 	bl	801dc88 <lv_ll_rem>
            lv_mem_free(a);
 801d440:	6978      	ldr	r0, [r7, #20]
 801d442:	f000 fe75 	bl	801e130 <lv_mem_free>
            anim_list_changed = true; /*Read by `anim_task`. It need to know if a delete occurred in
 801d446:	4b08      	ldr	r3, [pc, #32]	; (801d468 <lv_anim_del+0x6c>)
 801d448:	2201      	movs	r2, #1
 801d44a:	701a      	strb	r2, [r3, #0]
                                         the linked list*/
            del = true;
 801d44c:	2301      	movs	r3, #1
 801d44e:	74fb      	strb	r3, [r7, #19]
        }

        a = a_next;
 801d450:	68fb      	ldr	r3, [r7, #12]
 801d452:	617b      	str	r3, [r7, #20]
    while(a != NULL) {
 801d454:	697b      	ldr	r3, [r7, #20]
 801d456:	2b00      	cmp	r3, #0
 801d458:	d1dc      	bne.n	801d414 <lv_anim_del+0x18>
    }

    return del;
 801d45a:	7cfb      	ldrb	r3, [r7, #19]
}
 801d45c:	4618      	mov	r0, r3
 801d45e:	3718      	adds	r7, #24
 801d460:	46bd      	mov	sp, r7
 801d462:	bd80      	pop	{r7, pc}
 801d464:	2406366c 	.word	0x2406366c
 801d468:	240623e4 	.word	0x240623e4

0801d46c <lv_anim_speed_to_time>:
 * @param start start value of the animation
 * @param end end value of the animation
 * @return the required time [ms] for the animation with the given parameters
 */
uint16_t lv_anim_speed_to_time(uint16_t speed, lv_anim_value_t start, lv_anim_value_t end)
{
 801d46c:	b480      	push	{r7}
 801d46e:	b085      	sub	sp, #20
 801d470:	af00      	add	r7, sp, #0
 801d472:	4603      	mov	r3, r0
 801d474:	80fb      	strh	r3, [r7, #6]
 801d476:	460b      	mov	r3, r1
 801d478:	80bb      	strh	r3, [r7, #4]
 801d47a:	4613      	mov	r3, r2
 801d47c:	807b      	strh	r3, [r7, #2]
    int32_t d     = LV_MATH_ABS((int32_t)start - end);
 801d47e:	f9b7 2004 	ldrsh.w	r2, [r7, #4]
 801d482:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 801d486:	1ad3      	subs	r3, r2, r3
 801d488:	2b00      	cmp	r3, #0
 801d48a:	bfb8      	it	lt
 801d48c:	425b      	neglt	r3, r3
 801d48e:	60bb      	str	r3, [r7, #8]
    uint32_t time = (int32_t)((int32_t)(d * 1000) / speed);
 801d490:	68bb      	ldr	r3, [r7, #8]
 801d492:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 801d496:	fb02 f203 	mul.w	r2, r2, r3
 801d49a:	88fb      	ldrh	r3, [r7, #6]
 801d49c:	fb92 f3f3 	sdiv	r3, r2, r3
 801d4a0:	60fb      	str	r3, [r7, #12]

    if(time > UINT16_MAX) time = UINT16_MAX;
 801d4a2:	68fb      	ldr	r3, [r7, #12]
 801d4a4:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 801d4a8:	d302      	bcc.n	801d4b0 <lv_anim_speed_to_time+0x44>
 801d4aa:	f64f 73ff 	movw	r3, #65535	; 0xffff
 801d4ae:	60fb      	str	r3, [r7, #12]

    if(time == 0) {
 801d4b0:	68fb      	ldr	r3, [r7, #12]
 801d4b2:	2b00      	cmp	r3, #0
 801d4b4:	d102      	bne.n	801d4bc <lv_anim_speed_to_time+0x50>
        time++;
 801d4b6:	68fb      	ldr	r3, [r7, #12]
 801d4b8:	3301      	adds	r3, #1
 801d4ba:	60fb      	str	r3, [r7, #12]
    }

    return time;
 801d4bc:	68fb      	ldr	r3, [r7, #12]
 801d4be:	b29b      	uxth	r3, r3
}
 801d4c0:	4618      	mov	r0, r3
 801d4c2:	3714      	adds	r7, #20
 801d4c4:	46bd      	mov	sp, r7
 801d4c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d4ca:	4770      	bx	lr

0801d4cc <lv_anim_path_linear>:
 * Calculate the current value of an animation applying linear characteristic
 * @param a pointer to an animation
 * @return the current value to set
 */
lv_anim_value_t lv_anim_path_linear(const lv_anim_t * a)
{
 801d4cc:	b480      	push	{r7}
 801d4ce:	b085      	sub	sp, #20
 801d4d0:	af00      	add	r7, sp, #0
 801d4d2:	6078      	str	r0, [r7, #4]
    /*Calculate the current step*/
    uint32_t step;
    if(a->time == a->act_time) {
 801d4d4:	687b      	ldr	r3, [r7, #4]
 801d4d6:	8b1b      	ldrh	r3, [r3, #24]
 801d4d8:	461a      	mov	r2, r3
 801d4da:	687b      	ldr	r3, [r7, #4]
 801d4dc:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 801d4e0:	429a      	cmp	r2, r3
 801d4e2:	d103      	bne.n	801d4ec <lv_anim_path_linear+0x20>
        step = LV_ANIM_RESOLUTION; /*Use the last value if the time fully elapsed*/
 801d4e4:	f44f 6380 	mov.w	r3, #1024	; 0x400
 801d4e8:	60fb      	str	r3, [r7, #12]
 801d4ea:	e008      	b.n	801d4fe <lv_anim_path_linear+0x32>
    } else {
        step = ((int32_t)a->act_time * LV_ANIM_RESOLUTION) / a->time;
 801d4ec:	687b      	ldr	r3, [r7, #4]
 801d4ee:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 801d4f2:	029b      	lsls	r3, r3, #10
 801d4f4:	687a      	ldr	r2, [r7, #4]
 801d4f6:	8b12      	ldrh	r2, [r2, #24]
 801d4f8:	fb93 f3f2 	sdiv	r3, r3, r2
 801d4fc:	60fb      	str	r3, [r7, #12]
    }

    /* Get the new value which will be proportional to `step`
     * and the `start` and `end` values*/
    int32_t new_value;
    new_value = (int32_t)step * (a->end - a->start);
 801d4fe:	687b      	ldr	r3, [r7, #4]
 801d500:	695a      	ldr	r2, [r3, #20]
 801d502:	687b      	ldr	r3, [r7, #4]
 801d504:	691b      	ldr	r3, [r3, #16]
 801d506:	1ad3      	subs	r3, r2, r3
 801d508:	68fa      	ldr	r2, [r7, #12]
 801d50a:	fb02 f303 	mul.w	r3, r2, r3
 801d50e:	60bb      	str	r3, [r7, #8]
    new_value = new_value >> LV_ANIM_RES_SHIFT;
 801d510:	68bb      	ldr	r3, [r7, #8]
 801d512:	129b      	asrs	r3, r3, #10
 801d514:	60bb      	str	r3, [r7, #8]
    new_value += a->start;
 801d516:	687b      	ldr	r3, [r7, #4]
 801d518:	691b      	ldr	r3, [r3, #16]
 801d51a:	68ba      	ldr	r2, [r7, #8]
 801d51c:	4413      	add	r3, r2
 801d51e:	60bb      	str	r3, [r7, #8]

    return (lv_anim_value_t)new_value;
 801d520:	68bb      	ldr	r3, [r7, #8]
 801d522:	b21b      	sxth	r3, r3
}
 801d524:	4618      	mov	r0, r3
 801d526:	3714      	adds	r7, #20
 801d528:	46bd      	mov	sp, r7
 801d52a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d52e:	4770      	bx	lr

0801d530 <anim_task>:
/**
 * Periodically handle the animations.
 * @param param unused
 */
static void anim_task(lv_task_t * param)
{
 801d530:	b580      	push	{r7, lr}
 801d532:	b086      	sub	sp, #24
 801d534:	af00      	add	r7, sp, #0
 801d536:	6078      	str	r0, [r7, #4]
    (void)param;

    lv_anim_t * a;
    LV_LL_READ(LV_GC_ROOT(_lv_anim_ll), a)
 801d538:	4842      	ldr	r0, [pc, #264]	; (801d644 <anim_task+0x114>)
 801d53a:	f000 fc53 	bl	801dde4 <lv_ll_get_head>
 801d53e:	6178      	str	r0, [r7, #20]
 801d540:	e00b      	b.n	801d55a <anim_task+0x2a>
    {
        a->has_run = 0;
 801d542:	697a      	ldr	r2, [r7, #20]
 801d544:	f892 3020 	ldrb.w	r3, [r2, #32]
 801d548:	f36f 03c3 	bfc	r3, #3, #1
 801d54c:	f882 3020 	strb.w	r3, [r2, #32]
    LV_LL_READ(LV_GC_ROOT(_lv_anim_ll), a)
 801d550:	6979      	ldr	r1, [r7, #20]
 801d552:	483c      	ldr	r0, [pc, #240]	; (801d644 <anim_task+0x114>)
 801d554:	f000 fc6c 	bl	801de30 <lv_ll_get_next>
 801d558:	6178      	str	r0, [r7, #20]
 801d55a:	697b      	ldr	r3, [r7, #20]
 801d55c:	2b00      	cmp	r3, #0
 801d55e:	d1f0      	bne.n	801d542 <anim_task+0x12>
    }

    uint32_t elaps = lv_tick_elaps(last_task_run);
 801d560:	4b39      	ldr	r3, [pc, #228]	; (801d648 <anim_task+0x118>)
 801d562:	681b      	ldr	r3, [r3, #0]
 801d564:	4618      	mov	r0, r3
 801d566:	f7ff fed3 	bl	801d310 <lv_tick_elaps>
 801d56a:	6138      	str	r0, [r7, #16]

    a = lv_ll_get_head(&LV_GC_ROOT(_lv_anim_ll));
 801d56c:	4835      	ldr	r0, [pc, #212]	; (801d644 <anim_task+0x114>)
 801d56e:	f000 fc39 	bl	801dde4 <lv_ll_get_head>
 801d572:	6178      	str	r0, [r7, #20]

    while(a != NULL) {
 801d574:	e059      	b.n	801d62a <anim_task+0xfa>
        /*It can be set by `lv_anim_del()` typically in `end_cb`. If set then an animation delete
         * happened in `anim_ready_handler` which could make this linked list reading corrupt
         * because the list is changed meanwhile
         */
        anim_list_changed = false;
 801d576:	4b35      	ldr	r3, [pc, #212]	; (801d64c <anim_task+0x11c>)
 801d578:	2200      	movs	r2, #0
 801d57a:	701a      	strb	r2, [r3, #0]

        if(!a->has_run) {
 801d57c:	697b      	ldr	r3, [r7, #20]
 801d57e:	f893 3020 	ldrb.w	r3, [r3, #32]
 801d582:	f003 0308 	and.w	r3, r3, #8
 801d586:	b2db      	uxtb	r3, r3
 801d588:	2b00      	cmp	r3, #0
 801d58a:	d140      	bne.n	801d60e <anim_task+0xde>
            a->has_run = 1; /*The list readying might be reseted so need to know which anim has run already*/
 801d58c:	697a      	ldr	r2, [r7, #20]
 801d58e:	f892 3020 	ldrb.w	r3, [r2, #32]
 801d592:	f043 0308 	orr.w	r3, r3, #8
 801d596:	f882 3020 	strb.w	r3, [r2, #32]
            a->act_time += elaps;
 801d59a:	697b      	ldr	r3, [r7, #20]
 801d59c:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 801d5a0:	b29a      	uxth	r2, r3
 801d5a2:	693b      	ldr	r3, [r7, #16]
 801d5a4:	b29b      	uxth	r3, r3
 801d5a6:	4413      	add	r3, r2
 801d5a8:	b29b      	uxth	r3, r3
 801d5aa:	b21a      	sxth	r2, r3
 801d5ac:	697b      	ldr	r3, [r7, #20]
 801d5ae:	835a      	strh	r2, [r3, #26]
            if(a->act_time >= 0) {
 801d5b0:	697b      	ldr	r3, [r7, #20]
 801d5b2:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 801d5b6:	2b00      	cmp	r3, #0
 801d5b8:	db29      	blt.n	801d60e <anim_task+0xde>
                if(a->act_time > a->time) a->act_time = a->time;
 801d5ba:	697b      	ldr	r3, [r7, #20]
 801d5bc:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 801d5c0:	461a      	mov	r2, r3
 801d5c2:	697b      	ldr	r3, [r7, #20]
 801d5c4:	8b1b      	ldrh	r3, [r3, #24]
 801d5c6:	429a      	cmp	r2, r3
 801d5c8:	dd04      	ble.n	801d5d4 <anim_task+0xa4>
 801d5ca:	697b      	ldr	r3, [r7, #20]
 801d5cc:	8b1b      	ldrh	r3, [r3, #24]
 801d5ce:	b21a      	sxth	r2, r3
 801d5d0:	697b      	ldr	r3, [r7, #20]
 801d5d2:	835a      	strh	r2, [r3, #26]

                int32_t new_value;
                new_value = a->path_cb(a);
 801d5d4:	697b      	ldr	r3, [r7, #20]
 801d5d6:	689b      	ldr	r3, [r3, #8]
 801d5d8:	6978      	ldr	r0, [r7, #20]
 801d5da:	4798      	blx	r3
 801d5dc:	4603      	mov	r3, r0
 801d5de:	60fb      	str	r3, [r7, #12]

                /*Apply the calculated value*/
                if(a->exec_cb) a->exec_cb(a->var, new_value);
 801d5e0:	697b      	ldr	r3, [r7, #20]
 801d5e2:	685b      	ldr	r3, [r3, #4]
 801d5e4:	2b00      	cmp	r3, #0
 801d5e6:	d007      	beq.n	801d5f8 <anim_task+0xc8>
 801d5e8:	697b      	ldr	r3, [r7, #20]
 801d5ea:	685b      	ldr	r3, [r3, #4]
 801d5ec:	697a      	ldr	r2, [r7, #20]
 801d5ee:	6812      	ldr	r2, [r2, #0]
 801d5f0:	68f9      	ldr	r1, [r7, #12]
 801d5f2:	b209      	sxth	r1, r1
 801d5f4:	4610      	mov	r0, r2
 801d5f6:	4798      	blx	r3

                /*If the time is elapsed the animation is ready*/
                if(a->act_time >= a->time) {
 801d5f8:	697b      	ldr	r3, [r7, #20]
 801d5fa:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 801d5fe:	461a      	mov	r2, r3
 801d600:	697b      	ldr	r3, [r7, #20]
 801d602:	8b1b      	ldrh	r3, [r3, #24]
 801d604:	429a      	cmp	r2, r3
 801d606:	db02      	blt.n	801d60e <anim_task+0xde>
                    anim_ready_handler(a);
 801d608:	6978      	ldr	r0, [r7, #20]
 801d60a:	f000 f821 	bl	801d650 <anim_ready_handler>
            }
        }

        /* If the linked list changed due to anim. delete then it's not safe to continue
         * the reading of the list from here -> start from the head*/
        if(anim_list_changed)
 801d60e:	4b0f      	ldr	r3, [pc, #60]	; (801d64c <anim_task+0x11c>)
 801d610:	781b      	ldrb	r3, [r3, #0]
 801d612:	2b00      	cmp	r3, #0
 801d614:	d004      	beq.n	801d620 <anim_task+0xf0>
            a = lv_ll_get_head(&LV_GC_ROOT(_lv_anim_ll));
 801d616:	480b      	ldr	r0, [pc, #44]	; (801d644 <anim_task+0x114>)
 801d618:	f000 fbe4 	bl	801dde4 <lv_ll_get_head>
 801d61c:	6178      	str	r0, [r7, #20]
 801d61e:	e004      	b.n	801d62a <anim_task+0xfa>
        else
            a = lv_ll_get_next(&LV_GC_ROOT(_lv_anim_ll), a);
 801d620:	6979      	ldr	r1, [r7, #20]
 801d622:	4808      	ldr	r0, [pc, #32]	; (801d644 <anim_task+0x114>)
 801d624:	f000 fc04 	bl	801de30 <lv_ll_get_next>
 801d628:	6178      	str	r0, [r7, #20]
    while(a != NULL) {
 801d62a:	697b      	ldr	r3, [r7, #20]
 801d62c:	2b00      	cmp	r3, #0
 801d62e:	d1a2      	bne.n	801d576 <anim_task+0x46>
    }

    last_task_run = lv_tick_get();
 801d630:	f7ff fe54 	bl	801d2dc <lv_tick_get>
 801d634:	4603      	mov	r3, r0
 801d636:	4a04      	ldr	r2, [pc, #16]	; (801d648 <anim_task+0x118>)
 801d638:	6013      	str	r3, [r2, #0]
}
 801d63a:	bf00      	nop
 801d63c:	3718      	adds	r7, #24
 801d63e:	46bd      	mov	sp, r7
 801d640:	bd80      	pop	{r7, pc}
 801d642:	bf00      	nop
 801d644:	2406366c 	.word	0x2406366c
 801d648:	240623e0 	.word	0x240623e0
 801d64c:	240623e4 	.word	0x240623e4

0801d650 <anim_ready_handler>:
 * e.g. repeat, play back, delete etc.
 * @param a pointer to an animation descriptor
 * @return true: animation delete occurred nnd the `LV_GC_ROOT(_lv_anim_ll)` has changed
 * */
static bool anim_ready_handler(lv_anim_t * a)
{
 801d650:	b580      	push	{r7, lr}
 801d652:	b08c      	sub	sp, #48	; 0x30
 801d654:	af00      	add	r7, sp, #0
 801d656:	6078      	str	r0, [r7, #4]

    /*Delete the animation if
     * - no repeat and no play back (simple one shot animation)
     * - no repeat, play back is enabled and play back is ready */
    if((a->repeat == 0 && a->playback == 0) || (a->repeat == 0 && a->playback == 1 && a->playback_now == 1)) {
 801d658:	687b      	ldr	r3, [r7, #4]
 801d65a:	f893 3020 	ldrb.w	r3, [r3, #32]
 801d65e:	f003 0302 	and.w	r3, r3, #2
 801d662:	b2db      	uxtb	r3, r3
 801d664:	2b00      	cmp	r3, #0
 801d666:	d107      	bne.n	801d678 <anim_ready_handler+0x28>
 801d668:	687b      	ldr	r3, [r7, #4]
 801d66a:	f893 3020 	ldrb.w	r3, [r3, #32]
 801d66e:	f003 0301 	and.w	r3, r3, #1
 801d672:	b2db      	uxtb	r3, r3
 801d674:	2b00      	cmp	r3, #0
 801d676:	d017      	beq.n	801d6a8 <anim_ready_handler+0x58>
 801d678:	687b      	ldr	r3, [r7, #4]
 801d67a:	f893 3020 	ldrb.w	r3, [r3, #32]
 801d67e:	f003 0302 	and.w	r3, r3, #2
 801d682:	b2db      	uxtb	r3, r3
 801d684:	2b00      	cmp	r3, #0
 801d686:	d129      	bne.n	801d6dc <anim_ready_handler+0x8c>
 801d688:	687b      	ldr	r3, [r7, #4]
 801d68a:	f893 3020 	ldrb.w	r3, [r3, #32]
 801d68e:	f003 0301 	and.w	r3, r3, #1
 801d692:	b2db      	uxtb	r3, r3
 801d694:	2b00      	cmp	r3, #0
 801d696:	d021      	beq.n	801d6dc <anim_ready_handler+0x8c>
 801d698:	687b      	ldr	r3, [r7, #4]
 801d69a:	f893 3020 	ldrb.w	r3, [r3, #32]
 801d69e:	f003 0304 	and.w	r3, r3, #4
 801d6a2:	b2db      	uxtb	r3, r3
 801d6a4:	2b00      	cmp	r3, #0
 801d6a6:	d019      	beq.n	801d6dc <anim_ready_handler+0x8c>

        /*Create copy from the animation and delete the animation from the list.
         * This way the `ready_cb` will see the animations like it's animation is ready deleted*/
        lv_anim_t a_tmp;
        memcpy(&a_tmp, a, sizeof(lv_anim_t));
 801d6a8:	f107 0308 	add.w	r3, r7, #8
 801d6ac:	2224      	movs	r2, #36	; 0x24
 801d6ae:	6879      	ldr	r1, [r7, #4]
 801d6b0:	4618      	mov	r0, r3
 801d6b2:	f004 fad1 	bl	8021c58 <memcpy>
        lv_ll_rem(&LV_GC_ROOT(_lv_anim_ll), a);
 801d6b6:	6879      	ldr	r1, [r7, #4]
 801d6b8:	4829      	ldr	r0, [pc, #164]	; (801d760 <anim_ready_handler+0x110>)
 801d6ba:	f000 fae5 	bl	801dc88 <lv_ll_rem>
        lv_mem_free(a);
 801d6be:	6878      	ldr	r0, [r7, #4]
 801d6c0:	f000 fd36 	bl	801e130 <lv_mem_free>
        anim_list_changed = true;
 801d6c4:	4b27      	ldr	r3, [pc, #156]	; (801d764 <anim_ready_handler+0x114>)
 801d6c6:	2201      	movs	r2, #1
 801d6c8:	701a      	strb	r2, [r3, #0]

        /* Call the callback function at the end*/
        if(a_tmp.ready_cb != NULL) a_tmp.ready_cb(&a_tmp);
 801d6ca:	697b      	ldr	r3, [r7, #20]
 801d6cc:	2b00      	cmp	r3, #0
 801d6ce:	d040      	beq.n	801d752 <anim_ready_handler+0x102>
 801d6d0:	697b      	ldr	r3, [r7, #20]
 801d6d2:	f107 0208 	add.w	r2, r7, #8
 801d6d6:	4610      	mov	r0, r2
 801d6d8:	4798      	blx	r3
    if((a->repeat == 0 && a->playback == 0) || (a->repeat == 0 && a->playback == 1 && a->playback_now == 1)) {
 801d6da:	e03a      	b.n	801d752 <anim_ready_handler+0x102>
    }
    /*If the animation is not deleted then restart it*/
    else {
        a->act_time = -a->repeat_pause; /*Restart the animation*/
 801d6dc:	687b      	ldr	r3, [r7, #4]
 801d6de:	8bdb      	ldrh	r3, [r3, #30]
 801d6e0:	425b      	negs	r3, r3
 801d6e2:	b29b      	uxth	r3, r3
 801d6e4:	b21a      	sxth	r2, r3
 801d6e6:	687b      	ldr	r3, [r7, #4]
 801d6e8:	835a      	strh	r2, [r3, #26]
        /*Swap the start and end values in play back mode*/
        if(a->playback != 0) {
 801d6ea:	687b      	ldr	r3, [r7, #4]
 801d6ec:	f893 3020 	ldrb.w	r3, [r3, #32]
 801d6f0:	f003 0301 	and.w	r3, r3, #1
 801d6f4:	b2db      	uxtb	r3, r3
 801d6f6:	2b00      	cmp	r3, #0
 801d6f8:	d02c      	beq.n	801d754 <anim_ready_handler+0x104>
            /*If now turning back use the 'playback_pause*/
            if(a->playback_now == 0) a->act_time = -a->playback_pause;
 801d6fa:	687b      	ldr	r3, [r7, #4]
 801d6fc:	f893 3020 	ldrb.w	r3, [r3, #32]
 801d700:	f003 0304 	and.w	r3, r3, #4
 801d704:	b2db      	uxtb	r3, r3
 801d706:	2b00      	cmp	r3, #0
 801d708:	d106      	bne.n	801d718 <anim_ready_handler+0xc8>
 801d70a:	687b      	ldr	r3, [r7, #4]
 801d70c:	8b9b      	ldrh	r3, [r3, #28]
 801d70e:	425b      	negs	r3, r3
 801d710:	b29b      	uxth	r3, r3
 801d712:	b21a      	sxth	r2, r3
 801d714:	687b      	ldr	r3, [r7, #4]
 801d716:	835a      	strh	r2, [r3, #26]

            /*Toggle the play back state*/
            a->playback_now = a->playback_now == 0 ? 1 : 0;
 801d718:	687b      	ldr	r3, [r7, #4]
 801d71a:	f893 3020 	ldrb.w	r3, [r3, #32]
 801d71e:	f003 0304 	and.w	r3, r3, #4
 801d722:	b2db      	uxtb	r3, r3
 801d724:	2b00      	cmp	r3, #0
 801d726:	bf0c      	ite	eq
 801d728:	2301      	moveq	r3, #1
 801d72a:	2300      	movne	r3, #0
 801d72c:	b2d9      	uxtb	r1, r3
 801d72e:	687a      	ldr	r2, [r7, #4]
 801d730:	f892 3020 	ldrb.w	r3, [r2, #32]
 801d734:	f361 0382 	bfi	r3, r1, #2, #1
 801d738:	f882 3020 	strb.w	r3, [r2, #32]
            /*Swap the start and end values*/
            int32_t tmp;
            tmp      = a->start;
 801d73c:	687b      	ldr	r3, [r7, #4]
 801d73e:	691b      	ldr	r3, [r3, #16]
 801d740:	62fb      	str	r3, [r7, #44]	; 0x2c
            a->start = a->end;
 801d742:	687b      	ldr	r3, [r7, #4]
 801d744:	695a      	ldr	r2, [r3, #20]
 801d746:	687b      	ldr	r3, [r7, #4]
 801d748:	611a      	str	r2, [r3, #16]
            a->end   = tmp;
 801d74a:	687b      	ldr	r3, [r7, #4]
 801d74c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801d74e:	615a      	str	r2, [r3, #20]
 801d750:	e000      	b.n	801d754 <anim_ready_handler+0x104>
    if((a->repeat == 0 && a->playback == 0) || (a->repeat == 0 && a->playback == 1 && a->playback_now == 1)) {
 801d752:	bf00      	nop
        }
    }

    return anim_list_changed;
 801d754:	4b03      	ldr	r3, [pc, #12]	; (801d764 <anim_ready_handler+0x114>)
 801d756:	781b      	ldrb	r3, [r3, #0]
}
 801d758:	4618      	mov	r0, r3
 801d75a:	3730      	adds	r7, #48	; 0x30
 801d75c:	46bd      	mov	sp, r7
 801d75e:	bd80      	pop	{r7, pc}
 801d760:	2406366c 	.word	0x2406366c
 801d764:	240623e4 	.word	0x240623e4

0801d768 <lv_area_set>:
 * @param y1 top coordinate of the area
 * @param x2 right coordinate of the area
 * @param y2 bottom coordinate of the area
 */
void lv_area_set(lv_area_t * area_p, lv_coord_t x1, lv_coord_t y1, lv_coord_t x2, lv_coord_t y2)
{
 801d768:	b480      	push	{r7}
 801d76a:	b085      	sub	sp, #20
 801d76c:	af00      	add	r7, sp, #0
 801d76e:	60f8      	str	r0, [r7, #12]
 801d770:	4608      	mov	r0, r1
 801d772:	4611      	mov	r1, r2
 801d774:	461a      	mov	r2, r3
 801d776:	4603      	mov	r3, r0
 801d778:	817b      	strh	r3, [r7, #10]
 801d77a:	460b      	mov	r3, r1
 801d77c:	813b      	strh	r3, [r7, #8]
 801d77e:	4613      	mov	r3, r2
 801d780:	80fb      	strh	r3, [r7, #6]
    area_p->x1 = x1;
 801d782:	68fb      	ldr	r3, [r7, #12]
 801d784:	897a      	ldrh	r2, [r7, #10]
 801d786:	801a      	strh	r2, [r3, #0]
    area_p->y1 = y1;
 801d788:	68fb      	ldr	r3, [r7, #12]
 801d78a:	893a      	ldrh	r2, [r7, #8]
 801d78c:	805a      	strh	r2, [r3, #2]
    area_p->x2 = x2;
 801d78e:	68fb      	ldr	r3, [r7, #12]
 801d790:	88fa      	ldrh	r2, [r7, #6]
 801d792:	809a      	strh	r2, [r3, #4]
    area_p->y2 = y2;
 801d794:	68fb      	ldr	r3, [r7, #12]
 801d796:	8b3a      	ldrh	r2, [r7, #24]
 801d798:	80da      	strh	r2, [r3, #6]
}
 801d79a:	bf00      	nop
 801d79c:	3714      	adds	r7, #20
 801d79e:	46bd      	mov	sp, r7
 801d7a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d7a4:	4770      	bx	lr

0801d7a6 <lv_area_set_height>:
 * Set the height of an area
 * @param area_p pointer to an area
 * @param h the new height of the area (h == 1 makes y1 == y2)
 */
void lv_area_set_height(lv_area_t * area_p, lv_coord_t h)
{
 801d7a6:	b480      	push	{r7}
 801d7a8:	b083      	sub	sp, #12
 801d7aa:	af00      	add	r7, sp, #0
 801d7ac:	6078      	str	r0, [r7, #4]
 801d7ae:	460b      	mov	r3, r1
 801d7b0:	807b      	strh	r3, [r7, #2]
    area_p->y2 = area_p->y1 + h - 1;
 801d7b2:	687b      	ldr	r3, [r7, #4]
 801d7b4:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801d7b8:	b29a      	uxth	r2, r3
 801d7ba:	887b      	ldrh	r3, [r7, #2]
 801d7bc:	4413      	add	r3, r2
 801d7be:	b29b      	uxth	r3, r3
 801d7c0:	3b01      	subs	r3, #1
 801d7c2:	b29b      	uxth	r3, r3
 801d7c4:	b21a      	sxth	r2, r3
 801d7c6:	687b      	ldr	r3, [r7, #4]
 801d7c8:	80da      	strh	r2, [r3, #6]
}
 801d7ca:	bf00      	nop
 801d7cc:	370c      	adds	r7, #12
 801d7ce:	46bd      	mov	sp, r7
 801d7d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d7d4:	4770      	bx	lr

0801d7d6 <lv_area_get_size>:
 * Return with area of an area (x * y)
 * @param area_p pointer to an area
 * @return size of area
 */
uint32_t lv_area_get_size(const lv_area_t * area_p)
{
 801d7d6:	b480      	push	{r7}
 801d7d8:	b085      	sub	sp, #20
 801d7da:	af00      	add	r7, sp, #0
 801d7dc:	6078      	str	r0, [r7, #4]
    uint32_t size;

    size = (uint32_t)(area_p->x2 - area_p->x1 + 1) * (area_p->y2 - area_p->y1 + 1);
 801d7de:	687b      	ldr	r3, [r7, #4]
 801d7e0:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801d7e4:	461a      	mov	r2, r3
 801d7e6:	687b      	ldr	r3, [r7, #4]
 801d7e8:	f9b3 3000 	ldrsh.w	r3, [r3]
 801d7ec:	1ad3      	subs	r3, r2, r3
 801d7ee:	3301      	adds	r3, #1
 801d7f0:	461a      	mov	r2, r3
 801d7f2:	687b      	ldr	r3, [r7, #4]
 801d7f4:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801d7f8:	4619      	mov	r1, r3
 801d7fa:	687b      	ldr	r3, [r7, #4]
 801d7fc:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801d800:	1acb      	subs	r3, r1, r3
 801d802:	3301      	adds	r3, #1
 801d804:	fb03 f302 	mul.w	r3, r3, r2
 801d808:	60fb      	str	r3, [r7, #12]

    return size;
 801d80a:	68fb      	ldr	r3, [r7, #12]
}
 801d80c:	4618      	mov	r0, r3
 801d80e:	3714      	adds	r7, #20
 801d810:	46bd      	mov	sp, r7
 801d812:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d816:	4770      	bx	lr

0801d818 <lv_area_intersect>:
 * @param a1_p pointer to the first area
 * @param a2_p pointer to the second area
 * @return false: the two area has NO common parts, res_p is invalid
 */
bool lv_area_intersect(lv_area_t * res_p, const lv_area_t * a1_p, const lv_area_t * a2_p)
{
 801d818:	b480      	push	{r7}
 801d81a:	b087      	sub	sp, #28
 801d81c:	af00      	add	r7, sp, #0
 801d81e:	60f8      	str	r0, [r7, #12]
 801d820:	60b9      	str	r1, [r7, #8]
 801d822:	607a      	str	r2, [r7, #4]
    /* Get the smaller area from 'a1_p' and 'a2_p' */
    res_p->x1 = LV_MATH_MAX(a1_p->x1, a2_p->x1);
 801d824:	687b      	ldr	r3, [r7, #4]
 801d826:	f9b3 2000 	ldrsh.w	r2, [r3]
 801d82a:	68bb      	ldr	r3, [r7, #8]
 801d82c:	f9b3 3000 	ldrsh.w	r3, [r3]
 801d830:	4293      	cmp	r3, r2
 801d832:	bfb8      	it	lt
 801d834:	4613      	movlt	r3, r2
 801d836:	b21a      	sxth	r2, r3
 801d838:	68fb      	ldr	r3, [r7, #12]
 801d83a:	801a      	strh	r2, [r3, #0]
    res_p->y1 = LV_MATH_MAX(a1_p->y1, a2_p->y1);
 801d83c:	687b      	ldr	r3, [r7, #4]
 801d83e:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 801d842:	68bb      	ldr	r3, [r7, #8]
 801d844:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801d848:	4293      	cmp	r3, r2
 801d84a:	bfb8      	it	lt
 801d84c:	4613      	movlt	r3, r2
 801d84e:	b21a      	sxth	r2, r3
 801d850:	68fb      	ldr	r3, [r7, #12]
 801d852:	805a      	strh	r2, [r3, #2]
    res_p->x2 = LV_MATH_MIN(a1_p->x2, a2_p->x2);
 801d854:	687b      	ldr	r3, [r7, #4]
 801d856:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
 801d85a:	68bb      	ldr	r3, [r7, #8]
 801d85c:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801d860:	4293      	cmp	r3, r2
 801d862:	bfa8      	it	ge
 801d864:	4613      	movge	r3, r2
 801d866:	b21a      	sxth	r2, r3
 801d868:	68fb      	ldr	r3, [r7, #12]
 801d86a:	809a      	strh	r2, [r3, #4]
    res_p->y2 = LV_MATH_MIN(a1_p->y2, a2_p->y2);
 801d86c:	687b      	ldr	r3, [r7, #4]
 801d86e:	f9b3 2006 	ldrsh.w	r2, [r3, #6]
 801d872:	68bb      	ldr	r3, [r7, #8]
 801d874:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801d878:	4293      	cmp	r3, r2
 801d87a:	bfa8      	it	ge
 801d87c:	4613      	movge	r3, r2
 801d87e:	b21a      	sxth	r2, r3
 801d880:	68fb      	ldr	r3, [r7, #12]
 801d882:	80da      	strh	r2, [r3, #6]

    /*If x1 or y1 greater then x2 or y2 then the areas union is empty*/
    bool union_ok = true;
 801d884:	2301      	movs	r3, #1
 801d886:	75fb      	strb	r3, [r7, #23]
    if((res_p->x1 > res_p->x2) || (res_p->y1 > res_p->y2)) {
 801d888:	68fb      	ldr	r3, [r7, #12]
 801d88a:	f9b3 2000 	ldrsh.w	r2, [r3]
 801d88e:	68fb      	ldr	r3, [r7, #12]
 801d890:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801d894:	429a      	cmp	r2, r3
 801d896:	dc07      	bgt.n	801d8a8 <lv_area_intersect+0x90>
 801d898:	68fb      	ldr	r3, [r7, #12]
 801d89a:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 801d89e:	68fb      	ldr	r3, [r7, #12]
 801d8a0:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801d8a4:	429a      	cmp	r2, r3
 801d8a6:	dd01      	ble.n	801d8ac <lv_area_intersect+0x94>
        union_ok = false;
 801d8a8:	2300      	movs	r3, #0
 801d8aa:	75fb      	strb	r3, [r7, #23]
    }

    return union_ok;
 801d8ac:	7dfb      	ldrb	r3, [r7, #23]
}
 801d8ae:	4618      	mov	r0, r3
 801d8b0:	371c      	adds	r7, #28
 801d8b2:	46bd      	mov	sp, r7
 801d8b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d8b8:	4770      	bx	lr

0801d8ba <lv_area_join>:
 * @param res_p pointer to an area, the result will be stored here
 * @param a1_p pointer to the first area
 * @param a2_p pointer to the second area
 */
void lv_area_join(lv_area_t * a_res_p, const lv_area_t * a1_p, const lv_area_t * a2_p)
{
 801d8ba:	b480      	push	{r7}
 801d8bc:	b085      	sub	sp, #20
 801d8be:	af00      	add	r7, sp, #0
 801d8c0:	60f8      	str	r0, [r7, #12]
 801d8c2:	60b9      	str	r1, [r7, #8]
 801d8c4:	607a      	str	r2, [r7, #4]
    a_res_p->x1 = LV_MATH_MIN(a1_p->x1, a2_p->x1);
 801d8c6:	687b      	ldr	r3, [r7, #4]
 801d8c8:	f9b3 2000 	ldrsh.w	r2, [r3]
 801d8cc:	68bb      	ldr	r3, [r7, #8]
 801d8ce:	f9b3 3000 	ldrsh.w	r3, [r3]
 801d8d2:	4293      	cmp	r3, r2
 801d8d4:	bfa8      	it	ge
 801d8d6:	4613      	movge	r3, r2
 801d8d8:	b21a      	sxth	r2, r3
 801d8da:	68fb      	ldr	r3, [r7, #12]
 801d8dc:	801a      	strh	r2, [r3, #0]
    a_res_p->y1 = LV_MATH_MIN(a1_p->y1, a2_p->y1);
 801d8de:	687b      	ldr	r3, [r7, #4]
 801d8e0:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 801d8e4:	68bb      	ldr	r3, [r7, #8]
 801d8e6:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801d8ea:	4293      	cmp	r3, r2
 801d8ec:	bfa8      	it	ge
 801d8ee:	4613      	movge	r3, r2
 801d8f0:	b21a      	sxth	r2, r3
 801d8f2:	68fb      	ldr	r3, [r7, #12]
 801d8f4:	805a      	strh	r2, [r3, #2]
    a_res_p->x2 = LV_MATH_MAX(a1_p->x2, a2_p->x2);
 801d8f6:	687b      	ldr	r3, [r7, #4]
 801d8f8:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
 801d8fc:	68bb      	ldr	r3, [r7, #8]
 801d8fe:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801d902:	4293      	cmp	r3, r2
 801d904:	bfb8      	it	lt
 801d906:	4613      	movlt	r3, r2
 801d908:	b21a      	sxth	r2, r3
 801d90a:	68fb      	ldr	r3, [r7, #12]
 801d90c:	809a      	strh	r2, [r3, #4]
    a_res_p->y2 = LV_MATH_MAX(a1_p->y2, a2_p->y2);
 801d90e:	687b      	ldr	r3, [r7, #4]
 801d910:	f9b3 2006 	ldrsh.w	r2, [r3, #6]
 801d914:	68bb      	ldr	r3, [r7, #8]
 801d916:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801d91a:	4293      	cmp	r3, r2
 801d91c:	bfb8      	it	lt
 801d91e:	4613      	movlt	r3, r2
 801d920:	b21a      	sxth	r2, r3
 801d922:	68fb      	ldr	r3, [r7, #12]
 801d924:	80da      	strh	r2, [r3, #6]
}
 801d926:	bf00      	nop
 801d928:	3714      	adds	r7, #20
 801d92a:	46bd      	mov	sp, r7
 801d92c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d930:	4770      	bx	lr

0801d932 <lv_area_is_on>:
 * @param a1_p pointer to an area.
 * @param a2_p pointer to an other area
 * @return false: a1_p and a2_p has no common parts
 */
bool lv_area_is_on(const lv_area_t * a1_p, const lv_area_t * a2_p)
{
 801d932:	b480      	push	{r7}
 801d934:	b083      	sub	sp, #12
 801d936:	af00      	add	r7, sp, #0
 801d938:	6078      	str	r0, [r7, #4]
 801d93a:	6039      	str	r1, [r7, #0]
    if((a1_p->x1 <= a2_p->x2) && (a1_p->x2 >= a2_p->x1) && (a1_p->y1 <= a2_p->y2) && (a1_p->y2 >= a2_p->y1)) {
 801d93c:	687b      	ldr	r3, [r7, #4]
 801d93e:	f9b3 2000 	ldrsh.w	r2, [r3]
 801d942:	683b      	ldr	r3, [r7, #0]
 801d944:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801d948:	429a      	cmp	r2, r3
 801d94a:	dc19      	bgt.n	801d980 <lv_area_is_on+0x4e>
 801d94c:	687b      	ldr	r3, [r7, #4]
 801d94e:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
 801d952:	683b      	ldr	r3, [r7, #0]
 801d954:	f9b3 3000 	ldrsh.w	r3, [r3]
 801d958:	429a      	cmp	r2, r3
 801d95a:	db11      	blt.n	801d980 <lv_area_is_on+0x4e>
 801d95c:	687b      	ldr	r3, [r7, #4]
 801d95e:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 801d962:	683b      	ldr	r3, [r7, #0]
 801d964:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801d968:	429a      	cmp	r2, r3
 801d96a:	dc09      	bgt.n	801d980 <lv_area_is_on+0x4e>
 801d96c:	687b      	ldr	r3, [r7, #4]
 801d96e:	f9b3 2006 	ldrsh.w	r2, [r3, #6]
 801d972:	683b      	ldr	r3, [r7, #0]
 801d974:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801d978:	429a      	cmp	r2, r3
 801d97a:	db01      	blt.n	801d980 <lv_area_is_on+0x4e>
        return true;
 801d97c:	2301      	movs	r3, #1
 801d97e:	e000      	b.n	801d982 <lv_area_is_on+0x50>
    } else {
        return false;
 801d980:	2300      	movs	r3, #0
    }
}
 801d982:	4618      	mov	r0, r3
 801d984:	370c      	adds	r7, #12
 801d986:	46bd      	mov	sp, r7
 801d988:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d98c:	4770      	bx	lr

0801d98e <lv_area_is_in>:
 * @param ain_p pointer to an area which could be in 'aholder_p'
 * @param aholder pointer to an area which could involve 'ain_p'
 * @return
 */
bool lv_area_is_in(const lv_area_t * ain_p, const lv_area_t * aholder_p)
{
 801d98e:	b480      	push	{r7}
 801d990:	b085      	sub	sp, #20
 801d992:	af00      	add	r7, sp, #0
 801d994:	6078      	str	r0, [r7, #4]
 801d996:	6039      	str	r1, [r7, #0]
    bool is_in = false;
 801d998:	2300      	movs	r3, #0
 801d99a:	73fb      	strb	r3, [r7, #15]

    if(ain_p->x1 >= aholder_p->x1 && ain_p->y1 >= aholder_p->y1 && ain_p->x2 <= aholder_p->x2 &&
 801d99c:	687b      	ldr	r3, [r7, #4]
 801d99e:	f9b3 2000 	ldrsh.w	r2, [r3]
 801d9a2:	683b      	ldr	r3, [r7, #0]
 801d9a4:	f9b3 3000 	ldrsh.w	r3, [r3]
 801d9a8:	429a      	cmp	r2, r3
 801d9aa:	db19      	blt.n	801d9e0 <lv_area_is_in+0x52>
 801d9ac:	687b      	ldr	r3, [r7, #4]
 801d9ae:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 801d9b2:	683b      	ldr	r3, [r7, #0]
 801d9b4:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801d9b8:	429a      	cmp	r2, r3
 801d9ba:	db11      	blt.n	801d9e0 <lv_area_is_in+0x52>
 801d9bc:	687b      	ldr	r3, [r7, #4]
 801d9be:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
 801d9c2:	683b      	ldr	r3, [r7, #0]
 801d9c4:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801d9c8:	429a      	cmp	r2, r3
 801d9ca:	dc09      	bgt.n	801d9e0 <lv_area_is_in+0x52>
       ain_p->y2 <= aholder_p->y2) {
 801d9cc:	687b      	ldr	r3, [r7, #4]
 801d9ce:	f9b3 2006 	ldrsh.w	r2, [r3, #6]
 801d9d2:	683b      	ldr	r3, [r7, #0]
 801d9d4:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
    if(ain_p->x1 >= aholder_p->x1 && ain_p->y1 >= aholder_p->y1 && ain_p->x2 <= aholder_p->x2 &&
 801d9d8:	429a      	cmp	r2, r3
 801d9da:	dc01      	bgt.n	801d9e0 <lv_area_is_in+0x52>
        is_in = true;
 801d9dc:	2301      	movs	r3, #1
 801d9de:	73fb      	strb	r3, [r7, #15]
    }

    return is_in;
 801d9e0:	7bfb      	ldrb	r3, [r7, #15]
}
 801d9e2:	4618      	mov	r0, r3
 801d9e4:	3714      	adds	r7, #20
 801d9e6:	46bd      	mov	sp, r7
 801d9e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d9ec:	4770      	bx	lr

0801d9ee <lv_circ_init>:
 * @param c pointer to a point. The coordinates will be calculated here
 * @param tmp point to a variable. It will store temporary data
 * @param radius radius of the circle
 */
void lv_circ_init(lv_point_t * c, lv_coord_t * tmp, lv_coord_t radius)
{
 801d9ee:	b480      	push	{r7}
 801d9f0:	b085      	sub	sp, #20
 801d9f2:	af00      	add	r7, sp, #0
 801d9f4:	60f8      	str	r0, [r7, #12]
 801d9f6:	60b9      	str	r1, [r7, #8]
 801d9f8:	4613      	mov	r3, r2
 801d9fa:	80fb      	strh	r3, [r7, #6]
    c->x = radius;
 801d9fc:	68fb      	ldr	r3, [r7, #12]
 801d9fe:	88fa      	ldrh	r2, [r7, #6]
 801da00:	801a      	strh	r2, [r3, #0]
    c->y = 0;
 801da02:	68fb      	ldr	r3, [r7, #12]
 801da04:	2200      	movs	r2, #0
 801da06:	805a      	strh	r2, [r3, #2]
    *tmp = 1 - radius;
 801da08:	88fb      	ldrh	r3, [r7, #6]
 801da0a:	f1c3 0301 	rsb	r3, r3, #1
 801da0e:	b29b      	uxth	r3, r3
 801da10:	b21a      	sxth	r2, r3
 801da12:	68bb      	ldr	r3, [r7, #8]
 801da14:	801a      	strh	r2, [r3, #0]
}
 801da16:	bf00      	nop
 801da18:	3714      	adds	r7, #20
 801da1a:	46bd      	mov	sp, r7
 801da1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801da20:	4770      	bx	lr

0801da22 <lv_circ_cont>:
 * Test the circle drawing is ready or not
 * @param c same as in circ_init
 * @return true if the circle is not ready yet
 */
bool lv_circ_cont(lv_point_t * c)
{
 801da22:	b480      	push	{r7}
 801da24:	b083      	sub	sp, #12
 801da26:	af00      	add	r7, sp, #0
 801da28:	6078      	str	r0, [r7, #4]
    return c->y <= c->x ? true : false;
 801da2a:	687b      	ldr	r3, [r7, #4]
 801da2c:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 801da30:	687b      	ldr	r3, [r7, #4]
 801da32:	f9b3 3000 	ldrsh.w	r3, [r3]
 801da36:	429a      	cmp	r2, r3
 801da38:	bfd4      	ite	le
 801da3a:	2301      	movle	r3, #1
 801da3c:	2300      	movgt	r3, #0
 801da3e:	b2db      	uxtb	r3, r3
}
 801da40:	4618      	mov	r0, r3
 801da42:	370c      	adds	r7, #12
 801da44:	46bd      	mov	sp, r7
 801da46:	f85d 7b04 	ldr.w	r7, [sp], #4
 801da4a:	4770      	bx	lr

0801da4c <lv_circ_next>:
 * Get the next point from the circle
 * @param c same as in circ_init. The next point stored here.
 * @param tmp same as in circ_init.
 */
void lv_circ_next(lv_point_t * c, lv_coord_t * tmp)
{
 801da4c:	b480      	push	{r7}
 801da4e:	b083      	sub	sp, #12
 801da50:	af00      	add	r7, sp, #0
 801da52:	6078      	str	r0, [r7, #4]
 801da54:	6039      	str	r1, [r7, #0]
    c->y++;
 801da56:	687b      	ldr	r3, [r7, #4]
 801da58:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801da5c:	b29b      	uxth	r3, r3
 801da5e:	3301      	adds	r3, #1
 801da60:	b29b      	uxth	r3, r3
 801da62:	b21a      	sxth	r2, r3
 801da64:	687b      	ldr	r3, [r7, #4]
 801da66:	805a      	strh	r2, [r3, #2]

    if(*tmp <= 0) {
 801da68:	683b      	ldr	r3, [r7, #0]
 801da6a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801da6e:	2b00      	cmp	r3, #0
 801da70:	dc11      	bgt.n	801da96 <lv_circ_next+0x4a>
        (*tmp) += 2 * c->y + 1; /*Change in decision criterion for y -> y+1*/
 801da72:	683b      	ldr	r3, [r7, #0]
 801da74:	f9b3 3000 	ldrsh.w	r3, [r3]
 801da78:	b29a      	uxth	r2, r3
 801da7a:	687b      	ldr	r3, [r7, #4]
 801da7c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801da80:	b29b      	uxth	r3, r3
 801da82:	005b      	lsls	r3, r3, #1
 801da84:	b29b      	uxth	r3, r3
 801da86:	4413      	add	r3, r2
 801da88:	b29b      	uxth	r3, r3
 801da8a:	3301      	adds	r3, #1
 801da8c:	b29b      	uxth	r3, r3
 801da8e:	b21a      	sxth	r2, r3
 801da90:	683b      	ldr	r3, [r7, #0]
 801da92:	801a      	strh	r2, [r3, #0]
    } else {
        c->x--;
        (*tmp) += 2 * (c->y - c->x) + 1; /*Change for y -> y+1, x -> x-1*/
    }
}
 801da94:	e01e      	b.n	801dad4 <lv_circ_next+0x88>
        c->x--;
 801da96:	687b      	ldr	r3, [r7, #4]
 801da98:	f9b3 3000 	ldrsh.w	r3, [r3]
 801da9c:	b29b      	uxth	r3, r3
 801da9e:	3b01      	subs	r3, #1
 801daa0:	b29b      	uxth	r3, r3
 801daa2:	b21a      	sxth	r2, r3
 801daa4:	687b      	ldr	r3, [r7, #4]
 801daa6:	801a      	strh	r2, [r3, #0]
        (*tmp) += 2 * (c->y - c->x) + 1; /*Change for y -> y+1, x -> x-1*/
 801daa8:	683b      	ldr	r3, [r7, #0]
 801daaa:	f9b3 3000 	ldrsh.w	r3, [r3]
 801daae:	b29a      	uxth	r2, r3
 801dab0:	687b      	ldr	r3, [r7, #4]
 801dab2:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801dab6:	4619      	mov	r1, r3
 801dab8:	687b      	ldr	r3, [r7, #4]
 801daba:	f9b3 3000 	ldrsh.w	r3, [r3]
 801dabe:	1acb      	subs	r3, r1, r3
 801dac0:	b29b      	uxth	r3, r3
 801dac2:	005b      	lsls	r3, r3, #1
 801dac4:	b29b      	uxth	r3, r3
 801dac6:	4413      	add	r3, r2
 801dac8:	b29b      	uxth	r3, r3
 801daca:	3301      	adds	r3, #1
 801dacc:	b29b      	uxth	r3, r3
 801dace:	b21a      	sxth	r2, r3
 801dad0:	683b      	ldr	r3, [r7, #0]
 801dad2:	801a      	strh	r2, [r3, #0]
}
 801dad4:	bf00      	nop
 801dad6:	370c      	adds	r7, #12
 801dad8:	46bd      	mov	sp, r7
 801dada:	f85d 7b04 	ldr.w	r7, [sp], #4
 801dade:	4770      	bx	lr

0801dae0 <lv_ll_init>:
 * Initialize linked list
 * @param ll_dsc pointer to ll_dsc variable
 * @param node_size the size of 1 node in bytes
 */
void lv_ll_init(lv_ll_t * ll_p, uint32_t node_size)
{
 801dae0:	b480      	push	{r7}
 801dae2:	b083      	sub	sp, #12
 801dae4:	af00      	add	r7, sp, #0
 801dae6:	6078      	str	r0, [r7, #4]
 801dae8:	6039      	str	r1, [r7, #0]
    ll_p->head = NULL;
 801daea:	687b      	ldr	r3, [r7, #4]
 801daec:	2200      	movs	r2, #0
 801daee:	605a      	str	r2, [r3, #4]
    ll_p->tail = NULL;
 801daf0:	687b      	ldr	r3, [r7, #4]
 801daf2:	2200      	movs	r2, #0
 801daf4:	609a      	str	r2, [r3, #8]
        node_size = node_size & (~0x7);
        node_size += 8;
    }
#else
    /*Round the size up to 4*/
    if(node_size & 0x3) {
 801daf6:	683b      	ldr	r3, [r7, #0]
 801daf8:	f003 0303 	and.w	r3, r3, #3
 801dafc:	2b00      	cmp	r3, #0
 801dafe:	d006      	beq.n	801db0e <lv_ll_init+0x2e>
        node_size = node_size & (~0x3);
 801db00:	683b      	ldr	r3, [r7, #0]
 801db02:	f023 0303 	bic.w	r3, r3, #3
 801db06:	603b      	str	r3, [r7, #0]
        node_size += 4;
 801db08:	683b      	ldr	r3, [r7, #0]
 801db0a:	3304      	adds	r3, #4
 801db0c:	603b      	str	r3, [r7, #0]
    }
#endif

    ll_p->n_size = node_size;
 801db0e:	687b      	ldr	r3, [r7, #4]
 801db10:	683a      	ldr	r2, [r7, #0]
 801db12:	601a      	str	r2, [r3, #0]
}
 801db14:	bf00      	nop
 801db16:	370c      	adds	r7, #12
 801db18:	46bd      	mov	sp, r7
 801db1a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801db1e:	4770      	bx	lr

0801db20 <lv_ll_ins_head>:
 * Add a new head to a linked list
 * @param ll_p pointer to linked list
 * @return pointer to the new head
 */
void * lv_ll_ins_head(lv_ll_t * ll_p)
{
 801db20:	b580      	push	{r7, lr}
 801db22:	b084      	sub	sp, #16
 801db24:	af00      	add	r7, sp, #0
 801db26:	6078      	str	r0, [r7, #4]
    lv_ll_node_t * n_new;

    n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
 801db28:	687b      	ldr	r3, [r7, #4]
 801db2a:	681b      	ldr	r3, [r3, #0]
 801db2c:	3308      	adds	r3, #8
 801db2e:	4618      	mov	r0, r3
 801db30:	f000 fabe 	bl	801e0b0 <lv_mem_alloc>
 801db34:	60f8      	str	r0, [r7, #12]

    if(n_new != NULL) {
 801db36:	68fb      	ldr	r3, [r7, #12]
 801db38:	2b00      	cmp	r3, #0
 801db3a:	d020      	beq.n	801db7e <lv_ll_ins_head+0x5e>
        node_set_prev(ll_p, n_new, NULL);       /*No prev. before the new head*/
 801db3c:	2200      	movs	r2, #0
 801db3e:	68f9      	ldr	r1, [r7, #12]
 801db40:	6878      	ldr	r0, [r7, #4]
 801db42:	f000 f9ee 	bl	801df22 <node_set_prev>
        node_set_next(ll_p, n_new, ll_p->head); /*After new comes the old head*/
 801db46:	687b      	ldr	r3, [r7, #4]
 801db48:	685b      	ldr	r3, [r3, #4]
 801db4a:	461a      	mov	r2, r3
 801db4c:	68f9      	ldr	r1, [r7, #12]
 801db4e:	6878      	ldr	r0, [r7, #4]
 801db50:	f000 fa0d 	bl	801df6e <node_set_next>

        if(ll_p->head != NULL) { /*If there is old head then before it goes the new*/
 801db54:	687b      	ldr	r3, [r7, #4]
 801db56:	685b      	ldr	r3, [r3, #4]
 801db58:	2b00      	cmp	r3, #0
 801db5a:	d006      	beq.n	801db6a <lv_ll_ins_head+0x4a>
            node_set_prev(ll_p, ll_p->head, n_new);
 801db5c:	687b      	ldr	r3, [r7, #4]
 801db5e:	685b      	ldr	r3, [r3, #4]
 801db60:	68fa      	ldr	r2, [r7, #12]
 801db62:	4619      	mov	r1, r3
 801db64:	6878      	ldr	r0, [r7, #4]
 801db66:	f000 f9dc 	bl	801df22 <node_set_prev>
        }

        ll_p->head = n_new;      /*Set the new head in the dsc.*/
 801db6a:	687b      	ldr	r3, [r7, #4]
 801db6c:	68fa      	ldr	r2, [r7, #12]
 801db6e:	605a      	str	r2, [r3, #4]
        if(ll_p->tail == NULL) { /*If there is no tail (1. node) set the tail too*/
 801db70:	687b      	ldr	r3, [r7, #4]
 801db72:	689b      	ldr	r3, [r3, #8]
 801db74:	2b00      	cmp	r3, #0
 801db76:	d102      	bne.n	801db7e <lv_ll_ins_head+0x5e>
            ll_p->tail = n_new;
 801db78:	687b      	ldr	r3, [r7, #4]
 801db7a:	68fa      	ldr	r2, [r7, #12]
 801db7c:	609a      	str	r2, [r3, #8]
        }
    }

    return n_new;
 801db7e:	68fb      	ldr	r3, [r7, #12]
}
 801db80:	4618      	mov	r0, r3
 801db82:	3710      	adds	r7, #16
 801db84:	46bd      	mov	sp, r7
 801db86:	bd80      	pop	{r7, pc}

0801db88 <lv_ll_ins_prev>:
 * @param ll_p pointer to linked list
 * @param n_act pointer a node
 * @return pointer to the new head
 */
void * lv_ll_ins_prev(lv_ll_t * ll_p, void * n_act)
{
 801db88:	b580      	push	{r7, lr}
 801db8a:	b084      	sub	sp, #16
 801db8c:	af00      	add	r7, sp, #0
 801db8e:	6078      	str	r0, [r7, #4]
 801db90:	6039      	str	r1, [r7, #0]
    lv_ll_node_t * n_new;
    lv_ll_node_t * n_prev;

    if(NULL == ll_p || NULL == n_act) return NULL;
 801db92:	687b      	ldr	r3, [r7, #4]
 801db94:	2b00      	cmp	r3, #0
 801db96:	d002      	beq.n	801db9e <lv_ll_ins_prev+0x16>
 801db98:	683b      	ldr	r3, [r7, #0]
 801db9a:	2b00      	cmp	r3, #0
 801db9c:	d101      	bne.n	801dba2 <lv_ll_ins_prev+0x1a>
 801db9e:	2300      	movs	r3, #0
 801dba0:	e035      	b.n	801dc0e <lv_ll_ins_prev+0x86>

    if(lv_ll_get_head(ll_p) == n_act) {
 801dba2:	6878      	ldr	r0, [r7, #4]
 801dba4:	f000 f91e 	bl	801dde4 <lv_ll_get_head>
 801dba8:	4602      	mov	r2, r0
 801dbaa:	683b      	ldr	r3, [r7, #0]
 801dbac:	4293      	cmp	r3, r2
 801dbae:	d108      	bne.n	801dbc2 <lv_ll_ins_prev+0x3a>
        n_new = lv_ll_ins_head(ll_p);
 801dbb0:	6878      	ldr	r0, [r7, #4]
 801dbb2:	f7ff ffb5 	bl	801db20 <lv_ll_ins_head>
 801dbb6:	60f8      	str	r0, [r7, #12]
        if(n_new == NULL) return NULL;
 801dbb8:	68fb      	ldr	r3, [r7, #12]
 801dbba:	2b00      	cmp	r3, #0
 801dbbc:	d126      	bne.n	801dc0c <lv_ll_ins_prev+0x84>
 801dbbe:	2300      	movs	r3, #0
 801dbc0:	e025      	b.n	801dc0e <lv_ll_ins_prev+0x86>
    } else {
        n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
 801dbc2:	687b      	ldr	r3, [r7, #4]
 801dbc4:	681b      	ldr	r3, [r3, #0]
 801dbc6:	3308      	adds	r3, #8
 801dbc8:	4618      	mov	r0, r3
 801dbca:	f000 fa71 	bl	801e0b0 <lv_mem_alloc>
 801dbce:	60f8      	str	r0, [r7, #12]
        if(n_new == NULL) return NULL;
 801dbd0:	68fb      	ldr	r3, [r7, #12]
 801dbd2:	2b00      	cmp	r3, #0
 801dbd4:	d101      	bne.n	801dbda <lv_ll_ins_prev+0x52>
 801dbd6:	2300      	movs	r3, #0
 801dbd8:	e019      	b.n	801dc0e <lv_ll_ins_prev+0x86>

        n_prev = lv_ll_get_prev(ll_p, n_act);
 801dbda:	6839      	ldr	r1, [r7, #0]
 801dbdc:	6878      	ldr	r0, [r7, #4]
 801dbde:	f000 f941 	bl	801de64 <lv_ll_get_prev>
 801dbe2:	60b8      	str	r0, [r7, #8]
        node_set_next(ll_p, n_prev, n_new);
 801dbe4:	68fa      	ldr	r2, [r7, #12]
 801dbe6:	68b9      	ldr	r1, [r7, #8]
 801dbe8:	6878      	ldr	r0, [r7, #4]
 801dbea:	f000 f9c0 	bl	801df6e <node_set_next>
        node_set_prev(ll_p, n_new, n_prev);
 801dbee:	68ba      	ldr	r2, [r7, #8]
 801dbf0:	68f9      	ldr	r1, [r7, #12]
 801dbf2:	6878      	ldr	r0, [r7, #4]
 801dbf4:	f000 f995 	bl	801df22 <node_set_prev>
        node_set_prev(ll_p, n_act, n_new);
 801dbf8:	68fa      	ldr	r2, [r7, #12]
 801dbfa:	6839      	ldr	r1, [r7, #0]
 801dbfc:	6878      	ldr	r0, [r7, #4]
 801dbfe:	f000 f990 	bl	801df22 <node_set_prev>
        node_set_next(ll_p, n_new, n_act);
 801dc02:	683a      	ldr	r2, [r7, #0]
 801dc04:	68f9      	ldr	r1, [r7, #12]
 801dc06:	6878      	ldr	r0, [r7, #4]
 801dc08:	f000 f9b1 	bl	801df6e <node_set_next>
    }

    return n_new;
 801dc0c:	68fb      	ldr	r3, [r7, #12]
}
 801dc0e:	4618      	mov	r0, r3
 801dc10:	3710      	adds	r7, #16
 801dc12:	46bd      	mov	sp, r7
 801dc14:	bd80      	pop	{r7, pc}

0801dc16 <lv_ll_ins_tail>:
 * Add a new tail to a linked list
 * @param ll_p pointer to linked list
 * @return pointer to the new tail
 */
void * lv_ll_ins_tail(lv_ll_t * ll_p)
{
 801dc16:	b580      	push	{r7, lr}
 801dc18:	b084      	sub	sp, #16
 801dc1a:	af00      	add	r7, sp, #0
 801dc1c:	6078      	str	r0, [r7, #4]
    lv_ll_node_t * n_new;

    n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
 801dc1e:	687b      	ldr	r3, [r7, #4]
 801dc20:	681b      	ldr	r3, [r3, #0]
 801dc22:	3308      	adds	r3, #8
 801dc24:	4618      	mov	r0, r3
 801dc26:	f000 fa43 	bl	801e0b0 <lv_mem_alloc>
 801dc2a:	60f8      	str	r0, [r7, #12]
    if(n_new == NULL) return NULL;
 801dc2c:	68fb      	ldr	r3, [r7, #12]
 801dc2e:	2b00      	cmp	r3, #0
 801dc30:	d101      	bne.n	801dc36 <lv_ll_ins_tail+0x20>
 801dc32:	2300      	movs	r3, #0
 801dc34:	e024      	b.n	801dc80 <lv_ll_ins_tail+0x6a>

    if(n_new != NULL) {
 801dc36:	68fb      	ldr	r3, [r7, #12]
 801dc38:	2b00      	cmp	r3, #0
 801dc3a:	d020      	beq.n	801dc7e <lv_ll_ins_tail+0x68>
        node_set_next(ll_p, n_new, NULL);       /*No next after the new tail*/
 801dc3c:	2200      	movs	r2, #0
 801dc3e:	68f9      	ldr	r1, [r7, #12]
 801dc40:	6878      	ldr	r0, [r7, #4]
 801dc42:	f000 f994 	bl	801df6e <node_set_next>
        node_set_prev(ll_p, n_new, ll_p->tail); /*The prev. before new is tho old tail*/
 801dc46:	687b      	ldr	r3, [r7, #4]
 801dc48:	689b      	ldr	r3, [r3, #8]
 801dc4a:	461a      	mov	r2, r3
 801dc4c:	68f9      	ldr	r1, [r7, #12]
 801dc4e:	6878      	ldr	r0, [r7, #4]
 801dc50:	f000 f967 	bl	801df22 <node_set_prev>
        if(ll_p->tail != NULL) {                /*If there is old tail then the new comes after it*/
 801dc54:	687b      	ldr	r3, [r7, #4]
 801dc56:	689b      	ldr	r3, [r3, #8]
 801dc58:	2b00      	cmp	r3, #0
 801dc5a:	d006      	beq.n	801dc6a <lv_ll_ins_tail+0x54>
            node_set_next(ll_p, ll_p->tail, n_new);
 801dc5c:	687b      	ldr	r3, [r7, #4]
 801dc5e:	689b      	ldr	r3, [r3, #8]
 801dc60:	68fa      	ldr	r2, [r7, #12]
 801dc62:	4619      	mov	r1, r3
 801dc64:	6878      	ldr	r0, [r7, #4]
 801dc66:	f000 f982 	bl	801df6e <node_set_next>
        }

        ll_p->tail = n_new;      /*Set the new tail in the dsc.*/
 801dc6a:	687b      	ldr	r3, [r7, #4]
 801dc6c:	68fa      	ldr	r2, [r7, #12]
 801dc6e:	609a      	str	r2, [r3, #8]
        if(ll_p->head == NULL) { /*If there is no head (1. node) set the head too*/
 801dc70:	687b      	ldr	r3, [r7, #4]
 801dc72:	685b      	ldr	r3, [r3, #4]
 801dc74:	2b00      	cmp	r3, #0
 801dc76:	d102      	bne.n	801dc7e <lv_ll_ins_tail+0x68>
            ll_p->head = n_new;
 801dc78:	687b      	ldr	r3, [r7, #4]
 801dc7a:	68fa      	ldr	r2, [r7, #12]
 801dc7c:	605a      	str	r2, [r3, #4]
        }
    }

    return n_new;
 801dc7e:	68fb      	ldr	r3, [r7, #12]
}
 801dc80:	4618      	mov	r0, r3
 801dc82:	3710      	adds	r7, #16
 801dc84:	46bd      	mov	sp, r7
 801dc86:	bd80      	pop	{r7, pc}

0801dc88 <lv_ll_rem>:
 * It does not free the the memory of node.
 * @param ll_p pointer to the linked list of 'node_p'
 * @param node_p pointer to node in 'll_p' linked list
 */
void lv_ll_rem(lv_ll_t * ll_p, void * node_p)
{
 801dc88:	b580      	push	{r7, lr}
 801dc8a:	b084      	sub	sp, #16
 801dc8c:	af00      	add	r7, sp, #0
 801dc8e:	6078      	str	r0, [r7, #4]
 801dc90:	6039      	str	r1, [r7, #0]
    if(lv_ll_get_head(ll_p) == node_p) {
 801dc92:	6878      	ldr	r0, [r7, #4]
 801dc94:	f000 f8a6 	bl	801dde4 <lv_ll_get_head>
 801dc98:	4602      	mov	r2, r0
 801dc9a:	683b      	ldr	r3, [r7, #0]
 801dc9c:	4293      	cmp	r3, r2
 801dc9e:	d116      	bne.n	801dcce <lv_ll_rem+0x46>
        /*The new head will be the node after 'n_act'*/
        ll_p->head = lv_ll_get_next(ll_p, node_p);
 801dca0:	6839      	ldr	r1, [r7, #0]
 801dca2:	6878      	ldr	r0, [r7, #4]
 801dca4:	f000 f8c4 	bl	801de30 <lv_ll_get_next>
 801dca8:	4602      	mov	r2, r0
 801dcaa:	687b      	ldr	r3, [r7, #4]
 801dcac:	605a      	str	r2, [r3, #4]
        if(ll_p->head == NULL) {
 801dcae:	687b      	ldr	r3, [r7, #4]
 801dcb0:	685b      	ldr	r3, [r3, #4]
 801dcb2:	2b00      	cmp	r3, #0
 801dcb4:	d103      	bne.n	801dcbe <lv_ll_rem+0x36>
            ll_p->tail = NULL;
 801dcb6:	687b      	ldr	r3, [r7, #4]
 801dcb8:	2200      	movs	r2, #0
 801dcba:	609a      	str	r2, [r3, #8]
        lv_ll_node_t * n_next = lv_ll_get_next(ll_p, node_p);

        node_set_next(ll_p, n_prev, n_next);
        node_set_prev(ll_p, n_next, n_prev);
    }
}
 801dcbc:	e039      	b.n	801dd32 <lv_ll_rem+0xaa>
            node_set_prev(ll_p, ll_p->head, NULL);
 801dcbe:	687b      	ldr	r3, [r7, #4]
 801dcc0:	685b      	ldr	r3, [r3, #4]
 801dcc2:	2200      	movs	r2, #0
 801dcc4:	4619      	mov	r1, r3
 801dcc6:	6878      	ldr	r0, [r7, #4]
 801dcc8:	f000 f92b 	bl	801df22 <node_set_prev>
}
 801dccc:	e031      	b.n	801dd32 <lv_ll_rem+0xaa>
    } else if(lv_ll_get_tail(ll_p) == node_p) {
 801dcce:	6878      	ldr	r0, [r7, #4]
 801dcd0:	f000 f89b 	bl	801de0a <lv_ll_get_tail>
 801dcd4:	4602      	mov	r2, r0
 801dcd6:	683b      	ldr	r3, [r7, #0]
 801dcd8:	4293      	cmp	r3, r2
 801dcda:	d116      	bne.n	801dd0a <lv_ll_rem+0x82>
        ll_p->tail = lv_ll_get_prev(ll_p, node_p);
 801dcdc:	6839      	ldr	r1, [r7, #0]
 801dcde:	6878      	ldr	r0, [r7, #4]
 801dce0:	f000 f8c0 	bl	801de64 <lv_ll_get_prev>
 801dce4:	4602      	mov	r2, r0
 801dce6:	687b      	ldr	r3, [r7, #4]
 801dce8:	609a      	str	r2, [r3, #8]
        if(ll_p->tail == NULL) {
 801dcea:	687b      	ldr	r3, [r7, #4]
 801dcec:	689b      	ldr	r3, [r3, #8]
 801dcee:	2b00      	cmp	r3, #0
 801dcf0:	d103      	bne.n	801dcfa <lv_ll_rem+0x72>
            ll_p->head = NULL;
 801dcf2:	687b      	ldr	r3, [r7, #4]
 801dcf4:	2200      	movs	r2, #0
 801dcf6:	605a      	str	r2, [r3, #4]
}
 801dcf8:	e01b      	b.n	801dd32 <lv_ll_rem+0xaa>
            node_set_next(ll_p, ll_p->tail, NULL);
 801dcfa:	687b      	ldr	r3, [r7, #4]
 801dcfc:	689b      	ldr	r3, [r3, #8]
 801dcfe:	2200      	movs	r2, #0
 801dd00:	4619      	mov	r1, r3
 801dd02:	6878      	ldr	r0, [r7, #4]
 801dd04:	f000 f933 	bl	801df6e <node_set_next>
}
 801dd08:	e013      	b.n	801dd32 <lv_ll_rem+0xaa>
        lv_ll_node_t * n_prev = lv_ll_get_prev(ll_p, node_p);
 801dd0a:	6839      	ldr	r1, [r7, #0]
 801dd0c:	6878      	ldr	r0, [r7, #4]
 801dd0e:	f000 f8a9 	bl	801de64 <lv_ll_get_prev>
 801dd12:	60f8      	str	r0, [r7, #12]
        lv_ll_node_t * n_next = lv_ll_get_next(ll_p, node_p);
 801dd14:	6839      	ldr	r1, [r7, #0]
 801dd16:	6878      	ldr	r0, [r7, #4]
 801dd18:	f000 f88a 	bl	801de30 <lv_ll_get_next>
 801dd1c:	60b8      	str	r0, [r7, #8]
        node_set_next(ll_p, n_prev, n_next);
 801dd1e:	68ba      	ldr	r2, [r7, #8]
 801dd20:	68f9      	ldr	r1, [r7, #12]
 801dd22:	6878      	ldr	r0, [r7, #4]
 801dd24:	f000 f923 	bl	801df6e <node_set_next>
        node_set_prev(ll_p, n_next, n_prev);
 801dd28:	68fa      	ldr	r2, [r7, #12]
 801dd2a:	68b9      	ldr	r1, [r7, #8]
 801dd2c:	6878      	ldr	r0, [r7, #4]
 801dd2e:	f000 f8f8 	bl	801df22 <node_set_prev>
}
 801dd32:	bf00      	nop
 801dd34:	3710      	adds	r7, #16
 801dd36:	46bd      	mov	sp, r7
 801dd38:	bd80      	pop	{r7, pc}

0801dd3a <lv_ll_chg_list>:
 * @param node pointer to a node
 * @param head true: be the head in the new list
 *             false be the head in the new list
 */
void lv_ll_chg_list(lv_ll_t * ll_ori_p, lv_ll_t * ll_new_p, void * node, bool head)
{
 801dd3a:	b580      	push	{r7, lr}
 801dd3c:	b084      	sub	sp, #16
 801dd3e:	af00      	add	r7, sp, #0
 801dd40:	60f8      	str	r0, [r7, #12]
 801dd42:	60b9      	str	r1, [r7, #8]
 801dd44:	607a      	str	r2, [r7, #4]
 801dd46:	70fb      	strb	r3, [r7, #3]
    lv_ll_rem(ll_ori_p, node);
 801dd48:	6879      	ldr	r1, [r7, #4]
 801dd4a:	68f8      	ldr	r0, [r7, #12]
 801dd4c:	f7ff ff9c 	bl	801dc88 <lv_ll_rem>

    if(head) {
 801dd50:	78fb      	ldrb	r3, [r7, #3]
 801dd52:	2b00      	cmp	r3, #0
 801dd54:	d021      	beq.n	801dd9a <lv_ll_chg_list+0x60>
        /*Set node as head*/
        node_set_prev(ll_new_p, node, NULL);
 801dd56:	2200      	movs	r2, #0
 801dd58:	6879      	ldr	r1, [r7, #4]
 801dd5a:	68b8      	ldr	r0, [r7, #8]
 801dd5c:	f000 f8e1 	bl	801df22 <node_set_prev>
        node_set_next(ll_new_p, node, ll_new_p->head);
 801dd60:	68bb      	ldr	r3, [r7, #8]
 801dd62:	685b      	ldr	r3, [r3, #4]
 801dd64:	461a      	mov	r2, r3
 801dd66:	6879      	ldr	r1, [r7, #4]
 801dd68:	68b8      	ldr	r0, [r7, #8]
 801dd6a:	f000 f900 	bl	801df6e <node_set_next>

        if(ll_new_p->head != NULL) { /*If there is old head then before it goes the new*/
 801dd6e:	68bb      	ldr	r3, [r7, #8]
 801dd70:	685b      	ldr	r3, [r3, #4]
 801dd72:	2b00      	cmp	r3, #0
 801dd74:	d006      	beq.n	801dd84 <lv_ll_chg_list+0x4a>
            node_set_prev(ll_new_p, ll_new_p->head, node);
 801dd76:	68bb      	ldr	r3, [r7, #8]
 801dd78:	685b      	ldr	r3, [r3, #4]
 801dd7a:	687a      	ldr	r2, [r7, #4]
 801dd7c:	4619      	mov	r1, r3
 801dd7e:	68b8      	ldr	r0, [r7, #8]
 801dd80:	f000 f8cf 	bl	801df22 <node_set_prev>
        }

        ll_new_p->head = node;       /*Set the new head in the dsc.*/
 801dd84:	68bb      	ldr	r3, [r7, #8]
 801dd86:	687a      	ldr	r2, [r7, #4]
 801dd88:	605a      	str	r2, [r3, #4]
        if(ll_new_p->tail == NULL) { /*If there is no tail (first node) set the tail too*/
 801dd8a:	68bb      	ldr	r3, [r7, #8]
 801dd8c:	689b      	ldr	r3, [r3, #8]
 801dd8e:	2b00      	cmp	r3, #0
 801dd90:	d124      	bne.n	801dddc <lv_ll_chg_list+0xa2>
            ll_new_p->tail = node;
 801dd92:	68bb      	ldr	r3, [r7, #8]
 801dd94:	687a      	ldr	r2, [r7, #4]
 801dd96:	609a      	str	r2, [r3, #8]
        ll_new_p->tail = node;       /*Set the new tail in the dsc.*/
        if(ll_new_p->head == NULL) { /*If there is no head (first node) set the head too*/
            ll_new_p->head = node;
        }
    }
}
 801dd98:	e020      	b.n	801dddc <lv_ll_chg_list+0xa2>
        node_set_prev(ll_new_p, node, ll_new_p->tail);
 801dd9a:	68bb      	ldr	r3, [r7, #8]
 801dd9c:	689b      	ldr	r3, [r3, #8]
 801dd9e:	461a      	mov	r2, r3
 801dda0:	6879      	ldr	r1, [r7, #4]
 801dda2:	68b8      	ldr	r0, [r7, #8]
 801dda4:	f000 f8bd 	bl	801df22 <node_set_prev>
        node_set_next(ll_new_p, node, NULL);
 801dda8:	2200      	movs	r2, #0
 801ddaa:	6879      	ldr	r1, [r7, #4]
 801ddac:	68b8      	ldr	r0, [r7, #8]
 801ddae:	f000 f8de 	bl	801df6e <node_set_next>
        if(ll_new_p->tail != NULL) { /*If there is old tail then after it goes the new*/
 801ddb2:	68bb      	ldr	r3, [r7, #8]
 801ddb4:	689b      	ldr	r3, [r3, #8]
 801ddb6:	2b00      	cmp	r3, #0
 801ddb8:	d006      	beq.n	801ddc8 <lv_ll_chg_list+0x8e>
            node_set_next(ll_new_p, ll_new_p->tail, node);
 801ddba:	68bb      	ldr	r3, [r7, #8]
 801ddbc:	689b      	ldr	r3, [r3, #8]
 801ddbe:	687a      	ldr	r2, [r7, #4]
 801ddc0:	4619      	mov	r1, r3
 801ddc2:	68b8      	ldr	r0, [r7, #8]
 801ddc4:	f000 f8d3 	bl	801df6e <node_set_next>
        ll_new_p->tail = node;       /*Set the new tail in the dsc.*/
 801ddc8:	68bb      	ldr	r3, [r7, #8]
 801ddca:	687a      	ldr	r2, [r7, #4]
 801ddcc:	609a      	str	r2, [r3, #8]
        if(ll_new_p->head == NULL) { /*If there is no head (first node) set the head too*/
 801ddce:	68bb      	ldr	r3, [r7, #8]
 801ddd0:	685b      	ldr	r3, [r3, #4]
 801ddd2:	2b00      	cmp	r3, #0
 801ddd4:	d102      	bne.n	801dddc <lv_ll_chg_list+0xa2>
            ll_new_p->head = node;
 801ddd6:	68bb      	ldr	r3, [r7, #8]
 801ddd8:	687a      	ldr	r2, [r7, #4]
 801ddda:	605a      	str	r2, [r3, #4]
}
 801dddc:	bf00      	nop
 801ddde:	3710      	adds	r7, #16
 801dde0:	46bd      	mov	sp, r7
 801dde2:	bd80      	pop	{r7, pc}

0801dde4 <lv_ll_get_head>:
 * Return with head node of the linked list
 * @param ll_p pointer to linked list
 * @return pointer to the head of 'll_p'
 */
void * lv_ll_get_head(const lv_ll_t * ll_p)
{
 801dde4:	b480      	push	{r7}
 801dde6:	b085      	sub	sp, #20
 801dde8:	af00      	add	r7, sp, #0
 801ddea:	6078      	str	r0, [r7, #4]
    void * head = NULL;
 801ddec:	2300      	movs	r3, #0
 801ddee:	60fb      	str	r3, [r7, #12]

    if(ll_p != NULL) {
 801ddf0:	687b      	ldr	r3, [r7, #4]
 801ddf2:	2b00      	cmp	r3, #0
 801ddf4:	d002      	beq.n	801ddfc <lv_ll_get_head+0x18>
        head = ll_p->head;
 801ddf6:	687b      	ldr	r3, [r7, #4]
 801ddf8:	685b      	ldr	r3, [r3, #4]
 801ddfa:	60fb      	str	r3, [r7, #12]
    }

    return head;
 801ddfc:	68fb      	ldr	r3, [r7, #12]
}
 801ddfe:	4618      	mov	r0, r3
 801de00:	3714      	adds	r7, #20
 801de02:	46bd      	mov	sp, r7
 801de04:	f85d 7b04 	ldr.w	r7, [sp], #4
 801de08:	4770      	bx	lr

0801de0a <lv_ll_get_tail>:
 * Return with tail node of the linked list
 * @param ll_p pointer to linked list
 * @return pointer to the head of 'll_p'
 */
void * lv_ll_get_tail(const lv_ll_t * ll_p)
{
 801de0a:	b480      	push	{r7}
 801de0c:	b085      	sub	sp, #20
 801de0e:	af00      	add	r7, sp, #0
 801de10:	6078      	str	r0, [r7, #4]
    void * tail = NULL;
 801de12:	2300      	movs	r3, #0
 801de14:	60fb      	str	r3, [r7, #12]

    if(ll_p != NULL) {
 801de16:	687b      	ldr	r3, [r7, #4]
 801de18:	2b00      	cmp	r3, #0
 801de1a:	d002      	beq.n	801de22 <lv_ll_get_tail+0x18>
        tail = ll_p->tail;
 801de1c:	687b      	ldr	r3, [r7, #4]
 801de1e:	689b      	ldr	r3, [r3, #8]
 801de20:	60fb      	str	r3, [r7, #12]
    }

    return tail;
 801de22:	68fb      	ldr	r3, [r7, #12]
}
 801de24:	4618      	mov	r0, r3
 801de26:	3714      	adds	r7, #20
 801de28:	46bd      	mov	sp, r7
 801de2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801de2e:	4770      	bx	lr

0801de30 <lv_ll_get_next>:
 * @param ll_p pointer to linked list
 * @param n_act pointer a node
 * @return pointer to the next node
 */
void * lv_ll_get_next(const lv_ll_t * ll_p, const void * n_act)
{
 801de30:	b480      	push	{r7}
 801de32:	b085      	sub	sp, #20
 801de34:	af00      	add	r7, sp, #0
 801de36:	6078      	str	r0, [r7, #4]
 801de38:	6039      	str	r1, [r7, #0]
    void * next = NULL;
 801de3a:	2300      	movs	r3, #0
 801de3c:	60bb      	str	r3, [r7, #8]

    if(ll_p != NULL) {
 801de3e:	687b      	ldr	r3, [r7, #4]
 801de40:	2b00      	cmp	r3, #0
 801de42:	d008      	beq.n	801de56 <lv_ll_get_next+0x26>
        const lv_ll_node_t * n_act_d = n_act;
 801de44:	683b      	ldr	r3, [r7, #0]
 801de46:	60fb      	str	r3, [r7, #12]
        memcpy(&next, n_act_d + LL_NEXT_P_OFFSET(ll_p), sizeof(void *));
 801de48:	687b      	ldr	r3, [r7, #4]
 801de4a:	681b      	ldr	r3, [r3, #0]
 801de4c:	3304      	adds	r3, #4
 801de4e:	68fa      	ldr	r2, [r7, #12]
 801de50:	4413      	add	r3, r2
 801de52:	681b      	ldr	r3, [r3, #0]
 801de54:	60bb      	str	r3, [r7, #8]
    }

    return next;
 801de56:	68bb      	ldr	r3, [r7, #8]
}
 801de58:	4618      	mov	r0, r3
 801de5a:	3714      	adds	r7, #20
 801de5c:	46bd      	mov	sp, r7
 801de5e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801de62:	4770      	bx	lr

0801de64 <lv_ll_get_prev>:
 * @param ll_p pointer to linked list
 * @param n_act pointer a node
 * @return pointer to the previous node
 */
void * lv_ll_get_prev(const lv_ll_t * ll_p, const void * n_act)
{
 801de64:	b480      	push	{r7}
 801de66:	b085      	sub	sp, #20
 801de68:	af00      	add	r7, sp, #0
 801de6a:	6078      	str	r0, [r7, #4]
 801de6c:	6039      	str	r1, [r7, #0]
    void * prev = NULL;
 801de6e:	2300      	movs	r3, #0
 801de70:	60bb      	str	r3, [r7, #8]

    if(ll_p != NULL) {
 801de72:	687b      	ldr	r3, [r7, #4]
 801de74:	2b00      	cmp	r3, #0
 801de76:	d007      	beq.n	801de88 <lv_ll_get_prev+0x24>
        const lv_ll_node_t * n_act_d = n_act;
 801de78:	683b      	ldr	r3, [r7, #0]
 801de7a:	60fb      	str	r3, [r7, #12]
        memcpy(&prev, n_act_d + LL_PREV_P_OFFSET(ll_p), sizeof(void *));
 801de7c:	687b      	ldr	r3, [r7, #4]
 801de7e:	681b      	ldr	r3, [r3, #0]
 801de80:	68fa      	ldr	r2, [r7, #12]
 801de82:	4413      	add	r3, r2
 801de84:	681b      	ldr	r3, [r3, #0]
 801de86:	60bb      	str	r3, [r7, #8]
    }

    return prev;
 801de88:	68bb      	ldr	r3, [r7, #8]
}
 801de8a:	4618      	mov	r0, r3
 801de8c:	3714      	adds	r7, #20
 801de8e:	46bd      	mov	sp, r7
 801de90:	f85d 7b04 	ldr.w	r7, [sp], #4
 801de94:	4770      	bx	lr

0801de96 <lv_ll_move_before>:
 * @param ll_p pointer to a linked list
 * @param n_act pointer to node to move
 * @param n_after pointer to a node which should be after `n_act`
 */
void lv_ll_move_before(lv_ll_t * ll_p, void * n_act, void * n_after)
{
 801de96:	b580      	push	{r7, lr}
 801de98:	b086      	sub	sp, #24
 801de9a:	af00      	add	r7, sp, #0
 801de9c:	60f8      	str	r0, [r7, #12]
 801de9e:	60b9      	str	r1, [r7, #8]
 801dea0:	607a      	str	r2, [r7, #4]
    if(n_act == n_after) return; /*Can't move before itself*/
 801dea2:	68ba      	ldr	r2, [r7, #8]
 801dea4:	687b      	ldr	r3, [r7, #4]
 801dea6:	429a      	cmp	r2, r3
 801dea8:	d035      	beq.n	801df16 <lv_ll_move_before+0x80>

    void * n_before;
    if(n_after != NULL)
 801deaa:	687b      	ldr	r3, [r7, #4]
 801deac:	2b00      	cmp	r3, #0
 801deae:	d005      	beq.n	801debc <lv_ll_move_before+0x26>
        n_before = lv_ll_get_prev(ll_p, n_after);
 801deb0:	6879      	ldr	r1, [r7, #4]
 801deb2:	68f8      	ldr	r0, [r7, #12]
 801deb4:	f7ff ffd6 	bl	801de64 <lv_ll_get_prev>
 801deb8:	6178      	str	r0, [r7, #20]
 801deba:	e003      	b.n	801dec4 <lv_ll_move_before+0x2e>
    else
        n_before = lv_ll_get_tail(ll_p); /*if `n_after` is NULL `n_act` should be the new tail*/
 801debc:	68f8      	ldr	r0, [r7, #12]
 801debe:	f7ff ffa4 	bl	801de0a <lv_ll_get_tail>
 801dec2:	6178      	str	r0, [r7, #20]

    if(n_act == n_before) return; /*Already before `n_after`*/
 801dec4:	68ba      	ldr	r2, [r7, #8]
 801dec6:	697b      	ldr	r3, [r7, #20]
 801dec8:	429a      	cmp	r2, r3
 801deca:	d026      	beq.n	801df1a <lv_ll_move_before+0x84>

    /*It's much easier to remove from the list and add again*/
    lv_ll_rem(ll_p, n_act);
 801decc:	68b9      	ldr	r1, [r7, #8]
 801dece:	68f8      	ldr	r0, [r7, #12]
 801ded0:	f7ff feda 	bl	801dc88 <lv_ll_rem>

    /*Add again by setting the prev. and next nodes*/
    node_set_next(ll_p, n_before, n_act);
 801ded4:	68ba      	ldr	r2, [r7, #8]
 801ded6:	6979      	ldr	r1, [r7, #20]
 801ded8:	68f8      	ldr	r0, [r7, #12]
 801deda:	f000 f848 	bl	801df6e <node_set_next>
    node_set_prev(ll_p, n_act, n_before);
 801dede:	697a      	ldr	r2, [r7, #20]
 801dee0:	68b9      	ldr	r1, [r7, #8]
 801dee2:	68f8      	ldr	r0, [r7, #12]
 801dee4:	f000 f81d 	bl	801df22 <node_set_prev>
    node_set_prev(ll_p, n_after, n_act);
 801dee8:	68ba      	ldr	r2, [r7, #8]
 801deea:	6879      	ldr	r1, [r7, #4]
 801deec:	68f8      	ldr	r0, [r7, #12]
 801deee:	f000 f818 	bl	801df22 <node_set_prev>
    node_set_next(ll_p, n_act, n_after);
 801def2:	687a      	ldr	r2, [r7, #4]
 801def4:	68b9      	ldr	r1, [r7, #8]
 801def6:	68f8      	ldr	r0, [r7, #12]
 801def8:	f000 f839 	bl	801df6e <node_set_next>

    /*If `n_act` was moved before NULL then it become the new tail*/
    if(n_after == NULL) ll_p->tail = n_act;
 801defc:	687b      	ldr	r3, [r7, #4]
 801defe:	2b00      	cmp	r3, #0
 801df00:	d102      	bne.n	801df08 <lv_ll_move_before+0x72>
 801df02:	68fb      	ldr	r3, [r7, #12]
 801df04:	68ba      	ldr	r2, [r7, #8]
 801df06:	609a      	str	r2, [r3, #8]

    /*If `n_act` was moved before `NULL` then it's the new head*/
    if(n_before == NULL) ll_p->head = n_act;
 801df08:	697b      	ldr	r3, [r7, #20]
 801df0a:	2b00      	cmp	r3, #0
 801df0c:	d106      	bne.n	801df1c <lv_ll_move_before+0x86>
 801df0e:	68fb      	ldr	r3, [r7, #12]
 801df10:	68ba      	ldr	r2, [r7, #8]
 801df12:	605a      	str	r2, [r3, #4]
 801df14:	e002      	b.n	801df1c <lv_ll_move_before+0x86>
    if(n_act == n_after) return; /*Can't move before itself*/
 801df16:	bf00      	nop
 801df18:	e000      	b.n	801df1c <lv_ll_move_before+0x86>
    if(n_act == n_before) return; /*Already before `n_after`*/
 801df1a:	bf00      	nop
}
 801df1c:	3718      	adds	r7, #24
 801df1e:	46bd      	mov	sp, r7
 801df20:	bd80      	pop	{r7, pc}

0801df22 <node_set_prev>:
 * @param ll_p pointer to linked list
 * @param act pointer to a node which prev. node pointer should be set
 * @param prev pointer to a node which should be the previous node before 'act'
 */
static void node_set_prev(lv_ll_t * ll_p, lv_ll_node_t * act, lv_ll_node_t * prev)
{
 801df22:	b580      	push	{r7, lr}
 801df24:	b086      	sub	sp, #24
 801df26:	af00      	add	r7, sp, #0
 801df28:	60f8      	str	r0, [r7, #12]
 801df2a:	60b9      	str	r1, [r7, #8]
 801df2c:	607a      	str	r2, [r7, #4]
    if(act == NULL) return; /*Can't set the prev node of `NULL`*/
 801df2e:	68bb      	ldr	r3, [r7, #8]
 801df30:	2b00      	cmp	r3, #0
 801df32:	d018      	beq.n	801df66 <node_set_prev+0x44>

    uint32_t node_p_size = sizeof(lv_ll_node_t *);
 801df34:	2304      	movs	r3, #4
 801df36:	617b      	str	r3, [r7, #20]
    if(prev)
 801df38:	687b      	ldr	r3, [r7, #4]
 801df3a:	2b00      	cmp	r3, #0
 801df3c:	d009      	beq.n	801df52 <node_set_prev+0x30>
        memcpy(act + LL_PREV_P_OFFSET(ll_p), &prev, node_p_size);
 801df3e:	68fb      	ldr	r3, [r7, #12]
 801df40:	681b      	ldr	r3, [r3, #0]
 801df42:	68ba      	ldr	r2, [r7, #8]
 801df44:	4413      	add	r3, r2
 801df46:	1d39      	adds	r1, r7, #4
 801df48:	697a      	ldr	r2, [r7, #20]
 801df4a:	4618      	mov	r0, r3
 801df4c:	f003 fe84 	bl	8021c58 <memcpy>
 801df50:	e00a      	b.n	801df68 <node_set_prev+0x46>
    else
        memset(act + LL_PREV_P_OFFSET(ll_p), 0, node_p_size);
 801df52:	68fb      	ldr	r3, [r7, #12]
 801df54:	681b      	ldr	r3, [r3, #0]
 801df56:	68ba      	ldr	r2, [r7, #8]
 801df58:	4413      	add	r3, r2
 801df5a:	697a      	ldr	r2, [r7, #20]
 801df5c:	2100      	movs	r1, #0
 801df5e:	4618      	mov	r0, r3
 801df60:	f003 fe88 	bl	8021c74 <memset>
 801df64:	e000      	b.n	801df68 <node_set_prev+0x46>
    if(act == NULL) return; /*Can't set the prev node of `NULL`*/
 801df66:	bf00      	nop
}
 801df68:	3718      	adds	r7, #24
 801df6a:	46bd      	mov	sp, r7
 801df6c:	bd80      	pop	{r7, pc}

0801df6e <node_set_next>:
 * @param ll_p pointer to linked list
 * @param act pointer to a node which next node pointer should be set
 * @param next pointer to a node which should be the next node before 'act'
 */
static void node_set_next(lv_ll_t * ll_p, lv_ll_node_t * act, lv_ll_node_t * next)
{
 801df6e:	b580      	push	{r7, lr}
 801df70:	b086      	sub	sp, #24
 801df72:	af00      	add	r7, sp, #0
 801df74:	60f8      	str	r0, [r7, #12]
 801df76:	60b9      	str	r1, [r7, #8]
 801df78:	607a      	str	r2, [r7, #4]
    if(act == NULL) return; /*Can't set the next node of `NULL`*/
 801df7a:	68bb      	ldr	r3, [r7, #8]
 801df7c:	2b00      	cmp	r3, #0
 801df7e:	d01a      	beq.n	801dfb6 <node_set_next+0x48>

    uint32_t node_p_size = sizeof(lv_ll_node_t *);
 801df80:	2304      	movs	r3, #4
 801df82:	617b      	str	r3, [r7, #20]
    if(next)
 801df84:	687b      	ldr	r3, [r7, #4]
 801df86:	2b00      	cmp	r3, #0
 801df88:	d00a      	beq.n	801dfa0 <node_set_next+0x32>
        memcpy(act + LL_NEXT_P_OFFSET(ll_p), &next, node_p_size);
 801df8a:	68fb      	ldr	r3, [r7, #12]
 801df8c:	681b      	ldr	r3, [r3, #0]
 801df8e:	3304      	adds	r3, #4
 801df90:	68ba      	ldr	r2, [r7, #8]
 801df92:	4413      	add	r3, r2
 801df94:	1d39      	adds	r1, r7, #4
 801df96:	697a      	ldr	r2, [r7, #20]
 801df98:	4618      	mov	r0, r3
 801df9a:	f003 fe5d 	bl	8021c58 <memcpy>
 801df9e:	e00b      	b.n	801dfb8 <node_set_next+0x4a>
    else
        memset(act + LL_NEXT_P_OFFSET(ll_p), 0, node_p_size);
 801dfa0:	68fb      	ldr	r3, [r7, #12]
 801dfa2:	681b      	ldr	r3, [r3, #0]
 801dfa4:	3304      	adds	r3, #4
 801dfa6:	68ba      	ldr	r2, [r7, #8]
 801dfa8:	4413      	add	r3, r2
 801dfaa:	697a      	ldr	r2, [r7, #20]
 801dfac:	2100      	movs	r1, #0
 801dfae:	4618      	mov	r0, r3
 801dfb0:	f003 fe60 	bl	8021c74 <memset>
 801dfb4:	e000      	b.n	801dfb8 <node_set_next+0x4a>
    if(act == NULL) return; /*Can't set the next node of `NULL`*/
 801dfb6:	bf00      	nop
}
 801dfb8:	3718      	adds	r7, #24
 801dfba:	46bd      	mov	sp, r7
 801dfbc:	bd80      	pop	{r7, pc}
	...

0801dfc0 <lv_trigo_sin>:
 * Return with sinus of an angle
 * @param angle
 * @return sinus of 'angle'. sin(-90) = -32767, sin(90) = 32767
 */
int16_t lv_trigo_sin(int16_t angle)
{
 801dfc0:	b480      	push	{r7}
 801dfc2:	b085      	sub	sp, #20
 801dfc4:	af00      	add	r7, sp, #0
 801dfc6:	4603      	mov	r3, r0
 801dfc8:	80fb      	strh	r3, [r7, #6]
    int16_t ret = 0;
 801dfca:	2300      	movs	r3, #0
 801dfcc:	81fb      	strh	r3, [r7, #14]
    angle       = angle % 360;
 801dfce:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801dfd2:	4a31      	ldr	r2, [pc, #196]	; (801e098 <lv_trigo_sin+0xd8>)
 801dfd4:	fb82 1203 	smull	r1, r2, r2, r3
 801dfd8:	441a      	add	r2, r3
 801dfda:	1211      	asrs	r1, r2, #8
 801dfdc:	17da      	asrs	r2, r3, #31
 801dfde:	1a8a      	subs	r2, r1, r2
 801dfe0:	f44f 71b4 	mov.w	r1, #360	; 0x168
 801dfe4:	fb01 f202 	mul.w	r2, r1, r2
 801dfe8:	1a9b      	subs	r3, r3, r2
 801dfea:	80fb      	strh	r3, [r7, #6]

    if(angle < 0) angle = 360 + angle;
 801dfec:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801dff0:	2b00      	cmp	r3, #0
 801dff2:	da04      	bge.n	801dffe <lv_trigo_sin+0x3e>
 801dff4:	88fb      	ldrh	r3, [r7, #6]
 801dff6:	f503 73b4 	add.w	r3, r3, #360	; 0x168
 801dffa:	b29b      	uxth	r3, r3
 801dffc:	80fb      	strh	r3, [r7, #6]

    if(angle < 90) {
 801dffe:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801e002:	2b59      	cmp	r3, #89	; 0x59
 801e004:	dc06      	bgt.n	801e014 <lv_trigo_sin+0x54>
        ret = sin0_90_table[angle];
 801e006:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801e00a:	4a24      	ldr	r2, [pc, #144]	; (801e09c <lv_trigo_sin+0xdc>)
 801e00c:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 801e010:	81fb      	strh	r3, [r7, #14]
 801e012:	e038      	b.n	801e086 <lv_trigo_sin+0xc6>
    } else if(angle >= 90 && angle < 180) {
 801e014:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801e018:	2b59      	cmp	r3, #89	; 0x59
 801e01a:	dd0f      	ble.n	801e03c <lv_trigo_sin+0x7c>
 801e01c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801e020:	2bb3      	cmp	r3, #179	; 0xb3
 801e022:	dc0b      	bgt.n	801e03c <lv_trigo_sin+0x7c>
        angle = 180 - angle;
 801e024:	88fb      	ldrh	r3, [r7, #6]
 801e026:	f1c3 03b4 	rsb	r3, r3, #180	; 0xb4
 801e02a:	b29b      	uxth	r3, r3
 801e02c:	80fb      	strh	r3, [r7, #6]
        ret   = sin0_90_table[angle];
 801e02e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801e032:	4a1a      	ldr	r2, [pc, #104]	; (801e09c <lv_trigo_sin+0xdc>)
 801e034:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 801e038:	81fb      	strh	r3, [r7, #14]
 801e03a:	e024      	b.n	801e086 <lv_trigo_sin+0xc6>
    } else if(angle >= 180 && angle < 270) {
 801e03c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801e040:	2bb3      	cmp	r3, #179	; 0xb3
 801e042:	dd12      	ble.n	801e06a <lv_trigo_sin+0xaa>
 801e044:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801e048:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
 801e04c:	da0d      	bge.n	801e06a <lv_trigo_sin+0xaa>
        angle = angle - 180;
 801e04e:	88fb      	ldrh	r3, [r7, #6]
 801e050:	3bb4      	subs	r3, #180	; 0xb4
 801e052:	b29b      	uxth	r3, r3
 801e054:	80fb      	strh	r3, [r7, #6]
        ret   = -sin0_90_table[angle];
 801e056:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801e05a:	4a10      	ldr	r2, [pc, #64]	; (801e09c <lv_trigo_sin+0xdc>)
 801e05c:	f932 3013 	ldrsh.w	r3, [r2, r3, lsl #1]
 801e060:	b29b      	uxth	r3, r3
 801e062:	425b      	negs	r3, r3
 801e064:	b29b      	uxth	r3, r3
 801e066:	81fb      	strh	r3, [r7, #14]
 801e068:	e00d      	b.n	801e086 <lv_trigo_sin+0xc6>
    } else { /*angle >=270*/
        angle = 360 - angle;
 801e06a:	88fb      	ldrh	r3, [r7, #6]
 801e06c:	f5c3 73b4 	rsb	r3, r3, #360	; 0x168
 801e070:	b29b      	uxth	r3, r3
 801e072:	80fb      	strh	r3, [r7, #6]
        ret   = -sin0_90_table[angle];
 801e074:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801e078:	4a08      	ldr	r2, [pc, #32]	; (801e09c <lv_trigo_sin+0xdc>)
 801e07a:	f932 3013 	ldrsh.w	r3, [r2, r3, lsl #1]
 801e07e:	b29b      	uxth	r3, r3
 801e080:	425b      	negs	r3, r3
 801e082:	b29b      	uxth	r3, r3
 801e084:	81fb      	strh	r3, [r7, #14]
    }

    return ret;
 801e086:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
}
 801e08a:	4618      	mov	r0, r3
 801e08c:	3714      	adds	r7, #20
 801e08e:	46bd      	mov	sp, r7
 801e090:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e094:	4770      	bx	lr
 801e096:	bf00      	nop
 801e098:	b60b60b7 	.word	0xb60b60b7
 801e09c:	080d9cf0 	.word	0x080d9cf0

0801e0a0 <lv_mem_init>:

/**
 * Initiaiize the dyn_mem module (work memory and other variables)
 */
void lv_mem_init(void)
{
 801e0a0:	b480      	push	{r7}
 801e0a2:	af00      	add	r7, sp, #0
    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
    full->header.s.used = 0;
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
#endif
}
 801e0a4:	bf00      	nop
 801e0a6:	46bd      	mov	sp, r7
 801e0a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e0ac:	4770      	bx	lr
	...

0801e0b0 <lv_mem_alloc>:
 * Allocate a memory dynamically
 * @param size size of the memory to allocate in bytes
 * @return pointer to the allocated memory
 */
void * lv_mem_alloc(uint32_t size)
{
 801e0b0:	b580      	push	{r7, lr}
 801e0b2:	b084      	sub	sp, #16
 801e0b4:	af00      	add	r7, sp, #0
 801e0b6:	6078      	str	r0, [r7, #4]
    if(size == 0) {
 801e0b8:	687b      	ldr	r3, [r7, #4]
 801e0ba:	2b00      	cmp	r3, #0
 801e0bc:	d101      	bne.n	801e0c2 <lv_mem_alloc+0x12>
        return &zero_mem;
 801e0be:	4b1b      	ldr	r3, [pc, #108]	; (801e12c <lv_mem_alloc+0x7c>)
 801e0c0:	e02f      	b.n	801e122 <lv_mem_alloc+0x72>
        size = size & (~0x7);
        size += 8;
    }
#else
    /*Round the size up to 4*/
    if(size & 0x3) {
 801e0c2:	687b      	ldr	r3, [r7, #4]
 801e0c4:	f003 0303 	and.w	r3, r3, #3
 801e0c8:	2b00      	cmp	r3, #0
 801e0ca:	d006      	beq.n	801e0da <lv_mem_alloc+0x2a>
        size = size & (~0x3);
 801e0cc:	687b      	ldr	r3, [r7, #4]
 801e0ce:	f023 0303 	bic.w	r3, r3, #3
 801e0d2:	607b      	str	r3, [r7, #4]
        size += 4;
 801e0d4:	687b      	ldr	r3, [r7, #4]
 801e0d6:	3304      	adds	r3, #4
 801e0d8:	607b      	str	r3, [r7, #4]
    }
#endif
    void * alloc = NULL;
 801e0da:	2300      	movs	r3, #0
 801e0dc:	60fb      	str	r3, [r7, #12]
/*Use custom, user defined malloc function*/
#if LV_ENABLE_GC == 1 /*gc must not include header*/
    alloc = LV_MEM_CUSTOM_ALLOC(size);
#else                 /* LV_ENABLE_GC */
    /*Allocate a header too to store the size*/
    alloc = LV_MEM_CUSTOM_ALLOC(size + sizeof(lv_mem_header_t));
 801e0de:	687b      	ldr	r3, [r7, #4]
 801e0e0:	3304      	adds	r3, #4
 801e0e2:	4618      	mov	r0, r3
 801e0e4:	f7ee ff68 	bl	800cfb8 <pvPortMalloc>
 801e0e8:	60f8      	str	r0, [r7, #12]
    if(alloc != NULL) {
 801e0ea:	68fb      	ldr	r3, [r7, #12]
 801e0ec:	2b00      	cmp	r3, #0
 801e0ee:	d00f      	beq.n	801e110 <lv_mem_alloc+0x60>
        ((lv_mem_ent_t *)alloc)->header.s.d_size = size;
 801e0f0:	687b      	ldr	r3, [r7, #4]
 801e0f2:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 801e0f6:	68fa      	ldr	r2, [r7, #12]
 801e0f8:	6813      	ldr	r3, [r2, #0]
 801e0fa:	f361 035f 	bfi	r3, r1, #1, #31
 801e0fe:	6013      	str	r3, [r2, #0]
        ((lv_mem_ent_t *)alloc)->header.s.used   = 1;
 801e100:	68fa      	ldr	r2, [r7, #12]
 801e102:	7813      	ldrb	r3, [r2, #0]
 801e104:	f043 0301 	orr.w	r3, r3, #1
 801e108:	7013      	strb	r3, [r2, #0]

        alloc = &((lv_mem_ent_t *)alloc)->first_data;
 801e10a:	68fb      	ldr	r3, [r7, #12]
 801e10c:	3304      	adds	r3, #4
 801e10e:	60fb      	str	r3, [r7, #12]
    }
#endif                /* LV_ENABLE_GC */
#endif                /* LV_MEM_CUSTOM */

#if LV_MEM_ADD_JUNK
    if(alloc != NULL) memset(alloc, 0xaa, size);
 801e110:	68fb      	ldr	r3, [r7, #12]
 801e112:	2b00      	cmp	r3, #0
 801e114:	d004      	beq.n	801e120 <lv_mem_alloc+0x70>
 801e116:	687a      	ldr	r2, [r7, #4]
 801e118:	21aa      	movs	r1, #170	; 0xaa
 801e11a:	68f8      	ldr	r0, [r7, #12]
 801e11c:	f003 fdaa 	bl	8021c74 <memset>
#endif

    if(alloc == NULL) LV_LOG_WARN("Couldn't allocate memory");

    return alloc;
 801e120:	68fb      	ldr	r3, [r7, #12]
}
 801e122:	4618      	mov	r0, r3
 801e124:	3710      	adds	r7, #16
 801e126:	46bd      	mov	sp, r7
 801e128:	bd80      	pop	{r7, pc}
 801e12a:	bf00      	nop
 801e12c:	240623e8 	.word	0x240623e8

0801e130 <lv_mem_free>:
/**
 * Free an allocated data
 * @param data pointer to an allocated memory
 */
void lv_mem_free(const void * data)
{
 801e130:	b580      	push	{r7, lr}
 801e132:	b084      	sub	sp, #16
 801e134:	af00      	add	r7, sp, #0
 801e136:	6078      	str	r0, [r7, #4]
    if(data == &zero_mem) return;
 801e138:	687b      	ldr	r3, [r7, #4]
 801e13a:	4a10      	ldr	r2, [pc, #64]	; (801e17c <lv_mem_free+0x4c>)
 801e13c:	4293      	cmp	r3, r2
 801e13e:	d017      	beq.n	801e170 <lv_mem_free+0x40>
    if(data == NULL) return;
 801e140:	687b      	ldr	r3, [r7, #4]
 801e142:	2b00      	cmp	r3, #0
 801e144:	d016      	beq.n	801e174 <lv_mem_free+0x44>

#if LV_MEM_ADD_JUNK
    memset((void *)data, 0xbb, lv_mem_get_size(data));
 801e146:	6878      	ldr	r0, [r7, #4]
 801e148:	f000 f858 	bl	801e1fc <lv_mem_get_size>
 801e14c:	4603      	mov	r3, r0
 801e14e:	461a      	mov	r2, r3
 801e150:	21bb      	movs	r1, #187	; 0xbb
 801e152:	6878      	ldr	r0, [r7, #4]
 801e154:	f003 fd8e 	bl	8021c74 <memset>
#endif

#if LV_ENABLE_GC == 0
    /*e points to the header*/
    lv_mem_ent_t * e = (lv_mem_ent_t *)((uint8_t *)data - sizeof(lv_mem_header_t));
 801e158:	687b      	ldr	r3, [r7, #4]
 801e15a:	3b04      	subs	r3, #4
 801e15c:	60fb      	str	r3, [r7, #12]
    e->header.s.used = 0;
 801e15e:	68fa      	ldr	r2, [r7, #12]
 801e160:	7813      	ldrb	r3, [r2, #0]
 801e162:	f36f 0300 	bfc	r3, #0, #1
 801e166:	7013      	strb	r3, [r2, #0]
        e_next = ent_get_next(e_next);
    }
#endif
#else /*Use custom, user defined free function*/
#if LV_ENABLE_GC == 0
    LV_MEM_CUSTOM_FREE(e);
 801e168:	68f8      	ldr	r0, [r7, #12]
 801e16a:	f7ee fff1 	bl	800d150 <vPortFree>
 801e16e:	e002      	b.n	801e176 <lv_mem_free+0x46>
    if(data == &zero_mem) return;
 801e170:	bf00      	nop
 801e172:	e000      	b.n	801e176 <lv_mem_free+0x46>
    if(data == NULL) return;
 801e174:	bf00      	nop
#else
    LV_MEM_CUSTOM_FREE((void *)data);
#endif /*LV_ENABLE_GC*/
#endif
}
 801e176:	3710      	adds	r7, #16
 801e178:	46bd      	mov	sp, r7
 801e17a:	bd80      	pop	{r7, pc}
 801e17c:	240623e8 	.word	0x240623e8

0801e180 <lv_mem_realloc>:
 */

#if LV_ENABLE_GC == 0

void * lv_mem_realloc(void * data_p, uint32_t new_size)
{
 801e180:	b580      	push	{r7, lr}
 801e182:	b086      	sub	sp, #24
 801e184:	af00      	add	r7, sp, #0
 801e186:	6078      	str	r0, [r7, #4]
 801e188:	6039      	str	r1, [r7, #0]
    /*data_p could be previously freed pointer (in this case it is invalid)*/
    if(data_p != NULL) {
 801e18a:	687b      	ldr	r3, [r7, #4]
 801e18c:	2b00      	cmp	r3, #0
 801e18e:	d00b      	beq.n	801e1a8 <lv_mem_realloc+0x28>
        lv_mem_ent_t * e = (lv_mem_ent_t *)((uint8_t *)data_p - sizeof(lv_mem_header_t));
 801e190:	687b      	ldr	r3, [r7, #4]
 801e192:	3b04      	subs	r3, #4
 801e194:	617b      	str	r3, [r7, #20]
        if(e->header.s.used == 0) {
 801e196:	697b      	ldr	r3, [r7, #20]
 801e198:	781b      	ldrb	r3, [r3, #0]
 801e19a:	f003 0301 	and.w	r3, r3, #1
 801e19e:	b2db      	uxtb	r3, r3
 801e1a0:	2b00      	cmp	r3, #0
 801e1a2:	d101      	bne.n	801e1a8 <lv_mem_realloc+0x28>
            data_p = NULL;
 801e1a4:	2300      	movs	r3, #0
 801e1a6:	607b      	str	r3, [r7, #4]
        }
    }

    uint32_t old_size = lv_mem_get_size(data_p);
 801e1a8:	6878      	ldr	r0, [r7, #4]
 801e1aa:	f000 f827 	bl	801e1fc <lv_mem_get_size>
 801e1ae:	6138      	str	r0, [r7, #16]
    if(old_size == new_size) return data_p; /*Also avoid reallocating the same memory*/
 801e1b0:	693a      	ldr	r2, [r7, #16]
 801e1b2:	683b      	ldr	r3, [r7, #0]
 801e1b4:	429a      	cmp	r2, r3
 801e1b6:	d101      	bne.n	801e1bc <lv_mem_realloc+0x3c>
 801e1b8:	687b      	ldr	r3, [r7, #4]
 801e1ba:	e01a      	b.n	801e1f2 <lv_mem_realloc+0x72>
        return &e->first_data;
    }
#endif

    void * new_p;
    new_p = lv_mem_alloc(new_size);
 801e1bc:	6838      	ldr	r0, [r7, #0]
 801e1be:	f7ff ff77 	bl	801e0b0 <lv_mem_alloc>
 801e1c2:	60f8      	str	r0, [r7, #12]

    if(new_p != NULL && data_p != NULL) {
 801e1c4:	68fb      	ldr	r3, [r7, #12]
 801e1c6:	2b00      	cmp	r3, #0
 801e1c8:	d012      	beq.n	801e1f0 <lv_mem_realloc+0x70>
 801e1ca:	687b      	ldr	r3, [r7, #4]
 801e1cc:	2b00      	cmp	r3, #0
 801e1ce:	d00f      	beq.n	801e1f0 <lv_mem_realloc+0x70>
        /*Copy the old data to the new. Use the smaller size*/
        if(old_size != 0) {
 801e1d0:	693b      	ldr	r3, [r7, #16]
 801e1d2:	2b00      	cmp	r3, #0
 801e1d4:	d00c      	beq.n	801e1f0 <lv_mem_realloc+0x70>
            memcpy(new_p, data_p, LV_MATH_MIN(new_size, old_size));
 801e1d6:	693a      	ldr	r2, [r7, #16]
 801e1d8:	683b      	ldr	r3, [r7, #0]
 801e1da:	4293      	cmp	r3, r2
 801e1dc:	bf28      	it	cs
 801e1de:	4613      	movcs	r3, r2
 801e1e0:	461a      	mov	r2, r3
 801e1e2:	6879      	ldr	r1, [r7, #4]
 801e1e4:	68f8      	ldr	r0, [r7, #12]
 801e1e6:	f003 fd37 	bl	8021c58 <memcpy>
            lv_mem_free(data_p);
 801e1ea:	6878      	ldr	r0, [r7, #4]
 801e1ec:	f7ff ffa0 	bl	801e130 <lv_mem_free>
        }
    }

    if(new_p == NULL) LV_LOG_WARN("Couldn't allocate memory");

    return new_p;
 801e1f0:	68fb      	ldr	r3, [r7, #12]
}
 801e1f2:	4618      	mov	r0, r3
 801e1f4:	3718      	adds	r7, #24
 801e1f6:	46bd      	mov	sp, r7
 801e1f8:	bd80      	pop	{r7, pc}
	...

0801e1fc <lv_mem_get_size>:
 */

#if LV_ENABLE_GC == 0

uint32_t lv_mem_get_size(const void * data)
{
 801e1fc:	b480      	push	{r7}
 801e1fe:	b085      	sub	sp, #20
 801e200:	af00      	add	r7, sp, #0
 801e202:	6078      	str	r0, [r7, #4]
    if(data == NULL) return 0;
 801e204:	687b      	ldr	r3, [r7, #4]
 801e206:	2b00      	cmp	r3, #0
 801e208:	d101      	bne.n	801e20e <lv_mem_get_size+0x12>
 801e20a:	2300      	movs	r3, #0
 801e20c:	e00c      	b.n	801e228 <lv_mem_get_size+0x2c>
    if(data == &zero_mem) return 0;
 801e20e:	687b      	ldr	r3, [r7, #4]
 801e210:	4a08      	ldr	r2, [pc, #32]	; (801e234 <lv_mem_get_size+0x38>)
 801e212:	4293      	cmp	r3, r2
 801e214:	d101      	bne.n	801e21a <lv_mem_get_size+0x1e>
 801e216:	2300      	movs	r3, #0
 801e218:	e006      	b.n	801e228 <lv_mem_get_size+0x2c>

    lv_mem_ent_t * e = (lv_mem_ent_t *)((uint8_t *)data - sizeof(lv_mem_header_t));
 801e21a:	687b      	ldr	r3, [r7, #4]
 801e21c:	3b04      	subs	r3, #4
 801e21e:	60fb      	str	r3, [r7, #12]

    return e->header.s.d_size;
 801e220:	68fb      	ldr	r3, [r7, #12]
 801e222:	681b      	ldr	r3, [r3, #0]
 801e224:	f3c3 035e 	ubfx	r3, r3, #1, #31
}
 801e228:	4618      	mov	r0, r3
 801e22a:	3714      	adds	r7, #20
 801e22c:	46bd      	mov	sp, r7
 801e22e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e232:	4770      	bx	lr
 801e234:	240623e8 	.word	0x240623e8

0801e238 <lv_task_core_init>:

/**
 * Init the lv_task module
 */
void lv_task_core_init(void)
{
 801e238:	b580      	push	{r7, lr}
 801e23a:	af00      	add	r7, sp, #0
    lv_ll_init(&LV_GC_ROOT(_lv_task_ll), sizeof(lv_task_t));
 801e23c:	2114      	movs	r1, #20
 801e23e:	4804      	ldr	r0, [pc, #16]	; (801e250 <lv_task_core_init+0x18>)
 801e240:	f7ff fc4e 	bl	801dae0 <lv_ll_init>

    /*Initially enable the lv_task handling*/
    lv_task_enable(true);
 801e244:	2001      	movs	r0, #1
 801e246:	f000 fa23 	bl	801e690 <lv_task_enable>
}
 801e24a:	bf00      	nop
 801e24c:	bd80      	pop	{r7, pc}
 801e24e:	bf00      	nop
 801e250:	24063624 	.word	0x24063624

0801e254 <lv_task_handler>:

/**
 * Call it  periodically to handle lv_tasks.
 */
LV_ATTRIBUTE_TASK_HANDLER void lv_task_handler(void)
{
 801e254:	b580      	push	{r7, lr}
 801e256:	b084      	sub	sp, #16
 801e258:	af00      	add	r7, sp, #0
    LV_LOG_TRACE("lv_task_handler started");

    /*Avoid concurrent running of the task handler*/
    static bool task_handler_mutex = false;
    if(task_handler_mutex) return;
 801e25a:	4b6b      	ldr	r3, [pc, #428]	; (801e408 <lv_task_handler+0x1b4>)
 801e25c:	781b      	ldrb	r3, [r3, #0]
 801e25e:	2b00      	cmp	r3, #0
 801e260:	f040 80cd 	bne.w	801e3fe <lv_task_handler+0x1aa>
    task_handler_mutex = true;
 801e264:	4b68      	ldr	r3, [pc, #416]	; (801e408 <lv_task_handler+0x1b4>)
 801e266:	2201      	movs	r2, #1
 801e268:	701a      	strb	r2, [r3, #0]

    static uint32_t idle_period_start = 0;
    static uint32_t handler_start     = 0;
    static uint32_t busy_time         = 0;

    if(lv_task_run == false) {
 801e26a:	4b68      	ldr	r3, [pc, #416]	; (801e40c <lv_task_handler+0x1b8>)
 801e26c:	781b      	ldrb	r3, [r3, #0]
 801e26e:	f083 0301 	eor.w	r3, r3, #1
 801e272:	b2db      	uxtb	r3, r3
 801e274:	2b00      	cmp	r3, #0
 801e276:	d003      	beq.n	801e280 <lv_task_handler+0x2c>
        task_handler_mutex = false; /*Release mutex*/
 801e278:	4b63      	ldr	r3, [pc, #396]	; (801e408 <lv_task_handler+0x1b4>)
 801e27a:	2200      	movs	r2, #0
 801e27c:	701a      	strb	r2, [r3, #0]
        return;
 801e27e:	e0bf      	b.n	801e400 <lv_task_handler+0x1ac>
    }

    handler_start = lv_tick_get();
 801e280:	f7ff f82c 	bl	801d2dc <lv_tick_get>
 801e284:	4603      	mov	r3, r0
 801e286:	4a62      	ldr	r2, [pc, #392]	; (801e410 <lv_task_handler+0x1bc>)
 801e288:	6013      	str	r3, [r2, #0]

    /* Run all task from the highest to the lowest priority
     * If a lower priority task is executed check task again from the highest priority
     * but on the priority of executed tasks don't run tasks before the executed*/
    lv_task_t * task_interrupter = NULL;
 801e28a:	2300      	movs	r3, #0
 801e28c:	60fb      	str	r3, [r7, #12]
    lv_task_t * next;
    bool end_flag;
    do {
        end_flag                 = true;
 801e28e:	2301      	movs	r3, #1
 801e290:	72fb      	strb	r3, [r7, #11]
        task_deleted             = false;
 801e292:	4b60      	ldr	r3, [pc, #384]	; (801e414 <lv_task_handler+0x1c0>)
 801e294:	2200      	movs	r2, #0
 801e296:	701a      	strb	r2, [r3, #0]
        task_created             = false;
 801e298:	4b5f      	ldr	r3, [pc, #380]	; (801e418 <lv_task_handler+0x1c4>)
 801e29a:	2200      	movs	r2, #0
 801e29c:	701a      	strb	r2, [r3, #0]
        LV_GC_ROOT(_lv_task_act) = lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
 801e29e:	485f      	ldr	r0, [pc, #380]	; (801e41c <lv_task_handler+0x1c8>)
 801e2a0:	f7ff fda0 	bl	801dde4 <lv_ll_get_head>
 801e2a4:	4603      	mov	r3, r0
 801e2a6:	4a5e      	ldr	r2, [pc, #376]	; (801e420 <lv_task_handler+0x1cc>)
 801e2a8:	6013      	str	r3, [r2, #0]
        while(LV_GC_ROOT(_lv_task_act)) {
 801e2aa:	e05e      	b.n	801e36a <lv_task_handler+0x116>
            /* The task might be deleted if it runs only once ('once = 1')
             * So get next element until the current is surely valid*/
            next = lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), LV_GC_ROOT(_lv_task_act));
 801e2ac:	4b5c      	ldr	r3, [pc, #368]	; (801e420 <lv_task_handler+0x1cc>)
 801e2ae:	681b      	ldr	r3, [r3, #0]
 801e2b0:	4619      	mov	r1, r3
 801e2b2:	485a      	ldr	r0, [pc, #360]	; (801e41c <lv_task_handler+0x1c8>)
 801e2b4:	f7ff fdbc 	bl	801de30 <lv_ll_get_next>
 801e2b8:	6078      	str	r0, [r7, #4]

            /*We reach priority of the turned off task. There is nothing more to do.*/
            if(((lv_task_t *)LV_GC_ROOT(_lv_task_act))->prio == LV_TASK_PRIO_OFF) {
 801e2ba:	4b59      	ldr	r3, [pc, #356]	; (801e420 <lv_task_handler+0x1cc>)
 801e2bc:	681b      	ldr	r3, [r3, #0]
 801e2be:	7c1b      	ldrb	r3, [r3, #16]
 801e2c0:	f003 0307 	and.w	r3, r3, #7
 801e2c4:	b2db      	uxtb	r3, r3
 801e2c6:	2b00      	cmp	r3, #0
 801e2c8:	d054      	beq.n	801e374 <lv_task_handler+0x120>
                break;
            }

            /*Here is the interrupter task. Don't execute it again.*/
            if(LV_GC_ROOT(_lv_task_act) == task_interrupter) {
 801e2ca:	4b55      	ldr	r3, [pc, #340]	; (801e420 <lv_task_handler+0x1cc>)
 801e2cc:	681b      	ldr	r3, [r3, #0]
 801e2ce:	68fa      	ldr	r2, [r7, #12]
 801e2d0:	429a      	cmp	r2, r3
 801e2d2:	d105      	bne.n	801e2e0 <lv_task_handler+0x8c>
                task_interrupter = NULL; /*From this point only task after the interrupter comes, so
 801e2d4:	2300      	movs	r3, #0
 801e2d6:	60fb      	str	r3, [r7, #12]
                                            the interrupter is not interesting anymore*/
                LV_GC_ROOT(_lv_task_act) = next;
 801e2d8:	4a51      	ldr	r2, [pc, #324]	; (801e420 <lv_task_handler+0x1cc>)
 801e2da:	687b      	ldr	r3, [r7, #4]
 801e2dc:	6013      	str	r3, [r2, #0]
                continue; /*Load the next task*/
 801e2de:	e044      	b.n	801e36a <lv_task_handler+0x116>
            }

            /*Just try to run the tasks with highest priority.*/
            if(((lv_task_t *)LV_GC_ROOT(_lv_task_act))->prio == LV_TASK_PRIO_HIGHEST) {
 801e2e0:	4b4f      	ldr	r3, [pc, #316]	; (801e420 <lv_task_handler+0x1cc>)
 801e2e2:	681b      	ldr	r3, [r3, #0]
 801e2e4:	7c1b      	ldrb	r3, [r3, #16]
 801e2e6:	f003 0307 	and.w	r3, r3, #7
 801e2ea:	b2db      	uxtb	r3, r3
 801e2ec:	2b05      	cmp	r3, #5
 801e2ee:	d105      	bne.n	801e2fc <lv_task_handler+0xa8>
                lv_task_exec(LV_GC_ROOT(_lv_task_act));
 801e2f0:	4b4b      	ldr	r3, [pc, #300]	; (801e420 <lv_task_handler+0x1cc>)
 801e2f2:	681b      	ldr	r3, [r3, #0]
 801e2f4:	4618      	mov	r0, r3
 801e2f6:	f000 f9db 	bl	801e6b0 <lv_task_exec>
 801e2fa:	e02b      	b.n	801e354 <lv_task_handler+0x100>
            }
            /*Tasks with higher priority then the interrupted shall be run in every case*/
            else if(task_interrupter) {
 801e2fc:	68fb      	ldr	r3, [r7, #12]
 801e2fe:	2b00      	cmp	r3, #0
 801e300:	d01a      	beq.n	801e338 <lv_task_handler+0xe4>
                if(((lv_task_t *)LV_GC_ROOT(_lv_task_act))->prio > task_interrupter->prio) {
 801e302:	4b47      	ldr	r3, [pc, #284]	; (801e420 <lv_task_handler+0x1cc>)
 801e304:	681b      	ldr	r3, [r3, #0]
 801e306:	7c1b      	ldrb	r3, [r3, #16]
 801e308:	f3c3 0302 	ubfx	r3, r3, #0, #3
 801e30c:	b2da      	uxtb	r2, r3
 801e30e:	68fb      	ldr	r3, [r7, #12]
 801e310:	7c1b      	ldrb	r3, [r3, #16]
 801e312:	f3c3 0302 	ubfx	r3, r3, #0, #3
 801e316:	b2db      	uxtb	r3, r3
 801e318:	429a      	cmp	r2, r3
 801e31a:	d91b      	bls.n	801e354 <lv_task_handler+0x100>
                    if(lv_task_exec(LV_GC_ROOT(_lv_task_act))) {
 801e31c:	4b40      	ldr	r3, [pc, #256]	; (801e420 <lv_task_handler+0x1cc>)
 801e31e:	681b      	ldr	r3, [r3, #0]
 801e320:	4618      	mov	r0, r3
 801e322:	f000 f9c5 	bl	801e6b0 <lv_task_exec>
 801e326:	4603      	mov	r3, r0
 801e328:	2b00      	cmp	r3, #0
 801e32a:	d013      	beq.n	801e354 <lv_task_handler+0x100>
                        task_interrupter =
 801e32c:	4b3c      	ldr	r3, [pc, #240]	; (801e420 <lv_task_handler+0x1cc>)
 801e32e:	681b      	ldr	r3, [r3, #0]
 801e330:	60fb      	str	r3, [r7, #12]
                            LV_GC_ROOT(_lv_task_act); /*Check all tasks again from the highest priority */
                        end_flag = false;
 801e332:	2300      	movs	r3, #0
 801e334:	72fb      	strb	r3, [r7, #11]
                        break;
 801e336:	e022      	b.n	801e37e <lv_task_handler+0x12a>
                }
            }
            /* It is no interrupter task or we already reached it earlier.
             * Just run the remaining tasks*/
            else {
                if(lv_task_exec(LV_GC_ROOT(_lv_task_act))) {
 801e338:	4b39      	ldr	r3, [pc, #228]	; (801e420 <lv_task_handler+0x1cc>)
 801e33a:	681b      	ldr	r3, [r3, #0]
 801e33c:	4618      	mov	r0, r3
 801e33e:	f000 f9b7 	bl	801e6b0 <lv_task_exec>
 801e342:	4603      	mov	r3, r0
 801e344:	2b00      	cmp	r3, #0
 801e346:	d005      	beq.n	801e354 <lv_task_handler+0x100>
                    task_interrupter = LV_GC_ROOT(_lv_task_act); /*Check all tasks again from the highest priority */
 801e348:	4b35      	ldr	r3, [pc, #212]	; (801e420 <lv_task_handler+0x1cc>)
 801e34a:	681b      	ldr	r3, [r3, #0]
 801e34c:	60fb      	str	r3, [r7, #12]
                    end_flag         = false;
 801e34e:	2300      	movs	r3, #0
 801e350:	72fb      	strb	r3, [r7, #11]
                    break;
 801e352:	e014      	b.n	801e37e <lv_task_handler+0x12a>
                }
            }

            if(task_deleted) break; /*If a task was deleted then this or the next item might be corrupted*/
 801e354:	4b2f      	ldr	r3, [pc, #188]	; (801e414 <lv_task_handler+0x1c0>)
 801e356:	781b      	ldrb	r3, [r3, #0]
 801e358:	2b00      	cmp	r3, #0
 801e35a:	d10d      	bne.n	801e378 <lv_task_handler+0x124>
            if(task_created) break; /*If a task was created then this or the next item might be corrupted*/
 801e35c:	4b2e      	ldr	r3, [pc, #184]	; (801e418 <lv_task_handler+0x1c4>)
 801e35e:	781b      	ldrb	r3, [r3, #0]
 801e360:	2b00      	cmp	r3, #0
 801e362:	d10b      	bne.n	801e37c <lv_task_handler+0x128>

            LV_GC_ROOT(_lv_task_act) = next; /*Load the next task*/
 801e364:	4a2e      	ldr	r2, [pc, #184]	; (801e420 <lv_task_handler+0x1cc>)
 801e366:	687b      	ldr	r3, [r7, #4]
 801e368:	6013      	str	r3, [r2, #0]
        while(LV_GC_ROOT(_lv_task_act)) {
 801e36a:	4b2d      	ldr	r3, [pc, #180]	; (801e420 <lv_task_handler+0x1cc>)
 801e36c:	681b      	ldr	r3, [r3, #0]
 801e36e:	2b00      	cmp	r3, #0
 801e370:	d19c      	bne.n	801e2ac <lv_task_handler+0x58>
 801e372:	e004      	b.n	801e37e <lv_task_handler+0x12a>
                break;
 801e374:	bf00      	nop
 801e376:	e002      	b.n	801e37e <lv_task_handler+0x12a>
            if(task_deleted) break; /*If a task was deleted then this or the next item might be corrupted*/
 801e378:	bf00      	nop
 801e37a:	e000      	b.n	801e37e <lv_task_handler+0x12a>
            if(task_created) break; /*If a task was created then this or the next item might be corrupted*/
 801e37c:	bf00      	nop
        }
    } while(!end_flag);
 801e37e:	7afb      	ldrb	r3, [r7, #11]
 801e380:	f083 0301 	eor.w	r3, r3, #1
 801e384:	b2db      	uxtb	r3, r3
 801e386:	2b00      	cmp	r3, #0
 801e388:	d181      	bne.n	801e28e <lv_task_handler+0x3a>

    busy_time += lv_tick_elaps(handler_start);
 801e38a:	4b21      	ldr	r3, [pc, #132]	; (801e410 <lv_task_handler+0x1bc>)
 801e38c:	681b      	ldr	r3, [r3, #0]
 801e38e:	4618      	mov	r0, r3
 801e390:	f7fe ffbe 	bl	801d310 <lv_tick_elaps>
 801e394:	4602      	mov	r2, r0
 801e396:	4b23      	ldr	r3, [pc, #140]	; (801e424 <lv_task_handler+0x1d0>)
 801e398:	681b      	ldr	r3, [r3, #0]
 801e39a:	4413      	add	r3, r2
 801e39c:	4a21      	ldr	r2, [pc, #132]	; (801e424 <lv_task_handler+0x1d0>)
 801e39e:	6013      	str	r3, [r2, #0]
    uint32_t idle_period_time = lv_tick_elaps(idle_period_start);
 801e3a0:	4b21      	ldr	r3, [pc, #132]	; (801e428 <lv_task_handler+0x1d4>)
 801e3a2:	681b      	ldr	r3, [r3, #0]
 801e3a4:	4618      	mov	r0, r3
 801e3a6:	f7fe ffb3 	bl	801d310 <lv_tick_elaps>
 801e3aa:	6038      	str	r0, [r7, #0]
    if(idle_period_time >= IDLE_MEAS_PERIOD) {
 801e3ac:	683b      	ldr	r3, [r7, #0]
 801e3ae:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 801e3b2:	d320      	bcc.n	801e3f6 <lv_task_handler+0x1a2>

        idle_last         = (uint32_t)((uint32_t)busy_time * 100) / IDLE_MEAS_PERIOD; /*Calculate the busy percentage*/
 801e3b4:	4b1b      	ldr	r3, [pc, #108]	; (801e424 <lv_task_handler+0x1d0>)
 801e3b6:	681b      	ldr	r3, [r3, #0]
 801e3b8:	2264      	movs	r2, #100	; 0x64
 801e3ba:	fb02 f303 	mul.w	r3, r2, r3
 801e3be:	4a1b      	ldr	r2, [pc, #108]	; (801e42c <lv_task_handler+0x1d8>)
 801e3c0:	fba2 2303 	umull	r2, r3, r2, r3
 801e3c4:	095b      	lsrs	r3, r3, #5
 801e3c6:	b2da      	uxtb	r2, r3
 801e3c8:	4b19      	ldr	r3, [pc, #100]	; (801e430 <lv_task_handler+0x1dc>)
 801e3ca:	701a      	strb	r2, [r3, #0]
        idle_last         = idle_last > 100 ? 0 : 100 - idle_last;                    /*But we need idle time*/
 801e3cc:	4b18      	ldr	r3, [pc, #96]	; (801e430 <lv_task_handler+0x1dc>)
 801e3ce:	781b      	ldrb	r3, [r3, #0]
 801e3d0:	2b64      	cmp	r3, #100	; 0x64
 801e3d2:	d805      	bhi.n	801e3e0 <lv_task_handler+0x18c>
 801e3d4:	4b16      	ldr	r3, [pc, #88]	; (801e430 <lv_task_handler+0x1dc>)
 801e3d6:	781b      	ldrb	r3, [r3, #0]
 801e3d8:	f1c3 0364 	rsb	r3, r3, #100	; 0x64
 801e3dc:	b2db      	uxtb	r3, r3
 801e3de:	e000      	b.n	801e3e2 <lv_task_handler+0x18e>
 801e3e0:	2300      	movs	r3, #0
 801e3e2:	4a13      	ldr	r2, [pc, #76]	; (801e430 <lv_task_handler+0x1dc>)
 801e3e4:	7013      	strb	r3, [r2, #0]
        busy_time         = 0;
 801e3e6:	4b0f      	ldr	r3, [pc, #60]	; (801e424 <lv_task_handler+0x1d0>)
 801e3e8:	2200      	movs	r2, #0
 801e3ea:	601a      	str	r2, [r3, #0]
        idle_period_start = lv_tick_get();
 801e3ec:	f7fe ff76 	bl	801d2dc <lv_tick_get>
 801e3f0:	4603      	mov	r3, r0
 801e3f2:	4a0d      	ldr	r2, [pc, #52]	; (801e428 <lv_task_handler+0x1d4>)
 801e3f4:	6013      	str	r3, [r2, #0]
    }

    task_handler_mutex = false; /*Release the mutex*/
 801e3f6:	4b04      	ldr	r3, [pc, #16]	; (801e408 <lv_task_handler+0x1b4>)
 801e3f8:	2200      	movs	r2, #0
 801e3fa:	701a      	strb	r2, [r3, #0]
 801e3fc:	e000      	b.n	801e400 <lv_task_handler+0x1ac>
    if(task_handler_mutex) return;
 801e3fe:	bf00      	nop

    LV_LOG_TRACE("lv_task_handler ready");
}
 801e400:	3710      	adds	r7, #16
 801e402:	46bd      	mov	sp, r7
 801e404:	bd80      	pop	{r7, pc}
 801e406:	bf00      	nop
 801e408:	240623f0 	.word	0x240623f0
 801e40c:	240623ec 	.word	0x240623ec
 801e410:	240623f4 	.word	0x240623f4
 801e414:	240623ee 	.word	0x240623ee
 801e418:	240623ef 	.word	0x240623ef
 801e41c:	24063624 	.word	0x24063624
 801e420:	24063664 	.word	0x24063664
 801e424:	240623f8 	.word	0x240623f8
 801e428:	240623fc 	.word	0x240623fc
 801e42c:	10624dd3 	.word	0x10624dd3
 801e430:	240623ed 	.word	0x240623ed

0801e434 <lv_task_create_basic>:
 * Create an "empty" task. It needs to initialzed with at least
 * `lv_task_set_cb` and `lv_task_set_period`
 * @return pointer to the craeted task
 */
lv_task_t * lv_task_create_basic(void)
{
 801e434:	b580      	push	{r7, lr}
 801e436:	b082      	sub	sp, #8
 801e438:	af00      	add	r7, sp, #0
    lv_task_t * new_task = NULL;
 801e43a:	2300      	movs	r3, #0
 801e43c:	607b      	str	r3, [r7, #4]
    lv_task_t * tmp;

    /*Create task lists in order of priority from high to low*/
    tmp = lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
 801e43e:	4832      	ldr	r0, [pc, #200]	; (801e508 <lv_task_create_basic+0xd4>)
 801e440:	f7ff fcd0 	bl	801dde4 <lv_ll_get_head>
 801e444:	6038      	str	r0, [r7, #0]

    /*It's the first task*/
    if(NULL == tmp) {
 801e446:	683b      	ldr	r3, [r7, #0]
 801e448:	2b00      	cmp	r3, #0
 801e44a:	d10c      	bne.n	801e466 <lv_task_create_basic+0x32>
        new_task = lv_ll_ins_head(&LV_GC_ROOT(_lv_task_ll));
 801e44c:	482e      	ldr	r0, [pc, #184]	; (801e508 <lv_task_create_basic+0xd4>)
 801e44e:	f7ff fb67 	bl	801db20 <lv_ll_ins_head>
 801e452:	6078      	str	r0, [r7, #4]
        lv_mem_assert(new_task);
 801e454:	687b      	ldr	r3, [r7, #4]
 801e456:	2b00      	cmp	r3, #0
 801e458:	d100      	bne.n	801e45c <lv_task_create_basic+0x28>
 801e45a:	e7fe      	b.n	801e45a <lv_task_create_basic+0x26>
        if(new_task == NULL) return NULL;
 801e45c:	687b      	ldr	r3, [r7, #4]
 801e45e:	2b00      	cmp	r3, #0
 801e460:	d130      	bne.n	801e4c4 <lv_task_create_basic+0x90>
 801e462:	2300      	movs	r3, #0
 801e464:	e04c      	b.n	801e500 <lv_task_create_basic+0xcc>
    }
    /*Insert the new task to proper place according to its priority*/
    else {
        do {
            if(tmp->prio <= DEF_PRIO) {
 801e466:	683b      	ldr	r3, [r7, #0]
 801e468:	7c1b      	ldrb	r3, [r3, #16]
 801e46a:	f3c3 0302 	ubfx	r3, r3, #0, #3
 801e46e:	b2db      	uxtb	r3, r3
 801e470:	2b03      	cmp	r3, #3
 801e472:	d80d      	bhi.n	801e490 <lv_task_create_basic+0x5c>
                new_task = lv_ll_ins_prev(&LV_GC_ROOT(_lv_task_ll), tmp);
 801e474:	6839      	ldr	r1, [r7, #0]
 801e476:	4824      	ldr	r0, [pc, #144]	; (801e508 <lv_task_create_basic+0xd4>)
 801e478:	f7ff fb86 	bl	801db88 <lv_ll_ins_prev>
 801e47c:	6078      	str	r0, [r7, #4]
                lv_mem_assert(new_task);
 801e47e:	687b      	ldr	r3, [r7, #4]
 801e480:	2b00      	cmp	r3, #0
 801e482:	d100      	bne.n	801e486 <lv_task_create_basic+0x52>
 801e484:	e7fe      	b.n	801e484 <lv_task_create_basic+0x50>
                if(new_task == NULL) return NULL;
 801e486:	687b      	ldr	r3, [r7, #4]
 801e488:	2b00      	cmp	r3, #0
 801e48a:	d10a      	bne.n	801e4a2 <lv_task_create_basic+0x6e>
 801e48c:	2300      	movs	r3, #0
 801e48e:	e037      	b.n	801e500 <lv_task_create_basic+0xcc>
                break;
            }
            tmp = lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), tmp);
 801e490:	6839      	ldr	r1, [r7, #0]
 801e492:	481d      	ldr	r0, [pc, #116]	; (801e508 <lv_task_create_basic+0xd4>)
 801e494:	f7ff fccc 	bl	801de30 <lv_ll_get_next>
 801e498:	6038      	str	r0, [r7, #0]
        } while(tmp != NULL);
 801e49a:	683b      	ldr	r3, [r7, #0]
 801e49c:	2b00      	cmp	r3, #0
 801e49e:	d1e2      	bne.n	801e466 <lv_task_create_basic+0x32>
 801e4a0:	e000      	b.n	801e4a4 <lv_task_create_basic+0x70>
                break;
 801e4a2:	bf00      	nop

        /*Only too high priority tasks were found. Add the task to the end*/
        if(tmp == NULL) {
 801e4a4:	683b      	ldr	r3, [r7, #0]
 801e4a6:	2b00      	cmp	r3, #0
 801e4a8:	d10c      	bne.n	801e4c4 <lv_task_create_basic+0x90>
            new_task = lv_ll_ins_tail(&LV_GC_ROOT(_lv_task_ll));
 801e4aa:	4817      	ldr	r0, [pc, #92]	; (801e508 <lv_task_create_basic+0xd4>)
 801e4ac:	f7ff fbb3 	bl	801dc16 <lv_ll_ins_tail>
 801e4b0:	6078      	str	r0, [r7, #4]
            lv_mem_assert(new_task);
 801e4b2:	687b      	ldr	r3, [r7, #4]
 801e4b4:	2b00      	cmp	r3, #0
 801e4b6:	d100      	bne.n	801e4ba <lv_task_create_basic+0x86>
 801e4b8:	e7fe      	b.n	801e4b8 <lv_task_create_basic+0x84>
            if(new_task == NULL) return NULL;
 801e4ba:	687b      	ldr	r3, [r7, #4]
 801e4bc:	2b00      	cmp	r3, #0
 801e4be:	d101      	bne.n	801e4c4 <lv_task_create_basic+0x90>
 801e4c0:	2300      	movs	r3, #0
 801e4c2:	e01d      	b.n	801e500 <lv_task_create_basic+0xcc>
        }
    }

    new_task->period  = DEF_PERIOD;
 801e4c4:	687b      	ldr	r3, [r7, #4]
 801e4c6:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 801e4ca:	601a      	str	r2, [r3, #0]
    new_task->task_cb = NULL;
 801e4cc:	687b      	ldr	r3, [r7, #4]
 801e4ce:	2200      	movs	r2, #0
 801e4d0:	609a      	str	r2, [r3, #8]
    new_task->prio    = DEF_PRIO;
 801e4d2:	687a      	ldr	r2, [r7, #4]
 801e4d4:	7c13      	ldrb	r3, [r2, #16]
 801e4d6:	2103      	movs	r1, #3
 801e4d8:	f361 0302 	bfi	r3, r1, #0, #3
 801e4dc:	7413      	strb	r3, [r2, #16]

    new_task->once     = 0;
 801e4de:	687a      	ldr	r2, [r7, #4]
 801e4e0:	7c13      	ldrb	r3, [r2, #16]
 801e4e2:	f36f 03c3 	bfc	r3, #3, #1
 801e4e6:	7413      	strb	r3, [r2, #16]
    new_task->last_run = lv_tick_get();
 801e4e8:	f7fe fef8 	bl	801d2dc <lv_tick_get>
 801e4ec:	4602      	mov	r2, r0
 801e4ee:	687b      	ldr	r3, [r7, #4]
 801e4f0:	605a      	str	r2, [r3, #4]

    new_task->user_data = NULL;
 801e4f2:	687b      	ldr	r3, [r7, #4]
 801e4f4:	2200      	movs	r2, #0
 801e4f6:	60da      	str	r2, [r3, #12]

    task_created = true;
 801e4f8:	4b04      	ldr	r3, [pc, #16]	; (801e50c <lv_task_create_basic+0xd8>)
 801e4fa:	2201      	movs	r2, #1
 801e4fc:	701a      	strb	r2, [r3, #0]

    return new_task;
 801e4fe:	687b      	ldr	r3, [r7, #4]
}
 801e500:	4618      	mov	r0, r3
 801e502:	3708      	adds	r7, #8
 801e504:	46bd      	mov	sp, r7
 801e506:	bd80      	pop	{r7, pc}
 801e508:	24063624 	.word	0x24063624
 801e50c:	240623ef 	.word	0x240623ef

0801e510 <lv_task_create>:
 * @param prio priority of the task (LV_TASK_PRIO_OFF means the task is stopped)
 * @param user_data custom parameter
 * @return pointer to the new task
 */
lv_task_t * lv_task_create(lv_task_cb_t task_cb, uint32_t period, lv_task_prio_t prio, void * user_data)
{
 801e510:	b580      	push	{r7, lr}
 801e512:	b086      	sub	sp, #24
 801e514:	af00      	add	r7, sp, #0
 801e516:	60f8      	str	r0, [r7, #12]
 801e518:	60b9      	str	r1, [r7, #8]
 801e51a:	603b      	str	r3, [r7, #0]
 801e51c:	4613      	mov	r3, r2
 801e51e:	71fb      	strb	r3, [r7, #7]
    lv_task_t * new_task = lv_task_create_basic();
 801e520:	f7ff ff88 	bl	801e434 <lv_task_create_basic>
 801e524:	6178      	str	r0, [r7, #20]
    lv_mem_assert(new_task);
 801e526:	697b      	ldr	r3, [r7, #20]
 801e528:	2b00      	cmp	r3, #0
 801e52a:	d100      	bne.n	801e52e <lv_task_create+0x1e>
 801e52c:	e7fe      	b.n	801e52c <lv_task_create+0x1c>
    if(new_task == NULL) return NULL;
 801e52e:	697b      	ldr	r3, [r7, #20]
 801e530:	2b00      	cmp	r3, #0
 801e532:	d101      	bne.n	801e538 <lv_task_create+0x28>
 801e534:	2300      	movs	r3, #0
 801e536:	e010      	b.n	801e55a <lv_task_create+0x4a>

    lv_task_set_cb(new_task, task_cb);
 801e538:	68f9      	ldr	r1, [r7, #12]
 801e53a:	6978      	ldr	r0, [r7, #20]
 801e53c:	f000 f811 	bl	801e562 <lv_task_set_cb>
    lv_task_set_period(new_task, period);
 801e540:	68b9      	ldr	r1, [r7, #8]
 801e542:	6978      	ldr	r0, [r7, #20]
 801e544:	f000 f884 	bl	801e650 <lv_task_set_period>
    lv_task_set_prio(new_task, prio);
 801e548:	79fb      	ldrb	r3, [r7, #7]
 801e54a:	4619      	mov	r1, r3
 801e54c:	6978      	ldr	r0, [r7, #20]
 801e54e:	f000 f835 	bl	801e5bc <lv_task_set_prio>
    new_task->user_data = user_data;
 801e552:	697b      	ldr	r3, [r7, #20]
 801e554:	683a      	ldr	r2, [r7, #0]
 801e556:	60da      	str	r2, [r3, #12]

    return new_task;
 801e558:	697b      	ldr	r3, [r7, #20]
}
 801e55a:	4618      	mov	r0, r3
 801e55c:	3718      	adds	r7, #24
 801e55e:	46bd      	mov	sp, r7
 801e560:	bd80      	pop	{r7, pc}

0801e562 <lv_task_set_cb>:
 * Set the callback the task (the function to call periodically)
 * @param task pointer to a task
 * @param task_cb teh function to call periodically
 */
void lv_task_set_cb(lv_task_t * task, lv_task_cb_t task_cb)
{
 801e562:	b480      	push	{r7}
 801e564:	b083      	sub	sp, #12
 801e566:	af00      	add	r7, sp, #0
 801e568:	6078      	str	r0, [r7, #4]
 801e56a:	6039      	str	r1, [r7, #0]
    task->task_cb = task_cb;
 801e56c:	687b      	ldr	r3, [r7, #4]
 801e56e:	683a      	ldr	r2, [r7, #0]
 801e570:	609a      	str	r2, [r3, #8]
}
 801e572:	bf00      	nop
 801e574:	370c      	adds	r7, #12
 801e576:	46bd      	mov	sp, r7
 801e578:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e57c:	4770      	bx	lr
	...

0801e580 <lv_task_del>:
/**
 * Delete a lv_task
 * @param task pointer to task created by task
 */
void lv_task_del(lv_task_t * task)
{
 801e580:	b580      	push	{r7, lr}
 801e582:	b082      	sub	sp, #8
 801e584:	af00      	add	r7, sp, #0
 801e586:	6078      	str	r0, [r7, #4]
    lv_ll_rem(&LV_GC_ROOT(_lv_task_ll), task);
 801e588:	6879      	ldr	r1, [r7, #4]
 801e58a:	4809      	ldr	r0, [pc, #36]	; (801e5b0 <lv_task_del+0x30>)
 801e58c:	f7ff fb7c 	bl	801dc88 <lv_ll_rem>

    lv_mem_free(task);
 801e590:	6878      	ldr	r0, [r7, #4]
 801e592:	f7ff fdcd 	bl	801e130 <lv_mem_free>

    if(LV_GC_ROOT(_lv_task_act) == task) task_deleted = true; /*The active task was deleted*/
 801e596:	4b07      	ldr	r3, [pc, #28]	; (801e5b4 <lv_task_del+0x34>)
 801e598:	681b      	ldr	r3, [r3, #0]
 801e59a:	687a      	ldr	r2, [r7, #4]
 801e59c:	429a      	cmp	r2, r3
 801e59e:	d102      	bne.n	801e5a6 <lv_task_del+0x26>
 801e5a0:	4b05      	ldr	r3, [pc, #20]	; (801e5b8 <lv_task_del+0x38>)
 801e5a2:	2201      	movs	r2, #1
 801e5a4:	701a      	strb	r2, [r3, #0]
}
 801e5a6:	bf00      	nop
 801e5a8:	3708      	adds	r7, #8
 801e5aa:	46bd      	mov	sp, r7
 801e5ac:	bd80      	pop	{r7, pc}
 801e5ae:	bf00      	nop
 801e5b0:	24063624 	.word	0x24063624
 801e5b4:	24063664 	.word	0x24063664
 801e5b8:	240623ee 	.word	0x240623ee

0801e5bc <lv_task_set_prio>:
 * Set new priority for a lv_task
 * @param task pointer to a lv_task
 * @param prio the new priority
 */
void lv_task_set_prio(lv_task_t * task, lv_task_prio_t prio)
{
 801e5bc:	b580      	push	{r7, lr}
 801e5be:	b084      	sub	sp, #16
 801e5c0:	af00      	add	r7, sp, #0
 801e5c2:	6078      	str	r0, [r7, #4]
 801e5c4:	460b      	mov	r3, r1
 801e5c6:	70fb      	strb	r3, [r7, #3]
    if(task->prio == prio) return;
 801e5c8:	687b      	ldr	r3, [r7, #4]
 801e5ca:	7c1b      	ldrb	r3, [r3, #16]
 801e5cc:	f3c3 0302 	ubfx	r3, r3, #0, #3
 801e5d0:	b2db      	uxtb	r3, r3
 801e5d2:	461a      	mov	r2, r3
 801e5d4:	78fb      	ldrb	r3, [r7, #3]
 801e5d6:	429a      	cmp	r2, r3
 801e5d8:	d033      	beq.n	801e642 <lv_task_set_prio+0x86>

    /*Find the tasks with new priority*/
    lv_task_t * i;
    LV_LL_READ(LV_GC_ROOT(_lv_task_ll), i)
 801e5da:	481c      	ldr	r0, [pc, #112]	; (801e64c <lv_task_set_prio+0x90>)
 801e5dc:	f7ff fc02 	bl	801dde4 <lv_ll_get_head>
 801e5e0:	60f8      	str	r0, [r7, #12]
 801e5e2:	e017      	b.n	801e614 <lv_task_set_prio+0x58>
    {
        if(i->prio <= prio) {
 801e5e4:	68fb      	ldr	r3, [r7, #12]
 801e5e6:	7c1b      	ldrb	r3, [r3, #16]
 801e5e8:	f3c3 0302 	ubfx	r3, r3, #0, #3
 801e5ec:	b2db      	uxtb	r3, r3
 801e5ee:	461a      	mov	r2, r3
 801e5f0:	78fb      	ldrb	r3, [r7, #3]
 801e5f2:	429a      	cmp	r2, r3
 801e5f4:	dc09      	bgt.n	801e60a <lv_task_set_prio+0x4e>
            if(i != task) lv_ll_move_before(&LV_GC_ROOT(_lv_task_ll), task, i);
 801e5f6:	68fa      	ldr	r2, [r7, #12]
 801e5f8:	687b      	ldr	r3, [r7, #4]
 801e5fa:	429a      	cmp	r2, r3
 801e5fc:	d00e      	beq.n	801e61c <lv_task_set_prio+0x60>
 801e5fe:	68fa      	ldr	r2, [r7, #12]
 801e600:	6879      	ldr	r1, [r7, #4]
 801e602:	4812      	ldr	r0, [pc, #72]	; (801e64c <lv_task_set_prio+0x90>)
 801e604:	f7ff fc47 	bl	801de96 <lv_ll_move_before>
            break;
 801e608:	e008      	b.n	801e61c <lv_task_set_prio+0x60>
    LV_LL_READ(LV_GC_ROOT(_lv_task_ll), i)
 801e60a:	68f9      	ldr	r1, [r7, #12]
 801e60c:	480f      	ldr	r0, [pc, #60]	; (801e64c <lv_task_set_prio+0x90>)
 801e60e:	f7ff fc0f 	bl	801de30 <lv_ll_get_next>
 801e612:	60f8      	str	r0, [r7, #12]
 801e614:	68fb      	ldr	r3, [r7, #12]
 801e616:	2b00      	cmp	r3, #0
 801e618:	d1e4      	bne.n	801e5e4 <lv_task_set_prio+0x28>
 801e61a:	e000      	b.n	801e61e <lv_task_set_prio+0x62>
            break;
 801e61c:	bf00      	nop
        }
    }

    /*There was no such a low priority so far then add the node to the tail*/
    if(i == NULL) {
 801e61e:	68fb      	ldr	r3, [r7, #12]
 801e620:	2b00      	cmp	r3, #0
 801e622:	d104      	bne.n	801e62e <lv_task_set_prio+0x72>
        lv_ll_move_before(&LV_GC_ROOT(_lv_task_ll), task, NULL);
 801e624:	2200      	movs	r2, #0
 801e626:	6879      	ldr	r1, [r7, #4]
 801e628:	4808      	ldr	r0, [pc, #32]	; (801e64c <lv_task_set_prio+0x90>)
 801e62a:	f7ff fc34 	bl	801de96 <lv_ll_move_before>
    }

    task->prio = prio;
 801e62e:	78fb      	ldrb	r3, [r7, #3]
 801e630:	f003 0307 	and.w	r3, r3, #7
 801e634:	b2d9      	uxtb	r1, r3
 801e636:	687a      	ldr	r2, [r7, #4]
 801e638:	7c13      	ldrb	r3, [r2, #16]
 801e63a:	f361 0302 	bfi	r3, r1, #0, #3
 801e63e:	7413      	strb	r3, [r2, #16]
 801e640:	e000      	b.n	801e644 <lv_task_set_prio+0x88>
    if(task->prio == prio) return;
 801e642:	bf00      	nop
}
 801e644:	3710      	adds	r7, #16
 801e646:	46bd      	mov	sp, r7
 801e648:	bd80      	pop	{r7, pc}
 801e64a:	bf00      	nop
 801e64c:	24063624 	.word	0x24063624

0801e650 <lv_task_set_period>:
 * Set new period for a lv_task
 * @param task pointer to a lv_task
 * @param period the new period
 */
void lv_task_set_period(lv_task_t * task, uint32_t period)
{
 801e650:	b480      	push	{r7}
 801e652:	b083      	sub	sp, #12
 801e654:	af00      	add	r7, sp, #0
 801e656:	6078      	str	r0, [r7, #4]
 801e658:	6039      	str	r1, [r7, #0]
    task->period = period;
 801e65a:	687b      	ldr	r3, [r7, #4]
 801e65c:	683a      	ldr	r2, [r7, #0]
 801e65e:	601a      	str	r2, [r3, #0]
}
 801e660:	bf00      	nop
 801e662:	370c      	adds	r7, #12
 801e664:	46bd      	mov	sp, r7
 801e666:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e66a:	4770      	bx	lr

0801e66c <lv_task_ready>:
/**
 * Make a lv_task ready. It will not wait its period.
 * @param task pointer to a lv_task.
 */
void lv_task_ready(lv_task_t * task)
{
 801e66c:	b580      	push	{r7, lr}
 801e66e:	b082      	sub	sp, #8
 801e670:	af00      	add	r7, sp, #0
 801e672:	6078      	str	r0, [r7, #4]
    task->last_run = lv_tick_get() - task->period - 1;
 801e674:	f7fe fe32 	bl	801d2dc <lv_tick_get>
 801e678:	4602      	mov	r2, r0
 801e67a:	687b      	ldr	r3, [r7, #4]
 801e67c:	681b      	ldr	r3, [r3, #0]
 801e67e:	1ad3      	subs	r3, r2, r3
 801e680:	1e5a      	subs	r2, r3, #1
 801e682:	687b      	ldr	r3, [r7, #4]
 801e684:	605a      	str	r2, [r3, #4]
}
 801e686:	bf00      	nop
 801e688:	3708      	adds	r7, #8
 801e68a:	46bd      	mov	sp, r7
 801e68c:	bd80      	pop	{r7, pc}
	...

0801e690 <lv_task_enable>:
/**
 * Enable or disable the whole lv_task handling
 * @param en: true: lv_task handling is running, false: lv_task handling is suspended
 */
void lv_task_enable(bool en)
{
 801e690:	b480      	push	{r7}
 801e692:	b083      	sub	sp, #12
 801e694:	af00      	add	r7, sp, #0
 801e696:	4603      	mov	r3, r0
 801e698:	71fb      	strb	r3, [r7, #7]
    lv_task_run = en;
 801e69a:	4a04      	ldr	r2, [pc, #16]	; (801e6ac <lv_task_enable+0x1c>)
 801e69c:	79fb      	ldrb	r3, [r7, #7]
 801e69e:	7013      	strb	r3, [r2, #0]
}
 801e6a0:	bf00      	nop
 801e6a2:	370c      	adds	r7, #12
 801e6a4:	46bd      	mov	sp, r7
 801e6a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e6aa:	4770      	bx	lr
 801e6ac:	240623ec 	.word	0x240623ec

0801e6b0 <lv_task_exec>:
 * Execute task if its the priority is appropriate
 * @param task pointer to lv_task
 * @return true: execute, false: not executed
 */
static bool lv_task_exec(lv_task_t * task)
{
 801e6b0:	b580      	push	{r7, lr}
 801e6b2:	b084      	sub	sp, #16
 801e6b4:	af00      	add	r7, sp, #0
 801e6b6:	6078      	str	r0, [r7, #4]
    bool exec = false;
 801e6b8:	2300      	movs	r3, #0
 801e6ba:	73fb      	strb	r3, [r7, #15]

    /*Execute if at least 'period' time elapsed*/
    uint32_t elp = lv_tick_elaps(task->last_run);
 801e6bc:	687b      	ldr	r3, [r7, #4]
 801e6be:	685b      	ldr	r3, [r3, #4]
 801e6c0:	4618      	mov	r0, r3
 801e6c2:	f7fe fe25 	bl	801d310 <lv_tick_elaps>
 801e6c6:	60b8      	str	r0, [r7, #8]
    if(elp >= task->period) {
 801e6c8:	687b      	ldr	r3, [r7, #4]
 801e6ca:	681b      	ldr	r3, [r3, #0]
 801e6cc:	68ba      	ldr	r2, [r7, #8]
 801e6ce:	429a      	cmp	r2, r3
 801e6d0:	d325      	bcc.n	801e71e <lv_task_exec+0x6e>
        task->last_run = lv_tick_get();
 801e6d2:	f7fe fe03 	bl	801d2dc <lv_tick_get>
 801e6d6:	4602      	mov	r2, r0
 801e6d8:	687b      	ldr	r3, [r7, #4]
 801e6da:	605a      	str	r2, [r3, #4]
        task_deleted   = false;
 801e6dc:	4b12      	ldr	r3, [pc, #72]	; (801e728 <lv_task_exec+0x78>)
 801e6de:	2200      	movs	r2, #0
 801e6e0:	701a      	strb	r2, [r3, #0]
        task_created   = false;
 801e6e2:	4b12      	ldr	r3, [pc, #72]	; (801e72c <lv_task_exec+0x7c>)
 801e6e4:	2200      	movs	r2, #0
 801e6e6:	701a      	strb	r2, [r3, #0]
        if(task->task_cb) task->task_cb(task);
 801e6e8:	687b      	ldr	r3, [r7, #4]
 801e6ea:	689b      	ldr	r3, [r3, #8]
 801e6ec:	2b00      	cmp	r3, #0
 801e6ee:	d003      	beq.n	801e6f8 <lv_task_exec+0x48>
 801e6f0:	687b      	ldr	r3, [r7, #4]
 801e6f2:	689b      	ldr	r3, [r3, #8]
 801e6f4:	6878      	ldr	r0, [r7, #4]
 801e6f6:	4798      	blx	r3

        /*Delete if it was a one shot lv_task*/
        if(task_deleted == false) { /*The task might be deleted by itself as well*/
 801e6f8:	4b0b      	ldr	r3, [pc, #44]	; (801e728 <lv_task_exec+0x78>)
 801e6fa:	781b      	ldrb	r3, [r3, #0]
 801e6fc:	f083 0301 	eor.w	r3, r3, #1
 801e700:	b2db      	uxtb	r3, r3
 801e702:	2b00      	cmp	r3, #0
 801e704:	d009      	beq.n	801e71a <lv_task_exec+0x6a>
            if(task->once != 0) {
 801e706:	687b      	ldr	r3, [r7, #4]
 801e708:	7c1b      	ldrb	r3, [r3, #16]
 801e70a:	f003 0308 	and.w	r3, r3, #8
 801e70e:	b2db      	uxtb	r3, r3
 801e710:	2b00      	cmp	r3, #0
 801e712:	d002      	beq.n	801e71a <lv_task_exec+0x6a>
                lv_task_del(task);
 801e714:	6878      	ldr	r0, [r7, #4]
 801e716:	f7ff ff33 	bl	801e580 <lv_task_del>
            }
        }
        exec = true;
 801e71a:	2301      	movs	r3, #1
 801e71c:	73fb      	strb	r3, [r7, #15]
    }

    return exec;
 801e71e:	7bfb      	ldrb	r3, [r7, #15]
}
 801e720:	4618      	mov	r0, r3
 801e722:	3710      	adds	r7, #16
 801e724:	46bd      	mov	sp, r7
 801e726:	bd80      	pop	{r7, pc}
 801e728:	240623ee 	.word	0x240623ee
 801e72c:	240623ef 	.word	0x240623ef

0801e730 <lv_font_get_line_height>:
 * Get the line height of a font. All characters fit into this height
 * @param font_p pointer to a font
 * @return the height of a font
 */
static inline uint8_t lv_font_get_line_height(const lv_font_t * font_p)
{
 801e730:	b480      	push	{r7}
 801e732:	b083      	sub	sp, #12
 801e734:	af00      	add	r7, sp, #0
 801e736:	6078      	str	r0, [r7, #4]
    return font_p->line_height;
 801e738:	687b      	ldr	r3, [r7, #4]
 801e73a:	7a1b      	ldrb	r3, [r3, #8]
}
 801e73c:	4618      	mov	r0, r3
 801e73e:	370c      	adds	r7, #12
 801e740:	46bd      	mov	sp, r7
 801e742:	f85d 7b04 	ldr.w	r7, [sp], #4
 801e746:	4770      	bx	lr

0801e748 <lv_txt_get_size>:
 * @param max_width max with of the text (break the lines to fit this size) Set CORD_MAX to avoid
 * line breaks
 */
void lv_txt_get_size(lv_point_t * size_res, const char * text, const lv_font_t * font, lv_coord_t letter_space,
                     lv_coord_t line_space, lv_coord_t max_width, lv_txt_flag_t flag)
{
 801e748:	b580      	push	{r7, lr}
 801e74a:	b08a      	sub	sp, #40	; 0x28
 801e74c:	af02      	add	r7, sp, #8
 801e74e:	60f8      	str	r0, [r7, #12]
 801e750:	60b9      	str	r1, [r7, #8]
 801e752:	607a      	str	r2, [r7, #4]
 801e754:	807b      	strh	r3, [r7, #2]
    size_res->x = 0;
 801e756:	68fb      	ldr	r3, [r7, #12]
 801e758:	2200      	movs	r2, #0
 801e75a:	801a      	strh	r2, [r3, #0]
    size_res->y = 0;
 801e75c:	68fb      	ldr	r3, [r7, #12]
 801e75e:	2200      	movs	r2, #0
 801e760:	805a      	strh	r2, [r3, #2]

    if(text == NULL) return;
 801e762:	68bb      	ldr	r3, [r7, #8]
 801e764:	2b00      	cmp	r3, #0
 801e766:	f000 809a 	beq.w	801e89e <lv_txt_get_size+0x156>
    if(font == NULL) return;
 801e76a:	687b      	ldr	r3, [r7, #4]
 801e76c:	2b00      	cmp	r3, #0
 801e76e:	f000 8098 	beq.w	801e8a2 <lv_txt_get_size+0x15a>

    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
 801e772:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 801e776:	f003 0302 	and.w	r3, r3, #2
 801e77a:	2b00      	cmp	r3, #0
 801e77c:	d002      	beq.n	801e784 <lv_txt_get_size+0x3c>
 801e77e:	f647 4318 	movw	r3, #31768	; 0x7c18
 801e782:	85bb      	strh	r3, [r7, #44]	; 0x2c

    uint32_t line_start     = 0;
 801e784:	2300      	movs	r3, #0
 801e786:	61fb      	str	r3, [r7, #28]
    uint32_t new_line_start = 0;
 801e788:	2300      	movs	r3, #0
 801e78a:	61bb      	str	r3, [r7, #24]
    lv_coord_t act_line_length;
    uint8_t letter_height = lv_font_get_line_height(font);
 801e78c:	6878      	ldr	r0, [r7, #4]
 801e78e:	f7ff ffcf 	bl	801e730 <lv_font_get_line_height>
 801e792:	4603      	mov	r3, r0
 801e794:	75fb      	strb	r3, [r7, #23]

    /*Calc. the height and longest line*/
    while(text[line_start] != '\0') {
 801e796:	e048      	b.n	801e82a <lv_txt_get_size+0xe2>
        new_line_start += lv_txt_get_next_line(&text[line_start], font, letter_space, max_width, flag);
 801e798:	68ba      	ldr	r2, [r7, #8]
 801e79a:	69fb      	ldr	r3, [r7, #28]
 801e79c:	18d0      	adds	r0, r2, r3
 801e79e:	f9b7 102c 	ldrsh.w	r1, [r7, #44]	; 0x2c
 801e7a2:	f9b7 2002 	ldrsh.w	r2, [r7, #2]
 801e7a6:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 801e7aa:	9300      	str	r3, [sp, #0]
 801e7ac:	460b      	mov	r3, r1
 801e7ae:	6879      	ldr	r1, [r7, #4]
 801e7b0:	f000 f87c 	bl	801e8ac <lv_txt_get_next_line>
 801e7b4:	4603      	mov	r3, r0
 801e7b6:	461a      	mov	r2, r3
 801e7b8:	69bb      	ldr	r3, [r7, #24]
 801e7ba:	4413      	add	r3, r2
 801e7bc:	61bb      	str	r3, [r7, #24]
        size_res->y += letter_height;
 801e7be:	68fb      	ldr	r3, [r7, #12]
 801e7c0:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801e7c4:	b29a      	uxth	r2, r3
 801e7c6:	7dfb      	ldrb	r3, [r7, #23]
 801e7c8:	b29b      	uxth	r3, r3
 801e7ca:	4413      	add	r3, r2
 801e7cc:	b29b      	uxth	r3, r3
 801e7ce:	b21a      	sxth	r2, r3
 801e7d0:	68fb      	ldr	r3, [r7, #12]
 801e7d2:	805a      	strh	r2, [r3, #2]
        size_res->y += line_space;
 801e7d4:	68fb      	ldr	r3, [r7, #12]
 801e7d6:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801e7da:	b29a      	uxth	r2, r3
 801e7dc:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 801e7de:	4413      	add	r3, r2
 801e7e0:	b29b      	uxth	r3, r3
 801e7e2:	b21a      	sxth	r2, r3
 801e7e4:	68fb      	ldr	r3, [r7, #12]
 801e7e6:	805a      	strh	r2, [r3, #2]

        /*Calculate the the longest line*/
        act_line_length = lv_txt_get_width(&text[line_start], new_line_start - line_start, font, letter_space, flag);
 801e7e8:	68ba      	ldr	r2, [r7, #8]
 801e7ea:	69fb      	ldr	r3, [r7, #28]
 801e7ec:	18d0      	adds	r0, r2, r3
 801e7ee:	69bb      	ldr	r3, [r7, #24]
 801e7f0:	b29a      	uxth	r2, r3
 801e7f2:	69fb      	ldr	r3, [r7, #28]
 801e7f4:	b29b      	uxth	r3, r3
 801e7f6:	1ad3      	subs	r3, r2, r3
 801e7f8:	b299      	uxth	r1, r3
 801e7fa:	f9b7 2002 	ldrsh.w	r2, [r7, #2]
 801e7fe:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 801e802:	9300      	str	r3, [sp, #0]
 801e804:	4613      	mov	r3, r2
 801e806:	687a      	ldr	r2, [r7, #4]
 801e808:	f000 f902 	bl	801ea10 <lv_txt_get_width>
 801e80c:	4603      	mov	r3, r0
 801e80e:	82bb      	strh	r3, [r7, #20]

        size_res->x = LV_MATH_MAX(act_line_length, size_res->x);
 801e810:	68fb      	ldr	r3, [r7, #12]
 801e812:	f9b3 3000 	ldrsh.w	r3, [r3]
 801e816:	f9b7 2014 	ldrsh.w	r2, [r7, #20]
 801e81a:	4293      	cmp	r3, r2
 801e81c:	bfb8      	it	lt
 801e81e:	4613      	movlt	r3, r2
 801e820:	b21a      	sxth	r2, r3
 801e822:	68fb      	ldr	r3, [r7, #12]
 801e824:	801a      	strh	r2, [r3, #0]
        line_start  = new_line_start;
 801e826:	69bb      	ldr	r3, [r7, #24]
 801e828:	61fb      	str	r3, [r7, #28]
    while(text[line_start] != '\0') {
 801e82a:	68ba      	ldr	r2, [r7, #8]
 801e82c:	69fb      	ldr	r3, [r7, #28]
 801e82e:	4413      	add	r3, r2
 801e830:	781b      	ldrb	r3, [r3, #0]
 801e832:	2b00      	cmp	r3, #0
 801e834:	d1b0      	bne.n	801e798 <lv_txt_get_size+0x50>
    }

    /*Ma ke the text one line taller if the last character is '\n' or '\r'*/
    if((line_start != 0) && (text[line_start - 1] == '\n' || text[line_start - 1] == '\r')) {
 801e836:	69fb      	ldr	r3, [r7, #28]
 801e838:	2b00      	cmp	r3, #0
 801e83a:	d01b      	beq.n	801e874 <lv_txt_get_size+0x12c>
 801e83c:	69fb      	ldr	r3, [r7, #28]
 801e83e:	3b01      	subs	r3, #1
 801e840:	68ba      	ldr	r2, [r7, #8]
 801e842:	4413      	add	r3, r2
 801e844:	781b      	ldrb	r3, [r3, #0]
 801e846:	2b0a      	cmp	r3, #10
 801e848:	d006      	beq.n	801e858 <lv_txt_get_size+0x110>
 801e84a:	69fb      	ldr	r3, [r7, #28]
 801e84c:	3b01      	subs	r3, #1
 801e84e:	68ba      	ldr	r2, [r7, #8]
 801e850:	4413      	add	r3, r2
 801e852:	781b      	ldrb	r3, [r3, #0]
 801e854:	2b0d      	cmp	r3, #13
 801e856:	d10d      	bne.n	801e874 <lv_txt_get_size+0x12c>
        size_res->y += letter_height + line_space;
 801e858:	68fb      	ldr	r3, [r7, #12]
 801e85a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801e85e:	b29a      	uxth	r2, r3
 801e860:	7dfb      	ldrb	r3, [r7, #23]
 801e862:	b299      	uxth	r1, r3
 801e864:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 801e866:	440b      	add	r3, r1
 801e868:	b29b      	uxth	r3, r3
 801e86a:	4413      	add	r3, r2
 801e86c:	b29b      	uxth	r3, r3
 801e86e:	b21a      	sxth	r2, r3
 801e870:	68fb      	ldr	r3, [r7, #12]
 801e872:	805a      	strh	r2, [r3, #2]
    }

    /*Correction with the last line space or set the height manually if the text is empty*/
    if(size_res->y == 0)
 801e874:	68fb      	ldr	r3, [r7, #12]
 801e876:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801e87a:	2b00      	cmp	r3, #0
 801e87c:	d104      	bne.n	801e888 <lv_txt_get_size+0x140>
        size_res->y = letter_height;
 801e87e:	7dfb      	ldrb	r3, [r7, #23]
 801e880:	b21a      	sxth	r2, r3
 801e882:	68fb      	ldr	r3, [r7, #12]
 801e884:	805a      	strh	r2, [r3, #2]
 801e886:	e00d      	b.n	801e8a4 <lv_txt_get_size+0x15c>
    else
        size_res->y -= line_space;
 801e888:	68fb      	ldr	r3, [r7, #12]
 801e88a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801e88e:	b29a      	uxth	r2, r3
 801e890:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 801e892:	1ad3      	subs	r3, r2, r3
 801e894:	b29b      	uxth	r3, r3
 801e896:	b21a      	sxth	r2, r3
 801e898:	68fb      	ldr	r3, [r7, #12]
 801e89a:	805a      	strh	r2, [r3, #2]
 801e89c:	e002      	b.n	801e8a4 <lv_txt_get_size+0x15c>
    if(text == NULL) return;
 801e89e:	bf00      	nop
 801e8a0:	e000      	b.n	801e8a4 <lv_txt_get_size+0x15c>
    if(font == NULL) return;
 801e8a2:	bf00      	nop
}
 801e8a4:	3720      	adds	r7, #32
 801e8a6:	46bd      	mov	sp, r7
 801e8a8:	bd80      	pop	{r7, pc}
	...

0801e8ac <lv_txt_get_next_line>:
 * @param flags settings for the text from 'txt_flag_type' enum
 * @return the index of the first char of the new line (in byte index not letter index. With UTF-8 they are different)
 */
uint16_t lv_txt_get_next_line(const char * txt, const lv_font_t * font, lv_coord_t letter_space, lv_coord_t max_width,
                              lv_txt_flag_t flag)
{
 801e8ac:	b580      	push	{r7, lr}
 801e8ae:	b08c      	sub	sp, #48	; 0x30
 801e8b0:	af00      	add	r7, sp, #0
 801e8b2:	60f8      	str	r0, [r7, #12]
 801e8b4:	60b9      	str	r1, [r7, #8]
 801e8b6:	4611      	mov	r1, r2
 801e8b8:	461a      	mov	r2, r3
 801e8ba:	460b      	mov	r3, r1
 801e8bc:	80fb      	strh	r3, [r7, #6]
 801e8be:	4613      	mov	r3, r2
 801e8c0:	80bb      	strh	r3, [r7, #4]
    if(txt == NULL) return 0;
 801e8c2:	68fb      	ldr	r3, [r7, #12]
 801e8c4:	2b00      	cmp	r3, #0
 801e8c6:	d101      	bne.n	801e8cc <lv_txt_get_next_line+0x20>
 801e8c8:	2300      	movs	r3, #0
 801e8ca:	e099      	b.n	801ea00 <lv_txt_get_next_line+0x154>
    if(font == NULL) return 0;
 801e8cc:	68bb      	ldr	r3, [r7, #8]
 801e8ce:	2b00      	cmp	r3, #0
 801e8d0:	d101      	bne.n	801e8d6 <lv_txt_get_next_line+0x2a>
 801e8d2:	2300      	movs	r3, #0
 801e8d4:	e094      	b.n	801ea00 <lv_txt_get_next_line+0x154>

    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
 801e8d6:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 801e8da:	f003 0302 	and.w	r3, r3, #2
 801e8de:	2b00      	cmp	r3, #0
 801e8e0:	d002      	beq.n	801e8e8 <lv_txt_get_next_line+0x3c>
 801e8e2:	f647 4318 	movw	r3, #31768	; 0x7c18
 801e8e6:	80bb      	strh	r3, [r7, #4]

    uint32_t i                   = 0;
 801e8e8:	2300      	movs	r3, #0
 801e8ea:	61bb      	str	r3, [r7, #24]
    uint32_t i_next              = 0;
 801e8ec:	2300      	movs	r3, #0
 801e8ee:	617b      	str	r3, [r7, #20]
    lv_coord_t cur_w             = 0;
 801e8f0:	2300      	movs	r3, #0
 801e8f2:	85fb      	strh	r3, [r7, #46]	; 0x2e
    uint32_t last_break          = NO_BREAK_FOUND;
 801e8f4:	f04f 33ff 	mov.w	r3, #4294967295
 801e8f8:	62bb      	str	r3, [r7, #40]	; 0x28
    lv_txt_cmd_state_t cmd_state = LV_TXT_CMD_STATE_WAIT;
 801e8fa:	2300      	movs	r3, #0
 801e8fc:	74fb      	strb	r3, [r7, #19]
    uint32_t letter_w;
    uint32_t letter      = 0;
 801e8fe:	2300      	movs	r3, #0
 801e900:	623b      	str	r3, [r7, #32]
    uint32_t letter_next = 0;
 801e902:	2300      	movs	r3, #0
 801e904:	627b      	str	r3, [r7, #36]	; 0x24

    letter_next = lv_txt_encoded_next(txt, &i_next);
 801e906:	4b40      	ldr	r3, [pc, #256]	; (801ea08 <lv_txt_get_next_line+0x15c>)
 801e908:	681b      	ldr	r3, [r3, #0]
 801e90a:	f107 0214 	add.w	r2, r7, #20
 801e90e:	4611      	mov	r1, r2
 801e910:	68f8      	ldr	r0, [r7, #12]
 801e912:	4798      	blx	r3
 801e914:	6278      	str	r0, [r7, #36]	; 0x24

    while(txt[i] != '\0') {
 801e916:	e06b      	b.n	801e9f0 <lv_txt_get_next_line+0x144>
        letter      = letter_next;
 801e918:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e91a:	623b      	str	r3, [r7, #32]
        i           = i_next;
 801e91c:	697b      	ldr	r3, [r7, #20]
 801e91e:	61bb      	str	r3, [r7, #24]
        letter_next = lv_txt_encoded_next(txt, &i_next);
 801e920:	4b39      	ldr	r3, [pc, #228]	; (801ea08 <lv_txt_get_next_line+0x15c>)
 801e922:	681b      	ldr	r3, [r3, #0]
 801e924:	f107 0214 	add.w	r2, r7, #20
 801e928:	4611      	mov	r1, r2
 801e92a:	68f8      	ldr	r0, [r7, #12]
 801e92c:	4798      	blx	r3
 801e92e:	6278      	str	r0, [r7, #36]	; 0x24

        /*Handle the recolor command*/
        if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
 801e930:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 801e934:	f003 0301 	and.w	r3, r3, #1
 801e938:	2b00      	cmp	r3, #0
 801e93a:	d009      	beq.n	801e950 <lv_txt_get_next_line+0xa4>
            if(lv_txt_is_cmd(&cmd_state, letter) != false) {
 801e93c:	f107 0313 	add.w	r3, r7, #19
 801e940:	6a39      	ldr	r1, [r7, #32]
 801e942:	4618      	mov	r0, r3
 801e944:	f000 f8ce 	bl	801eae4 <lv_txt_is_cmd>
 801e948:	4603      	mov	r3, r0
 801e94a:	2b00      	cmp	r3, #0
 801e94c:	d000      	beq.n	801e950 <lv_txt_get_next_line+0xa4>
                continue; /*Skip the letter is it is part of a command*/
 801e94e:	e04f      	b.n	801e9f0 <lv_txt_get_next_line+0x144>
            }
        }

        /*Check for new line chars*/
        if(letter == '\n' || letter == '\r') {
 801e950:	6a3b      	ldr	r3, [r7, #32]
 801e952:	2b0a      	cmp	r3, #10
 801e954:	d002      	beq.n	801e95c <lv_txt_get_next_line+0xb0>
 801e956:	6a3b      	ldr	r3, [r7, #32]
 801e958:	2b0d      	cmp	r3, #13
 801e95a:	d10b      	bne.n	801e974 <lv_txt_get_next_line+0xc8>
            /*Return with the first letter of the next line*/
            if(letter == '\r' && letter_next == '\n')
 801e95c:	6a3b      	ldr	r3, [r7, #32]
 801e95e:	2b0d      	cmp	r3, #13
 801e960:	d105      	bne.n	801e96e <lv_txt_get_next_line+0xc2>
 801e962:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801e964:	2b0a      	cmp	r3, #10
 801e966:	d102      	bne.n	801e96e <lv_txt_get_next_line+0xc2>
                return i_next;
 801e968:	697b      	ldr	r3, [r7, #20]
 801e96a:	b29b      	uxth	r3, r3
 801e96c:	e048      	b.n	801ea00 <lv_txt_get_next_line+0x154>
            else
                return i;
 801e96e:	69bb      	ldr	r3, [r7, #24]
 801e970:	b29b      	uxth	r3, r3
 801e972:	e045      	b.n	801ea00 <lv_txt_get_next_line+0x154>
        } else { /*Check the actual length*/
            letter_w = lv_font_get_glyph_width(font, letter, letter_next);
 801e974:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801e976:	6a39      	ldr	r1, [r7, #32]
 801e978:	68b8      	ldr	r0, [r7, #8]
 801e97a:	f7fd fff3 	bl	801c964 <lv_font_get_glyph_width>
 801e97e:	4603      	mov	r3, r0
 801e980:	61fb      	str	r3, [r7, #28]
            cur_w += letter_w;
 801e982:	69fb      	ldr	r3, [r7, #28]
 801e984:	b29a      	uxth	r2, r3
 801e986:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 801e988:	4413      	add	r3, r2
 801e98a:	b29b      	uxth	r3, r3
 801e98c:	85fb      	strh	r3, [r7, #46]	; 0x2e

            /*If the txt is too long then finish, this is the line end*/
            if(cur_w > max_width) {
 801e98e:	f9b7 202e 	ldrsh.w	r2, [r7, #46]	; 0x2e
 801e992:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 801e996:	429a      	cmp	r2, r3
 801e998:	dd1a      	ble.n	801e9d0 <lv_txt_get_next_line+0x124>
                /*If a break character was already found break there*/
                if(last_break != NO_BREAK_FOUND) {
 801e99a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801e99c:	f1b3 3fff 	cmp.w	r3, #4294967295
 801e9a0:	d002      	beq.n	801e9a8 <lv_txt_get_next_line+0xfc>
                    i = last_break;
 801e9a2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801e9a4:	61bb      	str	r3, [r7, #24]
 801e9a6:	e006      	b.n	801e9b6 <lv_txt_get_next_line+0x10a>
                } else {
                    /* Now this character is out of the area so it will be first character of the next line*/
                    /* But 'i' already points to the next character (because of lv_txt_utf8_next) step beck one*/
                    lv_txt_encoded_prev(txt, &i);
 801e9a8:	4b18      	ldr	r3, [pc, #96]	; (801ea0c <lv_txt_get_next_line+0x160>)
 801e9aa:	681b      	ldr	r3, [r3, #0]
 801e9ac:	f107 0218 	add.w	r2, r7, #24
 801e9b0:	4611      	mov	r1, r2
 801e9b2:	68f8      	ldr	r0, [r7, #12]
 801e9b4:	4798      	blx	r3
                }

                /* Do not let to return without doing nothing.
                 * Find at least one character (Avoid infinite loop )*/
                if(i == 0) lv_txt_encoded_next(txt, &i);
 801e9b6:	69bb      	ldr	r3, [r7, #24]
 801e9b8:	2b00      	cmp	r3, #0
 801e9ba:	d106      	bne.n	801e9ca <lv_txt_get_next_line+0x11e>
 801e9bc:	4b12      	ldr	r3, [pc, #72]	; (801ea08 <lv_txt_get_next_line+0x15c>)
 801e9be:	681b      	ldr	r3, [r3, #0]
 801e9c0:	f107 0218 	add.w	r2, r7, #24
 801e9c4:	4611      	mov	r1, r2
 801e9c6:	68f8      	ldr	r0, [r7, #12]
 801e9c8:	4798      	blx	r3

                return i;
 801e9ca:	69bb      	ldr	r3, [r7, #24]
 801e9cc:	b29b      	uxth	r3, r3
 801e9ce:	e017      	b.n	801ea00 <lv_txt_get_next_line+0x154>
            }
            /*If this char still can fit to this line then check if
             * txt can be broken here later */
            else if(is_break_char(letter)) {
 801e9d0:	6a38      	ldr	r0, [r7, #32]
 801e9d2:	f000 faa9 	bl	801ef28 <is_break_char>
 801e9d6:	4603      	mov	r3, r0
 801e9d8:	2b00      	cmp	r3, #0
 801e9da:	d001      	beq.n	801e9e0 <lv_txt_get_next_line+0x134>
                last_break = i; /*Save the first char index after break*/
 801e9dc:	69bb      	ldr	r3, [r7, #24]
 801e9de:	62bb      	str	r3, [r7, #40]	; 0x28
            }
        }

        if(letter_w > 0) {
 801e9e0:	69fb      	ldr	r3, [r7, #28]
 801e9e2:	2b00      	cmp	r3, #0
 801e9e4:	d004      	beq.n	801e9f0 <lv_txt_get_next_line+0x144>
            cur_w += letter_space;
 801e9e6:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801e9e8:	88fb      	ldrh	r3, [r7, #6]
 801e9ea:	4413      	add	r3, r2
 801e9ec:	b29b      	uxth	r3, r3
 801e9ee:	85fb      	strh	r3, [r7, #46]	; 0x2e
    while(txt[i] != '\0') {
 801e9f0:	69bb      	ldr	r3, [r7, #24]
 801e9f2:	68fa      	ldr	r2, [r7, #12]
 801e9f4:	4413      	add	r3, r2
 801e9f6:	781b      	ldrb	r3, [r3, #0]
 801e9f8:	2b00      	cmp	r3, #0
 801e9fa:	d18d      	bne.n	801e918 <lv_txt_get_next_line+0x6c>
        }
    }

    return i;
 801e9fc:	69bb      	ldr	r3, [r7, #24]
 801e9fe:	b29b      	uxth	r3, r3
}
 801ea00:	4618      	mov	r0, r3
 801ea02:	3730      	adds	r7, #48	; 0x30
 801ea04:	46bd      	mov	sp, r7
 801ea06:	bd80      	pop	{r7, pc}
 801ea08:	240001d0 	.word	0x240001d0
 801ea0c:	240001d4 	.word	0x240001d4

0801ea10 <lv_txt_get_width>:
 * @param flags settings for the text from 'txt_flag_t' enum
 * @return length of a char_num long text
 */
lv_coord_t lv_txt_get_width(const char * txt, uint16_t length, const lv_font_t * font, lv_coord_t letter_space,
                            lv_txt_flag_t flag)
{
 801ea10:	b580      	push	{r7, lr}
 801ea12:	b08a      	sub	sp, #40	; 0x28
 801ea14:	af00      	add	r7, sp, #0
 801ea16:	60f8      	str	r0, [r7, #12]
 801ea18:	607a      	str	r2, [r7, #4]
 801ea1a:	461a      	mov	r2, r3
 801ea1c:	460b      	mov	r3, r1
 801ea1e:	817b      	strh	r3, [r7, #10]
 801ea20:	4613      	mov	r3, r2
 801ea22:	813b      	strh	r3, [r7, #8]
    if(txt == NULL) return 0;
 801ea24:	68fb      	ldr	r3, [r7, #12]
 801ea26:	2b00      	cmp	r3, #0
 801ea28:	d101      	bne.n	801ea2e <lv_txt_get_width+0x1e>
 801ea2a:	2300      	movs	r3, #0
 801ea2c:	e053      	b.n	801ead6 <lv_txt_get_width+0xc6>
    if(font == NULL) return 0;
 801ea2e:	687b      	ldr	r3, [r7, #4]
 801ea30:	2b00      	cmp	r3, #0
 801ea32:	d101      	bne.n	801ea38 <lv_txt_get_width+0x28>
 801ea34:	2300      	movs	r3, #0
 801ea36:	e04e      	b.n	801ead6 <lv_txt_get_width+0xc6>

    uint32_t i                   = 0;
 801ea38:	2300      	movs	r3, #0
 801ea3a:	617b      	str	r3, [r7, #20]
    lv_coord_t width             = 0;
 801ea3c:	2300      	movs	r3, #0
 801ea3e:	84fb      	strh	r3, [r7, #38]	; 0x26
    lv_txt_cmd_state_t cmd_state = LV_TXT_CMD_STATE_WAIT;
 801ea40:	2300      	movs	r3, #0
 801ea42:	74fb      	strb	r3, [r7, #19]
    uint32_t letter;
    uint32_t letter_next;

    if(length != 0) {
 801ea44:	897b      	ldrh	r3, [r7, #10]
 801ea46:	2b00      	cmp	r3, #0
 801ea48:	d043      	beq.n	801ead2 <lv_txt_get_width+0xc2>
        while(i < length) {
 801ea4a:	e035      	b.n	801eab8 <lv_txt_get_width+0xa8>
            letter      = lv_txt_encoded_next(txt, &i);
 801ea4c:	4b24      	ldr	r3, [pc, #144]	; (801eae0 <lv_txt_get_width+0xd0>)
 801ea4e:	681b      	ldr	r3, [r3, #0]
 801ea50:	f107 0214 	add.w	r2, r7, #20
 801ea54:	4611      	mov	r1, r2
 801ea56:	68f8      	ldr	r0, [r7, #12]
 801ea58:	4798      	blx	r3
 801ea5a:	6238      	str	r0, [r7, #32]
            letter_next = lv_txt_encoded_next(&txt[i], NULL);
 801ea5c:	4b20      	ldr	r3, [pc, #128]	; (801eae0 <lv_txt_get_width+0xd0>)
 801ea5e:	681b      	ldr	r3, [r3, #0]
 801ea60:	697a      	ldr	r2, [r7, #20]
 801ea62:	68f9      	ldr	r1, [r7, #12]
 801ea64:	440a      	add	r2, r1
 801ea66:	2100      	movs	r1, #0
 801ea68:	4610      	mov	r0, r2
 801ea6a:	4798      	blx	r3
 801ea6c:	61f8      	str	r0, [r7, #28]
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
 801ea6e:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 801ea72:	f003 0301 	and.w	r3, r3, #1
 801ea76:	2b00      	cmp	r3, #0
 801ea78:	d009      	beq.n	801ea8e <lv_txt_get_width+0x7e>
                if(lv_txt_is_cmd(&cmd_state, letter) != false) {
 801ea7a:	f107 0313 	add.w	r3, r7, #19
 801ea7e:	6a39      	ldr	r1, [r7, #32]
 801ea80:	4618      	mov	r0, r3
 801ea82:	f000 f82f 	bl	801eae4 <lv_txt_is_cmd>
 801ea86:	4603      	mov	r3, r0
 801ea88:	2b00      	cmp	r3, #0
 801ea8a:	d000      	beq.n	801ea8e <lv_txt_get_width+0x7e>
                    continue;
 801ea8c:	e014      	b.n	801eab8 <lv_txt_get_width+0xa8>
                }
            }

            lv_coord_t char_width = lv_font_get_glyph_width(font, letter, letter_next);
 801ea8e:	69fa      	ldr	r2, [r7, #28]
 801ea90:	6a39      	ldr	r1, [r7, #32]
 801ea92:	6878      	ldr	r0, [r7, #4]
 801ea94:	f7fd ff66 	bl	801c964 <lv_font_get_glyph_width>
 801ea98:	4603      	mov	r3, r0
 801ea9a:	837b      	strh	r3, [r7, #26]
            if(char_width > 0) {
 801ea9c:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 801eaa0:	2b00      	cmp	r3, #0
 801eaa2:	dd09      	ble.n	801eab8 <lv_txt_get_width+0xa8>
                width += char_width;
 801eaa4:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801eaa6:	8b7b      	ldrh	r3, [r7, #26]
 801eaa8:	4413      	add	r3, r2
 801eaaa:	b29b      	uxth	r3, r3
 801eaac:	84fb      	strh	r3, [r7, #38]	; 0x26
                width += letter_space;
 801eaae:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801eab0:	893b      	ldrh	r3, [r7, #8]
 801eab2:	4413      	add	r3, r2
 801eab4:	b29b      	uxth	r3, r3
 801eab6:	84fb      	strh	r3, [r7, #38]	; 0x26
        while(i < length) {
 801eab8:	897a      	ldrh	r2, [r7, #10]
 801eaba:	697b      	ldr	r3, [r7, #20]
 801eabc:	429a      	cmp	r2, r3
 801eabe:	d8c5      	bhi.n	801ea4c <lv_txt_get_width+0x3c>
            }
        }

        if(width > 0) {
 801eac0:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 801eac4:	2b00      	cmp	r3, #0
 801eac6:	dd04      	ble.n	801ead2 <lv_txt_get_width+0xc2>
            width -= letter_space; /*Trim the last letter space. Important if the text is center
 801eac8:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801eaca:	893b      	ldrh	r3, [r7, #8]
 801eacc:	1ad3      	subs	r3, r2, r3
 801eace:	b29b      	uxth	r3, r3
 801ead0:	84fb      	strh	r3, [r7, #38]	; 0x26
                                      aligned */
        }
    }

    return width;
 801ead2:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
}
 801ead6:	4618      	mov	r0, r3
 801ead8:	3728      	adds	r7, #40	; 0x28
 801eada:	46bd      	mov	sp, r7
 801eadc:	bd80      	pop	{r7, pc}
 801eade:	bf00      	nop
 801eae0:	240001d0 	.word	0x240001d0

0801eae4 <lv_txt_is_cmd>:
 * @param c the current character
 * @return true: the character is part of a command and should not be written,
 *         false: the character should be written
 */
bool lv_txt_is_cmd(lv_txt_cmd_state_t * state, uint32_t c)
{
 801eae4:	b480      	push	{r7}
 801eae6:	b085      	sub	sp, #20
 801eae8:	af00      	add	r7, sp, #0
 801eaea:	6078      	str	r0, [r7, #4]
 801eaec:	6039      	str	r1, [r7, #0]
    bool ret = false;
 801eaee:	2300      	movs	r3, #0
 801eaf0:	73fb      	strb	r3, [r7, #15]

    if(c == (uint32_t)LV_TXT_COLOR_CMD[0]) {
 801eaf2:	2323      	movs	r3, #35	; 0x23
 801eaf4:	461a      	mov	r2, r3
 801eaf6:	683b      	ldr	r3, [r7, #0]
 801eaf8:	4293      	cmp	r3, r2
 801eafa:	d11a      	bne.n	801eb32 <lv_txt_is_cmd+0x4e>
        if(*state == LV_TXT_CMD_STATE_WAIT) { /*Start char*/
 801eafc:	687b      	ldr	r3, [r7, #4]
 801eafe:	781b      	ldrb	r3, [r3, #0]
 801eb00:	2b00      	cmp	r3, #0
 801eb02:	d105      	bne.n	801eb10 <lv_txt_is_cmd+0x2c>
            *state = LV_TXT_CMD_STATE_PAR;
 801eb04:	687b      	ldr	r3, [r7, #4]
 801eb06:	2201      	movs	r2, #1
 801eb08:	701a      	strb	r2, [r3, #0]
            ret    = true;
 801eb0a:	2301      	movs	r3, #1
 801eb0c:	73fb      	strb	r3, [r7, #15]
 801eb0e:	e010      	b.n	801eb32 <lv_txt_is_cmd+0x4e>
        }
        /*Other start char in parameter is escaped cmd. char */
        else if(*state == LV_TXT_CMD_STATE_PAR) {
 801eb10:	687b      	ldr	r3, [r7, #4]
 801eb12:	781b      	ldrb	r3, [r3, #0]
 801eb14:	2b01      	cmp	r3, #1
 801eb16:	d103      	bne.n	801eb20 <lv_txt_is_cmd+0x3c>
            *state = LV_TXT_CMD_STATE_WAIT;
 801eb18:	687b      	ldr	r3, [r7, #4]
 801eb1a:	2200      	movs	r2, #0
 801eb1c:	701a      	strb	r2, [r3, #0]
 801eb1e:	e008      	b.n	801eb32 <lv_txt_is_cmd+0x4e>
        }
        /*Command end */
        else if(*state == LV_TXT_CMD_STATE_IN) {
 801eb20:	687b      	ldr	r3, [r7, #4]
 801eb22:	781b      	ldrb	r3, [r3, #0]
 801eb24:	2b02      	cmp	r3, #2
 801eb26:	d104      	bne.n	801eb32 <lv_txt_is_cmd+0x4e>
            *state = LV_TXT_CMD_STATE_WAIT;
 801eb28:	687b      	ldr	r3, [r7, #4]
 801eb2a:	2200      	movs	r2, #0
 801eb2c:	701a      	strb	r2, [r3, #0]
            ret    = true;
 801eb2e:	2301      	movs	r3, #1
 801eb30:	73fb      	strb	r3, [r7, #15]
        }
    }

    /*Skip the color parameter and wait the space after it*/
    if(*state == LV_TXT_CMD_STATE_PAR) {
 801eb32:	687b      	ldr	r3, [r7, #4]
 801eb34:	781b      	ldrb	r3, [r3, #0]
 801eb36:	2b01      	cmp	r3, #1
 801eb38:	d107      	bne.n	801eb4a <lv_txt_is_cmd+0x66>
        if(c == ' ') {
 801eb3a:	683b      	ldr	r3, [r7, #0]
 801eb3c:	2b20      	cmp	r3, #32
 801eb3e:	d102      	bne.n	801eb46 <lv_txt_is_cmd+0x62>
            *state = LV_TXT_CMD_STATE_IN; /*After the parameter the text is in the command*/
 801eb40:	687b      	ldr	r3, [r7, #4]
 801eb42:	2202      	movs	r2, #2
 801eb44:	701a      	strb	r2, [r3, #0]
        }
        ret = true;
 801eb46:	2301      	movs	r3, #1
 801eb48:	73fb      	strb	r3, [r7, #15]
    }

    return ret;
 801eb4a:	7bfb      	ldrb	r3, [r7, #15]
}
 801eb4c:	4618      	mov	r0, r3
 801eb4e:	3714      	adds	r7, #20
 801eb50:	46bd      	mov	sp, r7
 801eb52:	f85d 7b04 	ldr.w	r7, [sp], #4
 801eb56:	4770      	bx	lr

0801eb58 <lv_txt_utf8_size>:
 * Give the size of an UTF-8 coded character
 * @param str pointer to a character in a string
 * @return length of the UTF-8 character (1,2,3 or 4). O on invalid code
 */
static uint8_t lv_txt_utf8_size(const char * str)
{
 801eb58:	b480      	push	{r7}
 801eb5a:	b083      	sub	sp, #12
 801eb5c:	af00      	add	r7, sp, #0
 801eb5e:	6078      	str	r0, [r7, #4]
    if((str[0] & 0x80) == 0)
 801eb60:	687b      	ldr	r3, [r7, #4]
 801eb62:	781b      	ldrb	r3, [r3, #0]
 801eb64:	b25b      	sxtb	r3, r3
 801eb66:	2b00      	cmp	r3, #0
 801eb68:	db01      	blt.n	801eb6e <lv_txt_utf8_size+0x16>
        return 1;
 801eb6a:	2301      	movs	r3, #1
 801eb6c:	e018      	b.n	801eba0 <lv_txt_utf8_size+0x48>
    else if((str[0] & 0xE0) == 0xC0)
 801eb6e:	687b      	ldr	r3, [r7, #4]
 801eb70:	781b      	ldrb	r3, [r3, #0]
 801eb72:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
 801eb76:	2bc0      	cmp	r3, #192	; 0xc0
 801eb78:	d101      	bne.n	801eb7e <lv_txt_utf8_size+0x26>
        return 2;
 801eb7a:	2302      	movs	r3, #2
 801eb7c:	e010      	b.n	801eba0 <lv_txt_utf8_size+0x48>
    else if((str[0] & 0xF0) == 0xE0)
 801eb7e:	687b      	ldr	r3, [r7, #4]
 801eb80:	781b      	ldrb	r3, [r3, #0]
 801eb82:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 801eb86:	2be0      	cmp	r3, #224	; 0xe0
 801eb88:	d101      	bne.n	801eb8e <lv_txt_utf8_size+0x36>
        return 3;
 801eb8a:	2303      	movs	r3, #3
 801eb8c:	e008      	b.n	801eba0 <lv_txt_utf8_size+0x48>
    else if((str[0] & 0xF8) == 0xF0)
 801eb8e:	687b      	ldr	r3, [r7, #4]
 801eb90:	781b      	ldrb	r3, [r3, #0]
 801eb92:	f003 03f8 	and.w	r3, r3, #248	; 0xf8
 801eb96:	2bf0      	cmp	r3, #240	; 0xf0
 801eb98:	d101      	bne.n	801eb9e <lv_txt_utf8_size+0x46>
        return 4;
 801eb9a:	2304      	movs	r3, #4
 801eb9c:	e000      	b.n	801eba0 <lv_txt_utf8_size+0x48>
    return 1; /*If the char was invalid step tell it's 1 byte long*/
 801eb9e:	2301      	movs	r3, #1
}
 801eba0:	4618      	mov	r0, r3
 801eba2:	370c      	adds	r7, #12
 801eba4:	46bd      	mov	sp, r7
 801eba6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ebaa:	4770      	bx	lr

0801ebac <lv_txt_utf8_next>:
 *          After call it will point to the next UTF-8 char in 'txt'.
 *          NULL to use txt[0] as index
 * @return the decoded Unicode character or 0 on invalid UTF-8 code
 */
static uint32_t lv_txt_utf8_next(const char * txt, uint32_t * i)
{
 801ebac:	b480      	push	{r7}
 801ebae:	b085      	sub	sp, #20
 801ebb0:	af00      	add	r7, sp, #0
 801ebb2:	6078      	str	r0, [r7, #4]
 801ebb4:	6039      	str	r1, [r7, #0]
     * 00000000 00000000 00000yyy yyxxxxxx -> 110yyyyy 10xxxxxx
     * 00000000 00000000 zzzzyyyy yyxxxxxx -> 1110zzzz 10yyyyyy 10xxxxxx
     * 00000000 000wwwzz zzzzyyyy yyxxxxxx -> 11110www 10zzzzzz 10yyyyyy 10xxxxxx
     * */

    uint32_t result = 0;
 801ebb6:	2300      	movs	r3, #0
 801ebb8:	60fb      	str	r3, [r7, #12]

    /*Dummy 'i' pointer is required*/
    uint32_t i_tmp = 0;
 801ebba:	2300      	movs	r3, #0
 801ebbc:	60bb      	str	r3, [r7, #8]
    if(i == NULL) i = &i_tmp;
 801ebbe:	683b      	ldr	r3, [r7, #0]
 801ebc0:	2b00      	cmp	r3, #0
 801ebc2:	d102      	bne.n	801ebca <lv_txt_utf8_next+0x1e>
 801ebc4:	f107 0308 	add.w	r3, r7, #8
 801ebc8:	603b      	str	r3, [r7, #0]

    /*Normal ASCII*/
    if((txt[*i] & 0x80) == 0) {
 801ebca:	683b      	ldr	r3, [r7, #0]
 801ebcc:	681b      	ldr	r3, [r3, #0]
 801ebce:	687a      	ldr	r2, [r7, #4]
 801ebd0:	4413      	add	r3, r2
 801ebd2:	781b      	ldrb	r3, [r3, #0]
 801ebd4:	b25b      	sxtb	r3, r3
 801ebd6:	2b00      	cmp	r3, #0
 801ebd8:	db0b      	blt.n	801ebf2 <lv_txt_utf8_next+0x46>
        result = txt[*i];
 801ebda:	683b      	ldr	r3, [r7, #0]
 801ebdc:	681b      	ldr	r3, [r3, #0]
 801ebde:	687a      	ldr	r2, [r7, #4]
 801ebe0:	4413      	add	r3, r2
 801ebe2:	781b      	ldrb	r3, [r3, #0]
 801ebe4:	60fb      	str	r3, [r7, #12]
        (*i)++;
 801ebe6:	683b      	ldr	r3, [r7, #0]
 801ebe8:	681b      	ldr	r3, [r3, #0]
 801ebea:	1c5a      	adds	r2, r3, #1
 801ebec:	683b      	ldr	r3, [r7, #0]
 801ebee:	601a      	str	r2, [r3, #0]
 801ebf0:	e0ea      	b.n	801edc8 <lv_txt_utf8_next+0x21c>
    }
    /*Real UTF-8 decode*/
    else {
        /*2 bytes UTF-8 code*/
        if((txt[*i] & 0xE0) == 0xC0) {
 801ebf2:	683b      	ldr	r3, [r7, #0]
 801ebf4:	681b      	ldr	r3, [r3, #0]
 801ebf6:	687a      	ldr	r2, [r7, #4]
 801ebf8:	4413      	add	r3, r2
 801ebfa:	781b      	ldrb	r3, [r3, #0]
 801ebfc:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
 801ec00:	2bc0      	cmp	r3, #192	; 0xc0
 801ec02:	d128      	bne.n	801ec56 <lv_txt_utf8_next+0xaa>
            result = (uint32_t)(txt[*i] & 0x1F) << 6;
 801ec04:	683b      	ldr	r3, [r7, #0]
 801ec06:	681b      	ldr	r3, [r3, #0]
 801ec08:	687a      	ldr	r2, [r7, #4]
 801ec0a:	4413      	add	r3, r2
 801ec0c:	781b      	ldrb	r3, [r3, #0]
 801ec0e:	019b      	lsls	r3, r3, #6
 801ec10:	f403 63f8 	and.w	r3, r3, #1984	; 0x7c0
 801ec14:	60fb      	str	r3, [r7, #12]
            (*i)++;
 801ec16:	683b      	ldr	r3, [r7, #0]
 801ec18:	681b      	ldr	r3, [r3, #0]
 801ec1a:	1c5a      	adds	r2, r3, #1
 801ec1c:	683b      	ldr	r3, [r7, #0]
 801ec1e:	601a      	str	r2, [r3, #0]
            if((txt[*i] & 0xC0) != 0x80) return 0; /*Invalid UTF-8 code*/
 801ec20:	683b      	ldr	r3, [r7, #0]
 801ec22:	681b      	ldr	r3, [r3, #0]
 801ec24:	687a      	ldr	r2, [r7, #4]
 801ec26:	4413      	add	r3, r2
 801ec28:	781b      	ldrb	r3, [r3, #0]
 801ec2a:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 801ec2e:	2b80      	cmp	r3, #128	; 0x80
 801ec30:	d001      	beq.n	801ec36 <lv_txt_utf8_next+0x8a>
 801ec32:	2300      	movs	r3, #0
 801ec34:	e0c9      	b.n	801edca <lv_txt_utf8_next+0x21e>
            result += (txt[*i] & 0x3F);
 801ec36:	683b      	ldr	r3, [r7, #0]
 801ec38:	681b      	ldr	r3, [r3, #0]
 801ec3a:	687a      	ldr	r2, [r7, #4]
 801ec3c:	4413      	add	r3, r2
 801ec3e:	781b      	ldrb	r3, [r3, #0]
 801ec40:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801ec44:	68fa      	ldr	r2, [r7, #12]
 801ec46:	4413      	add	r3, r2
 801ec48:	60fb      	str	r3, [r7, #12]
            (*i)++;
 801ec4a:	683b      	ldr	r3, [r7, #0]
 801ec4c:	681b      	ldr	r3, [r3, #0]
 801ec4e:	1c5a      	adds	r2, r3, #1
 801ec50:	683b      	ldr	r3, [r7, #0]
 801ec52:	601a      	str	r2, [r3, #0]
 801ec54:	e0b8      	b.n	801edc8 <lv_txt_utf8_next+0x21c>
        }
        /*3 bytes UTF-8 code*/
        else if((txt[*i] & 0xF0) == 0xE0) {
 801ec56:	683b      	ldr	r3, [r7, #0]
 801ec58:	681b      	ldr	r3, [r3, #0]
 801ec5a:	687a      	ldr	r2, [r7, #4]
 801ec5c:	4413      	add	r3, r2
 801ec5e:	781b      	ldrb	r3, [r3, #0]
 801ec60:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 801ec64:	2be0      	cmp	r3, #224	; 0xe0
 801ec66:	d142      	bne.n	801ecee <lv_txt_utf8_next+0x142>
            result = (uint32_t)(txt[*i] & 0x0F) << 12;
 801ec68:	683b      	ldr	r3, [r7, #0]
 801ec6a:	681b      	ldr	r3, [r3, #0]
 801ec6c:	687a      	ldr	r2, [r7, #4]
 801ec6e:	4413      	add	r3, r2
 801ec70:	781b      	ldrb	r3, [r3, #0]
 801ec72:	031b      	lsls	r3, r3, #12
 801ec74:	b29b      	uxth	r3, r3
 801ec76:	60fb      	str	r3, [r7, #12]
            (*i)++;
 801ec78:	683b      	ldr	r3, [r7, #0]
 801ec7a:	681b      	ldr	r3, [r3, #0]
 801ec7c:	1c5a      	adds	r2, r3, #1
 801ec7e:	683b      	ldr	r3, [r7, #0]
 801ec80:	601a      	str	r2, [r3, #0]

            if((txt[*i] & 0xC0) != 0x80) return 0; /*Invalid UTF-8 code*/
 801ec82:	683b      	ldr	r3, [r7, #0]
 801ec84:	681b      	ldr	r3, [r3, #0]
 801ec86:	687a      	ldr	r2, [r7, #4]
 801ec88:	4413      	add	r3, r2
 801ec8a:	781b      	ldrb	r3, [r3, #0]
 801ec8c:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 801ec90:	2b80      	cmp	r3, #128	; 0x80
 801ec92:	d001      	beq.n	801ec98 <lv_txt_utf8_next+0xec>
 801ec94:	2300      	movs	r3, #0
 801ec96:	e098      	b.n	801edca <lv_txt_utf8_next+0x21e>
            result += (uint32_t)(txt[*i] & 0x3F) << 6;
 801ec98:	683b      	ldr	r3, [r7, #0]
 801ec9a:	681b      	ldr	r3, [r3, #0]
 801ec9c:	687a      	ldr	r2, [r7, #4]
 801ec9e:	4413      	add	r3, r2
 801eca0:	781b      	ldrb	r3, [r3, #0]
 801eca2:	019b      	lsls	r3, r3, #6
 801eca4:	f403 637c 	and.w	r3, r3, #4032	; 0xfc0
 801eca8:	68fa      	ldr	r2, [r7, #12]
 801ecaa:	4413      	add	r3, r2
 801ecac:	60fb      	str	r3, [r7, #12]
            (*i)++;
 801ecae:	683b      	ldr	r3, [r7, #0]
 801ecb0:	681b      	ldr	r3, [r3, #0]
 801ecb2:	1c5a      	adds	r2, r3, #1
 801ecb4:	683b      	ldr	r3, [r7, #0]
 801ecb6:	601a      	str	r2, [r3, #0]

            if((txt[*i] & 0xC0) != 0x80) return 0; /*Invalid UTF-8 code*/
 801ecb8:	683b      	ldr	r3, [r7, #0]
 801ecba:	681b      	ldr	r3, [r3, #0]
 801ecbc:	687a      	ldr	r2, [r7, #4]
 801ecbe:	4413      	add	r3, r2
 801ecc0:	781b      	ldrb	r3, [r3, #0]
 801ecc2:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 801ecc6:	2b80      	cmp	r3, #128	; 0x80
 801ecc8:	d001      	beq.n	801ecce <lv_txt_utf8_next+0x122>
 801ecca:	2300      	movs	r3, #0
 801eccc:	e07d      	b.n	801edca <lv_txt_utf8_next+0x21e>
            result += (txt[*i] & 0x3F);
 801ecce:	683b      	ldr	r3, [r7, #0]
 801ecd0:	681b      	ldr	r3, [r3, #0]
 801ecd2:	687a      	ldr	r2, [r7, #4]
 801ecd4:	4413      	add	r3, r2
 801ecd6:	781b      	ldrb	r3, [r3, #0]
 801ecd8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801ecdc:	68fa      	ldr	r2, [r7, #12]
 801ecde:	4413      	add	r3, r2
 801ece0:	60fb      	str	r3, [r7, #12]
            (*i)++;
 801ece2:	683b      	ldr	r3, [r7, #0]
 801ece4:	681b      	ldr	r3, [r3, #0]
 801ece6:	1c5a      	adds	r2, r3, #1
 801ece8:	683b      	ldr	r3, [r7, #0]
 801ecea:	601a      	str	r2, [r3, #0]
 801ecec:	e06c      	b.n	801edc8 <lv_txt_utf8_next+0x21c>
        }
        /*4 bytes UTF-8 code*/
        else if((txt[*i] & 0xF8) == 0xF0) {
 801ecee:	683b      	ldr	r3, [r7, #0]
 801ecf0:	681b      	ldr	r3, [r3, #0]
 801ecf2:	687a      	ldr	r2, [r7, #4]
 801ecf4:	4413      	add	r3, r2
 801ecf6:	781b      	ldrb	r3, [r3, #0]
 801ecf8:	f003 03f8 	and.w	r3, r3, #248	; 0xf8
 801ecfc:	2bf0      	cmp	r3, #240	; 0xf0
 801ecfe:	d15e      	bne.n	801edbe <lv_txt_utf8_next+0x212>
            result = (uint32_t)(txt[*i] & 0x07) << 18;
 801ed00:	683b      	ldr	r3, [r7, #0]
 801ed02:	681b      	ldr	r3, [r3, #0]
 801ed04:	687a      	ldr	r2, [r7, #4]
 801ed06:	4413      	add	r3, r2
 801ed08:	781b      	ldrb	r3, [r3, #0]
 801ed0a:	049b      	lsls	r3, r3, #18
 801ed0c:	f403 13e0 	and.w	r3, r3, #1835008	; 0x1c0000
 801ed10:	60fb      	str	r3, [r7, #12]
            (*i)++;
 801ed12:	683b      	ldr	r3, [r7, #0]
 801ed14:	681b      	ldr	r3, [r3, #0]
 801ed16:	1c5a      	adds	r2, r3, #1
 801ed18:	683b      	ldr	r3, [r7, #0]
 801ed1a:	601a      	str	r2, [r3, #0]

            if((txt[*i] & 0xC0) != 0x80) return 0; /*Invalid UTF-8 code*/
 801ed1c:	683b      	ldr	r3, [r7, #0]
 801ed1e:	681b      	ldr	r3, [r3, #0]
 801ed20:	687a      	ldr	r2, [r7, #4]
 801ed22:	4413      	add	r3, r2
 801ed24:	781b      	ldrb	r3, [r3, #0]
 801ed26:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 801ed2a:	2b80      	cmp	r3, #128	; 0x80
 801ed2c:	d001      	beq.n	801ed32 <lv_txt_utf8_next+0x186>
 801ed2e:	2300      	movs	r3, #0
 801ed30:	e04b      	b.n	801edca <lv_txt_utf8_next+0x21e>
            result += (uint32_t)(txt[*i] & 0x3F) << 12;
 801ed32:	683b      	ldr	r3, [r7, #0]
 801ed34:	681b      	ldr	r3, [r3, #0]
 801ed36:	687a      	ldr	r2, [r7, #4]
 801ed38:	4413      	add	r3, r2
 801ed3a:	781b      	ldrb	r3, [r3, #0]
 801ed3c:	031b      	lsls	r3, r3, #12
 801ed3e:	f403 337c 	and.w	r3, r3, #258048	; 0x3f000
 801ed42:	68fa      	ldr	r2, [r7, #12]
 801ed44:	4413      	add	r3, r2
 801ed46:	60fb      	str	r3, [r7, #12]
            (*i)++;
 801ed48:	683b      	ldr	r3, [r7, #0]
 801ed4a:	681b      	ldr	r3, [r3, #0]
 801ed4c:	1c5a      	adds	r2, r3, #1
 801ed4e:	683b      	ldr	r3, [r7, #0]
 801ed50:	601a      	str	r2, [r3, #0]

            if((txt[*i] & 0xC0) != 0x80) return 0; /*Invalid UTF-8 code*/
 801ed52:	683b      	ldr	r3, [r7, #0]
 801ed54:	681b      	ldr	r3, [r3, #0]
 801ed56:	687a      	ldr	r2, [r7, #4]
 801ed58:	4413      	add	r3, r2
 801ed5a:	781b      	ldrb	r3, [r3, #0]
 801ed5c:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 801ed60:	2b80      	cmp	r3, #128	; 0x80
 801ed62:	d001      	beq.n	801ed68 <lv_txt_utf8_next+0x1bc>
 801ed64:	2300      	movs	r3, #0
 801ed66:	e030      	b.n	801edca <lv_txt_utf8_next+0x21e>
            result += (uint32_t)(txt[*i] & 0x3F) << 6;
 801ed68:	683b      	ldr	r3, [r7, #0]
 801ed6a:	681b      	ldr	r3, [r3, #0]
 801ed6c:	687a      	ldr	r2, [r7, #4]
 801ed6e:	4413      	add	r3, r2
 801ed70:	781b      	ldrb	r3, [r3, #0]
 801ed72:	019b      	lsls	r3, r3, #6
 801ed74:	f403 637c 	and.w	r3, r3, #4032	; 0xfc0
 801ed78:	68fa      	ldr	r2, [r7, #12]
 801ed7a:	4413      	add	r3, r2
 801ed7c:	60fb      	str	r3, [r7, #12]
            (*i)++;
 801ed7e:	683b      	ldr	r3, [r7, #0]
 801ed80:	681b      	ldr	r3, [r3, #0]
 801ed82:	1c5a      	adds	r2, r3, #1
 801ed84:	683b      	ldr	r3, [r7, #0]
 801ed86:	601a      	str	r2, [r3, #0]

            if((txt[*i] & 0xC0) != 0x80) return 0; /*Invalid UTF-8 code*/
 801ed88:	683b      	ldr	r3, [r7, #0]
 801ed8a:	681b      	ldr	r3, [r3, #0]
 801ed8c:	687a      	ldr	r2, [r7, #4]
 801ed8e:	4413      	add	r3, r2
 801ed90:	781b      	ldrb	r3, [r3, #0]
 801ed92:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 801ed96:	2b80      	cmp	r3, #128	; 0x80
 801ed98:	d001      	beq.n	801ed9e <lv_txt_utf8_next+0x1f2>
 801ed9a:	2300      	movs	r3, #0
 801ed9c:	e015      	b.n	801edca <lv_txt_utf8_next+0x21e>
            result += txt[*i] & 0x3F;
 801ed9e:	683b      	ldr	r3, [r7, #0]
 801eda0:	681b      	ldr	r3, [r3, #0]
 801eda2:	687a      	ldr	r2, [r7, #4]
 801eda4:	4413      	add	r3, r2
 801eda6:	781b      	ldrb	r3, [r3, #0]
 801eda8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801edac:	68fa      	ldr	r2, [r7, #12]
 801edae:	4413      	add	r3, r2
 801edb0:	60fb      	str	r3, [r7, #12]
            (*i)++;
 801edb2:	683b      	ldr	r3, [r7, #0]
 801edb4:	681b      	ldr	r3, [r3, #0]
 801edb6:	1c5a      	adds	r2, r3, #1
 801edb8:	683b      	ldr	r3, [r7, #0]
 801edba:	601a      	str	r2, [r3, #0]
 801edbc:	e004      	b.n	801edc8 <lv_txt_utf8_next+0x21c>
        } else {
            (*i)++; /*Not UTF-8 char. Go the next.*/
 801edbe:	683b      	ldr	r3, [r7, #0]
 801edc0:	681b      	ldr	r3, [r3, #0]
 801edc2:	1c5a      	adds	r2, r3, #1
 801edc4:	683b      	ldr	r3, [r7, #0]
 801edc6:	601a      	str	r2, [r3, #0]
        }
    }
    return result;
 801edc8:	68fb      	ldr	r3, [r7, #12]
}
 801edca:	4618      	mov	r0, r3
 801edcc:	3714      	adds	r7, #20
 801edce:	46bd      	mov	sp, r7
 801edd0:	f85d 7b04 	ldr.w	r7, [sp], #4
 801edd4:	4770      	bx	lr
	...

0801edd8 <lv_txt_utf8_prev>:
 * @param i start byte index in 'txt' where to start. After the call it will point to the previous
 * UTF-8 char in 'txt'.
 * @return the decoded Unicode character or 0 on invalid UTF-8 code
 */
static uint32_t lv_txt_utf8_prev(const char * txt, uint32_t * i)
{
 801edd8:	b580      	push	{r7, lr}
 801edda:	b086      	sub	sp, #24
 801eddc:	af00      	add	r7, sp, #0
 801edde:	6078      	str	r0, [r7, #4]
 801ede0:	6039      	str	r1, [r7, #0]
    uint8_t c_size;
    uint8_t cnt = 0;
 801ede2:	2300      	movs	r3, #0
 801ede4:	75fb      	strb	r3, [r7, #23]

    /*Try to find a !0 long UTF-8 char by stepping one character back*/
    (*i)--;
 801ede6:	683b      	ldr	r3, [r7, #0]
 801ede8:	681b      	ldr	r3, [r3, #0]
 801edea:	1e5a      	subs	r2, r3, #1
 801edec:	683b      	ldr	r3, [r7, #0]
 801edee:	601a      	str	r2, [r3, #0]
    do {
        if(cnt >= 4) return 0; /*No UTF-8 char found before the initial*/
 801edf0:	7dfb      	ldrb	r3, [r7, #23]
 801edf2:	2b03      	cmp	r3, #3
 801edf4:	d901      	bls.n	801edfa <lv_txt_utf8_prev+0x22>
 801edf6:	2300      	movs	r3, #0
 801edf8:	e02a      	b.n	801ee50 <lv_txt_utf8_prev+0x78>

        c_size = lv_txt_encoded_size(&txt[*i]);
 801edfa:	4b17      	ldr	r3, [pc, #92]	; (801ee58 <lv_txt_utf8_prev+0x80>)
 801edfc:	681b      	ldr	r3, [r3, #0]
 801edfe:	683a      	ldr	r2, [r7, #0]
 801ee00:	6812      	ldr	r2, [r2, #0]
 801ee02:	6879      	ldr	r1, [r7, #4]
 801ee04:	440a      	add	r2, r1
 801ee06:	4610      	mov	r0, r2
 801ee08:	4798      	blx	r3
 801ee0a:	4603      	mov	r3, r0
 801ee0c:	75bb      	strb	r3, [r7, #22]
        if(c_size == 0) {
 801ee0e:	7dbb      	ldrb	r3, [r7, #22]
 801ee10:	2b00      	cmp	r3, #0
 801ee12:	d10b      	bne.n	801ee2c <lv_txt_utf8_prev+0x54>
            if(*i != 0)
 801ee14:	683b      	ldr	r3, [r7, #0]
 801ee16:	681b      	ldr	r3, [r3, #0]
 801ee18:	2b00      	cmp	r3, #0
 801ee1a:	d005      	beq.n	801ee28 <lv_txt_utf8_prev+0x50>
                (*i)--;
 801ee1c:	683b      	ldr	r3, [r7, #0]
 801ee1e:	681b      	ldr	r3, [r3, #0]
 801ee20:	1e5a      	subs	r2, r3, #1
 801ee22:	683b      	ldr	r3, [r7, #0]
 801ee24:	601a      	str	r2, [r3, #0]
 801ee26:	e001      	b.n	801ee2c <lv_txt_utf8_prev+0x54>
            else
                return 0;
 801ee28:	2300      	movs	r3, #0
 801ee2a:	e011      	b.n	801ee50 <lv_txt_utf8_prev+0x78>
        }
        cnt++;
 801ee2c:	7dfb      	ldrb	r3, [r7, #23]
 801ee2e:	3301      	adds	r3, #1
 801ee30:	75fb      	strb	r3, [r7, #23]
    } while(c_size == 0);
 801ee32:	7dbb      	ldrb	r3, [r7, #22]
 801ee34:	2b00      	cmp	r3, #0
 801ee36:	d0db      	beq.n	801edf0 <lv_txt_utf8_prev+0x18>

    uint32_t i_tmp  = *i;
 801ee38:	683b      	ldr	r3, [r7, #0]
 801ee3a:	681b      	ldr	r3, [r3, #0]
 801ee3c:	60fb      	str	r3, [r7, #12]
    uint32_t letter = lv_txt_encoded_next(txt, &i_tmp); /*Character found, get it*/
 801ee3e:	4b07      	ldr	r3, [pc, #28]	; (801ee5c <lv_txt_utf8_prev+0x84>)
 801ee40:	681b      	ldr	r3, [r3, #0]
 801ee42:	f107 020c 	add.w	r2, r7, #12
 801ee46:	4611      	mov	r1, r2
 801ee48:	6878      	ldr	r0, [r7, #4]
 801ee4a:	4798      	blx	r3
 801ee4c:	6138      	str	r0, [r7, #16]

    return letter;
 801ee4e:	693b      	ldr	r3, [r7, #16]
}
 801ee50:	4618      	mov	r0, r3
 801ee52:	3718      	adds	r7, #24
 801ee54:	46bd      	mov	sp, r7
 801ee56:	bd80      	pop	{r7, pc}
 801ee58:	240001cc 	.word	0x240001cc
 801ee5c:	240001d0 	.word	0x240001d0

0801ee60 <lv_txt_utf8_get_byte_id>:
 * @param txt a '\0' terminated UTF-8 string
 * @param utf8_id character index
 * @return byte index of the 'utf8_id'th letter
 */
static uint32_t lv_txt_utf8_get_byte_id(const char * txt, uint32_t utf8_id)
{
 801ee60:	b580      	push	{r7, lr}
 801ee62:	b084      	sub	sp, #16
 801ee64:	af00      	add	r7, sp, #0
 801ee66:	6078      	str	r0, [r7, #4]
 801ee68:	6039      	str	r1, [r7, #0]
    uint32_t i;
    uint32_t byte_cnt = 0;
 801ee6a:	2300      	movs	r3, #0
 801ee6c:	60bb      	str	r3, [r7, #8]
    for(i = 0; i < utf8_id; i++) {
 801ee6e:	2300      	movs	r3, #0
 801ee70:	60fb      	str	r3, [r7, #12]
 801ee72:	e00e      	b.n	801ee92 <lv_txt_utf8_get_byte_id+0x32>
        byte_cnt += lv_txt_encoded_size(&txt[byte_cnt]);
 801ee74:	4b0b      	ldr	r3, [pc, #44]	; (801eea4 <lv_txt_utf8_get_byte_id+0x44>)
 801ee76:	681b      	ldr	r3, [r3, #0]
 801ee78:	6879      	ldr	r1, [r7, #4]
 801ee7a:	68ba      	ldr	r2, [r7, #8]
 801ee7c:	440a      	add	r2, r1
 801ee7e:	4610      	mov	r0, r2
 801ee80:	4798      	blx	r3
 801ee82:	4603      	mov	r3, r0
 801ee84:	461a      	mov	r2, r3
 801ee86:	68bb      	ldr	r3, [r7, #8]
 801ee88:	4413      	add	r3, r2
 801ee8a:	60bb      	str	r3, [r7, #8]
    for(i = 0; i < utf8_id; i++) {
 801ee8c:	68fb      	ldr	r3, [r7, #12]
 801ee8e:	3301      	adds	r3, #1
 801ee90:	60fb      	str	r3, [r7, #12]
 801ee92:	68fa      	ldr	r2, [r7, #12]
 801ee94:	683b      	ldr	r3, [r7, #0]
 801ee96:	429a      	cmp	r2, r3
 801ee98:	d3ec      	bcc.n	801ee74 <lv_txt_utf8_get_byte_id+0x14>
    }

    return byte_cnt;
 801ee9a:	68bb      	ldr	r3, [r7, #8]
}
 801ee9c:	4618      	mov	r0, r3
 801ee9e:	3710      	adds	r7, #16
 801eea0:	46bd      	mov	sp, r7
 801eea2:	bd80      	pop	{r7, pc}
 801eea4:	240001cc 	.word	0x240001cc

0801eea8 <lv_txt_utf8_get_char_id>:
 * @param txt a '\0' terminated UTF-8 string
 * @param byte_id byte index
 * @return character index of the letter at 'byte_id'th position
 */
static uint32_t lv_txt_utf8_get_char_id(const char * txt, uint32_t byte_id)
{
 801eea8:	b580      	push	{r7, lr}
 801eeaa:	b084      	sub	sp, #16
 801eeac:	af00      	add	r7, sp, #0
 801eeae:	6078      	str	r0, [r7, #4]
 801eeb0:	6039      	str	r1, [r7, #0]
    uint32_t i        = 0;
 801eeb2:	2300      	movs	r3, #0
 801eeb4:	60bb      	str	r3, [r7, #8]
    uint32_t char_cnt = 0;
 801eeb6:	2300      	movs	r3, #0
 801eeb8:	60fb      	str	r3, [r7, #12]

    while(i < byte_id) {
 801eeba:	e009      	b.n	801eed0 <lv_txt_utf8_get_char_id+0x28>
        lv_txt_encoded_next(txt, &i); /*'i' points to the next letter so use the prev. value*/
 801eebc:	4b09      	ldr	r3, [pc, #36]	; (801eee4 <lv_txt_utf8_get_char_id+0x3c>)
 801eebe:	681b      	ldr	r3, [r3, #0]
 801eec0:	f107 0208 	add.w	r2, r7, #8
 801eec4:	4611      	mov	r1, r2
 801eec6:	6878      	ldr	r0, [r7, #4]
 801eec8:	4798      	blx	r3
        char_cnt++;
 801eeca:	68fb      	ldr	r3, [r7, #12]
 801eecc:	3301      	adds	r3, #1
 801eece:	60fb      	str	r3, [r7, #12]
    while(i < byte_id) {
 801eed0:	68bb      	ldr	r3, [r7, #8]
 801eed2:	683a      	ldr	r2, [r7, #0]
 801eed4:	429a      	cmp	r2, r3
 801eed6:	d8f1      	bhi.n	801eebc <lv_txt_utf8_get_char_id+0x14>
    }

    return char_cnt;
 801eed8:	68fb      	ldr	r3, [r7, #12]
}
 801eeda:	4618      	mov	r0, r3
 801eedc:	3710      	adds	r7, #16
 801eede:	46bd      	mov	sp, r7
 801eee0:	bd80      	pop	{r7, pc}
 801eee2:	bf00      	nop
 801eee4:	240001d0 	.word	0x240001d0

0801eee8 <lv_txt_utf8_get_length>:
 * E.g.: "BC" is 3 characters (but 4 bytes)
 * @param txt a '\0' terminated char string
 * @return number of characters
 */
static uint32_t lv_txt_utf8_get_length(const char * txt)
{
 801eee8:	b580      	push	{r7, lr}
 801eeea:	b084      	sub	sp, #16
 801eeec:	af00      	add	r7, sp, #0
 801eeee:	6078      	str	r0, [r7, #4]
    uint32_t len = 0;
 801eef0:	2300      	movs	r3, #0
 801eef2:	60fb      	str	r3, [r7, #12]
    uint32_t i   = 0;
 801eef4:	2300      	movs	r3, #0
 801eef6:	60bb      	str	r3, [r7, #8]

    while(txt[i] != '\0') {
 801eef8:	e009      	b.n	801ef0e <lv_txt_utf8_get_length+0x26>
        lv_txt_encoded_next(txt, &i);
 801eefa:	4b0a      	ldr	r3, [pc, #40]	; (801ef24 <lv_txt_utf8_get_length+0x3c>)
 801eefc:	681b      	ldr	r3, [r3, #0]
 801eefe:	f107 0208 	add.w	r2, r7, #8
 801ef02:	4611      	mov	r1, r2
 801ef04:	6878      	ldr	r0, [r7, #4]
 801ef06:	4798      	blx	r3
        len++;
 801ef08:	68fb      	ldr	r3, [r7, #12]
 801ef0a:	3301      	adds	r3, #1
 801ef0c:	60fb      	str	r3, [r7, #12]
    while(txt[i] != '\0') {
 801ef0e:	68bb      	ldr	r3, [r7, #8]
 801ef10:	687a      	ldr	r2, [r7, #4]
 801ef12:	4413      	add	r3, r2
 801ef14:	781b      	ldrb	r3, [r3, #0]
 801ef16:	2b00      	cmp	r3, #0
 801ef18:	d1ef      	bne.n	801eefa <lv_txt_utf8_get_length+0x12>
    }

    return len;
 801ef1a:	68fb      	ldr	r3, [r7, #12]
}
 801ef1c:	4618      	mov	r0, r3
 801ef1e:	3710      	adds	r7, #16
 801ef20:	46bd      	mov	sp, r7
 801ef22:	bd80      	pop	{r7, pc}
 801ef24:	240001d0 	.word	0x240001d0

0801ef28 <is_break_char>:
 * Test if char is break char or not (a text can broken here or not)
 * @param letter a letter
 * @return false: 'letter' is not break char
 */
static inline bool is_break_char(uint32_t letter)
{
 801ef28:	b480      	push	{r7}
 801ef2a:	b085      	sub	sp, #20
 801ef2c:	af00      	add	r7, sp, #0
 801ef2e:	6078      	str	r0, [r7, #4]
    uint8_t i;
    bool ret = false;
 801ef30:	2300      	movs	r3, #0
 801ef32:	73bb      	strb	r3, [r7, #14]

    /*Compare the letter to TXT_BREAK_CHARS*/
    for(i = 0; LV_TXT_BREAK_CHARS[i] != '\0'; i++) {
 801ef34:	2300      	movs	r3, #0
 801ef36:	73fb      	strb	r3, [r7, #15]
 801ef38:	e00c      	b.n	801ef54 <is_break_char+0x2c>
        if(letter == (uint32_t)LV_TXT_BREAK_CHARS[i]) {
 801ef3a:	7bfb      	ldrb	r3, [r7, #15]
 801ef3c:	4a0b      	ldr	r2, [pc, #44]	; (801ef6c <is_break_char+0x44>)
 801ef3e:	5cd3      	ldrb	r3, [r2, r3]
 801ef40:	461a      	mov	r2, r3
 801ef42:	687b      	ldr	r3, [r7, #4]
 801ef44:	4293      	cmp	r3, r2
 801ef46:	d102      	bne.n	801ef4e <is_break_char+0x26>
            ret = true; /*If match then it is break char*/
 801ef48:	2301      	movs	r3, #1
 801ef4a:	73bb      	strb	r3, [r7, #14]
            break;
 801ef4c:	e007      	b.n	801ef5e <is_break_char+0x36>
    for(i = 0; LV_TXT_BREAK_CHARS[i] != '\0'; i++) {
 801ef4e:	7bfb      	ldrb	r3, [r7, #15]
 801ef50:	3301      	adds	r3, #1
 801ef52:	73fb      	strb	r3, [r7, #15]
 801ef54:	7bfb      	ldrb	r3, [r7, #15]
 801ef56:	4a05      	ldr	r2, [pc, #20]	; (801ef6c <is_break_char+0x44>)
 801ef58:	5cd3      	ldrb	r3, [r2, r3]
 801ef5a:	2b00      	cmp	r3, #0
 801ef5c:	d1ed      	bne.n	801ef3a <is_break_char+0x12>
        }
    }

    return ret;
 801ef5e:	7bbb      	ldrb	r3, [r7, #14]
}
 801ef60:	4618      	mov	r0, r3
 801ef62:	3714      	adds	r7, #20
 801ef64:	46bd      	mov	sp, r7
 801ef66:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ef6a:	4770      	bx	lr
 801ef6c:	080228fc 	.word	0x080228fc

0801ef70 <lv_utils_bsearch>:
 *
 * @return a pointer to a matching item, or NULL if none exists.
 */
void * lv_utils_bsearch(const void * key, const void * base, uint32_t n, uint32_t size,
                        int32_t (*cmp)(const void * pRef, const void * pElement))
{
 801ef70:	b580      	push	{r7, lr}
 801ef72:	b086      	sub	sp, #24
 801ef74:	af00      	add	r7, sp, #0
 801ef76:	60f8      	str	r0, [r7, #12]
 801ef78:	60b9      	str	r1, [r7, #8]
 801ef7a:	607a      	str	r2, [r7, #4]
 801ef7c:	603b      	str	r3, [r7, #0]
    const char * middle;
    int32_t c;

    for(middle = base; n != 0;) {
 801ef7e:	68bb      	ldr	r3, [r7, #8]
 801ef80:	617b      	str	r3, [r7, #20]
 801ef82:	e02d      	b.n	801efe0 <lv_utils_bsearch+0x70>
        middle += (n / 2) * size;
 801ef84:	687b      	ldr	r3, [r7, #4]
 801ef86:	085b      	lsrs	r3, r3, #1
 801ef88:	683a      	ldr	r2, [r7, #0]
 801ef8a:	fb02 f303 	mul.w	r3, r2, r3
 801ef8e:	697a      	ldr	r2, [r7, #20]
 801ef90:	4413      	add	r3, r2
 801ef92:	617b      	str	r3, [r7, #20]
        if((c = (*cmp)(key, middle)) > 0) {
 801ef94:	6a3b      	ldr	r3, [r7, #32]
 801ef96:	6979      	ldr	r1, [r7, #20]
 801ef98:	68f8      	ldr	r0, [r7, #12]
 801ef9a:	4798      	blx	r3
 801ef9c:	6138      	str	r0, [r7, #16]
 801ef9e:	693b      	ldr	r3, [r7, #16]
 801efa0:	2b00      	cmp	r3, #0
 801efa2:	dd12      	ble.n	801efca <lv_utils_bsearch+0x5a>
            n    = (n / 2) - ((n & 1) == 0);
 801efa4:	687b      	ldr	r3, [r7, #4]
 801efa6:	085b      	lsrs	r3, r3, #1
 801efa8:	687a      	ldr	r2, [r7, #4]
 801efaa:	f002 0201 	and.w	r2, r2, #1
 801efae:	2a00      	cmp	r2, #0
 801efb0:	bf0c      	ite	eq
 801efb2:	2201      	moveq	r2, #1
 801efb4:	2200      	movne	r2, #0
 801efb6:	b2d2      	uxtb	r2, r2
 801efb8:	1a9b      	subs	r3, r3, r2
 801efba:	607b      	str	r3, [r7, #4]
            base = (middle += size);
 801efbc:	697a      	ldr	r2, [r7, #20]
 801efbe:	683b      	ldr	r3, [r7, #0]
 801efc0:	4413      	add	r3, r2
 801efc2:	617b      	str	r3, [r7, #20]
 801efc4:	697b      	ldr	r3, [r7, #20]
 801efc6:	60bb      	str	r3, [r7, #8]
 801efc8:	e00a      	b.n	801efe0 <lv_utils_bsearch+0x70>
        } else if(c < 0) {
 801efca:	693b      	ldr	r3, [r7, #16]
 801efcc:	2b00      	cmp	r3, #0
 801efce:	da05      	bge.n	801efdc <lv_utils_bsearch+0x6c>
            n /= 2;
 801efd0:	687b      	ldr	r3, [r7, #4]
 801efd2:	085b      	lsrs	r3, r3, #1
 801efd4:	607b      	str	r3, [r7, #4]
            middle = base;
 801efd6:	68bb      	ldr	r3, [r7, #8]
 801efd8:	617b      	str	r3, [r7, #20]
 801efda:	e001      	b.n	801efe0 <lv_utils_bsearch+0x70>
        } else {
            return (char *)middle;
 801efdc:	697b      	ldr	r3, [r7, #20]
 801efde:	e003      	b.n	801efe8 <lv_utils_bsearch+0x78>
    for(middle = base; n != 0;) {
 801efe0:	687b      	ldr	r3, [r7, #4]
 801efe2:	2b00      	cmp	r3, #0
 801efe4:	d1ce      	bne.n	801ef84 <lv_utils_bsearch+0x14>
        }
    }
    return NULL;
 801efe6:	2300      	movs	r3, #0
}
 801efe8:	4618      	mov	r0, r3
 801efea:	3718      	adds	r7, #24
 801efec:	46bd      	mov	sp, r7
 801efee:	bd80      	pop	{r7, pc}

0801eff0 <lv_arc_create>:
 * @param par pointer to an object, it will be the parent of the new arc
 * @param copy pointer to a arc object, if not NULL then the new object will be copied from it
 * @return pointer to the created arc
 */
lv_obj_t * lv_arc_create(lv_obj_t * par, const lv_obj_t * copy)
{
 801eff0:	b580      	push	{r7, lr}
 801eff2:	b086      	sub	sp, #24
 801eff4:	af00      	add	r7, sp, #0
 801eff6:	6078      	str	r0, [r7, #4]
 801eff8:	6039      	str	r1, [r7, #0]

    LV_LOG_TRACE("arc create started");

    /*Create the ancestor of arc*/
    lv_obj_t * new_arc = lv_obj_create(par, copy);
 801effa:	6839      	ldr	r1, [r7, #0]
 801effc:	6878      	ldr	r0, [r7, #4]
 801effe:	f7f3 fbbf 	bl	8012780 <lv_obj_create>
 801f002:	6178      	str	r0, [r7, #20]
    lv_mem_assert(new_arc);
 801f004:	697b      	ldr	r3, [r7, #20]
 801f006:	2b00      	cmp	r3, #0
 801f008:	d100      	bne.n	801f00c <lv_arc_create+0x1c>
 801f00a:	e7fe      	b.n	801f00a <lv_arc_create+0x1a>
    if(new_arc == NULL) return NULL;
 801f00c:	697b      	ldr	r3, [r7, #20]
 801f00e:	2b00      	cmp	r3, #0
 801f010:	d101      	bne.n	801f016 <lv_arc_create+0x26>
 801f012:	2300      	movs	r3, #0
 801f014:	e059      	b.n	801f0ca <lv_arc_create+0xda>

    /*Allocate the arc type specific extended data*/
    lv_arc_ext_t * ext = lv_obj_allocate_ext_attr(new_arc, sizeof(lv_arc_ext_t));
 801f016:	2104      	movs	r1, #4
 801f018:	6978      	ldr	r0, [r7, #20]
 801f01a:	f7f4 fe13 	bl	8013c44 <lv_obj_allocate_ext_attr>
 801f01e:	6138      	str	r0, [r7, #16]
    lv_mem_assert(ext);
 801f020:	693b      	ldr	r3, [r7, #16]
 801f022:	2b00      	cmp	r3, #0
 801f024:	d100      	bne.n	801f028 <lv_arc_create+0x38>
 801f026:	e7fe      	b.n	801f026 <lv_arc_create+0x36>
    if(ext == NULL) return NULL;
 801f028:	693b      	ldr	r3, [r7, #16]
 801f02a:	2b00      	cmp	r3, #0
 801f02c:	d101      	bne.n	801f032 <lv_arc_create+0x42>
 801f02e:	2300      	movs	r3, #0
 801f030:	e04b      	b.n	801f0ca <lv_arc_create+0xda>

    if(ancestor_signal == NULL) ancestor_signal = lv_obj_get_signal_cb(new_arc);
 801f032:	4b28      	ldr	r3, [pc, #160]	; (801f0d4 <lv_arc_create+0xe4>)
 801f034:	681b      	ldr	r3, [r3, #0]
 801f036:	2b00      	cmp	r3, #0
 801f038:	d105      	bne.n	801f046 <lv_arc_create+0x56>
 801f03a:	6978      	ldr	r0, [r7, #20]
 801f03c:	f7f4 ffa3 	bl	8013f86 <lv_obj_get_signal_cb>
 801f040:	4603      	mov	r3, r0
 801f042:	4a24      	ldr	r2, [pc, #144]	; (801f0d4 <lv_arc_create+0xe4>)
 801f044:	6013      	str	r3, [r2, #0]
    if(ancestor_design == NULL) ancestor_design = lv_obj_get_design_cb(new_arc);
 801f046:	4b24      	ldr	r3, [pc, #144]	; (801f0d8 <lv_arc_create+0xe8>)
 801f048:	681b      	ldr	r3, [r3, #0]
 801f04a:	2b00      	cmp	r3, #0
 801f04c:	d105      	bne.n	801f05a <lv_arc_create+0x6a>
 801f04e:	6978      	ldr	r0, [r7, #20]
 801f050:	f7f4 ffa5 	bl	8013f9e <lv_obj_get_design_cb>
 801f054:	4603      	mov	r3, r0
 801f056:	4a20      	ldr	r2, [pc, #128]	; (801f0d8 <lv_arc_create+0xe8>)
 801f058:	6013      	str	r3, [r2, #0]

    /*Initialize the allocated 'ext' */
    ext->angle_start = 45;
 801f05a:	693b      	ldr	r3, [r7, #16]
 801f05c:	222d      	movs	r2, #45	; 0x2d
 801f05e:	801a      	strh	r2, [r3, #0]
    ext->angle_end   = 315;
 801f060:	693b      	ldr	r3, [r7, #16]
 801f062:	f240 123b 	movw	r2, #315	; 0x13b
 801f066:	805a      	strh	r2, [r3, #2]

    /*The signal and design functions are not copied so set them here*/
    lv_obj_set_signal_cb(new_arc, lv_arc_signal);
 801f068:	491c      	ldr	r1, [pc, #112]	; (801f0dc <lv_arc_create+0xec>)
 801f06a:	6978      	ldr	r0, [r7, #20]
 801f06c:	f7f4 fdce 	bl	8013c0c <lv_obj_set_signal_cb>
    lv_obj_set_design_cb(new_arc, lv_arc_design);
 801f070:	491b      	ldr	r1, [pc, #108]	; (801f0e0 <lv_arc_create+0xf0>)
 801f072:	6978      	ldr	r0, [r7, #20]
 801f074:	f7f4 fdd8 	bl	8013c28 <lv_obj_set_design_cb>

    /*Init the new arc arc*/
    if(copy == NULL) {
 801f078:	683b      	ldr	r3, [r7, #0]
 801f07a:	2b00      	cmp	r3, #0
 801f07c:	d113      	bne.n	801f0a6 <lv_arc_create+0xb6>
        /*Set the default styles*/
        lv_theme_t * th = lv_theme_get_current();
 801f07e:	f002 f851 	bl	8021124 <lv_theme_get_current>
 801f082:	60b8      	str	r0, [r7, #8]
        if(th) {
 801f084:	68bb      	ldr	r3, [r7, #8]
 801f086:	2b00      	cmp	r3, #0
 801f088:	d007      	beq.n	801f09a <lv_arc_create+0xaa>
            lv_arc_set_style(new_arc, LV_ARC_STYLE_MAIN, th->style.arc);
 801f08a:	68bb      	ldr	r3, [r7, #8]
 801f08c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 801f08e:	461a      	mov	r2, r3
 801f090:	2100      	movs	r1, #0
 801f092:	6978      	ldr	r0, [r7, #20]
 801f094:	f000 f851 	bl	801f13a <lv_arc_set_style>
 801f098:	e016      	b.n	801f0c8 <lv_arc_create+0xd8>
        } else {
            lv_arc_set_style(new_arc, LV_ARC_STYLE_MAIN, &lv_style_plain_color);
 801f09a:	4a12      	ldr	r2, [pc, #72]	; (801f0e4 <lv_arc_create+0xf4>)
 801f09c:	2100      	movs	r1, #0
 801f09e:	6978      	ldr	r0, [r7, #20]
 801f0a0:	f000 f84b 	bl	801f13a <lv_arc_set_style>
 801f0a4:	e010      	b.n	801f0c8 <lv_arc_create+0xd8>
        }

    }
    /*Copy an existing arc*/
    else {
        lv_arc_ext_t * copy_ext = lv_obj_get_ext_attr(copy);
 801f0a6:	6838      	ldr	r0, [r7, #0]
 801f0a8:	f7f4 ff85 	bl	8013fb6 <lv_obj_get_ext_attr>
 801f0ac:	60f8      	str	r0, [r7, #12]
        ext->angle_start        = copy_ext->angle_start;
 801f0ae:	68fb      	ldr	r3, [r7, #12]
 801f0b0:	f9b3 2000 	ldrsh.w	r2, [r3]
 801f0b4:	693b      	ldr	r3, [r7, #16]
 801f0b6:	801a      	strh	r2, [r3, #0]
        ext->angle_end          = copy_ext->angle_end;
 801f0b8:	68fb      	ldr	r3, [r7, #12]
 801f0ba:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 801f0be:	693b      	ldr	r3, [r7, #16]
 801f0c0:	805a      	strh	r2, [r3, #2]

        /*Refresh the style with new signal function*/
        lv_obj_refresh_style(new_arc);
 801f0c2:	6978      	ldr	r0, [r7, #20]
 801f0c4:	f7f4 fcbb 	bl	8013a3e <lv_obj_refresh_style>
    }

    LV_LOG_INFO("arc created");

    return new_arc;
 801f0c8:	697b      	ldr	r3, [r7, #20]
}
 801f0ca:	4618      	mov	r0, r3
 801f0cc:	3718      	adds	r7, #24
 801f0ce:	46bd      	mov	sp, r7
 801f0d0:	bd80      	pop	{r7, pc}
 801f0d2:	bf00      	nop
 801f0d4:	24062400 	.word	0x24062400
 801f0d8:	24062404 	.word	0x24062404
 801f0dc:	0801f465 	.word	0x0801f465
 801f0e0:	0801f191 	.word	0x0801f191
 801f0e4:	240635e8 	.word	0x240635e8

0801f0e8 <lv_arc_set_angles>:
 * @param arc pointer to an arc object
 * @param start the start angle [0..360]
 * @param end the end angle [0..360]
 */
void lv_arc_set_angles(lv_obj_t * arc, uint16_t start, uint16_t end)
{
 801f0e8:	b580      	push	{r7, lr}
 801f0ea:	b084      	sub	sp, #16
 801f0ec:	af00      	add	r7, sp, #0
 801f0ee:	6078      	str	r0, [r7, #4]
 801f0f0:	460b      	mov	r3, r1
 801f0f2:	807b      	strh	r3, [r7, #2]
 801f0f4:	4613      	mov	r3, r2
 801f0f6:	803b      	strh	r3, [r7, #0]
    lv_arc_ext_t * ext = lv_obj_get_ext_attr(arc);
 801f0f8:	6878      	ldr	r0, [r7, #4]
 801f0fa:	f7f4 ff5c 	bl	8013fb6 <lv_obj_get_ext_attr>
 801f0fe:	60f8      	str	r0, [r7, #12]

    if(start > 360) start = 360;
 801f100:	887b      	ldrh	r3, [r7, #2]
 801f102:	f5b3 7fb4 	cmp.w	r3, #360	; 0x168
 801f106:	d902      	bls.n	801f10e <lv_arc_set_angles+0x26>
 801f108:	f44f 73b4 	mov.w	r3, #360	; 0x168
 801f10c:	807b      	strh	r3, [r7, #2]
    if(end > 360) end = 360;
 801f10e:	883b      	ldrh	r3, [r7, #0]
 801f110:	f5b3 7fb4 	cmp.w	r3, #360	; 0x168
 801f114:	d902      	bls.n	801f11c <lv_arc_set_angles+0x34>
 801f116:	f44f 73b4 	mov.w	r3, #360	; 0x168
 801f11a:	803b      	strh	r3, [r7, #0]

    ext->angle_start = start;
 801f11c:	f9b7 2002 	ldrsh.w	r2, [r7, #2]
 801f120:	68fb      	ldr	r3, [r7, #12]
 801f122:	801a      	strh	r2, [r3, #0]
    ext->angle_end   = end;
 801f124:	f9b7 2000 	ldrsh.w	r2, [r7]
 801f128:	68fb      	ldr	r3, [r7, #12]
 801f12a:	805a      	strh	r2, [r3, #2]

    lv_obj_invalidate(arc);
 801f12c:	6878      	ldr	r0, [r7, #4]
 801f12e:	f7f3 fd9d 	bl	8012c6c <lv_obj_invalidate>
}
 801f132:	bf00      	nop
 801f134:	3710      	adds	r7, #16
 801f136:	46bd      	mov	sp, r7
 801f138:	bd80      	pop	{r7, pc}

0801f13a <lv_arc_set_style>:
 * @param arc pointer to arc object
 * @param type which style should be set
 * @param style pointer to a style
 *  */
void lv_arc_set_style(lv_obj_t * arc, lv_arc_style_t type, const lv_style_t * style)
{
 801f13a:	b580      	push	{r7, lr}
 801f13c:	b084      	sub	sp, #16
 801f13e:	af00      	add	r7, sp, #0
 801f140:	60f8      	str	r0, [r7, #12]
 801f142:	460b      	mov	r3, r1
 801f144:	607a      	str	r2, [r7, #4]
 801f146:	72fb      	strb	r3, [r7, #11]
    switch(type) {
 801f148:	7afb      	ldrb	r3, [r7, #11]
 801f14a:	2b00      	cmp	r3, #0
 801f14c:	d104      	bne.n	801f158 <lv_arc_set_style+0x1e>
        case LV_ARC_STYLE_MAIN: lv_obj_set_style(arc, style); break;
 801f14e:	6879      	ldr	r1, [r7, #4]
 801f150:	68f8      	ldr	r0, [r7, #12]
 801f152:	f7f4 fc62 	bl	8013a1a <lv_obj_set_style>
 801f156:	bf00      	nop
    }
}
 801f158:	bf00      	nop
 801f15a:	3710      	adds	r7, #16
 801f15c:	46bd      	mov	sp, r7
 801f15e:	bd80      	pop	{r7, pc}

0801f160 <lv_arc_get_style>:
 * @param arc pointer to arc object
 * @param type which style should be get
 * @return style pointer to the style
 *  */
const lv_style_t * lv_arc_get_style(const lv_obj_t * arc, lv_arc_style_t type)
{
 801f160:	b580      	push	{r7, lr}
 801f162:	b084      	sub	sp, #16
 801f164:	af00      	add	r7, sp, #0
 801f166:	6078      	str	r0, [r7, #4]
 801f168:	460b      	mov	r3, r1
 801f16a:	70fb      	strb	r3, [r7, #3]
    const lv_style_t * style = NULL;
 801f16c:	2300      	movs	r3, #0
 801f16e:	60fb      	str	r3, [r7, #12]

    switch(type) {
 801f170:	78fb      	ldrb	r3, [r7, #3]
 801f172:	2b00      	cmp	r3, #0
 801f174:	d104      	bne.n	801f180 <lv_arc_get_style+0x20>
        case LV_ARC_STYLE_MAIN: style = lv_obj_get_style(arc); break;
 801f176:	6878      	ldr	r0, [r7, #4]
 801f178:	f7f4 fe62 	bl	8013e40 <lv_obj_get_style>
 801f17c:	60f8      	str	r0, [r7, #12]
 801f17e:	e002      	b.n	801f186 <lv_arc_get_style+0x26>
        default: style = NULL; break;
 801f180:	2300      	movs	r3, #0
 801f182:	60fb      	str	r3, [r7, #12]
 801f184:	bf00      	nop
    }

    return style;
 801f186:	68fb      	ldr	r3, [r7, #12]
}
 801f188:	4618      	mov	r0, r3
 801f18a:	3710      	adds	r7, #16
 801f18c:	46bd      	mov	sp, r7
 801f18e:	bd80      	pop	{r7, pc}

0801f190 <lv_arc_design>:
 *             LV_DESIGN_DRAW: draw the object (always return 'true')
 *             LV_DESIGN_DRAW_POST: drawing after every children are drawn
 * @param return true/false, depends on 'mode'
 */
static bool lv_arc_design(lv_obj_t * arc, const lv_area_t * mask, lv_design_mode_t mode)
{
 801f190:	b5b0      	push	{r4, r5, r7, lr}
 801f192:	b0a0      	sub	sp, #128	; 0x80
 801f194:	af04      	add	r7, sp, #16
 801f196:	60f8      	str	r0, [r7, #12]
 801f198:	60b9      	str	r1, [r7, #8]
 801f19a:	4613      	mov	r3, r2
 801f19c:	71fb      	strb	r3, [r7, #7]
    /*Return false if the object is not covers the mask_p area*/
    if(mode == LV_DESIGN_COVER_CHK) {
 801f19e:	79fb      	ldrb	r3, [r7, #7]
 801f1a0:	2b02      	cmp	r3, #2
 801f1a2:	d101      	bne.n	801f1a8 <lv_arc_design+0x18>
        return false;
 801f1a4:	2300      	movs	r3, #0
 801f1a6:	e157      	b.n	801f458 <lv_arc_design+0x2c8>
    }
    /*Draw the object*/
    else if(mode == LV_DESIGN_DRAW_MAIN) {
 801f1a8:	79fb      	ldrb	r3, [r7, #7]
 801f1aa:	2b00      	cmp	r3, #0
 801f1ac:	f040 8153 	bne.w	801f456 <lv_arc_design+0x2c6>
        lv_arc_ext_t * ext       = lv_obj_get_ext_attr(arc);
 801f1b0:	68f8      	ldr	r0, [r7, #12]
 801f1b2:	f7f4 ff00 	bl	8013fb6 <lv_obj_get_ext_attr>
 801f1b6:	66f8      	str	r0, [r7, #108]	; 0x6c
        const lv_style_t * style = lv_arc_get_style(arc, LV_ARC_STYLE_MAIN);
 801f1b8:	2100      	movs	r1, #0
 801f1ba:	68f8      	ldr	r0, [r7, #12]
 801f1bc:	f7ff ffd0 	bl	801f160 <lv_arc_get_style>
 801f1c0:	66b8      	str	r0, [r7, #104]	; 0x68

        lv_coord_t r       = (LV_MATH_MIN(lv_obj_get_width(arc), lv_obj_get_height(arc))) / 2;
 801f1c2:	68f8      	ldr	r0, [r7, #12]
 801f1c4:	f7f4 fe20 	bl	8013e08 <lv_obj_get_width>
 801f1c8:	4603      	mov	r3, r0
 801f1ca:	461c      	mov	r4, r3
 801f1cc:	68f8      	ldr	r0, [r7, #12]
 801f1ce:	f7f4 fe29 	bl	8013e24 <lv_obj_get_height>
 801f1d2:	4603      	mov	r3, r0
 801f1d4:	429c      	cmp	r4, r3
 801f1d6:	da09      	bge.n	801f1ec <lv_arc_design+0x5c>
 801f1d8:	68f8      	ldr	r0, [r7, #12]
 801f1da:	f7f4 fe15 	bl	8013e08 <lv_obj_get_width>
 801f1de:	4603      	mov	r3, r0
 801f1e0:	2b00      	cmp	r3, #0
 801f1e2:	da00      	bge.n	801f1e6 <lv_arc_design+0x56>
 801f1e4:	3301      	adds	r3, #1
 801f1e6:	105b      	asrs	r3, r3, #1
 801f1e8:	b21b      	sxth	r3, r3
 801f1ea:	e008      	b.n	801f1fe <lv_arc_design+0x6e>
 801f1ec:	68f8      	ldr	r0, [r7, #12]
 801f1ee:	f7f4 fe19 	bl	8013e24 <lv_obj_get_height>
 801f1f2:	4603      	mov	r3, r0
 801f1f4:	2b00      	cmp	r3, #0
 801f1f6:	da00      	bge.n	801f1fa <lv_arc_design+0x6a>
 801f1f8:	3301      	adds	r3, #1
 801f1fa:	105b      	asrs	r3, r3, #1
 801f1fc:	b21b      	sxth	r3, r3
 801f1fe:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
        lv_coord_t x       = arc->coords.x1 + lv_obj_get_width(arc) / 2;
 801f202:	68fb      	ldr	r3, [r7, #12]
 801f204:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 801f208:	b29c      	uxth	r4, r3
 801f20a:	68f8      	ldr	r0, [r7, #12]
 801f20c:	f7f4 fdfc 	bl	8013e08 <lv_obj_get_width>
 801f210:	4603      	mov	r3, r0
 801f212:	2b00      	cmp	r3, #0
 801f214:	da00      	bge.n	801f218 <lv_arc_design+0x88>
 801f216:	3301      	adds	r3, #1
 801f218:	105b      	asrs	r3, r3, #1
 801f21a:	b21b      	sxth	r3, r3
 801f21c:	b29b      	uxth	r3, r3
 801f21e:	4423      	add	r3, r4
 801f220:	b29b      	uxth	r3, r3
 801f222:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
        lv_coord_t y       = arc->coords.y1 + lv_obj_get_height(arc) / 2;
 801f226:	68fb      	ldr	r3, [r7, #12]
 801f228:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 801f22c:	b29c      	uxth	r4, r3
 801f22e:	68f8      	ldr	r0, [r7, #12]
 801f230:	f7f4 fdf8 	bl	8013e24 <lv_obj_get_height>
 801f234:	4603      	mov	r3, r0
 801f236:	2b00      	cmp	r3, #0
 801f238:	da00      	bge.n	801f23c <lv_arc_design+0xac>
 801f23a:	3301      	adds	r3, #1
 801f23c:	105b      	asrs	r3, r3, #1
 801f23e:	b21b      	sxth	r3, r3
 801f240:	b29b      	uxth	r3, r3
 801f242:	4423      	add	r3, r4
 801f244:	b29b      	uxth	r3, r3
 801f246:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
        lv_opa_t opa_scale = lv_obj_get_opa_scale(arc);
 801f24a:	68f8      	ldr	r0, [r7, #12]
 801f24c:	f7f4 fe65 	bl	8013f1a <lv_obj_get_opa_scale>
 801f250:	4603      	mov	r3, r0
 801f252:	f887 3061 	strb.w	r3, [r7, #97]	; 0x61
        lv_draw_arc(x, y, r, mask, ext->angle_start, ext->angle_end, style, opa_scale);
 801f256:	f8b7 5066 	ldrh.w	r5, [r7, #102]	; 0x66
 801f25a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801f25c:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f260:	b29b      	uxth	r3, r3
 801f262:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 801f264:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
 801f268:	b292      	uxth	r2, r2
 801f26a:	f9b7 4062 	ldrsh.w	r4, [r7, #98]	; 0x62
 801f26e:	f9b7 0064 	ldrsh.w	r0, [r7, #100]	; 0x64
 801f272:	f897 1061 	ldrb.w	r1, [r7, #97]	; 0x61
 801f276:	9103      	str	r1, [sp, #12]
 801f278:	6eb9      	ldr	r1, [r7, #104]	; 0x68
 801f27a:	9102      	str	r1, [sp, #8]
 801f27c:	9201      	str	r2, [sp, #4]
 801f27e:	9300      	str	r3, [sp, #0]
 801f280:	68bb      	ldr	r3, [r7, #8]
 801f282:	462a      	mov	r2, r5
 801f284:	4621      	mov	r1, r4
 801f286:	f7f6 f913 	bl	80154b0 <lv_draw_arc>

        /*Draw circle on the ends if enabled */
        if(style->line.rounded) {
 801f28a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801f28c:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 801f290:	f003 0301 	and.w	r3, r3, #1
 801f294:	b2db      	uxtb	r3, r3
 801f296:	2b00      	cmp	r3, #0
 801f298:	f000 80dd 	beq.w	801f456 <lv_arc_design+0x2c6>
            lv_coord_t thick_half = style->line.width / 2;
 801f29c:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801f29e:	f9b3 3036 	ldrsh.w	r3, [r3, #54]	; 0x36
 801f2a2:	2b00      	cmp	r3, #0
 801f2a4:	da00      	bge.n	801f2a8 <lv_arc_design+0x118>
 801f2a6:	3301      	adds	r3, #1
 801f2a8:	105b      	asrs	r3, r3, #1
 801f2aa:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
            lv_coord_t cir_x      = ((r - thick_half) * lv_trigo_sin(ext->angle_start) >> LV_TRIGO_SHIFT);
 801f2ae:	f9b7 2066 	ldrsh.w	r2, [r7, #102]	; 0x66
 801f2b2:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 801f2b6:	1ad4      	subs	r4, r2, r3
 801f2b8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801f2ba:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f2be:	4618      	mov	r0, r3
 801f2c0:	f7fe fe7e 	bl	801dfc0 <lv_trigo_sin>
 801f2c4:	4603      	mov	r3, r0
 801f2c6:	fb03 f304 	mul.w	r3, r3, r4
 801f2ca:	13db      	asrs	r3, r3, #15
 801f2cc:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
            lv_coord_t cir_y      = ((r - thick_half) * lv_trigo_sin(ext->angle_start + 90) >> LV_TRIGO_SHIFT);
 801f2d0:	f9b7 2066 	ldrsh.w	r2, [r7, #102]	; 0x66
 801f2d4:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 801f2d8:	1ad4      	subs	r4, r2, r3
 801f2da:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801f2dc:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f2e0:	b29b      	uxth	r3, r3
 801f2e2:	335a      	adds	r3, #90	; 0x5a
 801f2e4:	b29b      	uxth	r3, r3
 801f2e6:	b21b      	sxth	r3, r3
 801f2e8:	4618      	mov	r0, r3
 801f2ea:	f7fe fe69 	bl	801dfc0 <lv_trigo_sin>
 801f2ee:	4603      	mov	r3, r0
 801f2f0:	fb03 f304 	mul.w	r3, r3, r4
 801f2f4:	13db      	asrs	r3, r3, #15
 801f2f6:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a

            lv_style_t cir_style;
            lv_style_copy(&cir_style, &lv_style_plain);
 801f2fa:	f107 0314 	add.w	r3, r7, #20
 801f2fe:	4958      	ldr	r1, [pc, #352]	; (801f460 <lv_arc_design+0x2d0>)
 801f300:	4618      	mov	r0, r3
 801f302:	f7f6 f83b 	bl	801537c <lv_style_copy>
            cir_style.body.grad_color = style->line.color;
 801f306:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801f308:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 801f30a:	833b      	strh	r3, [r7, #24]
            cir_style.body.main_color = cir_style.body.grad_color;
 801f30c:	8b3b      	ldrh	r3, [r7, #24]
 801f30e:	82fb      	strh	r3, [r7, #22]
            cir_style.body.radius     = LV_RADIUS_CIRCLE;
 801f310:	f647 4318 	movw	r3, #31768	; 0x7c18
 801f314:	837b      	strh	r3, [r7, #26]
            lv_area_t cir_area;
            cir_area.x1 = cir_x + x - thick_half;
 801f316:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 801f31a:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 801f31e:	4413      	add	r3, r2
 801f320:	b29a      	uxth	r2, r3
 801f322:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801f326:	1ad3      	subs	r3, r2, r3
 801f328:	b29b      	uxth	r3, r3
 801f32a:	b21b      	sxth	r3, r3
 801f32c:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
            cir_area.y1 = cir_y + y - thick_half;
 801f330:	f8b7 205a 	ldrh.w	r2, [r7, #90]	; 0x5a
 801f334:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 801f338:	4413      	add	r3, r2
 801f33a:	b29a      	uxth	r2, r3
 801f33c:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801f340:	1ad3      	subs	r3, r2, r3
 801f342:	b29b      	uxth	r3, r3
 801f344:	b21b      	sxth	r3, r3
 801f346:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
            cir_area.x2 = cir_x + x + thick_half;
 801f34a:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 801f34e:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 801f352:	4413      	add	r3, r2
 801f354:	b29a      	uxth	r2, r3
 801f356:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801f35a:	4413      	add	r3, r2
 801f35c:	b29b      	uxth	r3, r3
 801f35e:	b21b      	sxth	r3, r3
 801f360:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
            cir_area.y2 = cir_y + y + thick_half;
 801f364:	f8b7 205a 	ldrh.w	r2, [r7, #90]	; 0x5a
 801f368:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 801f36c:	4413      	add	r3, r2
 801f36e:	b29a      	uxth	r2, r3
 801f370:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801f374:	4413      	add	r3, r2
 801f376:	b29b      	uxth	r3, r3
 801f378:	b21b      	sxth	r3, r3
 801f37a:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56

            lv_draw_rect(&cir_area, mask, &cir_style, opa_scale);
 801f37e:	f897 3061 	ldrb.w	r3, [r7, #97]	; 0x61
 801f382:	f107 0214 	add.w	r2, r7, #20
 801f386:	f107 0050 	add.w	r0, r7, #80	; 0x50
 801f38a:	68b9      	ldr	r1, [r7, #8]
 801f38c:	f7f8 fb85 	bl	8017a9a <lv_draw_rect>

            cir_x = ((r - thick_half) * lv_trigo_sin(ext->angle_end) >> LV_TRIGO_SHIFT);
 801f390:	f9b7 2066 	ldrsh.w	r2, [r7, #102]	; 0x66
 801f394:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 801f398:	1ad4      	subs	r4, r2, r3
 801f39a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801f39c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801f3a0:	4618      	mov	r0, r3
 801f3a2:	f7fe fe0d 	bl	801dfc0 <lv_trigo_sin>
 801f3a6:	4603      	mov	r3, r0
 801f3a8:	fb03 f304 	mul.w	r3, r3, r4
 801f3ac:	13db      	asrs	r3, r3, #15
 801f3ae:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
            cir_y = ((r - thick_half) * lv_trigo_sin(ext->angle_end + 90) >> LV_TRIGO_SHIFT);
 801f3b2:	f9b7 2066 	ldrsh.w	r2, [r7, #102]	; 0x66
 801f3b6:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 801f3ba:	1ad4      	subs	r4, r2, r3
 801f3bc:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801f3be:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801f3c2:	b29b      	uxth	r3, r3
 801f3c4:	335a      	adds	r3, #90	; 0x5a
 801f3c6:	b29b      	uxth	r3, r3
 801f3c8:	b21b      	sxth	r3, r3
 801f3ca:	4618      	mov	r0, r3
 801f3cc:	f7fe fdf8 	bl	801dfc0 <lv_trigo_sin>
 801f3d0:	4603      	mov	r3, r0
 801f3d2:	fb03 f304 	mul.w	r3, r3, r4
 801f3d6:	13db      	asrs	r3, r3, #15
 801f3d8:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a

            cir_area.x1 = cir_x + x - thick_half;
 801f3dc:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 801f3e0:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 801f3e4:	4413      	add	r3, r2
 801f3e6:	b29a      	uxth	r2, r3
 801f3e8:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801f3ec:	1ad3      	subs	r3, r2, r3
 801f3ee:	b29b      	uxth	r3, r3
 801f3f0:	b21b      	sxth	r3, r3
 801f3f2:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
            cir_area.y1 = cir_y + y - thick_half;
 801f3f6:	f8b7 205a 	ldrh.w	r2, [r7, #90]	; 0x5a
 801f3fa:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 801f3fe:	4413      	add	r3, r2
 801f400:	b29a      	uxth	r2, r3
 801f402:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801f406:	1ad3      	subs	r3, r2, r3
 801f408:	b29b      	uxth	r3, r3
 801f40a:	b21b      	sxth	r3, r3
 801f40c:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
            cir_area.x2 = cir_x + x + thick_half;
 801f410:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 801f414:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 801f418:	4413      	add	r3, r2
 801f41a:	b29a      	uxth	r2, r3
 801f41c:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801f420:	4413      	add	r3, r2
 801f422:	b29b      	uxth	r3, r3
 801f424:	b21b      	sxth	r3, r3
 801f426:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
            cir_area.y2 = cir_y + y + thick_half;
 801f42a:	f8b7 205a 	ldrh.w	r2, [r7, #90]	; 0x5a
 801f42e:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 801f432:	4413      	add	r3, r2
 801f434:	b29a      	uxth	r2, r3
 801f436:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801f43a:	4413      	add	r3, r2
 801f43c:	b29b      	uxth	r3, r3
 801f43e:	b21b      	sxth	r3, r3
 801f440:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56

            lv_draw_rect(&cir_area, mask, &cir_style, opa_scale);
 801f444:	f897 3061 	ldrb.w	r3, [r7, #97]	; 0x61
 801f448:	f107 0214 	add.w	r2, r7, #20
 801f44c:	f107 0050 	add.w	r0, r7, #80	; 0x50
 801f450:	68b9      	ldr	r1, [r7, #8]
 801f452:	f7f8 fb22 	bl	8017a9a <lv_draw_rect>
    }
    /*Post draw when the children are drawn*/
    else if(mode == LV_DESIGN_DRAW_POST) {
    }

    return true;
 801f456:	2301      	movs	r3, #1
}
 801f458:	4618      	mov	r0, r3
 801f45a:	3770      	adds	r7, #112	; 0x70
 801f45c:	46bd      	mov	sp, r7
 801f45e:	bdb0      	pop	{r4, r5, r7, pc}
 801f460:	240634f8 	.word	0x240634f8

0801f464 <lv_arc_signal>:
 * @param sign a signal type from lv_signal_t enum
 * @param param pointer to a signal specific variable
 * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted
 */
static lv_res_t lv_arc_signal(lv_obj_t * arc, lv_signal_t sign, void * param)
{
 801f464:	b580      	push	{r7, lr}
 801f466:	b086      	sub	sp, #24
 801f468:	af00      	add	r7, sp, #0
 801f46a:	60f8      	str	r0, [r7, #12]
 801f46c:	460b      	mov	r3, r1
 801f46e:	607a      	str	r2, [r7, #4]
 801f470:	72fb      	strb	r3, [r7, #11]
    lv_res_t res;

    /* Include the ancient signal function */
    res = ancestor_signal(arc, sign, param);
 801f472:	4b18      	ldr	r3, [pc, #96]	; (801f4d4 <lv_arc_signal+0x70>)
 801f474:	681b      	ldr	r3, [r3, #0]
 801f476:	7af9      	ldrb	r1, [r7, #11]
 801f478:	687a      	ldr	r2, [r7, #4]
 801f47a:	68f8      	ldr	r0, [r7, #12]
 801f47c:	4798      	blx	r3
 801f47e:	4603      	mov	r3, r0
 801f480:	75bb      	strb	r3, [r7, #22]
    if(res != LV_RES_OK) return res;
 801f482:	7dbb      	ldrb	r3, [r7, #22]
 801f484:	2b01      	cmp	r3, #1
 801f486:	d001      	beq.n	801f48c <lv_arc_signal+0x28>
 801f488:	7dbb      	ldrb	r3, [r7, #22]
 801f48a:	e01e      	b.n	801f4ca <lv_arc_signal+0x66>

    if(sign == LV_SIGNAL_CLEANUP) {
 801f48c:	7afb      	ldrb	r3, [r7, #11]
 801f48e:	2b00      	cmp	r3, #0
 801f490:	d01a      	beq.n	801f4c8 <lv_arc_signal+0x64>
        /*Nothing to cleanup. (No dynamically allocated memory in 'ext')*/
    } else if(sign == LV_SIGNAL_GET_TYPE) {
 801f492:	7afb      	ldrb	r3, [r7, #11]
 801f494:	2b06      	cmp	r3, #6
 801f496:	d117      	bne.n	801f4c8 <lv_arc_signal+0x64>
        lv_obj_type_t * buf = param;
 801f498:	687b      	ldr	r3, [r7, #4]
 801f49a:	613b      	str	r3, [r7, #16]
        uint8_t i;
        for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
 801f49c:	2300      	movs	r3, #0
 801f49e:	75fb      	strb	r3, [r7, #23]
 801f4a0:	e008      	b.n	801f4b4 <lv_arc_signal+0x50>
            if(buf->type[i] == NULL) break;
 801f4a2:	7dfa      	ldrb	r2, [r7, #23]
 801f4a4:	693b      	ldr	r3, [r7, #16]
 801f4a6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801f4aa:	2b00      	cmp	r3, #0
 801f4ac:	d006      	beq.n	801f4bc <lv_arc_signal+0x58>
        for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
 801f4ae:	7dfb      	ldrb	r3, [r7, #23]
 801f4b0:	3301      	adds	r3, #1
 801f4b2:	75fb      	strb	r3, [r7, #23]
 801f4b4:	7dfb      	ldrb	r3, [r7, #23]
 801f4b6:	2b06      	cmp	r3, #6
 801f4b8:	d9f3      	bls.n	801f4a2 <lv_arc_signal+0x3e>
 801f4ba:	e000      	b.n	801f4be <lv_arc_signal+0x5a>
            if(buf->type[i] == NULL) break;
 801f4bc:	bf00      	nop
        }
        buf->type[i] = "lv_arc";
 801f4be:	7dfa      	ldrb	r2, [r7, #23]
 801f4c0:	693b      	ldr	r3, [r7, #16]
 801f4c2:	4905      	ldr	r1, [pc, #20]	; (801f4d8 <lv_arc_signal+0x74>)
 801f4c4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    }

    return res;
 801f4c8:	7dbb      	ldrb	r3, [r7, #22]
}
 801f4ca:	4618      	mov	r0, r3
 801f4cc:	3718      	adds	r7, #24
 801f4ce:	46bd      	mov	sp, r7
 801f4d0:	bd80      	pop	{r7, pc}
 801f4d2:	bf00      	nop
 801f4d4:	24062400 	.word	0x24062400
 801f4d8:	08022904 	.word	0x08022904

0801f4dc <lv_img_get_style>:
 * @param img pointer to an image object
 * @param type which style should be get (can be only `LV_IMG_STYLE_MAIN`)
 * @return pointer to the image's style
 */
static inline const lv_style_t * lv_img_get_style(const lv_obj_t * img, lv_img_style_t type)
{
 801f4dc:	b580      	push	{r7, lr}
 801f4de:	b082      	sub	sp, #8
 801f4e0:	af00      	add	r7, sp, #0
 801f4e2:	6078      	str	r0, [r7, #4]
 801f4e4:	460b      	mov	r3, r1
 801f4e6:	70fb      	strb	r3, [r7, #3]
    (void)type; /*Unused*/
    return lv_obj_get_style(img);
 801f4e8:	6878      	ldr	r0, [r7, #4]
 801f4ea:	f7f4 fca9 	bl	8013e40 <lv_obj_get_style>
 801f4ee:	4603      	mov	r3, r0
}
 801f4f0:	4618      	mov	r0, r3
 801f4f2:	3708      	adds	r7, #8
 801f4f4:	46bd      	mov	sp, r7
 801f4f6:	bd80      	pop	{r7, pc}

0801f4f8 <lv_img_create>:
 * @param par pointer to an object, it will be the parent of the new button
 * @param copy pointer to a image object, if not NULL then the new object will be copied from it
 * @return pointer to the created image
 */
lv_obj_t * lv_img_create(lv_obj_t * par, const lv_obj_t * copy)
{
 801f4f8:	b580      	push	{r7, lr}
 801f4fa:	b086      	sub	sp, #24
 801f4fc:	af00      	add	r7, sp, #0
 801f4fe:	6078      	str	r0, [r7, #4]
 801f500:	6039      	str	r1, [r7, #0]
    LV_LOG_TRACE("image create started");

    lv_obj_t * new_img = NULL;
 801f502:	2300      	movs	r3, #0
 801f504:	617b      	str	r3, [r7, #20]

    /*Create a basic object*/
    new_img = lv_obj_create(par, copy);
 801f506:	6839      	ldr	r1, [r7, #0]
 801f508:	6878      	ldr	r0, [r7, #4]
 801f50a:	f7f3 f939 	bl	8012780 <lv_obj_create>
 801f50e:	6178      	str	r0, [r7, #20]
    lv_mem_assert(new_img);
 801f510:	697b      	ldr	r3, [r7, #20]
 801f512:	2b00      	cmp	r3, #0
 801f514:	d100      	bne.n	801f518 <lv_img_create+0x20>
 801f516:	e7fe      	b.n	801f516 <lv_img_create+0x1e>
    if(new_img == NULL) return NULL;
 801f518:	697b      	ldr	r3, [r7, #20]
 801f51a:	2b00      	cmp	r3, #0
 801f51c:	d101      	bne.n	801f522 <lv_img_create+0x2a>
 801f51e:	2300      	movs	r3, #0
 801f520:	e07b      	b.n	801f61a <lv_img_create+0x122>

    if(ancestor_signal == NULL) ancestor_signal = lv_obj_get_signal_cb(new_img);
 801f522:	4b40      	ldr	r3, [pc, #256]	; (801f624 <lv_img_create+0x12c>)
 801f524:	681b      	ldr	r3, [r3, #0]
 801f526:	2b00      	cmp	r3, #0
 801f528:	d105      	bne.n	801f536 <lv_img_create+0x3e>
 801f52a:	6978      	ldr	r0, [r7, #20]
 801f52c:	f7f4 fd2b 	bl	8013f86 <lv_obj_get_signal_cb>
 801f530:	4603      	mov	r3, r0
 801f532:	4a3c      	ldr	r2, [pc, #240]	; (801f624 <lv_img_create+0x12c>)
 801f534:	6013      	str	r3, [r2, #0]

    /*Extend the basic object to image object*/
    lv_img_ext_t * ext = lv_obj_allocate_ext_attr(new_img, sizeof(lv_img_ext_t));
 801f536:	2110      	movs	r1, #16
 801f538:	6978      	ldr	r0, [r7, #20]
 801f53a:	f7f4 fb83 	bl	8013c44 <lv_obj_allocate_ext_attr>
 801f53e:	6138      	str	r0, [r7, #16]
    lv_mem_assert(ext);
 801f540:	693b      	ldr	r3, [r7, #16]
 801f542:	2b00      	cmp	r3, #0
 801f544:	d100      	bne.n	801f548 <lv_img_create+0x50>
 801f546:	e7fe      	b.n	801f546 <lv_img_create+0x4e>
    if(ext == NULL) return NULL;
 801f548:	693b      	ldr	r3, [r7, #16]
 801f54a:	2b00      	cmp	r3, #0
 801f54c:	d101      	bne.n	801f552 <lv_img_create+0x5a>
 801f54e:	2300      	movs	r3, #0
 801f550:	e063      	b.n	801f61a <lv_img_create+0x122>

    ext->src       = NULL;
 801f552:	693b      	ldr	r3, [r7, #16]
 801f554:	2200      	movs	r2, #0
 801f556:	601a      	str	r2, [r3, #0]
    ext->src_type  = LV_IMG_SRC_UNKNOWN;
 801f558:	693a      	ldr	r2, [r7, #16]
 801f55a:	7b13      	ldrb	r3, [r2, #12]
 801f55c:	f043 0303 	orr.w	r3, r3, #3
 801f560:	7313      	strb	r3, [r2, #12]
    ext->cf        = LV_IMG_CF_UNKNOWN;
 801f562:	693a      	ldr	r2, [r7, #16]
 801f564:	7b13      	ldrb	r3, [r2, #12]
 801f566:	f36f 03c7 	bfc	r3, #3, #5
 801f56a:	7313      	strb	r3, [r2, #12]
    ext->w         = lv_obj_get_width(new_img);
 801f56c:	6978      	ldr	r0, [r7, #20]
 801f56e:	f7f4 fc4b 	bl	8013e08 <lv_obj_get_width>
 801f572:	4603      	mov	r3, r0
 801f574:	461a      	mov	r2, r3
 801f576:	693b      	ldr	r3, [r7, #16]
 801f578:	811a      	strh	r2, [r3, #8]
    ext->h         = lv_obj_get_height(new_img);
 801f57a:	6978      	ldr	r0, [r7, #20]
 801f57c:	f7f4 fc52 	bl	8013e24 <lv_obj_get_height>
 801f580:	4603      	mov	r3, r0
 801f582:	461a      	mov	r2, r3
 801f584:	693b      	ldr	r3, [r7, #16]
 801f586:	815a      	strh	r2, [r3, #10]
    ext->auto_size = 1;
 801f588:	693a      	ldr	r2, [r7, #16]
 801f58a:	7b13      	ldrb	r3, [r2, #12]
 801f58c:	f043 0304 	orr.w	r3, r3, #4
 801f590:	7313      	strb	r3, [r2, #12]
    ext->offset.x  = 0;
 801f592:	693b      	ldr	r3, [r7, #16]
 801f594:	2200      	movs	r2, #0
 801f596:	809a      	strh	r2, [r3, #4]
    ext->offset.y  = 0;
 801f598:	693b      	ldr	r3, [r7, #16]
 801f59a:	2200      	movs	r2, #0
 801f59c:	80da      	strh	r2, [r3, #6]

    /*Init the new object*/
    lv_obj_set_signal_cb(new_img, lv_img_signal);
 801f59e:	4922      	ldr	r1, [pc, #136]	; (801f628 <lv_img_create+0x130>)
 801f5a0:	6978      	ldr	r0, [r7, #20]
 801f5a2:	f7f4 fb33 	bl	8013c0c <lv_obj_set_signal_cb>
    lv_obj_set_design_cb(new_img, lv_img_design);
 801f5a6:	4921      	ldr	r1, [pc, #132]	; (801f62c <lv_img_create+0x134>)
 801f5a8:	6978      	ldr	r0, [r7, #20]
 801f5aa:	f7f4 fb3d 	bl	8013c28 <lv_obj_set_design_cb>

    if(copy == NULL) {
 801f5ae:	683b      	ldr	r3, [r7, #0]
 801f5b0:	2b00      	cmp	r3, #0
 801f5b2:	d11a      	bne.n	801f5ea <lv_img_create+0xf2>
        lv_obj_set_click(new_img, false);
 801f5b4:	2100      	movs	r1, #0
 801f5b6:	6978      	ldr	r0, [r7, #20]
 801f5b8:	f7f4 fa8f 	bl	8013ada <lv_obj_set_click>
        /* Enable auto size for non screens
         * because image screens are wallpapers
         * and must be screen sized*/
        if(par != NULL) {
 801f5bc:	687b      	ldr	r3, [r7, #4]
 801f5be:	2b00      	cmp	r3, #0
 801f5c0:	d009      	beq.n	801f5d6 <lv_img_create+0xde>
            ext->auto_size = 1;
 801f5c2:	693a      	ldr	r2, [r7, #16]
 801f5c4:	7b13      	ldrb	r3, [r2, #12]
 801f5c6:	f043 0304 	orr.w	r3, r3, #4
 801f5ca:	7313      	strb	r3, [r2, #12]
            lv_obj_set_style(new_img, NULL); /*Inherit the style  by default*/
 801f5cc:	2100      	movs	r1, #0
 801f5ce:	6978      	ldr	r0, [r7, #20]
 801f5d0:	f7f4 fa23 	bl	8013a1a <lv_obj_set_style>
 801f5d4:	e020      	b.n	801f618 <lv_img_create+0x120>
        } else {
            ext->auto_size = 0;
 801f5d6:	693a      	ldr	r2, [r7, #16]
 801f5d8:	7b13      	ldrb	r3, [r2, #12]
 801f5da:	f36f 0382 	bfc	r3, #2, #1
 801f5de:	7313      	strb	r3, [r2, #12]
            lv_obj_set_style(new_img, &lv_style_plain); /*Set a style for screens*/
 801f5e0:	4913      	ldr	r1, [pc, #76]	; (801f630 <lv_img_create+0x138>)
 801f5e2:	6978      	ldr	r0, [r7, #20]
 801f5e4:	f7f4 fa19 	bl	8013a1a <lv_obj_set_style>
 801f5e8:	e016      	b.n	801f618 <lv_img_create+0x120>
        }
    } else {
        lv_img_ext_t * copy_ext = lv_obj_get_ext_attr(copy);
 801f5ea:	6838      	ldr	r0, [r7, #0]
 801f5ec:	f7f4 fce3 	bl	8013fb6 <lv_obj_get_ext_attr>
 801f5f0:	60f8      	str	r0, [r7, #12]
        ext->auto_size          = copy_ext->auto_size;
 801f5f2:	68fb      	ldr	r3, [r7, #12]
 801f5f4:	7b1b      	ldrb	r3, [r3, #12]
 801f5f6:	f3c3 0380 	ubfx	r3, r3, #2, #1
 801f5fa:	b2d9      	uxtb	r1, r3
 801f5fc:	693a      	ldr	r2, [r7, #16]
 801f5fe:	7b13      	ldrb	r3, [r2, #12]
 801f600:	f361 0382 	bfi	r3, r1, #2, #1
 801f604:	7313      	strb	r3, [r2, #12]
        lv_img_set_src(new_img, copy_ext->src);
 801f606:	68fb      	ldr	r3, [r7, #12]
 801f608:	681b      	ldr	r3, [r3, #0]
 801f60a:	4619      	mov	r1, r3
 801f60c:	6978      	ldr	r0, [r7, #20]
 801f60e:	f000 f811 	bl	801f634 <lv_img_set_src>

        /*Refresh the style with new signal function*/
        lv_obj_refresh_style(new_img);
 801f612:	6978      	ldr	r0, [r7, #20]
 801f614:	f7f4 fa13 	bl	8013a3e <lv_obj_refresh_style>
    }

    LV_LOG_INFO("image created");

    return new_img;
 801f618:	697b      	ldr	r3, [r7, #20]
}
 801f61a:	4618      	mov	r0, r3
 801f61c:	3718      	adds	r7, #24
 801f61e:	46bd      	mov	sp, r7
 801f620:	bd80      	pop	{r7, pc}
 801f622:	bf00      	nop
 801f624:	24062408 	.word	0x24062408
 801f628:	0801faa1 	.word	0x0801faa1
 801f62c:	0801f84b 	.word	0x0801f84b
 801f630:	240634f8 	.word	0x240634f8

0801f634 <lv_img_set_src>:
 * Set the pixel map to display by the image
 * @param img pointer to an image object
 * @param data the image data
 */
void lv_img_set_src(lv_obj_t * img, const void * src_img)
{
 801f634:	b590      	push	{r4, r7, lr}
 801f636:	b08f      	sub	sp, #60	; 0x3c
 801f638:	af04      	add	r7, sp, #16
 801f63a:	6078      	str	r0, [r7, #4]
 801f63c:	6039      	str	r1, [r7, #0]
    lv_img_src_t src_type = lv_img_src_get_type(src_img);
 801f63e:	6838      	ldr	r0, [r7, #0]
 801f640:	f7f7 fbf7 	bl	8016e32 <lv_img_src_get_type>
 801f644:	4603      	mov	r3, r0
 801f646:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    lv_img_ext_t * ext    = lv_obj_get_ext_attr(img);
 801f64a:	6878      	ldr	r0, [r7, #4]
 801f64c:	f7f4 fcb3 	bl	8013fb6 <lv_obj_get_ext_attr>
 801f650:	61f8      	str	r0, [r7, #28]
        default: LV_LOG_WARN("lv_img_set_src: unknown type");
    }
#endif

    /*If the new source type is unknown free the memories of the old source*/
    if(src_type == LV_IMG_SRC_UNKNOWN) {
 801f652:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 801f656:	2b03      	cmp	r3, #3
 801f658:	d11b      	bne.n	801f692 <lv_img_set_src+0x5e>
        LV_LOG_WARN("lv_img_set_src: unknown image type");
        if(ext->src_type == LV_IMG_SRC_SYMBOL || ext->src_type == LV_IMG_SRC_FILE) {
 801f65a:	69fb      	ldr	r3, [r7, #28]
 801f65c:	7b1b      	ldrb	r3, [r3, #12]
 801f65e:	f003 0303 	and.w	r3, r3, #3
 801f662:	b2db      	uxtb	r3, r3
 801f664:	2b02      	cmp	r3, #2
 801f666:	d006      	beq.n	801f676 <lv_img_set_src+0x42>
 801f668:	69fb      	ldr	r3, [r7, #28]
 801f66a:	7b1b      	ldrb	r3, [r3, #12]
 801f66c:	f003 0303 	and.w	r3, r3, #3
 801f670:	b2db      	uxtb	r3, r3
 801f672:	2b01      	cmp	r3, #1
 801f674:	d104      	bne.n	801f680 <lv_img_set_src+0x4c>
            lv_mem_free(ext->src);
 801f676:	69fb      	ldr	r3, [r7, #28]
 801f678:	681b      	ldr	r3, [r3, #0]
 801f67a:	4618      	mov	r0, r3
 801f67c:	f7fe fd58 	bl	801e130 <lv_mem_free>
        }
        ext->src      = NULL;
 801f680:	69fb      	ldr	r3, [r7, #28]
 801f682:	2200      	movs	r2, #0
 801f684:	601a      	str	r2, [r3, #0]
        ext->src_type = LV_IMG_SRC_UNKNOWN;
 801f686:	69fa      	ldr	r2, [r7, #28]
 801f688:	7b13      	ldrb	r3, [r2, #12]
 801f68a:	f043 0303 	orr.w	r3, r3, #3
 801f68e:	7313      	strb	r3, [r2, #12]
        return;
 801f690:	e0c2      	b.n	801f818 <lv_img_set_src+0x1e4>
    }

    lv_img_header_t header;
    lv_img_decoder_get_info(src_img, &header);
 801f692:	f107 0310 	add.w	r3, r7, #16
 801f696:	4619      	mov	r1, r3
 801f698:	6838      	ldr	r0, [r7, #0]
 801f69a:	f7fc fb35 	bl	801bd08 <lv_img_decoder_get_info>

    /*Save the source*/
    if(src_type == LV_IMG_SRC_VARIABLE) {
 801f69e:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 801f6a2:	2b00      	cmp	r3, #0
 801f6a4:	d116      	bne.n	801f6d4 <lv_img_set_src+0xa0>
        LV_LOG_INFO("lv_img_set_src:  `LV_IMG_SRC_VARIABLE` type found");

        /*If memory was allocated because of the previous `src_type` then free it*/
        if(ext->src_type == LV_IMG_SRC_FILE || ext->src_type == LV_IMG_SRC_SYMBOL) {
 801f6a6:	69fb      	ldr	r3, [r7, #28]
 801f6a8:	7b1b      	ldrb	r3, [r3, #12]
 801f6aa:	f003 0303 	and.w	r3, r3, #3
 801f6ae:	b2db      	uxtb	r3, r3
 801f6b0:	2b01      	cmp	r3, #1
 801f6b2:	d006      	beq.n	801f6c2 <lv_img_set_src+0x8e>
 801f6b4:	69fb      	ldr	r3, [r7, #28]
 801f6b6:	7b1b      	ldrb	r3, [r3, #12]
 801f6b8:	f003 0303 	and.w	r3, r3, #3
 801f6bc:	b2db      	uxtb	r3, r3
 801f6be:	2b02      	cmp	r3, #2
 801f6c0:	d104      	bne.n	801f6cc <lv_img_set_src+0x98>
            lv_mem_free(ext->src);
 801f6c2:	69fb      	ldr	r3, [r7, #28]
 801f6c4:	681b      	ldr	r3, [r3, #0]
 801f6c6:	4618      	mov	r0, r3
 801f6c8:	f7fe fd32 	bl	801e130 <lv_mem_free>
        }
        ext->src = src_img;
 801f6cc:	69fb      	ldr	r3, [r7, #28]
 801f6ce:	683a      	ldr	r2, [r7, #0]
 801f6d0:	601a      	str	r2, [r3, #0]
 801f6d2:	e03c      	b.n	801f74e <lv_img_set_src+0x11a>
    } else if(src_type == LV_IMG_SRC_FILE || src_type == LV_IMG_SRC_SYMBOL) {
 801f6d4:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 801f6d8:	2b01      	cmp	r3, #1
 801f6da:	d003      	beq.n	801f6e4 <lv_img_set_src+0xb0>
 801f6dc:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 801f6e0:	2b02      	cmp	r3, #2
 801f6e2:	d134      	bne.n	801f74e <lv_img_set_src+0x11a>
        /* If the new and the old src are the same then it was only a refresh.*/
        if(ext->src != src_img) {
 801f6e4:	69fb      	ldr	r3, [r7, #28]
 801f6e6:	681b      	ldr	r3, [r3, #0]
 801f6e8:	683a      	ldr	r2, [r7, #0]
 801f6ea:	429a      	cmp	r2, r3
 801f6ec:	d02f      	beq.n	801f74e <lv_img_set_src+0x11a>
            const void * old_src = NULL;
 801f6ee:	2300      	movs	r3, #0
 801f6f0:	627b      	str	r3, [r7, #36]	; 0x24
            /* If memory was allocated because of the previous `src_type` then save its pointer and free after allocation.
             * It's important to allocate first to be sure the new data will be on a new address.
             * Else `img_cache` wouldn't see the change in source.*/
            if(ext->src_type == LV_IMG_SRC_FILE || ext->src_type == LV_IMG_SRC_SYMBOL) {
 801f6f2:	69fb      	ldr	r3, [r7, #28]
 801f6f4:	7b1b      	ldrb	r3, [r3, #12]
 801f6f6:	f003 0303 	and.w	r3, r3, #3
 801f6fa:	b2db      	uxtb	r3, r3
 801f6fc:	2b01      	cmp	r3, #1
 801f6fe:	d006      	beq.n	801f70e <lv_img_set_src+0xda>
 801f700:	69fb      	ldr	r3, [r7, #28]
 801f702:	7b1b      	ldrb	r3, [r3, #12]
 801f704:	f003 0303 	and.w	r3, r3, #3
 801f708:	b2db      	uxtb	r3, r3
 801f70a:	2b02      	cmp	r3, #2
 801f70c:	d102      	bne.n	801f714 <lv_img_set_src+0xe0>
                old_src = ext->src;
 801f70e:	69fb      	ldr	r3, [r7, #28]
 801f710:	681b      	ldr	r3, [r3, #0]
 801f712:	627b      	str	r3, [r7, #36]	; 0x24
            }
            char * new_str = lv_mem_alloc(strlen(src_img) + 1);
 801f714:	6838      	ldr	r0, [r7, #0]
 801f716:	f7e0 fded 	bl	80002f4 <strlen>
 801f71a:	4603      	mov	r3, r0
 801f71c:	3301      	adds	r3, #1
 801f71e:	4618      	mov	r0, r3
 801f720:	f7fe fcc6 	bl	801e0b0 <lv_mem_alloc>
 801f724:	61b8      	str	r0, [r7, #24]
            lv_mem_assert(new_str);
 801f726:	69bb      	ldr	r3, [r7, #24]
 801f728:	2b00      	cmp	r3, #0
 801f72a:	d100      	bne.n	801f72e <lv_img_set_src+0xfa>
 801f72c:	e7fe      	b.n	801f72c <lv_img_set_src+0xf8>
            if(new_str == NULL) return;
 801f72e:	69bb      	ldr	r3, [r7, #24]
 801f730:	2b00      	cmp	r3, #0
 801f732:	d070      	beq.n	801f816 <lv_img_set_src+0x1e2>
            strcpy(new_str, src_img);
 801f734:	6839      	ldr	r1, [r7, #0]
 801f736:	69b8      	ldr	r0, [r7, #24]
 801f738:	f002 fb98 	bl	8021e6c <strcpy>
            ext->src = new_str;
 801f73c:	69fb      	ldr	r3, [r7, #28]
 801f73e:	69ba      	ldr	r2, [r7, #24]
 801f740:	601a      	str	r2, [r3, #0]

            if(old_src) lv_mem_free(old_src);
 801f742:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801f744:	2b00      	cmp	r3, #0
 801f746:	d002      	beq.n	801f74e <lv_img_set_src+0x11a>
 801f748:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801f74a:	f7fe fcf1 	bl	801e130 <lv_mem_free>
        }
    }

    if(src_type == LV_IMG_SRC_SYMBOL) {
 801f74e:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 801f752:	2b02      	cmp	r3, #2
 801f754:	d12a      	bne.n	801f7ac <lv_img_set_src+0x178>
        /*`lv_img_dsc_get_info` couldn't set the with and height of a font so set it here*/
        const lv_style_t * style = lv_img_get_style(img, LV_IMG_STYLE_MAIN);
 801f756:	2100      	movs	r1, #0
 801f758:	6878      	ldr	r0, [r7, #4]
 801f75a:	f7ff febf 	bl	801f4dc <lv_img_get_style>
 801f75e:	6178      	str	r0, [r7, #20]
        lv_point_t size;
        lv_txt_get_size(&size, src_img, style->text.font, style->text.letter_space, style->text.line_space,
 801f760:	697b      	ldr	r3, [r7, #20]
 801f762:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 801f764:	697b      	ldr	r3, [r7, #20]
 801f766:	f9b3 1028 	ldrsh.w	r1, [r3, #40]	; 0x28
 801f76a:	697b      	ldr	r3, [r7, #20]
 801f76c:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 801f770:	f107 000c 	add.w	r0, r7, #12
 801f774:	2400      	movs	r4, #0
 801f776:	9402      	str	r4, [sp, #8]
 801f778:	f647 4418 	movw	r4, #31768	; 0x7c18
 801f77c:	9401      	str	r4, [sp, #4]
 801f77e:	9300      	str	r3, [sp, #0]
 801f780:	460b      	mov	r3, r1
 801f782:	6839      	ldr	r1, [r7, #0]
 801f784:	f7fe ffe0 	bl	801e748 <lv_txt_get_size>
                        LV_COORD_MAX, LV_TXT_FLAG_NONE);
        header.w = size.x;
 801f788:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 801f78c:	f3c3 030a 	ubfx	r3, r3, #0, #11
 801f790:	b29a      	uxth	r2, r3
 801f792:	693b      	ldr	r3, [r7, #16]
 801f794:	f362 2394 	bfi	r3, r2, #10, #11
 801f798:	613b      	str	r3, [r7, #16]
        header.h = size.y;
 801f79a:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 801f79e:	f3c3 030a 	ubfx	r3, r3, #0, #11
 801f7a2:	b29a      	uxth	r2, r3
 801f7a4:	8a7b      	ldrh	r3, [r7, #18]
 801f7a6:	f362 134f 	bfi	r3, r2, #5, #11
 801f7aa:	827b      	strh	r3, [r7, #18]
    }

    ext->src_type = src_type;
 801f7ac:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 801f7b0:	f003 0303 	and.w	r3, r3, #3
 801f7b4:	b2d9      	uxtb	r1, r3
 801f7b6:	69fa      	ldr	r2, [r7, #28]
 801f7b8:	7b13      	ldrb	r3, [r2, #12]
 801f7ba:	f361 0301 	bfi	r3, r1, #0, #2
 801f7be:	7313      	strb	r3, [r2, #12]
    ext->w        = header.w;
 801f7c0:	693b      	ldr	r3, [r7, #16]
 801f7c2:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801f7c6:	b29b      	uxth	r3, r3
 801f7c8:	b21a      	sxth	r2, r3
 801f7ca:	69fb      	ldr	r3, [r7, #28]
 801f7cc:	811a      	strh	r2, [r3, #8]
    ext->h        = header.h;
 801f7ce:	8a7b      	ldrh	r3, [r7, #18]
 801f7d0:	f3c3 134a 	ubfx	r3, r3, #5, #11
 801f7d4:	b29b      	uxth	r3, r3
 801f7d6:	b21a      	sxth	r2, r3
 801f7d8:	69fb      	ldr	r3, [r7, #28]
 801f7da:	815a      	strh	r2, [r3, #10]
    ext->cf       = header.cf;
 801f7dc:	7c3b      	ldrb	r3, [r7, #16]
 801f7de:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801f7e2:	b2d9      	uxtb	r1, r3
 801f7e4:	69fa      	ldr	r2, [r7, #28]
 801f7e6:	7b13      	ldrb	r3, [r2, #12]
 801f7e8:	f361 03c7 	bfi	r3, r1, #3, #5
 801f7ec:	7313      	strb	r3, [r2, #12]

    if(lv_img_get_auto_size(img) != false) {
 801f7ee:	6878      	ldr	r0, [r7, #4]
 801f7f0:	f000 f815 	bl	801f81e <lv_img_get_auto_size>
 801f7f4:	4603      	mov	r3, r0
 801f7f6:	2b00      	cmp	r3, #0
 801f7f8:	d009      	beq.n	801f80e <lv_img_set_src+0x1da>
        lv_obj_set_size(img, ext->w, ext->h);
 801f7fa:	69fb      	ldr	r3, [r7, #28]
 801f7fc:	f9b3 1008 	ldrsh.w	r1, [r3, #8]
 801f800:	69fb      	ldr	r3, [r7, #28]
 801f802:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 801f806:	461a      	mov	r2, r3
 801f808:	6878      	ldr	r0, [r7, #4]
 801f80a:	f7f3 fb9d 	bl	8012f48 <lv_obj_set_size>
    }

    lv_obj_invalidate(img);
 801f80e:	6878      	ldr	r0, [r7, #4]
 801f810:	f7f3 fa2c 	bl	8012c6c <lv_obj_invalidate>
 801f814:	e000      	b.n	801f818 <lv_img_set_src+0x1e4>
            if(new_str == NULL) return;
 801f816:	bf00      	nop
}
 801f818:	372c      	adds	r7, #44	; 0x2c
 801f81a:	46bd      	mov	sp, r7
 801f81c:	bd90      	pop	{r4, r7, pc}

0801f81e <lv_img_get_auto_size>:
 * Get the auto size enable attribute
 * @param img pointer to an image
 * @return true: auto size is enabled, false: auto size is disabled
 */
bool lv_img_get_auto_size(const lv_obj_t * img)
{
 801f81e:	b580      	push	{r7, lr}
 801f820:	b084      	sub	sp, #16
 801f822:	af00      	add	r7, sp, #0
 801f824:	6078      	str	r0, [r7, #4]
    lv_img_ext_t * ext = lv_obj_get_ext_attr(img);
 801f826:	6878      	ldr	r0, [r7, #4]
 801f828:	f7f4 fbc5 	bl	8013fb6 <lv_obj_get_ext_attr>
 801f82c:	60f8      	str	r0, [r7, #12]

    return ext->auto_size == 0 ? false : true;
 801f82e:	68fb      	ldr	r3, [r7, #12]
 801f830:	7b1b      	ldrb	r3, [r3, #12]
 801f832:	f003 0304 	and.w	r3, r3, #4
 801f836:	b2db      	uxtb	r3, r3
 801f838:	2b00      	cmp	r3, #0
 801f83a:	bf14      	ite	ne
 801f83c:	2301      	movne	r3, #1
 801f83e:	2300      	moveq	r3, #0
 801f840:	b2db      	uxtb	r3, r3
}
 801f842:	4618      	mov	r0, r3
 801f844:	3710      	adds	r7, #16
 801f846:	46bd      	mov	sp, r7
 801f848:	bd80      	pop	{r7, pc}

0801f84a <lv_img_design>:
 *             LV_DESIGN_DRAW: draw the object (always return 'true')
 *             LV_DESIGN_DRAW_POST: drawing after every children are drawn
 * @param return true/false, depends on 'mode'
 */
static bool lv_img_design(lv_obj_t * img, const lv_area_t * mask, lv_design_mode_t mode)
{
 801f84a:	b590      	push	{r4, r7, lr}
 801f84c:	b0a3      	sub	sp, #140	; 0x8c
 801f84e:	af06      	add	r7, sp, #24
 801f850:	60f8      	str	r0, [r7, #12]
 801f852:	60b9      	str	r1, [r7, #8]
 801f854:	4613      	mov	r3, r2
 801f856:	71fb      	strb	r3, [r7, #7]
    const lv_style_t * style = lv_obj_get_style(img);
 801f858:	68f8      	ldr	r0, [r7, #12]
 801f85a:	f7f4 faf1 	bl	8013e40 <lv_obj_get_style>
 801f85e:	66b8      	str	r0, [r7, #104]	; 0x68
    lv_img_ext_t * ext       = lv_obj_get_ext_attr(img);
 801f860:	68f8      	ldr	r0, [r7, #12]
 801f862:	f7f4 fba8 	bl	8013fb6 <lv_obj_get_ext_attr>
 801f866:	6678      	str	r0, [r7, #100]	; 0x64

    if(mode == LV_DESIGN_COVER_CHK) {
 801f868:	79fb      	ldrb	r3, [r7, #7]
 801f86a:	2b02      	cmp	r3, #2
 801f86c:	d12c      	bne.n	801f8c8 <lv_img_design+0x7e>
        bool cover = false;
 801f86e:	2300      	movs	r3, #0
 801f870:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
        if(ext->src_type == LV_IMG_SRC_UNKNOWN || ext->src_type == LV_IMG_SRC_SYMBOL) return false;
 801f874:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801f876:	7b1b      	ldrb	r3, [r3, #12]
 801f878:	f003 0303 	and.w	r3, r3, #3
 801f87c:	b2db      	uxtb	r3, r3
 801f87e:	2b03      	cmp	r3, #3
 801f880:	d006      	beq.n	801f890 <lv_img_design+0x46>
 801f882:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801f884:	7b1b      	ldrb	r3, [r3, #12]
 801f886:	f003 0303 	and.w	r3, r3, #3
 801f88a:	b2db      	uxtb	r3, r3
 801f88c:	2b02      	cmp	r3, #2
 801f88e:	d101      	bne.n	801f894 <lv_img_design+0x4a>
 801f890:	2300      	movs	r3, #0
 801f892:	e100      	b.n	801fa96 <lv_img_design+0x24c>

        if(ext->cf == LV_IMG_CF_TRUE_COLOR || ext->cf == LV_IMG_CF_RAW) cover = lv_area_is_in(mask, &img->coords);
 801f894:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801f896:	7b1b      	ldrb	r3, [r3, #12]
 801f898:	f023 0307 	bic.w	r3, r3, #7
 801f89c:	b2db      	uxtb	r3, r3
 801f89e:	2b20      	cmp	r3, #32
 801f8a0:	d006      	beq.n	801f8b0 <lv_img_design+0x66>
 801f8a2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801f8a4:	7b1b      	ldrb	r3, [r3, #12]
 801f8a6:	f023 0307 	bic.w	r3, r3, #7
 801f8aa:	b2db      	uxtb	r3, r3
 801f8ac:	2b08      	cmp	r3, #8
 801f8ae:	d108      	bne.n	801f8c2 <lv_img_design+0x78>
 801f8b0:	68fb      	ldr	r3, [r7, #12]
 801f8b2:	3310      	adds	r3, #16
 801f8b4:	4619      	mov	r1, r3
 801f8b6:	68b8      	ldr	r0, [r7, #8]
 801f8b8:	f7fe f869 	bl	801d98e <lv_area_is_in>
 801f8bc:	4603      	mov	r3, r0
 801f8be:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f

        return cover;
 801f8c2:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 801f8c6:	e0e6      	b.n	801fa96 <lv_img_design+0x24c>
    } else if(mode == LV_DESIGN_DRAW_MAIN) {
 801f8c8:	79fb      	ldrb	r3, [r7, #7]
 801f8ca:	2b00      	cmp	r3, #0
 801f8cc:	f040 80e2 	bne.w	801fa94 <lv_img_design+0x24a>
        if(ext->h == 0 || ext->w == 0) return true;
 801f8d0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801f8d2:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 801f8d6:	2b00      	cmp	r3, #0
 801f8d8:	d004      	beq.n	801f8e4 <lv_img_design+0x9a>
 801f8da:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801f8dc:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 801f8e0:	2b00      	cmp	r3, #0
 801f8e2:	d101      	bne.n	801f8e8 <lv_img_design+0x9e>
 801f8e4:	2301      	movs	r3, #1
 801f8e6:	e0d6      	b.n	801fa96 <lv_img_design+0x24c>
        lv_area_t coords;
        lv_opa_t opa_scale = lv_obj_get_opa_scale(img);
 801f8e8:	68f8      	ldr	r0, [r7, #12]
 801f8ea:	f7f4 fb16 	bl	8013f1a <lv_obj_get_opa_scale>
 801f8ee:	4603      	mov	r3, r0
 801f8f0:	f887 3063 	strb.w	r3, [r7, #99]	; 0x63

        lv_obj_get_coords(img, &coords);
 801f8f4:	f107 0358 	add.w	r3, r7, #88	; 0x58
 801f8f8:	4619      	mov	r1, r3
 801f8fa:	68f8      	ldr	r0, [r7, #12]
 801f8fc:	f7f4 fa43 	bl	8013d86 <lv_obj_get_coords>

        if(ext->src_type == LV_IMG_SRC_FILE || ext->src_type == LV_IMG_SRC_VARIABLE) {
 801f900:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801f902:	7b1b      	ldrb	r3, [r3, #12]
 801f904:	f003 0303 	and.w	r3, r3, #3
 801f908:	b2db      	uxtb	r3, r3
 801f90a:	2b01      	cmp	r3, #1
 801f90c:	d007      	beq.n	801f91e <lv_img_design+0xd4>
 801f90e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801f910:	7b1b      	ldrb	r3, [r3, #12]
 801f912:	f003 0303 	and.w	r3, r3, #3
 801f916:	b2db      	uxtb	r3, r3
 801f918:	2b00      	cmp	r3, #0
 801f91a:	f040 8086 	bne.w	801fa2a <lv_img_design+0x1e0>
            coords.x1 -= ext->offset.x;
 801f91e:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 801f922:	b29a      	uxth	r2, r3
 801f924:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801f926:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801f92a:	b29b      	uxth	r3, r3
 801f92c:	1ad3      	subs	r3, r2, r3
 801f92e:	b29b      	uxth	r3, r3
 801f930:	b21b      	sxth	r3, r3
 801f932:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58
            coords.y1 -= ext->offset.y;
 801f936:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 801f93a:	b29a      	uxth	r2, r3
 801f93c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801f93e:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801f942:	b29b      	uxth	r3, r3
 801f944:	1ad3      	subs	r3, r2, r3
 801f946:	b29b      	uxth	r3, r3
 801f948:	b21b      	sxth	r3, r3
 801f94a:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a

            LV_LOG_TRACE("lv_img_design: start to draw image");
            lv_area_t cords_tmp;
            cords_tmp.y1 = coords.y1;
 801f94e:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 801f952:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
            cords_tmp.y2 = coords.y1 + ext->h - 1;
 801f956:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 801f95a:	b29a      	uxth	r2, r3
 801f95c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801f95e:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 801f962:	b29b      	uxth	r3, r3
 801f964:	4413      	add	r3, r2
 801f966:	b29b      	uxth	r3, r3
 801f968:	3b01      	subs	r3, #1
 801f96a:	b29b      	uxth	r3, r3
 801f96c:	b21b      	sxth	r3, r3
 801f96e:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56

            for(; cords_tmp.y1 < coords.y2; cords_tmp.y1 += ext->h, cords_tmp.y2 += ext->h) {
 801f972:	e053      	b.n	801fa1c <lv_img_design+0x1d2>
                cords_tmp.x1 = coords.x1;
 801f974:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 801f978:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
                cords_tmp.x2 = coords.x1 + ext->w - 1;
 801f97c:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 801f980:	b29a      	uxth	r2, r3
 801f982:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801f984:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 801f988:	b29b      	uxth	r3, r3
 801f98a:	4413      	add	r3, r2
 801f98c:	b29b      	uxth	r3, r3
 801f98e:	3b01      	subs	r3, #1
 801f990:	b29b      	uxth	r3, r3
 801f992:	b21b      	sxth	r3, r3
 801f994:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
                for(; cords_tmp.x1 < coords.x2; cords_tmp.x1 += ext->w, cords_tmp.x2 += ext->w) {
 801f998:	e022      	b.n	801f9e0 <lv_img_design+0x196>
                    lv_draw_img(&cords_tmp, mask, ext->src, style, opa_scale);
 801f99a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801f99c:	681a      	ldr	r2, [r3, #0]
 801f99e:	f107 0050 	add.w	r0, r7, #80	; 0x50
 801f9a2:	f897 3063 	ldrb.w	r3, [r7, #99]	; 0x63
 801f9a6:	9300      	str	r3, [sp, #0]
 801f9a8:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801f9aa:	68b9      	ldr	r1, [r7, #8]
 801f9ac:	f7f7 f95a 	bl	8016c64 <lv_draw_img>
                for(; cords_tmp.x1 < coords.x2; cords_tmp.x1 += ext->w, cords_tmp.x2 += ext->w) {
 801f9b0:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 801f9b4:	b29a      	uxth	r2, r3
 801f9b6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801f9b8:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 801f9bc:	b29b      	uxth	r3, r3
 801f9be:	4413      	add	r3, r2
 801f9c0:	b29b      	uxth	r3, r3
 801f9c2:	b21b      	sxth	r3, r3
 801f9c4:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
 801f9c8:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 801f9cc:	b29a      	uxth	r2, r3
 801f9ce:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801f9d0:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 801f9d4:	b29b      	uxth	r3, r3
 801f9d6:	4413      	add	r3, r2
 801f9d8:	b29b      	uxth	r3, r3
 801f9da:	b21b      	sxth	r3, r3
 801f9dc:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
 801f9e0:	f9b7 2050 	ldrsh.w	r2, [r7, #80]	; 0x50
 801f9e4:	f9b7 305c 	ldrsh.w	r3, [r7, #92]	; 0x5c
 801f9e8:	429a      	cmp	r2, r3
 801f9ea:	dbd6      	blt.n	801f99a <lv_img_design+0x150>
            for(; cords_tmp.y1 < coords.y2; cords_tmp.y1 += ext->h, cords_tmp.y2 += ext->h) {
 801f9ec:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 801f9f0:	b29a      	uxth	r2, r3
 801f9f2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801f9f4:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 801f9f8:	b29b      	uxth	r3, r3
 801f9fa:	4413      	add	r3, r2
 801f9fc:	b29b      	uxth	r3, r3
 801f9fe:	b21b      	sxth	r3, r3
 801fa00:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
 801fa04:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 801fa08:	b29a      	uxth	r2, r3
 801fa0a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801fa0c:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 801fa10:	b29b      	uxth	r3, r3
 801fa12:	4413      	add	r3, r2
 801fa14:	b29b      	uxth	r3, r3
 801fa16:	b21b      	sxth	r3, r3
 801fa18:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
 801fa1c:	f9b7 2052 	ldrsh.w	r2, [r7, #82]	; 0x52
 801fa20:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 801fa24:	429a      	cmp	r2, r3
 801fa26:	dba5      	blt.n	801f974 <lv_img_design+0x12a>
        if(ext->src_type == LV_IMG_SRC_FILE || ext->src_type == LV_IMG_SRC_VARIABLE) {
 801fa28:	e034      	b.n	801fa94 <lv_img_design+0x24a>
                }
            }
        } else if(ext->src_type == LV_IMG_SRC_SYMBOL) {
 801fa2a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801fa2c:	7b1b      	ldrb	r3, [r3, #12]
 801fa2e:	f003 0303 	and.w	r3, r3, #3
 801fa32:	b2db      	uxtb	r3, r3
 801fa34:	2b02      	cmp	r3, #2
 801fa36:	d122      	bne.n	801fa7e <lv_img_design+0x234>
            LV_LOG_TRACE("lv_img_design: start to draw symbol");
            lv_style_t style_mod;
            lv_style_copy(&style_mod, style);
 801fa38:	f107 0314 	add.w	r3, r7, #20
 801fa3c:	6eb9      	ldr	r1, [r7, #104]	; 0x68
 801fa3e:	4618      	mov	r0, r3
 801fa40:	f7f5 fc9c 	bl	801537c <lv_style_copy>
            style_mod.text.color = style->image.color;
 801fa44:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801fa46:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 801fa48:	86bb      	strh	r3, [r7, #52]	; 0x34
            lv_draw_label(&coords, mask, &style_mod, opa_scale, ext->src, LV_TXT_FLAG_NONE, NULL, -1, -1, NULL);
 801fa4a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 801fa4c:	681b      	ldr	r3, [r3, #0]
 801fa4e:	f897 1063 	ldrb.w	r1, [r7, #99]	; 0x63
 801fa52:	f107 0214 	add.w	r2, r7, #20
 801fa56:	f107 0058 	add.w	r0, r7, #88	; 0x58
 801fa5a:	2400      	movs	r4, #0
 801fa5c:	9405      	str	r4, [sp, #20]
 801fa5e:	f64f 74ff 	movw	r4, #65535	; 0xffff
 801fa62:	9404      	str	r4, [sp, #16]
 801fa64:	f64f 74ff 	movw	r4, #65535	; 0xffff
 801fa68:	9403      	str	r4, [sp, #12]
 801fa6a:	2400      	movs	r4, #0
 801fa6c:	9402      	str	r4, [sp, #8]
 801fa6e:	2400      	movs	r4, #0
 801fa70:	9401      	str	r4, [sp, #4]
 801fa72:	9300      	str	r3, [sp, #0]
 801fa74:	460b      	mov	r3, r1
 801fa76:	68b9      	ldr	r1, [r7, #8]
 801fa78:	f7f7 fb76 	bl	8017168 <lv_draw_label>
 801fa7c:	e00a      	b.n	801fa94 <lv_img_design+0x24a>
        } else {
            /*Trigger the error handler of image drawer*/
            LV_LOG_WARN("lv_img_design: image source type is unknown");
            lv_draw_img(&img->coords, mask, NULL, style, opa_scale);
 801fa7e:	68fb      	ldr	r3, [r7, #12]
 801fa80:	f103 0010 	add.w	r0, r3, #16
 801fa84:	f897 3063 	ldrb.w	r3, [r7, #99]	; 0x63
 801fa88:	9300      	str	r3, [sp, #0]
 801fa8a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801fa8c:	2200      	movs	r2, #0
 801fa8e:	68b9      	ldr	r1, [r7, #8]
 801fa90:	f7f7 f8e8 	bl	8016c64 <lv_draw_img>
        }
    }

    return true;
 801fa94:	2301      	movs	r3, #1
}
 801fa96:	4618      	mov	r0, r3
 801fa98:	3774      	adds	r7, #116	; 0x74
 801fa9a:	46bd      	mov	sp, r7
 801fa9c:	bd90      	pop	{r4, r7, pc}
	...

0801faa0 <lv_img_signal>:
 * @param sign a signal type from lv_signal_t enum
 * @param param pointer to a signal specific variable
 * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted
 */
static lv_res_t lv_img_signal(lv_obj_t * img, lv_signal_t sign, void * param)
{
 801faa0:	b580      	push	{r7, lr}
 801faa2:	b088      	sub	sp, #32
 801faa4:	af00      	add	r7, sp, #0
 801faa6:	60f8      	str	r0, [r7, #12]
 801faa8:	460b      	mov	r3, r1
 801faaa:	607a      	str	r2, [r7, #4]
 801faac:	72fb      	strb	r3, [r7, #11]
    lv_res_t res;

    /* Include the ancient signal function */
    res = ancestor_signal(img, sign, param);
 801faae:	4b30      	ldr	r3, [pc, #192]	; (801fb70 <lv_img_signal+0xd0>)
 801fab0:	681b      	ldr	r3, [r3, #0]
 801fab2:	7af9      	ldrb	r1, [r7, #11]
 801fab4:	687a      	ldr	r2, [r7, #4]
 801fab6:	68f8      	ldr	r0, [r7, #12]
 801fab8:	4798      	blx	r3
 801faba:	4603      	mov	r3, r0
 801fabc:	77bb      	strb	r3, [r7, #30]
    if(res != LV_RES_OK) return res;
 801fabe:	7fbb      	ldrb	r3, [r7, #30]
 801fac0:	2b01      	cmp	r3, #1
 801fac2:	d001      	beq.n	801fac8 <lv_img_signal+0x28>
 801fac4:	7fbb      	ldrb	r3, [r7, #30]
 801fac6:	e04f      	b.n	801fb68 <lv_img_signal+0xc8>

    lv_img_ext_t * ext = lv_obj_get_ext_attr(img);
 801fac8:	68f8      	ldr	r0, [r7, #12]
 801faca:	f7f4 fa74 	bl	8013fb6 <lv_obj_get_ext_attr>
 801face:	61b8      	str	r0, [r7, #24]
    if(sign == LV_SIGNAL_CLEANUP) {
 801fad0:	7afb      	ldrb	r3, [r7, #11]
 801fad2:	2b00      	cmp	r3, #0
 801fad4:	d11b      	bne.n	801fb0e <lv_img_signal+0x6e>
        if(ext->src_type == LV_IMG_SRC_FILE || ext->src_type == LV_IMG_SRC_SYMBOL) {
 801fad6:	69bb      	ldr	r3, [r7, #24]
 801fad8:	7b1b      	ldrb	r3, [r3, #12]
 801fada:	f003 0303 	and.w	r3, r3, #3
 801fade:	b2db      	uxtb	r3, r3
 801fae0:	2b01      	cmp	r3, #1
 801fae2:	d006      	beq.n	801faf2 <lv_img_signal+0x52>
 801fae4:	69bb      	ldr	r3, [r7, #24]
 801fae6:	7b1b      	ldrb	r3, [r3, #12]
 801fae8:	f003 0303 	and.w	r3, r3, #3
 801faec:	b2db      	uxtb	r3, r3
 801faee:	2b02      	cmp	r3, #2
 801faf0:	d139      	bne.n	801fb66 <lv_img_signal+0xc6>
            lv_mem_free(ext->src);
 801faf2:	69bb      	ldr	r3, [r7, #24]
 801faf4:	681b      	ldr	r3, [r3, #0]
 801faf6:	4618      	mov	r0, r3
 801faf8:	f7fe fb1a 	bl	801e130 <lv_mem_free>
            ext->src      = NULL;
 801fafc:	69bb      	ldr	r3, [r7, #24]
 801fafe:	2200      	movs	r2, #0
 801fb00:	601a      	str	r2, [r3, #0]
            ext->src_type = LV_IMG_SRC_UNKNOWN;
 801fb02:	69ba      	ldr	r2, [r7, #24]
 801fb04:	7b13      	ldrb	r3, [r2, #12]
 801fb06:	f043 0303 	orr.w	r3, r3, #3
 801fb0a:	7313      	strb	r3, [r2, #12]
 801fb0c:	e02b      	b.n	801fb66 <lv_img_signal+0xc6>
        }
    } else if(sign == LV_SIGNAL_STYLE_CHG) {
 801fb0e:	7afb      	ldrb	r3, [r7, #11]
 801fb10:	2b04      	cmp	r3, #4
 801fb12:	d10d      	bne.n	801fb30 <lv_img_signal+0x90>
        /*Refresh the file name to refresh the symbol text size*/
        if(ext->src_type == LV_IMG_SRC_SYMBOL) {
 801fb14:	69bb      	ldr	r3, [r7, #24]
 801fb16:	7b1b      	ldrb	r3, [r3, #12]
 801fb18:	f003 0303 	and.w	r3, r3, #3
 801fb1c:	b2db      	uxtb	r3, r3
 801fb1e:	2b02      	cmp	r3, #2
 801fb20:	d121      	bne.n	801fb66 <lv_img_signal+0xc6>
            lv_img_set_src(img, ext->src);
 801fb22:	69bb      	ldr	r3, [r7, #24]
 801fb24:	681b      	ldr	r3, [r3, #0]
 801fb26:	4619      	mov	r1, r3
 801fb28:	68f8      	ldr	r0, [r7, #12]
 801fb2a:	f7ff fd83 	bl	801f634 <lv_img_set_src>
 801fb2e:	e01a      	b.n	801fb66 <lv_img_signal+0xc6>
        }
    } else if(sign == LV_SIGNAL_GET_TYPE) {
 801fb30:	7afb      	ldrb	r3, [r7, #11]
 801fb32:	2b06      	cmp	r3, #6
 801fb34:	d117      	bne.n	801fb66 <lv_img_signal+0xc6>
        lv_obj_type_t * buf = param;
 801fb36:	687b      	ldr	r3, [r7, #4]
 801fb38:	617b      	str	r3, [r7, #20]
        uint8_t i;
        for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
 801fb3a:	2300      	movs	r3, #0
 801fb3c:	77fb      	strb	r3, [r7, #31]
 801fb3e:	e008      	b.n	801fb52 <lv_img_signal+0xb2>
            if(buf->type[i] == NULL) break;
 801fb40:	7ffa      	ldrb	r2, [r7, #31]
 801fb42:	697b      	ldr	r3, [r7, #20]
 801fb44:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801fb48:	2b00      	cmp	r3, #0
 801fb4a:	d006      	beq.n	801fb5a <lv_img_signal+0xba>
        for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
 801fb4c:	7ffb      	ldrb	r3, [r7, #31]
 801fb4e:	3301      	adds	r3, #1
 801fb50:	77fb      	strb	r3, [r7, #31]
 801fb52:	7ffb      	ldrb	r3, [r7, #31]
 801fb54:	2b06      	cmp	r3, #6
 801fb56:	d9f3      	bls.n	801fb40 <lv_img_signal+0xa0>
 801fb58:	e000      	b.n	801fb5c <lv_img_signal+0xbc>
            if(buf->type[i] == NULL) break;
 801fb5a:	bf00      	nop
        }
        buf->type[i] = "lv_img";
 801fb5c:	7ffa      	ldrb	r2, [r7, #31]
 801fb5e:	697b      	ldr	r3, [r7, #20]
 801fb60:	4904      	ldr	r1, [pc, #16]	; (801fb74 <lv_img_signal+0xd4>)
 801fb62:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    }

    return res;
 801fb66:	7fbb      	ldrb	r3, [r7, #30]
}
 801fb68:	4618      	mov	r0, r3
 801fb6a:	3720      	adds	r7, #32
 801fb6c:	46bd      	mov	sp, r7
 801fb6e:	bd80      	pop	{r7, pc}
 801fb70:	24062408 	.word	0x24062408
 801fb74:	08022910 	.word	0x08022910

0801fb78 <lv_font_get_line_height>:
 * Get the line height of a font. All characters fit into this height
 * @param font_p pointer to a font
 * @return the height of a font
 */
static inline uint8_t lv_font_get_line_height(const lv_font_t * font_p)
{
 801fb78:	b480      	push	{r7}
 801fb7a:	b083      	sub	sp, #12
 801fb7c:	af00      	add	r7, sp, #0
 801fb7e:	6078      	str	r0, [r7, #4]
    return font_p->line_height;
 801fb80:	687b      	ldr	r3, [r7, #4]
 801fb82:	7a1b      	ldrb	r3, [r3, #8]
}
 801fb84:	4618      	mov	r0, r3
 801fb86:	370c      	adds	r7, #12
 801fb88:	46bd      	mov	sp, r7
 801fb8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fb8e:	4770      	bx	lr

0801fb90 <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
 801fb90:	b480      	push	{r7}
 801fb92:	b083      	sub	sp, #12
 801fb94:	af00      	add	r7, sp, #0
 801fb96:	6078      	str	r0, [r7, #4]
    return area_p->x2 - area_p->x1 + 1;
 801fb98:	687b      	ldr	r3, [r7, #4]
 801fb9a:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801fb9e:	b29a      	uxth	r2, r3
 801fba0:	687b      	ldr	r3, [r7, #4]
 801fba2:	f9b3 3000 	ldrsh.w	r3, [r3]
 801fba6:	b29b      	uxth	r3, r3
 801fba8:	1ad3      	subs	r3, r2, r3
 801fbaa:	b29b      	uxth	r3, r3
 801fbac:	3301      	adds	r3, #1
 801fbae:	b29b      	uxth	r3, r3
 801fbb0:	b21b      	sxth	r3, r3
}
 801fbb2:	4618      	mov	r0, r3
 801fbb4:	370c      	adds	r7, #12
 801fbb6:	46bd      	mov	sp, r7
 801fbb8:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fbbc:	4770      	bx	lr

0801fbbe <lv_area_get_height>:
 * Get the height of an area
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
 801fbbe:	b480      	push	{r7}
 801fbc0:	b083      	sub	sp, #12
 801fbc2:	af00      	add	r7, sp, #0
 801fbc4:	6078      	str	r0, [r7, #4]
    return area_p->y2 - area_p->y1 + 1;
 801fbc6:	687b      	ldr	r3, [r7, #4]
 801fbc8:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801fbcc:	b29a      	uxth	r2, r3
 801fbce:	687b      	ldr	r3, [r7, #4]
 801fbd0:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801fbd4:	b29b      	uxth	r3, r3
 801fbd6:	1ad3      	subs	r3, r2, r3
 801fbd8:	b29b      	uxth	r3, r3
 801fbda:	3301      	adds	r3, #1
 801fbdc:	b29b      	uxth	r3, r3
 801fbde:	b21b      	sxth	r3, r3
}
 801fbe0:	4618      	mov	r0, r3
 801fbe2:	370c      	adds	r7, #12
 801fbe4:	46bd      	mov	sp, r7
 801fbe6:	f85d 7b04 	ldr.w	r7, [sp], #4
 801fbea:	4770      	bx	lr

0801fbec <lv_label_set_style>:
{
 801fbec:	b580      	push	{r7, lr}
 801fbee:	b084      	sub	sp, #16
 801fbf0:	af00      	add	r7, sp, #0
 801fbf2:	60f8      	str	r0, [r7, #12]
 801fbf4:	460b      	mov	r3, r1
 801fbf6:	607a      	str	r2, [r7, #4]
 801fbf8:	72fb      	strb	r3, [r7, #11]
    lv_obj_set_style(label, style);
 801fbfa:	6879      	ldr	r1, [r7, #4]
 801fbfc:	68f8      	ldr	r0, [r7, #12]
 801fbfe:	f7f3 ff0c 	bl	8013a1a <lv_obj_set_style>
}
 801fc02:	bf00      	nop
 801fc04:	3710      	adds	r7, #16
 801fc06:	46bd      	mov	sp, r7
 801fc08:	bd80      	pop	{r7, pc}

0801fc0a <lv_label_get_style>:
 * @param label pointer to an label object
 * @param type which style should be get (can be only `LV_LABEL_STYLE_MAIN`)
 * @return pointer to the label's style
 */
static inline const lv_style_t * lv_label_get_style(const lv_obj_t * label, lv_label_style_t type)
{
 801fc0a:	b580      	push	{r7, lr}
 801fc0c:	b082      	sub	sp, #8
 801fc0e:	af00      	add	r7, sp, #0
 801fc10:	6078      	str	r0, [r7, #4]
 801fc12:	460b      	mov	r3, r1
 801fc14:	70fb      	strb	r3, [r7, #3]
    (void)type; /*Unused*/
    return lv_obj_get_style(label);
 801fc16:	6878      	ldr	r0, [r7, #4]
 801fc18:	f7f4 f912 	bl	8013e40 <lv_obj_get_style>
 801fc1c:	4603      	mov	r3, r0
}
 801fc1e:	4618      	mov	r0, r3
 801fc20:	3708      	adds	r7, #8
 801fc22:	46bd      	mov	sp, r7
 801fc24:	bd80      	pop	{r7, pc}
	...

0801fc28 <lv_label_create>:
 * @param par pointer to an object, it will be the parent of the new label
 * @param copy pointer to a button object, if not NULL then the new object will be copied from it
 * @return pointer to the created button
 */
lv_obj_t * lv_label_create(lv_obj_t * par, const lv_obj_t * copy)
{
 801fc28:	b5b0      	push	{r4, r5, r7, lr}
 801fc2a:	b086      	sub	sp, #24
 801fc2c:	af00      	add	r7, sp, #0
 801fc2e:	6078      	str	r0, [r7, #4]
 801fc30:	6039      	str	r1, [r7, #0]
    LV_LOG_TRACE("label create started");

    /*Create a basic object*/
    lv_obj_t * new_label = lv_obj_create(par, copy);
 801fc32:	6839      	ldr	r1, [r7, #0]
 801fc34:	6878      	ldr	r0, [r7, #4]
 801fc36:	f7f2 fda3 	bl	8012780 <lv_obj_create>
 801fc3a:	6178      	str	r0, [r7, #20]
    lv_mem_assert(new_label);
 801fc3c:	697b      	ldr	r3, [r7, #20]
 801fc3e:	2b00      	cmp	r3, #0
 801fc40:	d100      	bne.n	801fc44 <lv_label_create+0x1c>
 801fc42:	e7fe      	b.n	801fc42 <lv_label_create+0x1a>
    if(new_label == NULL) return NULL;
 801fc44:	697b      	ldr	r3, [r7, #20]
 801fc46:	2b00      	cmp	r3, #0
 801fc48:	d101      	bne.n	801fc4e <lv_label_create+0x26>
 801fc4a:	2300      	movs	r3, #0
 801fc4c:	e111      	b.n	801fe72 <lv_label_create+0x24a>

    if(ancestor_signal == NULL) ancestor_signal = lv_obj_get_signal_cb(new_label);
 801fc4e:	4b8b      	ldr	r3, [pc, #556]	; (801fe7c <lv_label_create+0x254>)
 801fc50:	681b      	ldr	r3, [r3, #0]
 801fc52:	2b00      	cmp	r3, #0
 801fc54:	d105      	bne.n	801fc62 <lv_label_create+0x3a>
 801fc56:	6978      	ldr	r0, [r7, #20]
 801fc58:	f7f4 f995 	bl	8013f86 <lv_obj_get_signal_cb>
 801fc5c:	4603      	mov	r3, r0
 801fc5e:	4a87      	ldr	r2, [pc, #540]	; (801fe7c <lv_label_create+0x254>)
 801fc60:	6013      	str	r3, [r2, #0]

    /*Extend the basic object to a label object*/
    lv_obj_allocate_ext_attr(new_label, sizeof(lv_label_ext_t));
 801fc62:	2120      	movs	r1, #32
 801fc64:	6978      	ldr	r0, [r7, #20]
 801fc66:	f7f3 ffed 	bl	8013c44 <lv_obj_allocate_ext_attr>

    lv_label_ext_t * ext = lv_obj_get_ext_attr(new_label);
 801fc6a:	6978      	ldr	r0, [r7, #20]
 801fc6c:	f7f4 f9a3 	bl	8013fb6 <lv_obj_get_ext_attr>
 801fc70:	6138      	str	r0, [r7, #16]
    lv_mem_assert(ext);
 801fc72:	693b      	ldr	r3, [r7, #16]
 801fc74:	2b00      	cmp	r3, #0
 801fc76:	d100      	bne.n	801fc7a <lv_label_create+0x52>
 801fc78:	e7fe      	b.n	801fc78 <lv_label_create+0x50>
    if(ext == NULL) return NULL;
 801fc7a:	693b      	ldr	r3, [r7, #16]
 801fc7c:	2b00      	cmp	r3, #0
 801fc7e:	d101      	bne.n	801fc84 <lv_label_create+0x5c>
 801fc80:	2300      	movs	r3, #0
 801fc82:	e0f6      	b.n	801fe72 <lv_label_create+0x24a>

    ext->text       = NULL;
 801fc84:	693b      	ldr	r3, [r7, #16]
 801fc86:	2200      	movs	r2, #0
 801fc88:	601a      	str	r2, [r3, #0]
    ext->static_txt = 0;
 801fc8a:	693a      	ldr	r2, [r7, #16]
 801fc8c:	7f93      	ldrb	r3, [r2, #30]
 801fc8e:	f36f 03c3 	bfc	r3, #3, #1
 801fc92:	7793      	strb	r3, [r2, #30]
    ext->recolor    = 0;
 801fc94:	693a      	ldr	r2, [r7, #16]
 801fc96:	7f93      	ldrb	r3, [r2, #30]
 801fc98:	f36f 1386 	bfc	r3, #6, #1
 801fc9c:	7793      	strb	r3, [r2, #30]
    ext->body_draw  = 0;
 801fc9e:	693a      	ldr	r2, [r7, #16]
 801fca0:	7fd3      	ldrb	r3, [r2, #31]
 801fca2:	f36f 0300 	bfc	r3, #0, #1
 801fca6:	77d3      	strb	r3, [r2, #31]
    ext->align      = LV_LABEL_ALIGN_LEFT;
 801fca8:	693a      	ldr	r2, [r7, #16]
 801fcaa:	7f93      	ldrb	r3, [r2, #30]
 801fcac:	f36f 1305 	bfc	r3, #4, #2
 801fcb0:	7793      	strb	r3, [r2, #30]
    ext->dot_end    = LV_LABEL_DOT_END_INV;
 801fcb2:	693b      	ldr	r3, [r7, #16]
 801fcb4:	f64f 72ff 	movw	r2, #65535	; 0xffff
 801fcb8:	811a      	strh	r2, [r3, #8]
    ext->long_mode  = LV_LABEL_LONG_EXPAND;
 801fcba:	693a      	ldr	r2, [r7, #16]
 801fcbc:	7f93      	ldrb	r3, [r2, #30]
 801fcbe:	f36f 0302 	bfc	r3, #0, #3
 801fcc2:	7793      	strb	r3, [r2, #30]
#if LV_USE_ANIMATION
    ext->anim_speed = LV_LABEL_DEF_SCROLL_SPEED;
 801fcc4:	693b      	ldr	r3, [r7, #16]
 801fcc6:	2219      	movs	r2, #25
 801fcc8:	839a      	strh	r2, [r3, #28]
#endif
    ext->offset.x = 0;
 801fcca:	693b      	ldr	r3, [r7, #16]
 801fccc:	2200      	movs	r2, #0
 801fcce:	815a      	strh	r2, [r3, #10]
    ext->offset.y = 0;
 801fcd0:	693b      	ldr	r3, [r7, #16]
 801fcd2:	2200      	movs	r2, #0
 801fcd4:	819a      	strh	r2, [r3, #12]

#if LV_LABEL_LONG_TXT_HINT
    ext->hint.line_start = -1;
 801fcd6:	693b      	ldr	r3, [r7, #16]
 801fcd8:	f04f 32ff 	mov.w	r2, #4294967295
 801fcdc:	611a      	str	r2, [r3, #16]
    ext->hint.coord_y    = 0;
 801fcde:	693b      	ldr	r3, [r7, #16]
 801fce0:	2200      	movs	r2, #0
 801fce2:	619a      	str	r2, [r3, #24]
    ext->hint.y          = 0;
 801fce4:	693b      	ldr	r3, [r7, #16]
 801fce6:	2200      	movs	r2, #0
 801fce8:	615a      	str	r2, [r3, #20]

#if LV_LABEL_TEXT_SEL
    ext->txt_sel_start = LV_LABEL_TEXT_SEL_OFF;
    ext->txt_sel_end   = LV_LABEL_TEXT_SEL_OFF;
#endif
    ext->dot.tmp_ptr   = NULL;
 801fcea:	693b      	ldr	r3, [r7, #16]
 801fcec:	2200      	movs	r2, #0
 801fcee:	605a      	str	r2, [r3, #4]
    ext->dot_tmp_alloc = 0;
 801fcf0:	693a      	ldr	r2, [r7, #16]
 801fcf2:	7fd3      	ldrb	r3, [r2, #31]
 801fcf4:	f36f 0341 	bfc	r3, #1, #1
 801fcf8:	77d3      	strb	r3, [r2, #31]

    lv_obj_set_design_cb(new_label, lv_label_design);
 801fcfa:	4961      	ldr	r1, [pc, #388]	; (801fe80 <lv_label_create+0x258>)
 801fcfc:	6978      	ldr	r0, [r7, #20]
 801fcfe:	f7f3 ff93 	bl	8013c28 <lv_obj_set_design_cb>
    lv_obj_set_signal_cb(new_label, lv_label_signal);
 801fd02:	4960      	ldr	r1, [pc, #384]	; (801fe84 <lv_label_create+0x25c>)
 801fd04:	6978      	ldr	r0, [r7, #20]
 801fd06:	f7f3 ff81 	bl	8013c0c <lv_obj_set_signal_cb>

    /*Init the new label*/
    if(copy == NULL) {
 801fd0a:	683b      	ldr	r3, [r7, #0]
 801fd0c:	2b00      	cmp	r3, #0
 801fd0e:	d111      	bne.n	801fd34 <lv_label_create+0x10c>
        lv_obj_set_click(new_label, false);
 801fd10:	2100      	movs	r1, #0
 801fd12:	6978      	ldr	r0, [r7, #20]
 801fd14:	f7f3 fee1 	bl	8013ada <lv_obj_set_click>
        lv_label_set_long_mode(new_label, LV_LABEL_LONG_EXPAND);
 801fd18:	2100      	movs	r1, #0
 801fd1a:	6978      	ldr	r0, [r7, #20]
 801fd1c:	f000 f952 	bl	801ffc4 <lv_label_set_long_mode>
        lv_label_set_text(new_label, "Text");
 801fd20:	4959      	ldr	r1, [pc, #356]	; (801fe88 <lv_label_create+0x260>)
 801fd22:	6978      	ldr	r0, [r7, #20]
 801fd24:	f000 f8b2 	bl	801fe8c <lv_label_set_text>
        lv_label_set_style(new_label, LV_LABEL_STYLE_MAIN, NULL); /*Inherit parent's style*/
 801fd28:	2200      	movs	r2, #0
 801fd2a:	2100      	movs	r1, #0
 801fd2c:	6978      	ldr	r0, [r7, #20]
 801fd2e:	f7ff ff5d 	bl	801fbec <lv_label_set_style>
 801fd32:	e09d      	b.n	801fe70 <lv_label_create+0x248>
    }
    /*Copy 'copy' if not NULL*/
    else {
        lv_label_ext_t * copy_ext = lv_obj_get_ext_attr(copy);
 801fd34:	6838      	ldr	r0, [r7, #0]
 801fd36:	f7f4 f93e 	bl	8013fb6 <lv_obj_get_ext_attr>
 801fd3a:	60f8      	str	r0, [r7, #12]
        lv_label_set_long_mode(new_label, lv_label_get_long_mode(copy));
 801fd3c:	6838      	ldr	r0, [r7, #0]
 801fd3e:	f000 fa22 	bl	8020186 <lv_label_get_long_mode>
 801fd42:	4603      	mov	r3, r0
 801fd44:	4619      	mov	r1, r3
 801fd46:	6978      	ldr	r0, [r7, #20]
 801fd48:	f000 f93c 	bl	801ffc4 <lv_label_set_long_mode>
        lv_label_set_recolor(new_label, lv_label_get_recolor(copy));
 801fd4c:	6838      	ldr	r0, [r7, #0]
 801fd4e:	f000 fa3c 	bl	80201ca <lv_label_get_recolor>
 801fd52:	4603      	mov	r3, r0
 801fd54:	4619      	mov	r1, r3
 801fd56:	6978      	ldr	r0, [r7, #20]
 801fd58:	f000 f9b4 	bl	80200c4 <lv_label_set_recolor>
        lv_label_set_body_draw(new_label, lv_label_get_body_draw(copy));
 801fd5c:	6838      	ldr	r0, [r7, #0]
 801fd5e:	f000 fa4a 	bl	80201f6 <lv_label_get_body_draw>
 801fd62:	4603      	mov	r3, r0
 801fd64:	4619      	mov	r1, r3
 801fd66:	6978      	ldr	r0, [r7, #20]
 801fd68:	f000 f9d4 	bl	8020114 <lv_label_set_body_draw>
        lv_label_set_align(new_label, lv_label_get_align(copy));
 801fd6c:	6838      	ldr	r0, [r7, #0]
 801fd6e:	f000 fa1b 	bl	80201a8 <lv_label_get_align>
 801fd72:	4603      	mov	r3, r0
 801fd74:	4619      	mov	r1, r3
 801fd76:	6978      	ldr	r0, [r7, #20]
 801fd78:	f000 f980 	bl	802007c <lv_label_set_align>
        if(copy_ext->static_txt == 0)
 801fd7c:	68fb      	ldr	r3, [r7, #12]
 801fd7e:	7f9b      	ldrb	r3, [r3, #30]
 801fd80:	f003 0308 	and.w	r3, r3, #8
 801fd84:	b2db      	uxtb	r3, r3
 801fd86:	2b00      	cmp	r3, #0
 801fd88:	d108      	bne.n	801fd9c <lv_label_create+0x174>
            lv_label_set_text(new_label, lv_label_get_text(copy));
 801fd8a:	6838      	ldr	r0, [r7, #0]
 801fd8c:	f000 f9ed 	bl	802016a <lv_label_get_text>
 801fd90:	4603      	mov	r3, r0
 801fd92:	4619      	mov	r1, r3
 801fd94:	6978      	ldr	r0, [r7, #20]
 801fd96:	f000 f879 	bl	801fe8c <lv_label_set_text>
 801fd9a:	e007      	b.n	801fdac <lv_label_create+0x184>
        else
            lv_label_set_static_text(new_label, lv_label_get_text(copy));
 801fd9c:	6838      	ldr	r0, [r7, #0]
 801fd9e:	f000 f9e4 	bl	802016a <lv_label_get_text>
 801fda2:	4603      	mov	r3, r0
 801fda4:	4619      	mov	r1, r3
 801fda6:	6978      	ldr	r0, [r7, #20]
 801fda8:	f000 f8dd 	bl	801ff66 <lv_label_set_static_text>

        /*In DOT mode save the text byte-to-byte because a '\0' can be in the middle*/
        if(copy_ext->long_mode == LV_LABEL_LONG_DOT) {
 801fdac:	68fb      	ldr	r3, [r7, #12]
 801fdae:	7f9b      	ldrb	r3, [r3, #30]
 801fdb0:	f003 0307 	and.w	r3, r3, #7
 801fdb4:	b2db      	uxtb	r3, r3
 801fdb6:	2b02      	cmp	r3, #2
 801fdb8:	d128      	bne.n	801fe0c <lv_label_create+0x1e4>
            ext->text = lv_mem_realloc(ext->text, lv_mem_get_size(copy_ext->text));
 801fdba:	693b      	ldr	r3, [r7, #16]
 801fdbc:	681c      	ldr	r4, [r3, #0]
 801fdbe:	68fb      	ldr	r3, [r7, #12]
 801fdc0:	681b      	ldr	r3, [r3, #0]
 801fdc2:	4618      	mov	r0, r3
 801fdc4:	f7fe fa1a 	bl	801e1fc <lv_mem_get_size>
 801fdc8:	4603      	mov	r3, r0
 801fdca:	4619      	mov	r1, r3
 801fdcc:	4620      	mov	r0, r4
 801fdce:	f7fe f9d7 	bl	801e180 <lv_mem_realloc>
 801fdd2:	4602      	mov	r2, r0
 801fdd4:	693b      	ldr	r3, [r7, #16]
 801fdd6:	601a      	str	r2, [r3, #0]
            lv_mem_assert(ext->text);
 801fdd8:	693b      	ldr	r3, [r7, #16]
 801fdda:	681b      	ldr	r3, [r3, #0]
 801fddc:	2b00      	cmp	r3, #0
 801fdde:	d100      	bne.n	801fde2 <lv_label_create+0x1ba>
 801fde0:	e7fe      	b.n	801fde0 <lv_label_create+0x1b8>
            if(ext->text == NULL) return NULL;
 801fde2:	693b      	ldr	r3, [r7, #16]
 801fde4:	681b      	ldr	r3, [r3, #0]
 801fde6:	2b00      	cmp	r3, #0
 801fde8:	d101      	bne.n	801fdee <lv_label_create+0x1c6>
 801fdea:	2300      	movs	r3, #0
 801fdec:	e041      	b.n	801fe72 <lv_label_create+0x24a>
            memcpy(ext->text, copy_ext->text, lv_mem_get_size(copy_ext->text));
 801fdee:	693b      	ldr	r3, [r7, #16]
 801fdf0:	681c      	ldr	r4, [r3, #0]
 801fdf2:	68fb      	ldr	r3, [r7, #12]
 801fdf4:	681d      	ldr	r5, [r3, #0]
 801fdf6:	68fb      	ldr	r3, [r7, #12]
 801fdf8:	681b      	ldr	r3, [r3, #0]
 801fdfa:	4618      	mov	r0, r3
 801fdfc:	f7fe f9fe 	bl	801e1fc <lv_mem_get_size>
 801fe00:	4603      	mov	r3, r0
 801fe02:	461a      	mov	r2, r3
 801fe04:	4629      	mov	r1, r5
 801fe06:	4620      	mov	r0, r4
 801fe08:	f001 ff26 	bl	8021c58 <memcpy>
        }

        if(copy_ext->dot_tmp_alloc && copy_ext->dot.tmp_ptr) {
 801fe0c:	68fb      	ldr	r3, [r7, #12]
 801fe0e:	7fdb      	ldrb	r3, [r3, #31]
 801fe10:	f003 0302 	and.w	r3, r3, #2
 801fe14:	b2db      	uxtb	r3, r3
 801fe16:	2b00      	cmp	r3, #0
 801fe18:	d013      	beq.n	801fe42 <lv_label_create+0x21a>
 801fe1a:	68fb      	ldr	r3, [r7, #12]
 801fe1c:	685b      	ldr	r3, [r3, #4]
 801fe1e:	2b00      	cmp	r3, #0
 801fe20:	d00f      	beq.n	801fe42 <lv_label_create+0x21a>
            int len = strlen(copy_ext->dot.tmp_ptr);
 801fe22:	68fb      	ldr	r3, [r7, #12]
 801fe24:	685b      	ldr	r3, [r3, #4]
 801fe26:	4618      	mov	r0, r3
 801fe28:	f7e0 fa64 	bl	80002f4 <strlen>
 801fe2c:	4603      	mov	r3, r0
 801fe2e:	60bb      	str	r3, [r7, #8]
            lv_label_set_dot_tmp(new_label, ext->dot.tmp_ptr, len);
 801fe30:	693b      	ldr	r3, [r7, #16]
 801fe32:	685b      	ldr	r3, [r3, #4]
 801fe34:	68ba      	ldr	r2, [r7, #8]
 801fe36:	b292      	uxth	r2, r2
 801fe38:	4619      	mov	r1, r3
 801fe3a:	6978      	ldr	r0, [r7, #20]
 801fe3c:	f001 f8f2 	bl	8021024 <lv_label_set_dot_tmp>
        if(copy_ext->dot_tmp_alloc && copy_ext->dot.tmp_ptr) {
 801fe40:	e005      	b.n	801fe4e <lv_label_create+0x226>
        } else {
            memcpy(ext->dot.tmp, copy_ext->dot.tmp, sizeof(ext->dot.tmp));
 801fe42:	693b      	ldr	r3, [r7, #16]
 801fe44:	3304      	adds	r3, #4
 801fe46:	68fa      	ldr	r2, [r7, #12]
 801fe48:	3204      	adds	r2, #4
 801fe4a:	6812      	ldr	r2, [r2, #0]
 801fe4c:	601a      	str	r2, [r3, #0]
        }
        ext->dot_tmp_alloc = copy_ext->dot_tmp_alloc;
 801fe4e:	68fb      	ldr	r3, [r7, #12]
 801fe50:	7fdb      	ldrb	r3, [r3, #31]
 801fe52:	f3c3 0340 	ubfx	r3, r3, #1, #1
 801fe56:	b2d9      	uxtb	r1, r3
 801fe58:	693a      	ldr	r2, [r7, #16]
 801fe5a:	7fd3      	ldrb	r3, [r2, #31]
 801fe5c:	f361 0341 	bfi	r3, r1, #1, #1
 801fe60:	77d3      	strb	r3, [r2, #31]
        ext->dot_end       = copy_ext->dot_end;
 801fe62:	68fb      	ldr	r3, [r7, #12]
 801fe64:	891a      	ldrh	r2, [r3, #8]
 801fe66:	693b      	ldr	r3, [r7, #16]
 801fe68:	811a      	strh	r2, [r3, #8]

        /*Refresh the style with new signal function*/
        lv_obj_refresh_style(new_label);
 801fe6a:	6978      	ldr	r0, [r7, #20]
 801fe6c:	f7f3 fde7 	bl	8013a3e <lv_obj_refresh_style>
    }

    LV_LOG_INFO("label created");

    return new_label;
 801fe70:	697b      	ldr	r3, [r7, #20]
}
 801fe72:	4618      	mov	r0, r3
 801fe74:	3718      	adds	r7, #24
 801fe76:	46bd      	mov	sp, r7
 801fe78:	bdb0      	pop	{r4, r5, r7, pc}
 801fe7a:	bf00      	nop
 801fe7c:	2406240c 	.word	0x2406240c
 801fe80:	080204a9 	.word	0x080204a9
 801fe84:	08020855 	.word	0x08020855
 801fe88:	08022918 	.word	0x08022918

0801fe8c <lv_label_set_text>:
 * Set a new text for a label. Memory will be allocated to store the text by the label.
 * @param label pointer to a label object
 * @param text '\0' terminated character string. NULL to refresh with the current text.
 */
void lv_label_set_text(lv_obj_t * label, const char * text)
{
 801fe8c:	b590      	push	{r4, r7, lr}
 801fe8e:	b085      	sub	sp, #20
 801fe90:	af00      	add	r7, sp, #0
 801fe92:	6078      	str	r0, [r7, #4]
 801fe94:	6039      	str	r1, [r7, #0]
    lv_obj_invalidate(label);
 801fe96:	6878      	ldr	r0, [r7, #4]
 801fe98:	f7f2 fee8 	bl	8012c6c <lv_obj_invalidate>

    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 801fe9c:	6878      	ldr	r0, [r7, #4]
 801fe9e:	f7f4 f88a 	bl	8013fb6 <lv_obj_get_ext_attr>
 801fea2:	60f8      	str	r0, [r7, #12]

    /*If text is NULL then refresh */
    if(text == NULL) {
 801fea4:	683b      	ldr	r3, [r7, #0]
 801fea6:	2b00      	cmp	r3, #0
 801fea8:	d103      	bne.n	801feb2 <lv_label_set_text+0x26>
        lv_label_refr_text(label);
 801feaa:	6878      	ldr	r0, [r7, #4]
 801feac:	f000 fd92 	bl	80209d4 <lv_label_refr_text>
        return;
 801feb0:	e056      	b.n	801ff60 <lv_label_set_text+0xd4>
    }

    if(ext->text == text) {
 801feb2:	68fb      	ldr	r3, [r7, #12]
 801feb4:	681b      	ldr	r3, [r3, #0]
 801feb6:	683a      	ldr	r2, [r7, #0]
 801feb8:	429a      	cmp	r2, r3
 801feba:	d119      	bne.n	801fef0 <lv_label_set_text+0x64>
        /*If set its own text then reallocate it (maybe its size changed)*/
        ext->text = lv_mem_realloc(ext->text, strlen(ext->text) + 1);
 801febc:	68fb      	ldr	r3, [r7, #12]
 801febe:	681c      	ldr	r4, [r3, #0]
 801fec0:	68fb      	ldr	r3, [r7, #12]
 801fec2:	681b      	ldr	r3, [r3, #0]
 801fec4:	4618      	mov	r0, r3
 801fec6:	f7e0 fa15 	bl	80002f4 <strlen>
 801feca:	4603      	mov	r3, r0
 801fecc:	3301      	adds	r3, #1
 801fece:	4619      	mov	r1, r3
 801fed0:	4620      	mov	r0, r4
 801fed2:	f7fe f955 	bl	801e180 <lv_mem_realloc>
 801fed6:	4602      	mov	r2, r0
 801fed8:	68fb      	ldr	r3, [r7, #12]
 801feda:	601a      	str	r2, [r3, #0]
        lv_mem_assert(ext->text);
 801fedc:	68fb      	ldr	r3, [r7, #12]
 801fede:	681b      	ldr	r3, [r3, #0]
 801fee0:	2b00      	cmp	r3, #0
 801fee2:	d100      	bne.n	801fee6 <lv_label_set_text+0x5a>
 801fee4:	e7fe      	b.n	801fee4 <lv_label_set_text+0x58>
        if(ext->text == NULL) return;
 801fee6:	68fb      	ldr	r3, [r7, #12]
 801fee8:	681b      	ldr	r3, [r3, #0]
 801feea:	2b00      	cmp	r3, #0
 801feec:	d133      	bne.n	801ff56 <lv_label_set_text+0xca>
 801feee:	e037      	b.n	801ff60 <lv_label_set_text+0xd4>
    } else {
        /*Allocate space for the new text*/
        uint32_t len = strlen(text) + 1;
 801fef0:	6838      	ldr	r0, [r7, #0]
 801fef2:	f7e0 f9ff 	bl	80002f4 <strlen>
 801fef6:	4603      	mov	r3, r0
 801fef8:	3301      	adds	r3, #1
 801fefa:	60bb      	str	r3, [r7, #8]
        if(ext->text != NULL && ext->static_txt == 0) {
 801fefc:	68fb      	ldr	r3, [r7, #12]
 801fefe:	681b      	ldr	r3, [r3, #0]
 801ff00:	2b00      	cmp	r3, #0
 801ff02:	d00e      	beq.n	801ff22 <lv_label_set_text+0x96>
 801ff04:	68fb      	ldr	r3, [r7, #12]
 801ff06:	7f9b      	ldrb	r3, [r3, #30]
 801ff08:	f003 0308 	and.w	r3, r3, #8
 801ff0c:	b2db      	uxtb	r3, r3
 801ff0e:	2b00      	cmp	r3, #0
 801ff10:	d107      	bne.n	801ff22 <lv_label_set_text+0x96>
            lv_mem_free(ext->text);
 801ff12:	68fb      	ldr	r3, [r7, #12]
 801ff14:	681b      	ldr	r3, [r3, #0]
 801ff16:	4618      	mov	r0, r3
 801ff18:	f7fe f90a 	bl	801e130 <lv_mem_free>
            ext->text = NULL;
 801ff1c:	68fb      	ldr	r3, [r7, #12]
 801ff1e:	2200      	movs	r2, #0
 801ff20:	601a      	str	r2, [r3, #0]
        }

        ext->text = lv_mem_alloc(len);
 801ff22:	68b8      	ldr	r0, [r7, #8]
 801ff24:	f7fe f8c4 	bl	801e0b0 <lv_mem_alloc>
 801ff28:	4602      	mov	r2, r0
 801ff2a:	68fb      	ldr	r3, [r7, #12]
 801ff2c:	601a      	str	r2, [r3, #0]
        lv_mem_assert(ext->text);
 801ff2e:	68fb      	ldr	r3, [r7, #12]
 801ff30:	681b      	ldr	r3, [r3, #0]
 801ff32:	2b00      	cmp	r3, #0
 801ff34:	d100      	bne.n	801ff38 <lv_label_set_text+0xac>
 801ff36:	e7fe      	b.n	801ff36 <lv_label_set_text+0xaa>
        if(ext->text == NULL) return;
 801ff38:	68fb      	ldr	r3, [r7, #12]
 801ff3a:	681b      	ldr	r3, [r3, #0]
 801ff3c:	2b00      	cmp	r3, #0
 801ff3e:	d00e      	beq.n	801ff5e <lv_label_set_text+0xd2>

        strcpy(ext->text, text);
 801ff40:	68fb      	ldr	r3, [r7, #12]
 801ff42:	681b      	ldr	r3, [r3, #0]
 801ff44:	6839      	ldr	r1, [r7, #0]
 801ff46:	4618      	mov	r0, r3
 801ff48:	f001 ff90 	bl	8021e6c <strcpy>
        ext->static_txt = 0; /*Now the text is dynamically allocated*/
 801ff4c:	68fa      	ldr	r2, [r7, #12]
 801ff4e:	7f93      	ldrb	r3, [r2, #30]
 801ff50:	f36f 03c3 	bfc	r3, #3, #1
 801ff54:	7793      	strb	r3, [r2, #30]
    }

    lv_label_refr_text(label);
 801ff56:	6878      	ldr	r0, [r7, #4]
 801ff58:	f000 fd3c 	bl	80209d4 <lv_label_refr_text>
 801ff5c:	e000      	b.n	801ff60 <lv_label_set_text+0xd4>
        if(ext->text == NULL) return;
 801ff5e:	bf00      	nop
}
 801ff60:	3714      	adds	r7, #20
 801ff62:	46bd      	mov	sp, r7
 801ff64:	bd90      	pop	{r4, r7, pc}

0801ff66 <lv_label_set_static_text>:
 * has to be 'alive' while the label exist.
 * @param label pointer to a label object
 * @param text pointer to a text. NULL to refresh with the current text.
 */
void lv_label_set_static_text(lv_obj_t * label, const char * text)
{
 801ff66:	b580      	push	{r7, lr}
 801ff68:	b084      	sub	sp, #16
 801ff6a:	af00      	add	r7, sp, #0
 801ff6c:	6078      	str	r0, [r7, #4]
 801ff6e:	6039      	str	r1, [r7, #0]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 801ff70:	6878      	ldr	r0, [r7, #4]
 801ff72:	f7f4 f820 	bl	8013fb6 <lv_obj_get_ext_attr>
 801ff76:	60f8      	str	r0, [r7, #12]
    if(ext->static_txt == 0 && ext->text != NULL) {
 801ff78:	68fb      	ldr	r3, [r7, #12]
 801ff7a:	7f9b      	ldrb	r3, [r3, #30]
 801ff7c:	f003 0308 	and.w	r3, r3, #8
 801ff80:	b2db      	uxtb	r3, r3
 801ff82:	2b00      	cmp	r3, #0
 801ff84:	d10b      	bne.n	801ff9e <lv_label_set_static_text+0x38>
 801ff86:	68fb      	ldr	r3, [r7, #12]
 801ff88:	681b      	ldr	r3, [r3, #0]
 801ff8a:	2b00      	cmp	r3, #0
 801ff8c:	d007      	beq.n	801ff9e <lv_label_set_static_text+0x38>
        lv_mem_free(ext->text);
 801ff8e:	68fb      	ldr	r3, [r7, #12]
 801ff90:	681b      	ldr	r3, [r3, #0]
 801ff92:	4618      	mov	r0, r3
 801ff94:	f7fe f8cc 	bl	801e130 <lv_mem_free>
        ext->text = NULL;
 801ff98:	68fb      	ldr	r3, [r7, #12]
 801ff9a:	2200      	movs	r2, #0
 801ff9c:	601a      	str	r2, [r3, #0]
    }

    if(text != NULL) {
 801ff9e:	683b      	ldr	r3, [r7, #0]
 801ffa0:	2b00      	cmp	r3, #0
 801ffa2:	d007      	beq.n	801ffb4 <lv_label_set_static_text+0x4e>
        ext->static_txt = 1;
 801ffa4:	68fa      	ldr	r2, [r7, #12]
 801ffa6:	7f93      	ldrb	r3, [r2, #30]
 801ffa8:	f043 0308 	orr.w	r3, r3, #8
 801ffac:	7793      	strb	r3, [r2, #30]
        ext->text       = (char *)text;
 801ffae:	68fb      	ldr	r3, [r7, #12]
 801ffb0:	683a      	ldr	r2, [r7, #0]
 801ffb2:	601a      	str	r2, [r3, #0]
    }

    lv_label_refr_text(label);
 801ffb4:	6878      	ldr	r0, [r7, #4]
 801ffb6:	f000 fd0d 	bl	80209d4 <lv_label_refr_text>
}
 801ffba:	bf00      	nop
 801ffbc:	3710      	adds	r7, #16
 801ffbe:	46bd      	mov	sp, r7
 801ffc0:	bd80      	pop	{r7, pc}
	...

0801ffc4 <lv_label_set_long_mode>:
 * @param long_mode the new mode from 'lv_label_long_mode' enum.
 *                  In LV_LONG_BREAK/LONG/ROLL the size of the label should be set AFTER this
 * function
 */
void lv_label_set_long_mode(lv_obj_t * label, lv_label_long_mode_t long_mode)
{
 801ffc4:	b580      	push	{r7, lr}
 801ffc6:	b084      	sub	sp, #16
 801ffc8:	af00      	add	r7, sp, #0
 801ffca:	6078      	str	r0, [r7, #4]
 801ffcc:	460b      	mov	r3, r1
 801ffce:	70fb      	strb	r3, [r7, #3]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 801ffd0:	6878      	ldr	r0, [r7, #4]
 801ffd2:	f7f3 fff0 	bl	8013fb6 <lv_obj_get_ext_attr>
 801ffd6:	60f8      	str	r0, [r7, #12]

#if LV_USE_ANIMATION
    /*Delete the old animation (if exists)*/
    lv_anim_del(label, (lv_anim_exec_xcb_t)lv_obj_set_x);
 801ffd8:	4924      	ldr	r1, [pc, #144]	; (802006c <lv_label_set_long_mode+0xa8>)
 801ffda:	6878      	ldr	r0, [r7, #4]
 801ffdc:	f7fd fa0e 	bl	801d3fc <lv_anim_del>
    lv_anim_del(label, (lv_anim_exec_xcb_t)lv_obj_set_y);
 801ffe0:	4923      	ldr	r1, [pc, #140]	; (8020070 <lv_label_set_long_mode+0xac>)
 801ffe2:	6878      	ldr	r0, [r7, #4]
 801ffe4:	f7fd fa0a 	bl	801d3fc <lv_anim_del>
    lv_anim_del(label, (lv_anim_exec_xcb_t)lv_label_set_offset_x);
 801ffe8:	4922      	ldr	r1, [pc, #136]	; (8020074 <lv_label_set_long_mode+0xb0>)
 801ffea:	6878      	ldr	r0, [r7, #4]
 801ffec:	f7fd fa06 	bl	801d3fc <lv_anim_del>
    lv_anim_del(label, (lv_anim_exec_xcb_t)lv_label_set_offset_y);
 801fff0:	4921      	ldr	r1, [pc, #132]	; (8020078 <lv_label_set_long_mode+0xb4>)
 801fff2:	6878      	ldr	r0, [r7, #4]
 801fff4:	f7fd fa02 	bl	801d3fc <lv_anim_del>
#endif
    ext->offset.x = 0;
 801fff8:	68fb      	ldr	r3, [r7, #12]
 801fffa:	2200      	movs	r2, #0
 801fffc:	815a      	strh	r2, [r3, #10]
    ext->offset.y = 0;
 801fffe:	68fb      	ldr	r3, [r7, #12]
 8020000:	2200      	movs	r2, #0
 8020002:	819a      	strh	r2, [r3, #12]

    if(long_mode == LV_LABEL_LONG_SROLL || long_mode == LV_LABEL_LONG_SROLL_CIRC || long_mode == LV_LABEL_LONG_CROP)
 8020004:	78fb      	ldrb	r3, [r7, #3]
 8020006:	2b03      	cmp	r3, #3
 8020008:	d005      	beq.n	8020016 <lv_label_set_long_mode+0x52>
 802000a:	78fb      	ldrb	r3, [r7, #3]
 802000c:	2b04      	cmp	r3, #4
 802000e:	d002      	beq.n	8020016 <lv_label_set_long_mode+0x52>
 8020010:	78fb      	ldrb	r3, [r7, #3]
 8020012:	2b05      	cmp	r3, #5
 8020014:	d105      	bne.n	8020022 <lv_label_set_long_mode+0x5e>
        ext->expand = 1;
 8020016:	68fa      	ldr	r2, [r7, #12]
 8020018:	7f93      	ldrb	r3, [r2, #30]
 802001a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 802001e:	7793      	strb	r3, [r2, #30]
 8020020:	e004      	b.n	802002c <lv_label_set_long_mode+0x68>
    else
        ext->expand = 0;
 8020022:	68fa      	ldr	r2, [r7, #12]
 8020024:	7f93      	ldrb	r3, [r2, #30]
 8020026:	f36f 13c7 	bfc	r3, #7, #1
 802002a:	7793      	strb	r3, [r2, #30]

    /*Restore the character under the dots*/
    if(ext->long_mode == LV_LABEL_LONG_DOT && ext->dot_end != LV_LABEL_DOT_END_INV) {
 802002c:	68fb      	ldr	r3, [r7, #12]
 802002e:	7f9b      	ldrb	r3, [r3, #30]
 8020030:	f003 0307 	and.w	r3, r3, #7
 8020034:	b2db      	uxtb	r3, r3
 8020036:	2b02      	cmp	r3, #2
 8020038:	d108      	bne.n	802004c <lv_label_set_long_mode+0x88>
 802003a:	68fb      	ldr	r3, [r7, #12]
 802003c:	891b      	ldrh	r3, [r3, #8]
 802003e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8020042:	4293      	cmp	r3, r2
 8020044:	d002      	beq.n	802004c <lv_label_set_long_mode+0x88>
        lv_label_revert_dots(label);
 8020046:	6878      	ldr	r0, [r7, #4]
 8020048:	f000 ff6a 	bl	8020f20 <lv_label_revert_dots>
    }

    ext->long_mode = long_mode;
 802004c:	78fb      	ldrb	r3, [r7, #3]
 802004e:	f003 0307 	and.w	r3, r3, #7
 8020052:	b2d9      	uxtb	r1, r3
 8020054:	68fa      	ldr	r2, [r7, #12]
 8020056:	7f93      	ldrb	r3, [r2, #30]
 8020058:	f361 0302 	bfi	r3, r1, #0, #3
 802005c:	7793      	strb	r3, [r2, #30]
    lv_label_refr_text(label);
 802005e:	6878      	ldr	r0, [r7, #4]
 8020060:	f000 fcb8 	bl	80209d4 <lv_label_refr_text>
}
 8020064:	bf00      	nop
 8020066:	3710      	adds	r7, #16
 8020068:	46bd      	mov	sp, r7
 802006a:	bd80      	pop	{r7, pc}
 802006c:	08012ef5 	.word	0x08012ef5
 8020070:	08012f1f 	.word	0x08012f1f
 8020074:	08020fd5 	.word	0x08020fd5
 8020078:	08020ffd 	.word	0x08020ffd

0802007c <lv_label_set_align>:
 * Set the align of the label (left or center)
 * @param label pointer to a label object
 * @param align 'LV_LABEL_ALIGN_LEFT' or 'LV_LABEL_ALIGN_LEFT'
 */
void lv_label_set_align(lv_obj_t * label, lv_label_align_t align)
{
 802007c:	b580      	push	{r7, lr}
 802007e:	b084      	sub	sp, #16
 8020080:	af00      	add	r7, sp, #0
 8020082:	6078      	str	r0, [r7, #4]
 8020084:	460b      	mov	r3, r1
 8020086:	70fb      	strb	r3, [r7, #3]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 8020088:	6878      	ldr	r0, [r7, #4]
 802008a:	f7f3 ff94 	bl	8013fb6 <lv_obj_get_ext_attr>
 802008e:	60f8      	str	r0, [r7, #12]
    if(ext->align == align) return;
 8020090:	68fb      	ldr	r3, [r7, #12]
 8020092:	7f9b      	ldrb	r3, [r3, #30]
 8020094:	f3c3 1301 	ubfx	r3, r3, #4, #2
 8020098:	b2db      	uxtb	r3, r3
 802009a:	461a      	mov	r2, r3
 802009c:	78fb      	ldrb	r3, [r7, #3]
 802009e:	429a      	cmp	r2, r3
 80200a0:	d00c      	beq.n	80200bc <lv_label_set_align+0x40>

    ext->align = align;
 80200a2:	78fb      	ldrb	r3, [r7, #3]
 80200a4:	f003 0303 	and.w	r3, r3, #3
 80200a8:	b2d9      	uxtb	r1, r3
 80200aa:	68fa      	ldr	r2, [r7, #12]
 80200ac:	7f93      	ldrb	r3, [r2, #30]
 80200ae:	f361 1305 	bfi	r3, r1, #4, #2
 80200b2:	7793      	strb	r3, [r2, #30]

    lv_obj_invalidate(label); /*Enough to invalidate because alignment is only drawing related
 80200b4:	6878      	ldr	r0, [r7, #4]
 80200b6:	f7f2 fdd9 	bl	8012c6c <lv_obj_invalidate>
 80200ba:	e000      	b.n	80200be <lv_label_set_align+0x42>
    if(ext->align == align) return;
 80200bc:	bf00      	nop
                                 (lv_refr_label_text() not required)*/
}
 80200be:	3710      	adds	r7, #16
 80200c0:	46bd      	mov	sp, r7
 80200c2:	bd80      	pop	{r7, pc}

080200c4 <lv_label_set_recolor>:
 * Enable the recoloring by in-line commands
 * @param label pointer to a label object
 * @param en true: enable recoloring, false: disable
 */
void lv_label_set_recolor(lv_obj_t * label, bool en)
{
 80200c4:	b580      	push	{r7, lr}
 80200c6:	b084      	sub	sp, #16
 80200c8:	af00      	add	r7, sp, #0
 80200ca:	6078      	str	r0, [r7, #4]
 80200cc:	460b      	mov	r3, r1
 80200ce:	70fb      	strb	r3, [r7, #3]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 80200d0:	6878      	ldr	r0, [r7, #4]
 80200d2:	f7f3 ff70 	bl	8013fb6 <lv_obj_get_ext_attr>
 80200d6:	60f8      	str	r0, [r7, #12]
    if(ext->recolor == en) return;
 80200d8:	68fb      	ldr	r3, [r7, #12]
 80200da:	7f9b      	ldrb	r3, [r3, #30]
 80200dc:	f3c3 1380 	ubfx	r3, r3, #6, #1
 80200e0:	b2db      	uxtb	r3, r3
 80200e2:	78fa      	ldrb	r2, [r7, #3]
 80200e4:	429a      	cmp	r2, r3
 80200e6:	d011      	beq.n	802010c <lv_label_set_recolor+0x48>

    ext->recolor = en == false ? 0 : 1;
 80200e8:	78fb      	ldrb	r3, [r7, #3]
 80200ea:	f083 0301 	eor.w	r3, r3, #1
 80200ee:	b2db      	uxtb	r3, r3
 80200f0:	2b00      	cmp	r3, #0
 80200f2:	d001      	beq.n	80200f8 <lv_label_set_recolor+0x34>
 80200f4:	2100      	movs	r1, #0
 80200f6:	e000      	b.n	80200fa <lv_label_set_recolor+0x36>
 80200f8:	2101      	movs	r1, #1
 80200fa:	68fa      	ldr	r2, [r7, #12]
 80200fc:	7f93      	ldrb	r3, [r2, #30]
 80200fe:	f361 1386 	bfi	r3, r1, #6, #1
 8020102:	7793      	strb	r3, [r2, #30]

    lv_label_refr_text(label); /*Refresh the text because the potential colo codes in text needs to
 8020104:	6878      	ldr	r0, [r7, #4]
 8020106:	f000 fc65 	bl	80209d4 <lv_label_refr_text>
 802010a:	e000      	b.n	802010e <lv_label_set_recolor+0x4a>
    if(ext->recolor == en) return;
 802010c:	bf00      	nop
                                  be hided or revealed*/
}
 802010e:	3710      	adds	r7, #16
 8020110:	46bd      	mov	sp, r7
 8020112:	bd80      	pop	{r7, pc}

08020114 <lv_label_set_body_draw>:
 * Set the label to draw (or not draw) background specified in its style's body
 * @param label pointer to a label object
 * @param en true: draw body; false: don't draw body
 */
void lv_label_set_body_draw(lv_obj_t * label, bool en)
{
 8020114:	b580      	push	{r7, lr}
 8020116:	b084      	sub	sp, #16
 8020118:	af00      	add	r7, sp, #0
 802011a:	6078      	str	r0, [r7, #4]
 802011c:	460b      	mov	r3, r1
 802011e:	70fb      	strb	r3, [r7, #3]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 8020120:	6878      	ldr	r0, [r7, #4]
 8020122:	f7f3 ff48 	bl	8013fb6 <lv_obj_get_ext_attr>
 8020126:	60f8      	str	r0, [r7, #12]
    if(ext->body_draw == en) return;
 8020128:	68fb      	ldr	r3, [r7, #12]
 802012a:	7fdb      	ldrb	r3, [r3, #31]
 802012c:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8020130:	b2db      	uxtb	r3, r3
 8020132:	78fa      	ldrb	r2, [r7, #3]
 8020134:	429a      	cmp	r2, r3
 8020136:	d014      	beq.n	8020162 <lv_label_set_body_draw+0x4e>

    ext->body_draw = en == false ? 0 : 1;
 8020138:	78fb      	ldrb	r3, [r7, #3]
 802013a:	f083 0301 	eor.w	r3, r3, #1
 802013e:	b2db      	uxtb	r3, r3
 8020140:	2b00      	cmp	r3, #0
 8020142:	d001      	beq.n	8020148 <lv_label_set_body_draw+0x34>
 8020144:	2100      	movs	r1, #0
 8020146:	e000      	b.n	802014a <lv_label_set_body_draw+0x36>
 8020148:	2101      	movs	r1, #1
 802014a:	68fa      	ldr	r2, [r7, #12]
 802014c:	7fd3      	ldrb	r3, [r2, #31]
 802014e:	f361 0300 	bfi	r3, r1, #0, #1
 8020152:	77d3      	strb	r3, [r2, #31]

    lv_obj_refresh_ext_draw_pad(label);
 8020154:	6878      	ldr	r0, [r7, #4]
 8020156:	f7f3 fd8b 	bl	8013c70 <lv_obj_refresh_ext_draw_pad>

    lv_obj_invalidate(label);
 802015a:	6878      	ldr	r0, [r7, #4]
 802015c:	f7f2 fd86 	bl	8012c6c <lv_obj_invalidate>
 8020160:	e000      	b.n	8020164 <lv_label_set_body_draw+0x50>
    if(ext->body_draw == en) return;
 8020162:	bf00      	nop
}
 8020164:	3710      	adds	r7, #16
 8020166:	46bd      	mov	sp, r7
 8020168:	bd80      	pop	{r7, pc}

0802016a <lv_label_get_text>:
 * Get the text of a label
 * @param label pointer to a label object
 * @return the text of the label
 */
char * lv_label_get_text(const lv_obj_t * label)
{
 802016a:	b580      	push	{r7, lr}
 802016c:	b084      	sub	sp, #16
 802016e:	af00      	add	r7, sp, #0
 8020170:	6078      	str	r0, [r7, #4]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 8020172:	6878      	ldr	r0, [r7, #4]
 8020174:	f7f3 ff1f 	bl	8013fb6 <lv_obj_get_ext_attr>
 8020178:	60f8      	str	r0, [r7, #12]

    return ext->text;
 802017a:	68fb      	ldr	r3, [r7, #12]
 802017c:	681b      	ldr	r3, [r3, #0]
}
 802017e:	4618      	mov	r0, r3
 8020180:	3710      	adds	r7, #16
 8020182:	46bd      	mov	sp, r7
 8020184:	bd80      	pop	{r7, pc}

08020186 <lv_label_get_long_mode>:
 * Get the long mode of a label
 * @param label pointer to a label object
 * @return the long mode
 */
lv_label_long_mode_t lv_label_get_long_mode(const lv_obj_t * label)
{
 8020186:	b580      	push	{r7, lr}
 8020188:	b084      	sub	sp, #16
 802018a:	af00      	add	r7, sp, #0
 802018c:	6078      	str	r0, [r7, #4]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 802018e:	6878      	ldr	r0, [r7, #4]
 8020190:	f7f3 ff11 	bl	8013fb6 <lv_obj_get_ext_attr>
 8020194:	60f8      	str	r0, [r7, #12]
    return ext->long_mode;
 8020196:	68fb      	ldr	r3, [r7, #12]
 8020198:	7f9b      	ldrb	r3, [r3, #30]
 802019a:	f3c3 0302 	ubfx	r3, r3, #0, #3
 802019e:	b2db      	uxtb	r3, r3
}
 80201a0:	4618      	mov	r0, r3
 80201a2:	3710      	adds	r7, #16
 80201a4:	46bd      	mov	sp, r7
 80201a6:	bd80      	pop	{r7, pc}

080201a8 <lv_label_get_align>:
 * Get the align attribute
 * @param label pointer to a label object
 * @return LV_LABEL_ALIGN_LEFT or LV_LABEL_ALIGN_CENTER
 */
lv_label_align_t lv_label_get_align(const lv_obj_t * label)
{
 80201a8:	b580      	push	{r7, lr}
 80201aa:	b084      	sub	sp, #16
 80201ac:	af00      	add	r7, sp, #0
 80201ae:	6078      	str	r0, [r7, #4]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 80201b0:	6878      	ldr	r0, [r7, #4]
 80201b2:	f7f3 ff00 	bl	8013fb6 <lv_obj_get_ext_attr>
 80201b6:	60f8      	str	r0, [r7, #12]
    return ext->align;
 80201b8:	68fb      	ldr	r3, [r7, #12]
 80201ba:	7f9b      	ldrb	r3, [r3, #30]
 80201bc:	f3c3 1301 	ubfx	r3, r3, #4, #2
 80201c0:	b2db      	uxtb	r3, r3
}
 80201c2:	4618      	mov	r0, r3
 80201c4:	3710      	adds	r7, #16
 80201c6:	46bd      	mov	sp, r7
 80201c8:	bd80      	pop	{r7, pc}

080201ca <lv_label_get_recolor>:
 * Get the recoloring attribute
 * @param label pointer to a label object
 * @return true: recoloring is enabled, false: disable
 */
bool lv_label_get_recolor(const lv_obj_t * label)
{
 80201ca:	b580      	push	{r7, lr}
 80201cc:	b084      	sub	sp, #16
 80201ce:	af00      	add	r7, sp, #0
 80201d0:	6078      	str	r0, [r7, #4]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 80201d2:	6878      	ldr	r0, [r7, #4]
 80201d4:	f7f3 feef 	bl	8013fb6 <lv_obj_get_ext_attr>
 80201d8:	60f8      	str	r0, [r7, #12]
    return ext->recolor == 0 ? false : true;
 80201da:	68fb      	ldr	r3, [r7, #12]
 80201dc:	7f9b      	ldrb	r3, [r3, #30]
 80201de:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80201e2:	b2db      	uxtb	r3, r3
 80201e4:	2b00      	cmp	r3, #0
 80201e6:	bf14      	ite	ne
 80201e8:	2301      	movne	r3, #1
 80201ea:	2300      	moveq	r3, #0
 80201ec:	b2db      	uxtb	r3, r3
}
 80201ee:	4618      	mov	r0, r3
 80201f0:	3710      	adds	r7, #16
 80201f2:	46bd      	mov	sp, r7
 80201f4:	bd80      	pop	{r7, pc}

080201f6 <lv_label_get_body_draw>:
 * Get the body draw attribute
 * @param label pointer to a label object
 * @return true: draw body; false: don't draw body
 */
bool lv_label_get_body_draw(const lv_obj_t * label)
{
 80201f6:	b580      	push	{r7, lr}
 80201f8:	b084      	sub	sp, #16
 80201fa:	af00      	add	r7, sp, #0
 80201fc:	6078      	str	r0, [r7, #4]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 80201fe:	6878      	ldr	r0, [r7, #4]
 8020200:	f7f3 fed9 	bl	8013fb6 <lv_obj_get_ext_attr>
 8020204:	60f8      	str	r0, [r7, #12]
    return ext->body_draw == 0 ? false : true;
 8020206:	68fb      	ldr	r3, [r7, #12]
 8020208:	7fdb      	ldrb	r3, [r3, #31]
 802020a:	f003 0301 	and.w	r3, r3, #1
 802020e:	b2db      	uxtb	r3, r3
 8020210:	2b00      	cmp	r3, #0
 8020212:	bf14      	ite	ne
 8020214:	2301      	movne	r3, #1
 8020216:	2300      	moveq	r3, #0
 8020218:	b2db      	uxtb	r3, r3
}
 802021a:	4618      	mov	r0, r3
 802021c:	3710      	adds	r7, #16
 802021e:	46bd      	mov	sp, r7
 8020220:	bd80      	pop	{r7, pc}
	...

08020224 <lv_label_get_letter_on>:
 * @param pos pointer to point with coordinates on a the label
 * @return the index of the letter on the 'pos_p' point (E.g. on 0;0 is the 0. letter)
 * Expressed in character index and not byte index (different in UTF-8)
 */
uint16_t lv_label_get_letter_on(const lv_obj_t * label, lv_point_t * pos)
{
 8020224:	b580      	push	{r7, lr}
 8020226:	b092      	sub	sp, #72	; 0x48
 8020228:	af02      	add	r7, sp, #8
 802022a:	6078      	str	r0, [r7, #4]
 802022c:	6039      	str	r1, [r7, #0]
    const char * txt         = lv_label_get_text(label);
 802022e:	6878      	ldr	r0, [r7, #4]
 8020230:	f7ff ff9b 	bl	802016a <lv_label_get_text>
 8020234:	62b8      	str	r0, [r7, #40]	; 0x28
    lv_label_ext_t * ext     = lv_obj_get_ext_attr(label);
 8020236:	6878      	ldr	r0, [r7, #4]
 8020238:	f7f3 febd 	bl	8013fb6 <lv_obj_get_ext_attr>
 802023c:	6278      	str	r0, [r7, #36]	; 0x24
    uint32_t line_start      = 0;
 802023e:	2300      	movs	r3, #0
 8020240:	63fb      	str	r3, [r7, #60]	; 0x3c
    uint32_t new_line_start  = 0;
 8020242:	2300      	movs	r3, #0
 8020244:	63bb      	str	r3, [r7, #56]	; 0x38
    lv_coord_t max_w         = lv_obj_get_width(label);
 8020246:	6878      	ldr	r0, [r7, #4]
 8020248:	f7f3 fdde 	bl	8013e08 <lv_obj_get_width>
 802024c:	4603      	mov	r3, r0
 802024e:	86fb      	strh	r3, [r7, #54]	; 0x36
    const lv_style_t * style = lv_obj_get_style(label);
 8020250:	6878      	ldr	r0, [r7, #4]
 8020252:	f7f3 fdf5 	bl	8013e40 <lv_obj_get_style>
 8020256:	6238      	str	r0, [r7, #32]
    const lv_font_t * font   = style->text.font;
 8020258:	6a3b      	ldr	r3, [r7, #32]
 802025a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 802025c:	61fb      	str	r3, [r7, #28]
    uint8_t letter_height    = lv_font_get_line_height(font);
 802025e:	69f8      	ldr	r0, [r7, #28]
 8020260:	f7ff fc8a 	bl	801fb78 <lv_font_get_line_height>
 8020264:	4603      	mov	r3, r0
 8020266:	76fb      	strb	r3, [r7, #27]
    lv_coord_t y             = 0;
 8020268:	2300      	movs	r3, #0
 802026a:	86bb      	strh	r3, [r7, #52]	; 0x34
    lv_txt_flag_t flag       = LV_TXT_FLAG_NONE;
 802026c:	2300      	movs	r3, #0
 802026e:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33

    if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
 8020272:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8020274:	7f9b      	ldrb	r3, [r3, #30]
 8020276:	f003 0340 	and.w	r3, r3, #64	; 0x40
 802027a:	b2db      	uxtb	r3, r3
 802027c:	2b00      	cmp	r3, #0
 802027e:	d005      	beq.n	802028c <lv_label_get_letter_on+0x68>
 8020280:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8020284:	f043 0301 	orr.w	r3, r3, #1
 8020288:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
    if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
 802028c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802028e:	7f9b      	ldrb	r3, [r3, #30]
 8020290:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8020294:	b2db      	uxtb	r3, r3
 8020296:	2b00      	cmp	r3, #0
 8020298:	d005      	beq.n	80202a6 <lv_label_get_letter_on+0x82>
 802029a:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 802029e:	f043 0302 	orr.w	r3, r3, #2
 80202a2:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
    if(ext->align == LV_LABEL_ALIGN_CENTER) flag |= LV_TXT_FLAG_CENTER;
 80202a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80202a8:	7f9b      	ldrb	r3, [r3, #30]
 80202aa:	f003 0330 	and.w	r3, r3, #48	; 0x30
 80202ae:	b2db      	uxtb	r3, r3
 80202b0:	2b10      	cmp	r3, #16
 80202b2:	d105      	bne.n	80202c0 <lv_label_get_letter_on+0x9c>
 80202b4:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 80202b8:	f043 0304 	orr.w	r3, r3, #4
 80202bc:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33

    /*If the width will be expanded set the max length to very big */
    if(ext->long_mode == LV_LABEL_LONG_EXPAND) {
 80202c0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80202c2:	7f9b      	ldrb	r3, [r3, #30]
 80202c4:	f003 0307 	and.w	r3, r3, #7
 80202c8:	b2db      	uxtb	r3, r3
 80202ca:	2b00      	cmp	r3, #0
 80202cc:	d12f      	bne.n	802032e <lv_label_get_letter_on+0x10a>
        max_w = LV_COORD_MAX;
 80202ce:	f647 4318 	movw	r3, #31768	; 0x7c18
 80202d2:	86fb      	strh	r3, [r7, #54]	; 0x36
    }

    /*Search the line of the index letter */;
    while(txt[line_start] != '\0') {
 80202d4:	e02b      	b.n	802032e <lv_label_get_letter_on+0x10a>
        new_line_start += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, max_w, flag);
 80202d6:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80202d8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80202da:	18d0      	adds	r0, r2, r3
 80202dc:	6a3b      	ldr	r3, [r7, #32]
 80202de:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
 80202e2:	f9b7 1036 	ldrsh.w	r1, [r7, #54]	; 0x36
 80202e6:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 80202ea:	9300      	str	r3, [sp, #0]
 80202ec:	460b      	mov	r3, r1
 80202ee:	69f9      	ldr	r1, [r7, #28]
 80202f0:	f7fe fadc 	bl	801e8ac <lv_txt_get_next_line>
 80202f4:	4603      	mov	r3, r0
 80202f6:	461a      	mov	r2, r3
 80202f8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80202fa:	4413      	add	r3, r2
 80202fc:	63bb      	str	r3, [r7, #56]	; 0x38

        if(pos->y <= y + letter_height) break; /*The line is found (stored in 'line_start')*/
 80202fe:	683b      	ldr	r3, [r7, #0]
 8020300:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8020304:	4619      	mov	r1, r3
 8020306:	f9b7 2034 	ldrsh.w	r2, [r7, #52]	; 0x34
 802030a:	7efb      	ldrb	r3, [r7, #27]
 802030c:	4413      	add	r3, r2
 802030e:	4299      	cmp	r1, r3
 8020310:	dd14      	ble.n	802033c <lv_label_get_letter_on+0x118>
        y += letter_height + style->text.line_space;
 8020312:	7efb      	ldrb	r3, [r7, #27]
 8020314:	b29a      	uxth	r2, r3
 8020316:	6a3b      	ldr	r3, [r7, #32]
 8020318:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 802031c:	b29b      	uxth	r3, r3
 802031e:	4413      	add	r3, r2
 8020320:	b29a      	uxth	r2, r3
 8020322:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 8020324:	4413      	add	r3, r2
 8020326:	b29b      	uxth	r3, r3
 8020328:	86bb      	strh	r3, [r7, #52]	; 0x34

        line_start = new_line_start;
 802032a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802032c:	63fb      	str	r3, [r7, #60]	; 0x3c
    while(txt[line_start] != '\0') {
 802032e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8020330:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8020332:	4413      	add	r3, r2
 8020334:	781b      	ldrb	r3, [r3, #0]
 8020336:	2b00      	cmp	r3, #0
 8020338:	d1cd      	bne.n	80202d6 <lv_label_get_letter_on+0xb2>
 802033a:	e000      	b.n	802033e <lv_label_get_letter_on+0x11a>
        if(pos->y <= y + letter_height) break; /*The line is found (stored in 'line_start')*/
 802033c:	bf00      	nop
    }

    /*Calculate the x coordinate*/
    lv_coord_t x = 0;
 802033e:	2300      	movs	r3, #0
 8020340:	863b      	strh	r3, [r7, #48]	; 0x30
    if(ext->align == LV_LABEL_ALIGN_CENTER) {
 8020342:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8020344:	7f9b      	ldrb	r3, [r3, #30]
 8020346:	f003 0330 	and.w	r3, r3, #48	; 0x30
 802034a:	b2db      	uxtb	r3, r3
 802034c:	2b10      	cmp	r3, #16
 802034e:	d12b      	bne.n	80203a8 <lv_label_get_letter_on+0x184>
        lv_coord_t line_w;
        line_w = lv_txt_get_width(&txt[line_start], new_line_start - line_start, font, style->text.letter_space, flag);
 8020350:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8020352:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8020354:	18d0      	adds	r0, r2, r3
 8020356:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8020358:	b29a      	uxth	r2, r3
 802035a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802035c:	b29b      	uxth	r3, r3
 802035e:	1ad3      	subs	r3, r2, r3
 8020360:	b299      	uxth	r1, r3
 8020362:	6a3b      	ldr	r3, [r7, #32]
 8020364:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
 8020368:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 802036c:	9300      	str	r3, [sp, #0]
 802036e:	4613      	mov	r3, r2
 8020370:	69fa      	ldr	r2, [r7, #28]
 8020372:	f7fe fb4d 	bl	801ea10 <lv_txt_get_width>
 8020376:	4603      	mov	r3, r0
 8020378:	833b      	strh	r3, [r7, #24]
        x += lv_obj_get_width(label) / 2 - line_w / 2;
 802037a:	6878      	ldr	r0, [r7, #4]
 802037c:	f7f3 fd44 	bl	8013e08 <lv_obj_get_width>
 8020380:	4603      	mov	r3, r0
 8020382:	2b00      	cmp	r3, #0
 8020384:	da00      	bge.n	8020388 <lv_label_get_letter_on+0x164>
 8020386:	3301      	adds	r3, #1
 8020388:	105b      	asrs	r3, r3, #1
 802038a:	b21b      	sxth	r3, r3
 802038c:	461a      	mov	r2, r3
 802038e:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8020392:	2b00      	cmp	r3, #0
 8020394:	da00      	bge.n	8020398 <lv_label_get_letter_on+0x174>
 8020396:	3301      	adds	r3, #1
 8020398:	105b      	asrs	r3, r3, #1
 802039a:	b21b      	sxth	r3, r3
 802039c:	1ad3      	subs	r3, r2, r3
 802039e:	b29a      	uxth	r2, r3
 80203a0:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 80203a2:	4413      	add	r3, r2
 80203a4:	b29b      	uxth	r3, r3
 80203a6:	863b      	strh	r3, [r7, #48]	; 0x30
    }

    lv_txt_cmd_state_t cmd_state = LV_TXT_CMD_STATE_WAIT;
 80203a8:	2300      	movs	r3, #0
 80203aa:	73fb      	strb	r3, [r7, #15]

    uint32_t i         = line_start;
 80203ac:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80203ae:	60bb      	str	r3, [r7, #8]
    uint32_t i_act = i;
 80203b0:	68bb      	ldr	r3, [r7, #8]
 80203b2:	62fb      	str	r3, [r7, #44]	; 0x2c
    uint32_t letter;
    uint32_t letter_next;

    if(new_line_start > 0) {
 80203b4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80203b6:	2b00      	cmp	r3, #0
 80203b8:	d04d      	beq.n	8020456 <lv_label_get_letter_on+0x232>
        while(i < new_line_start) {
 80203ba:	e048      	b.n	802044e <lv_label_get_letter_on+0x22a>
            /* Get the current letter.*/
            letter = lv_txt_encoded_next(txt, &i);
 80203bc:	4b2c      	ldr	r3, [pc, #176]	; (8020470 <lv_label_get_letter_on+0x24c>)
 80203be:	681b      	ldr	r3, [r3, #0]
 80203c0:	f107 0208 	add.w	r2, r7, #8
 80203c4:	4611      	mov	r1, r2
 80203c6:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80203c8:	4798      	blx	r3
 80203ca:	6178      	str	r0, [r7, #20]

            /*Get the next letter too for kerning*/
            letter_next = lv_txt_encoded_next(&txt[i], NULL);
 80203cc:	4b28      	ldr	r3, [pc, #160]	; (8020470 <lv_label_get_letter_on+0x24c>)
 80203ce:	681b      	ldr	r3, [r3, #0]
 80203d0:	68ba      	ldr	r2, [r7, #8]
 80203d2:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80203d4:	440a      	add	r2, r1
 80203d6:	2100      	movs	r1, #0
 80203d8:	4610      	mov	r0, r2
 80203da:	4798      	blx	r3
 80203dc:	6138      	str	r0, [r7, #16]

            /*Handle the recolor command*/
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
 80203de:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 80203e2:	f003 0301 	and.w	r3, r3, #1
 80203e6:	2b00      	cmp	r3, #0
 80203e8:	d00e      	beq.n	8020408 <lv_label_get_letter_on+0x1e4>
                if(lv_txt_is_cmd(&cmd_state, txt[i]) != false) {
 80203ea:	68bb      	ldr	r3, [r7, #8]
 80203ec:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80203ee:	4413      	add	r3, r2
 80203f0:	781b      	ldrb	r3, [r3, #0]
 80203f2:	461a      	mov	r2, r3
 80203f4:	f107 030f 	add.w	r3, r7, #15
 80203f8:	4611      	mov	r1, r2
 80203fa:	4618      	mov	r0, r3
 80203fc:	f7fe fb72 	bl	801eae4 <lv_txt_is_cmd>
 8020400:	4603      	mov	r3, r0
 8020402:	2b00      	cmp	r3, #0
 8020404:	d000      	beq.n	8020408 <lv_label_get_letter_on+0x1e4>
                    continue; /*Skip the letter is it is part of a command*/
 8020406:	e022      	b.n	802044e <lv_label_get_letter_on+0x22a>
                }
            }

            x += lv_font_get_glyph_width(font, letter, letter_next);
 8020408:	693a      	ldr	r2, [r7, #16]
 802040a:	6979      	ldr	r1, [r7, #20]
 802040c:	69f8      	ldr	r0, [r7, #28]
 802040e:	f7fc faa9 	bl	801c964 <lv_font_get_glyph_width>
 8020412:	4603      	mov	r3, r0
 8020414:	461a      	mov	r2, r3
 8020416:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 8020418:	4413      	add	r3, r2
 802041a:	b29b      	uxth	r3, r3
 802041c:	863b      	strh	r3, [r7, #48]	; 0x30

            /*Finish if the x position or the last char of the line is reached*/
            if(pos->x < x || i == new_line_start) {
 802041e:	683b      	ldr	r3, [r7, #0]
 8020420:	f9b3 3000 	ldrsh.w	r3, [r3]
 8020424:	f9b7 2030 	ldrsh.w	r2, [r7, #48]	; 0x30
 8020428:	429a      	cmp	r2, r3
 802042a:	dc03      	bgt.n	8020434 <lv_label_get_letter_on+0x210>
 802042c:	68bb      	ldr	r3, [r7, #8]
 802042e:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8020430:	429a      	cmp	r2, r3
 8020432:	d102      	bne.n	802043a <lv_label_get_letter_on+0x216>
                i = i_act;
 8020434:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8020436:	60bb      	str	r3, [r7, #8]
                break;
 8020438:	e00d      	b.n	8020456 <lv_label_get_letter_on+0x232>
            }
            x += style->text.letter_space;
 802043a:	6a3b      	ldr	r3, [r7, #32]
 802043c:	f9b3 3028 	ldrsh.w	r3, [r3, #40]	; 0x28
 8020440:	b29a      	uxth	r2, r3
 8020442:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 8020444:	4413      	add	r3, r2
 8020446:	b29b      	uxth	r3, r3
 8020448:	863b      	strh	r3, [r7, #48]	; 0x30
            i_act = i;
 802044a:	68bb      	ldr	r3, [r7, #8]
 802044c:	62fb      	str	r3, [r7, #44]	; 0x2c
        while(i < new_line_start) {
 802044e:	68bb      	ldr	r3, [r7, #8]
 8020450:	6bba      	ldr	r2, [r7, #56]	; 0x38
 8020452:	429a      	cmp	r2, r3
 8020454:	d8b2      	bhi.n	80203bc <lv_label_get_letter_on+0x198>
        }
    }

    return lv_encoded_get_char_id(txt, i);
 8020456:	4b07      	ldr	r3, [pc, #28]	; (8020474 <lv_label_get_letter_on+0x250>)
 8020458:	681b      	ldr	r3, [r3, #0]
 802045a:	68ba      	ldr	r2, [r7, #8]
 802045c:	4611      	mov	r1, r2
 802045e:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8020460:	4798      	blx	r3
 8020462:	4603      	mov	r3, r0
 8020464:	b29b      	uxth	r3, r3
}
 8020466:	4618      	mov	r0, r3
 8020468:	3740      	adds	r7, #64	; 0x40
 802046a:	46bd      	mov	sp, r7
 802046c:	bd80      	pop	{r7, pc}
 802046e:	bf00      	nop
 8020470:	240001d0 	.word	0x240001d0
 8020474:	240001dc 	.word	0x240001dc

08020478 <lv_label_get_text_sel_start>:
 * @brief Get the selection start index.
 * @param label pointer to a label object.
 * @return selection start index. `LV_LABEL_TXT_SEL_OFF` if nothing is selected.
 */
uint16_t lv_label_get_text_sel_start(const lv_obj_t * label)
{
 8020478:	b480      	push	{r7}
 802047a:	b083      	sub	sp, #12
 802047c:	af00      	add	r7, sp, #0
 802047e:	6078      	str	r0, [r7, #4]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    return ext->txt_sel_start;

#else
    (void)label;    /*Unused*/
    return LV_LABEL_TEXT_SEL_OFF;
 8020480:	f64f 73ff 	movw	r3, #65535	; 0xffff
#endif
}
 8020484:	4618      	mov	r0, r3
 8020486:	370c      	adds	r7, #12
 8020488:	46bd      	mov	sp, r7
 802048a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802048e:	4770      	bx	lr

08020490 <lv_label_get_text_sel_end>:
 * @brief Get the selection end index.
 * @param label pointer to a label object.
 * @return selection end index. `LV_LABEL_TXT_SEL_OFF` if nothing is selected.
 */
uint16_t lv_label_get_text_sel_end(const lv_obj_t * label)
{
 8020490:	b480      	push	{r7}
 8020492:	b083      	sub	sp, #12
 8020494:	af00      	add	r7, sp, #0
 8020496:	6078      	str	r0, [r7, #4]
#if LV_LABEL_TEXT_SEL
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    return ext->txt_sel_end;
#else
    (void)label; /*Unused*/
    return LV_LABEL_TEXT_SEL_OFF;
 8020498:	f64f 73ff 	movw	r3, #65535	; 0xffff
#endif
}
 802049c:	4618      	mov	r0, r3
 802049e:	370c      	adds	r7, #12
 80204a0:	46bd      	mov	sp, r7
 80204a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80204a6:	4770      	bx	lr

080204a8 <lv_label_design>:
 *             LV_DESIGN_DRAW: draw the object (always return 'true')
 *             LV_DESIGN_DRAW_POST: drawing after every children are drawn
 * @param return true/false, depends on 'mode'
 */
static bool lv_label_design(lv_obj_t * label, const lv_area_t * mask, lv_design_mode_t mode)
{
 80204a8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80204aa:	b099      	sub	sp, #100	; 0x64
 80204ac:	af06      	add	r7, sp, #24
 80204ae:	60f8      	str	r0, [r7, #12]
 80204b0:	60b9      	str	r1, [r7, #8]
 80204b2:	4613      	mov	r3, r2
 80204b4:	71fb      	strb	r3, [r7, #7]
    /* A label never covers an area */
    if(mode == LV_DESIGN_COVER_CHK)
 80204b6:	79fb      	ldrb	r3, [r7, #7]
 80204b8:	2b02      	cmp	r3, #2
 80204ba:	d101      	bne.n	80204c0 <lv_label_design+0x18>
        return false;
 80204bc:	2300      	movs	r3, #0
 80204be:	e1c4      	b.n	802084a <lv_label_design+0x3a2>
    else if(mode == LV_DESIGN_DRAW_MAIN) {
 80204c0:	79fb      	ldrb	r3, [r7, #7]
 80204c2:	2b00      	cmp	r3, #0
 80204c4:	f040 81c0 	bne.w	8020848 <lv_label_design+0x3a0>
        lv_area_t coords;
        const lv_style_t * style = lv_obj_get_style(label);
 80204c8:	68f8      	ldr	r0, [r7, #12]
 80204ca:	f7f3 fcb9 	bl	8013e40 <lv_obj_get_style>
 80204ce:	63f8      	str	r0, [r7, #60]	; 0x3c
        lv_opa_t opa_scale       = lv_obj_get_opa_scale(label);
 80204d0:	68f8      	ldr	r0, [r7, #12]
 80204d2:	f7f3 fd22 	bl	8013f1a <lv_obj_get_opa_scale>
 80204d6:	4603      	mov	r3, r0
 80204d8:	f887 303b 	strb.w	r3, [r7, #59]	; 0x3b
        lv_obj_get_coords(label, &coords);
 80204dc:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80204e0:	4619      	mov	r1, r3
 80204e2:	68f8      	ldr	r0, [r7, #12]
 80204e4:	f7f3 fc4f 	bl	8013d86 <lv_obj_get_coords>

#if LV_USE_GROUP
        lv_group_t * g = lv_obj_get_group(label);
 80204e8:	68f8      	ldr	r0, [r7, #12]
 80204ea:	f7f3 fd70 	bl	8013fce <lv_obj_get_group>
 80204ee:	6378      	str	r0, [r7, #52]	; 0x34
        if(lv_group_get_focused(g) == label) {
 80204f0:	6b78      	ldr	r0, [r7, #52]	; 0x34
 80204f2:	f7f1 ff67 	bl	80123c4 <lv_group_get_focused>
 80204f6:	4602      	mov	r2, r0
 80204f8:	68fb      	ldr	r3, [r7, #12]
 80204fa:	4293      	cmp	r3, r2
 80204fc:	d107      	bne.n	802050e <lv_label_design+0x66>
            lv_draw_rect(&coords, mask, style, opa_scale);
 80204fe:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
 8020502:	f107 0028 	add.w	r0, r7, #40	; 0x28
 8020506:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8020508:	68b9      	ldr	r1, [r7, #8]
 802050a:	f7f7 fac6 	bl	8017a9a <lv_draw_rect>
        }
#endif

        lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 802050e:	68f8      	ldr	r0, [r7, #12]
 8020510:	f7f3 fd51 	bl	8013fb6 <lv_obj_get_ext_attr>
 8020514:	6338      	str	r0, [r7, #48]	; 0x30

        if(ext->body_draw) {
 8020516:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8020518:	7fdb      	ldrb	r3, [r3, #31]
 802051a:	f003 0301 	and.w	r3, r3, #1
 802051e:	b2db      	uxtb	r3, r3
 8020520:	2b00      	cmp	r3, #0
 8020522:	d03b      	beq.n	802059c <lv_label_design+0xf4>
            lv_area_t bg;
            lv_obj_get_coords(label, &bg);
 8020524:	f107 0320 	add.w	r3, r7, #32
 8020528:	4619      	mov	r1, r3
 802052a:	68f8      	ldr	r0, [r7, #12]
 802052c:	f7f3 fc2b 	bl	8013d86 <lv_obj_get_coords>
            bg.x1 -= style->body.padding.left;
 8020530:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 8020534:	b29a      	uxth	r2, r3
 8020536:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8020538:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 802053c:	b29b      	uxth	r3, r3
 802053e:	1ad3      	subs	r3, r2, r3
 8020540:	b29b      	uxth	r3, r3
 8020542:	b21b      	sxth	r3, r3
 8020544:	843b      	strh	r3, [r7, #32]
            bg.x2 += style->body.padding.right;
 8020546:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 802054a:	b29a      	uxth	r2, r3
 802054c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802054e:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
 8020552:	b29b      	uxth	r3, r3
 8020554:	4413      	add	r3, r2
 8020556:	b29b      	uxth	r3, r3
 8020558:	b21b      	sxth	r3, r3
 802055a:	84bb      	strh	r3, [r7, #36]	; 0x24
            bg.y1 -= style->body.padding.top;
 802055c:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8020560:	b29a      	uxth	r2, r3
 8020562:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8020564:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 8020568:	b29b      	uxth	r3, r3
 802056a:	1ad3      	subs	r3, r2, r3
 802056c:	b29b      	uxth	r3, r3
 802056e:	b21b      	sxth	r3, r3
 8020570:	847b      	strh	r3, [r7, #34]	; 0x22
            bg.y2 += style->body.padding.bottom;
 8020572:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8020576:	b29a      	uxth	r2, r3
 8020578:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802057a:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 802057e:	b29b      	uxth	r3, r3
 8020580:	4413      	add	r3, r2
 8020582:	b29b      	uxth	r3, r3
 8020584:	b21b      	sxth	r3, r3
 8020586:	84fb      	strh	r3, [r7, #38]	; 0x26

            lv_draw_rect(&bg, mask, style, lv_obj_get_opa_scale(label));
 8020588:	68f8      	ldr	r0, [r7, #12]
 802058a:	f7f3 fcc6 	bl	8013f1a <lv_obj_get_opa_scale>
 802058e:	4603      	mov	r3, r0
 8020590:	f107 0020 	add.w	r0, r7, #32
 8020594:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8020596:	68b9      	ldr	r1, [r7, #8]
 8020598:	f7f7 fa7f 	bl	8017a9a <lv_draw_rect>
        }

        /*TEST: draw a background for the label*/
        // lv_draw_rect(&label->coords, mask, &lv_style_plain_color, LV_OPA_COVER);

        lv_txt_flag_t flag = LV_TXT_FLAG_NONE;
 802059c:	2300      	movs	r3, #0
 802059e:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
        if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
 80205a2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80205a4:	7f9b      	ldrb	r3, [r3, #30]
 80205a6:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80205aa:	b2db      	uxtb	r3, r3
 80205ac:	2b00      	cmp	r3, #0
 80205ae:	d005      	beq.n	80205bc <lv_label_design+0x114>
 80205b0:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 80205b4:	f043 0301 	orr.w	r3, r3, #1
 80205b8:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
        if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
 80205bc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80205be:	7f9b      	ldrb	r3, [r3, #30]
 80205c0:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80205c4:	b2db      	uxtb	r3, r3
 80205c6:	2b00      	cmp	r3, #0
 80205c8:	d005      	beq.n	80205d6 <lv_label_design+0x12e>
 80205ca:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 80205ce:	f043 0302 	orr.w	r3, r3, #2
 80205d2:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
        if(ext->align == LV_LABEL_ALIGN_CENTER) flag |= LV_TXT_FLAG_CENTER;
 80205d6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80205d8:	7f9b      	ldrb	r3, [r3, #30]
 80205da:	f003 0330 	and.w	r3, r3, #48	; 0x30
 80205de:	b2db      	uxtb	r3, r3
 80205e0:	2b10      	cmp	r3, #16
 80205e2:	d105      	bne.n	80205f0 <lv_label_design+0x148>
 80205e4:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 80205e8:	f043 0304 	orr.w	r3, r3, #4
 80205ec:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
        if(ext->align == LV_LABEL_ALIGN_RIGHT) flag |= LV_TXT_FLAG_RIGHT;
 80205f0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80205f2:	7f9b      	ldrb	r3, [r3, #30]
 80205f4:	f003 0330 	and.w	r3, r3, #48	; 0x30
 80205f8:	b2db      	uxtb	r3, r3
 80205fa:	2b20      	cmp	r3, #32
 80205fc:	d105      	bne.n	802060a <lv_label_design+0x162>
 80205fe:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 8020602:	f043 0308 	orr.w	r3, r3, #8
 8020606:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47

        /* In ROLL mode the CENTER and RIGHT are pointless so remove them.
         * (In addition they will result mis-alignment is this case)*/
        if((ext->long_mode == LV_LABEL_LONG_SROLL || ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) &&
 802060a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802060c:	7f9b      	ldrb	r3, [r3, #30]
 802060e:	f003 0307 	and.w	r3, r3, #7
 8020612:	b2db      	uxtb	r3, r3
 8020614:	2b03      	cmp	r3, #3
 8020616:	d006      	beq.n	8020626 <lv_label_design+0x17e>
 8020618:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802061a:	7f9b      	ldrb	r3, [r3, #30]
 802061c:	f003 0307 	and.w	r3, r3, #7
 8020620:	b2db      	uxtb	r3, r3
 8020622:	2b04      	cmp	r3, #4
 8020624:	d138      	bne.n	8020698 <lv_label_design+0x1f0>
           (ext->align == LV_LABEL_ALIGN_CENTER || ext->align == LV_LABEL_ALIGN_RIGHT)) {
 8020626:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8020628:	7f9b      	ldrb	r3, [r3, #30]
 802062a:	f003 0330 	and.w	r3, r3, #48	; 0x30
 802062e:	b2db      	uxtb	r3, r3
        if((ext->long_mode == LV_LABEL_LONG_SROLL || ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) &&
 8020630:	2b10      	cmp	r3, #16
 8020632:	d006      	beq.n	8020642 <lv_label_design+0x19a>
           (ext->align == LV_LABEL_ALIGN_CENTER || ext->align == LV_LABEL_ALIGN_RIGHT)) {
 8020634:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8020636:	7f9b      	ldrb	r3, [r3, #30]
 8020638:	f003 0330 	and.w	r3, r3, #48	; 0x30
 802063c:	b2db      	uxtb	r3, r3
 802063e:	2b20      	cmp	r3, #32
 8020640:	d12a      	bne.n	8020698 <lv_label_design+0x1f0>
            lv_point_t size;
            lv_txt_get_size(&size, ext->text, style->text.font, style->text.letter_space, style->text.line_space,
 8020642:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8020644:	6819      	ldr	r1, [r3, #0]
 8020646:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8020648:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 802064a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802064c:	f9b3 5028 	ldrsh.w	r5, [r3, #40]	; 0x28
 8020650:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8020652:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 8020656:	f107 001c 	add.w	r0, r7, #28
 802065a:	f897 2047 	ldrb.w	r2, [r7, #71]	; 0x47
 802065e:	9202      	str	r2, [sp, #8]
 8020660:	f647 4218 	movw	r2, #31768	; 0x7c18
 8020664:	9201      	str	r2, [sp, #4]
 8020666:	9300      	str	r3, [sp, #0]
 8020668:	462b      	mov	r3, r5
 802066a:	4622      	mov	r2, r4
 802066c:	f7fe f86c 	bl	801e748 <lv_txt_get_size>
                            LV_COORD_MAX, flag);
            if(size.x > lv_obj_get_width(label)) {
 8020670:	f9b7 401c 	ldrsh.w	r4, [r7, #28]
 8020674:	68f8      	ldr	r0, [r7, #12]
 8020676:	f7f3 fbc7 	bl	8013e08 <lv_obj_get_width>
 802067a:	4603      	mov	r3, r0
 802067c:	429c      	cmp	r4, r3
 802067e:	dd0b      	ble.n	8020698 <lv_label_design+0x1f0>
                flag &= ~LV_TXT_FLAG_RIGHT;
 8020680:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 8020684:	f023 0308 	bic.w	r3, r3, #8
 8020688:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
                flag &= ~LV_TXT_FLAG_CENTER;
 802068c:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 8020690:	f023 0304 	bic.w	r3, r3, #4
 8020694:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
            }
        }
#if LV_LABEL_LONG_TXT_HINT
        lv_draw_label_hint_t * hint = &ext->hint;
 8020698:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802069a:	3310      	adds	r3, #16
 802069c:	643b      	str	r3, [r7, #64]	; 0x40
        if(ext->long_mode == LV_LABEL_LONG_SROLL_CIRC || lv_obj_get_height(label) < LV_LABEL_HINT_HEIGHT_LIMIT)
 802069e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80206a0:	7f9b      	ldrb	r3, [r3, #30]
 80206a2:	f003 0307 	and.w	r3, r3, #7
 80206a6:	b2db      	uxtb	r3, r3
 80206a8:	2b04      	cmp	r3, #4
 80206aa:	d006      	beq.n	80206ba <lv_label_design+0x212>
 80206ac:	68f8      	ldr	r0, [r7, #12]
 80206ae:	f7f3 fbb9 	bl	8013e24 <lv_obj_get_height>
 80206b2:	4603      	mov	r3, r0
 80206b4:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80206b8:	da01      	bge.n	80206be <lv_label_design+0x216>
            hint = NULL;
 80206ba:	2300      	movs	r3, #0
 80206bc:	643b      	str	r3, [r7, #64]	; 0x40

#else
        /*Just for compatibility*/
        lv_draw_label_hint_t * hint = NULL;
#endif
        lv_draw_label(&coords, mask, style, opa_scale, ext->text, flag, &ext->offset,
 80206be:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80206c0:	681c      	ldr	r4, [r3, #0]
 80206c2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80206c4:	f103 050a 	add.w	r5, r3, #10
 80206c8:	68f8      	ldr	r0, [r7, #12]
 80206ca:	f7ff fed5 	bl	8020478 <lv_label_get_text_sel_start>
 80206ce:	4603      	mov	r3, r0
 80206d0:	461e      	mov	r6, r3
 80206d2:	68f8      	ldr	r0, [r7, #12]
 80206d4:	f7ff fedc 	bl	8020490 <lv_label_get_text_sel_end>
 80206d8:	4603      	mov	r3, r0
 80206da:	4619      	mov	r1, r3
 80206dc:	f897 203b 	ldrb.w	r2, [r7, #59]	; 0x3b
 80206e0:	f107 0028 	add.w	r0, r7, #40	; 0x28
 80206e4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80206e6:	9305      	str	r3, [sp, #20]
 80206e8:	9104      	str	r1, [sp, #16]
 80206ea:	9603      	str	r6, [sp, #12]
 80206ec:	9502      	str	r5, [sp, #8]
 80206ee:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 80206f2:	9301      	str	r3, [sp, #4]
 80206f4:	9400      	str	r4, [sp, #0]
 80206f6:	4613      	mov	r3, r2
 80206f8:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80206fa:	68b9      	ldr	r1, [r7, #8]
 80206fc:	f7f6 fd34 	bl	8017168 <lv_draw_label>
                              lv_label_get_text_sel_start(label), lv_label_get_text_sel_end(label), hint);


        if(ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) {
 8020700:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8020702:	7f9b      	ldrb	r3, [r3, #30]
 8020704:	f003 0307 	and.w	r3, r3, #7
 8020708:	b2db      	uxtb	r3, r3
 802070a:	2b04      	cmp	r3, #4
 802070c:	f040 809c 	bne.w	8020848 <lv_label_design+0x3a0>
            lv_point_t size;
            lv_txt_get_size(&size, ext->text, style->text.font, style->text.letter_space, style->text.line_space,
 8020710:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8020712:	6819      	ldr	r1, [r3, #0]
 8020714:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8020716:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 8020718:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802071a:	f9b3 5028 	ldrsh.w	r5, [r3, #40]	; 0x28
 802071e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8020720:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 8020724:	f107 0018 	add.w	r0, r7, #24
 8020728:	f897 2047 	ldrb.w	r2, [r7, #71]	; 0x47
 802072c:	9202      	str	r2, [sp, #8]
 802072e:	f647 4218 	movw	r2, #31768	; 0x7c18
 8020732:	9201      	str	r2, [sp, #4]
 8020734:	9300      	str	r3, [sp, #0]
 8020736:	462b      	mov	r3, r5
 8020738:	4622      	mov	r2, r4
 802073a:	f7fe f805 	bl	801e748 <lv_txt_get_size>
                            LV_COORD_MAX, flag);

            lv_point_t ofs;

            /*Draw the text again next to the original to make an circular effect */
            if(size.x > lv_obj_get_width(label)) {
 802073e:	f9b7 4018 	ldrsh.w	r4, [r7, #24]
 8020742:	68f8      	ldr	r0, [r7, #12]
 8020744:	f7f3 fb60 	bl	8013e08 <lv_obj_get_width>
 8020748:	4603      	mov	r3, r0
 802074a:	429c      	cmp	r4, r3
 802074c:	dd3c      	ble.n	80207c8 <lv_label_design+0x320>
                ofs.x = ext->offset.x + size.x +
 802074e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8020750:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 8020754:	b29a      	uxth	r2, r3
 8020756:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 802075a:	b29b      	uxth	r3, r3
 802075c:	4413      	add	r3, r2
 802075e:	b29c      	uxth	r4, r3
                        lv_font_get_glyph_width(style->text.font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT;
 8020760:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8020762:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8020764:	2220      	movs	r2, #32
 8020766:	2120      	movs	r1, #32
 8020768:	4618      	mov	r0, r3
 802076a:	f7fc f8fb 	bl	801c964 <lv_font_get_glyph_width>
 802076e:	4603      	mov	r3, r0
                ofs.x = ext->offset.x + size.x +
 8020770:	461a      	mov	r2, r3
 8020772:	0052      	lsls	r2, r2, #1
 8020774:	4413      	add	r3, r2
 8020776:	b29b      	uxth	r3, r3
 8020778:	4423      	add	r3, r4
 802077a:	b29b      	uxth	r3, r3
 802077c:	b21b      	sxth	r3, r3
 802077e:	82bb      	strh	r3, [r7, #20]
                ofs.y = ext->offset.y;
 8020780:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8020782:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8020786:	82fb      	strh	r3, [r7, #22]

                lv_draw_label(&coords, mask, style, opa_scale, ext->text, flag, &ofs,
 8020788:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802078a:	681c      	ldr	r4, [r3, #0]
 802078c:	68f8      	ldr	r0, [r7, #12]
 802078e:	f7ff fe73 	bl	8020478 <lv_label_get_text_sel_start>
 8020792:	4603      	mov	r3, r0
 8020794:	461d      	mov	r5, r3
 8020796:	68f8      	ldr	r0, [r7, #12]
 8020798:	f7ff fe7a 	bl	8020490 <lv_label_get_text_sel_end>
 802079c:	4603      	mov	r3, r0
 802079e:	4619      	mov	r1, r3
 80207a0:	f897 203b 	ldrb.w	r2, [r7, #59]	; 0x3b
 80207a4:	f107 0028 	add.w	r0, r7, #40	; 0x28
 80207a8:	2300      	movs	r3, #0
 80207aa:	9305      	str	r3, [sp, #20]
 80207ac:	9104      	str	r1, [sp, #16]
 80207ae:	9503      	str	r5, [sp, #12]
 80207b0:	f107 0314 	add.w	r3, r7, #20
 80207b4:	9302      	str	r3, [sp, #8]
 80207b6:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 80207ba:	9301      	str	r3, [sp, #4]
 80207bc:	9400      	str	r4, [sp, #0]
 80207be:	4613      	mov	r3, r2
 80207c0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80207c2:	68b9      	ldr	r1, [r7, #8]
 80207c4:	f7f6 fcd0 	bl	8017168 <lv_draw_label>
                              lv_label_get_text_sel_start(label), lv_label_get_text_sel_end(label), NULL);
            }

            /*Draw the text again below the original to make an circular effect */
            if(size.y > lv_obj_get_height(label)) {
 80207c8:	f9b7 401a 	ldrsh.w	r4, [r7, #26]
 80207cc:	68f8      	ldr	r0, [r7, #12]
 80207ce:	f7f3 fb29 	bl	8013e24 <lv_obj_get_height>
 80207d2:	4603      	mov	r3, r0
 80207d4:	429c      	cmp	r4, r3
 80207d6:	dd37      	ble.n	8020848 <lv_label_design+0x3a0>
                ofs.x = ext->offset.x;
 80207d8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80207da:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 80207de:	82bb      	strh	r3, [r7, #20]
                ofs.y = ext->offset.y + size.y + lv_font_get_line_height(style->text.font);
 80207e0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80207e2:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 80207e6:	b29a      	uxth	r2, r3
 80207e8:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80207ec:	b29b      	uxth	r3, r3
 80207ee:	4413      	add	r3, r2
 80207f0:	b29c      	uxth	r4, r3
 80207f2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80207f4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80207f6:	4618      	mov	r0, r3
 80207f8:	f7ff f9be 	bl	801fb78 <lv_font_get_line_height>
 80207fc:	4603      	mov	r3, r0
 80207fe:	b29b      	uxth	r3, r3
 8020800:	4423      	add	r3, r4
 8020802:	b29b      	uxth	r3, r3
 8020804:	b21b      	sxth	r3, r3
 8020806:	82fb      	strh	r3, [r7, #22]
                lv_draw_label(&coords, mask, style, opa_scale, ext->text, flag, &ofs,
 8020808:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802080a:	681c      	ldr	r4, [r3, #0]
 802080c:	68f8      	ldr	r0, [r7, #12]
 802080e:	f7ff fe33 	bl	8020478 <lv_label_get_text_sel_start>
 8020812:	4603      	mov	r3, r0
 8020814:	461d      	mov	r5, r3
 8020816:	68f8      	ldr	r0, [r7, #12]
 8020818:	f7ff fe3a 	bl	8020490 <lv_label_get_text_sel_end>
 802081c:	4603      	mov	r3, r0
 802081e:	4619      	mov	r1, r3
 8020820:	f897 203b 	ldrb.w	r2, [r7, #59]	; 0x3b
 8020824:	f107 0028 	add.w	r0, r7, #40	; 0x28
 8020828:	2300      	movs	r3, #0
 802082a:	9305      	str	r3, [sp, #20]
 802082c:	9104      	str	r1, [sp, #16]
 802082e:	9503      	str	r5, [sp, #12]
 8020830:	f107 0314 	add.w	r3, r7, #20
 8020834:	9302      	str	r3, [sp, #8]
 8020836:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 802083a:	9301      	str	r3, [sp, #4]
 802083c:	9400      	str	r4, [sp, #0]
 802083e:	4613      	mov	r3, r2
 8020840:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8020842:	68b9      	ldr	r1, [r7, #8]
 8020844:	f7f6 fc90 	bl	8017168 <lv_draw_label>
                              lv_label_get_text_sel_start(label), lv_label_get_text_sel_end(label), NULL);
            }
        }
    }
    return true;
 8020848:	2301      	movs	r3, #1
}
 802084a:	4618      	mov	r0, r3
 802084c:	374c      	adds	r7, #76	; 0x4c
 802084e:	46bd      	mov	sp, r7
 8020850:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08020854 <lv_label_signal>:
 * @param sign a signal type from lv_signal_t enum
 * @param param pointer to a signal specific variable
 * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted
 */
static lv_res_t lv_label_signal(lv_obj_t * label, lv_signal_t sign, void * param)
{
 8020854:	b590      	push	{r4, r7, lr}
 8020856:	b089      	sub	sp, #36	; 0x24
 8020858:	af00      	add	r7, sp, #0
 802085a:	60f8      	str	r0, [r7, #12]
 802085c:	460b      	mov	r3, r1
 802085e:	607a      	str	r2, [r7, #4]
 8020860:	72fb      	strb	r3, [r7, #11]
    lv_res_t res;

    /* Include the ancient signal function */
    res = ancestor_signal(label, sign, param);
 8020862:	4b5a      	ldr	r3, [pc, #360]	; (80209cc <lv_label_signal+0x178>)
 8020864:	681b      	ldr	r3, [r3, #0]
 8020866:	7af9      	ldrb	r1, [r7, #11]
 8020868:	687a      	ldr	r2, [r7, #4]
 802086a:	68f8      	ldr	r0, [r7, #12]
 802086c:	4798      	blx	r3
 802086e:	4603      	mov	r3, r0
 8020870:	77bb      	strb	r3, [r7, #30]
    if(res != LV_RES_OK) return res;
 8020872:	7fbb      	ldrb	r3, [r7, #30]
 8020874:	2b01      	cmp	r3, #1
 8020876:	d001      	beq.n	802087c <lv_label_signal+0x28>
 8020878:	7fbb      	ldrb	r3, [r7, #30]
 802087a:	e0a3      	b.n	80209c4 <lv_label_signal+0x170>

    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 802087c:	68f8      	ldr	r0, [r7, #12]
 802087e:	f7f3 fb9a 	bl	8013fb6 <lv_obj_get_ext_attr>
 8020882:	61b8      	str	r0, [r7, #24]
    if(sign == LV_SIGNAL_CLEANUP) {
 8020884:	7afb      	ldrb	r3, [r7, #11]
 8020886:	2b00      	cmp	r3, #0
 8020888:	d112      	bne.n	80208b0 <lv_label_signal+0x5c>
        if(ext->static_txt == 0) {
 802088a:	69bb      	ldr	r3, [r7, #24]
 802088c:	7f9b      	ldrb	r3, [r3, #30]
 802088e:	f003 0308 	and.w	r3, r3, #8
 8020892:	b2db      	uxtb	r3, r3
 8020894:	2b00      	cmp	r3, #0
 8020896:	d107      	bne.n	80208a8 <lv_label_signal+0x54>
            lv_mem_free(ext->text);
 8020898:	69bb      	ldr	r3, [r7, #24]
 802089a:	681b      	ldr	r3, [r3, #0]
 802089c:	4618      	mov	r0, r3
 802089e:	f7fd fc47 	bl	801e130 <lv_mem_free>
            ext->text = NULL;
 80208a2:	69bb      	ldr	r3, [r7, #24]
 80208a4:	2200      	movs	r2, #0
 80208a6:	601a      	str	r2, [r3, #0]
        }
        lv_label_dot_tmp_free(label);
 80208a8:	68f8      	ldr	r0, [r7, #12]
 80208aa:	f000 fc16 	bl	80210da <lv_label_dot_tmp_free>
 80208ae:	e088      	b.n	80209c2 <lv_label_signal+0x16e>
    } else if(sign == LV_SIGNAL_STYLE_CHG) {
 80208b0:	7afb      	ldrb	r3, [r7, #11]
 80208b2:	2b04      	cmp	r3, #4
 80208b4:	d106      	bne.n	80208c4 <lv_label_signal+0x70>
        /*Revert dots for proper refresh*/
        lv_label_revert_dots(label);
 80208b6:	68f8      	ldr	r0, [r7, #12]
 80208b8:	f000 fb32 	bl	8020f20 <lv_label_revert_dots>

        lv_label_refr_text(label);
 80208bc:	68f8      	ldr	r0, [r7, #12]
 80208be:	f000 f889 	bl	80209d4 <lv_label_refr_text>
 80208c2:	e07e      	b.n	80209c2 <lv_label_signal+0x16e>
    } else if(sign == LV_SIGNAL_CORD_CHG) {
 80208c4:	7afb      	ldrb	r3, [r7, #11]
 80208c6:	2b02      	cmp	r3, #2
 80208c8:	d120      	bne.n	802090c <lv_label_signal+0xb8>
        if(lv_area_get_width(&label->coords) != lv_area_get_width(param) ||
 80208ca:	68fb      	ldr	r3, [r7, #12]
 80208cc:	3310      	adds	r3, #16
 80208ce:	4618      	mov	r0, r3
 80208d0:	f7ff f95e 	bl	801fb90 <lv_area_get_width>
 80208d4:	4603      	mov	r3, r0
 80208d6:	461c      	mov	r4, r3
 80208d8:	6878      	ldr	r0, [r7, #4]
 80208da:	f7ff f959 	bl	801fb90 <lv_area_get_width>
 80208de:	4603      	mov	r3, r0
 80208e0:	429c      	cmp	r4, r3
 80208e2:	d10c      	bne.n	80208fe <lv_label_signal+0xaa>
           lv_area_get_height(&label->coords) != lv_area_get_height(param)) {
 80208e4:	68fb      	ldr	r3, [r7, #12]
 80208e6:	3310      	adds	r3, #16
 80208e8:	4618      	mov	r0, r3
 80208ea:	f7ff f968 	bl	801fbbe <lv_area_get_height>
 80208ee:	4603      	mov	r3, r0
 80208f0:	461c      	mov	r4, r3
 80208f2:	6878      	ldr	r0, [r7, #4]
 80208f4:	f7ff f963 	bl	801fbbe <lv_area_get_height>
 80208f8:	4603      	mov	r3, r0
        if(lv_area_get_width(&label->coords) != lv_area_get_width(param) ||
 80208fa:	429c      	cmp	r4, r3
 80208fc:	d061      	beq.n	80209c2 <lv_label_signal+0x16e>
            lv_label_revert_dots(label);
 80208fe:	68f8      	ldr	r0, [r7, #12]
 8020900:	f000 fb0e 	bl	8020f20 <lv_label_revert_dots>
            lv_label_refr_text(label);
 8020904:	68f8      	ldr	r0, [r7, #12]
 8020906:	f000 f865 	bl	80209d4 <lv_label_refr_text>
 802090a:	e05a      	b.n	80209c2 <lv_label_signal+0x16e>
        }
    } else if(sign == LV_SIGNAL_REFR_EXT_DRAW_PAD) {
 802090c:	7afb      	ldrb	r3, [r7, #11]
 802090e:	2b05      	cmp	r3, #5
 8020910:	d13c      	bne.n	802098c <lv_label_signal+0x138>
        if(ext->body_draw) {
 8020912:	69bb      	ldr	r3, [r7, #24]
 8020914:	7fdb      	ldrb	r3, [r3, #31]
 8020916:	f003 0301 	and.w	r3, r3, #1
 802091a:	b2db      	uxtb	r3, r3
 802091c:	2b00      	cmp	r3, #0
 802091e:	d050      	beq.n	80209c2 <lv_label_signal+0x16e>
            const lv_style_t * style = lv_label_get_style(label, LV_LABEL_STYLE_MAIN);
 8020920:	2100      	movs	r1, #0
 8020922:	68f8      	ldr	r0, [r7, #12]
 8020924:	f7ff f971 	bl	801fc0a <lv_label_get_style>
 8020928:	6138      	str	r0, [r7, #16]

            label->ext_draw_pad = LV_MATH_MAX(label->ext_draw_pad, style->body.padding.left);
 802092a:	693b      	ldr	r3, [r7, #16]
 802092c:	f9b3 201a 	ldrsh.w	r2, [r3, #26]
 8020930:	68fb      	ldr	r3, [r7, #12]
 8020932:	f9b3 3034 	ldrsh.w	r3, [r3, #52]	; 0x34
 8020936:	4293      	cmp	r3, r2
 8020938:	bfb8      	it	lt
 802093a:	4613      	movlt	r3, r2
 802093c:	b21a      	sxth	r2, r3
 802093e:	68fb      	ldr	r3, [r7, #12]
 8020940:	869a      	strh	r2, [r3, #52]	; 0x34
            label->ext_draw_pad = LV_MATH_MAX(label->ext_draw_pad, style->body.padding.right);
 8020942:	693b      	ldr	r3, [r7, #16]
 8020944:	f9b3 201c 	ldrsh.w	r2, [r3, #28]
 8020948:	68fb      	ldr	r3, [r7, #12]
 802094a:	f9b3 3034 	ldrsh.w	r3, [r3, #52]	; 0x34
 802094e:	4293      	cmp	r3, r2
 8020950:	bfb8      	it	lt
 8020952:	4613      	movlt	r3, r2
 8020954:	b21a      	sxth	r2, r3
 8020956:	68fb      	ldr	r3, [r7, #12]
 8020958:	869a      	strh	r2, [r3, #52]	; 0x34
            label->ext_draw_pad = LV_MATH_MAX(label->ext_draw_pad, style->body.padding.top);
 802095a:	693b      	ldr	r3, [r7, #16]
 802095c:	f9b3 2016 	ldrsh.w	r2, [r3, #22]
 8020960:	68fb      	ldr	r3, [r7, #12]
 8020962:	f9b3 3034 	ldrsh.w	r3, [r3, #52]	; 0x34
 8020966:	4293      	cmp	r3, r2
 8020968:	bfb8      	it	lt
 802096a:	4613      	movlt	r3, r2
 802096c:	b21a      	sxth	r2, r3
 802096e:	68fb      	ldr	r3, [r7, #12]
 8020970:	869a      	strh	r2, [r3, #52]	; 0x34
            label->ext_draw_pad = LV_MATH_MAX(label->ext_draw_pad, style->body.padding.bottom);
 8020972:	693b      	ldr	r3, [r7, #16]
 8020974:	f9b3 2018 	ldrsh.w	r2, [r3, #24]
 8020978:	68fb      	ldr	r3, [r7, #12]
 802097a:	f9b3 3034 	ldrsh.w	r3, [r3, #52]	; 0x34
 802097e:	4293      	cmp	r3, r2
 8020980:	bfb8      	it	lt
 8020982:	4613      	movlt	r3, r2
 8020984:	b21a      	sxth	r2, r3
 8020986:	68fb      	ldr	r3, [r7, #12]
 8020988:	869a      	strh	r2, [r3, #52]	; 0x34
 802098a:	e01a      	b.n	80209c2 <lv_label_signal+0x16e>
        }
    } else if(sign == LV_SIGNAL_GET_TYPE) {
 802098c:	7afb      	ldrb	r3, [r7, #11]
 802098e:	2b06      	cmp	r3, #6
 8020990:	d117      	bne.n	80209c2 <lv_label_signal+0x16e>
        lv_obj_type_t * buf = param;
 8020992:	687b      	ldr	r3, [r7, #4]
 8020994:	617b      	str	r3, [r7, #20]
        uint8_t i;
        for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
 8020996:	2300      	movs	r3, #0
 8020998:	77fb      	strb	r3, [r7, #31]
 802099a:	e008      	b.n	80209ae <lv_label_signal+0x15a>
            if(buf->type[i] == NULL) break;
 802099c:	7ffa      	ldrb	r2, [r7, #31]
 802099e:	697b      	ldr	r3, [r7, #20]
 80209a0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80209a4:	2b00      	cmp	r3, #0
 80209a6:	d006      	beq.n	80209b6 <lv_label_signal+0x162>
        for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
 80209a8:	7ffb      	ldrb	r3, [r7, #31]
 80209aa:	3301      	adds	r3, #1
 80209ac:	77fb      	strb	r3, [r7, #31]
 80209ae:	7ffb      	ldrb	r3, [r7, #31]
 80209b0:	2b06      	cmp	r3, #6
 80209b2:	d9f3      	bls.n	802099c <lv_label_signal+0x148>
 80209b4:	e000      	b.n	80209b8 <lv_label_signal+0x164>
            if(buf->type[i] == NULL) break;
 80209b6:	bf00      	nop
        }
        buf->type[i] = "lv_label";
 80209b8:	7ffa      	ldrb	r2, [r7, #31]
 80209ba:	697b      	ldr	r3, [r7, #20]
 80209bc:	4904      	ldr	r1, [pc, #16]	; (80209d0 <lv_label_signal+0x17c>)
 80209be:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    }

    return res;
 80209c2:	7fbb      	ldrb	r3, [r7, #30]
}
 80209c4:	4618      	mov	r0, r3
 80209c6:	3724      	adds	r7, #36	; 0x24
 80209c8:	46bd      	mov	sp, r7
 80209ca:	bd90      	pop	{r4, r7, pc}
 80209cc:	2406240c 	.word	0x2406240c
 80209d0:	08022920 	.word	0x08022920

080209d4 <lv_label_refr_text>:
/**
 * Refresh the label with its text stored in its extended data
 * @param label pointer to a label object
 */
static void lv_label_refr_text(lv_obj_t * label)
{
 80209d4:	b590      	push	{r4, r7, lr}
 80209d6:	b09d      	sub	sp, #116	; 0x74
 80209d8:	af04      	add	r7, sp, #16
 80209da:	6078      	str	r0, [r7, #4]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 80209dc:	6878      	ldr	r0, [r7, #4]
 80209de:	f7f3 faea 	bl	8013fb6 <lv_obj_get_ext_attr>
 80209e2:	64f8      	str	r0, [r7, #76]	; 0x4c

    if(ext->text == NULL) return;
 80209e4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80209e6:	681b      	ldr	r3, [r3, #0]
 80209e8:	2b00      	cmp	r3, #0
 80209ea:	f000 828f 	beq.w	8020f0c <lv_label_refr_text+0x538>
#if LV_LABEL_LONG_TXT_HINT
    ext->hint.line_start = -1; /*The hint is invalid if the text changes*/
 80209ee:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80209f0:	f04f 32ff 	mov.w	r2, #4294967295
 80209f4:	611a      	str	r2, [r3, #16]
#endif

    lv_coord_t max_w         = lv_obj_get_width(label);
 80209f6:	6878      	ldr	r0, [r7, #4]
 80209f8:	f7f3 fa06 	bl	8013e08 <lv_obj_get_width>
 80209fc:	4603      	mov	r3, r0
 80209fe:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
    const lv_style_t * style = lv_obj_get_style(label);
 8020a02:	6878      	ldr	r0, [r7, #4]
 8020a04:	f7f3 fa1c 	bl	8013e40 <lv_obj_get_style>
 8020a08:	64b8      	str	r0, [r7, #72]	; 0x48
    const lv_font_t * font   = style->text.font;
 8020a0a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8020a0c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8020a0e:	647b      	str	r3, [r7, #68]	; 0x44

    /*If the width will be expanded set the max length to very big */
    if(ext->long_mode == LV_LABEL_LONG_EXPAND) {
 8020a10:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020a12:	7f9b      	ldrb	r3, [r3, #30]
 8020a14:	f003 0307 	and.w	r3, r3, #7
 8020a18:	b2db      	uxtb	r3, r3
 8020a1a:	2b00      	cmp	r3, #0
 8020a1c:	d103      	bne.n	8020a26 <lv_label_refr_text+0x52>
        max_w = LV_COORD_MAX;
 8020a1e:	f647 4318 	movw	r3, #31768	; 0x7c18
 8020a22:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
    }

    /*Calc. the height and longest line*/
    lv_point_t size;
    lv_txt_flag_t flag = LV_TXT_FLAG_NONE;
 8020a26:	2300      	movs	r3, #0
 8020a28:	f887 305d 	strb.w	r3, [r7, #93]	; 0x5d
    if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
 8020a2c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020a2e:	7f9b      	ldrb	r3, [r3, #30]
 8020a30:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8020a34:	b2db      	uxtb	r3, r3
 8020a36:	2b00      	cmp	r3, #0
 8020a38:	d005      	beq.n	8020a46 <lv_label_refr_text+0x72>
 8020a3a:	f897 305d 	ldrb.w	r3, [r7, #93]	; 0x5d
 8020a3e:	f043 0301 	orr.w	r3, r3, #1
 8020a42:	f887 305d 	strb.w	r3, [r7, #93]	; 0x5d
    if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
 8020a46:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020a48:	7f9b      	ldrb	r3, [r3, #30]
 8020a4a:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8020a4e:	b2db      	uxtb	r3, r3
 8020a50:	2b00      	cmp	r3, #0
 8020a52:	d005      	beq.n	8020a60 <lv_label_refr_text+0x8c>
 8020a54:	f897 305d 	ldrb.w	r3, [r7, #93]	; 0x5d
 8020a58:	f043 0302 	orr.w	r3, r3, #2
 8020a5c:	f887 305d 	strb.w	r3, [r7, #93]	; 0x5d
    lv_txt_get_size(&size, ext->text, font, style->text.letter_space, style->text.line_space, max_w, flag);
 8020a60:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020a62:	6819      	ldr	r1, [r3, #0]
 8020a64:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8020a66:	f9b3 4028 	ldrsh.w	r4, [r3, #40]	; 0x28
 8020a6a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8020a6c:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 8020a70:	f107 0038 	add.w	r0, r7, #56	; 0x38
 8020a74:	f897 205d 	ldrb.w	r2, [r7, #93]	; 0x5d
 8020a78:	9202      	str	r2, [sp, #8]
 8020a7a:	f9b7 205e 	ldrsh.w	r2, [r7, #94]	; 0x5e
 8020a7e:	9201      	str	r2, [sp, #4]
 8020a80:	9300      	str	r3, [sp, #0]
 8020a82:	4623      	mov	r3, r4
 8020a84:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8020a86:	f7fd fe5f 	bl	801e748 <lv_txt_get_size>

    /*Set the full size in expand mode*/
    if(ext->long_mode == LV_LABEL_LONG_EXPAND) {
 8020a8a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020a8c:	7f9b      	ldrb	r3, [r3, #30]
 8020a8e:	f003 0307 	and.w	r3, r3, #7
 8020a92:	b2db      	uxtb	r3, r3
 8020a94:	2b00      	cmp	r3, #0
 8020a96:	d108      	bne.n	8020aaa <lv_label_refr_text+0xd6>
        lv_obj_set_size(label, size.x, size.y);
 8020a98:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 8020a9c:	f9b7 203a 	ldrsh.w	r2, [r7, #58]	; 0x3a
 8020aa0:	4619      	mov	r1, r3
 8020aa2:	6878      	ldr	r0, [r7, #4]
 8020aa4:	f7f2 fa50 	bl	8012f48 <lv_obj_set_size>
 8020aa8:	e22c      	b.n	8020f04 <lv_label_refr_text+0x530>
    }
    /*In roll mode keep the size but start offset animations*/
    else if(ext->long_mode == LV_LABEL_LONG_SROLL) {
 8020aaa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020aac:	7f9b      	ldrb	r3, [r3, #30]
 8020aae:	f003 0307 	and.w	r3, r3, #7
 8020ab2:	b2db      	uxtb	r3, r3
 8020ab4:	2b03      	cmp	r3, #3
 8020ab6:	f040 809f 	bne.w	8020bf8 <lv_label_refr_text+0x224>
#if LV_USE_ANIMATION
        lv_anim_t anim;
        anim.var      = label;
 8020aba:	687b      	ldr	r3, [r7, #4]
 8020abc:	60fb      	str	r3, [r7, #12]
        anim.repeat   = 1;
 8020abe:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 8020ac2:	f043 0302 	orr.w	r3, r3, #2
 8020ac6:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
        anim.playback = 1;
 8020aca:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 8020ace:	f043 0301 	orr.w	r3, r3, #1
 8020ad2:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
        anim.start    = 0;
 8020ad6:	2300      	movs	r3, #0
 8020ad8:	61fb      	str	r3, [r7, #28]
        anim.ready_cb = NULL;
 8020ada:	2300      	movs	r3, #0
 8020adc:	61bb      	str	r3, [r7, #24]
        anim.path_cb  = lv_anim_path_linear;
 8020ade:	4baa      	ldr	r3, [pc, #680]	; (8020d88 <lv_label_refr_text+0x3b4>)
 8020ae0:	617b      	str	r3, [r7, #20]
        anim.playback_pause =
            (((lv_font_get_glyph_width(style->text.font, ' ', ' ') + style->text.letter_space) * 1000) /
 8020ae2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8020ae4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8020ae6:	2220      	movs	r2, #32
 8020ae8:	2120      	movs	r1, #32
 8020aea:	4618      	mov	r0, r3
 8020aec:	f7fb ff3a 	bl	801c964 <lv_font_get_glyph_width>
 8020af0:	4603      	mov	r3, r0
 8020af2:	461a      	mov	r2, r3
 8020af4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8020af6:	f9b3 3028 	ldrsh.w	r3, [r3, #40]	; 0x28
 8020afa:	4413      	add	r3, r2
 8020afc:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8020b00:	fb02 f303 	mul.w	r3, r2, r3
             ext->anim_speed) *
 8020b04:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8020b06:	8b92      	ldrh	r2, [r2, #28]
            (((lv_font_get_glyph_width(style->text.font, ' ', ' ') + style->text.letter_space) * 1000) /
 8020b08:	fb93 f3f2 	sdiv	r3, r3, r2
        anim.playback_pause =
 8020b0c:	b29b      	uxth	r3, r3
 8020b0e:	461a      	mov	r2, r3
 8020b10:	0052      	lsls	r2, r2, #1
 8020b12:	4413      	add	r3, r2
 8020b14:	b29b      	uxth	r3, r3
 8020b16:	853b      	strh	r3, [r7, #40]	; 0x28
            LV_LABEL_WAIT_CHAR_COUNT;
        anim.repeat_pause = anim.playback_pause;
 8020b18:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8020b1a:	857b      	strh	r3, [r7, #42]	; 0x2a
        anim.act_time     = -anim.playback_pause;
 8020b1c:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8020b1e:	425b      	negs	r3, r3
 8020b20:	b29b      	uxth	r3, r3
 8020b22:	b21b      	sxth	r3, r3
 8020b24:	84fb      	strh	r3, [r7, #38]	; 0x26

        bool hor_anim = false;
 8020b26:	2300      	movs	r3, #0
 8020b28:	f887 305c 	strb.w	r3, [r7, #92]	; 0x5c
        if(size.x > lv_obj_get_width(label)) {
 8020b2c:	f9b7 4038 	ldrsh.w	r4, [r7, #56]	; 0x38
 8020b30:	6878      	ldr	r0, [r7, #4]
 8020b32:	f7f3 f969 	bl	8013e08 <lv_obj_get_width>
 8020b36:	4603      	mov	r3, r0
 8020b38:	429c      	cmp	r4, r3
 8020b3a:	dd1e      	ble.n	8020b7a <lv_label_refr_text+0x1a6>
            anim.end     = lv_obj_get_width(label) - size.x;
 8020b3c:	6878      	ldr	r0, [r7, #4]
 8020b3e:	f7f3 f963 	bl	8013e08 <lv_obj_get_width>
 8020b42:	4603      	mov	r3, r0
 8020b44:	461a      	mov	r2, r3
 8020b46:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 8020b4a:	1ad3      	subs	r3, r2, r3
 8020b4c:	623b      	str	r3, [r7, #32]
            anim.exec_cb = (lv_anim_exec_xcb_t)lv_label_set_offset_x;
 8020b4e:	4b8f      	ldr	r3, [pc, #572]	; (8020d8c <lv_label_refr_text+0x3b8>)
 8020b50:	613b      	str	r3, [r7, #16]
            anim.time    = lv_anim_speed_to_time(ext->anim_speed, anim.start, anim.end);
 8020b52:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020b54:	8b9b      	ldrh	r3, [r3, #28]
 8020b56:	69fa      	ldr	r2, [r7, #28]
 8020b58:	b211      	sxth	r1, r2
 8020b5a:	6a3a      	ldr	r2, [r7, #32]
 8020b5c:	b212      	sxth	r2, r2
 8020b5e:	4618      	mov	r0, r3
 8020b60:	f7fc fc84 	bl	801d46c <lv_anim_speed_to_time>
 8020b64:	4603      	mov	r3, r0
 8020b66:	84bb      	strh	r3, [r7, #36]	; 0x24
            lv_anim_create(&anim);
 8020b68:	f107 030c 	add.w	r3, r7, #12
 8020b6c:	4618      	mov	r0, r3
 8020b6e:	f7fc fc05 	bl	801d37c <lv_anim_create>
            hor_anim = true;
 8020b72:	2301      	movs	r3, #1
 8020b74:	f887 305c 	strb.w	r3, [r7, #92]	; 0x5c
 8020b78:	e006      	b.n	8020b88 <lv_label_refr_text+0x1b4>
        } else {
            /*Delete the offset animation if not required*/
            lv_anim_del(label, (lv_anim_exec_xcb_t)lv_label_set_offset_x);
 8020b7a:	4984      	ldr	r1, [pc, #528]	; (8020d8c <lv_label_refr_text+0x3b8>)
 8020b7c:	6878      	ldr	r0, [r7, #4]
 8020b7e:	f7fc fc3d 	bl	801d3fc <lv_anim_del>
            ext->offset.x = 0;
 8020b82:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020b84:	2200      	movs	r2, #0
 8020b86:	815a      	strh	r2, [r3, #10]
        }

        if(size.y > lv_obj_get_height(label) && hor_anim == false) {
 8020b88:	f9b7 403a 	ldrsh.w	r4, [r7, #58]	; 0x3a
 8020b8c:	6878      	ldr	r0, [r7, #4]
 8020b8e:	f7f3 f949 	bl	8013e24 <lv_obj_get_height>
 8020b92:	4603      	mov	r3, r0
 8020b94:	429c      	cmp	r4, r3
 8020b96:	dd27      	ble.n	8020be8 <lv_label_refr_text+0x214>
 8020b98:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 8020b9c:	f083 0301 	eor.w	r3, r3, #1
 8020ba0:	b2db      	uxtb	r3, r3
 8020ba2:	2b00      	cmp	r3, #0
 8020ba4:	d020      	beq.n	8020be8 <lv_label_refr_text+0x214>
            anim.end     = lv_obj_get_height(label) - size.y - (lv_font_get_line_height(font));
 8020ba6:	6878      	ldr	r0, [r7, #4]
 8020ba8:	f7f3 f93c 	bl	8013e24 <lv_obj_get_height>
 8020bac:	4603      	mov	r3, r0
 8020bae:	461a      	mov	r2, r3
 8020bb0:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8020bb4:	1ad4      	subs	r4, r2, r3
 8020bb6:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8020bb8:	f7fe ffde 	bl	801fb78 <lv_font_get_line_height>
 8020bbc:	4603      	mov	r3, r0
 8020bbe:	1ae3      	subs	r3, r4, r3
 8020bc0:	623b      	str	r3, [r7, #32]
            anim.exec_cb = (lv_anim_exec_xcb_t)lv_label_set_offset_y;
 8020bc2:	4b73      	ldr	r3, [pc, #460]	; (8020d90 <lv_label_refr_text+0x3bc>)
 8020bc4:	613b      	str	r3, [r7, #16]

            anim.time = lv_anim_speed_to_time(ext->anim_speed, anim.start, anim.end);
 8020bc6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020bc8:	8b9b      	ldrh	r3, [r3, #28]
 8020bca:	69fa      	ldr	r2, [r7, #28]
 8020bcc:	b211      	sxth	r1, r2
 8020bce:	6a3a      	ldr	r2, [r7, #32]
 8020bd0:	b212      	sxth	r2, r2
 8020bd2:	4618      	mov	r0, r3
 8020bd4:	f7fc fc4a 	bl	801d46c <lv_anim_speed_to_time>
 8020bd8:	4603      	mov	r3, r0
 8020bda:	84bb      	strh	r3, [r7, #36]	; 0x24
            lv_anim_create(&anim);
 8020bdc:	f107 030c 	add.w	r3, r7, #12
 8020be0:	4618      	mov	r0, r3
 8020be2:	f7fc fbcb 	bl	801d37c <lv_anim_create>
 8020be6:	e18d      	b.n	8020f04 <lv_label_refr_text+0x530>
        } else {
            /*Delete the offset animation if not required*/
            lv_anim_del(label, (lv_anim_exec_xcb_t)lv_label_set_offset_y);
 8020be8:	4969      	ldr	r1, [pc, #420]	; (8020d90 <lv_label_refr_text+0x3bc>)
 8020bea:	6878      	ldr	r0, [r7, #4]
 8020bec:	f7fc fc06 	bl	801d3fc <lv_anim_del>
            ext->offset.y = 0;
 8020bf0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020bf2:	2200      	movs	r2, #0
 8020bf4:	819a      	strh	r2, [r3, #12]
 8020bf6:	e185      	b.n	8020f04 <lv_label_refr_text+0x530>
        }
#endif
    }
    /*In roll inf. mode keep the size but start offset animations*/
    else if(ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) {
 8020bf8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020bfa:	7f9b      	ldrb	r3, [r3, #30]
 8020bfc:	f003 0307 	and.w	r3, r3, #7
 8020c00:	b2db      	uxtb	r3, r3
 8020c02:	2b04      	cmp	r3, #4
 8020c04:	f040 809c 	bne.w	8020d40 <lv_label_refr_text+0x36c>
#if LV_USE_ANIMATION
        lv_anim_t anim;
        anim.var      = label;
 8020c08:	687b      	ldr	r3, [r7, #4]
 8020c0a:	60fb      	str	r3, [r7, #12]
        anim.repeat   = 1;
 8020c0c:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 8020c10:	f043 0302 	orr.w	r3, r3, #2
 8020c14:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
        anim.playback = 0;
 8020c18:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 8020c1c:	f36f 0300 	bfc	r3, #0, #1
 8020c20:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
        anim.start    = 0;
 8020c24:	2300      	movs	r3, #0
 8020c26:	61fb      	str	r3, [r7, #28]
        anim.act_time = -(((lv_font_get_glyph_width(style->text.font, ' ', ' ') + style->text.letter_space) * 1000) /
 8020c28:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8020c2a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8020c2c:	2220      	movs	r2, #32
 8020c2e:	2120      	movs	r1, #32
 8020c30:	4618      	mov	r0, r3
 8020c32:	f7fb fe97 	bl	801c964 <lv_font_get_glyph_width>
 8020c36:	4603      	mov	r3, r0
 8020c38:	461a      	mov	r2, r3
 8020c3a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8020c3c:	f9b3 3028 	ldrsh.w	r3, [r3, #40]	; 0x28
 8020c40:	4413      	add	r3, r2
 8020c42:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8020c46:	fb02 f303 	mul.w	r3, r2, r3
                          ext->anim_speed) *
 8020c4a:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8020c4c:	8b92      	ldrh	r2, [r2, #28]
        anim.act_time = -(((lv_font_get_glyph_width(style->text.font, ' ', ' ') + style->text.letter_space) * 1000) /
 8020c4e:	fb93 f3f2 	sdiv	r3, r3, r2
 8020c52:	b29b      	uxth	r3, r3
 8020c54:	461a      	mov	r2, r3
 8020c56:	009b      	lsls	r3, r3, #2
 8020c58:	1ad3      	subs	r3, r2, r3
 8020c5a:	b29b      	uxth	r3, r3
 8020c5c:	b21b      	sxth	r3, r3
 8020c5e:	84fb      	strh	r3, [r7, #38]	; 0x26
                        LV_LABEL_WAIT_CHAR_COUNT;
        anim.ready_cb       = NULL;
 8020c60:	2300      	movs	r3, #0
 8020c62:	61bb      	str	r3, [r7, #24]
        anim.path_cb        = lv_anim_path_linear;
 8020c64:	4b48      	ldr	r3, [pc, #288]	; (8020d88 <lv_label_refr_text+0x3b4>)
 8020c66:	617b      	str	r3, [r7, #20]
        anim.playback_pause = 0;
 8020c68:	2300      	movs	r3, #0
 8020c6a:	853b      	strh	r3, [r7, #40]	; 0x28
        anim.repeat_pause   = 0;
 8020c6c:	2300      	movs	r3, #0
 8020c6e:	857b      	strh	r3, [r7, #42]	; 0x2a

        bool hor_anim = false;
 8020c70:	2300      	movs	r3, #0
 8020c72:	f887 305b 	strb.w	r3, [r7, #91]	; 0x5b
        if(size.x > lv_obj_get_width(label)) {
 8020c76:	f9b7 4038 	ldrsh.w	r4, [r7, #56]	; 0x38
 8020c7a:	6878      	ldr	r0, [r7, #4]
 8020c7c:	f7f3 f8c4 	bl	8013e08 <lv_obj_get_width>
 8020c80:	4603      	mov	r3, r0
 8020c82:	429c      	cmp	r4, r3
 8020c84:	dd22      	ble.n	8020ccc <lv_label_refr_text+0x2f8>
            anim.end     = -size.x - lv_font_get_glyph_width(font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT;
 8020c86:	2220      	movs	r2, #32
 8020c88:	2120      	movs	r1, #32
 8020c8a:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8020c8c:	f7fb fe6a 	bl	801c964 <lv_font_get_glyph_width>
 8020c90:	4603      	mov	r3, r0
 8020c92:	461a      	mov	r2, r3
 8020c94:	009b      	lsls	r3, r3, #2
 8020c96:	1ad3      	subs	r3, r2, r3
 8020c98:	f9b7 2038 	ldrsh.w	r2, [r7, #56]	; 0x38
 8020c9c:	1a9b      	subs	r3, r3, r2
 8020c9e:	623b      	str	r3, [r7, #32]
            anim.exec_cb = (lv_anim_exec_xcb_t)lv_label_set_offset_x;
 8020ca0:	4b3a      	ldr	r3, [pc, #232]	; (8020d8c <lv_label_refr_text+0x3b8>)
 8020ca2:	613b      	str	r3, [r7, #16]
            anim.time    = lv_anim_speed_to_time(ext->anim_speed, anim.start, anim.end);
 8020ca4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020ca6:	8b9b      	ldrh	r3, [r3, #28]
 8020ca8:	69fa      	ldr	r2, [r7, #28]
 8020caa:	b211      	sxth	r1, r2
 8020cac:	6a3a      	ldr	r2, [r7, #32]
 8020cae:	b212      	sxth	r2, r2
 8020cb0:	4618      	mov	r0, r3
 8020cb2:	f7fc fbdb 	bl	801d46c <lv_anim_speed_to_time>
 8020cb6:	4603      	mov	r3, r0
 8020cb8:	84bb      	strh	r3, [r7, #36]	; 0x24
            lv_anim_create(&anim);
 8020cba:	f107 030c 	add.w	r3, r7, #12
 8020cbe:	4618      	mov	r0, r3
 8020cc0:	f7fc fb5c 	bl	801d37c <lv_anim_create>
            hor_anim = true;
 8020cc4:	2301      	movs	r3, #1
 8020cc6:	f887 305b 	strb.w	r3, [r7, #91]	; 0x5b
 8020cca:	e006      	b.n	8020cda <lv_label_refr_text+0x306>
        } else {
            /*Delete the offset animation if not required*/
            lv_anim_del(label, (lv_anim_exec_xcb_t)lv_label_set_offset_x);
 8020ccc:	492f      	ldr	r1, [pc, #188]	; (8020d8c <lv_label_refr_text+0x3b8>)
 8020cce:	6878      	ldr	r0, [r7, #4]
 8020cd0:	f7fc fb94 	bl	801d3fc <lv_anim_del>
            ext->offset.x = 0;
 8020cd4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020cd6:	2200      	movs	r2, #0
 8020cd8:	815a      	strh	r2, [r3, #10]
        }

        if(size.y > lv_obj_get_height(label) && hor_anim == false) {
 8020cda:	f9b7 403a 	ldrsh.w	r4, [r7, #58]	; 0x3a
 8020cde:	6878      	ldr	r0, [r7, #4]
 8020ce0:	f7f3 f8a0 	bl	8013e24 <lv_obj_get_height>
 8020ce4:	4603      	mov	r3, r0
 8020ce6:	429c      	cmp	r4, r3
 8020ce8:	dd22      	ble.n	8020d30 <lv_label_refr_text+0x35c>
 8020cea:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 8020cee:	f083 0301 	eor.w	r3, r3, #1
 8020cf2:	b2db      	uxtb	r3, r3
 8020cf4:	2b00      	cmp	r3, #0
 8020cf6:	d01b      	beq.n	8020d30 <lv_label_refr_text+0x35c>
            anim.end     = -size.y - (lv_font_get_line_height(font));
 8020cf8:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8020cfc:	425c      	negs	r4, r3
 8020cfe:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8020d00:	f7fe ff3a 	bl	801fb78 <lv_font_get_line_height>
 8020d04:	4603      	mov	r3, r0
 8020d06:	1ae3      	subs	r3, r4, r3
 8020d08:	623b      	str	r3, [r7, #32]
            anim.exec_cb = (lv_anim_exec_xcb_t)lv_label_set_offset_y;
 8020d0a:	4b21      	ldr	r3, [pc, #132]	; (8020d90 <lv_label_refr_text+0x3bc>)
 8020d0c:	613b      	str	r3, [r7, #16]
            anim.time    = lv_anim_speed_to_time(ext->anim_speed, anim.start, anim.end);
 8020d0e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020d10:	8b9b      	ldrh	r3, [r3, #28]
 8020d12:	69fa      	ldr	r2, [r7, #28]
 8020d14:	b211      	sxth	r1, r2
 8020d16:	6a3a      	ldr	r2, [r7, #32]
 8020d18:	b212      	sxth	r2, r2
 8020d1a:	4618      	mov	r0, r3
 8020d1c:	f7fc fba6 	bl	801d46c <lv_anim_speed_to_time>
 8020d20:	4603      	mov	r3, r0
 8020d22:	84bb      	strh	r3, [r7, #36]	; 0x24
            lv_anim_create(&anim);
 8020d24:	f107 030c 	add.w	r3, r7, #12
 8020d28:	4618      	mov	r0, r3
 8020d2a:	f7fc fb27 	bl	801d37c <lv_anim_create>
 8020d2e:	e0e9      	b.n	8020f04 <lv_label_refr_text+0x530>
        } else {
            /*Delete the offset animation if not required*/
            lv_anim_del(label, (lv_anim_exec_xcb_t)lv_label_set_offset_y);
 8020d30:	4917      	ldr	r1, [pc, #92]	; (8020d90 <lv_label_refr_text+0x3bc>)
 8020d32:	6878      	ldr	r0, [r7, #4]
 8020d34:	f7fc fb62 	bl	801d3fc <lv_anim_del>
            ext->offset.y = 0;
 8020d38:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020d3a:	2200      	movs	r2, #0
 8020d3c:	819a      	strh	r2, [r3, #12]
 8020d3e:	e0e1      	b.n	8020f04 <lv_label_refr_text+0x530>
        }
#endif
    } else if(ext->long_mode == LV_LABEL_LONG_DOT) {
 8020d40:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020d42:	7f9b      	ldrb	r3, [r3, #30]
 8020d44:	f003 0307 	and.w	r3, r3, #7
 8020d48:	b2db      	uxtb	r3, r3
 8020d4a:	2b02      	cmp	r3, #2
 8020d4c:	f040 80cd 	bne.w	8020eea <lv_label_refr_text+0x516>
        if(size.y <= lv_obj_get_height(label)) { /*No dots are required, the text is short enough*/
 8020d50:	f9b7 403a 	ldrsh.w	r4, [r7, #58]	; 0x3a
 8020d54:	6878      	ldr	r0, [r7, #4]
 8020d56:	f7f3 f865 	bl	8013e24 <lv_obj_get_height>
 8020d5a:	4603      	mov	r3, r0
 8020d5c:	429c      	cmp	r4, r3
 8020d5e:	dc04      	bgt.n	8020d6a <lv_label_refr_text+0x396>
            ext->dot_end = LV_LABEL_DOT_END_INV;
 8020d60:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020d62:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8020d66:	811a      	strh	r2, [r3, #8]
 8020d68:	e0cc      	b.n	8020f04 <lv_label_refr_text+0x530>
        } else if(lv_txt_get_encoded_length(ext->text) <= LV_LABEL_DOT_NUM) { /*Don't turn to dots all the characters*/
 8020d6a:	4b0a      	ldr	r3, [pc, #40]	; (8020d94 <lv_label_refr_text+0x3c0>)
 8020d6c:	681b      	ldr	r3, [r3, #0]
 8020d6e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8020d70:	6812      	ldr	r2, [r2, #0]
 8020d72:	4610      	mov	r0, r2
 8020d74:	4798      	blx	r3
 8020d76:	4603      	mov	r3, r0
 8020d78:	2b03      	cmp	r3, #3
 8020d7a:	d80d      	bhi.n	8020d98 <lv_label_refr_text+0x3c4>
            ext->dot_end = LV_LABEL_DOT_END_INV;
 8020d7c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020d7e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8020d82:	811a      	strh	r2, [r3, #8]
 8020d84:	e0be      	b.n	8020f04 <lv_label_refr_text+0x530>
 8020d86:	bf00      	nop
 8020d88:	0801d4cd 	.word	0x0801d4cd
 8020d8c:	08020fd5 	.word	0x08020fd5
 8020d90:	08020ffd 	.word	0x08020ffd
 8020d94:	240001e0 	.word	0x240001e0
        } else {
            lv_point_t p;
            p.x = lv_obj_get_width(label) -
 8020d98:	6878      	ldr	r0, [r7, #4]
 8020d9a:	f7f3 f835 	bl	8013e08 <lv_obj_get_width>
 8020d9e:	4603      	mov	r3, r0
 8020da0:	b29c      	uxth	r4, r3
                  (lv_font_get_glyph_width(style->text.font, '.', '.') + style->text.letter_space) *
 8020da2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8020da4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8020da6:	222e      	movs	r2, #46	; 0x2e
 8020da8:	212e      	movs	r1, #46	; 0x2e
 8020daa:	4618      	mov	r0, r3
 8020dac:	f7fb fdda 	bl	801c964 <lv_font_get_glyph_width>
 8020db0:	4603      	mov	r3, r0
 8020db2:	461a      	mov	r2, r3
 8020db4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8020db6:	f9b3 3028 	ldrsh.w	r3, [r3, #40]	; 0x28
 8020dba:	4413      	add	r3, r2
            p.x = lv_obj_get_width(label) -
 8020dbc:	b29b      	uxth	r3, r3
 8020dbe:	461a      	mov	r2, r3
 8020dc0:	009b      	lsls	r3, r3, #2
 8020dc2:	1ad3      	subs	r3, r2, r3
 8020dc4:	b29b      	uxth	r3, r3
 8020dc6:	4423      	add	r3, r4
 8020dc8:	b29b      	uxth	r3, r3
 8020dca:	b21b      	sxth	r3, r3
 8020dcc:	86bb      	strh	r3, [r7, #52]	; 0x34
                      LV_LABEL_DOT_NUM; /*Shrink with dots*/
            p.y = lv_obj_get_height(label);
 8020dce:	6878      	ldr	r0, [r7, #4]
 8020dd0:	f7f3 f828 	bl	8013e24 <lv_obj_get_height>
 8020dd4:	4603      	mov	r3, r0
 8020dd6:	86fb      	strh	r3, [r7, #54]	; 0x36
            p.y -= p.y %
 8020dd8:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8020ddc:	461c      	mov	r4, r3
                   (lv_font_get_line_height(style->text.font) + style->text.line_space); /*Round down to the last line*/
 8020dde:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8020de0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8020de2:	4618      	mov	r0, r3
 8020de4:	f7fe fec8 	bl	801fb78 <lv_font_get_line_height>
 8020de8:	4603      	mov	r3, r0
 8020dea:	461a      	mov	r2, r3
 8020dec:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8020dee:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 8020df2:	4413      	add	r3, r2
            p.y -= p.y %
 8020df4:	fb94 f2f3 	sdiv	r2, r4, r3
 8020df8:	fb03 f302 	mul.w	r3, r3, r2
 8020dfc:	1ae3      	subs	r3, r4, r3
 8020dfe:	f9b7 2036 	ldrsh.w	r2, [r7, #54]	; 0x36
 8020e02:	b292      	uxth	r2, r2
 8020e04:	b29b      	uxth	r3, r3
 8020e06:	1ad3      	subs	r3, r2, r3
 8020e08:	b29b      	uxth	r3, r3
 8020e0a:	b21b      	sxth	r3, r3
 8020e0c:	86fb      	strh	r3, [r7, #54]	; 0x36
            p.y -= style->text.line_space;                                               /*Trim the last line space*/
 8020e0e:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8020e12:	b29a      	uxth	r2, r3
 8020e14:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8020e16:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 8020e1a:	b29b      	uxth	r3, r3
 8020e1c:	1ad3      	subs	r3, r2, r3
 8020e1e:	b29b      	uxth	r3, r3
 8020e20:	b21b      	sxth	r3, r3
 8020e22:	86fb      	strh	r3, [r7, #54]	; 0x36
            uint32_t letter_id = lv_label_get_letter_on(label, &p);
 8020e24:	f107 0334 	add.w	r3, r7, #52	; 0x34
 8020e28:	4619      	mov	r1, r3
 8020e2a:	6878      	ldr	r0, [r7, #4]
 8020e2c:	f7ff f9fa 	bl	8020224 <lv_label_get_letter_on>
 8020e30:	4603      	mov	r3, r0
 8020e32:	643b      	str	r3, [r7, #64]	; 0x40

            /*Save letters under the dots and replace them with dots*/
            uint32_t i;
            uint32_t byte_id     = lv_txt_encoded_get_byte_id(ext->text, letter_id);
 8020e34:	4b37      	ldr	r3, [pc, #220]	; (8020f14 <lv_label_refr_text+0x540>)
 8020e36:	681b      	ldr	r3, [r3, #0]
 8020e38:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8020e3a:	6812      	ldr	r2, [r2, #0]
 8020e3c:	6c39      	ldr	r1, [r7, #64]	; 0x40
 8020e3e:	4610      	mov	r0, r2
 8020e40:	4798      	blx	r3
 8020e42:	4603      	mov	r3, r0
 8020e44:	633b      	str	r3, [r7, #48]	; 0x30
            uint32_t byte_id_ori = byte_id;
 8020e46:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8020e48:	63fb      	str	r3, [r7, #60]	; 0x3c
            uint8_t len          = 0;
 8020e4a:	2300      	movs	r3, #0
 8020e4c:	f887 3053 	strb.w	r3, [r7, #83]	; 0x53
            for(i = 0; i <= LV_LABEL_DOT_NUM; i++) {
 8020e50:	2300      	movs	r3, #0
 8020e52:	657b      	str	r3, [r7, #84]	; 0x54
 8020e54:	e019      	b.n	8020e8a <lv_label_refr_text+0x4b6>
                len += lv_txt_encoded_size(&ext->text[byte_id]);
 8020e56:	4b30      	ldr	r3, [pc, #192]	; (8020f18 <lv_label_refr_text+0x544>)
 8020e58:	681b      	ldr	r3, [r3, #0]
 8020e5a:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8020e5c:	6811      	ldr	r1, [r2, #0]
 8020e5e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8020e60:	440a      	add	r2, r1
 8020e62:	4610      	mov	r0, r2
 8020e64:	4798      	blx	r3
 8020e66:	4603      	mov	r3, r0
 8020e68:	461a      	mov	r2, r3
 8020e6a:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 8020e6e:	4413      	add	r3, r2
 8020e70:	f887 3053 	strb.w	r3, [r7, #83]	; 0x53
                lv_txt_encoded_next(ext->text, &byte_id);
 8020e74:	4b29      	ldr	r3, [pc, #164]	; (8020f1c <lv_label_refr_text+0x548>)
 8020e76:	681b      	ldr	r3, [r3, #0]
 8020e78:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 8020e7a:	6812      	ldr	r2, [r2, #0]
 8020e7c:	f107 0130 	add.w	r1, r7, #48	; 0x30
 8020e80:	4610      	mov	r0, r2
 8020e82:	4798      	blx	r3
            for(i = 0; i <= LV_LABEL_DOT_NUM; i++) {
 8020e84:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8020e86:	3301      	adds	r3, #1
 8020e88:	657b      	str	r3, [r7, #84]	; 0x54
 8020e8a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8020e8c:	2b03      	cmp	r3, #3
 8020e8e:	d9e2      	bls.n	8020e56 <lv_label_refr_text+0x482>
            }

            if(lv_label_set_dot_tmp(label, &ext->text[byte_id_ori], len)) {
 8020e90:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020e92:	681a      	ldr	r2, [r3, #0]
 8020e94:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8020e96:	4413      	add	r3, r2
 8020e98:	f897 2053 	ldrb.w	r2, [r7, #83]	; 0x53
 8020e9c:	b292      	uxth	r2, r2
 8020e9e:	4619      	mov	r1, r3
 8020ea0:	6878      	ldr	r0, [r7, #4]
 8020ea2:	f000 f8bf 	bl	8021024 <lv_label_set_dot_tmp>
 8020ea6:	4603      	mov	r3, r0
 8020ea8:	2b00      	cmp	r3, #0
 8020eaa:	d02b      	beq.n	8020f04 <lv_label_refr_text+0x530>
                for(i = 0; i < LV_LABEL_DOT_NUM; i++) {
 8020eac:	2300      	movs	r3, #0
 8020eae:	657b      	str	r3, [r7, #84]	; 0x54
 8020eb0:	e00a      	b.n	8020ec8 <lv_label_refr_text+0x4f4>
                    ext->text[byte_id_ori + i] = '.';
 8020eb2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020eb4:	681a      	ldr	r2, [r3, #0]
 8020eb6:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 8020eb8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8020eba:	440b      	add	r3, r1
 8020ebc:	4413      	add	r3, r2
 8020ebe:	222e      	movs	r2, #46	; 0x2e
 8020ec0:	701a      	strb	r2, [r3, #0]
                for(i = 0; i < LV_LABEL_DOT_NUM; i++) {
 8020ec2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8020ec4:	3301      	adds	r3, #1
 8020ec6:	657b      	str	r3, [r7, #84]	; 0x54
 8020ec8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8020eca:	2b02      	cmp	r3, #2
 8020ecc:	d9f1      	bls.n	8020eb2 <lv_label_refr_text+0x4de>
                }
                ext->text[byte_id_ori + LV_LABEL_DOT_NUM] = '\0';
 8020ece:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020ed0:	681a      	ldr	r2, [r3, #0]
 8020ed2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8020ed4:	3303      	adds	r3, #3
 8020ed6:	4413      	add	r3, r2
 8020ed8:	2200      	movs	r2, #0
 8020eda:	701a      	strb	r2, [r3, #0]
                ext->dot_end                              = letter_id + LV_LABEL_DOT_NUM;
 8020edc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8020ede:	b29b      	uxth	r3, r3
 8020ee0:	3303      	adds	r3, #3
 8020ee2:	b29a      	uxth	r2, r3
 8020ee4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020ee6:	811a      	strh	r2, [r3, #8]
 8020ee8:	e00c      	b.n	8020f04 <lv_label_refr_text+0x530>
            }
        }
    }
    /*In break mode only the height can change*/
    else if(ext->long_mode == LV_LABEL_LONG_BREAK) {
 8020eea:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8020eec:	7f9b      	ldrb	r3, [r3, #30]
 8020eee:	f003 0307 	and.w	r3, r3, #7
 8020ef2:	b2db      	uxtb	r3, r3
 8020ef4:	2b01      	cmp	r3, #1
 8020ef6:	d105      	bne.n	8020f04 <lv_label_refr_text+0x530>
        lv_obj_set_height(label, size.y);
 8020ef8:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8020efc:	4619      	mov	r1, r3
 8020efe:	6878      	ldr	r0, [r7, #4]
 8020f00:	f7f2 f8b0 	bl	8013064 <lv_obj_set_height>
    /*Do not set the size in Clip mode*/
    else if(ext->long_mode == LV_LABEL_LONG_CROP) {
        /*Do nothing*/
    }

    lv_obj_invalidate(label);
 8020f04:	6878      	ldr	r0, [r7, #4]
 8020f06:	f7f1 feb1 	bl	8012c6c <lv_obj_invalidate>
 8020f0a:	e000      	b.n	8020f0e <lv_label_refr_text+0x53a>
    if(ext->text == NULL) return;
 8020f0c:	bf00      	nop
}
 8020f0e:	3764      	adds	r7, #100	; 0x64
 8020f10:	46bd      	mov	sp, r7
 8020f12:	bd90      	pop	{r4, r7, pc}
 8020f14:	240001d8 	.word	0x240001d8
 8020f18:	240001cc 	.word	0x240001cc
 8020f1c:	240001d0 	.word	0x240001d0

08020f20 <lv_label_revert_dots>:

static void lv_label_revert_dots(lv_obj_t * label)
{
 8020f20:	b580      	push	{r7, lr}
 8020f22:	b088      	sub	sp, #32
 8020f24:	af00      	add	r7, sp, #0
 8020f26:	6078      	str	r0, [r7, #4]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 8020f28:	6878      	ldr	r0, [r7, #4]
 8020f2a:	f7f3 f844 	bl	8013fb6 <lv_obj_get_ext_attr>
 8020f2e:	61b8      	str	r0, [r7, #24]
    if(ext->long_mode != LV_LABEL_LONG_DOT) return;
 8020f30:	69bb      	ldr	r3, [r7, #24]
 8020f32:	7f9b      	ldrb	r3, [r3, #30]
 8020f34:	f003 0307 	and.w	r3, r3, #7
 8020f38:	b2db      	uxtb	r3, r3
 8020f3a:	2b02      	cmp	r3, #2
 8020f3c:	d142      	bne.n	8020fc4 <lv_label_revert_dots+0xa4>
    if(ext->dot_end == LV_LABEL_DOT_END_INV) return;
 8020f3e:	69bb      	ldr	r3, [r7, #24]
 8020f40:	891b      	ldrh	r3, [r3, #8]
 8020f42:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8020f46:	4293      	cmp	r3, r2
 8020f48:	d03e      	beq.n	8020fc8 <lv_label_revert_dots+0xa8>
    uint32_t letter_i = ext->dot_end - LV_LABEL_DOT_NUM;
 8020f4a:	69bb      	ldr	r3, [r7, #24]
 8020f4c:	891b      	ldrh	r3, [r3, #8]
 8020f4e:	3b03      	subs	r3, #3
 8020f50:	617b      	str	r3, [r7, #20]
    uint32_t byte_i   = lv_txt_encoded_get_byte_id(ext->text, letter_i);
 8020f52:	4b1f      	ldr	r3, [pc, #124]	; (8020fd0 <lv_label_revert_dots+0xb0>)
 8020f54:	681b      	ldr	r3, [r3, #0]
 8020f56:	69ba      	ldr	r2, [r7, #24]
 8020f58:	6812      	ldr	r2, [r2, #0]
 8020f5a:	6979      	ldr	r1, [r7, #20]
 8020f5c:	4610      	mov	r0, r2
 8020f5e:	4798      	blx	r3
 8020f60:	6138      	str	r0, [r7, #16]

    /*Restore the characters*/
    uint8_t i      = 0;
 8020f62:	2300      	movs	r3, #0
 8020f64:	77fb      	strb	r3, [r7, #31]
    char * dot_tmp = lv_label_get_dot_tmp(label);
 8020f66:	6878      	ldr	r0, [r7, #4]
 8020f68:	f000 f89f 	bl	80210aa <lv_label_get_dot_tmp>
 8020f6c:	60f8      	str	r0, [r7, #12]
    while(ext->text[byte_i + i] != '\0') {
 8020f6e:	e00d      	b.n	8020f8c <lv_label_revert_dots+0x6c>
        ext->text[byte_i + i] = dot_tmp[i];
 8020f70:	7ffb      	ldrb	r3, [r7, #31]
 8020f72:	68fa      	ldr	r2, [r7, #12]
 8020f74:	441a      	add	r2, r3
 8020f76:	69bb      	ldr	r3, [r7, #24]
 8020f78:	6819      	ldr	r1, [r3, #0]
 8020f7a:	7ff8      	ldrb	r0, [r7, #31]
 8020f7c:	693b      	ldr	r3, [r7, #16]
 8020f7e:	4403      	add	r3, r0
 8020f80:	440b      	add	r3, r1
 8020f82:	7812      	ldrb	r2, [r2, #0]
 8020f84:	701a      	strb	r2, [r3, #0]
        i++;
 8020f86:	7ffb      	ldrb	r3, [r7, #31]
 8020f88:	3301      	adds	r3, #1
 8020f8a:	77fb      	strb	r3, [r7, #31]
    while(ext->text[byte_i + i] != '\0') {
 8020f8c:	69bb      	ldr	r3, [r7, #24]
 8020f8e:	681a      	ldr	r2, [r3, #0]
 8020f90:	7ff9      	ldrb	r1, [r7, #31]
 8020f92:	693b      	ldr	r3, [r7, #16]
 8020f94:	440b      	add	r3, r1
 8020f96:	4413      	add	r3, r2
 8020f98:	781b      	ldrb	r3, [r3, #0]
 8020f9a:	2b00      	cmp	r3, #0
 8020f9c:	d1e8      	bne.n	8020f70 <lv_label_revert_dots+0x50>
    }
    ext->text[byte_i + i] = dot_tmp[i];
 8020f9e:	7ffb      	ldrb	r3, [r7, #31]
 8020fa0:	68fa      	ldr	r2, [r7, #12]
 8020fa2:	441a      	add	r2, r3
 8020fa4:	69bb      	ldr	r3, [r7, #24]
 8020fa6:	6819      	ldr	r1, [r3, #0]
 8020fa8:	7ff8      	ldrb	r0, [r7, #31]
 8020faa:	693b      	ldr	r3, [r7, #16]
 8020fac:	4403      	add	r3, r0
 8020fae:	440b      	add	r3, r1
 8020fb0:	7812      	ldrb	r2, [r2, #0]
 8020fb2:	701a      	strb	r2, [r3, #0]
    lv_label_dot_tmp_free(label);
 8020fb4:	6878      	ldr	r0, [r7, #4]
 8020fb6:	f000 f890 	bl	80210da <lv_label_dot_tmp_free>

    ext->dot_end = LV_LABEL_DOT_END_INV;
 8020fba:	69bb      	ldr	r3, [r7, #24]
 8020fbc:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8020fc0:	811a      	strh	r2, [r3, #8]
 8020fc2:	e002      	b.n	8020fca <lv_label_revert_dots+0xaa>
    if(ext->long_mode != LV_LABEL_LONG_DOT) return;
 8020fc4:	bf00      	nop
 8020fc6:	e000      	b.n	8020fca <lv_label_revert_dots+0xaa>
    if(ext->dot_end == LV_LABEL_DOT_END_INV) return;
 8020fc8:	bf00      	nop
}
 8020fca:	3720      	adds	r7, #32
 8020fcc:	46bd      	mov	sp, r7
 8020fce:	bd80      	pop	{r7, pc}
 8020fd0:	240001d8 	.word	0x240001d8

08020fd4 <lv_label_set_offset_x>:

#if LV_USE_ANIMATION
static void lv_label_set_offset_x(lv_obj_t * label, lv_coord_t x)
{
 8020fd4:	b580      	push	{r7, lr}
 8020fd6:	b084      	sub	sp, #16
 8020fd8:	af00      	add	r7, sp, #0
 8020fda:	6078      	str	r0, [r7, #4]
 8020fdc:	460b      	mov	r3, r1
 8020fde:	807b      	strh	r3, [r7, #2]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 8020fe0:	6878      	ldr	r0, [r7, #4]
 8020fe2:	f7f2 ffe8 	bl	8013fb6 <lv_obj_get_ext_attr>
 8020fe6:	60f8      	str	r0, [r7, #12]
    ext->offset.x        = x;
 8020fe8:	68fb      	ldr	r3, [r7, #12]
 8020fea:	887a      	ldrh	r2, [r7, #2]
 8020fec:	815a      	strh	r2, [r3, #10]
    lv_obj_invalidate(label);
 8020fee:	6878      	ldr	r0, [r7, #4]
 8020ff0:	f7f1 fe3c 	bl	8012c6c <lv_obj_invalidate>
}
 8020ff4:	bf00      	nop
 8020ff6:	3710      	adds	r7, #16
 8020ff8:	46bd      	mov	sp, r7
 8020ffa:	bd80      	pop	{r7, pc}

08020ffc <lv_label_set_offset_y>:

static void lv_label_set_offset_y(lv_obj_t * label, lv_coord_t y)
{
 8020ffc:	b580      	push	{r7, lr}
 8020ffe:	b084      	sub	sp, #16
 8021000:	af00      	add	r7, sp, #0
 8021002:	6078      	str	r0, [r7, #4]
 8021004:	460b      	mov	r3, r1
 8021006:	807b      	strh	r3, [r7, #2]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 8021008:	6878      	ldr	r0, [r7, #4]
 802100a:	f7f2 ffd4 	bl	8013fb6 <lv_obj_get_ext_attr>
 802100e:	60f8      	str	r0, [r7, #12]
    ext->offset.y        = y;
 8021010:	68fb      	ldr	r3, [r7, #12]
 8021012:	887a      	ldrh	r2, [r7, #2]
 8021014:	819a      	strh	r2, [r3, #12]
    lv_obj_invalidate(label);
 8021016:	6878      	ldr	r0, [r7, #4]
 8021018:	f7f1 fe28 	bl	8012c6c <lv_obj_invalidate>
}
 802101c:	bf00      	nop
 802101e:	3710      	adds	r7, #16
 8021020:	46bd      	mov	sp, r7
 8021022:	bd80      	pop	{r7, pc}

08021024 <lv_label_set_dot_tmp>:
 * @param label pointer to label object
 * @param len Number of characters to store.
 * @return true on success.
 */
static bool lv_label_set_dot_tmp(lv_obj_t * label, char * data, uint16_t len)
{
 8021024:	b580      	push	{r7, lr}
 8021026:	b086      	sub	sp, #24
 8021028:	af00      	add	r7, sp, #0
 802102a:	60f8      	str	r0, [r7, #12]
 802102c:	60b9      	str	r1, [r7, #8]
 802102e:	4613      	mov	r3, r2
 8021030:	80fb      	strh	r3, [r7, #6]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 8021032:	68f8      	ldr	r0, [r7, #12]
 8021034:	f7f2 ffbf 	bl	8013fb6 <lv_obj_get_ext_attr>
 8021038:	6178      	str	r0, [r7, #20]
    lv_label_dot_tmp_free(label); /* Deallocate any existing space */
 802103a:	68f8      	ldr	r0, [r7, #12]
 802103c:	f000 f84d 	bl	80210da <lv_label_dot_tmp_free>
    if(len > sizeof(char *)) {
 8021040:	88fb      	ldrh	r3, [r7, #6]
 8021042:	2b04      	cmp	r3, #4
 8021044:	d920      	bls.n	8021088 <lv_label_set_dot_tmp+0x64>
        /* Memory needs to be allocated. Allocates an additional byte
         * for a NULL-terminator so it can be copied. */
        ext->dot.tmp_ptr = lv_mem_alloc(len + 1);
 8021046:	88fb      	ldrh	r3, [r7, #6]
 8021048:	3301      	adds	r3, #1
 802104a:	4618      	mov	r0, r3
 802104c:	f7fd f830 	bl	801e0b0 <lv_mem_alloc>
 8021050:	4602      	mov	r2, r0
 8021052:	697b      	ldr	r3, [r7, #20]
 8021054:	605a      	str	r2, [r3, #4]
        if(ext->dot.tmp_ptr == NULL) {
 8021056:	697b      	ldr	r3, [r7, #20]
 8021058:	685b      	ldr	r3, [r3, #4]
 802105a:	2b00      	cmp	r3, #0
 802105c:	d101      	bne.n	8021062 <lv_label_set_dot_tmp+0x3e>
            LV_LOG_ERROR("Failed to allocate memory for dot_tmp_ptr");
            return false;
 802105e:	2300      	movs	r3, #0
 8021060:	e01f      	b.n	80210a2 <lv_label_set_dot_tmp+0x7e>
        }
        memcpy(ext->dot.tmp_ptr, data, len);
 8021062:	697b      	ldr	r3, [r7, #20]
 8021064:	685b      	ldr	r3, [r3, #4]
 8021066:	88fa      	ldrh	r2, [r7, #6]
 8021068:	68b9      	ldr	r1, [r7, #8]
 802106a:	4618      	mov	r0, r3
 802106c:	f000 fdf4 	bl	8021c58 <memcpy>
        ext->dot.tmp_ptr[len] = '\0';
 8021070:	697b      	ldr	r3, [r7, #20]
 8021072:	685a      	ldr	r2, [r3, #4]
 8021074:	88fb      	ldrh	r3, [r7, #6]
 8021076:	4413      	add	r3, r2
 8021078:	2200      	movs	r2, #0
 802107a:	701a      	strb	r2, [r3, #0]
        ext->dot_tmp_alloc    = true;
 802107c:	697a      	ldr	r2, [r7, #20]
 802107e:	7fd3      	ldrb	r3, [r2, #31]
 8021080:	f043 0302 	orr.w	r3, r3, #2
 8021084:	77d3      	strb	r3, [r2, #31]
 8021086:	e00b      	b.n	80210a0 <lv_label_set_dot_tmp+0x7c>
    } else {
        /* Characters can be directly stored in object */
        ext->dot_tmp_alloc = false;
 8021088:	697a      	ldr	r2, [r7, #20]
 802108a:	7fd3      	ldrb	r3, [r2, #31]
 802108c:	f36f 0341 	bfc	r3, #1, #1
 8021090:	77d3      	strb	r3, [r2, #31]
        memcpy(ext->dot.tmp, data, len);
 8021092:	697b      	ldr	r3, [r7, #20]
 8021094:	3304      	adds	r3, #4
 8021096:	88fa      	ldrh	r2, [r7, #6]
 8021098:	68b9      	ldr	r1, [r7, #8]
 802109a:	4618      	mov	r0, r3
 802109c:	f000 fddc 	bl	8021c58 <memcpy>
    }
    return true;
 80210a0:	2301      	movs	r3, #1
}
 80210a2:	4618      	mov	r0, r3
 80210a4:	3718      	adds	r7, #24
 80210a6:	46bd      	mov	sp, r7
 80210a8:	bd80      	pop	{r7, pc}

080210aa <lv_label_get_dot_tmp>:
 * Get the stored dot_tmp characters
 * @param label pointer to label object
 * @return char pointer to a stored characters. Is *not* necessarily NULL-terminated.
 */
static char * lv_label_get_dot_tmp(lv_obj_t * label)
{
 80210aa:	b580      	push	{r7, lr}
 80210ac:	b084      	sub	sp, #16
 80210ae:	af00      	add	r7, sp, #0
 80210b0:	6078      	str	r0, [r7, #4]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 80210b2:	6878      	ldr	r0, [r7, #4]
 80210b4:	f7f2 ff7f 	bl	8013fb6 <lv_obj_get_ext_attr>
 80210b8:	60f8      	str	r0, [r7, #12]
    if(ext->dot_tmp_alloc) {
 80210ba:	68fb      	ldr	r3, [r7, #12]
 80210bc:	7fdb      	ldrb	r3, [r3, #31]
 80210be:	f003 0302 	and.w	r3, r3, #2
 80210c2:	b2db      	uxtb	r3, r3
 80210c4:	2b00      	cmp	r3, #0
 80210c6:	d002      	beq.n	80210ce <lv_label_get_dot_tmp+0x24>
        return ext->dot.tmp_ptr;
 80210c8:	68fb      	ldr	r3, [r7, #12]
 80210ca:	685b      	ldr	r3, [r3, #4]
 80210cc:	e001      	b.n	80210d2 <lv_label_get_dot_tmp+0x28>
    } else {
        return ext->dot.tmp;
 80210ce:	68fb      	ldr	r3, [r7, #12]
 80210d0:	3304      	adds	r3, #4
    }
}
 80210d2:	4618      	mov	r0, r3
 80210d4:	3710      	adds	r7, #16
 80210d6:	46bd      	mov	sp, r7
 80210d8:	bd80      	pop	{r7, pc}

080210da <lv_label_dot_tmp_free>:
 * Free the dot_tmp_ptr field if it was previously allocated.
 * Always clears the field
 * @param label pointer to label object.
 */
static void lv_label_dot_tmp_free(lv_obj_t * label)
{
 80210da:	b580      	push	{r7, lr}
 80210dc:	b084      	sub	sp, #16
 80210de:	af00      	add	r7, sp, #0
 80210e0:	6078      	str	r0, [r7, #4]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 80210e2:	6878      	ldr	r0, [r7, #4]
 80210e4:	f7f2 ff67 	bl	8013fb6 <lv_obj_get_ext_attr>
 80210e8:	60f8      	str	r0, [r7, #12]
    if(ext->dot_tmp_alloc && ext->dot.tmp_ptr) {
 80210ea:	68fb      	ldr	r3, [r7, #12]
 80210ec:	7fdb      	ldrb	r3, [r3, #31]
 80210ee:	f003 0302 	and.w	r3, r3, #2
 80210f2:	b2db      	uxtb	r3, r3
 80210f4:	2b00      	cmp	r3, #0
 80210f6:	d008      	beq.n	802110a <lv_label_dot_tmp_free+0x30>
 80210f8:	68fb      	ldr	r3, [r7, #12]
 80210fa:	685b      	ldr	r3, [r3, #4]
 80210fc:	2b00      	cmp	r3, #0
 80210fe:	d004      	beq.n	802110a <lv_label_dot_tmp_free+0x30>
        lv_mem_free(ext->dot.tmp_ptr);
 8021100:	68fb      	ldr	r3, [r7, #12]
 8021102:	685b      	ldr	r3, [r3, #4]
 8021104:	4618      	mov	r0, r3
 8021106:	f7fd f813 	bl	801e130 <lv_mem_free>
    }
    ext->dot_tmp_alloc = false;
 802110a:	68fa      	ldr	r2, [r7, #12]
 802110c:	7fd3      	ldrb	r3, [r2, #31]
 802110e:	f36f 0341 	bfc	r3, #1, #1
 8021112:	77d3      	strb	r3, [r2, #31]
    ext->dot.tmp_ptr   = NULL;
 8021114:	68fb      	ldr	r3, [r7, #12]
 8021116:	2200      	movs	r2, #0
 8021118:	605a      	str	r2, [r3, #4]
}
 802111a:	bf00      	nop
 802111c:	3710      	adds	r7, #16
 802111e:	46bd      	mov	sp, r7
 8021120:	bd80      	pop	{r7, pc}
	...

08021124 <lv_theme_get_current>:
/**
 * Get the current system theme.
 * @return pointer to the current system theme. NULL if not set.
 */
lv_theme_t * lv_theme_get_current(void)
{
 8021124:	b480      	push	{r7}
 8021126:	af00      	add	r7, sp, #0
#if LV_THEME_LIVE_UPDATE == 0
    return current_theme;
 8021128:	4b03      	ldr	r3, [pc, #12]	; (8021138 <lv_theme_get_current+0x14>)
 802112a:	681b      	ldr	r3, [r3, #0]
    if(!inited)
        return NULL;
    else
        return &current_theme;
#endif
}
 802112c:	4618      	mov	r0, r3
 802112e:	46bd      	mov	sp, r7
 8021130:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021134:	4770      	bx	lr
 8021136:	bf00      	nop
 8021138:	24062410 	.word	0x24062410

0802113c <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
 802113c:	f8df d034 	ldr.w	sp, [pc, #52]	; 8021174 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 8021140:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 8021142:	e003      	b.n	802114c <LoopCopyDataInit>

08021144 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 8021144:	4b0c      	ldr	r3, [pc, #48]	; (8021178 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 8021146:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 8021148:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 802114a:	3104      	adds	r1, #4

0802114c <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 802114c:	480b      	ldr	r0, [pc, #44]	; (802117c <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 802114e:	4b0c      	ldr	r3, [pc, #48]	; (8021180 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 8021150:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 8021152:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 8021154:	d3f6      	bcc.n	8021144 <CopyDataInit>
  ldr  r2, =_sbss
 8021156:	4a0b      	ldr	r2, [pc, #44]	; (8021184 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 8021158:	e002      	b.n	8021160 <LoopFillZerobss>

0802115a <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 802115a:	2300      	movs	r3, #0
  str  r3, [r2], #4
 802115c:	f842 3b04 	str.w	r3, [r2], #4

08021160 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8021160:	4b09      	ldr	r3, [pc, #36]	; (8021188 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 8021162:	429a      	cmp	r2, r3
  bcc  FillZerobss
 8021164:	d3f9      	bcc.n	802115a <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 8021166:	f7f0 ffdb 	bl	8012120 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 802116a:	f000 fd4f 	bl	8021c0c <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 802116e:	f7ee f9c3 	bl	800f4f8 <main>
  bx  lr    
 8021172:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
 8021174:	24080000 	.word	0x24080000
  ldr  r3, =_sidata
 8021178:	080d9e4c 	.word	0x080d9e4c
  ldr  r0, =_sdata
 802117c:	24000000 	.word	0x24000000
  ldr  r3, =_edata
 8021180:	24000248 	.word	0x24000248
  ldr  r2, =_sbss
 8021184:	24000248 	.word	0x24000248
  ldr  r3, = _ebss
 8021188:	240636a0 	.word	0x240636a0

0802118c <ADC3_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 802118c:	e7fe      	b.n	802118c <ADC3_IRQHandler>
	...

08021190 <B_tcpStart>:
  * @retval B_tcpHandle_t*: pointer to a B_tcpHandle_t struct which stores uart, task handles and other transmission information 
  */
B_tcpHandle_t* B_tcpStart(uint8_t senderID, B_uartHandle_t** transmitBuarts,
                            B_uartHandle_t* rxBuart,
                            uint8_t numTransmitBuarts,
                            CRC_HandleTypeDef* crc){
 8021190:	b580      	push	{r7, lr}
 8021192:	b088      	sub	sp, #32
 8021194:	af02      	add	r7, sp, #8
 8021196:	60b9      	str	r1, [r7, #8]
 8021198:	607a      	str	r2, [r7, #4]
 802119a:	461a      	mov	r2, r3
 802119c:	4603      	mov	r3, r0
 802119e:	73fb      	strb	r3, [r7, #15]
 80211a0:	4613      	mov	r3, r2
 80211a2:	73bb      	strb	r3, [r7, #14]
    B_tcpHandle_t *btcp;
    btcp = pvPortMalloc(sizeof(B_tcpHandle_t));
 80211a4:	2020      	movs	r0, #32
 80211a6:	f7eb ff07 	bl	800cfb8 <pvPortMalloc>
 80211aa:	6138      	str	r0, [r7, #16]
    btcp->numTransmitBuarts = numTransmitBuarts;
 80211ac:	693b      	ldr	r3, [r7, #16]
 80211ae:	7bba      	ldrb	r2, [r7, #14]
 80211b0:	721a      	strb	r2, [r3, #8]
    btcp->transmitBuarts = pvPortMalloc(sizeof(B_tcpHandle_t*)*numTransmitBuarts);
 80211b2:	7bbb      	ldrb	r3, [r7, #14]
 80211b4:	009b      	lsls	r3, r3, #2
 80211b6:	4618      	mov	r0, r3
 80211b8:	f7eb fefe 	bl	800cfb8 <pvPortMalloc>
 80211bc:	4602      	mov	r2, r0
 80211be:	693b      	ldr	r3, [r7, #16]
 80211c0:	605a      	str	r2, [r3, #4]
    for(int i = 0; i < numTransmitBuarts; i++){
 80211c2:	2300      	movs	r3, #0
 80211c4:	617b      	str	r3, [r7, #20]
 80211c6:	e00d      	b.n	80211e4 <B_tcpStart+0x54>
    	btcp->transmitBuarts[i] = transmitBuarts[i];
 80211c8:	697b      	ldr	r3, [r7, #20]
 80211ca:	009b      	lsls	r3, r3, #2
 80211cc:	68ba      	ldr	r2, [r7, #8]
 80211ce:	441a      	add	r2, r3
 80211d0:	693b      	ldr	r3, [r7, #16]
 80211d2:	6859      	ldr	r1, [r3, #4]
 80211d4:	697b      	ldr	r3, [r7, #20]
 80211d6:	009b      	lsls	r3, r3, #2
 80211d8:	440b      	add	r3, r1
 80211da:	6812      	ldr	r2, [r2, #0]
 80211dc:	601a      	str	r2, [r3, #0]
    for(int i = 0; i < numTransmitBuarts; i++){
 80211de:	697b      	ldr	r3, [r7, #20]
 80211e0:	3301      	adds	r3, #1
 80211e2:	617b      	str	r3, [r7, #20]
 80211e4:	7bbb      	ldrb	r3, [r7, #14]
 80211e6:	697a      	ldr	r2, [r7, #20]
 80211e8:	429a      	cmp	r2, r3
 80211ea:	dbed      	blt.n	80211c8 <B_tcpStart+0x38>
    }
    btcp->senderID = senderID;
 80211ec:	693b      	ldr	r3, [r7, #16]
 80211ee:	7bfa      	ldrb	r2, [r7, #15]
 80211f0:	701a      	strb	r2, [r3, #0]
    btcp->rxBuart = rxBuart;
 80211f2:	693b      	ldr	r3, [r7, #16]
 80211f4:	687a      	ldr	r2, [r7, #4]
 80211f6:	60da      	str	r2, [r3, #12]
    btcp->tcpSeqNum = 0;
 80211f8:	693b      	ldr	r3, [r7, #16]
 80211fa:	2200      	movs	r2, #0
 80211fc:	741a      	strb	r2, [r3, #16]
    btcp->crc = crc;
 80211fe:	693b      	ldr	r3, [r7, #16]
 8021200:	6a3a      	ldr	r2, [r7, #32]
 8021202:	61da      	str	r2, [r3, #28]
    btcp->txQ = xQueueCreate(TCP_TX_QUEUE_SIZE, sizeof(B_tcpPacket_t));
 8021204:	2200      	movs	r2, #0
 8021206:	2110      	movs	r1, #16
 8021208:	2040      	movs	r0, #64	; 0x40
 802120a:	f7e9 fae3 	bl	800a7d4 <xQueueGenericCreate>
 802120e:	4602      	mov	r2, r0
 8021210:	693b      	ldr	r3, [r7, #16]
 8021212:	615a      	str	r2, [r3, #20]
    //hpQ = xQueueCreate(10, sizeof(uint8_t));
    //xTaskCreate(tcpTxTask, "tcpTxTask", TCP_TRX_TASK_STACK_SIZE, btcp, TCP_TX_TASK_PRIORITY, &btcp->txTask);
    xTaskCreate(tcpRxTask, "tcpRxTask", TCP_TRX_TASK_STACK_SIZE, btcp, TCP_TX_TASK_PRIORITY, &btcp->rxTask);
 8021214:	693b      	ldr	r3, [r7, #16]
 8021216:	3318      	adds	r3, #24
 8021218:	9301      	str	r3, [sp, #4]
 802121a:	2304      	movs	r3, #4
 802121c:	9300      	str	r3, [sp, #0]
 802121e:	693b      	ldr	r3, [r7, #16]
 8021220:	f44f 7280 	mov.w	r2, #256	; 0x100
 8021224:	4904      	ldr	r1, [pc, #16]	; (8021238 <B_tcpStart+0xa8>)
 8021226:	4805      	ldr	r0, [pc, #20]	; (802123c <B_tcpStart+0xac>)
 8021228:	f7ea f8f4 	bl	800b414 <xTaskCreate>
    //xTaskCreate(highPowerTask, "highPowerTask", 1024, NULL, 5, NULL);
    return btcp;
 802122c:	693b      	ldr	r3, [r7, #16]
}
 802122e:	4618      	mov	r0, r3
 8021230:	3718      	adds	r7, #24
 8021232:	46bd      	mov	sp, r7
 8021234:	bd80      	pop	{r7, pc}
 8021236:	bf00      	nop
 8021238:	0802292c 	.word	0x0802292c
 802123c:	080213fd 	.word	0x080213fd

08021240 <B_tcpSend>:
  * @note	msg array can be up to MAX_PACKET_SIZE (256) bytes long if it does not contain values that must be escaped. 
			If it contains values that need to be escaped, the msg array can be up to (MAX_PACKET_SIZE - number_of_values_to_be_escaped) bytes long

  * @retval B_tcpHandle_t*: pointer to a B_tcpHandle_t struct which stores uart, task handles and other transmission information 
  */
void B_tcpSend(B_tcpHandle_t *btcp, uint8_t *msg, uint8_t length){
 8021240:	b580      	push	{r7, lr}
 8021242:	b08a      	sub	sp, #40	; 0x28
 8021244:	af00      	add	r7, sp, #0
 8021246:	60f8      	str	r0, [r7, #12]
 8021248:	60b9      	str	r1, [r7, #8]
 802124a:	4613      	mov	r3, r2
 802124c:	71fb      	strb	r3, [r7, #7]
	
    uint8_t *buf = pvPortMalloc(sizeof(uint8_t)*(MAX_PACKET_SIZE+8)); 
 802124e:	f44f 7084 	mov.w	r0, #264	; 0x108
 8021252:	f7eb feb1 	bl	800cfb8 <pvPortMalloc>
 8021256:	6178      	str	r0, [r7, #20]
	//Not sure why we don't do sizeof(uint8_t)*(MAX_PACKET_SIZE+8) * 2 just in case all characters need to be escaped 
    
	buf[0] = BSSR_SERIAL_START; //equal to 0xa5 (165)
 8021258:	697b      	ldr	r3, [r7, #20]
 802125a:	22a5      	movs	r2, #165	; 0xa5
 802125c:	701a      	strb	r2, [r3, #0]
    buf[1] = length;
 802125e:	697b      	ldr	r3, [r7, #20]
 8021260:	3301      	adds	r3, #1
 8021262:	79fa      	ldrb	r2, [r7, #7]
 8021264:	701a      	strb	r2, [r3, #0]
    buf[2] = btcp->senderID;
 8021266:	697b      	ldr	r3, [r7, #20]
 8021268:	3302      	adds	r3, #2
 802126a:	68fa      	ldr	r2, [r7, #12]
 802126c:	7812      	ldrb	r2, [r2, #0]
 802126e:	701a      	strb	r2, [r3, #0]
    buf[3] = btcp->tcpSeqNum;
 8021270:	697b      	ldr	r3, [r7, #20]
 8021272:	3303      	adds	r3, #3
 8021274:	68fa      	ldr	r2, [r7, #12]
 8021276:	7c12      	ldrb	r2, [r2, #16]
 8021278:	701a      	strb	r2, [r3, #0]
    memcpy(buf+4, msg, length); // Copies message into buffer
 802127a:	697b      	ldr	r3, [r7, #20]
 802127c:	3304      	adds	r3, #4
 802127e:	79fa      	ldrb	r2, [r7, #7]
 8021280:	68b9      	ldr	r1, [r7, #8]
 8021282:	4618      	mov	r0, r3
 8021284:	f000 fce8 	bl	8021c58 <memcpy>
	
    // Note the crc_result takes the One's complement of HAL_CRC_Calculate. This is done using the "~" operator
    uint32_t crc_result = ~HAL_CRC_Calculate(btcp->crc, (uint32_t*)buf, length+4);
 8021288:	68fb      	ldr	r3, [r7, #12]
 802128a:	69d8      	ldr	r0, [r3, #28]
 802128c:	79fb      	ldrb	r3, [r7, #7]
 802128e:	3304      	adds	r3, #4
 8021290:	461a      	mov	r2, r3
 8021292:	6979      	ldr	r1, [r7, #20]
 8021294:	f7df fbb4 	bl	8000a00 <HAL_CRC_Calculate>
 8021298:	4603      	mov	r3, r0
 802129a:	43db      	mvns	r3, r3
 802129c:	613b      	str	r3, [r7, #16]
    uint16_t buf_pos = 4;
 802129e:	2304      	movs	r3, #4
 80212a0:	84fb      	strh	r3, [r7, #38]	; 0x26
	
	// Note: the following if statements are to check whether some values need to escaped. If so, an escape character will be placed before the value to be escaped.
	// A value needs to be escaped if it is equal to BSSR_SERIAL_START (165) or BSSR_SERIAL_ESCAPE (90)
	
	// If length + 4 needs to be escaped, will store length + 4 in the buffer and insert BSSR_SERIAL_ESCAPE before it in the buffer
    if((length + 4) == BSSR_SERIAL_START || (length + 4) == BSSR_SERIAL_ESCAPE){
 80212a2:	79fb      	ldrb	r3, [r7, #7]
 80212a4:	2ba1      	cmp	r3, #161	; 0xa1
 80212a6:	d002      	beq.n	80212ae <B_tcpSend+0x6e>
 80212a8:	79fb      	ldrb	r3, [r7, #7]
 80212aa:	2b56      	cmp	r3, #86	; 0x56
 80212ac:	d10c      	bne.n	80212c8 <B_tcpSend+0x88>
        buf_pos++;
 80212ae:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80212b0:	3301      	adds	r3, #1
 80212b2:	84fb      	strh	r3, [r7, #38]	; 0x26
        buf[3] = length + 4;   //either serial start or escape
 80212b4:	697b      	ldr	r3, [r7, #20]
 80212b6:	3303      	adds	r3, #3
 80212b8:	79fa      	ldrb	r2, [r7, #7]
 80212ba:	3204      	adds	r2, #4
 80212bc:	b2d2      	uxtb	r2, r2
 80212be:	701a      	strb	r2, [r3, #0]
        buf[2] = BSSR_SERIAL_ESCAPE; // equal to 0x5a (90)
 80212c0:	697b      	ldr	r3, [r7, #20]
 80212c2:	3302      	adds	r3, #2
 80212c4:	225a      	movs	r2, #90	; 0x5a
 80212c6:	701a      	strb	r2, [r3, #0]
		// If true, buf_pos is 5
    }
	
	// Checks if tcpSeqNum needs to be escaped, and if so,inserts BSSR_SERIAL_ESCAPE before it in the buffer
    if(btcp->tcpSeqNum == BSSR_SERIAL_START || btcp->tcpSeqNum == BSSR_SERIAL_ESCAPE){
 80212c8:	68fb      	ldr	r3, [r7, #12]
 80212ca:	7c1b      	ldrb	r3, [r3, #16]
 80212cc:	2ba5      	cmp	r3, #165	; 0xa5
 80212ce:	d003      	beq.n	80212d8 <B_tcpSend+0x98>
 80212d0:	68fb      	ldr	r3, [r7, #12]
 80212d2:	7c1b      	ldrb	r3, [r3, #16]
 80212d4:	2b5a      	cmp	r3, #90	; 0x5a
 80212d6:	d108      	bne.n	80212ea <B_tcpSend+0xaa>
		
        buf[buf_pos -1] = BSSR_SERIAL_ESCAPE;  //either buf[3] or buf[4] is assigned escape
 80212d8:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80212da:	3b01      	subs	r3, #1
 80212dc:	697a      	ldr	r2, [r7, #20]
 80212de:	4413      	add	r3, r2
 80212e0:	225a      	movs	r2, #90	; 0x5a
 80212e2:	701a      	strb	r2, [r3, #0]
        buf_pos++;
 80212e4:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80212e6:	3301      	adds	r3, #1
 80212e8:	84fb      	strh	r3, [r7, #38]	; 0x26
    }
    buf[buf_pos -1] = btcp->tcpSeqNum; // buf_pos-1 could be 3, 4, 5
 80212ea:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80212ec:	3b01      	subs	r3, #1
 80212ee:	697a      	ldr	r2, [r7, #20]
 80212f0:	4413      	add	r3, r2
 80212f2:	68fa      	ldr	r2, [r7, #12]
 80212f4:	7c12      	ldrb	r2, [r2, #16]
 80212f6:	701a      	strb	r2, [r3, #0]
    btcp->tcpSeqNum++;
 80212f8:	68fb      	ldr	r3, [r7, #12]
 80212fa:	7c1b      	ldrb	r3, [r3, #16]
 80212fc:	3301      	adds	r3, #1
 80212fe:	b2da      	uxtb	r2, r3
 8021300:	68fb      	ldr	r3, [r7, #12]
 8021302:	741a      	strb	r2, [r3, #16]
    // at this point, buf_pos could be 4,5,6
	
	// Checks if msg[i] needs to be escaped, and if so, inserts BSSR_SERIAL_ESCAPE before it in the buffer
    for(int i = 0; i < length; i++){
 8021304:	2300      	movs	r3, #0
 8021306:	623b      	str	r3, [r7, #32]
 8021308:	e021      	b.n	802134e <B_tcpSend+0x10e>
        if(msg[i] == BSSR_SERIAL_ESCAPE || msg[i] == BSSR_SERIAL_START){ //if 90 or 165, escape
 802130a:	6a3b      	ldr	r3, [r7, #32]
 802130c:	68ba      	ldr	r2, [r7, #8]
 802130e:	4413      	add	r3, r2
 8021310:	781b      	ldrb	r3, [r3, #0]
 8021312:	2b5a      	cmp	r3, #90	; 0x5a
 8021314:	d005      	beq.n	8021322 <B_tcpSend+0xe2>
 8021316:	6a3b      	ldr	r3, [r7, #32]
 8021318:	68ba      	ldr	r2, [r7, #8]
 802131a:	4413      	add	r3, r2
 802131c:	781b      	ldrb	r3, [r3, #0]
 802131e:	2ba5      	cmp	r3, #165	; 0xa5
 8021320:	d107      	bne.n	8021332 <B_tcpSend+0xf2>
            buf[buf_pos] = BSSR_SERIAL_ESCAPE;
 8021322:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8021324:	697a      	ldr	r2, [r7, #20]
 8021326:	4413      	add	r3, r2
 8021328:	225a      	movs	r2, #90	; 0x5a
 802132a:	701a      	strb	r2, [r3, #0]
            buf_pos++;
 802132c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 802132e:	3301      	adds	r3, #1
 8021330:	84fb      	strh	r3, [r7, #38]	; 0x26
        }
        buf[buf_pos] = msg[i];
 8021332:	6a3b      	ldr	r3, [r7, #32]
 8021334:	68ba      	ldr	r2, [r7, #8]
 8021336:	441a      	add	r2, r3
 8021338:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 802133a:	6979      	ldr	r1, [r7, #20]
 802133c:	440b      	add	r3, r1
 802133e:	7812      	ldrb	r2, [r2, #0]
 8021340:	701a      	strb	r2, [r3, #0]
        buf_pos++;
 8021342:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8021344:	3301      	adds	r3, #1
 8021346:	84fb      	strh	r3, [r7, #38]	; 0x26
    for(int i = 0; i < length; i++){
 8021348:	6a3b      	ldr	r3, [r7, #32]
 802134a:	3301      	adds	r3, #1
 802134c:	623b      	str	r3, [r7, #32]
 802134e:	79fb      	ldrb	r3, [r7, #7]
 8021350:	6a3a      	ldr	r2, [r7, #32]
 8021352:	429a      	cmp	r2, r3
 8021354:	dbd9      	blt.n	802130a <B_tcpSend+0xca>
    }
	
	// Computes, stores, and checks if each crc value needs to be escaped, and if so, inserts BSSR_SERIAL_ESCAPE before it. 
    for(int i = 0; i < 4; i++){
 8021356:	2300      	movs	r3, #0
 8021358:	61fb      	str	r3, [r7, #28]
 802135a:	e02e      	b.n	80213ba <B_tcpSend+0x17a>
        buf[buf_pos] = (crc_result>>(8*(3-i))) &255;	// Don't understand this part. Not sure why bitwise right shift by so many bits would make sense. Wouldn't result be 0?
 802135c:	69fb      	ldr	r3, [r7, #28]
 802135e:	f1c3 0303 	rsb	r3, r3, #3
 8021362:	00db      	lsls	r3, r3, #3
 8021364:	693a      	ldr	r2, [r7, #16]
 8021366:	fa22 f103 	lsr.w	r1, r2, r3
 802136a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 802136c:	697a      	ldr	r2, [r7, #20]
 802136e:	4413      	add	r3, r2
 8021370:	b2ca      	uxtb	r2, r1
 8021372:	701a      	strb	r2, [r3, #0]
        // It seems like only when i is 3, would the buf[buf_pos] be a value that isn't zero
		if(buf[buf_pos] == BSSR_SERIAL_ESCAPE || buf[buf_pos] == BSSR_SERIAL_START){
 8021374:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8021376:	697a      	ldr	r2, [r7, #20]
 8021378:	4413      	add	r3, r2
 802137a:	781b      	ldrb	r3, [r3, #0]
 802137c:	2b5a      	cmp	r3, #90	; 0x5a
 802137e:	d005      	beq.n	802138c <B_tcpSend+0x14c>
 8021380:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8021382:	697a      	ldr	r2, [r7, #20]
 8021384:	4413      	add	r3, r2
 8021386:	781b      	ldrb	r3, [r3, #0]
 8021388:	2ba5      	cmp	r3, #165	; 0xa5
 802138a:	d110      	bne.n	80213ae <B_tcpSend+0x16e>
            buf[buf_pos+1] = buf[buf_pos];
 802138c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 802138e:	697a      	ldr	r2, [r7, #20]
 8021390:	441a      	add	r2, r3
 8021392:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8021394:	3301      	adds	r3, #1
 8021396:	6979      	ldr	r1, [r7, #20]
 8021398:	440b      	add	r3, r1
 802139a:	7812      	ldrb	r2, [r2, #0]
 802139c:	701a      	strb	r2, [r3, #0]
            buf[buf_pos] = BSSR_SERIAL_ESCAPE;
 802139e:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80213a0:	697a      	ldr	r2, [r7, #20]
 80213a2:	4413      	add	r3, r2
 80213a4:	225a      	movs	r2, #90	; 0x5a
 80213a6:	701a      	strb	r2, [r3, #0]
            buf_pos++;
 80213a8:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80213aa:	3301      	adds	r3, #1
 80213ac:	84fb      	strh	r3, [r7, #38]	; 0x26
        }
        buf_pos++;
 80213ae:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80213b0:	3301      	adds	r3, #1
 80213b2:	84fb      	strh	r3, [r7, #38]	; 0x26
    for(int i = 0; i < 4; i++){
 80213b4:	69fb      	ldr	r3, [r7, #28]
 80213b6:	3301      	adds	r3, #1
 80213b8:	61fb      	str	r3, [r7, #28]
 80213ba:	69fb      	ldr	r3, [r7, #28]
 80213bc:	2b03      	cmp	r3, #3
 80213be:	ddcd      	ble.n	802135c <B_tcpSend+0x11c>
    }
	
	// Send the message to the Queue corresponding to each of the UART ports in the transmitBuarts array 
    for(int i = 0; i < btcp->numTransmitBuarts; i++){
 80213c0:	2300      	movs	r3, #0
 80213c2:	61bb      	str	r3, [r7, #24]
 80213c4:	e00d      	b.n	80213e2 <B_tcpSend+0x1a2>
        B_uartSend(btcp->transmitBuarts[i], buf, buf_pos);
 80213c6:	68fb      	ldr	r3, [r7, #12]
 80213c8:	685a      	ldr	r2, [r3, #4]
 80213ca:	69bb      	ldr	r3, [r7, #24]
 80213cc:	009b      	lsls	r3, r3, #2
 80213ce:	4413      	add	r3, r2
 80213d0:	681b      	ldr	r3, [r3, #0]
 80213d2:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 80213d4:	6979      	ldr	r1, [r7, #20]
 80213d6:	4618      	mov	r0, r3
 80213d8:	f000 fa18 	bl	802180c <B_uartSend>
    for(int i = 0; i < btcp->numTransmitBuarts; i++){
 80213dc:	69bb      	ldr	r3, [r7, #24]
 80213de:	3301      	adds	r3, #1
 80213e0:	61bb      	str	r3, [r7, #24]
 80213e2:	68fb      	ldr	r3, [r7, #12]
 80213e4:	7a1b      	ldrb	r3, [r3, #8]
 80213e6:	461a      	mov	r2, r3
 80213e8:	69bb      	ldr	r3, [r7, #24]
 80213ea:	4293      	cmp	r3, r2
 80213ec:	dbeb      	blt.n	80213c6 <B_tcpSend+0x186>
    }
    vPortFree(buf);
 80213ee:	6978      	ldr	r0, [r7, #20]
 80213f0:	f7eb feae 	bl	800d150 <vPortFree>
}
 80213f4:	bf00      	nop
 80213f6:	3728      	adds	r7, #40	; 0x28
 80213f8:	46bd      	mov	sp, r7
 80213fa:	bd80      	pop	{r7, pc}

080213fc <tcpRxTask>:
//  ######     ##    ##     ##    ##     ##  ##
//       ##    ##    #########    ##     ##  ##
// ##    ##    ##    ##     ##    ##     ##  ##    ##
//  ######     ##    ##     ##    ##    ####  ######

static void tcpRxTask(void *pv){
 80213fc:	b580      	push	{r7, lr}
 80213fe:	f5ad 7d54 	sub.w	sp, sp, #848	; 0x350
 8021402:	af00      	add	r7, sp, #0
 8021404:	1d3b      	adds	r3, r7, #4
 8021406:	6018      	str	r0, [r3, #0]
    B_tcpHandle_t* btcp = pv;
 8021408:	1d3b      	adds	r3, r7, #4
 802140a:	681b      	ldr	r3, [r3, #0]
 802140c:	f8c7 3334 	str.w	r3, [r7, #820]	; 0x334
    B_bufQEntry_t *e;
    uint8_t input_buffer[MAX_PACKET_SIZE + 4];
    uint8_t raw_input_buffer[(MAX_PACKET_SIZE + 8)*2]; // Just in case every byte is escaped
    uint8_t escaped = 0;
 8021410:	2300      	movs	r3, #0
 8021412:	f887 334f 	strb.w	r3, [r7, #847]	; 0x34f
    uint16_t buf_pos = 0;
 8021416:	2300      	movs	r3, #0
 8021418:	f8a7 334c 	strh.w	r3, [r7, #844]	; 0x34c
    uint16_t raw_buf_pos = 0;
 802141c:	2300      	movs	r3, #0
 802141e:	f8a7 334a 	strh.w	r3, [r7, #842]	; 0x34a
    uint8_t expected_length = 0;
 8021422:	2300      	movs	r3, #0
 8021424:	f887 3349 	strb.w	r3, [r7, #841]	; 0x349
    uint8_t started = 0;
 8021428:	2300      	movs	r3, #0
 802142a:	f887 3348 	strb.w	r3, [r7, #840]	; 0x348
    uint8_t sender = 0;
 802142e:	2300      	movs	r3, #0
 8021430:	f887 3347 	strb.w	r3, [r7, #839]	; 0x347
    uint16_t seqNum = 0xffff;
 8021434:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8021438:	f8a7 3344 	strh.w	r3, [r7, #836]	; 0x344
    uint8_t crcAcc = 0;
 802143c:	2300      	movs	r3, #0
 802143e:	f887 3343 	strb.w	r3, [r7, #835]	; 0x343
    uint32_t crc = 0;
 8021442:	2300      	movs	r3, #0
 8021444:	f8c7 333c 	str.w	r3, [r7, #828]	; 0x33c
    uint32_t crcExpected = 0;
 8021448:	2300      	movs	r3, #0
 802144a:	f8c7 3330 	str.w	r3, [r7, #816]	; 0x330
    B_tcpPacket_t pkt;
    for(;;){
        e = B_uartRead(btcp->rxBuart);
 802144e:	f8d7 3334 	ldr.w	r3, [r7, #820]	; 0x334
 8021452:	68db      	ldr	r3, [r3, #12]
 8021454:	4618      	mov	r0, r3
 8021456:	f000 f9fa 	bl	802184e <B_uartRead>
 802145a:	f8c7 032c 	str.w	r0, [r7, #812]	; 0x32c
        for(int i = 0; i < e->len; i++){
 802145e:	2300      	movs	r3, #0
 8021460:	f8c7 3338 	str.w	r3, [r7, #824]	; 0x338
 8021464:	e14f      	b.n	8021706 <tcpRxTask+0x30a>
            raw_input_buffer[raw_buf_pos] = e->buf[i];
 8021466:	f8d7 332c 	ldr.w	r3, [r7, #812]	; 0x32c
 802146a:	681a      	ldr	r2, [r3, #0]
 802146c:	f8d7 3338 	ldr.w	r3, [r7, #824]	; 0x338
 8021470:	441a      	add	r2, r3
 8021472:	f8b7 334a 	ldrh.w	r3, [r7, #842]	; 0x34a
 8021476:	7811      	ldrb	r1, [r2, #0]
 8021478:	f107 0218 	add.w	r2, r7, #24
 802147c:	54d1      	strb	r1, [r2, r3]
            raw_buf_pos++;
 802147e:	f8b7 334a 	ldrh.w	r3, [r7, #842]	; 0x34a
 8021482:	3301      	adds	r3, #1
 8021484:	f8a7 334a 	strh.w	r3, [r7, #842]	; 0x34a

			// First, check if there is an escape character and act accordingly
            if(e->buf[i] == BSSR_SERIAL_ESCAPE && !escaped){ 
 8021488:	f8d7 332c 	ldr.w	r3, [r7, #812]	; 0x32c
 802148c:	681a      	ldr	r2, [r3, #0]
 802148e:	f8d7 3338 	ldr.w	r3, [r7, #824]	; 0x338
 8021492:	4413      	add	r3, r2
 8021494:	781b      	ldrb	r3, [r3, #0]
 8021496:	2b5a      	cmp	r3, #90	; 0x5a
 8021498:	d107      	bne.n	80214aa <tcpRxTask+0xae>
 802149a:	f897 334f 	ldrb.w	r3, [r7, #847]	; 0x34f
 802149e:	2b00      	cmp	r3, #0
 80214a0:	d103      	bne.n	80214aa <tcpRxTask+0xae>
                escaped = 1;
 80214a2:	2301      	movs	r3, #1
 80214a4:	f887 334f 	strb.w	r3, [r7, #847]	; 0x34f
				continue; //Go to the next loop iteration
 80214a8:	e128      	b.n	80216fc <tcpRxTask+0x300>
            } else if (escaped) {
 80214aa:	f897 334f 	ldrb.w	r3, [r7, #847]	; 0x34f
 80214ae:	2b00      	cmp	r3, #0
 80214b0:	d002      	beq.n	80214b8 <tcpRxTask+0xbc>
				escaped = 0;
 80214b2:	2300      	movs	r3, #0
 80214b4:	f887 334f 	strb.w	r3, [r7, #847]	; 0x34f
			}

			if(!started){	
 80214b8:	f897 3348 	ldrb.w	r3, [r7, #840]	; 0x348
 80214bc:	2b00      	cmp	r3, #0
 80214be:	d11e      	bne.n	80214fe <tcpRxTask+0x102>
                if(e->buf[i] == BSSR_SERIAL_START){
 80214c0:	f8d7 332c 	ldr.w	r3, [r7, #812]	; 0x32c
 80214c4:	681a      	ldr	r2, [r3, #0]
 80214c6:	f8d7 3338 	ldr.w	r3, [r7, #824]	; 0x338
 80214ca:	4413      	add	r3, r2
 80214cc:	781b      	ldrb	r3, [r3, #0]
 80214ce:	2ba5      	cmp	r3, #165	; 0xa5
 80214d0:	f040 8114 	bne.w	80216fc <tcpRxTask+0x300>
                    started = 1;
 80214d4:	2301      	movs	r3, #1
 80214d6:	f887 3348 	strb.w	r3, [r7, #840]	; 0x348
                    input_buffer[buf_pos] = e->buf[i];
 80214da:	f8d7 332c 	ldr.w	r3, [r7, #812]	; 0x32c
 80214de:	681a      	ldr	r2, [r3, #0]
 80214e0:	f8d7 3338 	ldr.w	r3, [r7, #824]	; 0x338
 80214e4:	441a      	add	r2, r3
 80214e6:	f8b7 334c 	ldrh.w	r3, [r7, #844]	; 0x34c
 80214ea:	7811      	ldrb	r1, [r2, #0]
 80214ec:	f507 720a 	add.w	r2, r7, #552	; 0x228
 80214f0:	54d1      	strb	r1, [r2, r3]
                    buf_pos++;
 80214f2:	f8b7 334c 	ldrh.w	r3, [r7, #844]	; 0x34c
 80214f6:	3301      	adds	r3, #1
 80214f8:	f8a7 334c 	strh.w	r3, [r7, #844]	; 0x34c
 80214fc:	e0fe      	b.n	80216fc <tcpRxTask+0x300>
                }
            } else if(!expected_length){
 80214fe:	f897 3349 	ldrb.w	r3, [r7, #841]	; 0x349
 8021502:	2b00      	cmp	r3, #0
 8021504:	d11a      	bne.n	802153c <tcpRxTask+0x140>
                expected_length = e->buf[i];
 8021506:	f8d7 332c 	ldr.w	r3, [r7, #812]	; 0x32c
 802150a:	681a      	ldr	r2, [r3, #0]
 802150c:	f8d7 3338 	ldr.w	r3, [r7, #824]	; 0x338
 8021510:	4413      	add	r3, r2
 8021512:	781b      	ldrb	r3, [r3, #0]
 8021514:	f887 3349 	strb.w	r3, [r7, #841]	; 0x349
                input_buffer[buf_pos] = e->buf[i];
 8021518:	f8d7 332c 	ldr.w	r3, [r7, #812]	; 0x32c
 802151c:	681a      	ldr	r2, [r3, #0]
 802151e:	f8d7 3338 	ldr.w	r3, [r7, #824]	; 0x338
 8021522:	441a      	add	r2, r3
 8021524:	f8b7 334c 	ldrh.w	r3, [r7, #844]	; 0x34c
 8021528:	7811      	ldrb	r1, [r2, #0]
 802152a:	f507 720a 	add.w	r2, r7, #552	; 0x228
 802152e:	54d1      	strb	r1, [r2, r3]
                buf_pos++;
 8021530:	f8b7 334c 	ldrh.w	r3, [r7, #844]	; 0x34c
 8021534:	3301      	adds	r3, #1
 8021536:	f8a7 334c 	strh.w	r3, [r7, #844]	; 0x34c
 802153a:	e0df      	b.n	80216fc <tcpRxTask+0x300>
            } else if(!sender){
 802153c:	f897 3347 	ldrb.w	r3, [r7, #839]	; 0x347
 8021540:	2b00      	cmp	r3, #0
 8021542:	d11a      	bne.n	802157a <tcpRxTask+0x17e>
                sender = e->buf[i];
 8021544:	f8d7 332c 	ldr.w	r3, [r7, #812]	; 0x32c
 8021548:	681a      	ldr	r2, [r3, #0]
 802154a:	f8d7 3338 	ldr.w	r3, [r7, #824]	; 0x338
 802154e:	4413      	add	r3, r2
 8021550:	781b      	ldrb	r3, [r3, #0]
 8021552:	f887 3347 	strb.w	r3, [r7, #839]	; 0x347
                input_buffer[buf_pos] = e->buf[i];
 8021556:	f8d7 332c 	ldr.w	r3, [r7, #812]	; 0x32c
 802155a:	681a      	ldr	r2, [r3, #0]
 802155c:	f8d7 3338 	ldr.w	r3, [r7, #824]	; 0x338
 8021560:	441a      	add	r2, r3
 8021562:	f8b7 334c 	ldrh.w	r3, [r7, #844]	; 0x34c
 8021566:	7811      	ldrb	r1, [r2, #0]
 8021568:	f507 720a 	add.w	r2, r7, #552	; 0x228
 802156c:	54d1      	strb	r1, [r2, r3]
                buf_pos++;
 802156e:	f8b7 334c 	ldrh.w	r3, [r7, #844]	; 0x34c
 8021572:	3301      	adds	r3, #1
 8021574:	f8a7 334c 	strh.w	r3, [r7, #844]	; 0x34c
 8021578:	e0c0      	b.n	80216fc <tcpRxTask+0x300>
            } else if(seqNum == 0xffff){
 802157a:	f8b7 3344 	ldrh.w	r3, [r7, #836]	; 0x344
 802157e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8021582:	4293      	cmp	r3, r2
 8021584:	d11a      	bne.n	80215bc <tcpRxTask+0x1c0>
				seqNum = e->buf[i];
 8021586:	f8d7 332c 	ldr.w	r3, [r7, #812]	; 0x32c
 802158a:	681a      	ldr	r2, [r3, #0]
 802158c:	f8d7 3338 	ldr.w	r3, [r7, #824]	; 0x338
 8021590:	4413      	add	r3, r2
 8021592:	781b      	ldrb	r3, [r3, #0]
 8021594:	f8a7 3344 	strh.w	r3, [r7, #836]	; 0x344
				input_buffer[buf_pos] = e->buf[i];
 8021598:	f8d7 332c 	ldr.w	r3, [r7, #812]	; 0x32c
 802159c:	681a      	ldr	r2, [r3, #0]
 802159e:	f8d7 3338 	ldr.w	r3, [r7, #824]	; 0x338
 80215a2:	441a      	add	r2, r3
 80215a4:	f8b7 334c 	ldrh.w	r3, [r7, #844]	; 0x34c
 80215a8:	7811      	ldrb	r1, [r2, #0]
 80215aa:	f507 720a 	add.w	r2, r7, #552	; 0x228
 80215ae:	54d1      	strb	r1, [r2, r3]
				buf_pos++;
 80215b0:	f8b7 334c 	ldrh.w	r3, [r7, #844]	; 0x34c
 80215b4:	3301      	adds	r3, #1
 80215b6:	f8a7 334c 	strh.w	r3, [r7, #844]	; 0x34c
 80215ba:	e09f      	b.n	80216fc <tcpRxTask+0x300>
            } else if(buf_pos < expected_length+4){
 80215bc:	f897 3349 	ldrb.w	r3, [r7, #841]	; 0x349
 80215c0:	1cda      	adds	r2, r3, #3
 80215c2:	f8b7 334c 	ldrh.w	r3, [r7, #844]	; 0x34c
 80215c6:	429a      	cmp	r2, r3
 80215c8:	db11      	blt.n	80215ee <tcpRxTask+0x1f2>
                input_buffer[buf_pos] = e->buf[i];
 80215ca:	f8d7 332c 	ldr.w	r3, [r7, #812]	; 0x32c
 80215ce:	681a      	ldr	r2, [r3, #0]
 80215d0:	f8d7 3338 	ldr.w	r3, [r7, #824]	; 0x338
 80215d4:	441a      	add	r2, r3
 80215d6:	f8b7 334c 	ldrh.w	r3, [r7, #844]	; 0x34c
 80215da:	7811      	ldrb	r1, [r2, #0]
 80215dc:	f507 720a 	add.w	r2, r7, #552	; 0x228
 80215e0:	54d1      	strb	r1, [r2, r3]
                buf_pos++;
 80215e2:	f8b7 334c 	ldrh.w	r3, [r7, #844]	; 0x34c
 80215e6:	3301      	adds	r3, #1
 80215e8:	f8a7 334c 	strh.w	r3, [r7, #844]	; 0x34c
 80215ec:	e086      	b.n	80216fc <tcpRxTask+0x300>
            } else if(buf_pos + crcAcc < expected_length+8){
 80215ee:	f897 3349 	ldrb.w	r3, [r7, #841]	; 0x349
 80215f2:	1dda      	adds	r2, r3, #7
 80215f4:	f8b7 134c 	ldrh.w	r1, [r7, #844]	; 0x34c
 80215f8:	f897 3343 	ldrb.w	r3, [r7, #835]	; 0x343
 80215fc:	440b      	add	r3, r1
 80215fe:	429a      	cmp	r2, r3
 8021600:	db7c      	blt.n	80216fc <tcpRxTask+0x300>
                crc |= e->buf[i] << ((3-crcAcc)*8);
 8021602:	f8d7 332c 	ldr.w	r3, [r7, #812]	; 0x32c
 8021606:	681a      	ldr	r2, [r3, #0]
 8021608:	f8d7 3338 	ldr.w	r3, [r7, #824]	; 0x338
 802160c:	4413      	add	r3, r2
 802160e:	781b      	ldrb	r3, [r3, #0]
 8021610:	461a      	mov	r2, r3
 8021612:	f897 3343 	ldrb.w	r3, [r7, #835]	; 0x343
 8021616:	f1c3 0303 	rsb	r3, r3, #3
 802161a:	00db      	lsls	r3, r3, #3
 802161c:	fa02 f303 	lsl.w	r3, r2, r3
 8021620:	461a      	mov	r2, r3
 8021622:	f8d7 333c 	ldr.w	r3, [r7, #828]	; 0x33c
 8021626:	4313      	orrs	r3, r2
 8021628:	f8c7 333c 	str.w	r3, [r7, #828]	; 0x33c
                crcAcc++;
 802162c:	f897 3343 	ldrb.w	r3, [r7, #835]	; 0x343
 8021630:	3301      	adds	r3, #1
 8021632:	f887 3343 	strb.w	r3, [r7, #835]	; 0x343
                if(crcAcc == 4){
 8021636:	f897 3343 	ldrb.w	r3, [r7, #835]	; 0x343
 802163a:	2b04      	cmp	r3, #4
 802163c:	d15e      	bne.n	80216fc <tcpRxTask+0x300>
                	//crcExpected = ~HAL_CRC_Calculate(btcp->crc, input_buffer, buf_pos);
                	//GEN11 change:
                	crcExpected = ~HAL_CRC_Calculate(btcp->crc, (uint32_t*)input_buffer, buf_pos);
 802163e:	f8d7 3334 	ldr.w	r3, [r7, #820]	; 0x334
 8021642:	69db      	ldr	r3, [r3, #28]
 8021644:	f8b7 234c 	ldrh.w	r2, [r7, #844]	; 0x34c
 8021648:	f507 710a 	add.w	r1, r7, #552	; 0x228
 802164c:	4618      	mov	r0, r3
 802164e:	f7df f9d7 	bl	8000a00 <HAL_CRC_Calculate>
 8021652:	4603      	mov	r3, r0
 8021654:	43db      	mvns	r3, r3
 8021656:	f8c7 3330 	str.w	r3, [r7, #816]	; 0x330

					if(crcExpected == crc && sender != TCP_ID){ // If CRC correct and the sender is not this motherboard
 802165a:	f8d7 2330 	ldr.w	r2, [r7, #816]	; 0x330
 802165e:	f8d7 333c 	ldr.w	r3, [r7, #828]	; 0x33c
 8021662:	429a      	cmp	r2, r3
 8021664:	d12e      	bne.n	80216c4 <tcpRxTask+0x2c8>
 8021666:	f897 3347 	ldrb.w	r3, [r7, #839]	; 0x347
 802166a:	2b04      	cmp	r3, #4
 802166c:	d02a      	beq.n	80216c4 <tcpRxTask+0x2c8>
						/*for(int i = 0; i < btcp->numTransmitBuarts; i++){
							B_uartSend(btcp->transmitBuarts[i], raw_input_buffer, raw_buf_pos);
						}*/  //Commented out since this is for Daisy Chain, and we are not doing Daisy Chain this cycle
						pkt.length = expected_length;
 802166e:	f107 0308 	add.w	r3, r7, #8
 8021672:	f897 2349 	ldrb.w	r2, [r7, #841]	; 0x349
 8021676:	709a      	strb	r2, [r3, #2]
						pkt.sender = sender;
 8021678:	f107 0308 	add.w	r3, r7, #8
 802167c:	f897 2347 	ldrb.w	r2, [r7, #839]	; 0x347
 8021680:	701a      	strb	r2, [r3, #0]
						pkt.senderID = sender;
 8021682:	f107 0308 	add.w	r3, r7, #8
 8021686:	f897 2347 	ldrb.w	r2, [r7, #839]	; 0x347
 802168a:	705a      	strb	r2, [r3, #1]
						pkt.seqNum = seqNum;
 802168c:	f8b7 3344 	ldrh.w	r3, [r7, #836]	; 0x344
 8021690:	b2da      	uxtb	r2, r3
 8021692:	f107 0308 	add.w	r3, r7, #8
 8021696:	70da      	strb	r2, [r3, #3]
						pkt.payload = input_buffer;
 8021698:	f107 0308 	add.w	r3, r7, #8
 802169c:	f507 720a 	add.w	r2, r7, #552	; 0x228
 80216a0:	605a      	str	r2, [r3, #4]
						pkt.data = pkt.payload + 4; //points to element containing DataID
 80216a2:	f107 0308 	add.w	r3, r7, #8
 80216a6:	685b      	ldr	r3, [r3, #4]
 80216a8:	1d1a      	adds	r2, r3, #4
 80216aa:	f107 0308 	add.w	r3, r7, #8
 80216ae:	609a      	str	r2, [r3, #8]
						pkt.crc = crc;
 80216b0:	f107 0308 	add.w	r3, r7, #8
 80216b4:	f8d7 233c 	ldr.w	r2, [r7, #828]	; 0x33c
 80216b8:	60da      	str	r2, [r3, #12]
						serialParse(&pkt);
 80216ba:	f107 0308 	add.w	r3, r7, #8
 80216be:	4618      	mov	r0, r3
 80216c0:	f7ef fc30 	bl	8010f24 <serialParse>
					}
					raw_buf_pos = 0;
 80216c4:	2300      	movs	r3, #0
 80216c6:	f8a7 334a 	strh.w	r3, [r7, #842]	; 0x34a
					crc = 0;
 80216ca:	2300      	movs	r3, #0
 80216cc:	f8c7 333c 	str.w	r3, [r7, #828]	; 0x33c
					seqNum = 0xffff;
 80216d0:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80216d4:	f8a7 3344 	strh.w	r3, [r7, #836]	; 0x344
					crcAcc = 0;
 80216d8:	2300      	movs	r3, #0
 80216da:	f887 3343 	strb.w	r3, [r7, #835]	; 0x343
					crcExpected = 0;
 80216de:	2300      	movs	r3, #0
 80216e0:	f8c7 3330 	str.w	r3, [r7, #816]	; 0x330
					sender = 0;
 80216e4:	2300      	movs	r3, #0
 80216e6:	f887 3347 	strb.w	r3, [r7, #839]	; 0x347
					buf_pos = 0;
 80216ea:	2300      	movs	r3, #0
 80216ec:	f8a7 334c 	strh.w	r3, [r7, #844]	; 0x34c
					expected_length = 0;
 80216f0:	2300      	movs	r3, #0
 80216f2:	f887 3349 	strb.w	r3, [r7, #841]	; 0x349
					started = 0;
 80216f6:	2300      	movs	r3, #0
 80216f8:	f887 3348 	strb.w	r3, [r7, #840]	; 0x348
        for(int i = 0; i < e->len; i++){
 80216fc:	f8d7 3338 	ldr.w	r3, [r7, #824]	; 0x338
 8021700:	3301      	adds	r3, #1
 8021702:	f8c7 3338 	str.w	r3, [r7, #824]	; 0x338
 8021706:	f8d7 332c 	ldr.w	r3, [r7, #812]	; 0x32c
 802170a:	685a      	ldr	r2, [r3, #4]
 802170c:	f8d7 3338 	ldr.w	r3, [r7, #824]	; 0x338
 8021710:	429a      	cmp	r2, r3
 8021712:	f63f aea8 	bhi.w	8021466 <tcpRxTask+0x6a>
                }
            }
        }
        B_uartDoneRead(e);
 8021716:	f8d7 032c 	ldr.w	r0, [r7, #812]	; 0x32c
 802171a:	f000 f8ad 	bl	8021878 <B_uartDoneRead>
        e = B_uartRead(btcp->rxBuart);
 802171e:	e696      	b.n	802144e <tcpRxTask+0x52>

08021720 <B_uartStart>:
// ######   ##     ## ## ## ## ##
// ##       ##     ## ##  #### ##
// ##       ##     ## ##   ### ##    ##
// ##        #######  ##    ##  ######

B_uartHandle_t* B_uartStart(UART_HandleTypeDef* huart){
 8021720:	b580      	push	{r7, lr}
 8021722:	b086      	sub	sp, #24
 8021724:	af02      	add	r7, sp, #8
 8021726:	6078      	str	r0, [r7, #4]
	B_uartHandle_t *buart;
    for(int i = 0; i < 3; i++){
 8021728:	2300      	movs	r3, #0
 802172a:	60bb      	str	r3, [r7, #8]
 802172c:	e01e      	b.n	802176c <B_uartStart+0x4c>
        if(buarts[i] == NULL){
 802172e:	4a32      	ldr	r2, [pc, #200]	; (80217f8 <B_uartStart+0xd8>)
 8021730:	68bb      	ldr	r3, [r7, #8]
 8021732:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8021736:	2b00      	cmp	r3, #0
 8021738:	d115      	bne.n	8021766 <B_uartStart+0x46>
            buarts[i] = pvPortMalloc(sizeof(B_uartHandle_t));
 802173a:	2028      	movs	r0, #40	; 0x28
 802173c:	f7eb fc3c 	bl	800cfb8 <pvPortMalloc>
 8021740:	4602      	mov	r2, r0
 8021742:	492d      	ldr	r1, [pc, #180]	; (80217f8 <B_uartStart+0xd8>)
 8021744:	68bb      	ldr	r3, [r7, #8]
 8021746:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
            buart = buarts[i];
 802174a:	4a2b      	ldr	r2, [pc, #172]	; (80217f8 <B_uartStart+0xd8>)
 802174c:	68bb      	ldr	r3, [r7, #8]
 802174e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8021752:	60fb      	str	r3, [r7, #12]
            huarts[i] = huart;
 8021754:	4929      	ldr	r1, [pc, #164]	; (80217fc <B_uartStart+0xdc>)
 8021756:	68bb      	ldr	r3, [r7, #8]
 8021758:	687a      	ldr	r2, [r7, #4]
 802175a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
            buart->huart = huart;
 802175e:	68fb      	ldr	r3, [r7, #12]
 8021760:	687a      	ldr	r2, [r7, #4]
 8021762:	601a      	str	r2, [r3, #0]
            break;
 8021764:	e005      	b.n	8021772 <B_uartStart+0x52>
    for(int i = 0; i < 3; i++){
 8021766:	68bb      	ldr	r3, [r7, #8]
 8021768:	3301      	adds	r3, #1
 802176a:	60bb      	str	r3, [r7, #8]
 802176c:	68bb      	ldr	r3, [r7, #8]
 802176e:	2b02      	cmp	r3, #2
 8021770:	dddd      	ble.n	802172e <B_uartStart+0xe>
        }
    }
    buart->txSem = xSemaphoreCreateBinary();
 8021772:	2203      	movs	r2, #3
 8021774:	2100      	movs	r1, #0
 8021776:	2001      	movs	r0, #1
 8021778:	f7e9 f82c 	bl	800a7d4 <xQueueGenericCreate>
 802177c:	4602      	mov	r2, r0
 802177e:	68fb      	ldr	r3, [r7, #12]
 8021780:	605a      	str	r2, [r3, #4]
	buart->txQ = xQueueCreate(TX_QUEUE_SIZE, sizeof(B_bufQEntry_t));
 8021782:	2200      	movs	r2, #0
 8021784:	2108      	movs	r1, #8
 8021786:	2040      	movs	r0, #64	; 0x40
 8021788:	f7e9 f824 	bl	800a7d4 <xQueueGenericCreate>
 802178c:	4602      	mov	r2, r0
 802178e:	68fb      	ldr	r3, [r7, #12]
 8021790:	609a      	str	r2, [r3, #8]
	// buart->rxBuf = pvPortMalloc(RX_CIRC_BUF_SIZE); // done in task
	buart->rxQ = xQueueCreate(RX_QUEUE_SIZE, sizeof(B_bufQEntry_t));
 8021792:	2200      	movs	r2, #0
 8021794:	2108      	movs	r1, #8
 8021796:	2040      	movs	r0, #64	; 0x40
 8021798:	f7e9 f81c 	bl	800a7d4 <xQueueGenericCreate>
 802179c:	4602      	mov	r2, r0
 802179e:	68fb      	ldr	r3, [r7, #12]
 80217a0:	611a      	str	r2, [r3, #16]
	xTaskCreate(txTask, "uartTxTask", TRX_TASK_STACK_SIZE, buart, TX_TASK_PRIORITY, &buart->txTask);
 80217a2:	68fb      	ldr	r3, [r7, #12]
 80217a4:	3314      	adds	r3, #20
 80217a6:	9301      	str	r3, [sp, #4]
 80217a8:	2305      	movs	r3, #5
 80217aa:	9300      	str	r3, [sp, #0]
 80217ac:	68fb      	ldr	r3, [r7, #12]
 80217ae:	f44f 7280 	mov.w	r2, #256	; 0x100
 80217b2:	4913      	ldr	r1, [pc, #76]	; (8021800 <B_uartStart+0xe0>)
 80217b4:	4813      	ldr	r0, [pc, #76]	; (8021804 <B_uartStart+0xe4>)
 80217b6:	f7e9 fe2d 	bl	800b414 <xTaskCreate>
	xTaskCreate(rxTask, "uartTxTask", TRX_TASK_STACK_SIZE, buart, RX_TASK_PRIORITY, &buart->rxTask);
 80217ba:	68fb      	ldr	r3, [r7, #12]
 80217bc:	3318      	adds	r3, #24
 80217be:	9301      	str	r3, [sp, #4]
 80217c0:	2306      	movs	r3, #6
 80217c2:	9300      	str	r3, [sp, #0]
 80217c4:	68fb      	ldr	r3, [r7, #12]
 80217c6:	f44f 7280 	mov.w	r2, #256	; 0x100
 80217ca:	490d      	ldr	r1, [pc, #52]	; (8021800 <B_uartStart+0xe0>)
 80217cc:	480e      	ldr	r0, [pc, #56]	; (8021808 <B_uartStart+0xe8>)
 80217ce:	f7e9 fe21 	bl	800b414 <xTaskCreate>
	buart->topFlag = buart->head = buart->tail = 0;
 80217d2:	68fb      	ldr	r3, [r7, #12]
 80217d4:	2200      	movs	r2, #0
 80217d6:	621a      	str	r2, [r3, #32]
 80217d8:	68fb      	ldr	r3, [r7, #12]
 80217da:	6a1a      	ldr	r2, [r3, #32]
 80217dc:	68fb      	ldr	r3, [r7, #12]
 80217de:	61da      	str	r2, [r3, #28]
 80217e0:	68fb      	ldr	r3, [r7, #12]
 80217e2:	69db      	ldr	r3, [r3, #28]
 80217e4:	b2da      	uxtb	r2, r3
 80217e6:	68fb      	ldr	r3, [r7, #12]
 80217e8:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
	return buart;
 80217ec:	68fb      	ldr	r3, [r7, #12]
}
 80217ee:	4618      	mov	r0, r3
 80217f0:	3710      	adds	r7, #16
 80217f2:	46bd      	mov	sp, r7
 80217f4:	bd80      	pop	{r7, pc}
 80217f6:	bf00      	nop
 80217f8:	24062414 	.word	0x24062414
 80217fc:	24062424 	.word	0x24062424
 8021800:	08022938 	.word	0x08022938
 8021804:	08021899 	.word	0x08021899
 8021808:	080218e1 	.word	0x080218e1

0802180c <B_uartSend>:

int B_uartSend(B_uartHandle_t* buart, uint8_t* buf, size_t len){
 802180c:	b580      	push	{r7, lr}
 802180e:	b088      	sub	sp, #32
 8021810:	af00      	add	r7, sp, #0
 8021812:	60f8      	str	r0, [r7, #12]
 8021814:	60b9      	str	r1, [r7, #8]
 8021816:	607a      	str	r2, [r7, #4]
	B_bufQEntry_t e;
	e.buf = pvPortMalloc(len);
 8021818:	6878      	ldr	r0, [r7, #4]
 802181a:	f7eb fbcd 	bl	800cfb8 <pvPortMalloc>
 802181e:	4603      	mov	r3, r0
 8021820:	617b      	str	r3, [r7, #20]
	memcpy(e.buf, buf, len);
 8021822:	697b      	ldr	r3, [r7, #20]
 8021824:	687a      	ldr	r2, [r7, #4]
 8021826:	68b9      	ldr	r1, [r7, #8]
 8021828:	4618      	mov	r0, r3
 802182a:	f000 fa15 	bl	8021c58 <memcpy>
	e.len = len;
 802182e:	687b      	ldr	r3, [r7, #4]
 8021830:	61bb      	str	r3, [r7, #24]
	int sent = xQueueSendToBack(buart->txQ, &e, 0);
 8021832:	68fb      	ldr	r3, [r7, #12]
 8021834:	6898      	ldr	r0, [r3, #8]
 8021836:	f107 0114 	add.w	r1, r7, #20
 802183a:	2300      	movs	r3, #0
 802183c:	2200      	movs	r2, #0
 802183e:	f7e9 f851 	bl	800a8e4 <xQueueGenericSend>
 8021842:	61f8      	str	r0, [r7, #28]
	return sent;
 8021844:	69fb      	ldr	r3, [r7, #28]
}
 8021846:	4618      	mov	r0, r3
 8021848:	3720      	adds	r7, #32
 802184a:	46bd      	mov	sp, r7
 802184c:	bd80      	pop	{r7, pc}

0802184e <B_uartRead>:

B_bufQEntry_t* B_uartRead(B_uartHandle_t* buart){
 802184e:	b580      	push	{r7, lr}
 8021850:	b084      	sub	sp, #16
 8021852:	af00      	add	r7, sp, #0
 8021854:	6078      	str	r0, [r7, #4]
	B_bufQEntry_t* e = pvPortMalloc(sizeof(B_bufQEntry_t));
 8021856:	2008      	movs	r0, #8
 8021858:	f7eb fbae 	bl	800cfb8 <pvPortMalloc>
 802185c:	60f8      	str	r0, [r7, #12]
	xQueueReceive(buart->rxQ, e, portMAX_DELAY);
 802185e:	687b      	ldr	r3, [r7, #4]
 8021860:	691b      	ldr	r3, [r3, #16]
 8021862:	f04f 32ff 	mov.w	r2, #4294967295
 8021866:	68f9      	ldr	r1, [r7, #12]
 8021868:	4618      	mov	r0, r3
 802186a:	f7e9 fa61 	bl	800ad30 <xQueueReceive>
	return e;
 802186e:	68fb      	ldr	r3, [r7, #12]
}
 8021870:	4618      	mov	r0, r3
 8021872:	3710      	adds	r7, #16
 8021874:	46bd      	mov	sp, r7
 8021876:	bd80      	pop	{r7, pc}

08021878 <B_uartDoneRead>:

void B_uartDoneRead(B_bufQEntry_t* e){
 8021878:	b580      	push	{r7, lr}
 802187a:	b082      	sub	sp, #8
 802187c:	af00      	add	r7, sp, #0
 802187e:	6078      	str	r0, [r7, #4]
	vPortFree(e->buf);
 8021880:	687b      	ldr	r3, [r7, #4]
 8021882:	681b      	ldr	r3, [r3, #0]
 8021884:	4618      	mov	r0, r3
 8021886:	f7eb fc63 	bl	800d150 <vPortFree>
	vPortFree(e);
 802188a:	6878      	ldr	r0, [r7, #4]
 802188c:	f7eb fc60 	bl	800d150 <vPortFree>
}
 8021890:	bf00      	nop
 8021892:	3708      	adds	r7, #8
 8021894:	46bd      	mov	sp, r7
 8021896:	bd80      	pop	{r7, pc}

08021898 <txTask>:
//  ######     ##    ##     ##    ##     ##  ##
//       ##    ##    #########    ##     ##  ##
// ##    ##    ##    ##     ##    ##     ##  ##    ##
//  ######     ##    ##     ##    ##    ####  ######

static void txTask(void* pv){
 8021898:	b580      	push	{r7, lr}
 802189a:	b086      	sub	sp, #24
 802189c:	af00      	add	r7, sp, #0
 802189e:	6078      	str	r0, [r7, #4]
	B_uartHandle_t* buart = pv;
 80218a0:	687b      	ldr	r3, [r7, #4]
 80218a2:	617b      	str	r3, [r7, #20]
	B_bufQEntry_t e;
	for(;;){
		xQueueReceive(buart->txQ, &e, portMAX_DELAY);
 80218a4:	697b      	ldr	r3, [r7, #20]
 80218a6:	689b      	ldr	r3, [r3, #8]
 80218a8:	f107 010c 	add.w	r1, r7, #12
 80218ac:	f04f 32ff 	mov.w	r2, #4294967295
 80218b0:	4618      	mov	r0, r3
 80218b2:	f7e9 fa3d 	bl	800ad30 <xQueueReceive>
		HAL_UART_Transmit_DMA(buart->huart, e.buf, e.len);
 80218b6:	697b      	ldr	r3, [r7, #20]
 80218b8:	681b      	ldr	r3, [r3, #0]
 80218ba:	68f9      	ldr	r1, [r7, #12]
 80218bc:	693a      	ldr	r2, [r7, #16]
 80218be:	b292      	uxth	r2, r2
 80218c0:	4618      	mov	r0, r3
 80218c2:	f7e6 fea5 	bl	8008610 <HAL_UART_Transmit_DMA>
		
		//Waits until transmit is complete (happens when HAL_UART_TxCpltCallback is triggered)
		xSemaphoreTake(buart->txSem, portMAX_DELAY); 
 80218c6:	697b      	ldr	r3, [r7, #20]
 80218c8:	685b      	ldr	r3, [r3, #4]
 80218ca:	f04f 31ff 	mov.w	r1, #4294967295
 80218ce:	4618      	mov	r0, r3
 80218d0:	f7e9 fb0e 	bl	800aef0 <xQueueSemaphoreTake>
		vPortFree(e.buf);
 80218d4:	68fb      	ldr	r3, [r7, #12]
 80218d6:	4618      	mov	r0, r3
 80218d8:	f7eb fc3a 	bl	800d150 <vPortFree>
		xQueueReceive(buart->txQ, &e, portMAX_DELAY);
 80218dc:	e7e2      	b.n	80218a4 <txTask+0xc>
	...

080218e0 <rxTask>:
	}
}

static void rxTask(void* pv){
 80218e0:	b580      	push	{r7, lr}
 80218e2:	b086      	sub	sp, #24
 80218e4:	af00      	add	r7, sp, #0
 80218e6:	6078      	str	r0, [r7, #4]
	B_uartHandle_t* buart = pv;
 80218e8:	687b      	ldr	r3, [r7, #4]
 80218ea:	617b      	str	r3, [r7, #20]
	B_bufQEntry_t e;
	while(buart->huart->RxState != HAL_UART_STATE_READY) vTaskDelay(1);
 80218ec:	e002      	b.n	80218f4 <rxTask+0x14>
 80218ee:	2001      	movs	r0, #1
 80218f0:	f7e9 fede 	bl	800b6b0 <vTaskDelay>
 80218f4:	697b      	ldr	r3, [r7, #20]
 80218f6:	681b      	ldr	r3, [r3, #0]
 80218f8:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80218fc:	2b20      	cmp	r3, #32
 80218fe:	d1f6      	bne.n	80218ee <rxTask+0xe>
	buart->rxBuf = pvPortMalloc(RX_CIRC_BUF_SIZE);
 8021900:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8021904:	f7eb fb58 	bl	800cfb8 <pvPortMalloc>
 8021908:	4602      	mov	r2, r0
 802190a:	697b      	ldr	r3, [r7, #20]
 802190c:	60da      	str	r2, [r3, #12]
	while(!buart->rxBuf){
 802190e:	e009      	b.n	8021924 <rxTask+0x44>
		vTaskDelay(1);
 8021910:	2001      	movs	r0, #1
 8021912:	f7e9 fecd 	bl	800b6b0 <vTaskDelay>
		buart->rxBuf = pvPortMalloc(RX_CIRC_BUF_SIZE);
 8021916:	f44f 6000 	mov.w	r0, #2048	; 0x800
 802191a:	f7eb fb4d 	bl	800cfb8 <pvPortMalloc>
 802191e:	4602      	mov	r2, r0
 8021920:	697b      	ldr	r3, [r7, #20]
 8021922:	60da      	str	r2, [r3, #12]
	while(!buart->rxBuf){
 8021924:	697b      	ldr	r3, [r7, #20]
 8021926:	68db      	ldr	r3, [r3, #12]
 8021928:	2b00      	cmp	r3, #0
 802192a:	d0f1      	beq.n	8021910 <rxTask+0x30>
	}
	HAL_UART_Receive_DMA(buart->huart, buart->rxBuf, RX_CIRC_BUF_SIZE);
 802192c:	697b      	ldr	r3, [r7, #20]
 802192e:	6818      	ldr	r0, [r3, #0]
 8021930:	697b      	ldr	r3, [r7, #20]
 8021932:	68db      	ldr	r3, [r3, #12]
 8021934:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8021938:	4619      	mov	r1, r3
 802193a:	f7e6 fefb 	bl	8008734 <HAL_UART_Receive_DMA>
	for(;;){
		e.len = 0;
 802193e:	2300      	movs	r3, #0
 8021940:	60fb      	str	r3, [r7, #12]
		vPortEnterCritical();
 8021942:	f7eb fa17 	bl	800cd74 <vPortEnterCritical>
		// no flags will update in this region. Capture head value at beginning.
		// 0 to MAX-1, cuz CNDTR is MAX to 1 in circular mode
		buart->head = RX_CIRC_BUF_SIZE - __HAL_DMA_GET_COUNTER(buart->huart->hdmarx);
 8021946:	697b      	ldr	r3, [r7, #20]
 8021948:	681b      	ldr	r3, [r3, #0]
 802194a:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 802194c:	681b      	ldr	r3, [r3, #0]
 802194e:	4a6c      	ldr	r2, [pc, #432]	; (8021b00 <rxTask+0x220>)
 8021950:	4293      	cmp	r3, r2
 8021952:	d068      	beq.n	8021a26 <rxTask+0x146>
 8021954:	697b      	ldr	r3, [r7, #20]
 8021956:	681b      	ldr	r3, [r3, #0]
 8021958:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 802195a:	681b      	ldr	r3, [r3, #0]
 802195c:	4a69      	ldr	r2, [pc, #420]	; (8021b04 <rxTask+0x224>)
 802195e:	4293      	cmp	r3, r2
 8021960:	d061      	beq.n	8021a26 <rxTask+0x146>
 8021962:	697b      	ldr	r3, [r7, #20]
 8021964:	681b      	ldr	r3, [r3, #0]
 8021966:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8021968:	681b      	ldr	r3, [r3, #0]
 802196a:	4a67      	ldr	r2, [pc, #412]	; (8021b08 <rxTask+0x228>)
 802196c:	4293      	cmp	r3, r2
 802196e:	d05a      	beq.n	8021a26 <rxTask+0x146>
 8021970:	697b      	ldr	r3, [r7, #20]
 8021972:	681b      	ldr	r3, [r3, #0]
 8021974:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8021976:	681b      	ldr	r3, [r3, #0]
 8021978:	4a64      	ldr	r2, [pc, #400]	; (8021b0c <rxTask+0x22c>)
 802197a:	4293      	cmp	r3, r2
 802197c:	d053      	beq.n	8021a26 <rxTask+0x146>
 802197e:	697b      	ldr	r3, [r7, #20]
 8021980:	681b      	ldr	r3, [r3, #0]
 8021982:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8021984:	681b      	ldr	r3, [r3, #0]
 8021986:	4a62      	ldr	r2, [pc, #392]	; (8021b10 <rxTask+0x230>)
 8021988:	4293      	cmp	r3, r2
 802198a:	d04c      	beq.n	8021a26 <rxTask+0x146>
 802198c:	697b      	ldr	r3, [r7, #20]
 802198e:	681b      	ldr	r3, [r3, #0]
 8021990:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8021992:	681b      	ldr	r3, [r3, #0]
 8021994:	4a5f      	ldr	r2, [pc, #380]	; (8021b14 <rxTask+0x234>)
 8021996:	4293      	cmp	r3, r2
 8021998:	d045      	beq.n	8021a26 <rxTask+0x146>
 802199a:	697b      	ldr	r3, [r7, #20]
 802199c:	681b      	ldr	r3, [r3, #0]
 802199e:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 80219a0:	681b      	ldr	r3, [r3, #0]
 80219a2:	4a5d      	ldr	r2, [pc, #372]	; (8021b18 <rxTask+0x238>)
 80219a4:	4293      	cmp	r3, r2
 80219a6:	d03e      	beq.n	8021a26 <rxTask+0x146>
 80219a8:	697b      	ldr	r3, [r7, #20]
 80219aa:	681b      	ldr	r3, [r3, #0]
 80219ac:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 80219ae:	681b      	ldr	r3, [r3, #0]
 80219b0:	4a5a      	ldr	r2, [pc, #360]	; (8021b1c <rxTask+0x23c>)
 80219b2:	4293      	cmp	r3, r2
 80219b4:	d037      	beq.n	8021a26 <rxTask+0x146>
 80219b6:	697b      	ldr	r3, [r7, #20]
 80219b8:	681b      	ldr	r3, [r3, #0]
 80219ba:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 80219bc:	681b      	ldr	r3, [r3, #0]
 80219be:	4a58      	ldr	r2, [pc, #352]	; (8021b20 <rxTask+0x240>)
 80219c0:	4293      	cmp	r3, r2
 80219c2:	d030      	beq.n	8021a26 <rxTask+0x146>
 80219c4:	697b      	ldr	r3, [r7, #20]
 80219c6:	681b      	ldr	r3, [r3, #0]
 80219c8:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 80219ca:	681b      	ldr	r3, [r3, #0]
 80219cc:	4a55      	ldr	r2, [pc, #340]	; (8021b24 <rxTask+0x244>)
 80219ce:	4293      	cmp	r3, r2
 80219d0:	d029      	beq.n	8021a26 <rxTask+0x146>
 80219d2:	697b      	ldr	r3, [r7, #20]
 80219d4:	681b      	ldr	r3, [r3, #0]
 80219d6:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 80219d8:	681b      	ldr	r3, [r3, #0]
 80219da:	4a53      	ldr	r2, [pc, #332]	; (8021b28 <rxTask+0x248>)
 80219dc:	4293      	cmp	r3, r2
 80219de:	d022      	beq.n	8021a26 <rxTask+0x146>
 80219e0:	697b      	ldr	r3, [r7, #20]
 80219e2:	681b      	ldr	r3, [r3, #0]
 80219e4:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 80219e6:	681b      	ldr	r3, [r3, #0]
 80219e8:	4a50      	ldr	r2, [pc, #320]	; (8021b2c <rxTask+0x24c>)
 80219ea:	4293      	cmp	r3, r2
 80219ec:	d01b      	beq.n	8021a26 <rxTask+0x146>
 80219ee:	697b      	ldr	r3, [r7, #20]
 80219f0:	681b      	ldr	r3, [r3, #0]
 80219f2:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 80219f4:	681b      	ldr	r3, [r3, #0]
 80219f6:	4a4e      	ldr	r2, [pc, #312]	; (8021b30 <rxTask+0x250>)
 80219f8:	4293      	cmp	r3, r2
 80219fa:	d014      	beq.n	8021a26 <rxTask+0x146>
 80219fc:	697b      	ldr	r3, [r7, #20]
 80219fe:	681b      	ldr	r3, [r3, #0]
 8021a00:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8021a02:	681b      	ldr	r3, [r3, #0]
 8021a04:	4a4b      	ldr	r2, [pc, #300]	; (8021b34 <rxTask+0x254>)
 8021a06:	4293      	cmp	r3, r2
 8021a08:	d00d      	beq.n	8021a26 <rxTask+0x146>
 8021a0a:	697b      	ldr	r3, [r7, #20]
 8021a0c:	681b      	ldr	r3, [r3, #0]
 8021a0e:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8021a10:	681b      	ldr	r3, [r3, #0]
 8021a12:	4a49      	ldr	r2, [pc, #292]	; (8021b38 <rxTask+0x258>)
 8021a14:	4293      	cmp	r3, r2
 8021a16:	d006      	beq.n	8021a26 <rxTask+0x146>
 8021a18:	697b      	ldr	r3, [r7, #20]
 8021a1a:	681b      	ldr	r3, [r3, #0]
 8021a1c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8021a1e:	681b      	ldr	r3, [r3, #0]
 8021a20:	4a46      	ldr	r2, [pc, #280]	; (8021b3c <rxTask+0x25c>)
 8021a22:	4293      	cmp	r3, r2
 8021a24:	d107      	bne.n	8021a36 <rxTask+0x156>
 8021a26:	697b      	ldr	r3, [r7, #20]
 8021a28:	681b      	ldr	r3, [r3, #0]
 8021a2a:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8021a2c:	681b      	ldr	r3, [r3, #0]
 8021a2e:	685b      	ldr	r3, [r3, #4]
 8021a30:	f5c3 6300 	rsb	r3, r3, #2048	; 0x800
 8021a34:	e006      	b.n	8021a44 <rxTask+0x164>
 8021a36:	697b      	ldr	r3, [r7, #20]
 8021a38:	681b      	ldr	r3, [r3, #0]
 8021a3a:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8021a3c:	681b      	ldr	r3, [r3, #0]
 8021a3e:	685b      	ldr	r3, [r3, #4]
 8021a40:	f5c3 6300 	rsb	r3, r3, #2048	; 0x800
 8021a44:	697a      	ldr	r2, [r7, #20]
 8021a46:	61d3      	str	r3, [r2, #28]
		if(buart->topFlag){
 8021a48:	697b      	ldr	r3, [r7, #20]
 8021a4a:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8021a4e:	2b00      	cmp	r3, #0
 8021a50:	d013      	beq.n	8021a7a <rxTask+0x19a>
			if(buart->head > buart->tail) buart->tail = buart->head;
 8021a52:	697b      	ldr	r3, [r7, #20]
 8021a54:	69da      	ldr	r2, [r3, #28]
 8021a56:	697b      	ldr	r3, [r7, #20]
 8021a58:	6a1b      	ldr	r3, [r3, #32]
 8021a5a:	429a      	cmp	r2, r3
 8021a5c:	d903      	bls.n	8021a66 <rxTask+0x186>
 8021a5e:	697b      	ldr	r3, [r7, #20]
 8021a60:	69da      	ldr	r2, [r3, #28]
 8021a62:	697b      	ldr	r3, [r7, #20]
 8021a64:	621a      	str	r2, [r3, #32]
			e.len = RX_CIRC_BUF_SIZE - buart->tail;
 8021a66:	697b      	ldr	r3, [r7, #20]
 8021a68:	6a1b      	ldr	r3, [r3, #32]
 8021a6a:	f5c3 6300 	rsb	r3, r3, #2048	; 0x800
 8021a6e:	60fb      	str	r3, [r7, #12]
			buart->topFlag = 0;
 8021a70:	697b      	ldr	r3, [r7, #20]
 8021a72:	2200      	movs	r2, #0
 8021a74:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
 8021a78:	e00b      	b.n	8021a92 <rxTask+0x1b2>
		}else if(buart->head > buart->tail){
 8021a7a:	697b      	ldr	r3, [r7, #20]
 8021a7c:	69da      	ldr	r2, [r3, #28]
 8021a7e:	697b      	ldr	r3, [r7, #20]
 8021a80:	6a1b      	ldr	r3, [r3, #32]
 8021a82:	429a      	cmp	r2, r3
 8021a84:	d905      	bls.n	8021a92 <rxTask+0x1b2>
			e.len = buart->head - buart->tail;
 8021a86:	697b      	ldr	r3, [r7, #20]
 8021a88:	69da      	ldr	r2, [r3, #28]
 8021a8a:	697b      	ldr	r3, [r7, #20]
 8021a8c:	6a1b      	ldr	r3, [r3, #32]
 8021a8e:	1ad3      	subs	r3, r2, r3
 8021a90:	60fb      	str	r3, [r7, #12]
		}
		vPortExitCritical();
 8021a92:	f7eb f99f 	bl	800cdd4 <vPortExitCritical>
		if(e.len){
 8021a96:	68fb      	ldr	r3, [r7, #12]
 8021a98:	2b00      	cmp	r3, #0
 8021a9a:	d02c      	beq.n	8021af6 <rxTask+0x216>
			e.buf = pvPortMalloc(e.len);
 8021a9c:	68fb      	ldr	r3, [r7, #12]
 8021a9e:	4618      	mov	r0, r3
 8021aa0:	f7eb fa8a 	bl	800cfb8 <pvPortMalloc>
 8021aa4:	4603      	mov	r3, r0
 8021aa6:	60bb      	str	r3, [r7, #8]
			memcpy(e.buf, buart->rxBuf+buart->tail, e.len);
 8021aa8:	68b8      	ldr	r0, [r7, #8]
 8021aaa:	697b      	ldr	r3, [r7, #20]
 8021aac:	68da      	ldr	r2, [r3, #12]
 8021aae:	697b      	ldr	r3, [r7, #20]
 8021ab0:	6a1b      	ldr	r3, [r3, #32]
 8021ab2:	4413      	add	r3, r2
 8021ab4:	68fa      	ldr	r2, [r7, #12]
 8021ab6:	4619      	mov	r1, r3
 8021ab8:	f000 f8ce 	bl	8021c58 <memcpy>
			buart->tail += e.len;
 8021abc:	697b      	ldr	r3, [r7, #20]
 8021abe:	6a1a      	ldr	r2, [r3, #32]
 8021ac0:	68fb      	ldr	r3, [r7, #12]
 8021ac2:	441a      	add	r2, r3
 8021ac4:	697b      	ldr	r3, [r7, #20]
 8021ac6:	621a      	str	r2, [r3, #32]
			buart->tail %= RX_CIRC_BUF_SIZE;
 8021ac8:	697b      	ldr	r3, [r7, #20]
 8021aca:	6a1b      	ldr	r3, [r3, #32]
 8021acc:	f3c3 020a 	ubfx	r2, r3, #0, #11
 8021ad0:	697b      	ldr	r3, [r7, #20]
 8021ad2:	621a      	str	r2, [r3, #32]
			int sent = xQueueSendToBack(buart->rxQ, &e, 0);
 8021ad4:	697b      	ldr	r3, [r7, #20]
 8021ad6:	6918      	ldr	r0, [r3, #16]
 8021ad8:	f107 0108 	add.w	r1, r7, #8
 8021adc:	2300      	movs	r3, #0
 8021ade:	2200      	movs	r2, #0
 8021ae0:	f7e8 ff00 	bl	800a8e4 <xQueueGenericSend>
 8021ae4:	6138      	str	r0, [r7, #16]
			if(sent != pdTRUE) processCriticalFrame(&e);
 8021ae6:	693b      	ldr	r3, [r7, #16]
 8021ae8:	2b01      	cmp	r3, #1
 8021aea:	d004      	beq.n	8021af6 <rxTask+0x216>
 8021aec:	f107 0308 	add.w	r3, r7, #8
 8021af0:	4618      	mov	r0, r3
 8021af2:	f000 f825 	bl	8021b40 <processCriticalFrame>
		}
		vTaskDelay(1);
 8021af6:	2001      	movs	r0, #1
 8021af8:	f7e9 fdda 	bl	800b6b0 <vTaskDelay>
		e.len = 0;
 8021afc:	e71f      	b.n	802193e <rxTask+0x5e>
 8021afe:	bf00      	nop
 8021b00:	40020010 	.word	0x40020010
 8021b04:	40020028 	.word	0x40020028
 8021b08:	40020040 	.word	0x40020040
 8021b0c:	40020058 	.word	0x40020058
 8021b10:	40020070 	.word	0x40020070
 8021b14:	40020088 	.word	0x40020088
 8021b18:	400200a0 	.word	0x400200a0
 8021b1c:	400200b8 	.word	0x400200b8
 8021b20:	40020410 	.word	0x40020410
 8021b24:	40020428 	.word	0x40020428
 8021b28:	40020440 	.word	0x40020440
 8021b2c:	40020458 	.word	0x40020458
 8021b30:	40020470 	.word	0x40020470
 8021b34:	40020488 	.word	0x40020488
 8021b38:	400204a0 	.word	0x400204a0
 8021b3c:	400204b8 	.word	0x400204b8

08021b40 <processCriticalFrame>:
	}
}

static void processCriticalFrame(B_bufQEntry_t* e){
 8021b40:	b480      	push	{r7}
 8021b42:	b083      	sub	sp, #12
 8021b44:	af00      	add	r7, sp, #0
 8021b46:	6078      	str	r0, [r7, #4]

}
 8021b48:	bf00      	nop
 8021b4a:	370c      	adds	r7, #12
 8021b4c:	46bd      	mov	sp, r7
 8021b4e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021b52:	4770      	bx	lr

08021b54 <HAL_UART_TxCpltCallback>:
// ##       ######### ##       ##       ##     ## ######### ##       ##  ##
// ##    ## ##     ## ##       ##       ##     ## ##     ## ##    ## ##   ##
//  ######  ##     ## ######## ######## ########  ##     ##  ######  ##    ##


void HAL_UART_TxCpltCallback(UART_HandleTypeDef * huart){
 8021b54:	b580      	push	{r7, lr}
 8021b56:	b084      	sub	sp, #16
 8021b58:	af00      	add	r7, sp, #0
 8021b5a:	6078      	str	r0, [r7, #4]
	for(size_t i = 0; i < NUM_UARTS; i++){ //TODO linkedList
 8021b5c:	2300      	movs	r3, #0
 8021b5e:	60fb      	str	r3, [r7, #12]
 8021b60:	e013      	b.n	8021b8a <HAL_UART_TxCpltCallback+0x36>
		if(huart == huarts[i]){
 8021b62:	4a0d      	ldr	r2, [pc, #52]	; (8021b98 <HAL_UART_TxCpltCallback+0x44>)
 8021b64:	68fb      	ldr	r3, [r7, #12]
 8021b66:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8021b6a:	687a      	ldr	r2, [r7, #4]
 8021b6c:	429a      	cmp	r2, r3
 8021b6e:	d109      	bne.n	8021b84 <HAL_UART_TxCpltCallback+0x30>
			xSemaphoreGiveFromISR(buarts[i]->txSem, NULL);
 8021b70:	4a0a      	ldr	r2, [pc, #40]	; (8021b9c <HAL_UART_TxCpltCallback+0x48>)
 8021b72:	68fb      	ldr	r3, [r7, #12]
 8021b74:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8021b78:	685b      	ldr	r3, [r3, #4]
 8021b7a:	2100      	movs	r1, #0
 8021b7c:	4618      	mov	r0, r3
 8021b7e:	f7e9 f84a 	bl	800ac16 <xQueueGiveFromISR>
			return;
 8021b82:	e005      	b.n	8021b90 <HAL_UART_TxCpltCallback+0x3c>
	for(size_t i = 0; i < NUM_UARTS; i++){ //TODO linkedList
 8021b84:	68fb      	ldr	r3, [r7, #12]
 8021b86:	3301      	adds	r3, #1
 8021b88:	60fb      	str	r3, [r7, #12]
 8021b8a:	68fb      	ldr	r3, [r7, #12]
 8021b8c:	2b03      	cmp	r3, #3
 8021b8e:	d9e8      	bls.n	8021b62 <HAL_UART_TxCpltCallback+0xe>
		}
	}
	//configASSERT(NULL);
}
 8021b90:	3710      	adds	r7, #16
 8021b92:	46bd      	mov	sp, r7
 8021b94:	bd80      	pop	{r7, pc}
 8021b96:	bf00      	nop
 8021b98:	24062424 	.word	0x24062424
 8021b9c:	24062414 	.word	0x24062414

08021ba0 <HAL_UART_RxCpltCallback>:

void HAL_UART_RxCpltCallback(UART_HandleTypeDef * huart){
 8021ba0:	b480      	push	{r7}
 8021ba2:	b085      	sub	sp, #20
 8021ba4:	af00      	add	r7, sp, #0
 8021ba6:	6078      	str	r0, [r7, #4]
	for(size_t i = 0; i < NUM_UARTS; i++){ //TODO linkedList
 8021ba8:	2300      	movs	r3, #0
 8021baa:	60fb      	str	r3, [r7, #12]
 8021bac:	e011      	b.n	8021bd2 <HAL_UART_RxCpltCallback+0x32>
		if(huart == huarts[i]){
 8021bae:	4a12      	ldr	r2, [pc, #72]	; (8021bf8 <HAL_UART_RxCpltCallback+0x58>)
 8021bb0:	68fb      	ldr	r3, [r7, #12]
 8021bb2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8021bb6:	687a      	ldr	r2, [r7, #4]
 8021bb8:	429a      	cmp	r2, r3
 8021bba:	d107      	bne.n	8021bcc <HAL_UART_RxCpltCallback+0x2c>
			buarts[i]->topFlag = 1;
 8021bbc:	4a0f      	ldr	r2, [pc, #60]	; (8021bfc <HAL_UART_RxCpltCallback+0x5c>)
 8021bbe:	68fb      	ldr	r3, [r7, #12]
 8021bc0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8021bc4:	2201      	movs	r2, #1
 8021bc6:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
			return;
 8021bca:	e010      	b.n	8021bee <HAL_UART_RxCpltCallback+0x4e>
	for(size_t i = 0; i < NUM_UARTS; i++){ //TODO linkedList
 8021bcc:	68fb      	ldr	r3, [r7, #12]
 8021bce:	3301      	adds	r3, #1
 8021bd0:	60fb      	str	r3, [r7, #12]
 8021bd2:	68fb      	ldr	r3, [r7, #12]
 8021bd4:	2b03      	cmp	r3, #3
 8021bd6:	d9ea      	bls.n	8021bae <HAL_UART_RxCpltCallback+0xe>
	__asm volatile
 8021bd8:	f04f 0350 	mov.w	r3, #80	; 0x50
 8021bdc:	f383 8811 	msr	BASEPRI, r3
 8021be0:	f3bf 8f6f 	isb	sy
 8021be4:	f3bf 8f4f 	dsb	sy
 8021be8:	60bb      	str	r3, [r7, #8]
}
 8021bea:	bf00      	nop
		}
	}
	configASSERT(NULL);
 8021bec:	e7fe      	b.n	8021bec <HAL_UART_RxCpltCallback+0x4c>
}
 8021bee:	3714      	adds	r7, #20
 8021bf0:	46bd      	mov	sp, r7
 8021bf2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021bf6:	4770      	bx	lr
 8021bf8:	24062424 	.word	0x24062424
 8021bfc:	24062414 	.word	0x24062414

08021c00 <__errno>:
 8021c00:	4b01      	ldr	r3, [pc, #4]	; (8021c08 <__errno+0x8>)
 8021c02:	6818      	ldr	r0, [r3, #0]
 8021c04:	4770      	bx	lr
 8021c06:	bf00      	nop
 8021c08:	240001e4 	.word	0x240001e4

08021c0c <__libc_init_array>:
 8021c0c:	b570      	push	{r4, r5, r6, lr}
 8021c0e:	4d0d      	ldr	r5, [pc, #52]	; (8021c44 <__libc_init_array+0x38>)
 8021c10:	4c0d      	ldr	r4, [pc, #52]	; (8021c48 <__libc_init_array+0x3c>)
 8021c12:	1b64      	subs	r4, r4, r5
 8021c14:	10a4      	asrs	r4, r4, #2
 8021c16:	2600      	movs	r6, #0
 8021c18:	42a6      	cmp	r6, r4
 8021c1a:	d109      	bne.n	8021c30 <__libc_init_array+0x24>
 8021c1c:	4d0b      	ldr	r5, [pc, #44]	; (8021c4c <__libc_init_array+0x40>)
 8021c1e:	4c0c      	ldr	r4, [pc, #48]	; (8021c50 <__libc_init_array+0x44>)
 8021c20:	f000 fcc0 	bl	80225a4 <_init>
 8021c24:	1b64      	subs	r4, r4, r5
 8021c26:	10a4      	asrs	r4, r4, #2
 8021c28:	2600      	movs	r6, #0
 8021c2a:	42a6      	cmp	r6, r4
 8021c2c:	d105      	bne.n	8021c3a <__libc_init_array+0x2e>
 8021c2e:	bd70      	pop	{r4, r5, r6, pc}
 8021c30:	f855 3b04 	ldr.w	r3, [r5], #4
 8021c34:	4798      	blx	r3
 8021c36:	3601      	adds	r6, #1
 8021c38:	e7ee      	b.n	8021c18 <__libc_init_array+0xc>
 8021c3a:	f855 3b04 	ldr.w	r3, [r5], #4
 8021c3e:	4798      	blx	r3
 8021c40:	3601      	adds	r6, #1
 8021c42:	e7f2      	b.n	8021c2a <__libc_init_array+0x1e>
 8021c44:	080d9e44 	.word	0x080d9e44
 8021c48:	080d9e44 	.word	0x080d9e44
 8021c4c:	080d9e44 	.word	0x080d9e44
 8021c50:	080d9e48 	.word	0x080d9e48

08021c54 <__retarget_lock_acquire_recursive>:
 8021c54:	4770      	bx	lr

08021c56 <__retarget_lock_release_recursive>:
 8021c56:	4770      	bx	lr

08021c58 <memcpy>:
 8021c58:	440a      	add	r2, r1
 8021c5a:	4291      	cmp	r1, r2
 8021c5c:	f100 33ff 	add.w	r3, r0, #4294967295
 8021c60:	d100      	bne.n	8021c64 <memcpy+0xc>
 8021c62:	4770      	bx	lr
 8021c64:	b510      	push	{r4, lr}
 8021c66:	f811 4b01 	ldrb.w	r4, [r1], #1
 8021c6a:	f803 4f01 	strb.w	r4, [r3, #1]!
 8021c6e:	4291      	cmp	r1, r2
 8021c70:	d1f9      	bne.n	8021c66 <memcpy+0xe>
 8021c72:	bd10      	pop	{r4, pc}

08021c74 <memset>:
 8021c74:	4402      	add	r2, r0
 8021c76:	4603      	mov	r3, r0
 8021c78:	4293      	cmp	r3, r2
 8021c7a:	d100      	bne.n	8021c7e <memset+0xa>
 8021c7c:	4770      	bx	lr
 8021c7e:	f803 1b01 	strb.w	r1, [r3], #1
 8021c82:	e7f9      	b.n	8021c78 <memset+0x4>

08021c84 <_malloc_r>:
 8021c84:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8021c86:	1ccd      	adds	r5, r1, #3
 8021c88:	f025 0503 	bic.w	r5, r5, #3
 8021c8c:	3508      	adds	r5, #8
 8021c8e:	2d0c      	cmp	r5, #12
 8021c90:	bf38      	it	cc
 8021c92:	250c      	movcc	r5, #12
 8021c94:	2d00      	cmp	r5, #0
 8021c96:	4606      	mov	r6, r0
 8021c98:	db01      	blt.n	8021c9e <_malloc_r+0x1a>
 8021c9a:	42a9      	cmp	r1, r5
 8021c9c:	d903      	bls.n	8021ca6 <_malloc_r+0x22>
 8021c9e:	230c      	movs	r3, #12
 8021ca0:	6033      	str	r3, [r6, #0]
 8021ca2:	2000      	movs	r0, #0
 8021ca4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8021ca6:	f000 f8e9 	bl	8021e7c <__malloc_lock>
 8021caa:	4921      	ldr	r1, [pc, #132]	; (8021d30 <_malloc_r+0xac>)
 8021cac:	680a      	ldr	r2, [r1, #0]
 8021cae:	4614      	mov	r4, r2
 8021cb0:	b99c      	cbnz	r4, 8021cda <_malloc_r+0x56>
 8021cb2:	4f20      	ldr	r7, [pc, #128]	; (8021d34 <_malloc_r+0xb0>)
 8021cb4:	683b      	ldr	r3, [r7, #0]
 8021cb6:	b923      	cbnz	r3, 8021cc2 <_malloc_r+0x3e>
 8021cb8:	4621      	mov	r1, r4
 8021cba:	4630      	mov	r0, r6
 8021cbc:	f000 f8a6 	bl	8021e0c <_sbrk_r>
 8021cc0:	6038      	str	r0, [r7, #0]
 8021cc2:	4629      	mov	r1, r5
 8021cc4:	4630      	mov	r0, r6
 8021cc6:	f000 f8a1 	bl	8021e0c <_sbrk_r>
 8021cca:	1c43      	adds	r3, r0, #1
 8021ccc:	d123      	bne.n	8021d16 <_malloc_r+0x92>
 8021cce:	230c      	movs	r3, #12
 8021cd0:	6033      	str	r3, [r6, #0]
 8021cd2:	4630      	mov	r0, r6
 8021cd4:	f000 f8d8 	bl	8021e88 <__malloc_unlock>
 8021cd8:	e7e3      	b.n	8021ca2 <_malloc_r+0x1e>
 8021cda:	6823      	ldr	r3, [r4, #0]
 8021cdc:	1b5b      	subs	r3, r3, r5
 8021cde:	d417      	bmi.n	8021d10 <_malloc_r+0x8c>
 8021ce0:	2b0b      	cmp	r3, #11
 8021ce2:	d903      	bls.n	8021cec <_malloc_r+0x68>
 8021ce4:	6023      	str	r3, [r4, #0]
 8021ce6:	441c      	add	r4, r3
 8021ce8:	6025      	str	r5, [r4, #0]
 8021cea:	e004      	b.n	8021cf6 <_malloc_r+0x72>
 8021cec:	6863      	ldr	r3, [r4, #4]
 8021cee:	42a2      	cmp	r2, r4
 8021cf0:	bf0c      	ite	eq
 8021cf2:	600b      	streq	r3, [r1, #0]
 8021cf4:	6053      	strne	r3, [r2, #4]
 8021cf6:	4630      	mov	r0, r6
 8021cf8:	f000 f8c6 	bl	8021e88 <__malloc_unlock>
 8021cfc:	f104 000b 	add.w	r0, r4, #11
 8021d00:	1d23      	adds	r3, r4, #4
 8021d02:	f020 0007 	bic.w	r0, r0, #7
 8021d06:	1ac2      	subs	r2, r0, r3
 8021d08:	d0cc      	beq.n	8021ca4 <_malloc_r+0x20>
 8021d0a:	1a1b      	subs	r3, r3, r0
 8021d0c:	50a3      	str	r3, [r4, r2]
 8021d0e:	e7c9      	b.n	8021ca4 <_malloc_r+0x20>
 8021d10:	4622      	mov	r2, r4
 8021d12:	6864      	ldr	r4, [r4, #4]
 8021d14:	e7cc      	b.n	8021cb0 <_malloc_r+0x2c>
 8021d16:	1cc4      	adds	r4, r0, #3
 8021d18:	f024 0403 	bic.w	r4, r4, #3
 8021d1c:	42a0      	cmp	r0, r4
 8021d1e:	d0e3      	beq.n	8021ce8 <_malloc_r+0x64>
 8021d20:	1a21      	subs	r1, r4, r0
 8021d22:	4630      	mov	r0, r6
 8021d24:	f000 f872 	bl	8021e0c <_sbrk_r>
 8021d28:	3001      	adds	r0, #1
 8021d2a:	d1dd      	bne.n	8021ce8 <_malloc_r+0x64>
 8021d2c:	e7cf      	b.n	8021cce <_malloc_r+0x4a>
 8021d2e:	bf00      	nop
 8021d30:	24062434 	.word	0x24062434
 8021d34:	24062438 	.word	0x24062438

08021d38 <cleanup_glue>:
 8021d38:	b538      	push	{r3, r4, r5, lr}
 8021d3a:	460c      	mov	r4, r1
 8021d3c:	6809      	ldr	r1, [r1, #0]
 8021d3e:	4605      	mov	r5, r0
 8021d40:	b109      	cbz	r1, 8021d46 <cleanup_glue+0xe>
 8021d42:	f7ff fff9 	bl	8021d38 <cleanup_glue>
 8021d46:	4621      	mov	r1, r4
 8021d48:	4628      	mov	r0, r5
 8021d4a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8021d4e:	f000 b8a1 	b.w	8021e94 <_free_r>
	...

08021d54 <_reclaim_reent>:
 8021d54:	4b2c      	ldr	r3, [pc, #176]	; (8021e08 <_reclaim_reent+0xb4>)
 8021d56:	681b      	ldr	r3, [r3, #0]
 8021d58:	4283      	cmp	r3, r0
 8021d5a:	b570      	push	{r4, r5, r6, lr}
 8021d5c:	4604      	mov	r4, r0
 8021d5e:	d051      	beq.n	8021e04 <_reclaim_reent+0xb0>
 8021d60:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8021d62:	b143      	cbz	r3, 8021d76 <_reclaim_reent+0x22>
 8021d64:	68db      	ldr	r3, [r3, #12]
 8021d66:	2b00      	cmp	r3, #0
 8021d68:	d14a      	bne.n	8021e00 <_reclaim_reent+0xac>
 8021d6a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8021d6c:	6819      	ldr	r1, [r3, #0]
 8021d6e:	b111      	cbz	r1, 8021d76 <_reclaim_reent+0x22>
 8021d70:	4620      	mov	r0, r4
 8021d72:	f000 f88f 	bl	8021e94 <_free_r>
 8021d76:	6961      	ldr	r1, [r4, #20]
 8021d78:	b111      	cbz	r1, 8021d80 <_reclaim_reent+0x2c>
 8021d7a:	4620      	mov	r0, r4
 8021d7c:	f000 f88a 	bl	8021e94 <_free_r>
 8021d80:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8021d82:	b111      	cbz	r1, 8021d8a <_reclaim_reent+0x36>
 8021d84:	4620      	mov	r0, r4
 8021d86:	f000 f885 	bl	8021e94 <_free_r>
 8021d8a:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8021d8c:	b111      	cbz	r1, 8021d94 <_reclaim_reent+0x40>
 8021d8e:	4620      	mov	r0, r4
 8021d90:	f000 f880 	bl	8021e94 <_free_r>
 8021d94:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8021d96:	b111      	cbz	r1, 8021d9e <_reclaim_reent+0x4a>
 8021d98:	4620      	mov	r0, r4
 8021d9a:	f000 f87b 	bl	8021e94 <_free_r>
 8021d9e:	6c21      	ldr	r1, [r4, #64]	; 0x40
 8021da0:	b111      	cbz	r1, 8021da8 <_reclaim_reent+0x54>
 8021da2:	4620      	mov	r0, r4
 8021da4:	f000 f876 	bl	8021e94 <_free_r>
 8021da8:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 8021daa:	b111      	cbz	r1, 8021db2 <_reclaim_reent+0x5e>
 8021dac:	4620      	mov	r0, r4
 8021dae:	f000 f871 	bl	8021e94 <_free_r>
 8021db2:	6da1      	ldr	r1, [r4, #88]	; 0x58
 8021db4:	b111      	cbz	r1, 8021dbc <_reclaim_reent+0x68>
 8021db6:	4620      	mov	r0, r4
 8021db8:	f000 f86c 	bl	8021e94 <_free_r>
 8021dbc:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8021dbe:	b111      	cbz	r1, 8021dc6 <_reclaim_reent+0x72>
 8021dc0:	4620      	mov	r0, r4
 8021dc2:	f000 f867 	bl	8021e94 <_free_r>
 8021dc6:	69a3      	ldr	r3, [r4, #24]
 8021dc8:	b1e3      	cbz	r3, 8021e04 <_reclaim_reent+0xb0>
 8021dca:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8021dcc:	4620      	mov	r0, r4
 8021dce:	4798      	blx	r3
 8021dd0:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 8021dd2:	b1b9      	cbz	r1, 8021e04 <_reclaim_reent+0xb0>
 8021dd4:	4620      	mov	r0, r4
 8021dd6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8021dda:	f7ff bfad 	b.w	8021d38 <cleanup_glue>
 8021dde:	5949      	ldr	r1, [r1, r5]
 8021de0:	b941      	cbnz	r1, 8021df4 <_reclaim_reent+0xa0>
 8021de2:	3504      	adds	r5, #4
 8021de4:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8021de6:	2d80      	cmp	r5, #128	; 0x80
 8021de8:	68d9      	ldr	r1, [r3, #12]
 8021dea:	d1f8      	bne.n	8021dde <_reclaim_reent+0x8a>
 8021dec:	4620      	mov	r0, r4
 8021dee:	f000 f851 	bl	8021e94 <_free_r>
 8021df2:	e7ba      	b.n	8021d6a <_reclaim_reent+0x16>
 8021df4:	680e      	ldr	r6, [r1, #0]
 8021df6:	4620      	mov	r0, r4
 8021df8:	f000 f84c 	bl	8021e94 <_free_r>
 8021dfc:	4631      	mov	r1, r6
 8021dfe:	e7ef      	b.n	8021de0 <_reclaim_reent+0x8c>
 8021e00:	2500      	movs	r5, #0
 8021e02:	e7ef      	b.n	8021de4 <_reclaim_reent+0x90>
 8021e04:	bd70      	pop	{r4, r5, r6, pc}
 8021e06:	bf00      	nop
 8021e08:	240001e4 	.word	0x240001e4

08021e0c <_sbrk_r>:
 8021e0c:	b538      	push	{r3, r4, r5, lr}
 8021e0e:	4d06      	ldr	r5, [pc, #24]	; (8021e28 <_sbrk_r+0x1c>)
 8021e10:	2300      	movs	r3, #0
 8021e12:	4604      	mov	r4, r0
 8021e14:	4608      	mov	r0, r1
 8021e16:	602b      	str	r3, [r5, #0]
 8021e18:	f7f0 f956 	bl	80120c8 <_sbrk>
 8021e1c:	1c43      	adds	r3, r0, #1
 8021e1e:	d102      	bne.n	8021e26 <_sbrk_r+0x1a>
 8021e20:	682b      	ldr	r3, [r5, #0]
 8021e22:	b103      	cbz	r3, 8021e26 <_sbrk_r+0x1a>
 8021e24:	6023      	str	r3, [r4, #0]
 8021e26:	bd38      	pop	{r3, r4, r5, pc}
 8021e28:	2406369c 	.word	0x2406369c

08021e2c <siprintf>:
 8021e2c:	b40e      	push	{r1, r2, r3}
 8021e2e:	b500      	push	{lr}
 8021e30:	b09c      	sub	sp, #112	; 0x70
 8021e32:	ab1d      	add	r3, sp, #116	; 0x74
 8021e34:	9002      	str	r0, [sp, #8]
 8021e36:	9006      	str	r0, [sp, #24]
 8021e38:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 8021e3c:	4809      	ldr	r0, [pc, #36]	; (8021e64 <siprintf+0x38>)
 8021e3e:	9107      	str	r1, [sp, #28]
 8021e40:	9104      	str	r1, [sp, #16]
 8021e42:	4909      	ldr	r1, [pc, #36]	; (8021e68 <siprintf+0x3c>)
 8021e44:	f853 2b04 	ldr.w	r2, [r3], #4
 8021e48:	9105      	str	r1, [sp, #20]
 8021e4a:	6800      	ldr	r0, [r0, #0]
 8021e4c:	9301      	str	r3, [sp, #4]
 8021e4e:	a902      	add	r1, sp, #8
 8021e50:	f000 f8cc 	bl	8021fec <_svfiprintf_r>
 8021e54:	9b02      	ldr	r3, [sp, #8]
 8021e56:	2200      	movs	r2, #0
 8021e58:	701a      	strb	r2, [r3, #0]
 8021e5a:	b01c      	add	sp, #112	; 0x70
 8021e5c:	f85d eb04 	ldr.w	lr, [sp], #4
 8021e60:	b003      	add	sp, #12
 8021e62:	4770      	bx	lr
 8021e64:	240001e4 	.word	0x240001e4
 8021e68:	ffff0208 	.word	0xffff0208

08021e6c <strcpy>:
 8021e6c:	4603      	mov	r3, r0
 8021e6e:	f811 2b01 	ldrb.w	r2, [r1], #1
 8021e72:	f803 2b01 	strb.w	r2, [r3], #1
 8021e76:	2a00      	cmp	r2, #0
 8021e78:	d1f9      	bne.n	8021e6e <strcpy+0x2>
 8021e7a:	4770      	bx	lr

08021e7c <__malloc_lock>:
 8021e7c:	4801      	ldr	r0, [pc, #4]	; (8021e84 <__malloc_lock+0x8>)
 8021e7e:	f7ff bee9 	b.w	8021c54 <__retarget_lock_acquire_recursive>
 8021e82:	bf00      	nop
 8021e84:	24063694 	.word	0x24063694

08021e88 <__malloc_unlock>:
 8021e88:	4801      	ldr	r0, [pc, #4]	; (8021e90 <__malloc_unlock+0x8>)
 8021e8a:	f7ff bee4 	b.w	8021c56 <__retarget_lock_release_recursive>
 8021e8e:	bf00      	nop
 8021e90:	24063694 	.word	0x24063694

08021e94 <_free_r>:
 8021e94:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8021e96:	2900      	cmp	r1, #0
 8021e98:	d048      	beq.n	8021f2c <_free_r+0x98>
 8021e9a:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8021e9e:	9001      	str	r0, [sp, #4]
 8021ea0:	2b00      	cmp	r3, #0
 8021ea2:	f1a1 0404 	sub.w	r4, r1, #4
 8021ea6:	bfb8      	it	lt
 8021ea8:	18e4      	addlt	r4, r4, r3
 8021eaa:	f7ff ffe7 	bl	8021e7c <__malloc_lock>
 8021eae:	4a20      	ldr	r2, [pc, #128]	; (8021f30 <_free_r+0x9c>)
 8021eb0:	9801      	ldr	r0, [sp, #4]
 8021eb2:	6813      	ldr	r3, [r2, #0]
 8021eb4:	4615      	mov	r5, r2
 8021eb6:	b933      	cbnz	r3, 8021ec6 <_free_r+0x32>
 8021eb8:	6063      	str	r3, [r4, #4]
 8021eba:	6014      	str	r4, [r2, #0]
 8021ebc:	b003      	add	sp, #12
 8021ebe:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8021ec2:	f7ff bfe1 	b.w	8021e88 <__malloc_unlock>
 8021ec6:	42a3      	cmp	r3, r4
 8021ec8:	d90b      	bls.n	8021ee2 <_free_r+0x4e>
 8021eca:	6821      	ldr	r1, [r4, #0]
 8021ecc:	1862      	adds	r2, r4, r1
 8021ece:	4293      	cmp	r3, r2
 8021ed0:	bf04      	itt	eq
 8021ed2:	681a      	ldreq	r2, [r3, #0]
 8021ed4:	685b      	ldreq	r3, [r3, #4]
 8021ed6:	6063      	str	r3, [r4, #4]
 8021ed8:	bf04      	itt	eq
 8021eda:	1852      	addeq	r2, r2, r1
 8021edc:	6022      	streq	r2, [r4, #0]
 8021ede:	602c      	str	r4, [r5, #0]
 8021ee0:	e7ec      	b.n	8021ebc <_free_r+0x28>
 8021ee2:	461a      	mov	r2, r3
 8021ee4:	685b      	ldr	r3, [r3, #4]
 8021ee6:	b10b      	cbz	r3, 8021eec <_free_r+0x58>
 8021ee8:	42a3      	cmp	r3, r4
 8021eea:	d9fa      	bls.n	8021ee2 <_free_r+0x4e>
 8021eec:	6811      	ldr	r1, [r2, #0]
 8021eee:	1855      	adds	r5, r2, r1
 8021ef0:	42a5      	cmp	r5, r4
 8021ef2:	d10b      	bne.n	8021f0c <_free_r+0x78>
 8021ef4:	6824      	ldr	r4, [r4, #0]
 8021ef6:	4421      	add	r1, r4
 8021ef8:	1854      	adds	r4, r2, r1
 8021efa:	42a3      	cmp	r3, r4
 8021efc:	6011      	str	r1, [r2, #0]
 8021efe:	d1dd      	bne.n	8021ebc <_free_r+0x28>
 8021f00:	681c      	ldr	r4, [r3, #0]
 8021f02:	685b      	ldr	r3, [r3, #4]
 8021f04:	6053      	str	r3, [r2, #4]
 8021f06:	4421      	add	r1, r4
 8021f08:	6011      	str	r1, [r2, #0]
 8021f0a:	e7d7      	b.n	8021ebc <_free_r+0x28>
 8021f0c:	d902      	bls.n	8021f14 <_free_r+0x80>
 8021f0e:	230c      	movs	r3, #12
 8021f10:	6003      	str	r3, [r0, #0]
 8021f12:	e7d3      	b.n	8021ebc <_free_r+0x28>
 8021f14:	6825      	ldr	r5, [r4, #0]
 8021f16:	1961      	adds	r1, r4, r5
 8021f18:	428b      	cmp	r3, r1
 8021f1a:	bf04      	itt	eq
 8021f1c:	6819      	ldreq	r1, [r3, #0]
 8021f1e:	685b      	ldreq	r3, [r3, #4]
 8021f20:	6063      	str	r3, [r4, #4]
 8021f22:	bf04      	itt	eq
 8021f24:	1949      	addeq	r1, r1, r5
 8021f26:	6021      	streq	r1, [r4, #0]
 8021f28:	6054      	str	r4, [r2, #4]
 8021f2a:	e7c7      	b.n	8021ebc <_free_r+0x28>
 8021f2c:	b003      	add	sp, #12
 8021f2e:	bd30      	pop	{r4, r5, pc}
 8021f30:	24062434 	.word	0x24062434

08021f34 <__ssputs_r>:
 8021f34:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8021f38:	688e      	ldr	r6, [r1, #8]
 8021f3a:	429e      	cmp	r6, r3
 8021f3c:	4682      	mov	sl, r0
 8021f3e:	460c      	mov	r4, r1
 8021f40:	4690      	mov	r8, r2
 8021f42:	461f      	mov	r7, r3
 8021f44:	d838      	bhi.n	8021fb8 <__ssputs_r+0x84>
 8021f46:	898a      	ldrh	r2, [r1, #12]
 8021f48:	f412 6f90 	tst.w	r2, #1152	; 0x480
 8021f4c:	d032      	beq.n	8021fb4 <__ssputs_r+0x80>
 8021f4e:	6825      	ldr	r5, [r4, #0]
 8021f50:	6909      	ldr	r1, [r1, #16]
 8021f52:	eba5 0901 	sub.w	r9, r5, r1
 8021f56:	6965      	ldr	r5, [r4, #20]
 8021f58:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 8021f5c:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 8021f60:	3301      	adds	r3, #1
 8021f62:	444b      	add	r3, r9
 8021f64:	106d      	asrs	r5, r5, #1
 8021f66:	429d      	cmp	r5, r3
 8021f68:	bf38      	it	cc
 8021f6a:	461d      	movcc	r5, r3
 8021f6c:	0553      	lsls	r3, r2, #21
 8021f6e:	d531      	bpl.n	8021fd4 <__ssputs_r+0xa0>
 8021f70:	4629      	mov	r1, r5
 8021f72:	f7ff fe87 	bl	8021c84 <_malloc_r>
 8021f76:	4606      	mov	r6, r0
 8021f78:	b950      	cbnz	r0, 8021f90 <__ssputs_r+0x5c>
 8021f7a:	230c      	movs	r3, #12
 8021f7c:	f8ca 3000 	str.w	r3, [sl]
 8021f80:	89a3      	ldrh	r3, [r4, #12]
 8021f82:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8021f86:	81a3      	strh	r3, [r4, #12]
 8021f88:	f04f 30ff 	mov.w	r0, #4294967295
 8021f8c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8021f90:	6921      	ldr	r1, [r4, #16]
 8021f92:	464a      	mov	r2, r9
 8021f94:	f7ff fe60 	bl	8021c58 <memcpy>
 8021f98:	89a3      	ldrh	r3, [r4, #12]
 8021f9a:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 8021f9e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8021fa2:	81a3      	strh	r3, [r4, #12]
 8021fa4:	6126      	str	r6, [r4, #16]
 8021fa6:	6165      	str	r5, [r4, #20]
 8021fa8:	444e      	add	r6, r9
 8021faa:	eba5 0509 	sub.w	r5, r5, r9
 8021fae:	6026      	str	r6, [r4, #0]
 8021fb0:	60a5      	str	r5, [r4, #8]
 8021fb2:	463e      	mov	r6, r7
 8021fb4:	42be      	cmp	r6, r7
 8021fb6:	d900      	bls.n	8021fba <__ssputs_r+0x86>
 8021fb8:	463e      	mov	r6, r7
 8021fba:	4632      	mov	r2, r6
 8021fbc:	6820      	ldr	r0, [r4, #0]
 8021fbe:	4641      	mov	r1, r8
 8021fc0:	f000 faa8 	bl	8022514 <memmove>
 8021fc4:	68a3      	ldr	r3, [r4, #8]
 8021fc6:	6822      	ldr	r2, [r4, #0]
 8021fc8:	1b9b      	subs	r3, r3, r6
 8021fca:	4432      	add	r2, r6
 8021fcc:	60a3      	str	r3, [r4, #8]
 8021fce:	6022      	str	r2, [r4, #0]
 8021fd0:	2000      	movs	r0, #0
 8021fd2:	e7db      	b.n	8021f8c <__ssputs_r+0x58>
 8021fd4:	462a      	mov	r2, r5
 8021fd6:	f000 fab7 	bl	8022548 <_realloc_r>
 8021fda:	4606      	mov	r6, r0
 8021fdc:	2800      	cmp	r0, #0
 8021fde:	d1e1      	bne.n	8021fa4 <__ssputs_r+0x70>
 8021fe0:	6921      	ldr	r1, [r4, #16]
 8021fe2:	4650      	mov	r0, sl
 8021fe4:	f7ff ff56 	bl	8021e94 <_free_r>
 8021fe8:	e7c7      	b.n	8021f7a <__ssputs_r+0x46>
	...

08021fec <_svfiprintf_r>:
 8021fec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8021ff0:	4698      	mov	r8, r3
 8021ff2:	898b      	ldrh	r3, [r1, #12]
 8021ff4:	061b      	lsls	r3, r3, #24
 8021ff6:	b09d      	sub	sp, #116	; 0x74
 8021ff8:	4607      	mov	r7, r0
 8021ffa:	460d      	mov	r5, r1
 8021ffc:	4614      	mov	r4, r2
 8021ffe:	d50e      	bpl.n	802201e <_svfiprintf_r+0x32>
 8022000:	690b      	ldr	r3, [r1, #16]
 8022002:	b963      	cbnz	r3, 802201e <_svfiprintf_r+0x32>
 8022004:	2140      	movs	r1, #64	; 0x40
 8022006:	f7ff fe3d 	bl	8021c84 <_malloc_r>
 802200a:	6028      	str	r0, [r5, #0]
 802200c:	6128      	str	r0, [r5, #16]
 802200e:	b920      	cbnz	r0, 802201a <_svfiprintf_r+0x2e>
 8022010:	230c      	movs	r3, #12
 8022012:	603b      	str	r3, [r7, #0]
 8022014:	f04f 30ff 	mov.w	r0, #4294967295
 8022018:	e0d1      	b.n	80221be <_svfiprintf_r+0x1d2>
 802201a:	2340      	movs	r3, #64	; 0x40
 802201c:	616b      	str	r3, [r5, #20]
 802201e:	2300      	movs	r3, #0
 8022020:	9309      	str	r3, [sp, #36]	; 0x24
 8022022:	2320      	movs	r3, #32
 8022024:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 8022028:	f8cd 800c 	str.w	r8, [sp, #12]
 802202c:	2330      	movs	r3, #48	; 0x30
 802202e:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 80221d8 <_svfiprintf_r+0x1ec>
 8022032:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 8022036:	f04f 0901 	mov.w	r9, #1
 802203a:	4623      	mov	r3, r4
 802203c:	469a      	mov	sl, r3
 802203e:	f813 2b01 	ldrb.w	r2, [r3], #1
 8022042:	b10a      	cbz	r2, 8022048 <_svfiprintf_r+0x5c>
 8022044:	2a25      	cmp	r2, #37	; 0x25
 8022046:	d1f9      	bne.n	802203c <_svfiprintf_r+0x50>
 8022048:	ebba 0b04 	subs.w	fp, sl, r4
 802204c:	d00b      	beq.n	8022066 <_svfiprintf_r+0x7a>
 802204e:	465b      	mov	r3, fp
 8022050:	4622      	mov	r2, r4
 8022052:	4629      	mov	r1, r5
 8022054:	4638      	mov	r0, r7
 8022056:	f7ff ff6d 	bl	8021f34 <__ssputs_r>
 802205a:	3001      	adds	r0, #1
 802205c:	f000 80aa 	beq.w	80221b4 <_svfiprintf_r+0x1c8>
 8022060:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8022062:	445a      	add	r2, fp
 8022064:	9209      	str	r2, [sp, #36]	; 0x24
 8022066:	f89a 3000 	ldrb.w	r3, [sl]
 802206a:	2b00      	cmp	r3, #0
 802206c:	f000 80a2 	beq.w	80221b4 <_svfiprintf_r+0x1c8>
 8022070:	2300      	movs	r3, #0
 8022072:	f04f 32ff 	mov.w	r2, #4294967295
 8022076:	e9cd 2305 	strd	r2, r3, [sp, #20]
 802207a:	f10a 0a01 	add.w	sl, sl, #1
 802207e:	9304      	str	r3, [sp, #16]
 8022080:	9307      	str	r3, [sp, #28]
 8022082:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 8022086:	931a      	str	r3, [sp, #104]	; 0x68
 8022088:	4654      	mov	r4, sl
 802208a:	2205      	movs	r2, #5
 802208c:	f814 1b01 	ldrb.w	r1, [r4], #1
 8022090:	4851      	ldr	r0, [pc, #324]	; (80221d8 <_svfiprintf_r+0x1ec>)
 8022092:	f7de f93d 	bl	8000310 <memchr>
 8022096:	9a04      	ldr	r2, [sp, #16]
 8022098:	b9d8      	cbnz	r0, 80220d2 <_svfiprintf_r+0xe6>
 802209a:	06d0      	lsls	r0, r2, #27
 802209c:	bf44      	itt	mi
 802209e:	2320      	movmi	r3, #32
 80220a0:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 80220a4:	0711      	lsls	r1, r2, #28
 80220a6:	bf44      	itt	mi
 80220a8:	232b      	movmi	r3, #43	; 0x2b
 80220aa:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 80220ae:	f89a 3000 	ldrb.w	r3, [sl]
 80220b2:	2b2a      	cmp	r3, #42	; 0x2a
 80220b4:	d015      	beq.n	80220e2 <_svfiprintf_r+0xf6>
 80220b6:	9a07      	ldr	r2, [sp, #28]
 80220b8:	4654      	mov	r4, sl
 80220ba:	2000      	movs	r0, #0
 80220bc:	f04f 0c0a 	mov.w	ip, #10
 80220c0:	4621      	mov	r1, r4
 80220c2:	f811 3b01 	ldrb.w	r3, [r1], #1
 80220c6:	3b30      	subs	r3, #48	; 0x30
 80220c8:	2b09      	cmp	r3, #9
 80220ca:	d94e      	bls.n	802216a <_svfiprintf_r+0x17e>
 80220cc:	b1b0      	cbz	r0, 80220fc <_svfiprintf_r+0x110>
 80220ce:	9207      	str	r2, [sp, #28]
 80220d0:	e014      	b.n	80220fc <_svfiprintf_r+0x110>
 80220d2:	eba0 0308 	sub.w	r3, r0, r8
 80220d6:	fa09 f303 	lsl.w	r3, r9, r3
 80220da:	4313      	orrs	r3, r2
 80220dc:	9304      	str	r3, [sp, #16]
 80220de:	46a2      	mov	sl, r4
 80220e0:	e7d2      	b.n	8022088 <_svfiprintf_r+0x9c>
 80220e2:	9b03      	ldr	r3, [sp, #12]
 80220e4:	1d19      	adds	r1, r3, #4
 80220e6:	681b      	ldr	r3, [r3, #0]
 80220e8:	9103      	str	r1, [sp, #12]
 80220ea:	2b00      	cmp	r3, #0
 80220ec:	bfbb      	ittet	lt
 80220ee:	425b      	neglt	r3, r3
 80220f0:	f042 0202 	orrlt.w	r2, r2, #2
 80220f4:	9307      	strge	r3, [sp, #28]
 80220f6:	9307      	strlt	r3, [sp, #28]
 80220f8:	bfb8      	it	lt
 80220fa:	9204      	strlt	r2, [sp, #16]
 80220fc:	7823      	ldrb	r3, [r4, #0]
 80220fe:	2b2e      	cmp	r3, #46	; 0x2e
 8022100:	d10c      	bne.n	802211c <_svfiprintf_r+0x130>
 8022102:	7863      	ldrb	r3, [r4, #1]
 8022104:	2b2a      	cmp	r3, #42	; 0x2a
 8022106:	d135      	bne.n	8022174 <_svfiprintf_r+0x188>
 8022108:	9b03      	ldr	r3, [sp, #12]
 802210a:	1d1a      	adds	r2, r3, #4
 802210c:	681b      	ldr	r3, [r3, #0]
 802210e:	9203      	str	r2, [sp, #12]
 8022110:	2b00      	cmp	r3, #0
 8022112:	bfb8      	it	lt
 8022114:	f04f 33ff 	movlt.w	r3, #4294967295
 8022118:	3402      	adds	r4, #2
 802211a:	9305      	str	r3, [sp, #20]
 802211c:	f8df a0c8 	ldr.w	sl, [pc, #200]	; 80221e8 <_svfiprintf_r+0x1fc>
 8022120:	7821      	ldrb	r1, [r4, #0]
 8022122:	2203      	movs	r2, #3
 8022124:	4650      	mov	r0, sl
 8022126:	f7de f8f3 	bl	8000310 <memchr>
 802212a:	b140      	cbz	r0, 802213e <_svfiprintf_r+0x152>
 802212c:	2340      	movs	r3, #64	; 0x40
 802212e:	eba0 000a 	sub.w	r0, r0, sl
 8022132:	fa03 f000 	lsl.w	r0, r3, r0
 8022136:	9b04      	ldr	r3, [sp, #16]
 8022138:	4303      	orrs	r3, r0
 802213a:	3401      	adds	r4, #1
 802213c:	9304      	str	r3, [sp, #16]
 802213e:	f814 1b01 	ldrb.w	r1, [r4], #1
 8022142:	4826      	ldr	r0, [pc, #152]	; (80221dc <_svfiprintf_r+0x1f0>)
 8022144:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 8022148:	2206      	movs	r2, #6
 802214a:	f7de f8e1 	bl	8000310 <memchr>
 802214e:	2800      	cmp	r0, #0
 8022150:	d038      	beq.n	80221c4 <_svfiprintf_r+0x1d8>
 8022152:	4b23      	ldr	r3, [pc, #140]	; (80221e0 <_svfiprintf_r+0x1f4>)
 8022154:	bb1b      	cbnz	r3, 802219e <_svfiprintf_r+0x1b2>
 8022156:	9b03      	ldr	r3, [sp, #12]
 8022158:	3307      	adds	r3, #7
 802215a:	f023 0307 	bic.w	r3, r3, #7
 802215e:	3308      	adds	r3, #8
 8022160:	9303      	str	r3, [sp, #12]
 8022162:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8022164:	4433      	add	r3, r6
 8022166:	9309      	str	r3, [sp, #36]	; 0x24
 8022168:	e767      	b.n	802203a <_svfiprintf_r+0x4e>
 802216a:	fb0c 3202 	mla	r2, ip, r2, r3
 802216e:	460c      	mov	r4, r1
 8022170:	2001      	movs	r0, #1
 8022172:	e7a5      	b.n	80220c0 <_svfiprintf_r+0xd4>
 8022174:	2300      	movs	r3, #0
 8022176:	3401      	adds	r4, #1
 8022178:	9305      	str	r3, [sp, #20]
 802217a:	4619      	mov	r1, r3
 802217c:	f04f 0c0a 	mov.w	ip, #10
 8022180:	4620      	mov	r0, r4
 8022182:	f810 2b01 	ldrb.w	r2, [r0], #1
 8022186:	3a30      	subs	r2, #48	; 0x30
 8022188:	2a09      	cmp	r2, #9
 802218a:	d903      	bls.n	8022194 <_svfiprintf_r+0x1a8>
 802218c:	2b00      	cmp	r3, #0
 802218e:	d0c5      	beq.n	802211c <_svfiprintf_r+0x130>
 8022190:	9105      	str	r1, [sp, #20]
 8022192:	e7c3      	b.n	802211c <_svfiprintf_r+0x130>
 8022194:	fb0c 2101 	mla	r1, ip, r1, r2
 8022198:	4604      	mov	r4, r0
 802219a:	2301      	movs	r3, #1
 802219c:	e7f0      	b.n	8022180 <_svfiprintf_r+0x194>
 802219e:	ab03      	add	r3, sp, #12
 80221a0:	9300      	str	r3, [sp, #0]
 80221a2:	462a      	mov	r2, r5
 80221a4:	4b0f      	ldr	r3, [pc, #60]	; (80221e4 <_svfiprintf_r+0x1f8>)
 80221a6:	a904      	add	r1, sp, #16
 80221a8:	4638      	mov	r0, r7
 80221aa:	f3af 8000 	nop.w
 80221ae:	1c42      	adds	r2, r0, #1
 80221b0:	4606      	mov	r6, r0
 80221b2:	d1d6      	bne.n	8022162 <_svfiprintf_r+0x176>
 80221b4:	89ab      	ldrh	r3, [r5, #12]
 80221b6:	065b      	lsls	r3, r3, #25
 80221b8:	f53f af2c 	bmi.w	8022014 <_svfiprintf_r+0x28>
 80221bc:	9809      	ldr	r0, [sp, #36]	; 0x24
 80221be:	b01d      	add	sp, #116	; 0x74
 80221c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80221c4:	ab03      	add	r3, sp, #12
 80221c6:	9300      	str	r3, [sp, #0]
 80221c8:	462a      	mov	r2, r5
 80221ca:	4b06      	ldr	r3, [pc, #24]	; (80221e4 <_svfiprintf_r+0x1f8>)
 80221cc:	a904      	add	r1, sp, #16
 80221ce:	4638      	mov	r0, r7
 80221d0:	f000 f87a 	bl	80222c8 <_printf_i>
 80221d4:	e7eb      	b.n	80221ae <_svfiprintf_r+0x1c2>
 80221d6:	bf00      	nop
 80221d8:	080d9e08 	.word	0x080d9e08
 80221dc:	080d9e12 	.word	0x080d9e12
 80221e0:	00000000 	.word	0x00000000
 80221e4:	08021f35 	.word	0x08021f35
 80221e8:	080d9e0e 	.word	0x080d9e0e

080221ec <_printf_common>:
 80221ec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80221f0:	4616      	mov	r6, r2
 80221f2:	4699      	mov	r9, r3
 80221f4:	688a      	ldr	r2, [r1, #8]
 80221f6:	690b      	ldr	r3, [r1, #16]
 80221f8:	f8dd 8020 	ldr.w	r8, [sp, #32]
 80221fc:	4293      	cmp	r3, r2
 80221fe:	bfb8      	it	lt
 8022200:	4613      	movlt	r3, r2
 8022202:	6033      	str	r3, [r6, #0]
 8022204:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 8022208:	4607      	mov	r7, r0
 802220a:	460c      	mov	r4, r1
 802220c:	b10a      	cbz	r2, 8022212 <_printf_common+0x26>
 802220e:	3301      	adds	r3, #1
 8022210:	6033      	str	r3, [r6, #0]
 8022212:	6823      	ldr	r3, [r4, #0]
 8022214:	0699      	lsls	r1, r3, #26
 8022216:	bf42      	ittt	mi
 8022218:	6833      	ldrmi	r3, [r6, #0]
 802221a:	3302      	addmi	r3, #2
 802221c:	6033      	strmi	r3, [r6, #0]
 802221e:	6825      	ldr	r5, [r4, #0]
 8022220:	f015 0506 	ands.w	r5, r5, #6
 8022224:	d106      	bne.n	8022234 <_printf_common+0x48>
 8022226:	f104 0a19 	add.w	sl, r4, #25
 802222a:	68e3      	ldr	r3, [r4, #12]
 802222c:	6832      	ldr	r2, [r6, #0]
 802222e:	1a9b      	subs	r3, r3, r2
 8022230:	42ab      	cmp	r3, r5
 8022232:	dc26      	bgt.n	8022282 <_printf_common+0x96>
 8022234:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 8022238:	1e13      	subs	r3, r2, #0
 802223a:	6822      	ldr	r2, [r4, #0]
 802223c:	bf18      	it	ne
 802223e:	2301      	movne	r3, #1
 8022240:	0692      	lsls	r2, r2, #26
 8022242:	d42b      	bmi.n	802229c <_printf_common+0xb0>
 8022244:	f104 0243 	add.w	r2, r4, #67	; 0x43
 8022248:	4649      	mov	r1, r9
 802224a:	4638      	mov	r0, r7
 802224c:	47c0      	blx	r8
 802224e:	3001      	adds	r0, #1
 8022250:	d01e      	beq.n	8022290 <_printf_common+0xa4>
 8022252:	6823      	ldr	r3, [r4, #0]
 8022254:	68e5      	ldr	r5, [r4, #12]
 8022256:	6832      	ldr	r2, [r6, #0]
 8022258:	f003 0306 	and.w	r3, r3, #6
 802225c:	2b04      	cmp	r3, #4
 802225e:	bf08      	it	eq
 8022260:	1aad      	subeq	r5, r5, r2
 8022262:	68a3      	ldr	r3, [r4, #8]
 8022264:	6922      	ldr	r2, [r4, #16]
 8022266:	bf0c      	ite	eq
 8022268:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 802226c:	2500      	movne	r5, #0
 802226e:	4293      	cmp	r3, r2
 8022270:	bfc4      	itt	gt
 8022272:	1a9b      	subgt	r3, r3, r2
 8022274:	18ed      	addgt	r5, r5, r3
 8022276:	2600      	movs	r6, #0
 8022278:	341a      	adds	r4, #26
 802227a:	42b5      	cmp	r5, r6
 802227c:	d11a      	bne.n	80222b4 <_printf_common+0xc8>
 802227e:	2000      	movs	r0, #0
 8022280:	e008      	b.n	8022294 <_printf_common+0xa8>
 8022282:	2301      	movs	r3, #1
 8022284:	4652      	mov	r2, sl
 8022286:	4649      	mov	r1, r9
 8022288:	4638      	mov	r0, r7
 802228a:	47c0      	blx	r8
 802228c:	3001      	adds	r0, #1
 802228e:	d103      	bne.n	8022298 <_printf_common+0xac>
 8022290:	f04f 30ff 	mov.w	r0, #4294967295
 8022294:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8022298:	3501      	adds	r5, #1
 802229a:	e7c6      	b.n	802222a <_printf_common+0x3e>
 802229c:	18e1      	adds	r1, r4, r3
 802229e:	1c5a      	adds	r2, r3, #1
 80222a0:	2030      	movs	r0, #48	; 0x30
 80222a2:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 80222a6:	4422      	add	r2, r4
 80222a8:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 80222ac:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 80222b0:	3302      	adds	r3, #2
 80222b2:	e7c7      	b.n	8022244 <_printf_common+0x58>
 80222b4:	2301      	movs	r3, #1
 80222b6:	4622      	mov	r2, r4
 80222b8:	4649      	mov	r1, r9
 80222ba:	4638      	mov	r0, r7
 80222bc:	47c0      	blx	r8
 80222be:	3001      	adds	r0, #1
 80222c0:	d0e6      	beq.n	8022290 <_printf_common+0xa4>
 80222c2:	3601      	adds	r6, #1
 80222c4:	e7d9      	b.n	802227a <_printf_common+0x8e>
	...

080222c8 <_printf_i>:
 80222c8:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 80222cc:	460c      	mov	r4, r1
 80222ce:	4691      	mov	r9, r2
 80222d0:	7e27      	ldrb	r7, [r4, #24]
 80222d2:	990c      	ldr	r1, [sp, #48]	; 0x30
 80222d4:	2f78      	cmp	r7, #120	; 0x78
 80222d6:	4680      	mov	r8, r0
 80222d8:	469a      	mov	sl, r3
 80222da:	f104 0243 	add.w	r2, r4, #67	; 0x43
 80222de:	d807      	bhi.n	80222f0 <_printf_i+0x28>
 80222e0:	2f62      	cmp	r7, #98	; 0x62
 80222e2:	d80a      	bhi.n	80222fa <_printf_i+0x32>
 80222e4:	2f00      	cmp	r7, #0
 80222e6:	f000 80d8 	beq.w	802249a <_printf_i+0x1d2>
 80222ea:	2f58      	cmp	r7, #88	; 0x58
 80222ec:	f000 80a3 	beq.w	8022436 <_printf_i+0x16e>
 80222f0:	f104 0642 	add.w	r6, r4, #66	; 0x42
 80222f4:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
 80222f8:	e03a      	b.n	8022370 <_printf_i+0xa8>
 80222fa:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
 80222fe:	2b15      	cmp	r3, #21
 8022300:	d8f6      	bhi.n	80222f0 <_printf_i+0x28>
 8022302:	a001      	add	r0, pc, #4	; (adr r0, 8022308 <_printf_i+0x40>)
 8022304:	f850 f023 	ldr.w	pc, [r0, r3, lsl #2]
 8022308:	08022361 	.word	0x08022361
 802230c:	08022375 	.word	0x08022375
 8022310:	080222f1 	.word	0x080222f1
 8022314:	080222f1 	.word	0x080222f1
 8022318:	080222f1 	.word	0x080222f1
 802231c:	080222f1 	.word	0x080222f1
 8022320:	08022375 	.word	0x08022375
 8022324:	080222f1 	.word	0x080222f1
 8022328:	080222f1 	.word	0x080222f1
 802232c:	080222f1 	.word	0x080222f1
 8022330:	080222f1 	.word	0x080222f1
 8022334:	08022481 	.word	0x08022481
 8022338:	080223a5 	.word	0x080223a5
 802233c:	08022463 	.word	0x08022463
 8022340:	080222f1 	.word	0x080222f1
 8022344:	080222f1 	.word	0x080222f1
 8022348:	080224a3 	.word	0x080224a3
 802234c:	080222f1 	.word	0x080222f1
 8022350:	080223a5 	.word	0x080223a5
 8022354:	080222f1 	.word	0x080222f1
 8022358:	080222f1 	.word	0x080222f1
 802235c:	0802246b 	.word	0x0802246b
 8022360:	680b      	ldr	r3, [r1, #0]
 8022362:	1d1a      	adds	r2, r3, #4
 8022364:	681b      	ldr	r3, [r3, #0]
 8022366:	600a      	str	r2, [r1, #0]
 8022368:	f104 0642 	add.w	r6, r4, #66	; 0x42
 802236c:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8022370:	2301      	movs	r3, #1
 8022372:	e0a3      	b.n	80224bc <_printf_i+0x1f4>
 8022374:	6825      	ldr	r5, [r4, #0]
 8022376:	6808      	ldr	r0, [r1, #0]
 8022378:	062e      	lsls	r6, r5, #24
 802237a:	f100 0304 	add.w	r3, r0, #4
 802237e:	d50a      	bpl.n	8022396 <_printf_i+0xce>
 8022380:	6805      	ldr	r5, [r0, #0]
 8022382:	600b      	str	r3, [r1, #0]
 8022384:	2d00      	cmp	r5, #0
 8022386:	da03      	bge.n	8022390 <_printf_i+0xc8>
 8022388:	232d      	movs	r3, #45	; 0x2d
 802238a:	426d      	negs	r5, r5
 802238c:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8022390:	485e      	ldr	r0, [pc, #376]	; (802250c <_printf_i+0x244>)
 8022392:	230a      	movs	r3, #10
 8022394:	e019      	b.n	80223ca <_printf_i+0x102>
 8022396:	f015 0f40 	tst.w	r5, #64	; 0x40
 802239a:	6805      	ldr	r5, [r0, #0]
 802239c:	600b      	str	r3, [r1, #0]
 802239e:	bf18      	it	ne
 80223a0:	b22d      	sxthne	r5, r5
 80223a2:	e7ef      	b.n	8022384 <_printf_i+0xbc>
 80223a4:	680b      	ldr	r3, [r1, #0]
 80223a6:	6825      	ldr	r5, [r4, #0]
 80223a8:	1d18      	adds	r0, r3, #4
 80223aa:	6008      	str	r0, [r1, #0]
 80223ac:	0628      	lsls	r0, r5, #24
 80223ae:	d501      	bpl.n	80223b4 <_printf_i+0xec>
 80223b0:	681d      	ldr	r5, [r3, #0]
 80223b2:	e002      	b.n	80223ba <_printf_i+0xf2>
 80223b4:	0669      	lsls	r1, r5, #25
 80223b6:	d5fb      	bpl.n	80223b0 <_printf_i+0xe8>
 80223b8:	881d      	ldrh	r5, [r3, #0]
 80223ba:	4854      	ldr	r0, [pc, #336]	; (802250c <_printf_i+0x244>)
 80223bc:	2f6f      	cmp	r7, #111	; 0x6f
 80223be:	bf0c      	ite	eq
 80223c0:	2308      	moveq	r3, #8
 80223c2:	230a      	movne	r3, #10
 80223c4:	2100      	movs	r1, #0
 80223c6:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 80223ca:	6866      	ldr	r6, [r4, #4]
 80223cc:	60a6      	str	r6, [r4, #8]
 80223ce:	2e00      	cmp	r6, #0
 80223d0:	bfa2      	ittt	ge
 80223d2:	6821      	ldrge	r1, [r4, #0]
 80223d4:	f021 0104 	bicge.w	r1, r1, #4
 80223d8:	6021      	strge	r1, [r4, #0]
 80223da:	b90d      	cbnz	r5, 80223e0 <_printf_i+0x118>
 80223dc:	2e00      	cmp	r6, #0
 80223de:	d04d      	beq.n	802247c <_printf_i+0x1b4>
 80223e0:	4616      	mov	r6, r2
 80223e2:	fbb5 f1f3 	udiv	r1, r5, r3
 80223e6:	fb03 5711 	mls	r7, r3, r1, r5
 80223ea:	5dc7      	ldrb	r7, [r0, r7]
 80223ec:	f806 7d01 	strb.w	r7, [r6, #-1]!
 80223f0:	462f      	mov	r7, r5
 80223f2:	42bb      	cmp	r3, r7
 80223f4:	460d      	mov	r5, r1
 80223f6:	d9f4      	bls.n	80223e2 <_printf_i+0x11a>
 80223f8:	2b08      	cmp	r3, #8
 80223fa:	d10b      	bne.n	8022414 <_printf_i+0x14c>
 80223fc:	6823      	ldr	r3, [r4, #0]
 80223fe:	07df      	lsls	r7, r3, #31
 8022400:	d508      	bpl.n	8022414 <_printf_i+0x14c>
 8022402:	6923      	ldr	r3, [r4, #16]
 8022404:	6861      	ldr	r1, [r4, #4]
 8022406:	4299      	cmp	r1, r3
 8022408:	bfde      	ittt	le
 802240a:	2330      	movle	r3, #48	; 0x30
 802240c:	f806 3c01 	strble.w	r3, [r6, #-1]
 8022410:	f106 36ff 	addle.w	r6, r6, #4294967295
 8022414:	1b92      	subs	r2, r2, r6
 8022416:	6122      	str	r2, [r4, #16]
 8022418:	f8cd a000 	str.w	sl, [sp]
 802241c:	464b      	mov	r3, r9
 802241e:	aa03      	add	r2, sp, #12
 8022420:	4621      	mov	r1, r4
 8022422:	4640      	mov	r0, r8
 8022424:	f7ff fee2 	bl	80221ec <_printf_common>
 8022428:	3001      	adds	r0, #1
 802242a:	d14c      	bne.n	80224c6 <_printf_i+0x1fe>
 802242c:	f04f 30ff 	mov.w	r0, #4294967295
 8022430:	b004      	add	sp, #16
 8022432:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8022436:	4835      	ldr	r0, [pc, #212]	; (802250c <_printf_i+0x244>)
 8022438:	f884 7045 	strb.w	r7, [r4, #69]	; 0x45
 802243c:	6823      	ldr	r3, [r4, #0]
 802243e:	680e      	ldr	r6, [r1, #0]
 8022440:	061f      	lsls	r7, r3, #24
 8022442:	f856 5b04 	ldr.w	r5, [r6], #4
 8022446:	600e      	str	r6, [r1, #0]
 8022448:	d514      	bpl.n	8022474 <_printf_i+0x1ac>
 802244a:	07d9      	lsls	r1, r3, #31
 802244c:	bf44      	itt	mi
 802244e:	f043 0320 	orrmi.w	r3, r3, #32
 8022452:	6023      	strmi	r3, [r4, #0]
 8022454:	b91d      	cbnz	r5, 802245e <_printf_i+0x196>
 8022456:	6823      	ldr	r3, [r4, #0]
 8022458:	f023 0320 	bic.w	r3, r3, #32
 802245c:	6023      	str	r3, [r4, #0]
 802245e:	2310      	movs	r3, #16
 8022460:	e7b0      	b.n	80223c4 <_printf_i+0xfc>
 8022462:	6823      	ldr	r3, [r4, #0]
 8022464:	f043 0320 	orr.w	r3, r3, #32
 8022468:	6023      	str	r3, [r4, #0]
 802246a:	2378      	movs	r3, #120	; 0x78
 802246c:	4828      	ldr	r0, [pc, #160]	; (8022510 <_printf_i+0x248>)
 802246e:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8022472:	e7e3      	b.n	802243c <_printf_i+0x174>
 8022474:	065e      	lsls	r6, r3, #25
 8022476:	bf48      	it	mi
 8022478:	b2ad      	uxthmi	r5, r5
 802247a:	e7e6      	b.n	802244a <_printf_i+0x182>
 802247c:	4616      	mov	r6, r2
 802247e:	e7bb      	b.n	80223f8 <_printf_i+0x130>
 8022480:	680b      	ldr	r3, [r1, #0]
 8022482:	6826      	ldr	r6, [r4, #0]
 8022484:	6960      	ldr	r0, [r4, #20]
 8022486:	1d1d      	adds	r5, r3, #4
 8022488:	600d      	str	r5, [r1, #0]
 802248a:	0635      	lsls	r5, r6, #24
 802248c:	681b      	ldr	r3, [r3, #0]
 802248e:	d501      	bpl.n	8022494 <_printf_i+0x1cc>
 8022490:	6018      	str	r0, [r3, #0]
 8022492:	e002      	b.n	802249a <_printf_i+0x1d2>
 8022494:	0671      	lsls	r1, r6, #25
 8022496:	d5fb      	bpl.n	8022490 <_printf_i+0x1c8>
 8022498:	8018      	strh	r0, [r3, #0]
 802249a:	2300      	movs	r3, #0
 802249c:	6123      	str	r3, [r4, #16]
 802249e:	4616      	mov	r6, r2
 80224a0:	e7ba      	b.n	8022418 <_printf_i+0x150>
 80224a2:	680b      	ldr	r3, [r1, #0]
 80224a4:	1d1a      	adds	r2, r3, #4
 80224a6:	600a      	str	r2, [r1, #0]
 80224a8:	681e      	ldr	r6, [r3, #0]
 80224aa:	6862      	ldr	r2, [r4, #4]
 80224ac:	2100      	movs	r1, #0
 80224ae:	4630      	mov	r0, r6
 80224b0:	f7dd ff2e 	bl	8000310 <memchr>
 80224b4:	b108      	cbz	r0, 80224ba <_printf_i+0x1f2>
 80224b6:	1b80      	subs	r0, r0, r6
 80224b8:	6060      	str	r0, [r4, #4]
 80224ba:	6863      	ldr	r3, [r4, #4]
 80224bc:	6123      	str	r3, [r4, #16]
 80224be:	2300      	movs	r3, #0
 80224c0:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 80224c4:	e7a8      	b.n	8022418 <_printf_i+0x150>
 80224c6:	6923      	ldr	r3, [r4, #16]
 80224c8:	4632      	mov	r2, r6
 80224ca:	4649      	mov	r1, r9
 80224cc:	4640      	mov	r0, r8
 80224ce:	47d0      	blx	sl
 80224d0:	3001      	adds	r0, #1
 80224d2:	d0ab      	beq.n	802242c <_printf_i+0x164>
 80224d4:	6823      	ldr	r3, [r4, #0]
 80224d6:	079b      	lsls	r3, r3, #30
 80224d8:	d413      	bmi.n	8022502 <_printf_i+0x23a>
 80224da:	68e0      	ldr	r0, [r4, #12]
 80224dc:	9b03      	ldr	r3, [sp, #12]
 80224de:	4298      	cmp	r0, r3
 80224e0:	bfb8      	it	lt
 80224e2:	4618      	movlt	r0, r3
 80224e4:	e7a4      	b.n	8022430 <_printf_i+0x168>
 80224e6:	2301      	movs	r3, #1
 80224e8:	4632      	mov	r2, r6
 80224ea:	4649      	mov	r1, r9
 80224ec:	4640      	mov	r0, r8
 80224ee:	47d0      	blx	sl
 80224f0:	3001      	adds	r0, #1
 80224f2:	d09b      	beq.n	802242c <_printf_i+0x164>
 80224f4:	3501      	adds	r5, #1
 80224f6:	68e3      	ldr	r3, [r4, #12]
 80224f8:	9903      	ldr	r1, [sp, #12]
 80224fa:	1a5b      	subs	r3, r3, r1
 80224fc:	42ab      	cmp	r3, r5
 80224fe:	dcf2      	bgt.n	80224e6 <_printf_i+0x21e>
 8022500:	e7eb      	b.n	80224da <_printf_i+0x212>
 8022502:	2500      	movs	r5, #0
 8022504:	f104 0619 	add.w	r6, r4, #25
 8022508:	e7f5      	b.n	80224f6 <_printf_i+0x22e>
 802250a:	bf00      	nop
 802250c:	080d9e19 	.word	0x080d9e19
 8022510:	080d9e2a 	.word	0x080d9e2a

08022514 <memmove>:
 8022514:	4288      	cmp	r0, r1
 8022516:	b510      	push	{r4, lr}
 8022518:	eb01 0402 	add.w	r4, r1, r2
 802251c:	d902      	bls.n	8022524 <memmove+0x10>
 802251e:	4284      	cmp	r4, r0
 8022520:	4623      	mov	r3, r4
 8022522:	d807      	bhi.n	8022534 <memmove+0x20>
 8022524:	1e43      	subs	r3, r0, #1
 8022526:	42a1      	cmp	r1, r4
 8022528:	d008      	beq.n	802253c <memmove+0x28>
 802252a:	f811 2b01 	ldrb.w	r2, [r1], #1
 802252e:	f803 2f01 	strb.w	r2, [r3, #1]!
 8022532:	e7f8      	b.n	8022526 <memmove+0x12>
 8022534:	4402      	add	r2, r0
 8022536:	4601      	mov	r1, r0
 8022538:	428a      	cmp	r2, r1
 802253a:	d100      	bne.n	802253e <memmove+0x2a>
 802253c:	bd10      	pop	{r4, pc}
 802253e:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 8022542:	f802 4d01 	strb.w	r4, [r2, #-1]!
 8022546:	e7f7      	b.n	8022538 <memmove+0x24>

08022548 <_realloc_r>:
 8022548:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802254a:	4607      	mov	r7, r0
 802254c:	4614      	mov	r4, r2
 802254e:	460e      	mov	r6, r1
 8022550:	b921      	cbnz	r1, 802255c <_realloc_r+0x14>
 8022552:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8022556:	4611      	mov	r1, r2
 8022558:	f7ff bb94 	b.w	8021c84 <_malloc_r>
 802255c:	b922      	cbnz	r2, 8022568 <_realloc_r+0x20>
 802255e:	f7ff fc99 	bl	8021e94 <_free_r>
 8022562:	4625      	mov	r5, r4
 8022564:	4628      	mov	r0, r5
 8022566:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8022568:	f000 f814 	bl	8022594 <_malloc_usable_size_r>
 802256c:	42a0      	cmp	r0, r4
 802256e:	d20f      	bcs.n	8022590 <_realloc_r+0x48>
 8022570:	4621      	mov	r1, r4
 8022572:	4638      	mov	r0, r7
 8022574:	f7ff fb86 	bl	8021c84 <_malloc_r>
 8022578:	4605      	mov	r5, r0
 802257a:	2800      	cmp	r0, #0
 802257c:	d0f2      	beq.n	8022564 <_realloc_r+0x1c>
 802257e:	4631      	mov	r1, r6
 8022580:	4622      	mov	r2, r4
 8022582:	f7ff fb69 	bl	8021c58 <memcpy>
 8022586:	4631      	mov	r1, r6
 8022588:	4638      	mov	r0, r7
 802258a:	f7ff fc83 	bl	8021e94 <_free_r>
 802258e:	e7e9      	b.n	8022564 <_realloc_r+0x1c>
 8022590:	4635      	mov	r5, r6
 8022592:	e7e7      	b.n	8022564 <_realloc_r+0x1c>

08022594 <_malloc_usable_size_r>:
 8022594:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8022598:	1f18      	subs	r0, r3, #4
 802259a:	2b00      	cmp	r3, #0
 802259c:	bfbc      	itt	lt
 802259e:	580b      	ldrlt	r3, [r1, r0]
 80225a0:	18c0      	addlt	r0, r0, r3
 80225a2:	4770      	bx	lr

080225a4 <_init>:
 80225a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80225a6:	bf00      	nop
 80225a8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80225aa:	bc08      	pop	{r3}
 80225ac:	469e      	mov	lr, r3
 80225ae:	4770      	bx	lr

080225b0 <_fini>:
 80225b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80225b2:	bf00      	nop
 80225b4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80225b6:	bc08      	pop	{r3}
 80225b8:	469e      	mov	lr, r3
 80225ba:	4770      	bx	lr
